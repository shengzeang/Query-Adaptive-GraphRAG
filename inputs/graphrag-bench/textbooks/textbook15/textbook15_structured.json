[
    {
        "content": "## Introduction\n\nWhen you design and analyze algorithms, you need to be able to describe how they operate and how to design them. You also need some mathematical tools to show that your algorithms do the right thing and do it efficiently. This part will get you started. Later parts of this book will build upon this base.\n\nChapter 1 provides an overview of algorithms and their place in modern computing systems. This chapter defines what an algorithm is and lists some examples. It also makes a case for considering algorithms as a technology, alongside technologies such as fast hardware, graphical user interfaces, object-oriented systems, and networks.\n\nIn Chapter 2, we see our first algorithms, which solve the problem of sorting a sequence of \\(n\\) numbers. They are written in a pseudocode which, although not directly translatable to any conventional programming language, conveys the structure of the algorithm clearly enough that you should be able to implement it in the language of your choice. The sorting algorithms we examine are insertion sort, which uses an incremental approach, and merge sort, which uses a recursive technique known as \"divide-and-conquer.\" Although the time each requires increases with the value of \\(n\\), the rate of increase differs between the two algorithms. We determine these running times in Chapter 2, and we develop a useful \"asymptotic\" notation to express them.\n\nChapter 3 precisely defines asymptotic notation. We'll use asymptotic notation to bound the growth of functions--most often, functions that describe the running time of algorithms--from above and below. The chapter starts by informally defining the most commonly used asymptotic notations and giving an example of how to apply them. It then formally defines five asymptotic notations and presents conventions for how to put them together. The rest of Chapter 3 is primarily a presentation of mathematical notation, more to ensure that your use of notation matches that in this book than to teach you new mathematical concepts.\n\nChapter 4 delves further into the divide-and-conquer method introduced in Chapter 2. It provides two additional examples of divide-and-conquer algorithms for multiplying square matrices, including Strassen's surprising method. Chapter 4 contains methods for solving recurrences, which are useful for describing the running times of recursive algorithms. In the substitution method, you guess an answer and prove it correct. Recursion trees provide one way to generate a guess. Chapter 4 also presents the powerful technique of the \"master method,\" which you can often use to solve recurrences that arise from divide-and-conquer algorithms. Although the chapter provides a proof of a foundational theorem on which the master theorem depends, you should feel free to employ the master method without delving into the proof. Chapter 4 concludes with some advanced topics.\n\nChapter 5 introduces probabilistic analysis and randomized algorithms. You typically use probabilistic analysis to determine the running time of an algorithm in cases in which, due to the presence of an inherent probability distribution, the running time may differ on different inputs of the same size. In some cases, you might assume that the inputs conform to a known probability distribution, so that you are averaging the running time over all possible inputs. In other cases, the probability distribution comes not from the inputs but from random choices made during the course of the algorithm. An algorithm whose behavior is determined not only by its input but by the values produced by a random-number generator is a randomized algorithm. You can use randomized algorithms to enforce a probability distribution on the inputs -- thereby ensuring that no particular input always causes poor performance -- or even to bound the error rate of algorithms that are allowed to produce incorrect results on a limited basis.\n\nAppendices A-D contain other mathematical material that you will find helpful as you read this book. You might have seen much of the material in the appendix chapters before having read this book (although the specific definitions and notational conventions we use may differ in some cases from what you have seen in the past), and so you should think of the appendices as reference material. On the other hand, you probably have not already seen most of the material in Part I. All the chapters in Part I and the appendices are written with a tutorial flavor.\n\nThe Role of Algorithms in Computing\n\nWhat are algorithms? Why is the study of algorithms worthwhile? What is the role of algorithms relative to other technologies used in computers? This chapter will answer these questions.\n\n### Algorithms\n\nInformally, an _algorithm_ is any well-defined computational procedure that takes some value, or set of values, as _input_ and produces some value, or set of values, as _output_ in a finite amount of time. An algorithm is thus a sequence of computational steps that transform the input into the output.\n\nYou can also view an algorithm as a tool for solving a well-specified _computational problem_. The statement of the problem specifies in general terms the desired input/output relationship for problem instances, typically of arbitrarily large size. The algorithm describes a specific computational procedure for achieving that input/output relationship for all problem instances.\n\nAs an example, suppose that you need to sort a sequence of numbers into monotonically increasing order. This problem arises frequently in practice and provides fertile ground for introducing many standard design techniques and analysis tools. Here is how we formally define the _sorting problem_:\n\n**Input:**: A sequence of \\(n\\) numbers \\(\\langle a_{1},a_{2},\\ldots,a_{n}\\rangle\\).\n**Output:**: A permutation (reordering) \\(\\langle a^{\\prime}_{1},a^{\\prime}_{2},\\ldots,a^{\\prime}_{n}\\rangle\\) of the input sequence such that \\(a^{\\prime}_{1}\\leq a^{\\prime}_{2}\\leq\\cdots\\leq a^{\\prime}_{n}\\).\n\nThus, given the input sequence \\(\\langle 31,41,59,26,41,58\\rangle\\), a correct sorting algorithm returns as output the sequence \\(\\langle 26,31,41,41,58,59\\rangle\\). Such an input sequence is",
        "chapter": "Part I Foundations",
        "section": "Introduction",
        "subsection": "N/A",
        "subsubsection": "N/A"
    },
    {
        "content": "The Role of Algorithms in Computing\n\nWhat are algorithms? Why is the study of algorithms worthwhile? What is the role of algorithms relative to other technologies used in computers? This chapter will answer these questions.\n\n### Algorithms\n\nInformally, an _algorithm_ is any well-defined computational procedure that takes some value, or set of values, as _input_ and produces some value, or set of values, as _output_ in a finite amount of time. An algorithm is thus a sequence of computational steps that transform the input into the output.\n\nYou can also view an algorithm as a tool for solving a well-specified _computational problem_. The statement of the problem specifies in general terms the desired input/output relationship for problem instances, typically of arbitrarily large size. The algorithm describes a specific computational procedure for achieving that input/output relationship for all problem instances.\n\nAs an example, suppose that you need to sort a sequence of numbers into monotonically increasing order. This problem arises frequently in practice and provides fertile ground for introducing many standard design techniques and analysis tools. Here is how we formally define the _sorting problem_:\n\n**Input:**: A sequence of \\(n\\) numbers \\(\\langle a_{1},a_{2},\\ldots,a_{n}\\rangle\\).\n**Output:**: A permutation (reordering) \\(\\langle a^{\\prime}_{1},a^{\\prime}_{2},\\ldots,a^{\\prime}_{n}\\rangle\\) of the input sequence such that \\(a^{\\prime}_{1}\\leq a^{\\prime}_{2}\\leq\\cdots\\leq a^{\\prime}_{n}\\).\n\nThus, given the input sequence \\(\\langle 31,41,59,26,41,58\\rangle\\), a correct sorting algorithm returns as output the sequence \\(\\langle 26,31,41,41,58,59\\rangle\\). Such an input sequence is called an _instance_ of the sorting problem. In general, an _instance of a problem1_ consists of the input (satisfying whatever constraints are imposed in the problem statement) needed to compute a solution to the problem.\n\nFootnote 1: Sometimes, when the problem context is known, problem instances are themselves simply called \u201cproblems.\u201d\n\nBecause many programs use it as an intermediate step, sorting is a fundamental operation in computer science. As a result, you have a large number of good sorting algorithms at your disposal. Which algorithm is best for a given application depends on--among other factors--the number of items to be sorted, the extent to which the items are already somewhat sorted, possible restrictions on the item values, the architecture of the computer, and the kind of storage devices to be used: main memory, disks, or even--archaically--tapes.\n\nAn algorithm for a computational problem is _correct_ if, for every problem instance provided as input, it _halts--_finishes its computing in finite time--and outputs the correct solution to the problem instance. A correct algorithm _solves_ the given computational problem. An incorrect algorithm might not halt at all on some input instances, or it might halt with an incorrect answer. Contrary to what you might expect, incorrect algorithms can sometimes be useful, if you can control their error rate. We'll see an example of an algorithm with a controllable error rate in Chapter 31 when we study algorithms for finding large prime numbers. Ordinarily, however, we'll concern ourselves only with correct algorithms.\n\nAn algorithm can be specified in English, as a computer program, or even as a hardware design. The only requirement is that the specification must provide a precise description of the computational procedure to be followed.\n\n### What kinds of problems are solved by algorithms?\n\nSorting is by no means the only computational problem for which algorithms have been developed. (You probably suspected as much when you saw the size of this book.) Practical applications of algorithms are ubiquitous and include the following examples:\n\n* The Human Genome Project has made great progress toward the goals of identifying all the roughly 30,000 genes in human DNA, determining the sequences of the roughly 3 billion chemical base pairs that make up human DNA, storing this information in databases, and developing tools for data analysis. Each of these steps requires sophisticated algorithms. Although the solutions to the various problems involved are beyond the scope of this book, many methods to solve these biological problems use ideas presented here, enabling scientists to accomplish tasks while using resources efficiently. Dynamic programming, as in Chapter 14, is an important technique for solving several of these biological problems, particularly ones that involve determining similarity between DNA sequences. The savings realized are in time, both human and machine, and in money, as more information can be extracted by laboratory techniques.\n* The internet enables people all around the world to quickly access and retrieve large amounts of information. With the aid of clever algorithms, sites on the internet are able to manage and manipulate this large volume of data. Examples of problems that make essential use of algorithms include finding good routes on which the data travels (techniques for solving such problems appear in Chapter 22), and using a search engine to quickly find pages on which particular information resides (related techniques are in Chapters 11 and 32).\n* Electronic commerce enables goods and services to be negotiated and exchanged electronically, and it depends on the privacy of personal information such as credit card numbers, passwords, and bank statements. The core technologies used in electronic commerce include public-key cryptography and digital signatures (covered in Chapter 31), which are based on numerical algorithms and number theory.\n* Manufacturing and other commercial enterprises often need to allocate scarce resources in the most beneficial way. An oil company might wish to know where to place its wells in order to maximize its expected profit. A political candidate might want to determine where to spend money buying campaign advertising in order to maximize the chances of winning an election. An airline might wish to assign crews to flights in the least expensive way possible, making sure that each flight is covered and that government regulations regarding crew scheduling are met. An internet service provider might wish to determine where to place additional resources in order to serve its customers more effectively. All of these are examples of problems that can be solved by modeling them as linear programs, which Chapter 29 explores.\n\nAlthough some of the details of these examples are beyond the scope of this book, we do give underlying techniques that apply to these problems and problem areas. We also show how to solve many specific problems, including the following:\n\n* You have a road map on which the distance between each pair of adjacent intersections is marked, and you wish to determine the shortest route from one intersection to another. The number of possible routes can be huge, even if you disallow routes that cross over themselves. How can you choose which of all possible routes is the shortest? You can start by modeling the road map (which is itself a model of the actual roads) as a graph (which we will meet in Part VI and Appendix B). In this graph, you wish to find the shortest path from one vertex to another. Chapter 22 shows how to solve this problem efficiently.\n\nGiven a mechanical design in terms of a library of parts, where each part may include instances of other parts, list the parts in order so that each part appears before any part that uses it. If the design comprises \\(n\\) parts, then there are \\(n!\\) possible orders, where \\(n!\\) denotes the factorial function. Because the factorial function grows faster than even an exponential function, you cannot feasibly generate each possible order and then verify that, within that order, each part appears before the parts using it (unless you have only a few parts). This problem is an instance of topological sorting, and Chapter 20 shows how to solve this problem efficiently.\n* A doctor needs to determine whether an image represents a cancerous tumor or a benign one. The doctor has available images of many other tumors, some of which are known to be cancerous and some of which are known to be benign. A cancerous tumor is likely to be more similar to other cancerous tumors than to benign tumors, and a benign tumor is more likely to be similar to other benign tumors. By using a clustering algorithm, as in Chapter 33, the doctor can identify which outcome is more likely.\n* You need to compress a large file containing text so that it occupies less space. Many ways to do so are known, including \"LZW compression,\" which looks for repeating character sequences. Chapter 15 studies a different approach, \"Huffman coding,\" which encodes characters by bit sequences of various lengths, with characters occurring more frequently encoded by shorter bit sequences.\n\nThese lists are far from exhaustive (as you again have probably surmised from this book's heft), but they exhibit two characteristics common to many interesting algorithmic problems:\n\n1. They have many candidate solutions, the overwhelming majority of which do not solve the problem at hand. Finding one that does, or one that is \"best,\" without explicitly examining each possible solution, can present quite a challenge.\n2. They have practical applications. Of the problems in the above list, finding the shortest path provides the easiest examples. A transportation firm, such as a trucking or railroad company, has a financial interest in finding shortest paths through a road or rail network because taking shorter paths results in lower labor and fuel costs. Or a routing node on the internet might need to find the shortest path through the network in order to route a message quickly. Or a person wishing to drive from New York to Boston might want to find driving directions using a navigation app.\n\nNot every problem solved by algorithms has an easily identified set of candidate solutions. For example, given a set of numerical values representing samples of a signal taken at regular time intervals, the discrete Fourier transform convertsthe time domain to the frequency domain. That is, it approximates the signal as a weighted sum of sinusoids, producing the strength of various frequencies which, when summed, approximate the sampled signal. In addition to lying at the heart of signal processing, discrete Fourier transforms have applications in data compression and multiplying large polynomials and integers. Chapter 30 gives an efficient algorithm, the fast Fourier transform (commonly called the FFT), for this problem. The chapter also sketches out the design of a hardware FFT circuit.\n\n#### Data structures\n\nThis book also presents several data structures. A _data structure_ is a way to store and organize data in order to facilitate access and modifications. Using the appropriate data structure or structures is an important part of algorithm design. No single data structure works well for all purposes, and so you should know the strengths and limitations of several of them.\n\n#### Technique\n\nAlthough you can use this book as a \"cookbook\" for algorithms, you might someday encounter a problem for which you cannot readily find a published algorithm (many of the exercises and problems in this book, for example). This book will teach you techniques of algorithm design and analysis so that you can develop algorithms on your own, show that they give the correct answer, and analyze their efficiency. Different chapters address different aspects of algorithmic problem solving. Some chapters address specific problems, such as finding medians and order statistics in Chapter 9, computing minimum spanning trees in Chapter 21, and determining a maximum flow in a network in Chapter 24. Other chapters introduce techniques, such as divide-and-conquer in Chapters 2 and 4, dynamic programming in Chapter 14, and amortized analysis in Chapter 16.\n\n#### Hard problems\n\nMost of this book is about efficient algorithms. Our usual measure of efficiency is speed: how long does an algorithm take to produce its result? There are some problems, however, for which we know of no algorithm that runs in a reasonable amount of time. Chapter 34 studies an interesting subset of these problems, which are known as NP-complete.\n\nWhy are NP-complete problems interesting? First, although no efficient algorithm for an NP-complete problem has ever been found, nobody has ever proven that an efficient algorithm for one cannot exist. In other words, no one knows whether efficient algorithms exist for NP-complete problems. Second, the set of NP-complete problems has the remarkable property that if an efficient algorithm exists for any one of them, then efficient algorithms exist for all of them. This relationship among the NP-complete problems makes the lack of efficient solutions all the more tantalizing. Third, several NP-complete problems are similar, but not identical, to problems for which we do know of efficient algorithms. Computer scientists are intrigued by how a small change to the problem statement can cause a big change to the efficiency of the best known algorithm.\n\nYou should know about NP-complete problems because some of them arise surprisingly often in real applications. If you are called upon to produce an efficient algorithm for an NP-complete problem, you are likely to spend a lot of time in a fruitless search. If, instead, you can show that the problem is NP-complete, you can spend your time developing an efficient approximation algorithm, that is, an algorithm that gives a good, but not necessarily the best possible, solution.\n\nAs a concrete example, consider a delivery company with a central depot. Each day, it loads up delivery trucks at the depot and sends them around to deliver goods to several addresses. At the end of the day, each truck must end up back at the depot so that it is ready to be loaded for the next day. To reduce costs, the company wants to select an order of delivery stops that yields the lowest overall distance traveled by each truck. This problem is the well-known \"traveling-salesperson problem,\" and it is NP-complete.2 It has no known efficient algorithm. Under certain assumptions, however, we know of efficient algorithms that compute overall distances close to the smallest possible. Chapter 35 discusses such \"approximation algorithms.\"\n\nFootnote 2: To be precise, only decision problems\u2014those with a \u201cyes/no\u201d answer\u2014can be NP-complete. The decision version of the traveling salesperson problem asks whether there exists an order of stops whose distance totals at most a given amount.\n\n#### Alternative computing models\n\nFor many years, we could count on processor clock speeds increasing at a steady rate. Physical limitations present a fundamental roadblock to ever-increasing clock speeds, however: because power density increases superlinearly with clock speed, chips run the risk of melting once their clock speeds become high enough. In order to perform more computations per second, therefore, chips are being designed to contain not just one but several processing \"cores.\" We can liken these multi-core computers to several sequential computers on a single chip. In other words, they are a type of \"parallel computer.\" In order to elicit the best performance from multicore computers, we need to design algorithms with parallelism in mind. Chapter 26 presents a model for \"task-parallel\" algorithms, which take advantage of multiple processing cores. This model has advantages from both theoretical and practical standpoints, and many modern parallel-programming platforms embrace something similar to this model of parallelism.\n\nMost of the examples in this book assume that all of the input data are available when an algorithm begins running. Much of the work in algorithm design makes the same assumption. For many important real-world examples, however, the input actually arrives over time, and the algorithm must decide how to proceed without knowing what data will arrive in the future. In a data center, jobs are constantly arriving and departing, and a scheduling algorithm must decide when and where to run a job, without knowing what jobs will be arriving in the future. Traffic must be routed in the internet based on the current state, without knowing about where traffic will arrive in the future. Hospital emergency rooms make triage decisions about which patients to treat first without knowing when other patients will be arriving in the future and what treatments they will need. Algorithms that receive their input over time, rather than having all the input present at the start, are _online algorithms_, which Chapter 27 examines.\n\n#### Exercises\n\n_1.1-1_\n\nDescribe your own real-world example that requires sorting. Describe one that requires finding the shortest distance between two points.\n\n_1.1-2_\n\nOther than speed, what other measures of efficiency might you need to consider in a real-world setting?\n\n_1.1-3_\n\nSelect a data structure that you have seen, and discuss its strengths and limitations.\n\n_1.1-4_\n\nHow are the shortest-path and traveling-salesperson problems given above similar? How are they different?\n\n_1.1-5_\n\nSuggest a real-world problem in which only the best solution will do. Then come up with one in which \"approximately\" the best solution is good enough.\n\n_1.1-6_\n\nDescribe a real-world problem in which sometimes the entire input is available before you need to solve the problem, but other times the input is not entirely available in advance and arrives over time.\n\n### 1.2 Algorithms as a technology\n\nIf computers were infinitely fast and computer memory were free, would you have any reason to study algorithms? The answer is yes, if for no other reason than that you would still like to be certain that your solution method terminates and does so with the correct answer.\n\nIf computers were infinitely fast, any correct method for solving a problem would do. You would probably want your implementation to be within the bounds of good software engineering practice (for example, your implementation should be well designed and documented), but you would most often use whichever method was the easiest to implement.\n\nOf course, computers may be fast, but they are not infinitely fast. Computing time is therefore a bounded resource, which makes it precious. Although the saying goes, \"Time is money,\" time is even more valuable than money: you can get back money after you spend it, but once time is spent, you can never get it back. Memory may be inexpensive, but it is neither infinite nor free. You should choose algorithms that use the resources of time and space efficiently.\n\n#### Efficiency\n\nDifferent algorithms devised to solve the same problem often differ dramatically in their efficiency. These differences can be much more significant than differences due to hardware and software.\n\nAs an example, Chapter 2 introduces two algorithms for sorting. The first, known as _insertion sort_, takes time roughly equal to \\(c_{1}n^{2}\\) to sort \\(n\\) items, where \\(c_{1}\\) is a constant that does not depend on \\(n\\). That is, it takes time roughly proportional to \\(n^{2}\\). The second, _merge sort_, takes time roughly equal to \\(c_{2}n\\lg n\\), where \\(\\lg n\\) stands for \\(\\log_{2}n\\) and \\(c_{2}\\) is another constant that also does not depend on \\(n\\). Insertion sort typically has a smaller constant factor than merge sort, so that \\(c_{1}<c_{2}\\). We'll see that the constant factors can have far less of an impact on the running time than the dependence on the input size \\(n\\). Let's write insertion sort's running time as \\(c_{1}n\\cdot n\\) and merge sort's running time as \\(c_{2}n\\cdot\\lg n\\). Then we see that where insertion sort has a factor of \\(n\\) in its running time, merge sort has a factor of \\(\\lg n\\), which is much smaller. For example, when \\(n\\) is \\(1000,\\lg n\\) is approximately 10, and when \\(n\\) is \\(1,\\!000,\\!000,\\lg n\\) is approximately only 20. Although insertion sort usually runs faster than merge sort for small input sizes, once the input size \\(n\\) becomes large enough, merge sort's advantage of \\(\\lg n\\) versus \\(n\\) more than compensates for the difference in constant factors. No matter how much smaller \\(c_{1}\\) is than \\(c_{2}\\), there is always a crossover point beyond which merge sort is faster.",
        "chapter": "Part I Foundations",
        "section": "1 The Role of Algorithms in Computing",
        "subsection": "1.1 Algorithms",
        "subsubsection": "N/A"
    },
    {
        "content": "### 1.2 Algorithms as a technology\n\nIf computers were infinitely fast and computer memory were free, would you have any reason to study algorithms? The answer is yes, if for no other reason than that you would still like to be certain that your solution method terminates and does so with the correct answer.\n\nIf computers were infinitely fast, any correct method for solving a problem would do. You would probably want your implementation to be within the bounds of good software engineering practice (for example, your implementation should be well designed and documented), but you would most often use whichever method was the easiest to implement.\n\nOf course, computers may be fast, but they are not infinitely fast. Computing time is therefore a bounded resource, which makes it precious. Although the saying goes, \"Time is money,\" time is even more valuable than money: you can get back money after you spend it, but once time is spent, you can never get it back. Memory may be inexpensive, but it is neither infinite nor free. You should choose algorithms that use the resources of time and space efficiently.\n\n#### Efficiency\n\nDifferent algorithms devised to solve the same problem often differ dramatically in their efficiency. These differences can be much more significant than differences due to hardware and software.\n\nAs an example, Chapter 2 introduces two algorithms for sorting. The first, known as _insertion sort_, takes time roughly equal to \\(c_{1}n^{2}\\) to sort \\(n\\) items, where \\(c_{1}\\) is a constant that does not depend on \\(n\\). That is, it takes time roughly proportional to \\(n^{2}\\). The second, _merge sort_, takes time roughly equal to \\(c_{2}n\\lg n\\), where \\(\\lg n\\) stands for \\(\\log_{2}n\\) and \\(c_{2}\\) is another constant that also does not depend on \\(n\\). Insertion sort typically has a smaller constant factor than merge sort, so that \\(c_{1}<c_{2}\\). We'll see that the constant factors can have far less of an impact on the running time than the dependence on the input size \\(n\\). Let's write insertion sort's running time as \\(c_{1}n\\cdot n\\) and merge sort's running time as \\(c_{2}n\\cdot\\lg n\\). Then we see that where insertion sort has a factor of \\(n\\) in its running time, merge sort has a factor of \\(\\lg n\\), which is much smaller. For example, when \\(n\\) is \\(1000,\\lg n\\) is approximately 10, and when \\(n\\) is \\(1,\\!000,\\!000,\\lg n\\) is approximately only 20. Although insertion sort usually runs faster than merge sort for small input sizes, once the input size \\(n\\) becomes large enough, merge sort's advantage of \\(\\lg n\\) versus \\(n\\) more than compensates for the difference in constant factors. No matter how much smaller \\(c_{1}\\) is than \\(c_{2}\\), there is always a crossover point beyond which merge sort is faster.\n\n### Algorithms as a technology\n\nFor a concrete example, let us pit a faster computer (computer A) running insertion sort against a slower computer (computer B) running merge sort. They each must sort an array of 10 million numbers. (Although 10 million numbers might seem like a lot, if the numbers are eight-byte integers, then the input occupies about 80 megabytes, which fits in the memory of even an inexpensive laptop computer many times over.) Suppose that computer A executes 10 billion instructions per second (faster than any single sequential computer at the time of this writing) and computer B executes only 10 million instructions per second (much slower than most contemporary computers), so that computer A is 1000 times faster than computer B in raw computing power. To make the difference even more dramatic, suppose that the world's craftiest programmer codes insertion sort in machine language for computer A, and the resulting code requires \\(2n^{2}\\) instructions to sort \\(n\\) numbers. Suppose further that just an average programmer implements merge sort, using a high-level language with an inefficient compiler, with the resulting code taking \\(50\\,n\\lg n\\) instructions. To sort 10 million numbers, computer A takes\n\n\\(2\\cdot(10^{7})^{2}\\) instructions \\(10^{10}\\) instructions/second = 20,000 seconds (more than 5.5 hours),\n\nwhile computer B takes\n\n\\(50\\cdot 10^{7}\\lg 10^{7}\\) instructions \\(10^{7}\\) instructions/second \\(\\approx\\) 1163 seconds (under 20 minutes).\n\nBy using an algorithm whose running time grows more slowly, even with a poor compiler, computer B runs more than 17 times faster than computer A! The advantage of merge sort is even more pronounced when sorting 100 million numbers: where insertion sort takes more than 23 days, merge sort takes under four hours. Although 100 million might seem like a large number, there are more than 100 million web searches every half hour, more than 100 million emails sent every minute, and some of the smallest galaxies (known as ultra-compact dwarf galaxies) contain about 100 million stars. In general, as the problem size increases, so does the relative advantage of merge sort.\n\n### Algorithms and other technologies\n\nThe example above shows that you should consider algorithms, like computer hardware, as a _technology_. Total system performance depends on choosing efficient algorithms as much as on choosing fast hardware. Just as rapid advances are being made in other computer technologies, they are being made in algorithms as well.\n\nYou might wonder whether algorithms are truly that important on contemporary computers in light of other advanced technologies, such as* advanced computer architectures and fabrication technologies,\n* easy-to-use, intuitive, graphical user interfaces (GUIs),\n* object-oriented systems,\n* integrated web technologies,\n* fast networking, both wired and wireless,\n* machine learning,\n* and mobile devices.\n\nThe answer is yes. Although some applications do not explicitly require algorithmic content at the application level (such as some simple, web-based applications), many do. For example, consider a web-based service that determines how to travel from one location to another. Its implementation would rely on fast hardware, a graphical user interface, wide-area networking, and also possibly on object orientation. It would also require algorithms for operations such as finding routes (probably using a shortest-path algorithm), rendering maps, and interpolating addresses.\n\nMoreover, even an application that does not require algorithmic content at the application level relies heavily upon algorithms. Does the application rely on fast hardware? The hardware design used algorithms. Does the application rely on graphical user interfaces? The design of any GUI relies on algorithms. Does the application rely on networking? Routing in networks relies heavily on algorithms. Was the application written in a language other than machine code? Then it was processed by a compiler, interpreter, or assembler, all of which make extensive use of algorithms. Algorithms are at the core of most technologies used in contemporary computers.\n\nMachine learning can be thought of as a method for performing algorithmic tasks without explicitly designing an algorithm, but instead inferring patterns from data and thereby automatically learning a solution. At first glance, machine learning, which automates the process of algorithmic design, may seem to make learning about algorithms obsolete. The opposite is true, however. Machine learning is itself a collection of algorithms, just under a different name. Furthermore, it currently seems that the successes of machine learning are mainly for problems for which we, as humans, do not really understand what the right algorithm is. Prominent examples include computer vision and automatic language translation. For algorithmic problems that humans understand well, such as most of the problems in this book, efficient algorithms designed to solve a specific problem are typically more successful than machine-learning approaches.\n\nData science is an interdisciplinary field with the goal of extracting knowledge and insights from structured and unstructured data. Data science uses methodsfrom statistics, computer science, and optimization. The design and analysis of algorithms is fundamental to the field. The core techniques of data science, which overlap significantly with those in machine learning, include many of the algorithms in this book.\n\nFurthermore, with the ever-increasing capacities of computers, we use them to solve larger problems than ever before. As we saw in the above comparison between insertion sort and merge sort, it is at larger problem sizes that the differences in efficiency between algorithms become particularly prominent.\n\nHaving a solid base of algorithmic knowledge and technique is one characteristic that defines the truly skilled programmer. With modern computing technology, you can accomplish some tasks without knowing much about algorithms, but with a good background in algorithms, you can do much, much more.\n\n### Exercises\n\n#### 1.2-1\n\nGive an example of an application that requires algorithmic content at the application level, and discuss the function of the algorithms involved.\n\n#### 1.2-2\n\nSuppose that for inputs of size \\(n\\) on a particular computer, insertion sort runs in \\(8n^{2}\\) steps and merge sort runs in \\(64\\,n\\lg n\\) steps. For which values of \\(n\\) does insertion sort beat merge sort?\n\n#### 1.2-3\n\nWhat is the smallest value of \\(n\\) such that an algorithm whose running time is \\(100n^{2}\\) runs faster than an algorithm whose running time is \\(2^{n}\\) on the same machine?\n\n## Problems\n\n#### 1-1 Comparison of running times\n\nFor each function \\(f(n)\\) and time \\(t\\) in the following table, determine the largest size \\(n\\) of a problem that can be solved in time \\(t\\), assuming that the algorithm to solve the problem takes \\(f(n)\\) microseconds.",
        "chapter": "Part I Foundations",
        "section": "1 The Role of Algorithms in Computing",
        "subsection": "1.2 Algorithms as a technology",
        "subsubsection": "N/A"
    },
    {
        "content": "from statistics, computer science, and optimization. The design and analysis of algorithms is fundamental to the field. The core techniques of data science, which overlap significantly with those in machine learning, include many of the algorithms in this book.\n\nFurthermore, with the ever-increasing capacities of computers, we use them to solve larger problems than ever before. As we saw in the above comparison between insertion sort and merge sort, it is at larger problem sizes that the differences in efficiency between algorithms become particularly prominent.\n\nHaving a solid base of algorithmic knowledge and technique is one characteristic that defines the truly skilled programmer. With modern computing technology, you can accomplish some tasks without knowing much about algorithms, but with a good background in algorithms, you can do much, much more.\n\n### Exercises\n\n#### 1.2-1\n\nGive an example of an application that requires algorithmic content at the application level, and discuss the function of the algorithms involved.\n\n#### 1.2-2\n\nSuppose that for inputs of size \\(n\\) on a particular computer, insertion sort runs in \\(8n^{2}\\) steps and merge sort runs in \\(64\\,n\\lg n\\) steps. For which values of \\(n\\) does insertion sort beat merge sort?\n\n#### 1.2-3\n\nWhat is the smallest value of \\(n\\) such that an algorithm whose running time is \\(100n^{2}\\) runs faster than an algorithm whose running time is \\(2^{n}\\) on the same machine?\n\n## Problems\n\n#### 1-1 Comparison of running times\n\nFor each function \\(f(n)\\) and time \\(t\\) in the following table, determine the largest size \\(n\\) of a problem that can be solved in time \\(t\\), assuming that the algorithm to solve the problem takes \\(f(n)\\) microseconds.\n\n## Chapter 1 The Role of Algorithms in Computing\n\nThere are many excellent texts on the general topic of algorithms, including those by Aho, Hopcroft, and Ullman [5, 6], Dasgupta, Papadimitriou, and Vazirani [107], Edmonds [133], Erickson [135], Goodrich and Tamassia [195, 196], Kleinberg and Tardos [257], Knuth [259, 260, 261, 262, 263], Levitin [298], Louridas [305], Mehlhorn and Sanders [325], Mitzenmacher and Upfal [331], Neapolitan [342], Roughgarden [385, 386, 387, 388], Sanders, Mehlhorn, Dietzfelbinger, and Dementiev [393], Sedgewick and Wayne [402], Skiena [414], Soltys-Kulinicz [419], Wilf [455], and Williamson and Shmoys [459]. Some of the more practical aspects of algorithm design are discussed by Bentley [49, 50, 51], Bhargava [54], Kochenderfer and Wheeler [268], and McGeoch [321]. Surveys of the field of algorithms can also be found in books by Atallah and Blanton [27, 28] and Mehta and Sahhi [326]. For less technical material, see the books by Christian and Griffiths [92], Cormen [104], Erwig [136], MacCormick [307], and Vocking et al. [448]. Overviews of the algorithms used in computational biology can be found in books by Jones and Pevzner [240], Elloumi and Zomaya [134], and Marchisio [315].",
        "chapter": "Part I Foundations",
        "section": "1 The Role of Algorithms in Computing",
        "subsection": "Problems",
        "subsubsection": "N/A"
    },
    {
        "content": "## Chapter 1 The Role of Algorithms in Computing\n\nThere are many excellent texts on the general topic of algorithms, including those by Aho, Hopcroft, and Ullman [5, 6], Dasgupta, Papadimitriou, and Vazirani [107], Edmonds [133], Erickson [135], Goodrich and Tamassia [195, 196], Kleinberg and Tardos [257], Knuth [259, 260, 261, 262, 263], Levitin [298], Louridas [305], Mehlhorn and Sanders [325], Mitzenmacher and Upfal [331], Neapolitan [342], Roughgarden [385, 386, 387, 388], Sanders, Mehlhorn, Dietzfelbinger, and Dementiev [393], Sedgewick and Wayne [402], Skiena [414], Soltys-Kulinicz [419], Wilf [455], and Williamson and Shmoys [459]. Some of the more practical aspects of algorithm design are discussed by Bentley [49, 50, 51], Bhargava [54], Kochenderfer and Wheeler [268], and McGeoch [321]. Surveys of the field of algorithms can also be found in books by Atallah and Blanton [27, 28] and Mehta and Sahhi [326]. For less technical material, see the books by Christian and Griffiths [92], Cormen [104], Erwig [136], MacCormick [307], and Vocking et al. [448]. Overviews of the algorithms used in computational biology can be found in books by Jones and Pevzner [240], Elloumi and Zomaya [134], and Marchisio [315].\n\n## Chapter Getting Started\n\nThis chapter will familiarize you with the framework we'll use throughout the book to think about the design and analysis of algorithms. It is self-contained, but it does include several references to material that will be introduced in Chapters 3 and 4. (It also contains several summations, which Appendix A shows how to solve.)\n\nWe'll begin by examining the insertion sort algorithm to solve the sorting problem introduced in Chapter 1. We'll specify algorithms using a pseudocode that should be understandable to you if you have done computer programming. We'll see why insertion sort correctly sorts and analyze its running time. The analysis introduces a notation that describes how running time increases with the number of items to be sorted. Following a discussion of insertion sort, we'll use a method called divide-and-conquer to develop a sorting algorithm called merge sort. We'll end with an analysis of merge sort's running time.\n\n### Insertion sort\n\nOur first algorithm, insertion sort, solves the _sorting problem_ introduced in Chapter 1:\n\n**Input:**: A sequence of \\(n\\) numbers \\(\\langle a_{1},a_{2},\\ldots,a_{n}\\rangle\\).\n**Output:**: A permutation (reordering) \\(\\langle a^{\\prime}_{1},a^{\\prime}_{2},\\ldots,a^{\\prime}_{n}\\rangle\\) of the input sequence such that \\(a^{\\prime}_{1}\\leq a^{\\prime}_{2}\\leq\\cdots\\leq a^{\\prime}_{n}\\).\n\nThe numbers to be sorted are also known as the _keys_. Although the problem is conceptually about sorting a sequence, the input comes in the form of an array with \\(n\\) elements. When we want to sort numbers, it's often because they are the keys associated with other data, which we call _satellite data_. Together, a key and satellite data form a _record_. For example, consider a spreadsheet containing student records with many associated pieces of data such as age, grade-point average, and number of courses taken. Any one of these quantities could be a key, but when the",
        "chapter": "Part I Foundations",
        "section": "1 The Role of Algorithms in Computing",
        "subsection": "Chapter notes",
        "subsubsection": "N/A"
    },
    {
        "content": "## Chapter Getting Started\n\nThis chapter will familiarize you with the framework we'll use throughout the book to think about the design and analysis of algorithms. It is self-contained, but it does include several references to material that will be introduced in Chapters 3 and 4. (It also contains several summations, which Appendix A shows how to solve.)\n\nWe'll begin by examining the insertion sort algorithm to solve the sorting problem introduced in Chapter 1. We'll specify algorithms using a pseudocode that should be understandable to you if you have done computer programming. We'll see why insertion sort correctly sorts and analyze its running time. The analysis introduces a notation that describes how running time increases with the number of items to be sorted. Following a discussion of insertion sort, we'll use a method called divide-and-conquer to develop a sorting algorithm called merge sort. We'll end with an analysis of merge sort's running time.\n\n### Insertion sort\n\nOur first algorithm, insertion sort, solves the _sorting problem_ introduced in Chapter 1:\n\n**Input:**: A sequence of \\(n\\) numbers \\(\\langle a_{1},a_{2},\\ldots,a_{n}\\rangle\\).\n**Output:**: A permutation (reordering) \\(\\langle a^{\\prime}_{1},a^{\\prime}_{2},\\ldots,a^{\\prime}_{n}\\rangle\\) of the input sequence such that \\(a^{\\prime}_{1}\\leq a^{\\prime}_{2}\\leq\\cdots\\leq a^{\\prime}_{n}\\).\n\nThe numbers to be sorted are also known as the _keys_. Although the problem is conceptually about sorting a sequence, the input comes in the form of an array with \\(n\\) elements. When we want to sort numbers, it's often because they are the keys associated with other data, which we call _satellite data_. Together, a key and satellite data form a _record_. For example, consider a spreadsheet containing student records with many associated pieces of data such as age, grade-point average, and number of courses taken. Any one of these quantities could be a key, but when thespreadsheet sorts, it moves the associated record (the satellite data) with the key. When describing a sorting algorithm, we focus on the keys, but it is important to remember that there usually is associated satellite data.\n\nIn this book, we'll typically describe algorithms as procedures written in a _pseudocode_ that is similar in many respects to C, C++, Java, Python,1 or JavaScript. (Apologies if we've omitted your favorite programming language. We can't list them all.) If you have been introduced to any of these languages, you should have little trouble understanding algorithms \"coded\" in pseudocode. What separates pseudocode from real code is that in pseudocode, we employ whatever expressive method is most clear and concise to specify a given algorithm. Sometimes the clearest method is English, so do not be surprised if you come across an English phrase or sentence embedded within a section that looks more like real code. Another difference between pseudocode and real code is that pseudocode often ignores aspects of software engineering -- such as data abstraction, modularity, and error handling -- in order to convey the essence of the algorithm more concisely.\n\nFootnote 1: If you\u2019re familiar with only Python, you can think of arrays as similar to Python lists.\n\nWe start with _insertion sort_, which is an efficient algorithm for sorting a small number of elements. Insertion sort works the way you might sort a hand of playing cards. Start with an empty left hand and the cards in a pile on the table. Pick up the first card in the pile and hold it with your left hand. Then, with your right hand, remove one card at a time from the pile, and insert it into the correct position in your left hand. As Figure 2.1 illustrates, you find the correct position for a card by comparing it with each of the cards already in your left hand, starting at the right and moving left. As soon as you see a card in your left hand whose value is less than or equal to the card you're holding in your right hand, insert the card that you're holding in your right hand just to the right of this card in your left hand. If all the cards in your left hand have values greater than the card in your right hand, then place this card as the leftmost card in your left hand. At all times, the cards held in your left hand are sorted, and these cards were originally the top cards of the pile on the table.\n\nThe pseudocode for insertion sort is given as the procedure Insertion-Sort on the facing page. It takes two parameters: an array \\(A\\) containing the values to be sorted and the number \\(n\\) of values of sort. The values occupy positions \\(A[1]\\) through \\(A[n]\\) of the array, which we denote by \\(A[1\\!:\\!n]\\). When the Insertion-Sort procedure is finished, array \\(A[1\\!:\\!n]\\) contains the original values, but in sorted order.\n\n### Insertion-Sort(\\(A,n\\))\n\n```\n1for\\(i\\ =\\ 2\\)to\\(n\\)\n2key\\(=\\ A[i]\\)\n3//Insert\\(A[i]\\) into the sorted subarray\\(A[1:i-1]\\).\n4\\(j\\ =\\ i-1\\)\n5while\\(j\\ >\\ 0\\) and \\(A[j]>\\)key\n6\\(A[j+1]\\ =\\ A[j]\\)\n7\\(j\\ =\\ j-1\\)\n8\\(A[j+1]\\ =\\)key\n```\n\nListing 1: Sorting a hand of cards using insertion sort.\n\n#### 2.1.1 Loop invariants and the correctness of insertion sort\n\nFigure 2.2 shows how this algorithm works for an array \\(A\\) that starts out with the sequence \\(\\langle 5,\\ 2,\\ 4,\\ 6,\\ 1,\\ 3\\rangle\\). The index \\(i\\) indicates the \"current card\" being inserted into the hand. At the beginning of each iteration of the **for** loop, which is indexed by \\(i\\), the _subarray_ (a contiguous portion of the array) consisting of elements \\(A[1:i-1]\\) (that is, \\(A[1]\\) through \\(A[i-1]\\)) constitutes the currently sorted hand, and the remaining subarray \\(A[i\\ +1:n]\\) (elements \\(A[i+1]\\) through \\(A[n]\\)) corresponds to the pile of cards still on the table. In fact, elements \\(A[1:i-1]\\) are the elements _originally_ in positions \\(1\\) through \\(i-1\\), but now in sorted order. We state these properties of \\(A[1:i-1]\\) formally as a _loop invariant_:\n\nFigure 2.1: Sorting a hand of cards using insertion sort.\n\nAt the start of each iteration of the **for** loop of lines 1-8, the subarray \\(A[1:i-1]\\) consists of the elements originally in \\(A[1:i-1]\\), but in sorted order.\n\nLoop invariants help us understand why an algorithm is correct. When you're using a loop invariant, you need to show three things:\n\n**Initialization:**: It is true prior to the first iteration of the loop.\n**Maintenance:**: If it is true before an iteration of the loop, it remains true before the next iteration.\n**Termination:**: The loop terminates, and when it terminates, the invariant -- usually along with the reason that the loop terminated -- gives us a useful property that helps show that the algorithm is correct.\n\nWhen the first two properties hold, the loop invariant is true prior to every iteration of the loop. (Of course, you are free to use established facts other than the loop invariant itself to prove that the loop invariant remains true before each iteration.) A loop-invariant proof is a form of mathematical induction, where to prove that a property holds, you prove a base case and an inductive step. Here, showing that the invariant holds before the first iteration corresponds to the base case, and showing that the invariant holds from iteration to iteration corresponds to the inductive step.\n\nThe third property is perhaps the most important one, since you are using the loop invariant to show correctness. Typically, you use the loop invariant along with the condition that caused the loop to terminate. Mathematical induction typically applies the inductive step infinitely, but in a loop invariant the \"induction\" stops when the loop terminates.\n\nFigure 2.2: The operation of Insertion-Sort\\((A,n)\\), where \\(A\\) initially contains the sequence \\(\\langle 5,2,4,6,1,3\\rangle\\) and \\(n=6\\). Array indices appear above the rectangles, and values stored in the array positions appear within the rectangles. **(a)\u2013(e)** The iterations of the **for** loop of lines 1\u20138. In each iteration, the blue rectangle holds the key taken from \\(A[i]\\), which is compared with the values in tan rectangles to its left in the test of line 5. Orange arrows show array values moved one position to the right in line 6, and blue arrows indicate where the key moves to in line 8. **(f)** The final sorted array.\n\n### Insertion sort\n\nLet's see how these properties hold for insertion sort.\n\n**Initialization:**: We start by showing that the loop invariant holds before the first loop iteration, when \\(i=2\\).2 The subarray \\(A[1\\!:\\!i-1]\\) consists of just the single element \\(A[1]\\), which is in fact the original element in \\(A[1]\\). Moreover, this subarray is sorted (after all, how could a subarray with just one value not be sorted?), which shows that the loop invariant holds prior to the first iteration of the loop.\n**Maintenance:**: Next, we tackle the second property: showing that each iteration maintains the loop invariant. Informally, the body of the **for** loop works by moving the values in \\(A[i-1]\\), \\(A[i-2]\\), \\(A[i-3]\\), and so on by one position to the right until it finds the proper position for \\(A[i]\\) (lines 4-7), at which point it inserts the value of \\(A[i]\\) (line 8). The subarray \\(A[1\\!:\\!i]\\) then consists of the elements originally in \\(A[1\\!:\\!i]\\), but in sorted order. _Incrementing_\\(i\\) (increasing its value by 1) for the next iteration of the **for** loop then preserves the loop invariant.\n\nFootnote 2: When the loop is a **for** loop, the loop-invariant check just prior to the first iteration occurs immediately after the initial assignment to the loop-counter variable and just before the first test in the loop header. In the case of Insertion-Sort, this time is after assigning 2 to the variable \\(i\\) but before the first test of whether \\(i\\leq n\\).\n\nA more formal treatment of the second property would require us to state and show a loop invariant for the **while** loop of lines 5-7. Let's not get bogged down in such formalism just yet. Instead, we'll rely on our informal analysis to show that the second property holds for the outer loop.\n**Termination:**: Finally, we examine loop termination. The loop variable \\(i\\) starts at 2 and increases by 1 in each iteration. Once \\(i\\)'s value exceeds \\(n\\) in line 1, the loop terminates once \\(i\\) equals \\(n+1\\). Substituting \\(n+1\\) for \\(i\\) in the wording of the loop invariant yields that the subarray \\(A[1\\!:\\!n]\\) consists of the elements originally in \\(A[1\\!:\\!n]\\), but in sorted order. Hence, the algorithm is correct.\n\nThis method of loop invariants is used to show correctness in various places throughout this book.\n\n#### Pseudocode conventions\n\nWe use the following conventions in our pseudocode.\n\n* Indentation indicates block structure. For example, the body of the **for** loop that begins on line 1 consists of lines 2-8, and the body of the **while** loop thatbegins on line 5 contains lines 6-7 but not line 8. Our indentation style applies to **if**-**else** statements3 as well. Using indentation instead of textual indicators of block structure, such as **begin** and **end** statements or curly braces, reduces clutter while preserving, or even enhancing, clarity.4 Footnote 3: In an **if**-**else** statement, we indent **else** at the same level as its matching **if**. The first executable line of an **else** clause appears on the same line as the keyword **else**. For multiway tests, we use **elseif** for tests after the first one. When it is the first line in an **else** clause, an **if** statement appears on the line following **else** so that you do not misconstrute it as **elseif**.\n* The looping constructs **while**, **for**, and **repeat**-**until** and the **if**-**else** conditional construct have interpretations similar to those in C, C++, Java, Python, and JavaScript.5 In this book, the loop counter retains its value after the loop is exited, unlike some situations that arise in C++ and Java. Thus, immediately after a **for** loop, the loop counter's value is the value that first exceeded the **for** loop bound.6 We used this property in our correctness argument for insertion sort. The **for** loop header in line 1 is **for**\\(i=2\\)**to**\\(n\\), and so when this loop terminates, \\(i\\) equals \\(n+1\\). We use the keyword **to** when a **for** loop increments its loop counter in each iteration, and we use the keyword **downto** when a **for** loop _decrements_ its loop counter (reduces its value by 1 in each iteration). When the loop counter changes by an amount greater than 1, the amount of change follows the optional keyword **by**. Footnote 3: In an **if**-**else** statement, we indent **else** at the same level as its matching **if**. The first executable line of an **else** clause appears on the same line as the keyword **else**. For multiway tests, we use **elseif** for tests after the first one. When it is the first line in an **else** clause, an **if** statement appears on the line following **else** so that you do not misconstrute it as **elseif**.\n* The symbol \"_/_/_\" indicates that the remainder of the line is a comment.\n* Variables (such as \\(i\\), \\(j\\), and _key_) are local to the given procedure. We won't use global variables without explicit indication.\n* We access array elements by specifying the array name followed by the index in square brackets. For example, \\(A[i]\\) indicates the \\(i\\)th element of the array \\(A\\). Although many programming languages enforce 0-origin indexing for arrays (0 is the smallest valid index), we choose whichever indexing scheme is clearest for human readers to understand. Because people usually start counting at 1, not 0, most -- but not all -- of the arrays in this book use 1-origin indexing. To be clear about whether a particular algorithm assumes 0-origin or 1-origin indexing, we'll specify the bounds of the arrays explicitly. If you are implementing an algorithm that we specify using 1-origin indexing, but you're writing in a programming language that enforces 0-origin indexing (such as C, C++, Java, Python, or JavaScript), then give yourself credit for being able to adjust. You can either always subtract 1 from each index or allocate each array with one extra position and just ignore position 0. The notation \":\" denotes a subarray. Thus, \\(A[i:j]\\) indicates the subarray of \\(A\\) consisting of the elements \\(A[i]\\), \\(A[i+1]\\), \\(\\ldots\\), \\(A[j]\\).7 We also use this notation to indicate the bounds of an array, as we did earlier when discussing the array \\(A[1:n]\\). Footnote 7: If you\u2019re used to programming in Python, bear in mind that in this book, the subarray \\(A[i:j]\\) includes the element \\(A[j]\\). In Python, the last element of \\(A[i:j]\\) is \\(A[j-1]\\). Python allows negative indices, which count from the back end of the list. This book does not use negative array indices.\n* We typically organize compound data into _objects_, which are composed of _attributes_. We access a particular attribute using the syntax found in many object-oriented programming languages: the object name, followed by a dot, followed by the attribute name. For example, if an object \\(x\\) has attribute \\(f\\), we denote this attribute by \\(x.f\\). We treat a variable representing an array or object as a pointer (known as a reference in some programming languages) to the data representing the array or object. For all attributes \\(f\\) of an object \\(x\\), setting \\(y=x\\) causes \\(y.f\\) to equal \\(x.f\\). Moreover, if we now set \\(x.f=3\\), then afterward not only does \\(x.f\\) equal 3, but \\(y.f\\) equals 3 as well. In other words, \\(x\\) and \\(y\\) point to the same object after the assignment \\(y=x\\). This way of treating arrays and objects is consistent with most contemporary programming languages. Our attribute notation can \"cascade.\" For example, suppose that the attribute \\(f\\) is itself a pointer to some type of object that has an attribute \\(g\\). Then the notation \\(x.f.g\\) is implicitly parenthesized as \\((x.f).g\\). In other words, if we had assigned \\(y=x.f\\), then \\(x.f.g\\) is the same as \\(y.g\\). Sometimes a pointer refers to no object at all. In this case, we give it the special value nil.\n* We pass parameters to a procedure _by value_: the called procedure receives its own copy of the parameters, and if it assigns a value to a parameter, the change is _not_ seen by the calling procedure. When objects are passed, the pointer to the data representing the object is copied, but the object's attributes are not. For example, if \\(x\\) is a parameter of a called procedure, the assignment \\(x=y\\) within the called procedure is not visible to the calling procedure. The assignment \\(x.f=3\\), however, is visible if the calling procedure has a pointer to the same object as \\(x\\). Similarly, arrays are passed by pointer, so that a pointer to the array is passed, rather than the entire array, and changes to individual array elements are visible to the calling procedure. Again, most contemporary programming languages work this way.\n* A **return** statement immediately transfers control back to the point of call in the calling procedure. Most **return** statements also take a value to pass back to the caller. Our pseudocode differs from many programming languages in that we allow multiple values to be returned in a single **return** statement without having to create objects to package them together.8 Footnote 8: Python\u2019s tuple notation allows **return** statements to return multiple values without creating objects from a programmer-defined class.\n* The boolean operators \"and\" and \"or\" are _short circuiting_. That is, evaluate the expression \"\\(x\\) and \\(y\\)\" by first evaluating \\(x\\). If \\(x\\) evaluates to false, then the entire expression cannot evaluate to true, and therefore \\(y\\) is not evaluated. If, on the other hand, \\(x\\) evaluates to true, \\(y\\) must be evaluated to determine the value of the entire expression. Similarly, in the expression \"\\(x\\) or \\(y\\)\" the expression \\(y\\) is evaluated only if \\(x\\) evaluates to false. Short-circuiting operators allow us to write boolean expressions such as \"\\(x\\neq\\textsc{nil}\\) and \\(x.f=y\\)\" without worrying about what happens upon evaluating \\(x.f\\) when \\(x\\) is nil.\n* The keyword **error** indicates that an error occurred because conditions were wrong for the procedure to have been called, and the procedure immediately terminates. The calling procedure is responsible for handling the error, and so we do not specify what action to take.\n\n##### Exercises\n\n##### 2.1-1\n\nUsing Figure 2.2 as a model, illustrate the operation of Insertion-Sort on an array initially containing the sequence \\(\\langle 31,41,59,26,41,58\\rangle\\).\n\n##### 2.1-2\n\nConsider the procedure Sum-Array on the facing page. It computes the sum of the \\(n\\) numbers in array \\(A[1:n]\\). State a loop invariant for this procedure, and use its initialization, maintenance, and termination properties to show that the Sum-Array procedure returns the sum of the numbers in \\(A[1:n]\\).\n\n### Analyzing algorithms\n\n#### Analyzing\n\nan algorithm has come to mean predicting the resources that the algorithm requires. You might consider resources such as memory, communication bandwidth, or energy consumption. Most often, however, you'll want to measure computational time. If you analyze several candidate algorithms for a problem,",
        "chapter": "Part I Foundations",
        "section": "2 Getting Started",
        "subsection": "2.1 Insertion sort",
        "subsubsection": "N/A"
    },
    {
        "content": "### Analyzing algorithms\n\n#### Analyzing\n\nan algorithm has come to mean predicting the resources that the algorithm requires. You might consider resources such as memory, communication bandwidth, or energy consumption. Most often, however, you'll want to measure computational time. If you analyze several candidate algorithms for a problem,you can identify the most efficient one. There might be more than just one viable candidate, but you can often rule out several inferior algorithms in the process.\n\nBefore you can analyze an algorithm, you need a model of the technology that it runs on, including the resources of that technology and a way to express their costs. Most of this book assumes a generic one-processor, _random-access machine (RAM)_ model of computation as the implementation technology, with the understanding that algorithms are implemented as computer programs. In the RAM model, instructions execute one after another, with no concurrent operations. The RAM model assumes that each instruction takes the same amount of time as any other instruction and that each data access -- using the value of a variable or storing into a variable -- takes the same amount of time as any other data access. In other words, in the RAM model each instruction or data access takes a constant amount of time -- even indexing into an array.9\n\nFootnote 9: We assume that each element of a given array occupies the same number of bytes and that the elements of a given array are stored in contiguous memory locations. For example, if array \\(A[1\\!:\\!n]\\) starts at memory address \\(1000\\) and each element occupies four bytes, then element \\(A[i]\\) is at address \\(1000+4(i-1)\\). In general, computing the address in memory of a particular array element requires at most one subtraction (no subtraction for a 0-origin array), one multiplication (often implemented as a shift operation if the element size is an exact power of 2), and one addition. Furthermore, for code that iterates through the elements of an array in order, an optimizing compiler can generate the address of each element using just one addition, by adding the element size to the address of the preceding element.\n\nStrictly speaking, we should precisely define the instructions of the RAM model and their costs. To do so, however, would be tedious and yield little insight into algorithm design and analysis. Yet we must be careful not to abuse the RAM model. For example, what if a RAM had an instruction that sorts? Then you could sort in just one step. Such a RAM would be unrealistic, since such instructions do not appear in real computers. Our guide, therefore, is how real computers are designed. The RAM model contains instructions commonly found in real computers: arithmetic (such as add, subtract, multiply, divide, remainder, floor, ceiling), data movement (load, store, copy), and control (conditional and unconditional branch, subroutine call and return).\n\nThe data types in the RAM model are integer, floating point (for storing real-number approximations), and character. Real computers do not usually have a separate data type for the boolean values true and false. Instead, they often test whether an integer value is 0 (false) or nonzero (true), as in C. Although we typically do not concern ourselves with precision for floating-point values in this book (many numbers cannot be represented exactly in floating point), precision is crucial for most applications. We also assume that each word of data has a limit on the number of bits. For example, when working with inputs of size \\(n\\), we typically assume that integers are represented by \\(c\\log_{2}n\\) bits for some constant \\(c\\geq 1\\). We require \\(c\\geq 1\\) so that each word can hold the value of \\(n\\), enabling us to index the individual input elements, and we restrict \\(c\\) to be a constant so that the word size does not grow arbitrarily. (If the word size could grow arbitrarily, we could store huge amounts of data in one word and operate on it all in constant time -- an unrealistic scenario.)\n\nReal computers contain instructions not listed above, and such instructions represent a gray area in the RAM model. For example, is exponentiation a constant-time instruction? In the general case, no: to compute \\(x^{n}\\) when \\(x\\) and \\(n\\) are general integers typically takes time logarithmic in \\(n\\) (see equation (31.34) on page 31.3), and you must worry about whether the result fits into a computer word. If \\(n\\) is an exact power of 2, however, exponentiation can usually be viewed as a constant-time operation. Many computers have a \"shift left\" instruction, which in constant time shifts the bits of an integer by \\(n\\) positions to the left. In most computers, shifting the bits of an integer by 1 position to the left is equivalent to multiplying by 2, so that shifting the bits by \\(n\\) positions to the left is equivalent to multiplying by \\(2^{n}\\). Therefore, such computers can compute \\(2^{n}\\) in 1 constant-time instruction by shifting the integer 1 by \\(n\\) positions to the left, as long as \\(n\\) is no more than the number of bits in a computer word. We'll try to avoid such gray areas in the RAM model and treat computing \\(2^{n}\\) and multiplying by \\(2^{n}\\) as constant-time operations when the result is small enough to fit in a computer word.\n\nThe RAM model does not account for the memory hierarchy that is common in contemporary computers. It models neither caches nor virtual memory. Several other computational models attempt to account for memory-hierarchy effects, which are sometimes significant in real programs on real machines. Section 11.5 and a handful of problems in this book examine memory-hierarchy effects, but for the most part, the analyses in this book do not consider them. Models that include the memory hierarchy are quite a bit more complex than the RAM model, and so they can be difficult to work with. Moreover, RAM-model analyses are usually excellent predictors of performance on actual machines.\n\nAlthough it is often straightforward to analyze an algorithm in the RAM model, sometimes it can be quite a challenge. You might need to employ mathematical tools such as combinatorics, probability theory, algebraic dexterity, and the ability to identify the most significant terms in a formula. Because an algorithm might behave differently for each possible input, we need a means for summarizing that behavior in simple, easily understood formulas.\n\n#### Analysis of insertion sort\n\nHow long does the Insertion-Sort procedure take? One way to tell would be for you to run it on your computer and time how long it takes to run. Of course, you'dfirst have to implement it in a real programming language, since you cannot run our pseudocode directly. What would such a timing test tell you? You would find out how long insertion sort takes to run on your particular computer, on that particular input, under the particular implementation that you created, with the particular compiler or interpreter that you ran, with the particular libraries that you linked in, and with the particular background tasks that were running on your computer concurrently with your timing test (such as checking for incoming information over a network). If you run insertion sort again on your computer with the same input, you might even get a different timing result. From running just one implementation of insertion sort on just one computer and on just one input, what would you be able to determine about insertion sort's running time if you were to give it a different input, if you were to run it on a different computer, or if you were to implement it in a different programming language? Not much. We need a way to predict, given a new input, how long insertion sort will take.\n\nInstead of timing a run, or even several runs, of insertion sort, we can determine how long it takes by analyzing the algorithm itself. We'll examine how many times it executes each line of pseudocode and how long each line of pseudocode takes to run. We'll first come up with a precise but complicated formula for the running time. Then, we'll distill the important part of the formula using a convenient notation that can help us compare the running times of different algorithms for the same problem.\n\nHow do we analyze insertion sort? First, let's acknowledge that the running time depends on the input. You shouldn't be terribly surprised that sorting a thousand numbers takes longer than sorting three numbers. Moreover, insertion sort can take different amounts of time to sort two input arrays of the same size, depending on how nearly sorted they already are. Even though the running time can depend on many features of the input, we'll focus on the one that has been shown to have the greatest effect, namely the size of the input, and describe the running time of a program as a function of the size of its input. To do so, we need to define the terms \"running time\" and \"input size\" more carefully. We also need to be clear about whether we are discussing the running time for an input that elicits the worst-case behavior, the best-case behavior, or some other case.\n\nThe best notion for _input size_ depends on the problem being studied. For many problems, such as sorting or computing discrete Fourier transforms, the most natural measure is the _number of items in the input--_for example, the number \\(n\\) of items being sorted. For many other problems, such as multiplying two integers, the best measure of input size is the _total number of bits_ needed to represent the input in ordinary binary notation. Sometimes it is more appropriate to describe the size of the input with more than just one number. For example, if the input to an algorithm is a graph, we usually characterize the input size by both the number of vertices and the number of edges in the graph. We'll indicate which input size measure is being used with each problem we study.\n\nThe _running time_ of an algorithm on a particular input is the number of instructions and data accesses executed. How we account for these costs should be independent of any particular computer, but within the framework of the RAM model. For the moment, let us adopt the following view. A constant amount of time is required to execute each line of our pseudocode. One line might take more or less time than another line, but we'll assume that each execution of the \\(k\\)th line takes \\(c_{k}\\) time, where \\(c_{k}\\) is a constant. This viewpoint is in keeping with the RAM model, and it also reflects how the pseudocode would be implemented on most actual computers.10\n\nFootnote 10: There are some subtleties here. Computational steps that we specify in English are often variants of a procedure that requires more than just a constant amount of time. For example, in the R adixSort procedure on page 213, one line reads \u201cuse a stable sort to sort array \\(A\\) on digit \\(i\\),\u201d which, as we shall see, takes more than a constant amount of time. Also, although a statement that calls a subroutine takes only constant time, the subroutine itself, once invoked, may take more. That is, we separate the process of _calling_ the subroutine\\(-\\)passing parameters to it, etc.\\(-\\)from the process of _executing_ the subroutine.\n\nLet's analyze the Insertion-Sort procedure. As promised, we'll start by devising a precise formula that uses the input size and all the statement costs \\(c_{k}\\). This formula turns out to be messy, however. We'll then switch to a simpler notation that is more concise and easier to use. This simpler notation makes clear how to compare the running times of algorithms, especially as the size of the input increases.\n\nTo analyze the Insertion-Sort procedure, let's view it on the following page with the time cost of each statement and the number of times each statement is executed. For each \\(i=2,3,\\ldots,n\\), let \\(t_{i}\\) denote the number of times the **while** loop test in line 5 is executed for that value of \\(i\\). When a **for** or **while** loop exits in the usual way\\(-\\)because the test in the loop header comes up false\\(-\\)the test is executed one time more than the loop body. Because comments are not executable statements, assume that they take no time.\n\nThe running time of the algorithm is the sum of running times for each statement executed. A statement that takes \\(c_{k}\\) steps to execute and executes \\(m\\) times contributes \\(c_{k}m\\) to the total running time.11 We usually denote the running time of an algorithm on an input of size \\(n\\) by \\(T(n)\\). To compute \\(T(n)\\), the running time of Insertion-Sort on an input of \\(n\\) values, we sum the products of the _cost_ and _times_ columns, obtaining\n\nFootnote 11: This characteristic does not necessarily hold for a resource such as memory. A statement that references \\(m\\) words of memory and is executed \\(n\\) times does not necessarily reference \\(mn\\) distinct words of memory.\n\n\\[T(n) = c_{1}n+c_{2}(n-1)+c_{4}(n-1)+c_{5}\\sum_{i=2}^{n}t_{i}+c_{6}\\sum_{i=2 }^{n}(t_{i}-1)\\] \\[+c_{7}\\sum_{i=2}^{n}(t_{i}-1)+c_{8}(n-1)\\.\\]\n\nEven for inputs of a given size, an algorithm's running time may depend on _which_ input of that size is given. For example, in Insertion-Sort, the best case occurs when the array is already sorted. In this case, each time that line 5 executes, the value of _key_--the value originally in \\(A[i]\\)--is already greater than or equal to all values in \\(A[1:i-1]\\), so that the **while** loop of lines 5-7 always exits upon the first test in line 5. Therefore, we have that \\(t_{i}=1\\) for \\(i=2,3,\\ldots,n\\), and the best-case running time is given by\n\n\\[T(n) = c_{1}n+c_{2}(n-1)+c_{4}(n-1)+c_{5}(n-1)+c_{8}(n-1) \\tag{2.1}\\] \\[= (c_{1}+c_{2}+c_{4}+c_{5}+c_{8})n-(c_{2}+c_{4}+c_{5}+c_{8})\\.\\]\n\nWe can express this running time as \\(an+b\\) for _constants_\\(a\\) and \\(b\\) that depend on the statement costs \\(c_{k}\\) (where \\(a=c_{1}+c_{2}+c_{4}+c_{5}+c_{8}\\) and \\(b=c_{2}+c_{4}+c_{5}+c_{8}\\)). The running time is thus a _linear function_ of \\(n\\).\n\nThe worst case arises when the array is in reverse sorted order--that is, it starts out in decreasing order. The procedure must compare each element \\(A[i]\\) with each element in the entire sorted subarray \\(A[1:i-1]\\), and so \\(t_{i}=i\\) for \\(i=2,3,\\ldots,n\\). (The procedure finds that \\(A[j]>\\)_key_ every time in line 5, and the **while** loop exits only when \\(j\\) reaches 0.) Noting that\n\n\\[\\sum_{i=2}^{n}i = \\left(\\sum_{i=1}^{n}i\\right)-1\\] \\[= \\frac{n(n+1)}{2}-1\\quad\\mbox{(by equation (A.2) on page 1141)}\\]and\n\n\\[\\sum_{i\\,=\\,2}^{n}(i\\,-\\,1) \\,=\\,\\sum_{i\\,=\\,1}^{n-1}i\\] \\[\\,=\\,\\frac{n(n-1)}{2}\\quad\\mbox{(again, by equation (A.2)) }\\,,\\]\n\nwe find that in the worst case, the running time of Insertion-Sort is\n\n\\[T(n) \\,=\\,c_{1}n+c_{2}(n-1)+c_{4}(n-1)+c_{5}\\left(\\frac{n(n+1)}{2}-1\\right)\\] \\[\\qquad+c_{6}\\left(\\frac{n(n-1)}{2}\\right)+c_{7}\\left(\\frac{n(n-1) }{2}\\right)+c_{8}(n-1)\\] \\[\\,=\\,\\left(\\frac{c_{5}}{2}\\,+\\frac{c_{6}}{2}\\,+\\frac{c_{7}}{2} \\right)n^{2}+\\left(c_{1}+c_{2}+c_{4}+\\frac{c_{5}}{2}-\\frac{c_{6}}{2}-\\frac{c_ {7}}{2}\\,+c_{8}\\right)n\\] \\[\\qquad-(c_{2}+c_{4}+c_{5}+c_{8})\\;. \\tag{2.2}\\]\n\nWe can express this worst-case running time as \\(an^{2}\\,+\\,bn\\,+\\,c\\) for constants \\(a\\,,\\,b\\,,\\) and \\(c\\) that again depend on the statement costs \\(c_{k}\\) (now, \\(a=c_{5}/2+c_{6}/2+c_{7}/2\\), \\(b=c_{1}+c_{2}+c_{4}+c_{5}/2-c_{6}/2-c_{7}/2+c_{8}\\), and \\(c=-(c_{2}+c_{4}+c_{5}+c_{8})\\)). The running time is thus a _quadratic function_ of \\(n\\).\n\nTypically, as in insertion sort, the running time of an algorithm is fixed for a given input, although we'll also see some interesting \"randomized\" algorithms whose behavior can vary even for a fixed input.\n\n#### Worst-case and average-case analysis\n\nOur analysis of insertion sort looked at both the best case, in which the input array was already sorted, and the worst case, in which the input array was reverse sorted. For the remainder of this book, though, we'll usually (but not always) concentrate on finding only the _worst-case running time_, that is, the longest running time for _any_ input of size \\(n\\). Why? Here are three reasons:\n\n* The worst-case running time of an algorithm gives an upper bound on the running time for _any_ input. If you know it, then you have a guarantee that the algorithm never takes any longer. You need not make some educated guess about the running time and hope that it never gets much worse. This feature is especially important for real-time computing, in which operations must complete by a deadline.\n* For some algorithms, the worst case occurs fairly often. For example, in searching a database for a particular piece of information, the searching algorithm's worst case often occurs when the information is not present in the database. In some applications, searches for absent information may be frequent.\n\n* The \"average case\" is often roughly as bad as the worst case. Suppose that you run insertion sort on an array of \\(n\\) randomly chosen numbers. How long does it take to determine where in subarray \\(A[1:i-1]\\) to insert element \\(A[i]\\)? On average, half the elements in \\(A[1:i-1]\\) are less than \\(A[i]\\), and half the elements are greater. On average, therefore, \\(A[i]\\) is compared with just half of the subarray \\(A[1:i-1]\\), and so \\(t_{i}\\) is about \\(i/2\\). The resulting average-case running time turns out to be a quadratic function of the input size, just like the worst-case running time.\n\nIn some particular cases, we'll be interested in the _average-case_ running time of an algorithm. We'll see the technique of _probabilistic analysis_ applied to various algorithms throughout this book. The scope of average-case analysis is limited, because it may not be apparent what constitutes an \"average\" input for a particular problem. Often, we'll assume that all inputs of a given size are equally likely. In practice, this assumption may be violated, but we can sometimes use a _randomized algorithm_, which makes random choices, to allow a probabilistic analysis and yield an _expected_ running time. We explore randomized algorithms more in Chapter 5 and in several other subsequent chapters.\n\n### Order of growth\n\nIn order to ease our analysis of the Insertion-Sort procedure, we used some simplifying abstractions. First, we ignored the actual cost of each statement, using the constants \\(c_{k}\\) to represent these costs. Still, the best-case and worst-case running times in equations (2.1) and (2.2) are rather unwieldy. The constants in these expressions give us more detail than we really need. That's why we also expressed the best-case running time as \\(an+b\\) for constants \\(a\\) and \\(b\\) that depend on the statement costs \\(c_{k}\\) and why we expressed the worst-case running time as \\(an^{2}+bn+c\\) for constants \\(a\\), \\(b\\), and \\(c\\) that depend on the statement costs. We thus ignored not only the actual statement costs, but also the abstract costs \\(c_{k}\\).\n\nLet's now make one more simplifying abstraction: it is the _rate of growth_, or _order of growth_, of the running time that really interests us. We therefore consider only the leading term of a formula (e.g., \\(an^{2}\\)), since the lower-order terms are relatively insignificant for large values of \\(n\\). We also ignore the leading term's constant coefficient, since constant factors are less significant than the rate of growth in determining computational efficiency for large inputs. For insertion sort's worst-case running time, when we ignore the lower-order terms and the leading term's constant coefficient, only the factor of \\(n^{2}\\) from the leading term remains. That factor, \\(n^{2}\\), is by far the most important part of the running time. For example, suppose that an algorithm implemented on a particular machine takes \\(n^{2}/100+100n+17\\) microseconds on an input of size \\(n\\). Although the coefficients of \\(1/100\\) for the \\(n^{2}\\) term and \\(100\\) for the \\(n\\) term differ by four orders of magnitude, the \\(n^{2}/100\\) term dominates the \\(100n\\) term once \\(n\\) exceeds 10,000. Although 10,000 might seem large, it is smaller than the population of an average town. Many real-world problems have much larger input sizes.\n\nTo highlight the order of growth of the running time, we have a special notation that uses the Greek letter \\(\\Theta\\) (theta). We write that insertion sort has a worst-case running time of \\(\\Theta(n^{2})\\) (pronounced \"theta of \\(n\\)-squared\" or just \"theta \\(n\\)-squared\"). We also write that insertion sort has a best-case running time of \\(\\Theta(n)\\) (\"theta of \\(n\\)\" or \"theta \\(n\\)\"). For now, think of \\(\\Theta\\)-notation as saying \"roughly proportional when \\(n\\) is large,\" so that \\(\\Theta(n^{2})\\) means \"roughly proportional to \\(n^{2}\\) when \\(n\\) is large\" and \\(\\Theta(n)\\) means \"roughly proportional to \\(n\\) when \\(n\\) is large\" We'll use \\(\\Theta\\)-notation informally in this chapter and define it precisely in Chapter 3.\n\nWe usually consider one algorithm to be more efficient than another if its worst-case running time has a lower order of growth. Due to constant factors and lower-order terms, an algorithm whose running time has a higher order of growth might take less time for small inputs than an algorithm whose running time has a lower order of growth. But on large enough inputs, an algorithm whose worst-case running time is \\(\\Theta(n^{2})\\), for example, takes less time in the worst case than an algorithm whose worst-case running time is \\(\\Theta(n^{3})\\). Regardless of the constants hidden by the \\(\\Theta\\)-notation, there is always some number, say \\(n_{0}\\), such that for all input sizes \\(n\\geq n_{0}\\), the \\(\\Theta(n^{2})\\) algorithm beats the \\(\\Theta(n^{3})\\) algorithm in the worst case.\n\nExercises\n\n#### 2.2-1\n\nExpress the function \\(n^{3}/1000\\,+\\,100n^{2}\\,-\\,100n\\,+\\,3\\) in terms of \\(\\Theta\\)-notation.\n\n#### 2.2-2\n\nConsider sorting \\(n\\) numbers stored in array \\(A[1\\!:\\!n]\\) by first finding the smallest element of \\(A[1\\!:\\!n]\\) and exchanging it with the element in \\(A[1]\\). Then find the smallest element of \\(A[2\\!:\\!n]\\), and exchange it with \\(A[2]\\). Then find the smallest element of \\(A[3\\!:\\!n]\\), and exchange it with \\(A[3]\\). Continue in this manner for the first \\(n-1\\) elements of \\(A\\). Write pseudocode for this algorithm, which is known as _selection sort_. What loop invariant does this algorithm maintain? Why does it need to run for only the first \\(n-1\\) elements, rather than for all \\(n\\) elements? Give the worst-case running time of selection sort in \\(\\Theta\\)-notation. Is the best-case running time any better?\n\n#### 2.2-3\n\nConsider linear search again (see Exercise 2.1-4). How many elements of the input array need to be checked on the average, assuming that the element being searched for is equally likely to be any element in the array? How about in the worst case?Using \\(\\Theta\\)-notation, give the average-case and worst-case running times of linear search. Justify your answers.\n\n#### 2.2-4\n\nHow can you modify any sorting algorithm to have a good best-case running time?\n\n### 2.3 Designing algorithms\n\nYou can choose from a wide range of algorithm design techniques. Insertion sort uses the _incremental_ method: for each element \\(A[i]\\), insert it into its proper place in the subarray \\(A[1:i]\\), having already sorted the subarray \\(A[1:i-1]\\).\n\nThis section examines another design method, known as \"divide-and-conquer,\" which we explore in more detail in Chapter 4. We'll use divide-and-conquer to design a sorting algorithm whose worst-case running time is much less than that of insertion sort. One advantage of using an algorithm that follows the divide-and-conquer method is that analyzing its running time is often straightforward, using techniques that we'll explore in Chapter 4.\n\n#### The divide-and-conquer method\n\nMany useful algorithms are _recursive_ in structure: to solve a given problem, they _recurse_ (call themselves) one or more times to handle closely related subproblems. These algorithms typically follow the _divide-and-conquer_ method: they break the problem into several subproblems that are similar to the original problem but smaller in size, solve the subproblems recursively, and then combine these solutions to create a solution to the original problem.\n\nIn the divide-and-conquer method, if the problem is small enough--the _base case_--you just solve it directly without recursing. Otherwise--the _recursive case_--you perform three characteristic steps:\n\n**Divide** the problem into one or more subproblems that are smaller instances of the same problem.\n\n**Conquer** the subproblems by solving them recursively.\n\n**Combine** the subproblem solutions to form a solution to the original problem.\n\nThe _merge sort_ algorithm closely follows the divide-and-conquer method. In each step, it sorts a subarray \\(A[p:r]\\), starting with the entire array \\(A[1:n]\\) and recursing down to smaller and smaller subarrays. Here is how merge sort operates:",
        "chapter": "Part I Foundations",
        "section": "2 Getting Started",
        "subsection": "2.2 Analyzing algorithms",
        "subsubsection": "N/A"
    },
    {
        "content": "Using \\(\\Theta\\)-notation, give the average-case and worst-case running times of linear search. Justify your answers.\n\n#### 2.2-4\n\nHow can you modify any sorting algorithm to have a good best-case running time?\n\n### 2.3 Designing algorithms\n\nYou can choose from a wide range of algorithm design techniques. Insertion sort uses the _incremental_ method: for each element \\(A[i]\\), insert it into its proper place in the subarray \\(A[1:i]\\), having already sorted the subarray \\(A[1:i-1]\\).\n\nThis section examines another design method, known as \"divide-and-conquer,\" which we explore in more detail in Chapter 4. We'll use divide-and-conquer to design a sorting algorithm whose worst-case running time is much less than that of insertion sort. One advantage of using an algorithm that follows the divide-and-conquer method is that analyzing its running time is often straightforward, using techniques that we'll explore in Chapter 4.\n\n#### The divide-and-conquer method\n\nMany useful algorithms are _recursive_ in structure: to solve a given problem, they _recurse_ (call themselves) one or more times to handle closely related subproblems. These algorithms typically follow the _divide-and-conquer_ method: they break the problem into several subproblems that are similar to the original problem but smaller in size, solve the subproblems recursively, and then combine these solutions to create a solution to the original problem.\n\nIn the divide-and-conquer method, if the problem is small enough--the _base case_--you just solve it directly without recursing. Otherwise--the _recursive case_--you perform three characteristic steps:\n\n**Divide** the problem into one or more subproblems that are smaller instances of the same problem.\n\n**Conquer** the subproblems by solving them recursively.\n\n**Combine** the subproblem solutions to form a solution to the original problem.\n\nThe _merge sort_ algorithm closely follows the divide-and-conquer method. In each step, it sorts a subarray \\(A[p:r]\\), starting with the entire array \\(A[1:n]\\) and recursing down to smaller and smaller subarrays. Here is how merge sort operates:\n\n### Designing algorithms\n\n**Divide** the subarray \\(A[p:r]\\) to be sorted into two adjacent subarrays, each of half the size. To do so, compute the midpoint \\(q\\) of \\(A[p:r]\\) (taking the average of \\(p\\) and \\(r\\)), and divide \\(A[p:r]\\) into subarrays \\(A[p:q]\\) and \\(A[q+1:r]\\).\n**Conquer**: by sorting each of the two subarrays \\(A[p:q]\\) and \\(A[q+1:r]\\) recursively using merge sort.\n**Combine**: by merging the two sorted subarrays \\(A[p:q]\\) and \\(A[q+1:r]\\) back into \\(A[p:r]\\), producing the sorted answer.\n\nThe recursion \"bottoms out\"--it reaches the base case--when the subarray \\(A[p:r]\\) to be sorted has just 1 element, that is, when \\(p\\) equals \\(r\\). As we noted in the initialization argument for Insertion-Sort's loop invariant, a subarray comprising just a single element is always sorted.\n\nThe key operation of the merge sort algorithm occurs in the \"combine\" step, which merges two adjacent, sorted subarrays. The merge operation is performed by the auxiliary procedure Merge(\\(A\\), \\(p,q,r\\)) on the following page, where \\(A\\) is an array and \\(p\\), \\(q\\), and \\(r\\) are indices into the array such that \\(p\\leq q<r\\). The procedure assumes that the adjacent subarrays \\(A[p:q]\\) and \\(A[q+1:r]\\) were already recursively sorted. It _merges_ the two sorted subarrays to form a single sorted subarray that replaces the current subarray \\(A[p:r]\\).\n\nTo understand how the Merge procedure works, let's return to our card-playing motif. Suppose that you have two piles of cards face up on a table. Each pile is sorted, with the smallest-value cards on top. You wish to merge the two piles into a single sorted output pile, which is to be face down on the table. The basic step consists of choosing the smaller of the two cards on top of the face-up piles, removing it from its pile--which exposes a new top card--and placing this card face down onto the output pile. Repeat this step until one input pile is empty, at which time you can just take the remaining input pile and flip over the entire pile, placing it face down onto the output pile.\n\nLet's think about how long it takes to merge two sorted piles of cards. Each basic step takes constant time, since you are comparing just the two top cards. If the two sorted piles that you start with each have \\(n/2\\) cards, then the number of basic steps is at least \\(n/2\\) (since in whichever pile was emptied, every card was found to be smaller than some card from the other pile) and at most \\(n\\) (actually, at most \\(n-1\\), since after \\(n-1\\) basic steps, one of the piles must be empty). With each basic step taking constant time and the total number of basic steps being between \\(n/2\\) and \\(n\\), we can say that merging takes time roughly proportional to \\(n\\). That is, merging takes \\(\\Theta(n)\\) time.\n\nIn detail, the Merge procedure works as follows. It copies the two subarrays \\(A[p:q]\\) and \\(A[q+1:r]\\) into temporary arrays \\(L\\) and \\(R\\) (\"left\" and \"right\"), and then it merges the values in \\(L\\) and \\(R\\) back into \\(A[p:r]\\). Lines 1 and 2 compute the lengths \\(n_{L}\\) and \\(n_{R}\\) of the subarrays \\(A[p:q]\\) and \\(A[q+1:r]\\), respectively. Thenline 3 creates arrays \\(L[0\\!:\\!n_{L}-1]\\) and \\(R[0\\!:\\!n_{R}-1]\\) with respective lengths \\(n_{L}\\) and \\(n_{R}\\).12 The **for** loop of lines 4-5 copies the subarray \\(A[p\\!:\\!q]\\) into \\(L\\), and the **for** loop of lines 6-7 copies the subarray \\(A[q+1\\!:\\!r]\\) into \\(R\\).\n\nFootnote 12: This procedure is the rare case that uses both 1-origin indexing (for array \\(A\\)) and 0-origin indexing (for arrays \\(L\\) and \\(R\\)). Using 0-origin indexing for \\(L\\) and \\(R\\) makes for a simpler loop invariant in Exercise 2.3-3.\n\nLines 8-18, illustrated in Figure 2.3, perform the basic steps. The **while** loop of lines 12-18 repeatedly identifies the smallest value in \\(L\\) and \\(R\\) that has yet to \n\n### Designing algorithms\n\nThe operation of the **while** loop in lines 8-18 in the call \\(\\textsc{Merge}(A,9,12,16)\\), when the subarray \\(A[9\\,\\colon\\!16]\\) contains the values \\(\\langle 2,\\,4,\\,6,\\,7,\\,1,\\,2,\\,3,\\,5\\rangle\\). After allocating and copying into the arrays \\(L\\) and \\(R\\), the array \\(L\\) contains \\(\\langle 2,\\,4,\\,6,\\,7\\rangle\\), and the array \\(R\\) contains \\(\\langle 1,\\,2,\\,3,\\,5\\rangle\\). Tan positions in \\(A\\) contain their final values, and tan positions in \\(L\\) and \\(R\\) contain values that have yet to be copied back into \\(A\\). Taken together, the tan positions always comprise the values originally in \\(A[9\\,\\colon\\!16]\\). Blue positions in \\(A\\) contain values that will be copied over, and dark positions in \\(L\\) and \\(R\\) contain values that have already been copied back into \\(A\\). **(a)-(g)** The arrays \\(A\\), \\(L\\), and \\(R\\), and their respective indices \\(k\\), \\(i\\), and \\(j\\) prior to each iteration of the loop of lines 12-18. At the point in part (g), all values in \\(R\\) have been copied back into \\(A\\) (indicated by \\(j\\) equaling the length of \\(R\\)), and so the **while** loop in lines 12-18 terminates. **(h)** The arrays and indices at termination. The **while** loops of lines 20-23 and 24-27 copied back into \\(A\\) the remaining values in \\(L\\) and \\(R\\), which are the largest values originally in \\(A[9\\,\\colon\\!16]\\). Here, lines 20-23 copied \\(L[2\\,\\colon\\!3]\\) into \\(A[15\\,\\colon\\!16]\\), and because all values in \\(R\\) had already been copied back into \\(A\\), the **while** loop of lines 24-27 iterated \\(0\\) times. At this point, the subarray in \\(A[9\\,\\colon\\!16]\\) is sorted.\n\nFigure 2.3: The operation of the **while** loop in lines 8-18 in the call \\(\\textsc{Merge}(A,9,12,16)\\), when the subarray \\(A[9\\,\\colon\\!16]\\) contains the values \\(\\langle 2,\\,4,\\,6,\\,7,\\,1,\\,2,\\,3,\\,5\\rangle\\). After allocating and copying into the arrays \\(L\\) and \\(R\\), the array \\(L\\) contains \\(\\langle 2,\\,4,\\,6,\\,7\\rangle\\), and the array \\(R\\) contains \\(\\langle 1,\\,2,\\,3,\\,5\\rangle\\). Tan positions in \\(A\\) contain their final values, and tan positions in \\(L\\) and \\(R\\) contain values that have yet to be copied back into \\(A\\). Taken together, the tan positions always comprise the values originally in \\(A[9\\,\\colon\\!16]\\). Blue positions in \\(A\\) contain values that will be copied over, and dark positions in \\(L\\) and \\(R\\) contain values that have already been copied back into \\(A\\). **(a)-(g)** The arrays \\(A\\), \\(L\\), and \\(R\\), and their respective indices \\(k\\), \\(i\\), and \\(j\\) prior to each iteration of the loop of lines 12-18. At the point in part (g), all values in \\(R\\) have been copied back into \\(A\\) (indicated by \\(j\\) equaling the length of \\(R\\)), and so the **while** loop in lines 12-18 terminates. **(h)** The arrays and indices at termination. The **while** loops of lines 20-23 and 24-27 copied back into \\(A\\) the remaining values in \\(L\\) and \\(R\\), which are the largest values originally in \\(A[9\\,\\colon\\!16]\\). Here, lines 20-23 copied \\(L[2\\,\\colon\\!3]\\) into \\(A[15\\,\\colon\\!16]\\), and because all values in \\(R\\) had already been copied back into \\(A\\), the **while** loop of lines 24-27 iterated \\(0\\) times. At this point, the subarray in \\(A[9\\,\\colon\\!16]\\) is sorted.\n\nbe copied back into \\(A[p:r]\\) and copies it back in. As the comments indicate, the index \\(k\\) gives the position of \\(A\\) that is being filled in, and the indices \\(i\\) and \\(j\\) give the positions in \\(L\\) and \\(R\\), respectively, of the smallest remaining values. Eventually, either all of \\(L\\) or all of \\(R\\) is copied back into \\(A[p:r]\\), and this loop terminates. If the loop terminates because all of \\(R\\) has been copied back, that is, because \\(j\\) equals \\(n_{R}\\), then \\(i\\) is still less than \\(n_{L}\\), so that some of \\(L\\) has yet to be copied back, and these values are the greatest in both \\(L\\) and \\(R\\). In this case, the **while** loop of lines 20-23 copies these remaining values of \\(L\\) into the last few positions of \\(A[p:r]\\). Because \\(j\\) equals \\(n_{R}\\), the **while** loop of lines 24-27 iterates 0 times. If instead the **while** loop of lines 12-18 terminates because \\(i\\) equals \\(n_{L}\\), then all of \\(L\\) has already been copied back into \\(A[p:r]\\), and the **while** loop of lines 24-27 copies the remaining values of \\(R\\) back into the end of \\(A[p:r]\\).\n\nTo see that the Merge procedure runs in \\(\\Theta(n)\\) time, where \\(n=r-p+1\\),13 observe that each of lines 1-3 and 8-10 takes constant time, and the **for** loops of lines 4-7 take \\(\\Theta(n_{L}+n_{R})=\\Theta(n)\\) time.14 To account for the three **while** loops of lines 12-18, 20-23, and 24-27, observe that each iteration of these loops copies exactly one value from \\(L\\) or \\(R\\) back into \\(A\\) and that every value is copied back into \\(A\\) exactly once. Therefore, these three loops together make a total of \\(n\\) iterations. Since each iteration of each of the three loops takes constant time, the total time spent in these three loops is \\(\\Theta(n)\\).\n\nFootnote 13: If you\u2019re wondering where the \u201c\\(+1\\)\u201d comes from, imagine that \\(r=p+1\\). Then the subarray \\(A[p:r]\\) consists of two elements, and \\(r-p+1=2\\).\n\nFootnote 14: Chapter 3 shows how to formally interpret equations containing \\(\\Theta\\)-notation.\n\nWe can now use the Merge procedure as a subroutine in the merge sort algorithm. The procedure Merge-Sort\\((A,\\,p,r)\\) on the facing page sorts the elements in the subarray \\(A[p:r]\\). If \\(p\\) equals \\(r\\), the subarray has just 1 element and is therefore already sorted. Otherwise, we must have \\(p<r\\), and Merge-Sort runs the divide, conquer, and combine steps. The divide step simply computes an index \\(q\\) that partitions \\(A[p:r]\\) into two adjacent subarrays: \\(A[p:q]\\), containing \\(\\lceil n/2\\rceil\\) elements, and \\(A[q+1:r]\\), containing \\(\\lfloor n/2\\rfloor\\) elements.15 The initial call Merge-Sort\\((A,1,n)\\) sorts the entire array \\(A[1:n]\\).\n\nFootnote 15: The expression \\(\\lceil x\\rceil\\) denotes the least integer greater than or equal to \\(x\\), and \\(\\lfloor x\\rfloor\\) denotes the greatest integer less than or equal to \\(x\\). These notations are defined in Section 3.3. The easiest way to verify that setting \\(q\\) to \\(\\lfloor(p+r)/2\\rfloor\\) yields subarrays \\(A[p:q]\\) and \\(A[q+1:r]\\) of sizes \\(\\lceil n/2\\rceil\\) and \\(\\lfloor n/2\\rfloor\\), respectively, is to examine the four cases that arise depending on whether each of \\(p\\) and \\(r\\) is odd or even.\n\nFigure 2.4 illustrates the operation of the procedure for \\(n=8\\), showing also the sequence of divide and merge steps. The algorithm recursively divides the array down to 1-element subarrays. The combine steps merge pairs of 1-element subarrays\n\n### Designing algorithms\n\nMerge-Sort(\\(A\\), \\(p\\), \\(r\\))\n\n```\n1if\\(p\\geq r\\)// zero or one element?\n2return\n3\\(q=\\lfloor(p+r)/2\\rfloor\\)// midpoint of \\(A[p:r]\\)\n4Merge-Sort(\\(A\\), \\(p\\), \\(q\\))// recursively sort \\(A[p:q]\\)\n5Merge-Sort(\\(A\\), \\(q+1\\), \\(r\\))// recursively sort \\(A[q+1:r]\\)\n6// Merge \\(A[p:q]\\) and \\(A[q+1:r]\\) into \\(A[p:r]\\).\n7Merge(\\(A\\), \\(p\\), \\(q\\), \\(r\\))\n```\n\nMerge-Sort(\\(A\\), \\(p\\), \\(r\\))\n\n```\n1if\\(p\\geq r\\)// zero or one element?\n2return\n3\\(q=\\lfloor(p+r)/2\\rfloor\\)// midpoint of \\(A[p:r]\\)\n4Merge-Sort(\\(A\\), \\(p\\), \\(q\\))// recursively sort \\(A[p:q]\\)\n5Merge-Sort(\\(A\\), \\(q+1\\), \\(r\\))// recursively sort \\(A[q+1:r]\\)\n6// Merge \\(A[p:q]\\) and \\(A[q+1:r]\\) into \\(A[p:r]\\).\n7Merge(\\(A\\), \\(p\\), \\(q\\), \\(r\\))\n```\n\nMerge-Sort(\\(A\\), \\(p\\), \\(r\\))\n\n```\n1if\\(p\\geq r\\)// zero or one element?\n2return\n3\\(q=\\lfloor(p+r)/2\\rfloor\\)// midpoint of \\(A[p:r]\\)\n4Merge-Sort(\\(A\\), \\(p\\), \\(q\\))// recursively sort \\(A[p:q]\\)\n5Merge-Sort(\\(A\\), \\(q+1\\), \\(r\\))// recursively sort \\(A[q+1:r]\\)\n6// Merge \\(A[p:q]\\) and \\(A[q+1:r]\\) into \\(A[p:r]\\).\n7Merge(\\(A\\), \\(p\\), \\(q\\), \\(r\\))\n```\n\nMerge-Sort(\\(A\\), \\(p\\), \\(r\\))\n\n```\n1if\\(p\\geq r\\)// zero or one element?\n2return\n4\\(q=\\lfloor(p+r)/2\\rfloor\\)// midpoint of \\(A[p:r]\\)\n\n[MISSING_PAGE_POST]\n\n\\[T(n)=\\left\\{\\begin{array}{ll}\\Theta(1)&\\mbox{if $n<n_{0}$}\\,\\\\ D(n)+aT(n/b)+C(n)&\\mbox{otherwise}\\.\\end{array}\\right.\\]\n\nChapter 4 shows how to solve common recurrences of this form.\n\nSometimes, the \\(n/b\\) size of the divide step isn't an integer. For example, the Merge-Sort procedure divides a problem of size \\(n\\) into subproblems of sizes \\(\\lceil n/2\\rceil\\) and \\(\\lfloor n/2\\rfloor\\). Since the difference between \\(\\lceil n/2\\rceil\\) and \\(\\lfloor n/2\\rfloor\\) is at most 1,\n\nFigure 2.4: The operation of merge sort on the array \\(A\\) with length 8 that initially contains the sequence \\(\\langle 12,\\,3,\\,7,\\,9,\\,14,\\,6,\\,11,\\,2\\rangle\\). The indices \\(p\\), \\(q\\), and \\(r\\) into each subarray appear above their values. Numbers in italics indicate the order in which the Merge-Sort and Merge procedures are called following the initial call of Merge-Sort\\((A,1,8)\\).\n\nwhich for large \\(n\\) is much smaller than the effect of dividing \\(n\\) by 2, we'll squint a little and just call them both size \\(n/2\\). As Chapter 4 will discuss, this simplification of ignoring floors and ceilings does not generally affect the order of growth of a solution to a divide-and-conquer recurrence.\n\nAnother convention we'll adopt is to omit a statement of the base cases of the recurrence, which we'll also discuss in more detail in Chapter 4. The reason is that the base cases are pretty much always \\(T(n)=\\Theta(1)\\) if \\(n<n_{0}\\) for some constant \\(n_{0}>0\\). That's because the running time of an algorithm on an input of constant size is constant. We save ourselves a lot of extra writing by adopting this convention.\n\n#### Analysis of merge sort\n\nHere's how to set up the recurrence for \\(T(n)\\), the worst-case running time of merge sort on \\(n\\) numbers.\n\n**Divide:**: The divide step just computes the middle of the subarray, which takes constant time. Thus, \\(D(n)=\\Theta(1)\\).\n**Conquer:**: Recursively solving two subproblems, each of size \\(n/2\\), contributes \\(2T(n/2)\\) to the running time (ignoring the floors and ceilings, as we discussed).\n**Combine:**: Since the Merge procedure on an \\(n\\)-element subarray takes \\(\\Theta(n)\\) time, we have \\(C(n)=\\Theta(n)\\).\n\nWhen we add the functions \\(D(n)\\) and \\(C(n)\\) for the merge sort analysis, we are adding a function that is \\(\\Theta(n)\\) and a function that is \\(\\Theta(1)\\). This sum is a linear function of \\(n\\). That is, it is roughly proportional to \\(n\\) when \\(n\\) is large, and so merge sort's dividing and combining times together are \\(\\Theta(n)\\). Adding \\(\\Theta(n)\\) to the \\(2T(n/2)\\) term from the conquer step gives the recurrence for the worst-case running time \\(T(n)\\) of merge sort:\n\n\\[T(n)=2T(n/2)+\\Theta(n). \\tag{2.3}\\]\n\nChapter 4 presents the \"master theorem,\" which shows that \\(T(n)=\\Theta(n\\lg n)\\).17 Compared with insertion sort, whose worst-case running time is \\(\\Theta(n^{2})\\), merge sort trades away a factor of \\(n\\) for a factor of \\(\\lg n\\). Because the logarithm function grows more slowly than any linear function, that's a good trade. For large enough inputs, merge sort, with its \\(\\Theta(n\\lg n)\\) worst-case running time, outperforms insertion sort, whose worst-case running time is \\(\\Theta(n^{2})\\).\n\nWe do not need the master theorem, however, to understand intuitively why the solution to recurrence (2.3) is \\(T(n)=\\Theta(n\\lg n)\\). For simplicity, assume that \\(n\\) is an exact power of 2 and that the implicit base case is \\(n=1\\). Then recurrence (2.3) is essentially\n\n\\[T(n)=\\left\\{\\begin{array}{ll}c_{1}&\\mbox{if $n\\,=\\,1$,}\\\\ 2T(n/2)+c_{2}n&\\mbox{if $n>\\,1$,}\\end{array}\\right. \\tag{2.4}\\]\n\nwhere the constant \\(c_{1}>0\\) represents the time required to solve a problem of size 1, and \\(c_{2}>0\\) is the time per array element of the divide and combine steps.18\n\nFootnote 18: It is unlikely that \\(c_{1}\\) is exactly the time to solve problems of size 1 and that \\(c_{2}n\\) is exactly the time of the divide and combine steps. We\u2019ll look more closely at bounding recurrences in Chapter 4, where we\u2019ll be more careful about this kind of detail.\n\nFigure 2.5 illustrates one way of figuring out the solution to recurrence (2.4). Part (a) of the figure shows \\(T(n)\\), which part (b) expands into an equivalent tree representing the recurrence. The \\(c_{2}n\\) term denotes the cost of dividing and combining at the top level of recursion, and the two subtrees of the root are the two smaller recurrences \\(T(n/2)\\). Part (c) shows this process carried one step further by expanding \\(T(n/2)\\). The cost for dividing and combining at each of the two nodes at the second level of recursion is \\(c_{2}n/2\\). Continue to expand each node in the tree by breaking it into its constituent parts as determined by the recurrence, until the problem sizes get down to 1, each with a cost of \\(c_{1}\\). Part (d) shows the resulting _recursion tree_.\n\nNext, add the costs across each level of the tree. The top level has total cost \\(c_{2}n\\), the next level down has total cost \\(c_{2}(n/2)+c_{2}(n/2)=c_{2}n\\), the level after that has total cost \\(c_{2}(n/4)+c_{2}(n/4)+c_{2}(n/4)+c_{2}(n/4)=c_{2}n\\), and so on. Each level has twice as many nodes as the level above, but each node contributes only half the cost of a node from the level above. From one level to the next, doubling and halving cancel each other out, so that the cost across each level is the same: \\(c_{2}n\\). In general, the level that is \\(i\\) levels below the top has \\(2^{i}\\) nodes, each contributing a cost of \\(c_{2}(n/2^{i})\\), so that the \\(i\\)th level below the top has total cost \\(2^{i}\\cdot c_{2}(n/2^{i})=c_{2}n\\). The bottom level has \\(n\\) nodes, each contributing a cost of \\(c_{1}\\), for a total cost of \\(c_{1}n\\).\n\nThe total number of levels of the recursion tree in Figure 2.5 is \\(\\lg n\\,+\\,1\\), where \\(n\\) is the number of leaves, corresponding to the input size. An informal inductive argument justifies this claim. The base case occurs when \\(n=1\\), in which case the tree has only 1 level. Since \\(\\lg 1=0\\), we have that \\(\\lg n\\,+\\,1\\) gives the correct number of levels. Now assume as an inductive hypothesis that the number of levels of a recursion tree with \\(2^{i}\\) leaves is \\(\\lg 2^{i}\\,+\\,1=i\\,+\\,1\\) (since for any value of \\(i\\), we have that \\(\\lg 2^{i}\\,=\\,i\\)). Because we assume that the input size is an exact power of 2, the next input size to consider is \\(2^{i\\,+\\,1}\\). A tree with \\(n=2^{i\\,+\\,1}\\) leaves has 1 more \n\n### Designing algorithms\n\nHow to construct a recursion tree for the recurrence (2.4). Part **(a)** shows \\(T(n)\\), which progressively expands in **(b)-(d)** to form the recursion tree. The fully expanded tree in part (d) has \\(\\lg n\\,+\\,1\\) levels. Each level above the leaves contributes a total cost of \\(c_{2}n\\), and the leaf level contributes \\(c_{1}n\\). The total cost, therefore, is \\(c_{2}n\\lg n\\,+\\,c_{1}n\\,=\\,\\Theta(n\\lg n)\\).\n\nFigure 2.5: How to construct a recursion tree for the recurrence (2.4). Part **(a)** shows \\(T(n)\\), which progressively expands in **(b)-(d)** to form the recursion tree. The fully expanded tree in part (d) has \\(\\lg n\\,+\\,1\\) levels. Each level above the leaves contributes a total cost of \\(c_{2}n\\), and the leaf level contributes \\(c_{1}n\\). The total cost, therefore, is \\(c_{2}n\\lg n\\,+\\,c_{1}n\\,=\\,\\Theta(n\\lg n)\\).\n\nlevel than a tree with \\(2^{i}\\) leaves, and so the total number of levels is \\((i+1)+1=\\lg 2^{i+1}+1\\).\n\nTo compute the total cost represented by the recurrence (2.4), simply add up the costs of all the levels. The recursion tree has \\(\\lg n+1\\) levels. The levels above the leaves each cost \\(c_{2}n\\), and the leaf level costs \\(c_{1}n\\), for a total cost of \\(c_{2}n\\lg n+c_{1}n=\\Theta(n\\lg n)\\).\n\n##### Exercises\n\n##### 2.3-1\n\nUsing Figure 2.4 as a model, illustrate the operation of merge sort on an array initially containing the sequence \\(\\langle 3,41,52,26,38,57,9,49\\rangle\\).\n\n##### 2.3-2\n\nThe test in line 1 of the Merge-Sort procedure reads **\"if**\\(p\\geq r\\)\" rather than **\"if**\\(p\\neq r\\).\" If Merge-Sort is called with \\(p>r\\), then the subarray \\(A[p:r]\\) is empty. Argue that as long as the initial call of Merge-Sort\\((A,1,n)\\) has \\(n\\geq 1\\), the test **\"if**\\(p\\neq r\\)\" suffices to ensure that no recursive call has \\(p>r\\).\n\n##### 2.3-3\n\nState a loop invariant for the **while** loop of lines 12-18 of the Merge procedure. Show how to use it, along with the **while** loops of lines 20-23 and 24-27, to prove that the Merge procedure is correct.\n\n##### 2.3-4\n\nUse mathematical induction to show that when \\(n\\geq 2\\) is an exact power of 2, the solution of the recurrence\n\n\\[T(n)=\\left\\{\\begin{array}{ll}2&\\mbox{if $n=2$}\\\\ 2T(n/2)+n&\\mbox{if $n>2$}\\end{array}\\right.\\]\n\nis \\(T(n)=n\\lg n\\).\n\n##### 2.3-5\n\nYou can also think of insertion sort as a recursive algorithm. In order to sort \\(A[1:n]\\), recursively sort the subarray \\(A[1:n-1]\\) and then insert \\(A[n]\\) into the sorted subarray \\(A[1:n-1]\\). Write pseudocode for this recursive version of insertion sort. Give a recurrence for its worst-case running time.\n\n##### 2.3-6\n\nReferring back to the searching problem (see Exercise 2.1-4), observe that if the subarray being searched is already sorted, the searching algorithm can check the midpoint of the subarray against \\(v\\) and eliminate half of the subarray from further consideration. The _binary search_ algorithm repeats this procedure, halving the size of the remaining portion of the subarray each time. Write pseudocode, either iterative or recursive, for binary search. Argue that the worst-case running time of binary search is \\(\\Theta(\\lg n)\\).\n\n#### 2.3-7\n\nThe **while** loop of lines 5-7 of the Insertion-Sort procedure in Section 2.1 uses a linear search to scan (backward) through the sorted subarray \\(A[1:j-1]\\). What if insertion sort used a binary search (see Exercise 2.3-6) instead of a linear search? Would that improve the overall worst-case running time of insertion sort to \\(\\Theta(n\\lg n)\\)?\n\n#### 2.3-8\n\nDescribe an algorithm that, given a set \\(S\\) of \\(n\\) integers and another integer \\(x\\), determines whether \\(S\\) contains two elements that sum to exactly \\(x\\). Your algorithm should take \\(\\Theta(n\\lg n)\\) time in the worst case.\n\n## Problems\n\n### Insertion sort on small arrays in merge sort\n\nAlthough merge sort runs in \\(\\Theta(n\\lg n)\\) worst-case time and insertion sort runs in \\(\\Theta(n^{2})\\) worst-case time, the constant factors in insertion sort can make it faster in practice for small problem sizes on many machines. Thus it makes sense to _coarsen_ the leaves of the recursion by using insertion sort within merge sort when subproblems become sufficiently small. Consider a modification to merge sort in which \\(n/k\\) sublists of length \\(k\\) are sorted using insertion sort and then merged using the standard merging mechanism, where \\(k\\) is a value to be determined.\n\n* Show that insertion sort can sort the \\(n/k\\) sublists, each of length \\(k\\), in \\(\\Theta(nk)\\) worst-case time.\n* Show how to merge the sublists in \\(\\Theta(n\\lg(n/k))\\) worst-case time.\n* Given that the modified algorithm runs in \\(\\Theta(n\\lg(n/k))\\) worst-case time, what is the largest value of \\(k\\) as a function of \\(n\\) for which the modified algorithm has the same running time as standard merge sort, in terms of \\(\\Theta\\)-notation?\n* How should you choose \\(k\\) in practice?",
        "chapter": "Part I Foundations",
        "section": "2 Getting Started",
        "subsection": "2.3 Designing algorithms",
        "subsubsection": "N/A"
    },
    {
        "content": "consideration. The _binary search_ algorithm repeats this procedure, halving the size of the remaining portion of the subarray each time. Write pseudocode, either iterative or recursive, for binary search. Argue that the worst-case running time of binary search is \\(\\Theta(\\lg n)\\).\n\n#### 2.3-7\n\nThe **while** loop of lines 5-7 of the Insertion-Sort procedure in Section 2.1 uses a linear search to scan (backward) through the sorted subarray \\(A[1:j-1]\\). What if insertion sort used a binary search (see Exercise 2.3-6) instead of a linear search? Would that improve the overall worst-case running time of insertion sort to \\(\\Theta(n\\lg n)\\)?\n\n#### 2.3-8\n\nDescribe an algorithm that, given a set \\(S\\) of \\(n\\) integers and another integer \\(x\\), determines whether \\(S\\) contains two elements that sum to exactly \\(x\\). Your algorithm should take \\(\\Theta(n\\lg n)\\) time in the worst case.\n\n## Problems\n\n### Insertion sort on small arrays in merge sort\n\nAlthough merge sort runs in \\(\\Theta(n\\lg n)\\) worst-case time and insertion sort runs in \\(\\Theta(n^{2})\\) worst-case time, the constant factors in insertion sort can make it faster in practice for small problem sizes on many machines. Thus it makes sense to _coarsen_ the leaves of the recursion by using insertion sort within merge sort when subproblems become sufficiently small. Consider a modification to merge sort in which \\(n/k\\) sublists of length \\(k\\) are sorted using insertion sort and then merged using the standard merging mechanism, where \\(k\\) is a value to be determined.\n\n* Show that insertion sort can sort the \\(n/k\\) sublists, each of length \\(k\\), in \\(\\Theta(nk)\\) worst-case time.\n* Show how to merge the sublists in \\(\\Theta(n\\lg(n/k))\\) worst-case time.\n* Given that the modified algorithm runs in \\(\\Theta(n\\lg(n/k))\\) worst-case time, what is the largest value of \\(k\\) as a function of \\(n\\) for which the modified algorithm has the same running time as standard merge sort, in terms of \\(\\Theta\\)-notation?\n* How should you choose \\(k\\) in practice?\n\n### 2.2 Correctness of bubblesort\n\nBubblesort is a popular, but inefficient, sorting algorithm. It works by repeatedly swapping adjacent elements that are out of order. The procedure Bubblesort sorts array \\(A[1:n]\\).\n\n\\begin{tabular}{l l} \\hline \\hline \\multicolumn{2}{l}{Bubblesort(\\(A,n\\))} \\\\\n1 & **for**\\(i\\ =\\ 1\\)**to**\\(n-1\\) \\\\\n2 & **for**\\(j\\ =\\ n\\)**downto**\\(i\\ +\\ 1\\) \\\\\n3 & **if**\\(A[j]<A[j-1]\\) \\\\\n4 & \\multicolumn{2}{l}{exchange \\(A[j]\\) with \\(A[j-1]\\)} \\\\ \\end{tabular}\n\n* Let \\(A^{\\prime}\\) denote the array \\(A\\) after Bubblesort(\\(A,n\\)) is executed. To prove that Bubblesort is correct, you need to prove that it terminates and that \\[A^{\\prime}[1]\\leq A^{\\prime}[2]\\leq\\cdots\\leq A^{\\prime}[n]\\.\\] (2.5) In order to show that Bubblesort actually sorts, what else do you need to prove? The next two parts prove inequality (2.5).\n* State precisely a loop invariant for the **for*\n* loop in lines 2-4, and prove that this loop invariant holds. Your proof should use the structure of the loop-invariant proof presented in this chapter.\n* Using the termination condition of the loop invariant proved in part (b), state a loop invariant for the **for*\n* loop in lines 1-4 that allows you to prove inequality (2.5). Your proof should use the structure of the loop-invariant proof presented in this chapter.\n* What is the worst-case running time of Bubblesort? How does it compare with the running time of Insertion-Sort?\n\n### 2.3 Correctness of Horner's rule\n\nYou are given the coefficents \\(a_{0},a_{1},a_{2},\\ldots,a_{n}\\) of a polynomial\n\n\\[P(x) = \\sum_{k=0}^{n}a_{k}x^{k}\\] \\[= a_{0}+a_{1}x+a_{2}x^{2}+\\cdots+a_{n-1}x^{n-1}+a_{n}x^{n}\\,\\]\n\nand you want to evaluate this polynomial for a given value of \\(x\\). _Horner's rule_ says to evaluate the polynomial according to this parenthesization:\\(P(x)=a_{0}+x\\Big{(}a_{1}+x\\ \\big{(}a_{2}+\\cdots+x\\ (a_{n-1}+xa_{n})\\cdots\\big{)} \\Big{)}\\).\n\nThe procedure Horner implements Horner's rule to evaluate \\(P(x)\\), given the coefficients \\(a_{0},a_{1},a_{2},\\ldots,a_{n}\\) in an array \\(A[0:n]\\) and the value of \\(x\\).\n\nHorner(\\(A,n,x\\))\n\n1\\(p\\,=0\\)\n2for\\(i\\,=\\,n\\)**downto** 0\n3\\(p\\,=\\,A[i]+x\\cdot p\\)\n4return\\(p\\)\n\n_a._: In terms of \\(\\Theta\\)-notation, what is the running time of this procedure?\n\n_b._: Write pseudocode to implement the naive polynomial-evaluation algorithm that computes each term of the polynomial from scratch. What is the running time of this algorithm? How does it compare with Horner?\n\n_c._: Consider the following loop invariant for the procedure Horner:\n\nAt the start of each iteration of the **for** loop of lines 2-3,\n\n\\(p\\,=\\,\\sum_{k\\,=\\,0}^{n-(i\\,+\\,1)}A[k\\,+\\,i\\,+\\,1]\\cdot x^{k}\\).\n\nInterpret a summation with no terms as equaling 0. Following the structure of the loop-invariant proof presented in this chapter, use this loop invariant to show that, at termination, \\(p\\,=\\,\\sum_{k\\,=\\,0}^{n}A[k]\\cdot x^{k}\\).\n\n_2-4 Inversions_\n\nLet \\(A[1:n]\\) be an array of \\(n\\) distinct numbers. If \\(i\\,<\\,j\\) and \\(A[i]\\,>\\,A[j]\\), then the pair \\((i,\\,j)\\) is called an _inversion_ of \\(A\\).\n\n_a._: List the five inversions of the array \\(\\langle 2,3,8,6,1\\rangle\\).\n\n_b._: What array with elements from the set \\(\\{1,2,\\ldots,n\\}\\) has the most inversions? How many does it have?\n\n_c._: What is the relationship between the running time of insertion sort and the number of inversions in the input array? Justify your answer.\n\n_d._: Give an algorithm that determines the number of inversions in any permutation on \\(n\\) elements in \\(\\Theta(n\\lg n)\\) worst-case time. (_Hint:_ Modify merge sort.)\n\n## Chapter notes\n\nIn 1968, Knuth published the first of three volumes with the general title _The Art of Computer Programming_[259, 260, 261]. The first volume ushered in the modern study of computer algorithms with a focus on the analysis of running time. The full series remains an engaging and worthwhile reference for many of the topics presented here. According to Knuth, the word \"algorithm\" is derived from the name \"al-Khowarizmi,\" a ninth-century Persian mathematician.\n\nAho, Hopcroft, and Ullman [5] advocated the asymptotic analysis of algorithms -- using notations that Chapter 3 introduces, including \\(\\Theta\\)-notation--as a means of comparing relative performance. They also popularized the use of recurrence relations to describe the running times of recursive algorithms.\n\nKnuth [261] provides an encyclopedic treatment of many sorting algorithms. His comparison of sorting algorithms (page 381) includes exact step-counting analyses, like the one we performed here for insertion sort. Knuth's discussion of insertion sort encompasses several variations of the algorithm. The most important of these is Shell's sort, introduced by D. L. Shell, which uses insertion sort on periodic subarrays of the input to produce a faster sorting algorithm.\n\nMerge sort is also described by Knuth. He mentions that a mechanical collabor capable of merging two decks of punched cards in a single pass was invented in 1938. J. von Neumann, one of the pioneers of computer science, apparently wrote a program for merge sort on the EDVAC computer in 1945.\n\nThe early history of proving programs correct is described by Gries [200], who credits P. Naur with the first article in this field. Gries attributes loop invariants to R. W. Floyd. The textbook by Mitchell [329] is a good reference on how to prove programs correct.",
        "chapter": "Part I Foundations",
        "section": "2 Getting Started",
        "subsection": "Problems",
        "subsubsection": "N/A"
    },
    {
        "content": "## Chapter notes\n\nIn 1968, Knuth published the first of three volumes with the general title _The Art of Computer Programming_[259, 260, 261]. The first volume ushered in the modern study of computer algorithms with a focus on the analysis of running time. The full series remains an engaging and worthwhile reference for many of the topics presented here. According to Knuth, the word \"algorithm\" is derived from the name \"al-Khowarizmi,\" a ninth-century Persian mathematician.\n\nAho, Hopcroft, and Ullman [5] advocated the asymptotic analysis of algorithms -- using notations that Chapter 3 introduces, including \\(\\Theta\\)-notation--as a means of comparing relative performance. They also popularized the use of recurrence relations to describe the running times of recursive algorithms.\n\nKnuth [261] provides an encyclopedic treatment of many sorting algorithms. His comparison of sorting algorithms (page 381) includes exact step-counting analyses, like the one we performed here for insertion sort. Knuth's discussion of insertion sort encompasses several variations of the algorithm. The most important of these is Shell's sort, introduced by D. L. Shell, which uses insertion sort on periodic subarrays of the input to produce a faster sorting algorithm.\n\nMerge sort is also described by Knuth. He mentions that a mechanical collabor capable of merging two decks of punched cards in a single pass was invented in 1938. J. von Neumann, one of the pioneers of computer science, apparently wrote a program for merge sort on the EDVAC computer in 1945.\n\nThe early history of proving programs correct is described by Gries [200], who credits P. Naur with the first article in this field. Gries attributes loop invariants to R. W. Floyd. The textbook by Mitchell [329] is a good reference on how to prove programs correct.\n\n## Chapter Characterizing Running Times\n\nThe order of growth of the running time of an algorithm, defined in Chapter 2, gives a simple way to characterize the algorithm's efficiency and also allows us to compare it with alternative algorithms. Once the input size \\(n\\) becomes large enough, merge sort, with its \\(\\Theta(n\\lg n)\\) worst-case running time, beats insertion sort, whose worst-case running time is \\(\\Theta(n^{2})\\). Although we can sometimes determine the exact running time of an algorithm, as we did for insertion sort in Chapter 2, the extra precision is rarely worth the effort of computing it. For large enough inputs, the multiplicative constants and lower-order terms of an exact running time are dominated by the effects of the input size itself.\n\nWhen we look at input sizes large enough to make relevant only the order of growth of the running time, we are studying the _asymptotic_ efficiency of algorithms. That is, we are concerned with how the running time of an algorithm increases with the size of the input _in the limit_, as the size of the input increases without bound. Usually, an algorithm that is asymptotically more efficient is the best choice for all but very small inputs.\n\nThis chapter gives several standard methods for simplifying the asymptotic analysis of algorithms. The next section presents informally the three most commonly used types of \"asymptotic notation,\" of which we have already seen an example in \\(\\Theta\\)-notation. It also shows one way to use these asymptotic notations to reason about the worst-case running time of insertion sort. Then we look at asymptotic notations more formally and present several notational conventions used throughout this book. The last section reviews the behavior of functions that commonly arise when analyzing algorithms.",
        "chapter": "Part I Foundations",
        "section": "2 Getting Started",
        "subsection": "Chapter notes",
        "subsubsection": "N/A"
    },
    {
        "content": "### 3.1 \\(O\\)-notation, \\(\\Omega\\)-notation, and \\(\\Theta\\)-notation\n\nWhen we analyzed the worst-case running time of insertion sort in Chapter 2, we started with the complicated expression\n\n\\[\\left(\\frac{c_{5}}{2}+\\frac{c_{6}}{2}+\\frac{c_{7}}{2}\\right)n^{2}+ \\left(c_{1}+c_{2}+c_{4}+\\frac{c_{5}}{2}-\\frac{c_{6}}{2}-\\frac{c_{7}}{2}+c_{8} \\right)n\\] \\[\\qquad-(c_{2}+c_{4}+c_{5}+c_{8})\\.\\]\n\nWe then discarded the lower-order terms \\((c_{1}+c_{2}+c_{4}+c_{5}/2-c_{6}/2-c_{7}/2+c_{8})n\\) and \\(c_{2}+c_{4}+c_{5}+c_{8}\\), and we also ignored the coefficient \\(c_{5}/2+c_{6}/2+c_{7}/2\\) of \\(n^{2}\\). That left just the factor \\(n^{2}\\), which we put into \\(\\Theta\\)-notation as \\(\\Theta(n^{2})\\). We use this style to characterize running times of algorithms: discard the lower-order terms and the coefficient of the leading term, and use a notation that focuses on the rate of growth of the running time.\n\n\\(\\Theta\\)-notation is not the only such \"asymptotic notation.\" In this section, we'll see other forms of asymptotic notation as well. We start with intuitive looks at these notations, revisiting insertion sort to see how we can apply them. In the next section, we'll see the formal definitions of our asymptotic notations, along with conventions for using them.\n\nBefore we get into specifics, bear in mind that the asymptotic notations we'll see are designed so that they characterize functions in general. It so happens that the functions we are most interested in denote the running times of algorithms. But asymptotic notation can apply to functions that characterize some other aspect of algorithms (the amount of space they use, for example), or even to functions that have nothing whatsoever to do with algorithms.\n\n#### \\(O\\)-notation\n\n\\(O\\)-notation characterizes an _upper bound_ on the asymptotic behavior of a function. In other words, it says that a function grows _no faster_ than a certain rate, based on the highest-order term. Consider, for example, the function \\(7n^{3}+100n^{2}-20n+6\\). Its highest-order term is \\(7n^{3}\\), and so we say that this function's rate of growth is \\(n^{3}\\). Because this function grows no faster than \\(n^{3}\\), we can write that it is \\(O(n^{3})\\). You might be surprised that we can also write that the function \\(7n^{3}+100n^{2}-20n+6\\) is \\(O(n^{4})\\). Why? Because the function grows more slowly than \\(n^{4}\\), we are correct in saying that it grows no faster. As you might have guessed, this function is also \\(O(n^{5})\\), \\(O(n^{6})\\), and so on. More generally, it is \\(O(n^{c})\\) for any constant \\(c\\)\\(\\geq 3\\).\n\n### \\(\\Omega\\)-notation\n\n\\(\\Omega\\)-notation characterizes a _lower bound_ on the asymptotic behavior of a function. In other words, it says that a function grows _at least as fast_ as a certain rate, based --as in \\(O\\)-notation--on the highest-order term. Because the highest-order term in the function \\(7n^{3}+100n^{2}-20n+6\\) grows at least as fast as \\(n^{3}\\), this function is \\(\\Omega(n^{3})\\). This function is also \\(\\Omega(n^{2})\\) and \\(\\Omega(n)\\). More generally, it is \\(\\Omega(n^{c})\\) for any constant \\(c\\leq 3\\).\n\n### \\(\\Theta\\)-notation\n\n\\(\\Theta\\)-notation characterizes a _tight bound_ on the asymptotic behavior of a function. It says that a function grows _precisely_ at a certain rate, based--once again--on the highest-order term. Put another way, \\(\\Theta\\)-notation characterizes the rate of growth of the function to within a constant factor from above and to within a constant factor from below. These two constant factors need not be equal.\n\nIf you can show that a function is both \\(O(f(n))\\) and \\(\\Omega(f(n))\\) for some function \\(f(n)\\), then you have shown that the function is \\(\\Theta(f(n))\\). (The next section states this fact as a theorem.) For example, since the function \\(7n^{3}+100n^{2}-20n+6\\) is both \\(O(n^{3})\\) and \\(\\Omega(n^{3})\\), it is also \\(\\Theta(n^{3})\\).\n\n### Example: Insertion sort\n\nLet's revisit insertion sort and see how to work with asymptotic notation to characterize its \\(\\Theta(n^{2})\\) worst-case running time without evaluating summations as we did in Chapter 2. Here is the Insertion-Sort procedure once again:\n\nInsertion-Sort(\\(A,n\\))\n\n```\n1for\\(i=2\\)to\\(n\\)\n2key\\(=A[i]\\)\n3//Insert\\(A[i]\\)into the sorted subarray \\(A[1:i-1]\\).\n4\\(j=i-1\\)\n5while\\(j>0\\)and\\(A[j]>\\)key\n6\\(A[j+1]=A[j]\\)\n7\\(j=j-1\\)\n8\\(A[j+1]=\\)key\n```\n\n**Algorithm 2** Insertion-Sort(\\(A,n\\))\n\nWhat can we observe about how the pseudocode operates? The procedure has nested loops. The outer loop is a **for** loop that runs \\(n-1\\) times, regardless of the values being sorted. The inner loop is a **while** loop, but the number of iterations it makes depends on the values being sorted. The loop variable \\(j\\) starts at \\(i-1\\)and decreases by \\(1\\) in each iteration until either it reaches \\(0\\) or \\(A[j]\\leq\\mathit{key}\\). For a given value of \\(i\\), the **while** loop might iterate \\(0\\) times, \\(i-1\\) times, or anywhere in between. The body of the **while** loop (lines 6-7) takes constant time per iteration of the **while** loop.\n\nThese observations suffice to deduce an \\(O(n^{2})\\) running time for any case of Insertion-Sort, giving us a blanket statement that covers all inputs. The running time is dominated by the inner loop. Because each of the \\(n-1\\) iterations of the outer loop causes the inner loop to iterate at most \\(i-1\\) times, and because \\(i\\) is at most \\(n\\), the total number of iterations of the inner loop is at most \\((n-1)(n-1)\\), which is less than \\(n^{2}\\). Since each iteration of the inner loop takes constant time, the total time spent in the inner loop is at most a constant times \\(n^{2}\\), or \\(O(n^{2})\\).\n\nWith a little creativity, we can also see that the worst-case running time of Insertion-Sort is \\(\\Omega(n^{2})\\). By saying that the worst-case running time of an algorithm is \\(\\Omega(n^{2})\\), we mean that for every input size \\(n\\) above a certain threshold, there is at least one input of size \\(n\\) for which the algorithm takes at least \\(cn^{2}\\) time, for some positive constant \\(c\\). It does not necessarily mean that the algorithm takes at least \\(cn^{2}\\) time for all inputs.\n\nLet's now see why the worst-case running time of Insertion-Sort is \\(\\Omega(n^{2})\\). For a value to end up to the right of where it started, it must have been moved in line 6. In fact, for a value to end up \\(k\\) positions to the right of where it started, line 6 must have executed \\(k\\) times. As Figure 3.1 shows, let's assume that \\(n\\) is a multiple of \\(3\\) so that we can divide the array \\(A\\) into groups of \\(n/3\\) positions. Suppose that in the input to Insertion-Sort, the \\(n/3\\) largest values occupy the first \\(n/3\\) array positions \\(A[1:n/3]\\). (It does not matter what relative order they have within the first \\(n/3\\) positions.) Once the array has been sorted, each of these \\(n/3\\) values ends up somewhere in the last \\(n/3\\) positions \\(A[2n/3+1:n]\\). For that to happen, each of these \\(n/3\\) values must pass through each of the middle \\(n/3\\) positions \\(A[n/3+1:2n/3]\\). Each of these \\(n/3\\) values passes through these middle\n\nFigure 3.1: The \\(\\Omega(n^{2})\\) lower bound for insertion sort. If the first \\(n/3\\) positions contain the \\(n/3\\) largest values, each of these values must move through each of the middle \\(n/3\\) positions, one position at a time, to end up somewhere in the last \\(n/3\\) positions. Since each of \\(n/3\\) values moves through at least each of \\(n/3\\) positions, the time taken in this case is at least proportional to \\((n/3)(n/3)=n^{2}/9\\), or \\(\\Omega(n^{2})\\).\n\n\\(n/3\\) positions one position at a time, by at least \\(n/3\\) executions of line 6. Because at least \\(n/3\\) values have to pass through at least \\(n/3\\) positions, the time taken by Insertion-Sort in the worst case is at least proportional to \\((n/3)(n/3)=n^{2}/9\\), which is \\(\\Omega(n^{2})\\).\n\nBecause we have shown that Insertion-Sort runs in \\(O(n^{2})\\) time in all cases and that there is an input that makes it take \\(\\Omega(n^{2})\\) time, we can conclude that the worst-case running time of Insertion-Sort is \\(\\Theta(n^{2})\\). It does not matter that the constant factors for upper and lower bounds might differ. What matters is that we have characterized the worst-case running time to within constant factors (discounting lower-order terms). This argument does not show that Insertion-Sort runs in \\(\\Theta(n^{2})\\) time in _all_ cases. Indeed, we saw in Chapter 2 that the best-case running time is \\(\\Theta(n)\\).\n\n#### Exercises\n\n_3.1-1_\n\nModify the lower-bound argument for insertion sort to handle input sizes that are not necessarily a multiple of 3.\n\n_3.1-2_\n\nUsing reasoning similar to what we used for insertion sort, analyze the running time of the selection sort algorithm from Exercise 2.2-2.\n\n_3.1-3_\n\nSuppose that \\(\\alpha\\) is a fraction in the range \\(0<\\alpha<1\\). Show how to generalize the lower-bound argument for insertion sort to consider an input in which the \\(\\alpha n\\) largest values start in the first \\(\\alpha n\\) positions. What additional restriction do you need to put on \\(\\alpha\\)? What value of \\(\\alpha\\) maximizes the number of times that the \\(\\alpha n\\) largest values must pass through each of the middle \\((1-2\\alpha)n\\) array positions?\n\n### Asymptotic notation: formal definitions\n\nHaving seen asymptotic notation informally, let's get more formal. The notations we use to describe the asymptotic running time of an algorithm are defined in terms of functions whose domains are typically the set \\(\\mathbb{N}\\) of natural numbers or the set \\(\\mathbb{R}\\) of real numbers. Such notations are convenient for describing a running-time function \\(T(n)\\). This section defines the basic asymptotic notations and also introduces some common \"proper\" notational abuses.",
        "chapter": "Part I Foundations",
        "section": "3 Characterizing Running Times",
        "subsection": "3.1 O-notation, \u03a9-notation, and \u0398-notation",
        "subsubsection": "N/A"
    },
    {
        "content": "\\(n/3\\) positions one position at a time, by at least \\(n/3\\) executions of line 6. Because at least \\(n/3\\) values have to pass through at least \\(n/3\\) positions, the time taken by Insertion-Sort in the worst case is at least proportional to \\((n/3)(n/3)=n^{2}/9\\), which is \\(\\Omega(n^{2})\\).\n\nBecause we have shown that Insertion-Sort runs in \\(O(n^{2})\\) time in all cases and that there is an input that makes it take \\(\\Omega(n^{2})\\) time, we can conclude that the worst-case running time of Insertion-Sort is \\(\\Theta(n^{2})\\). It does not matter that the constant factors for upper and lower bounds might differ. What matters is that we have characterized the worst-case running time to within constant factors (discounting lower-order terms). This argument does not show that Insertion-Sort runs in \\(\\Theta(n^{2})\\) time in _all_ cases. Indeed, we saw in Chapter 2 that the best-case running time is \\(\\Theta(n)\\).\n\n#### Exercises\n\n_3.1-1_\n\nModify the lower-bound argument for insertion sort to handle input sizes that are not necessarily a multiple of 3.\n\n_3.1-2_\n\nUsing reasoning similar to what we used for insertion sort, analyze the running time of the selection sort algorithm from Exercise 2.2-2.\n\n_3.1-3_\n\nSuppose that \\(\\alpha\\) is a fraction in the range \\(0<\\alpha<1\\). Show how to generalize the lower-bound argument for insertion sort to consider an input in which the \\(\\alpha n\\) largest values start in the first \\(\\alpha n\\) positions. What additional restriction do you need to put on \\(\\alpha\\)? What value of \\(\\alpha\\) maximizes the number of times that the \\(\\alpha n\\) largest values must pass through each of the middle \\((1-2\\alpha)n\\) array positions?\n\n### Asymptotic notation: formal definitions\n\nHaving seen asymptotic notation informally, let's get more formal. The notations we use to describe the asymptotic running time of an algorithm are defined in terms of functions whose domains are typically the set \\(\\mathbb{N}\\) of natural numbers or the set \\(\\mathbb{R}\\) of real numbers. Such notations are convenient for describing a running-time function \\(T(n)\\). This section defines the basic asymptotic notations and also introduces some common \"proper\" notational abuses.\n\n### \\(O\\)-notation\n\nAs we saw in Section 3.1, \\(O\\)-notation describes an _asymptotic upper bound_. We use \\(O\\)-notation to give an upper bound on a function, to within a constant factor.\n\nHere is the formal definition of \\(O\\)-notation. For a given function \\(g(n)\\), we denote by \\(O(g(n))\\) (pronounced \"big-oh of \\(g\\) of \\(n\\)\" or sometimes just \"oh of \\(g\\) of \\(n\\)\") the _set of functions_\n\n\\[O(g(n))=\\{f(n): \\text{there exist positive constants $c$ and $n_{0}$ such that}\\] \\[0\\leq f(n)\\leq cg(n)\\text{ for all $n\\geq n_{0}$}\\}\\.\\lx@note{footnote}{Within set notation, a colon means \"such that.\"}\\]\n\nA function \\(f(n)\\) belongs to the set \\(O(g(n))\\) if there exists a positive constant \\(c\\) such that \\(f(n)\\leq cg(n)\\) for sufficiently large \\(n\\). Figure 3.2(a) shows the intuition behind \\(O\\)-notation. For all values \\(n\\) at and to the right of \\(n_{0}\\), the value of the function \\(f(n)\\) is on or below \\(cg(n)\\).\n\nThe definition of \\(O(g(n))\\) requires that every function \\(f(n)\\) in the set \\(O(g(n))\\) be _asymptotically nonnegative_: \\(f(n)\\) must be nonnegative whenever \\(n\\) is sufficiently large. (An _asymptotically positive_ function is one that is positive for all\n\nFigure 3.2: Graphic examples of the \\(O\\), \\(\\Omega\\), and \\(\\Theta\\) notations. In each part, the value of \\(n_{0}\\) shown is the minimum possible value, but any greater value also works. **(a)**\\(O\\)-notation gives an upper bound for a function to within a constant factor. We write \\(f(n)=O(g(n))\\) if there are positive constants \\(n_{0}\\) and \\(c\\) such that at and to the right of \\(n_{0}\\), the value of \\(f(n)\\) always lies on or below \\(cg(n)\\). **(b)**\\(\\Omega\\)-notation gives a lower bound for a function to within a constant factor. We write \\(f(n)=\\Omega(g(n))\\) if there are positive constants \\(n_{0}\\) and \\(c\\) such that at and to the right of \\(n_{0}\\), the value of \\(f(n)\\) always lies on or above \\(cg(n)\\). **(c)**\\(\\Theta\\)-notation bounds a function to within constant factors. We write \\(f(n)=\\Theta(g(n))\\) if there exist positive constants \\(n_{0}\\), \\(c_{1}\\), and \\(c_{2}\\) such that at and to the right of \\(n_{0}\\), the value of \\(f(n)\\) always lies between \\(c_{1}g(n)\\) and \\(c_{2}g(n)\\) inclusive.\n\nsufficiently large \\(n\\).) Consequently, the function \\(g(n)\\) itself must be asymptotically nonnegative, or else the set \\(O(g(n))\\) is empty. We therefore assume that every function used within \\(O\\)-notation is asymptotically nonnegative. This assumption holds for the other asymptotic notations defined in this chapter as well.\n\nYou might be surprised that we define \\(O\\)-notation in terms of sets. Indeed, you might expect that we would write \"\\(f(n)\\in O(g(n))\\)\" to indicate that \\(f(n)\\) belongs to the set \\(O(g(n))\\). Instead, we usually write \"\\(f(n)=O(g(n))\\)\" and say \"\\(f(n)\\) is big-oh of \\(g(n)\\)\" to express the same notion. Although it may seem confusing at first to abuse equality in this way, we'll see later in this section that doing so has its advantages.\n\nLet's explore an example of how to use the formal definition of \\(O\\)-notation to justify our practice of discarding lower-order terms and ignoring the constant coefficient of the highest-order term. We'll show that \\(4n^{2}+100n+500=O(n^{2})\\), even though the lower-order terms have much larger coefficients than the leading term. We need to find positive constants \\(c\\) and \\(n_{0}\\) such that \\(4n^{2}+100n+500\\leq cn^{2}\\) for all \\(n\\geq n_{0}\\). Dividing both sides by \\(n^{2}\\) gives \\(4+100/n+500/n^{2}\\leq c\\). This inequality is satisfied for many choices of \\(c\\) and \\(n_{0}\\). For example, if we choose \\(n_{0}=1\\), then this inequality holds for \\(c=604\\). If we choose \\(n_{0}=10\\), then \\(c=19\\) works, and choosing \\(n_{0}=100\\) allows us to use \\(c=5.05\\).\n\nWe can also use the formal definition of \\(O\\)-notation to show that the function \\(n^{3}-100n^{2}\\) does not belong to the set \\(O(n^{2})\\), even though the coefficient of \\(n^{2}\\) is a large negative number. If we had \\(n^{3}-100n^{2}=O(n^{2})\\), then there would be positive constants \\(c\\) and \\(n_{0}\\) such that \\(n^{3}-100n^{2}\\leq cn^{2}\\) for all \\(n\\geq n_{0}\\). Again, we divide both sides by \\(n^{2}\\), giving \\(n-100\\leq c\\). Regardless of what value we choose for the constant \\(c\\), this inequality does not hold for any value of \\(n>c+100\\).\n\n##### \\(\\Omega\\)-notation\n\nJust as \\(O\\)-notation provides an asymptotic _upper_ bound on a function, \\(\\Omega\\)-notation provides an _asymptotic lower bound_. For a given function \\(g(n)\\), we denote by \\(\\Omega(g(n))\\) (pronounced \"big-omega of \\(g\\) of \\(n\\)\" or sometimes just \"omega of \\(g\\) of \\(n\\)\") the set of functions\n\n\\[\\Omega(g(n))=\\{f(n):\\text{ there exist positive constants $c$ and $n_{0}$ such that}\\\\ 0\\leq cg(n)\\leq f(n)\\text{ for all $n\\geq n_{0}$}\\}\\text{.}\\]\n\nFigure 3.2(b) shows the intuition behind \\(\\Omega\\)-notation. For all values \\(n\\) at or to the right of \\(n_{0}\\), the value of \\(f(n)\\) is on or above \\(cg(n)\\).\n\nWe've already shown that \\(4n^{2}+100n+500=O(n^{2})\\). Now let's show that \\(4n^{2}+100n+500=\\Omega(n^{2})\\). We need to find positive constants \\(c\\) and \\(n_{0}\\) such that \\(4n^{2}+100n+500\\geq cn^{2}\\) for all \\(n\\geq n_{0}\\). As before, we divide both sides by \\(n^{2}\\)giving \\(4+100/n+500/n^{2}\\geq c\\). This inequality holds when \\(n_{0}\\) is any positive integer and \\(c=4\\).\n\nWhat if we had subtracted the lower-order terms from the \\(4n^{2}\\) term instead of adding them? What if we had a small coefficient for the \\(n^{2}\\) term? The function would still be \\(\\Omega(n^{2})\\). For example, let's show that \\(n^{2}/100-100n-500=\\Omega(n^{2})\\). Dividing by \\(n^{2}\\) gives \\(1/100-100/n-500/n^{2}\\geq c\\). We can choose any value for \\(n_{0}\\) that is at least 10,005 and find a positive value for \\(c\\). For example, when \\(n_{0}=10\\),005, we can choose \\(c=2.49\\times 10^{-9}\\). Yes, that's a tiny value for \\(c\\), but it is positive. If we select a larger value for \\(n_{0}\\), we can also increase \\(c\\). For example, if \\(n_{0}=100\\),000, then we can choose \\(c=0.0089\\). The higher the value of \\(n_{0}\\), the closer to the coefficient \\(1/100\\) we can choose \\(c\\).\n\n#### \\(\\Theta\\)-notation\n\nWe use \\(\\Theta\\)-notation for _asymptotically tight bounds_. For a given function \\(g(n)\\), we denote by \\(\\Theta(g(n))\\) (\"theta of \\(g\\)\") the set of functions\n\n\\(\\Theta(g(n))=\\{f(n):\\) there exist positive constants \\(c_{1},c_{2},\\) and \\(n_{0}\\) such that\n\n\\(0\\leq c_{1}g(n)\\leq f(n)\\leq c_{2}g(n)\\) for all \\(n\\geq n_{0}\\}\\).\n\nFigure 3.2(c) shows the intuition behind \\(\\Theta\\)-notation. For all values of \\(n\\) at and to the right of \\(n_{0}\\), the value of \\(f(n)\\) lies at or above \\(c_{1}g(n)\\) and at or below \\(c_{2}g(n)\\). In other words, for all \\(n\\geq n_{0}\\), the function \\(f(n)\\) is equal to \\(g(n)\\) to within constant factors.\n\nThe definitions of \\(O\\)-, \\(\\Omega\\)-, and \\(\\Theta\\)-notations lead to the following theorem, whose proof we leave as Exercise 3.2-4.\n\n**Theorem 3.1**: _For any two functions \\(f(n)\\) and \\(g(n)\\), we have \\(f(n)=\\Theta(g(n))\\) if and only if \\(f(n)=O(g(n))\\) and \\(f(n)=\\Omega(g(n))\\)._\n\nWe typically apply Theorem 3.1 to prove asymptotically tight bounds from asymptotic upper and lower bounds.\n\n#### Asymptotic notation and running times\n\nWhen you use asymptotic notation to characterize an algorithm's running time, make sure that the asymptotic notation you use is as precise as possible without overstating which running time it applies to. Here are some examples of using asymptotic notation properly and improperly to characterize running times.\n\nLet's start with insertion sort. We can correctly say that insertion sort's worst-case running time is \\(O(n^{2})\\), \\(\\Omega(n^{2})\\), and--due to Theorem 3.1\\(-\\Theta(n^{2})\\). Althoughall three ways to characterize the worst-case running times are correct, the \\(\\Theta(n^{2})\\) bound is the most precise and hence the most preferred. We can also correctly say that insertion sort's best-case running time is \\(O(n)\\), \\(\\Omega(n)\\), and \\(\\Theta(n)\\), again with \\(\\Theta(n)\\) the most precise and therefore the most preferred.\n\nHere is what we _cannot_ correctly say: insertion sort's running time is \\(\\Theta(n^{2})\\). That is an overstatement because by omitting \"worst-case\" from the statement, we're left with a blanket statement covering all cases. The error here is that insertion sort does not run in \\(\\Theta(n^{2})\\) time in all cases since, as we've seen, it runs in \\(\\Theta(n)\\) time in the best case. We can correctly say that insertion sort's running time is \\(O(n^{2})\\), however, because in all cases, its running time grows no faster than \\(n^{2}\\). When we say \\(O(n^{2})\\) instead of \\(\\Theta(n^{2})\\), there is no problem in having cases whose running time grows more slowly than \\(n^{2}\\). Likewise, we cannot correctly say that insertion sort's running time is \\(\\Theta(n)\\), but we can say that its running time is \\(\\Omega(n)\\).\n\nHow about merge sort? Since merge sort runs in \\(\\Theta(n\\lg n)\\) time in all cases, we can just say that its running time is \\(\\Theta(n\\lg n)\\) without specifying worst-case, best-case, or any other case.\n\nPeople occasionally conflate \\(O\\)-notation with \\(\\Theta\\)-notation by mistakenly using \\(O\\)-notation to indicate an asymptotically tight bound. They say things like \"an \\(O(n\\lg n)\\)-time algorithm runs faster than an \\(O(n^{2})\\)-time algorithm.\" Maybe it does, maybe it doesn't. Since \\(O\\)-notation denotes only an asymptotic upper bound, that so-called \\(O(n^{2})\\)-time algorithm might actually run in \\(\\Theta(n)\\) time. You should be careful to choose the appropriate asymptotic notation. If you want to indicate an asymptotically tight bound, use \\(\\Theta\\)-notation.\n\nWe typically use asymptotic notation to provide the simplest and most precise bounds possible. For example, if an algorithm has a running time of \\(3n^{2}+20n\\) in all cases, we use asymptotic notation to write that its running time is \\(\\Theta(n^{2})\\). Strictly speaking, we are also correct in writing that the running time is \\(O(n^{3})\\) or \\(\\Theta(3n^{2}+20n)\\). Neither of these expressions is as useful as writing \\(\\Theta(n^{2})\\) in this case, however: \\(O(n^{3})\\) is less precise than \\(\\Theta(n^{2})\\) if the running time is \\(3n^{2}+20n\\), and \\(\\Theta(3n^{2}+20n)\\) introduces complexity that obscures the order of growth. By writing the simplest and most precise bound, such as \\(\\Theta(n^{2})\\), we can categorize and compare different algorithms. Throughout the book, you will see asymptotic running times that are almost always based on polynomials and logarithms: functions such as \\(n\\), \\(n\\lg^{2}n\\), \\(n^{2}\\lg n\\), or \\(n^{1/2}\\). You will also see some other functions, such as exponentials, \\(\\lg\\lg n\\), and \\(\\lg^{*}n\\) (see Section 3.3). It is usually fairly easy to compare the rates of growth of these functions. Problem 3-3 gives you good practice.\n\n### Asymptotic notation in equations and inequalities\n\nAlthough we formally define asymptotic notation in terms of sets, we use the equal sign (=) instead of the set membership sign (\\(\\in\\)) within formulas. For example, we wrote that \\(4n^{2}+100n+500=O(n^{2})\\). We might also write \\(2n^{2}+3n+1=2n^{2}+\\Theta(n)\\). How do we interpret such formulas?\n\nWhen the asymptotic notation stands alone (that is, not within a larger formula) on the right-hand side of an equation (or inequality), as in \\(4n^{2}+100n+500=O(n^{2})\\), the equal sign means set membership: \\(4n^{2}+100n+500\\in O(n^{2})\\). In general, however, when asymptotic notation appears in a formula, we interpret it as standing for some anonymous function that we do not care to name. For example, the formula \\(2n^{2}+3n+1=2n^{2}+\\Theta(n)\\) means that \\(2n^{2}+3n+1=2n^{2}+f(n)\\), where \\(f(n)\\in\\Theta(n)\\). In this case, we let \\(f(n)=3n+1\\), which indeed belongs to \\(\\Theta(n)\\).\n\nUsing asymptotic notation in this manner can help eliminate inessential detail and clutter in an equation. For example, in Chapter 2 we expressed the worst-case running time of merge sort as the recurrence\n\n\\[T(n)=2T(n/2)+\\Theta(n)\\.\\]\n\nIf we are interested only in the asymptotic behavior of \\(T(n)\\), there is no point in specifying all the lower-order terms exactly, because they are all understood to be included in the anonymous function denoted by the term \\(\\Theta(n)\\).\n\nThe number of anonymous functions in an expression is understood to be equal to the number of times the asymptotic notation appears. For example, in the expression\n\n\\[\\sum_{i=1}^{n}O(i)\\,\\]\n\nthere is only a single anonymous function (a function of \\(i\\)). This expression is thus _not_ the same as \\(O(1)+O(2)+\\cdots+O(n)\\), which doesn't really have a clean interpretation.\n\nIn some cases, asymptotic notation appears on the left-hand side of an equation, as in\n\n\\[2n^{2}+\\Theta(n)=\\Theta(n^{2})\\.\\]\n\nInterpret such equations using the following rule: _No matter how the anonymous functions are chosen on the left of the equal sign, there is a way to choose the anonymous functions on the right of the equal sign to make the equation valid_. Thus, our example means that for _any_ function \\(f(n)\\in\\Theta(n)\\), there is _some_ function \\(g(n)\\in\\Theta(n^{2})\\) such that \\(2n^{2}+f(n)=g(n)\\) for all \\(n\\). In other words, the right-hand side of an equation provides a coarser level of detail than the left-hand side.\n\nWe can chain together a number of such relationships, as in\n\n\\[2n^{2}+3n+1 = 2n^{2}+\\Theta(n)\\] \\[= \\Theta(n^{2})\\.\\]\n\nBy the rules above, interpret each equation separately. The first equation says that there is _some_ function \\(f(n)\\in\\Theta(n)\\) such that \\(2n^{2}+3n+1=2n^{2}+f(n)\\) for all \\(n\\). The second equation says that for _any_ function \\(g(n)\\in\\Theta(n)\\) (such as the \\(f(n)\\) just mentioned), there is _some_ function \\(h(n)\\in\\Theta(n^{2})\\) such that \\(2n^{2}+g(n)=h(n)\\) for all \\(n\\). This interpretation implies that \\(2n^{2}+3n+1=\\Theta(n^{2})\\), which is what the chaining of equations intuitively says.\n\n#### Proper abuses of asymptotic notation\n\nBesides the abuse of equality to mean set membership, which we now see has a precise mathematical interpretation, another abuse of asymptotic notation occurs when the variable tending toward \\(\\infty\\) must be inferred from context. For example, when we say \\(O(g(n))\\), we can assume that we're interested in the growth of \\(g(n)\\) as \\(n\\) grows, and if we say \\(O(g(m))\\) we're talking about the growth of \\(g(m)\\) as \\(m\\) grows. The free variable in the expression indicates what variable is going to \\(\\infty\\).\n\nThe most common situation requiring contextual knowledge of which variable tends to \\(\\infty\\) occurs when the function inside the asymptotic notation is a constant, as in the expression \\(O(1)\\). We cannot infer from the expression which variable is going to \\(\\infty\\), because no variable appears there. The context must disambiguate. For example, if the equation using asymptotic notation is \\(f(n)=O(1)\\), it's apparent that the variable we're interested in is \\(n\\). Knowing from context that the variable of interest is \\(n\\), however, allows us to make perfect sense of the expression by using the formal definition of \\(O\\)-notation: the expression \\(f(n)=O(1)\\) means that the function \\(f(n)\\) is bounded from above by a constant as \\(n\\) goes to \\(\\infty\\). Technically, it might be less ambiguous if we explicitly indicated the variable tending to \\(\\infty\\) in the asymptotic notation itself, but that would clutter the notation. Instead, we simply ensure that the context makes it clear which variable (or variables) tend to \\(\\infty\\).\n\nWhen the function inside the asymptotic notation is bounded by a positive constant, as in \\(T(n)=O(1)\\), we often abuse asymptotic notation in yet another way, especially when stating recurrences. We may write something like \\(T(n)=O(1)\\) for \\(n<3\\). According to the formal definition of \\(O\\)-notation, this statement is meaningless, because the definition only says that \\(T(n)\\) is bounded above by a positive constant \\(c\\) for \\(n\\geq n_{0}\\) for some \\(n_{0}>0\\). The value of \\(T(n)\\) for \\(n<n_{0}\\) need not be so bounded. Thus, in the example \\(T(n)=O(1)\\) for \\(n<3\\), we cannot infer any constraint on \\(T(n)\\) when \\(n<3\\), because it might be that \\(n_{0}>3\\).\n\nWhat is conventionally meant when we say \\(T(n)=O(1)\\) for \\(n<3\\) is that there exists a positive constant \\(c\\) such that \\(T(n)\\leq c\\) for \\(n<3\\). This convention savesus the trouble of naming the bounding constant, allowing it to remain anonymous while we focus on more important variables in an analysis. Similar abuses occur with the other asymptotic notations. For example, \\(T(n)=\\Theta(1)\\) for \\(n<3\\) means that \\(T(n)\\) is bounded above and below by positive constants when \\(n<3\\).\n\nOccasionally, the function describing an algorithm's running time may not be defined for certain input sizes, for example, when an algorithm assumes that the input size is an exact power of 2. We still use asymptotic notation to describe the growth of the running time, understanding that any constraints apply only when the function is defined. For example, suppose that \\(f(n)\\) is defined only on a subset of the natural or nonnegative real numbers. Then \\(f(n)=O(g(n))\\) means that the bound \\(0\\leq T(n)\\leq cg(n)\\) in the definition of \\(O\\)-notation holds for all \\(n\\geq n_{0}\\) over the domain of \\(f(n)\\), that is, where \\(f(n)\\) is defined. This abuse is rarely pointed out, since what is meant is generally clear from context.\n\nIn mathematics, it's okay--and often desirable--to abuse a notation, as long as we don't misuse it. If we understand precisely what is meant by the abuse and don't draw incorrect conclusions, it can simplify our mathematical language, contribute to our higher-level understanding, and help us focus on what really matters.\n\n#### \\(o\\)-notation\n\nThe asymptotic upper bound provided by \\(O\\)-notation may or may not be asymptotically tight. The bound \\(2n^{2}=O(n^{2})\\) is asymptotically tight, but the bound \\(2n=O(n^{2})\\) is not. We use \\(o\\)-notation to denote an upper bound that is not asymptotically tight. We formally define \\(o(g(n))\\) (\"little-oh of \\(g\\) of \\(n\\)\") as the set\n\n\\[o(g(n))=\\{f(n):\\text{ for any positive constant }c>0,\\text{ there exists a constant }n_{0}>0\\text{ such that }0\\leq f(n)< cg(n)\\text{ for all }n\\geq n_{0}\\}\\.\\]\n\nFor example, \\(2n=o(n^{2})\\), but \\(2n^{2}\\neq o(n^{2})\\).\n\nThe definitions of \\(O\\)-notation and \\(o\\)-notation are similar. The main difference is that in \\(f(n)=O(g(n))\\), the bound \\(0\\leq f(n)\\leq cg(n)\\) holds for _some_ constant \\(c>0\\), but in \\(f(n)=o(g(n))\\), the bound \\(0\\leq f(n){<}cg(n)\\) holds for _all_ constants \\(c>0\\). Intuitively, in \\(o\\)-notation, the function \\(f(n)\\) becomes insignificant relative to \\(g(n)\\) as \\(n\\) gets large:\n\n\\[\\lim_{n\\to\\infty}\\frac{f(n)}{g(n)}=0\\.\\]\n\nSome authors use this limit as a definition of the \\(o\\)-notation, but the definition in this book also restricts the anonymous functions to be asymptotically nonnegative.\n\n\\(\\omega\\)-notation\n\nBy analogy, \\(\\omega\\)-notation is to \\(\\Omega\\)-notation as \\(o\\)-notation is to \\(O\\)-notation. We use \\(\\omega\\)-notation to denote a lower bound that is not asymptotically tight. One way to define it is by\n\n\\(f(n)\\in\\omega(g(n))\\) if and only if \\(g(n)\\in o(f(n))\\).\n\nFormally, however, we define \\(\\omega(g(n))\\) (\"little-omega of \\(g\\) of \\(n\\)\") as the set\n\n\\(\\omega(g(n))=\\{f(n):\\) for any positive constant \\(c>0\\), there exists a constant\n\n\\(n_{0}>0\\) such that \\(0\\leq cg(n)<f(n)\\) for all \\(n\\geq n_{0}\\}\\).\n\nWhere the definition of \\(o\\)-notation says that \\(f(n)<cg(n)\\), the definition of \\(\\omega\\)-notation says the opposite: that \\(cg(n)<f(n)\\). For examples of \\(\\omega\\)-notation, we have \\(n^{2}/2=\\omega(n)\\), but \\(n^{2}/2\\neq\\omega(n^{2})\\). The relation \\(f(n)=\\omega(g(n))\\) implies that\n\n\\(\\lim_{n\\to\\infty}\\frac{f(n)}{g(n)}=\\infty\\),\n\nif the limit exists. That is, \\(f(n)\\) becomes arbitrarily large relative to \\(g(n)\\) as \\(n\\) gets large.\n\n##### Comparing functions\n\nMany of the relational properties of real numbers apply to asymptotic comparisons as well. For the following, assume that \\(f(n)\\) and \\(g(n)\\) are asymptotically positive.\n\n**Transitivity:**\n\n\\(f(n)=\\Theta(g(n))\\) and \\(g(n)=\\Theta(h(n))\\) imply \\(f(n)=\\Theta(h(n))\\),\n\n\\(f(n)=O(g(n))\\) and \\(g(n)=O(h(n))\\) imply \\(f(n)=O(h(n))\\),\n\n\\(f(n)=\\Omega(g(n))\\) and \\(g(n)=\\Omega(h(n))\\) imply \\(f(n)=\\Omega(h(n))\\),\n\n\\(f(n)=o(g(n))\\) and \\(g(n)=o(h(n))\\) imply \\(f(n)=o(h(n))\\),\n\n\\(f(n)=\\omega(g(n))\\) and \\(g(n)=\\omega(h(n))\\) imply \\(f(n)=o(h(n))\\).\n\n**Reflexivity:**\n\n\\(f(n)=\\Theta(f(n))\\),\n\n\\(f(n)=O(f(n))\\),\n\n\\(f(n)=\\Omega(f(n))\\)\n\n**Symmetry:**\n\n\\(f(n)=\\Theta(g(n))\\) if and only if \\(g(n)=\\Theta(f(n))\\).\n\n**Transpose symmetry:**\n\n\\[f(n)\\ =\\ O(g(n))\\ \\ \\ \\mbox{if and only if}\\ \\ \\ g(n)\\ =\\ \\Omega(f(n))\\] \\[f(n)\\ =\\ o(g(n))\\ \\ \\ \\mbox{if and only if}\\ \\ \\ g(n)\\ =\\ \\omega(f(n))\\.\\]\n\nBecause these properties hold for asymptotic notations, we can draw an analogy between the asymptotic comparison of two functions \\(f\\) and \\(g\\) and the comparison of two real numbers \\(a\\) and \\(b\\):\n\n\\[f(n)\\ =\\ O(g(n))\\ \\ \\ \\mbox{is like}\\ \\ \\ a\\leq b\\,\\] \\[f(n)\\ =\\ \\Omega(g(n))\\ \\ \\ \\mbox{is like}\\ \\ \\ a\\geq b\\,\\] \\[f(n)\\ =\\ \\Theta(g(n))\\ \\ \\ \\mbox{is like}\\ \\ \\ a=b\\,\\] \\[f(n)\\ =\\ o(g(n))\\ \\ \\ \\mbox{is like}\\ \\ \\ a<b\\,\\] \\[f(n)\\ =\\ \\omega(g(n))\\ \\ \\ \\mbox{is like}\\ \\ \\ a>b\\.\\]\n\nWe say that \\(f(n)\\) is _asymptotically smaller_ than \\(g(n)\\) if \\(f(n)=o(g(n)),\\mbox{and}\\ f(n)\\) is _asymptotically larger_ than \\(g(n)\\) if \\(f(n)=\\omega(g(n))\\).\n\nOne property of real numbers, however, does not carry over to asymptotic notation:\n\n**Trichotomy:** For any two real numbers \\(a\\) and \\(b\\), exactly one of the following must hold: \\(a<b\\), \\(a=b\\), or \\(a>b\\).\n\nAlthough any two real numbers can be compared, not all functions are asymptotically comparable. That is, for two functions \\(f(n)\\) and \\(g(n)\\), it may be the case that neither \\(f(n)=O(g(n))\\) nor \\(f(n)=\\Omega(g(n))\\) holds. For example, we cannot compare the functions \\(n\\) and \\(n^{1+\\sin n}\\) using asymptotic notation, since the value of the exponent in \\(n^{1+\\sin n}\\) oscillates between 0 and 2, taking on all values in between.\n\n**Exercises**\n\n_3.2-1_\n\nLet \\(f(n)\\) and \\(g(n)\\) be asymptotically nonnegative functions. Using the basic definition of \\(\\Theta\\)-notation, prove that \\(\\max\\,\\{f(n),g(n)\\}=\\Theta(f(n)+g(n))\\).\n\n_3.2-2_\n\nExplain why the statement, \"The running time of algorithm \\(A\\) is at least \\(O(n^{2})\\),\" is meaningless.\n\n_3.2-3_\n\nIs \\(2^{n+1}=O(2^{n})\\)? Is \\(2^{2n}=O(2^{n})\\)?\n\n_3.2-4_\n\nProve Theorem 3.1.\n\n### Standard notations and common functions\n\nThis section reviews some standard mathematical functions and notations and explores the relationships among them. It also illustrates the use of the asymptotic notations.\n\n**Monotonicity**\n\nA function \\(f(n)\\) is _monotonically increasing_ if \\(m\\leq n\\) implies \\(f(m)\\leq f(n)\\). Similarly, it is _monotonically decreasing_ if \\(m\\leq n\\) implies \\(f(m)\\geq f(n)\\). A function \\(f(n)\\) is _strictly increasing_ if \\(m<n\\) implies \\(f(m)<f(n)\\) and _strictly decreasing_ if \\(m<n\\) implies \\(f(m)>f(n)\\).\n\n**Floors and ceilings**\n\nFor any real number \\(x\\), we denote the greatest integer less than or equal to \\(x\\) by \\(\\lfloor x\\rfloor\\) (read \"the floor of \\(x\\)\") and the least integer greater than or equal to \\(x\\) by \\(\\lceil x\\rceil\\) (read \"the ceiling of \\(x\\)\"). The floor function is monotonically increasing, as is the ceiling function.\n\nFloors and ceilings obey the following properties. For any integer \\(n\\), we have\n\n\\[\\lfloor n\\rfloor=n=\\lceil n\\rceil\\enspace. \\tag{3.1}\\]\n\nFor all real \\(x\\), we have",
        "chapter": "Part I Foundations",
        "section": "3 Characterizing Running Times",
        "subsection": "3.2 Asymptotic notation: formal definitions",
        "subsubsection": "N/A"
    },
    {
        "content": "### Standard notations and common functions\n\nThis section reviews some standard mathematical functions and notations and explores the relationships among them. It also illustrates the use of the asymptotic notations.\n\n**Monotonicity**\n\nA function \\(f(n)\\) is _monotonically increasing_ if \\(m\\leq n\\) implies \\(f(m)\\leq f(n)\\). Similarly, it is _monotonically decreasing_ if \\(m\\leq n\\) implies \\(f(m)\\geq f(n)\\). A function \\(f(n)\\) is _strictly increasing_ if \\(m<n\\) implies \\(f(m)<f(n)\\) and _strictly decreasing_ if \\(m<n\\) implies \\(f(m)>f(n)\\).\n\n**Floors and ceilings**\n\nFor any real number \\(x\\), we denote the greatest integer less than or equal to \\(x\\) by \\(\\lfloor x\\rfloor\\) (read \"the floor of \\(x\\)\") and the least integer greater than or equal to \\(x\\) by \\(\\lceil x\\rceil\\) (read \"the ceiling of \\(x\\)\"). The floor function is monotonically increasing, as is the ceiling function.\n\nFloors and ceilings obey the following properties. For any integer \\(n\\), we have\n\n\\[\\lfloor n\\rfloor=n=\\lceil n\\rceil\\enspace. \\tag{3.1}\\]\n\nFor all real \\(x\\), we have\\[x-1\\ <\\ \\lfloor x\\rfloor\\ \\leq\\ x\\ \\leq\\ \\lceil x\\rceil\\ <\\ x+1\\.\\] (3.2) We also have \\[-\\lfloor x\\rfloor=\\lceil-x\\rceil\\,\\] (3.3) or equivalently, \\[-\\lceil x\\rceil=\\lfloor-x\\rfloor\\.\\] (3.4) For any real number \\(x\\geq 0\\) and integers \\(a,b>0\\), we have \\[\\left\\lceil\\frac{\\lceil x/a\\rceil}{b}\\right\\rceil =\\ \\left\\lceil\\frac{x}{ab}\\right\\rceil\\, \\tag{3.5}\\] \\[\\left\\lfloor\\frac{\\lfloor x/a\\rfloor}{b}\\right\\rfloor =\\ \\left\\lfloor\\frac{x}{ab}\\right\\rfloor\\,\\] (3.6) \\[\\left\\lceil\\frac{a}{b}\\right\\rceil \\leq\\ \\frac{a+(b-1)}{b}\\,\\] (3.7) \\[\\left\\lfloor\\frac{a}{b}\\right\\rfloor \\geq\\ \\frac{a-(b-1)}{b}\\.\\] (3.8) For any integer \\(n\\) and real number \\(x\\), we have \\[\\lfloor n+x\\rfloor =\\ n+\\lfloor x\\rfloor\\,\\] (3.9) \\[\\lceil n+x\\rceil =\\ n+\\lceil x\\rceil. \\tag{3.10}\\]\n\n### 3.3 Modular arithmetic\n\nFor any integer \\(a\\) and any positive integer \\(n\\), the value \\(a\\) mod \\(n\\) is the _remainder_ (or _residue_) of the quotient \\(a/n\\):\n\n\\[a\\ {\\rm mod}\\ n=a-n\\ \\lfloor a/n\\rfloor. \\tag{3.11}\\]\n\nIt follows that\n\n\\[0\\leq a\\ {\\rm mod}\\ n<n\\, \\tag{3.12}\\]\n\neven when \\(a\\) is negative.\n\nGiven a well-defined notion of the remainder of one integer when divided by another, it is convenient to provide special notation to indicate equality of remainders. If \\((a\\ {\\rm mod}\\ n)=(b\\ {\\rm mod}\\ n)\\), we write \\(a=b\\ \\ ({\\rm mod}\\ n)\\) and say that \\(a\\) is _equivalent_ to \\(b\\), modulo \\(n\\). In other words, \\(a=b\\ \\ ({\\rm mod}\\ n)\\) if \\(a\\) and \\(b\\) have the same remainder when divided by \\(n\\). Equivalently, \\(a=b\\ \\ ({\\rm mod}\\ n)\\) if and only if \\(n\\) is a divisor of \\(b-a\\). We write \\(a\\neq b\\ \\ ({\\rm mod}\\ n)\\) if \\(a\\) is not equivalent to \\(b\\), modulo \\(n\\).\n\n### Polynomials\n\nGiven a nonnegative integer \\(d\\), a _polynomial in \\(n\\) of degree \\(d\\)_ is a function \\(p(n)\\) of the form\n\n\\[p(n)=\\sum_{i=0}^{d}a_{i}n^{i}\\,\\]\n\nwhere the constants \\(a_{0},a_{1},\\ldots,a_{d}\\) are the _coefficients_ of the polynomial and \\(a_{d}\\neq 0\\). A polynomial is asymptotically positive if and only if \\(a_{d}>0\\). For an asymptotically positive polynomial \\(p(n)\\) of degree \\(d\\), we have \\(p(n)=\\Theta(n^{d}).\\) For any real constant \\(a\\geq 0\\), the function \\(n^{a}\\) is monotonically increasing, and for any real constant \\(a\\leq 0\\), the function \\(n^{a}\\) is monotonically decreasing. We say that a function \\(f(n)\\) is _polynomially bounded_ if \\(f(n)=O(n^{k})\\) for some constant \\(k\\).\n\n### Exponentials\n\nFor all real \\(a>0,m\\), and \\(n\\), we have the following identities:\n\n\\(a^{0}\\ =\\ 1\\,\\)\n\n\\(a^{1}\\ =\\ a\\,\\)\n\n\\(a^{-1}\\ =\\ 1/a\\)\n\n\\((a^{m})^{n}\\ =\\ a^{mn}\\,\\)\n\n\\((a^{m})^{n}\\ =\\ (a^{n})^{m}\\,\\)\n\n\\(a^{m}a^{n}\\ =\\ a^{m+n}\\.\\)\n\nFor all \\(n\\) and \\(a\\geq 1\\), the function \\(a^{n}\\) is monotonically increasing in \\(n\\). When convenient, we assume that \\(0^{0}=1\\).\n\nWe can relate the rates of growth of polynomials and exponentials by the following fact. For all real constants \\(a>1\\) and \\(b\\), we have\n\n\\[\\lim_{n\\to\\infty}\\frac{n^{b}}{a^{n}}=0\\,\\]\n\nfrom which we can conclude that\n\n\\(n^{b}=o(a^{n})\\.\\)\n\nThus, any exponential function with a base strictly greater than \\(1\\) grows faster than any polynomial function.\n\nUsing \\(e\\) to denote \\(2.71828\\ldots\\), the base of the natural-logarithm function, we have for all real \\(x\\),\n\n\\[e^{x}=1+x+\\frac{x^{2}}{2!}+\\frac{x^{3}}{3!}+\\cdots=\\sum_{i=0}^{\\infty}\\frac{x ^{i}}{i!}\\,\\]where \"!\" denotes the factorial function defined later in this section. For all real, we have the inequality\n\n(3.14)\n\nwhere equality holds only when. When, we have the approximation\n\n(3.15)\n\nWhen, the approximation of by is quite good:\n\n(In this equation, the asymptotic notation is used to describe the limiting behavior as rather than as.) We have for all,\n\n(3.16)\n\n### Logarithms\n\nWe use the following notations:\n\nWe adopt the following notational convention: in the absence of parentheses, _a logarithm function applies only to the next term in the formula_, so that means ( and not ).\n\nFor any constant, the function is undefined if, strictly increasing if, negative if, positive if, and if. For all real,,, and, we have\n\n(3.17) (3.18) (3.19) (3.20) (3.21)By equation (3.19), changing the base of a logarithm from one constant to another changes the value of the logarithm by only a constant factor. Consequently, we often use the notation \"\\(\\lg n\\)\" when we don't care about constant factors, such as in \\(O\\)-notation. Computer scientists find 2 to be the most natural base for logarithms because so many algorithms and data structures involve splitting a problem into two parts.\n\nThere is a simple series expansion for \\(\\ln(1+x)\\) when \\(|x|<1\\):\n\n\\[\\ln(1+x)=x-\\frac{x^{2}}{2}+\\frac{x^{3}}{3}-\\frac{x^{4}}{4}+\\frac{x^{5}}{5}- \\cdots. \\tag{3.22}\\]\n\nWe also have the following inequalities for \\(x>-1\\):\n\n\\[\\frac{x}{1+x}\\ \\leq\\ \\ln(1+x)\\ \\leq\\ x\\, \\tag{3.23}\\]\n\nwhere equality holds only for \\(x=0\\).\n\nWe say that a function \\(f(n)\\) is _polylogarithmically bounded_ if \\(f(n)=O(\\lg^{k}n)\\) for some constant \\(k\\). We can relate the growth of polynomials and polylogarithms by substituting \\(\\lg n\\) for \\(n\\) and \\(2^{a}\\) for \\(a\\) in equation (3.13). For all real constants \\(a>0\\) and \\(b\\), we have\n\n\\[\\lg^{b}n=o(n^{a}). \\tag{3.24}\\]\n\nThus, any positive polynomial function grows faster than any polylogarithmic function.\n\n#### Factorials\n\nThe notation \\(n!\\) (read \"\\(n\\) factorial\") is defined for integers \\(n\\geq 0\\) as\n\n\\[n!=\\left\\{\\begin{array}{ll}1&\\mbox{if $n=0$}\\,\\\\ n\\cdot(n-1)!&\\mbox{if $n>0$}\\.\\end{array}\\right.\\]\n\nThus, \\(n!=1\\cdot 2\\cdot 3\\cdots n\\).\n\nA weak upper bound on the factorial function is \\(n!\\leq n^{n}\\), since each of the \\(n\\) terms in the factorial product is at most \\(n\\). _Stirling's approximation_,\n\n\\[n!=\\sqrt{2\\pi n}\\left(\\frac{n}{e}\\right)^{n}\\left(1+\\Theta\\left(\\frac{1}{n} \\right)\\right)\\, \\tag{3.25}\\]\n\nwhere \\(e\\) is the base of the natural logarithm, gives us a tighter upper bound, and a lower bound as well. Exercise 3.3-4 asks you to prove the three facts\n\n\\[n! = o(n^{n})\\, \\tag{3.26}\\] \\[n! = o(2^{n})\\,\\] (3.27) \\[\\lg(n!) = \\Theta(n\\lg n)\\, \\tag{3.28}\\]where Stirling's approximation is helpful in proving equation (3.28). The following equation also holds for all \\(n\\geq 1\\):\n\n\\[n!=\\sqrt{2\\pi\\,n}\\,\\Big{(}\\frac{n}{e}\\Big{)}^{n}\\,e^{\\alpha_{n}} \\tag{3.29}\\]\n\nwhere\n\n\\[\\frac{1}{12n\\,+\\,1}<\\alpha_{n}\\,<\\frac{1}{12n}\\.\\]\n\n##### Functional iteration\n\nWe use the notation \\(f^{(i)}(n)\\) to denote the function \\(f(n)\\) iteratively applied \\(i\\) times to an initial value of \\(n\\). Formally, let \\(f(n)\\) be a function over the reals. For non-negative integers \\(i\\), we recursively define\n\n\\[f^{(i)}(n)=\\left\\{\\begin{array}{ll}n&\\mbox{if $i\\,=\\,0$ },\\\\ f(f^{(i-1)}(n))&\\mbox{if $i\\,>\\,0$ }.\\end{array}\\right. \\tag{3.30}\\]\n\nFor example, if \\(f(n)=2n\\), then \\(f^{(i)}(n)=2^{i}n\\).\n\n##### The iterated logarithm function\n\nWe use the notation \\(\\lg^{*}n\\) (read \"log star of \\(n\\)\") to denote the iterated logarithm, defined as follows. Let \\(\\lg^{(i)}n\\) be as defined above, with \\(f(n)=\\lg n\\). Because the logarithm of a nonpositive number is undefined, \\(\\lg^{(i)}n\\) is defined only if \\(\\lg^{(i-1)}n>0\\). Be sure to distinguish \\(\\lg^{(i)}n\\) (the logarithm function applied \\(i\\) times in succession, starting with argument \\(n\\)) from \\(\\lg^{i}n\\) (the logarithm of \\(n\\) raised to the \\(i\\)th power). Then we define the iterated logarithm function as\n\n\\[\\lg^{*}n=\\min\\left\\{i\\,\\geq 0:\\lg^{(i)}n\\leq 1\\right\\}\\.\\]\n\nThe iterated logarithm is a _very_ slowly growing function:\n\n\\[\\lg^{*}2 = 1\\,\\] \\[\\lg^{*}4 = 2\\,\\] \\[\\lg^{*}16 = 3\\,\\] \\[\\lg^{*}65536 = 4\\,\\] \\[\\lg^{*}(2^{65536}) = 5\\.\\]\n\nSince the number of atoms in the observable universe is estimated to be about \\(10^{80}\\), which is much less than \\(2^{65536}=10^{65536/\\lg 10}\\approx 10^{19,728}\\), we rarely encounter an input size \\(n\\) for which \\(\\lg^{*}n>5\\).\n\n### Fibonacci numbers\n\nWe define the _Fibonacci numbers_\\(F_{i}\\), for \\(i\\,\\geq 0\\), as follows:\n\n\\[F_{i}\\,=\\,\\left\\{\\begin{array}{ll}0&\\mbox{if $i\\,=\\,0$,}\\\\ 1&\\mbox{if $i\\,=\\,1$,}\\\\ F_{i-1}+F_{i-2}&\\mbox{if $i\\,\\geq\\,2$.}\\end{array}\\right. \\tag{3.31}\\]\n\nThus, after the first two, each Fibonacci number is the sum of the two previous ones, yielding the sequence\n\n0,1,1,2,3,5,8,13,21,34,55,\\(\\ldots\\).\n\nFibonacci numbers are related to the _golden ratio_\\(\\phi\\) and its conjugate \\(\\widehat{\\phi}\\), which are the two roots of the equation\n\n\\(x^{2}\\,=\\,x\\,+\\,1\\).\n\nAs Exercise 3.3-7 asks you to prove, the golden ratio is given by\n\n\\[\\phi\\,=\\,\\frac{1\\,+\\,\\sqrt{5}}{2} \\tag{3.32}\\] \\[\\,=\\,1.61803\\ldots,\\]\n\nand its conjugate, by\n\n\\[\\widehat{\\phi}\\,=\\,\\frac{1\\,-\\,\\sqrt{5}}{2} \\tag{3.33}\\] \\[\\,=\\,-.61803\\ldots.\\]\n\nSpecifically, we have\n\n\\[F_{i}\\,=\\,\\frac{\\phi^{i}\\,-\\,\\widehat{\\phi}^{i}}{\\sqrt{5}}\\,\\]\n\nwhich can be proved by induction (Exercise 3.3-8). Since \\(\\left|\\widehat{\\phi}\\right|\\,<\\,1\\), we have\n\n\\[\\frac{\\left|\\widehat{\\phi}^{i}\\right|}{\\sqrt{5}} \\,<\\,\\frac{1}{\\sqrt{5}}\\] \\[\\,<\\,\\frac{1}{2}\\,\\]\n\nwhich implies that\n\n\\[F_{i}\\,=\\,\\left\\lfloor\\,\\frac{\\phi^{i}}{\\sqrt{5}}+\\frac{1}{2}\\,\\right\\rfloor\\, \\tag{3.34}\\]\n\nwhich is to say that the \\(i\\,\\)th Fibonacci number \\(F_{i}\\) is equal to \\(\\phi^{i}\\,/\\,\\sqrt{5}\\) rounded to the nearest integer. Thus, Fibonacci numbers grow exponentially.\n\n### Exercises\n\n#### 3.3-1\n\nShow that if \\(f(n)\\) and \\(g(n)\\) are monotonically increasing functions, then so are the functions \\(f(n)+g(n)\\) and \\(f(g(n))\\), and if \\(f(n)\\) and \\(g(n)\\) are in addition nonnegative, then \\(f(n)\\cdot g(n)\\) is monotonically increasing.\n\n#### 3.3-2\n\nProve that \\(\\lfloor\\alpha n\\rfloor+\\lceil(1-\\alpha)n\\rceil=n\\) for any integer \\(n\\) and real number \\(\\alpha\\) in the range \\(0\\leq\\alpha\\leq 1\\).\n\n#### 3.3-3\n\nUse equation (3.14) or other means to show that \\((n+o(n))^{k}=\\Theta(n^{k})\\) for any real constant \\(k\\). Conclude that \\(\\lceil n\\rceil^{k}=\\Theta(n^{k})\\) and \\(\\lfloor n\\rfloor^{k}=\\Theta(n^{k})\\).\n\n#### 3.3-4\n\nProve the following:\n\n_a._ Equation (3.21).\n\n_b._ Equations (3.26)-(3.28).\n\n_c._\\(\\lg(\\Theta(n))=\\Theta(\\lg n)\\).\n\n\\(\\bigstar\\) _3.3-5_\n\nIs the function \\(\\lceil\\lg n\\rceil!\\) polynomially bounded? Is the function \\(\\lceil\\lg\\lg n\\rceil!\\) polynomially bounded?\n\n\\(\\bigstar\\) _3.3-6_\n\nWhich is asymptotically larger: \\(\\lg(\\lg^{*}n)\\) or \\(\\lg^{*}(\\lg n)\\)?\n\n#### 3.3-7\n\nShow that the golden ratio \\(\\phi\\) and its conjugate \\(\\widehat{\\phi}\\) both satisfy the equation \\(x^{2}=x+1\\).\n\n#### 3.3-8\n\nProve by induction that the \\(i\\)th Fibonacci number satisfies the equation\n\n\\(F_{i}=(\\phi^{i}-\\widehat{\\phi}^{i})/\\sqrt{5}\\),\n\nwhere \\(\\phi\\) is the golden ratio and \\(\\widehat{\\phi}\\) is its conjugate.\n\n#### 3.3-9\n\nShow that \\(k\\lg k=\\Theta(n)\\) implies \\(k=\\Theta(n/\\lg n)\\).\n\n## Problems\n\n### Asymptotic behavior of polynomials\n\nLet\n\n\\[p(n)=\\sum_{i=0}^{d}a_{i}n^{i}\\,\\]\n\nwhere \\(a_{d}>0\\), be a degree-\\(d\\) polynomial in \\(n\\), and let \\(k\\) be a constant. Use the definitions of the asymptotic notations to prove the following properties.\n\n**a.**: If \\(k\\geq d\\), then \\(p(n)=O(n^{k})\\).\n**b.**: If \\(k\\leq d\\), then \\(p(n)=\\Omega(n^{k})\\).\n**c.**: If \\(k=d\\), then \\(p(n)=\\Theta(n^{k})\\).\n**d.**: If \\(k>d\\), then \\(p(n)=o(n^{k})\\).\n**e.**: If \\(k<d\\), then \\(p(n)=o(n^{k})\\).\n**3-2 Relative asymptotic growths**\n\nIndicate, for each pair of expressions \\((A,B)\\) in the table below whether \\(A\\) is \\(O\\), \\(o\\), \\(\\Omega\\), \\(\\omega\\), or \\(\\Theta\\) of \\(B\\). Assume that \\(k\\geq 1\\), \\(\\epsilon>0\\), and \\(c>1\\) are constants. Write your answer in the form of the table with \"yes\" or \"no\" written in each box.\n\n\\begin{tabular}{l c",
        "chapter": "Part I Foundations",
        "section": "3 Characterizing Running Times",
        "subsection": "3.3 Standard notations and common functions",
        "subsubsection": "N/A"
    },
    {
        "content": "## Problems\n\n### Asymptotic behavior of polynomials\n\nLet\n\n\\[p(n)=\\sum_{i=0}^{d}a_{i}n^{i}\\,\\]\n\nwhere \\(a_{d}>0\\), be a degree-\\(d\\) polynomial in \\(n\\), and let \\(k\\) be a constant. Use the definitions of the asymptotic notations to prove the following properties.\n\n**a.**: If \\(k\\geq d\\), then \\(p(n)=O(n^{k})\\).\n**b.**: If \\(k\\leq d\\), then \\(p(n)=\\Omega(n^{k})\\).\n**c.**: If \\(k=d\\), then \\(p(n)=\\Theta(n^{k})\\).\n**d.**: If \\(k>d\\), then \\(p(n)=o(n^{k})\\).\n**e.**: If \\(k<d\\), then \\(p(n)=o(n^{k})\\).\n**3-2 Relative asymptotic growths**\n\nIndicate, for each pair of expressions \\((A,B)\\) in the table below whether \\(A\\) is \\(O\\), \\(o\\), \\(\\Omega\\), \\(\\omega\\), or \\(\\Theta\\) of \\(B\\). Assume that \\(k\\geq 1\\), \\(\\epsilon>0\\), and \\(c>1\\) are constants. Write your answer in the form of the table with \"yes\" or \"no\" written in each box.\n\n\\begin{tabular}{l c \\[\\lg(\\lg^{*}n) 2\\;\\lg^{*\\,n} (\\sqrt{2})^{\\lg n} n^{2} n! (\\lg n)!\\] \\[(3/2)^{n} n^{3} \\lg^{2}n \\lg(n!) 2^{2^{n}} n^{1/\\lg n}\\] \\[\\ln\\ln n \\lg^{*}n n\\cdot 2^{n} n^{\\lg\\lg n} \\ln n 1\\] \\[2^{\\lg n} (\\lg n)^{\\lg n} e^{n} 4^{\\lg n} (n+1)! \\sqrt{\\lg n}\\] \\[\\lg^{*}(\\lg n) 2^{\\sqrt{2\\lg n}} n 2^{n} n\\lg n 2^{2^{n+1}}\\]\n\n_b._: Give an example of a single nonnegative function \\(f(n)\\) such that for all functions \\(g_{i}(n)\\) in part (a), \\(f(n)\\) is neither \\(O(g_{i}(n))\\) nor \\(\\Omega(g_{i}(n))\\).\n\n### Asymptotic notation properties\n\nLet \\(f(n)\\) and \\(g(n)\\) be asymptotically positive functions. Prove or disprove each of the following conjectures.\n\n_a._: \\(f(n)=O(g(n))\\) implies \\(g(n)=O(f(n))\\).\n\n_b._: \\(f(n)+g(n)=\\Theta(\\min\\{f(n),g(n)\\})\\).\n\n_c._: \\(f(n)=O(g(n))\\) implies \\(\\lg f(n)=O(\\lg g(n))\\), where \\(\\lg g(n)\\geq 1\\) and \\(f(n)\\geq 1\\) for all sufficiently large \\(n\\).\n\n_d._: \\(f(n)=O(g(n))\\) implies \\(2^{f(n)}=O\\left(2^{g(n)}\\right)\\).\n\n_e._: \\(f(n)=O\\left((f(n))^{2}\\right)\\).\n\n_f._: \\(f(n)=O(g(n))\\) implies \\(g(n)=\\Omega(\\_f(n))\\).\n\n_g._: \\(f(n)=\\Theta(f(n/2))\\).\n\n_h._: \\(f(n)+o(f(n))=\\Theta(f(n))\\).\n\n### Manipulating asymptotic notation\n\nLet \\(f(n)\\) and \\(g(n)\\) be asymptotically positive functions. Prove the following identities:\n\n_a._: \\(\\Theta(\\Theta(f(n)))=\\Theta(f(n))\\).\n\n_b._: \\(\\Theta(f(n))+O(f(n))=\\Theta(f(n))\\).\n\n_c._: \\(\\Theta(f(n))+\\Theta(g(n))=\\Theta(f(n)+g(n))\\).\n\n_d._: \\(\\Theta(f(n))\\cdot\\Theta(g(n))=\\Theta(f(n)\\cdot g(n))\\).\n\n_e._ Argue that for any real constants \\(a_{1},b_{1}>0\\) and integer constants \\(k_{1},k_{2}\\), the following asymptotic bound holds: \\((a_{1}n)^{k_{1}}\\,\\lg^{k_{2}}(a_{2}n)=\\Theta(n^{k_{1}}\\lg^{k_{2}}n)\\).\n* _f._ Prove that for \\(S\\subseteq\\mathbb{Z}\\), we have \\[\\sum_{k\\in S}\\Theta(f(k))=\\Theta\\left(\\sum_{k\\in S}f(k)\\right)\\,\\] assuming that both sums converge.\n* _g._ Show that for \\(S\\subseteq\\mathbb{Z}\\), the following asymptotic bound does not necessarily hold, even assuming that both products converge, by giving a counterexample: \\[\\prod_{k\\in S}\\Theta(f(k))=\\Theta\\left(\\prod_{k\\in S}f(k)\\right)\\.\\]\n\n_3-6 Variations on O and \\(\\Omega\\)_\n\nSome authors define \\(\\Omega\\)-notation in a slightly different way than this textbook does. We'll use the nomenclature \\(\\widetilde{\\Omega}\\) (read \"omega infinity\") for this alternative definition. We say that \\(f(n)=\\widetilde{\\Omega}(g(n))\\) if there exists a positive constant \\(c\\) such that \\(f(n)\\geq cg(n)\\geq 0\\) for infinitely many integers \\(n\\).\n\n_a._ Show that for any two asymptotically nonnegative functions \\(f(n)\\) and \\(g(n)\\), we have \\(f(n)=O(g(n))\\) or \\(f(n)=\\widetilde{\\Omega}(g(n))\\) (or both).\n\n_b._ Show that there exist two asymptotically nonnegative functions \\(f(n)\\) and \\(g(n)\\) for which neither \\(f(n)=O(g(n))\\) nor \\(f(n)=\\Omega(g(n))\\) holds.\n\n_c._ Describe the potential advantages and disadvantages of using \\(\\widetilde{\\Omega}\\)-notation instead of \\(\\Omega\\)-notation to characterize the running times of programs.\n\nSome authors also define \\(O\\) in a slightly different manner. We'll use \\(O^{\\prime}\\) for the alternative definition: \\(f(n)=O^{\\prime}(g(n))\\) if and only if \\(|f(n)|=O(g(n))\\).\n\n_d._ What happens to each direction of the \"if and only if\" in Theorem 3.1 on page 3.1 if we substitute \\(O^{\\prime}\\) for \\(O\\) but still use \\(\\Omega\\)?\n\nSome authors define \\(\\widetilde{O}\\) (read \"soft-oh\") to mean \\(O\\) with logarithmic factors ignored:\\(\\widetilde{O}(g(n))=\\{f(n):\\begin{array}{l}\\mbox{there exist positive constants $c$}\\,,k\\,,\\mbox{and}\\ n_{0}\\mbox{ such that}\\\\ 0\\leq f(n)\\leq cg(n)\\lg^{k}(n)\\mbox{ for all $n\\geq n_{0}$}\\}\\.\\end{array}\\)\n\n_e._ Define \\(\\widetilde{\\Omega}\\) and \\(\\widetilde{\\Theta}\\) in a similar manner. Prove the corresponding analog to Theorem 3.1.\n\n_3-7 Iterated functions_\n\nWe can apply the iteration operator \\({}^{*}\\) used in the \\(\\lg^{*}\\) function to any monotonically increasing function \\(f(n)\\) over the reals. For a given constant \\(c\\in\\mathbb{R}\\), we define the iterated function \\(f_{c}^{*}\\) by\n\n\\(f_{c}^{*}(n)=\\min\\left\\{i\\geq 0:\\,f^{(i)}(n)\\leq c\\right\\}\\,\\)\n\nwhich need not be well defined in all cases. In other words, the quantity \\(f_{c}^{*}(n)\\) is the minimum number of iterated applications of the function \\(f\\) required to reduce its argument down to \\(c\\) or less.\n\nFor each of the functions \\(f(n)\\) and constants \\(c\\) in the table below, give as tight a bound as possible on \\(f_{c}^{*}(n)\\). If there is no \\(i\\) such that \\(f^{(i)}(n)\\leq c\\), write \"undefined\" as your answer.\n\n\\begin{tabular}{l l l|l|l|}  & \\(f(n)\\) & \\(c\\) & \\(f_{c}^{*}(n)\\) \\\\ \\cline{2-4} _a._ & \\(n-1\\) & \\(0\\) & & \\\\ _b._ & \\(\\lg n\\) & \\(1\\) & & \\\\ _c._ & \\(n/2\\) & \\(1\\) & & \\\\ _d._ & \\(n/2\\) & \\(2\\) & & \\\\ _e._ & \\(\\sqrt{n}\\) & \\(2\\) & & \\\\ _f._ & \\(\\sqrt{n}\\) & \\(1\\) & & \\\\ _g._ & \\(n^{1/3}\\) & \\(2\\) & & \\\\ \\cline{2-4} \\end{tabular}\n\n**Chapter notes**\n\nKnuth [259] traces the origin of the \\(O\\)-notation to a number-theory text by P. Bachmann in 1892. The \\(o\\)-notation was invented by E. Landau in 1909 for his discussion of the distribution of prime numbers. The \\(\\Omega\\) and \\(\\Theta\\) notations were advocated by Knuth [265] to correct the popular, but technically sloppy, practice in the literature of using \\(O\\)-notation for both upper and lower bounds. As noted earlier in this chapter, many people continue to use the \\(O\\)-notation where the \\(\\Theta\\)-notation is more technically precise. The soft-oh notation \\(\\widetilde{O}\\) in Problem 3-6 was introduced",
        "chapter": "Part I Foundations",
        "section": "3 Characterizing Running Times",
        "subsection": "Problems",
        "subsubsection": "N/A"
    },
    {
        "content": "\\(\\widetilde{O}(g(n))=\\{f(n):\\begin{array}{l}\\mbox{there exist positive constants $c$}\\,,k\\,,\\mbox{and}\\ n_{0}\\mbox{ such that}\\\\ 0\\leq f(n)\\leq cg(n)\\lg^{k}(n)\\mbox{ for all $n\\geq n_{0}$}\\}\\.\\end{array}\\)\n\n_e._ Define \\(\\widetilde{\\Omega}\\) and \\(\\widetilde{\\Theta}\\) in a similar manner. Prove the corresponding analog to Theorem 3.1.\n\n_3-7 Iterated functions_\n\nWe can apply the iteration operator \\({}^{*}\\) used in the \\(\\lg^{*}\\) function to any monotonically increasing function \\(f(n)\\) over the reals. For a given constant \\(c\\in\\mathbb{R}\\), we define the iterated function \\(f_{c}^{*}\\) by\n\n\\(f_{c}^{*}(n)=\\min\\left\\{i\\geq 0:\\,f^{(i)}(n)\\leq c\\right\\}\\,\\)\n\nwhich need not be well defined in all cases. In other words, the quantity \\(f_{c}^{*}(n)\\) is the minimum number of iterated applications of the function \\(f\\) required to reduce its argument down to \\(c\\) or less.\n\nFor each of the functions \\(f(n)\\) and constants \\(c\\) in the table below, give as tight a bound as possible on \\(f_{c}^{*}(n)\\). If there is no \\(i\\) such that \\(f^{(i)}(n)\\leq c\\), write \"undefined\" as your answer.\n\n\\begin{tabular}{l l l|l|l|}  & \\(f(n)\\) & \\(c\\) & \\(f_{c}^{*}(n)\\) \\\\ \\cline{2-4} \\(a\\)**.** & \\(n-1\\) & \\(0\\) & & \\\\ \\cline{2-4} \\(b\\)**.** & \\(\\lg n\\) & \\(1\\) & & \\\\ \\cline{2-4} \\(c\\)**.** & \\(n/2\\) & \\(1\\) & & \\\\ \\cline{2-4} \\(d\\)**.** & \\(n/2\\) & \\(2\\) & & \\\\ \\cline{2-4} \\(e\\)**.** & \\(\\sqrt{n}\\) & \\(2\\) & & \\\\ \\cline{2-4} \\(f\\)**.** & \\(\\sqrt{n}\\) & \\(1\\) & & \\\\ \\cline{2-4} \\(g\\)**.** & \\(n^{1/3}\\) & \\(2\\) & & \\\\ \\cline{2-4} \\end{tabular}\n\n**Chapter notes**\n\nKnuth [259] traces the origin of the \\(O\\)-notation to a number-theory text by P. Bachmann in 1892. The \\(o\\)-notation was invented by E. Landau in 1909 for his discussion of the distribution of prime numbers. The \\(\\Omega\\) and \\(\\Theta\\) notations were advocated by Knuth [265] to correct the popular, but technically sloppy, practice in the literature of using \\(O\\)-notation for both upper and lower bounds. As noted earlier in this chapter, many people continue to use the \\(O\\)-notation where the \\(\\Theta\\)-notation is more technically precise. The soft-oh notation \\(\\widetilde{O}\\) in Problem 3-6 was introducedby Babai, Luks, and Seress [31], although it was originally written as \\(O\\!\\!\\sim\\). Some authors now define \\(\\widetilde{O}(g(n))\\) as ignoring factors that are logarithmic in \\(g(n)\\), rather than in \\(n\\). With this definition, we can say that \\(n2^{n}=\\widetilde{O}(2^{n})\\), but with the definition in Problem 3-6, this statement is not true. Further discussion of the history and development of asymptotic notations appears in works by Knuth [259, 265] and Brassard and Bratley [70].\n\nNot all authors define the asymptotic notations in the same way, although the various definitions agree in most common situations. Some of the alternative definitions encompass functions that are not asymptotically nonnegative, as long as their absolute values are appropriately bounded.\n\nEquation (3.29) is due to Robbins [381]. Other properties of elementary mathematical functions can be found in any good mathematical reference, such as Abramowitz and Stegun [1] or Zwillinger [468], or in a calculus book, such as Apostol [19] or Thomas et al. [433]. Knuth [259] and Graham, Knuth, and Patashnik [199] contain a wealth of material on discrete mathematics as used in computer science.\n\nThe divide-and-conquer method is a powerful strategy for designing asymptotically efficient algorithms. We saw an example of divide-and-conquer in Section 2.3.1 when learning about merge sort. In this chapter, we'll explore applications of the divide-and-conquer method and acquire valuable mathematical tools that you can use to solve the recurrences that arise when analyzing divide-and-conquer algorithms.\n\nRecall that for divide-and-conquer, you solve a given problem (instance) recursively. If the problem is small enough--the _base case_--you just solve it directly without recursing. Otherwise--the _recursive case_--you perform three characteristic steps:\n\n**Divide** the problem into one or more subproblems that are smaller instances of the same problem.\n\n**Conquer** the subproblems by solving them recursively.\n\n**Combine** the subproblem solutions to form a solution to the original problem.\n\nA divide-and-conquer algorithm breaks down a large problem into smaller subproblems, which themselves may be broken down into even smaller subproblems, and so forth. The recursion _bottoms out_ when it reaches a base case and the subproblem is small enough to solve directly without further recursing.\n\n#### Recurrences\n\nTo analyze recursive divide-and-conquer algorithms, we'll need some mathematical tools. A _recurrence_ is an equation that describes a function in terms of its value on other, typically smaller, arguments. Recurrences go hand in hand with the divide-and-conquer method because they give us a natural way to characterize the running times of recursive algorithms mathematically. You saw an example of a recurrence in Section 2.3.2 when we analyzed the worst-case running time of merge sort.",
        "chapter": "Part I Foundations",
        "section": "3 Characterizing Running Times",
        "subsection": "Chapter notes",
        "subsubsection": "N/A"
    },
    {
        "content": "### Solving recurrences\n\nAfter learning about divide-and-conquer algorithms for matrix multiplication in Sections 4.1 and 4.2, we'll explore several mathematical tools for solving recurrences -- that is, for obtaining asymptotic \\(\\Theta\\)-, \\(O\\)-, or \\(\\Omega\\)-bounds on their solutions. We want simple-to-use tools that can handle the most commonly occurring situations. But we also want general tools that work, perhaps with a little more effort, for less common cases. This chapter offers four methods for solving recurrences:\n\n* In the _substitution method_ (Section 4.3), you guess the form of a bound and then use mathematical induction to prove your guess correct and solve for constants. This method is perhaps the most robust method for solving recurrences, but it also requires you to make a good guess and to produce an inductive proof.\n* The _recursion-tree method_ (Section 4.4) models the recurrence as a tree whose nodes represent the costs incurred at various levels of the recursion. To solve the recurrence, you determine the costs at each level and add them up, perhaps using techniques for bounding summations from Section A.2. Even if you don't use this method to formally prove a bound, it can be helpful in guessing the form of the bound for use in the substitution method.\n* The _master method_ (Sections 4.5 and 4.6) is the easiest method, when it applies. It provides bounds for recurrences of the form \\[T(n)=a\\,T(n/b)+f(n)\\,\\] where \\(a>0\\) and \\(b>1\\) are constants and \\(f(n)\\) is a given \"driving\" function. This type of recurrence tends to arise more frequently in the study of algorithms than any other. It characterizes a divide-and-conquer algorithm that creates \\(a\\) subproblems, each of which is \\(1/b\\) times the size of the original problem, using \\(f(n)\\) time for the divide and combine steps. To apply the master method, you need to memorize three cases, but once you do, you can easily determine asymptotic bounds on running times for many divide-and-conquer algorithms.\n* The _Akra-Bazzi method_ (Section 4.7) is a general method for solving divide-and-conquer recurrences. Although it involves calculus, it can be used to attack more complicated recurrences than those addressed by the master method.\n\n### Multiplying square matrices\n\nWe can use the divide-and-conquer method to multiply square matrices. If you've seen matrices before, then you probably know how to multiply them. (Otherwise,you should read Section D.1.) Let \\(A=(a_{ik})\\) and \\(B=(b_{jk})\\) be square \\(n\\times n\\) matrices. The matrix product \\(C=A\\cdot B\\) is also an \\(n\\times n\\) matrix, where for \\(i,j=1,2,\\ldots,n\\), the \\((i,j)\\) entry of \\(C\\) is given by\n\n\\[c_{ij}=\\sum_{k=1}^{n}a_{ik}\\cdot b_{kj}. \\tag{4.1}\\]\n\nGenerally, we'll assume that the matrices are _dense_, meaning that most of the \\(n^{2}\\) entries are not \\(0\\), as opposed to _sparse_, where most of the \\(n^{2}\\) entries are \\(0\\) and the nonzero entries can be stored more compactly than in an \\(n\\times n\\) array.\n\nComputing the matrix \\(C\\) requires computing \\(n^{2}\\) matrix entries, each of which is the sum of \\(n\\) pairwise products of input elements from \\(A\\) and \\(B\\). The Matrix-Multiply procedure implements this strategy in a straightforward manner, and it generalizes the problem slightly. It takes as input three \\(n\\times n\\) matrices \\(A\\), \\(B\\), and \\(C\\), and it adds the matrix product \\(A\\cdot B\\) to \\(C\\), storing the result in \\(C\\). Thus, it computes \\(C=C+A\\cdot B\\), instead of just \\(C=A\\cdot B\\). If only the product \\(A\\cdot B\\) is needed, just initialize all \\(n^{2}\\) entries of \\(C\\) to \\(0\\) before calling the procedure, which takes an additional \\(\\Theta(n^{2})\\) time. We'll see that the cost of matrix multiplication asymptotically dominates this initialization cost.\n\nMatrix-Multiply (\\(A\\), \\(B\\), \\(C\\), \\(n\\))\n\n```\n1for\\(i=1\\)to\\(n\\)// compute entries in each of \\(n\\) rows\n2for\\(j=1\\)to\\(n\\)// compute \\(n\\) entries in row \\(i\\)\n3for\\(k=1\\)to\\(n\\)\n4\\(c_{ij}=c_{ij}+a_{ik}\\cdot b_{kj}\\)// add in another term of equation (4.1)\n```\n\nThe pseudocode for Matrix-Multiply works as follows. The **for** loop of lines 1-4 computes the entries of each row \\(i\\), and within a given row \\(i\\), the **for** loop of lines 2-4 computes each of the entries \\(c_{ij}\\) for each column \\(j\\). Each iteration of the **for** loop of lines 3-4 adds in one more term of equation (4.1).\n\nBecause each of the triply nested **for** loops runs for exactly \\(n\\) iterations, and each execution of line 4 takes constant time, the Matrix-Multiply procedure operates in \\(\\Theta(n^{3})\\) time. Even if we add in the \\(\\Theta(n^{2})\\) time for initializing \\(C\\) to \\(0\\), the running time is still \\(\\Theta(n^{3})\\).\n\n#### A simple divide-and-conquer algorithm\n\nLet's see how to compute the matrix product \\(A\\cdot B\\) using divide-and-conquer. For \\(n>1\\), the divide step partitions the \\(n\\times n\\) matrices into four \\(n/2\\times n/2\\) submatrices. We'll assume that \\(n\\) is an exact power of \\(2\\), so that as the algorithm recurses, we are guaranteed that the submatrix dimensions are integer. (Exercise 4.1-1 asks you to relax this assumption.) As with Matrix-Multiply, we'll actually compute \\(C=C+A\\cdot B\\). But to simplify the math behind the algorithm, let's assume that \\(C\\) has been initialized to the zero matrix, so that we are indeed computing \\(C=A\\cdot B\\).\n\nThe divide step views each of the \\(n\\times n\\) matrices \\(A\\), \\(B\\), and \\(C\\) as four \\(n/2\\times n/2\\) submatrices:\n\n\\[A=\\left(\\begin{array}{cc}A_{11}&A_{12}\\\\ A_{21}&A_{22}\\end{array}\\right),\\quad B=\\left(\\begin{array}{cc}B_{11}&B_{12 }\\\\ B_{21}&B_{22}\\end{array}\\right),\\quad C=\\left(\\begin{array}{cc}C_{11}&C_{12 }\\\\ C_{21}&C_{22}\\end{array}\\right). \\tag{4.2}\\]\n\nThen we can write the matrix product as\n\n\\[\\left(\\begin{array}{cc}C_{11}&C_{12}\\\\ C_{21}&C_{22}\\end{array}\\right) = \\left(\\begin{array}{cc}A_{11}&A_{12}\\\\ A_{21}&A_{22}\\end{array}\\right)\\!\\!\\left(\\begin{array}{cc}B_{11}&B_{12}\\\\ B_{21}&B_{22}\\end{array}\\right) \\tag{4.3}\\] \\[= \\left(\\begin{array}{cc}A_{11}\\cdot B_{11}+A_{12}\\cdot B_{21}&A_ {11}\\cdot B_{12}+A_{12}\\cdot B_{22}\\\\ A_{21}\\cdot B_{11}+A_{22}\\cdot B_{21}&A_{21}\\cdot B_{12}+A_{22}\\cdot B_{22} \\end{array}\\right), \\tag{4.4}\\]\n\nwhich corresponds to the equations\n\n\\[C_{11} = A_{11}\\cdot B_{11}+A_{12}\\cdot B_{21}\\, \\tag{4.5}\\] \\[C_{12} = A_{11}\\cdot B_{12}+A_{12}\\cdot B_{22}\\,\\] (4.6) \\[C_{21} = A_{21}\\cdot B_{11}+A_{22}\\cdot B_{21}\\,\\] (4.7) \\[C_{22} = A_{21}\\cdot B_{12}+A_{22}\\cdot B_{22}. \\tag{4.8}\\]\n\nEquations (4.5)-(4.8) involve eight \\(n/2\\times n/2\\) multiplications and four additions of \\(n/2\\times n/2\\) submatrices.\n\nAs we look to transform these equations to an algorithm that can be described with pseudocode, or even implemented for real, there are two common approaches for implementing the matrix partitioning.\n\nOne strategy is to allocate temporary storage to hold \\(A\\)'s four submatrices \\(A_{11}\\), \\(A_{12}\\), \\(A_{21}\\), and \\(A_{22}\\) and \\(B\\)'s four submatrices \\(B_{11}\\), \\(B_{12}\\), \\(B_{21}\\), and \\(B_{22}\\). Then copy each element in \\(A\\) and \\(B\\) to its corresponding location in the appropriate submatrix. After the recursive conquer step, copy the elements in each of \\(C\\)'s four submatrices \\(C_{11}\\), \\(C_{12}\\), \\(C_{21}\\), and \\(C_{22}\\) to their corresponding locations in \\(C\\). This approach takes \\(\\Theta(n^{2})\\) time, since \\(3n^{2}\\) elements are copied.\n\nThe second approach uses index calculations and is faster and more practical. A submatrix can be specified within a matrix by indicating where within the matrix the submatrix lies without touching any matrix elements. Partitioning a matrix (or recursively, a submatrix) only involves arithmetic on this location information, which has constant size independent of the size of the matrix. Changes to the submatrix elements update the original matrix, since they occupy the same storage.\n\nGoing forward, we'll assume that index calculations are used and that partitioning can be performed in \\(\\Theta(1)\\) time. Exercise 4.1-3 asks you to show that it makes no difference to the overall asymptotic running time of matrix multiplication, however, whether the partitioning of matrices uses the first method of copying or the second method of index calculation. But for other divide-and-conquer matrix calculations, such as matrix addition, it can make a difference, as Exercise 4.1-4 asks you to show.\n\nThe procedure Matrix-Multiply-Recursive uses equations (4.5)-(4.8) to implement a divide-and-conquer strategy for square-matrix multiplication. Like Matrix-Multiply, the procedure Matrix-Multiply-Recursive computes \\(C\\ =\\ C\\ +\\ A\\cdot B\\) since, if necessary, \\(C\\) can be initialized to 0 before the procedure is called in order to compute only \\(C\\ =\\ A\\cdot B\\).\n\nMatrix-Multiply-Recursive(\\(A,\\ B,C,n\\))\n\n```\n1if\\(n==1\\)\n2// Base case.\n3\\(c_{11}=c_{11}+a_{11}\\cdot b_{11}\\)\n4return\n5// Divide.\n6partition \\(A\\), \\(B\\), and \\(C\\) into \\(n/2\\times n/2\\) submatrices \\(A_{11}\\), \\(A_{12}\\), \\(A_{21}\\), \\(A_{22}\\); \\(B_{11}\\), \\(B_{12}\\), \\(B_{21}\\), \\(B_{22}\\);  and \\(C_{11}\\), \\(C_{12}\\), \\(C_{21}\\), \\(C_{22}\\); respectively\n7// Conquer.\n8Matrix-Multiply-Recursive(\\(A_{11}\\), \\(B_{11}\\), \\(C_{11}\\), \\(n/2\\))\n9Matrix-Multiply-Recursive(\\(A_{11}\\), \\(B_{12}\\), \\(C_{12}\\), \\(n/2\\))\n10Matrix-Multiply-Recursive(\\(A_{21}\\), \\(B_{11}\\), \\(C_{21}\\), \\(n/2\\))\n11Matrix-Multiply-Recursive(\\(A_{21}\\), \\(B_{12}\\), \\(C_{22}\\), \\(n/2\\))\n12Matrix-Multiply-Recursive(\\(A_{12}\\), \\(B_{21}\\), \\(C_{11}\\), \\(n/2\\))\n13Matrix-Multiply-Recursive(\\(A_{12}\\), \\(B_{22}\\), \\(C_{12}\\), \\(n/2\\))\n14Matrix-Multiply-Recursive(\\(A_{22}\\), \\(B_{21}\\), \\(C_{21}\\), \\(n/2\\))\n15Matrix-Multiply-Recursive(\\(A_{22}\\), \\(B_{22}\\), \\(C_{22}\\), \\(n/2\\))\n```\n\nAs we walk through the pseudocode, we'll derive a recurrence to characterize its running time. Let \\(T(n)\\) be the worst-case time to multiply two \\(n\\times n\\) matrices using this procedure.\n\nIn the base case, when \\(n=1\\), line 3 performs just the one scalar multiplication and one addition, which means that \\(T(1)=\\Theta(1)\\). As is our convention for constant base cases, we can omit this base case in the statement of the recurrence.\n\nThe recursive case occurs when \\(n>1\\). As discussed, we'll use index calculations to partition the matrices in line 6, taking \\(\\Theta(1)\\) time. Lines 8-15 recursively call Matrix-Multiply-Recursive a total of eight times. The first four recursive calls compute the first terms of equations (4.5)-(4.8), and the subsequent four recursive calls compute and add in the second terms. Each recursive call adds the product of a submatrix of \\(A\\) and a submatrix of \\(B\\) to the appropriate submatrixof \\(C\\) in place, thanks to index calculations. Because each recursive call multiplies two \\(n/2\\times n/2\\) matrices, thereby contributing \\(T(n/2)\\) to the overall running time, the time taken by all eight recursive calls is \\(8T(n/2)\\). There is no combine step, because the matrix \\(C\\) is updated in place. The total time for the recursive case, therefore, is the sum of the partitioning time and the time for all the recursive calls, or \\(\\Theta(1)+8T(n/2)\\).\n\nThus, omitting the statement of the base case, our recurrence for the running time of Matrix-Multiply-Recursive is\n\n\\[T(n)=8T(n/2)+\\Theta(1). \\tag{4.9}\\]\n\nAs we'll see from the master method in Section 4.5, recurrence (4.9) has the solution \\(T(n)=\\Theta(n^{3})\\), which means that it has the same asymptotic running time as the straightforward Matrix-Multiply procedure.\n\nWhy is the \\(\\Theta(n^{3})\\) solution to this recurrence so much larger than the \\(\\Theta(n\\lg n)\\) solution to the merge-sort recurrence (2.3) on page 41? After all, the recurrence for merge sort contains a \\(\\Theta(n)\\) term, whereas the recurrence for recursive matrix multiplication contains only a \\(\\Theta(1)\\) term.\n\nLet's think about what the recursion tree for recurrence (4.9) would look like as compared with the recursion tree for merge sort, illustrated in Figure 2.5 on page 43. The factor of 2 in the merge-sort recurrence determines how many children each tree node has, which in turn determines how many terms contribute to the sum at each level of the tree. In comparison, for the recurrence (4.9) for Matrix-Multiply-Recursive, each internal node in the recursion tree has eight children, not two, leading to a \"bushier\" recursion tree with many more leaves, despite the fact that the internal nodes are each much smaller. Consequently, the solution to recurrence (4.9) grows much more quickly than the solution to recurrence (2.3), which is borne out in the actual solutions: \\(\\Theta(n^{3})\\) versus \\(\\Theta(n\\lg n)\\).\n\n##### Exercises\n\n_Note:_ You may wish to read Section 4.5 before attempting some of these exercises.\n\n##### 4.1-1\n\nGeneralize Matrix-Multiply-Recursive to multiply \\(n\\times n\\) matrices for which \\(n\\) is not necessarily an exact power of 2. Give a recurrence describing its running time. Argue that it runs in \\(\\Theta(n^{3})\\) time in the worst case.\n\n##### 4.1-2\n\nHow quickly can you multiply a \\(k\\,n\\times n\\) matrix (\\(k\\,n\\) rows and \\(n\\) columns) by an \\(n\\times k\\,n\\) matrix, where \\(k\\geq 1\\), using Matrix-Multiply-Recursive as a subroutine? Answer the same question for multiplying an \\(n\\times k\\,n\\) matrix by a \\(k\\,n\\times n\\) matrix. Which is asymptotically faster, and by how much?\n\n### Strassen's algorithm for matrix multiplication\n\nYou might find it hard to imagine that any matrix multiplication algorithm could take less than \\(\\Theta(n^{3})\\) time, since the natural definition of matrix multiplication requires \\(n^{3}\\) scalar multiplications. Indeed, many mathematicians presumed that it was not possible to multiply matrices in \\(o(n^{3})\\) time until 1969, when V. Strassen [424] published a remarkable recursive algorithm for multiplying \\(n\\times n\\) matrices. Strassen's algorithm runs in \\(\\Theta(n^{\\lg 7})\\) time. Since \\(\\lg 7=2.8073549\\ldots\\), Strassen's algorithm runs in \\(O(n^{2.81})\\) time, which is asymptotically better than the \\(\\Theta(n^{3})\\) Matrix-Multiply and Matrix-Multiply-Recursive procedures.\n\nThe key to Strassen's method is to use the divide-and-conquer idea from the Matrix-Multiply-Recursive procedure, but make the recursion tree less bushy. We'll actually increase the work for each divide and combine step by a constant factor, but the reduction in bushiness will pay off. We won't reduce the bushiness from the eight-way branching of recurrence (4.9) all the way down to the two-way branching of recurrence (2.3), but we'll improve it just a little, and that will make a big difference. Instead of performing eight recursive multiplications of \\(n/2\\times n/2\\) matrices, Strassen's algorithm performs only seven. The cost of eliminating one matrix multiplication is several new additions and subtractions of \\(n/2\\times n/2\\) matrices, but still only a constant number. Rather than saying \"additions and subtractions\" everywhere, we'll adopt the common terminology of call",
        "chapter": "Part I Foundations",
        "section": "4 Divide-and-Conquer",
        "subsection": "4.1 Multiplying square matrices",
        "subsubsection": "N/A"
    },
    {
        "content": "### Strassen's algorithm for matrix multiplication\n\nYou might find it hard to imagine that any matrix multiplication algorithm could take less than \\(\\Theta(n^{3})\\) time, since the natural definition of matrix multiplication requires \\(n^{3}\\) scalar multiplications. Indeed, many mathematicians presumed that it was not possible to multiply matrices in \\(o(n^{3})\\) time until 1969, when V. Strassen [424] published a remarkable recursive algorithm for multiplying \\(n\\times n\\) matrices. Strassen's algorithm runs in \\(\\Theta(n^{\\lg 7})\\) time. Since \\(\\lg 7=2.8073549\\ldots\\), Strassen's algorithm runs in \\(O(n^{2.81})\\) time, which is asymptotically better than the \\(\\Theta(n^{3})\\) Matrix-Multiply and Matrix-Multiply-Recursive procedures.\n\nThe key to Strassen's method is to use the divide-and-conquer idea from the Matrix-Multiply-Recursive procedure, but make the recursion tree less bushy. We'll actually increase the work for each divide and combine step by a constant factor, but the reduction in bushiness will pay off. We won't reduce the bushiness from the eight-way branching of recurrence (4.9) all the way down to the two-way branching of recurrence (2.3), but we'll improve it just a little, and that will make a big difference. Instead of performing eight recursive multiplications of \\(n/2\\times n/2\\) matrices, Strassen's algorithm performs only seven. The cost of eliminating one matrix multiplication is several new additions and subtractions of \\(n/2\\times n/2\\) matrices, but still only a constant number. Rather than saying \"additions and subtractions\" everywhere, we'll adopt the common terminology of calling them both \"additions\" because subtraction is structurally the same computation as addition, except for a change of sign.\n\nTo get an inkling how the number of multiplications might be reduced, as well as why reducing the number of multiplications might be desirable for matrix calculations, suppose that you have two numbers \\(x\\) and \\(y\\), and you want to calculate the quantity \\(x^{2}-y^{2}\\). The straightforward calculation requires two multiplications to square \\(x\\) and \\(y\\), followed by one subtraction (which you can think of as a \"negative addition\"). But let's recall the old algebra trick \\(x^{2}-y^{2}=x^{2}-xy+xy-y^{2}=x(x-y)+y(x-y)=(x+y)(x-y)\\). Using this formulation of the desired quantity, you could instead compute the sum \\(x+y\\) and the difference \\(x-y\\) and then multiply them, requiring only a single multiplication and two additions. At the cost of an extra addition, only one multiplication is needed to compute an expression that looks as if it requires two. If \\(x\\) and \\(y\\) are scalars, there's not much difference: both approaches require three scalar operations. If \\(x\\) and \\(y\\) are large matrices, however, the cost of multiplying outweighs the cost of adding, in which case the second method outperforms the first, although not asymptotically.\n\nStrassen's strategy for reducing the number of matrix multiplications at the expense of more matrix additions is not at all obvious--perhaps the biggest understatement in this book! As with Matrix-Multiply-Recursive, Strassen's algorithm uses the divide-and-conquer method to compute \\(C=C+A\\cdot B\\), where \\(A\\), \\(B\\), and \\(C\\) are all \\(n\\times n\\) matrices and \\(n\\) is an exact power of 2. Strassen's algorithm computes the four submatrices \\(C_{11}\\), \\(C_{12}\\), \\(C_{21}\\), and \\(C_{22}\\) of \\(C\\) from equations (4.5)-(4.8) on page 82 in four steps. We'll analyze costs as we go along to develop a recurrence \\(T(n)\\) for the overall running time. Let's see how it works:\n\n1. If \\(n=1\\), the matrices each contain a single element. Perform a single scalar multiplication and a single scalar addition, as in line 3 of Matrix-Multiply-Recursive, taking \\(\\Theta(1)\\) time, and return. Otherwise, partition the input matrices \\(A\\) and \\(B\\) and output matrix \\(C\\) into \\(n/2\\times n/2\\) submatrices, as in equation (4.2). This step takes \\(\\Theta(1)\\) time by index calculation, just as in Matrix-Multiply-Recursive.\n2. Create \\(n/2\\times n/2\\) matrices \\(S_{1},S_{2},\\ldots,S_{10}\\), each of which is the sum or difference of two submatrices from step 1. Create and zero the entries of seven \\(n/2\\times n/2\\) matrices \\(P_{1}\\), \\(P_{2},\\ldots,P_{7}\\) to hold seven \\(n/2\\times n/2\\) matrix products. All 17 matrices can be created, and the \\(P_{i}\\) initialized, in \\(\\Theta(n^{2})\\) time.\n3. Using the submatrices from step 1 and the matrices \\(S_{1}\\), \\(S_{2},\\ldots,S_{10}\\) created in step 2, recursively compute each of the seven matrix products \\(P_{1}\\), \\(P_{2},\\ldots,P_{7}\\), taking \\(7T(n/2)\\) time.\n4. Update the four submatrices \\(C_{11}\\), \\(C_{12}\\), \\(C_{21}\\), \\(C_{22}\\) of the result matrix \\(C\\) by adding or subtracting various \\(P_{i}\\) matrices, which takes \\(\\Theta(n^{2})\\) time.\n\nWe'll see the details of steps 2-4 in a moment, but we already have enough information to set up a recurrence for the running time of Strassen's method. As is common, the base case in step 1 takes \\(\\Theta(1)\\) time, which we'll omit when stating the recurrence. When \\(n>1\\), steps 1, 2, and 4 take a total of \\(\\Theta(n^{2})\\) time, and step 3 requires seven multiplications of \\(n/2\\times n/2\\) matrices. Hence, we obtain the following recurrence for the running time of Strassen's algorithm:\n\n\\[T(n)=7T(n/2)+\\Theta(n^{2}). \\tag{4.10}\\]\n\nCompared with Matrix-Multiply-Recursive, we have traded off one recursive submatrix multiplication for a constant number of submatrix additions. Once you understand recurrences and their solutions, you'll be able to see why this trade-off actually leads to a lower asymptotic running time. By the master method in Section 4.5, recurrence (4.10) has the solution \\(T(n)=\\Theta(n^{\\lg 7})=O(n^{2.81})\\), beating the \\(\\Theta(n^{3})\\)-time algorithms.\n\nNow, let's delve into the details. Step 2 creates the following 10 matrices:\n\n\\[S_{1} = B_{12}-B_{22}\\,\\] \\[S_{2} = A_{11}+A_{12}\\,\\] \\[S_{3} = A_{21}+A_{22}\\,\\] \\[S_{4} = B_{21}-B_{11}\\,\\] \\[S_{5} = A_{11}+A_{22}\\,\\] \\[S_{6} = B_{11}+B_{22}\\,\\] \\[S_{7} = A_{12}-A_{22}\\,\\] \\[S_{8} = B_{21}+B_{22}\\,\\] \\[S_{9} = A_{11}-A_{21}\\,\\] \\[S_{10} = B_{11}+B_{12}\\.\\]\n\nThis step adds or subtracts \\(n/2\\times n/2\\) matrices 10 times, taking \\(\\Theta(n^{2})\\) time.\n\nStep 3 recursively multiplies \\(n/2\\times n/2\\) matrices 7 times to compute the following \\(n/2\\times n/2\\) matrices, each of which is the sum or difference of products of \\(A\\) and \\(B\\) submatrices:\n\n\\[P_{1} = A_{11}\\cdot S_{1}\\ \\ (=\\ A_{11}\\cdot B_{12}-A_{11}\\cdot B_{22})\\,\\] \\[P_{2} = S_{2}\\cdot B_{22}\\ \\ (=\\ A_{11}\\cdot B_{22}+A_{12}\\cdot B_{22})\\,\\] \\[P_{3} = S_{3}\\cdot B_{11}\\ \\ (=\\ A_{21}\\cdot B_{11}+A_{22}\\cdot B_{11})\\,\\] \\[P_{4} = A_{22}\\cdot S_{4}\\ \\ (=\\ A_{22}\\cdot B_{21}-A_{22}\\cdot B_{11})\\,\\] \\[P_{5} = S_{5}\\cdot S_{6}\\ \\ \\ (=\\ A_{11}\\cdot B_{11}+A_{11}\\cdot B_{22}+A_{22} \\cdot B_{11}+A_{22}\\cdot B_{22})\\,\\] \\[P_{6} = S_{7}\\cdot S_{8}\\ \\ \\ (=\\ A_{12}\\cdot B_{21}+A_{12}\\cdot B_{22}-A_{22} \\cdot B_{21}-A_{22}\\cdot B_{22})\\,\\] \\[P_{7} = S_{9}\\cdot S_{10}\\ \\ (=\\ A_{11}\\cdot B_{11}+A_{11}\\cdot B_{12}-A_{21} \\cdot B_{11}-A_{21}\\cdot B_{12})\\.\\]The only multiplications that the algorithm performs are those in the middle column of these equations. The right-hand column just shows what these products equal in terms of the original submatrices created in step 1, but the terms are never explicitly calculated by the algorithm.\n\nStep 4 adds to and subtracts from the four \\(n/2\\times n/2\\) submatrices of the product \\(C\\) the various \\(P_{i}\\) matrices created in step 3. We start with\n\n\\(C_{11}=C_{11}+P_{5}+P_{4}-P_{2}+P_{6}\\).\n\nExpanding the calculation on the right-hand side, with the expansion of each \\(P_{i}\\) on its own line and vertically aligning terms that cancel out, we see that the update to \\(C_{11}\\) equals\n\n\\(A_{11}\\cdot B_{11}+A_{11}\\cdot B_{22}+A_{22}\\cdot B_{11}+A_{22}\\cdot B_{22}\\)\n\n\\(-A_{22}\\cdot B_{11}\\)\\(-A_{12}\\cdot B_{22}\\)\n\n\\(-A_{22}\\cdot B_{22}-A_{22}\\cdot B_{21}+A_{12}\\cdot B_{22}+A_{12}\\cdot B_{21}\\)\n\n\\(A_{11}\\cdot B_{11}\\)\\(+A_{12}\\cdot B_{21}\\)\n\nwhich corresponds to equation (4.5). Similarly, setting\n\n\\(C_{12}=C_{12}+P_{1}+P_{2}\\)\n\nmeans that the update to \\(C_{12}\\) equals\n\n\\(A_{11}\\cdot B_{12}-A_{11}\\cdot B_{22}\\)\n\n\\(+A_{11}\\cdot B_{22}+A_{12}\\cdot B_{22}\\)\n\n\\(A_{11}\\cdot B_{12}\\)\\(+A_{12}\\cdot B_{22}\\),\n\ncorresponding to equation (4.6). Setting\n\n\\(C_{21}=C_{21}+P_{3}+P_{4}\\)\n\nmeans that the update to \\(C_{21}\\) equals\n\n\\(A_{21}\\cdot B_{11}+A_{22}\\cdot B_{11}\\)\n\n\\(-A_{22}\\cdot B_{11}+A_{22}\\cdot B_{21}\\)\n\n\\(A_{21}\\cdot B_{11}\\)\\(+A_{22}\\cdot B_{21}\\),\n\ncorresponding to equation (4.7). Finally, setting\n\n\\(C_{22}=C_{22}+P_{5}+P_{1}-P_{3}-P_{7}\\)\n\nmeans that the update to \\(C_{22}\\) equals\n\n### Strassen's algorithm for matrix multiplication\n\n\\[A_{11}\\cdot B_{11}+A_{11}\\cdot B_{22}+A_{22}\\cdot B_{11}+A_{22}\\cdot B_{22}\\\\ -A_{11}\\cdot B_{22}\\\\ -A_{22}\\cdot B_{11}\\\\ -A_{11}\\cdot B_{11}\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad-A_{21}\\cdot B _{11}\\\\ -A_{11}\\cdot B_{12}+A_{21}\\cdot B_{11}+A_{21}\\cdot B_{12}\\\\ \\\\ A_{22}\\cdot B_{22}\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad+A_{21}\\cdot B_{12}\\,\\]\n\nwhich corresponds to equation (4.8). Altogether, since we add or subtract \\(n/2\\times n/2\\) matrices 12 times in step 4, this step indeed takes \\(\\Theta(n^{2})\\) time.\n\nWe can see that Strassen's remarkable algorithm, comprising steps 1-4, produces the correct matrix product using 7 submatrix multiplications and 18 submatrix additions. We can also see that recurrence (4.10) characterizes its running time. Since Section 4.5 shows that this recurrence has the solution \\(T(n)=\\Theta(n^{\\lg 7})=o(n^{3})\\), Strassen's method asymptotically beats the \\(\\Theta(n^{3})\\) Matrix-Multiply and Matrix-Multiply-Recursive procedures.\n\n#### Exercises\n\n_Note:_ You may wish to read Section 4.5 before attempting some of these exercises.\n\n#### 4.2-1\n\nUse Strassen's algorithm to compute the matrix product\n\n\\[\\left(\\begin{array}{cc}1&3\\\\ 7&5\\end{array}\\right)\\left(\\begin{array}{cc}6&8\\\\ 4&2\\end{array}\\right)\\,.\\]\n\nShow your work.\n\n#### 4.2-2\n\nWrite pseudocode for Strassen's algorithm.\n\n#### 4.2-3\n\nWhat is the largest \\(k\\) such that if you can multiply \\(3\\times 3\\) matrices using \\(k\\) multiplications (not assuming commutativity of multiplication), then you can multiply \\(n\\times n\\) matrices in \\(o(n^{\\lg 7})\\) time? What is the running time of this algorithm?\n\n#### 4.2-4\n\nV. Pan discovered a way of multiplying \\(68\\times 68\\) matrices using 132,464 multiplications, a way of multiplying \\(70\\times 70\\) matrices using 143,640 multiplications, and a way of multiplying \\(72\\times 72\\) matrices using 155,424 multiplications. Which method yields the best asymptotic running time when used in a divide-and-conquer matrix-multiplication algorithm? How does it compare with Strassen's algorithm?\n\n#### 4.2-5\n\nShow how to multiply the complex numbers \\(a+bi\\) and \\(c+d\\,i\\) using only three multiplications of real numbers. The algorithm should take \\(a,b,c\\), and \\(d\\) as input and produce the real component \\(ac-bd\\) and the imaginary component \\(ad+bc\\) separately.\n\n#### 4.2-6\n\nSuppose that you have a \\(\\Theta(n^{\\alpha})\\)-time algorithm for squaring \\(n\\times n\\) matrices, where \\(\\alpha\\geq 2\\). Show how to use that algorithm to multiply two different \\(n\\times n\\) matrices in \\(\\Theta(n^{\\alpha})\\) time.\n\n### 4.3 The substitution method for solving recurrences\n\nNow that you have seen how recurrences characterize the running times of divide-and-conquer algorithms, let's learn how to solve them. We start in this section with the _substitution method_, which is the most general of the four methods in this chapter. The substitution method comprises two steps:\n\n1. Guess the form of the solution using symbolic constants.\n2. Use mathematical induction to show that the solution works, and find the constants.\n\nTo apply the inductive hypothesis, you substitute the guessed solution for the function on smaller values--hence the name \"substitution method.\" This method is powerful, but you must guess the form of the answer. Although generating a good guess might seem difficult, a little practice can quickly improve your intuition.\n\nYou can use the substitution method to establish either an upper or a lower bound on a recurrence. It's usually best not to try to do both at the same time. That is, rather than trying to prove a \\(\\Theta\\)-bound directly, first prove an \\(O\\)-bound, and then prove an \\(\\Omega\\)-bound. Together, they give you a \\(\\Theta\\)-bound (Theorem 3.1 on page 4.2).\n\nAs an example of the substitution method, let's determine an asymptotic upper bound on the recurrence:\n\n\\[T(n)=2T(\\lfloor n/2\\rfloor)+\\Theta(n). \\tag{4.11}\\]\n\nThis recurrence is similar to recurrence (2.3) on page 4.2 for merge sort, except for the floor function, which ensures that \\(T(n)\\) is defined over the integers. Let's guess that the asymptotic upper bound is the same--\\(T(n)=O(n\\lg n)\\)--and use the substitution method to prove it.\n\nWe'll adopt the inductive hypothesis that \\(T(n)\\leq cn\\lg n\\) for all \\(n\\geq n_{0}\\), where we'll choose the specific constants \\(c>0\\) and \\(n_{0}>0\\) later, after we see what",
        "chapter": "Part I Foundations",
        "section": "4 Divide-and-Conquer",
        "subsection": "4.2 Strassen\u2019s algorithm for matrix multiplication",
        "subsubsection": "N/A"
    },
    {
        "content": "#### 4.2-5\n\nShow how to multiply the complex numbers \\(a+bi\\) and \\(c+d\\,i\\) using only three multiplications of real numbers. The algorithm should take \\(a,b,c\\), and \\(d\\) as input and produce the real component \\(ac-bd\\) and the imaginary component \\(ad+bc\\) separately.\n\n#### 4.2-6\n\nSuppose that you have a \\(\\Theta(n^{\\alpha})\\)-time algorithm for squaring \\(n\\times n\\) matrices, where \\(\\alpha\\geq 2\\). Show how to use that algorithm to multiply two different \\(n\\times n\\) matrices in \\(\\Theta(n^{\\alpha})\\) time.\n\n### 4.3 The substitution method for solving recurrences\n\nNow that you have seen how recurrences characterize the running times of divide-and-conquer algorithms, let's learn how to solve them. We start in this section with the _substitution method_, which is the most general of the four methods in this chapter. The substitution method comprises two steps:\n\n1. Guess the form of the solution using symbolic constants.\n2. Use mathematical induction to show that the solution works, and find the constants.\n\nTo apply the inductive hypothesis, you substitute the guessed solution for the function on smaller values--hence the name \"substitution method.\" This method is powerful, but you must guess the form of the answer. Although generating a good guess might seem difficult, a little practice can quickly improve your intuition.\n\nYou can use the substitution method to establish either an upper or a lower bound on a recurrence. It's usually best not to try to do both at the same time. That is, rather than trying to prove a \\(\\Theta\\)-bound directly, first prove an \\(O\\)-bound, and then prove an \\(\\Omega\\)-bound. Together, they give you a \\(\\Theta\\)-bound (Theorem 3.1 on page 4.2).\n\nAs an example of the substitution method, let's determine an asymptotic upper bound on the recurrence:\n\n\\[T(n)=2T(\\lfloor n/2\\rfloor)+\\Theta(n). \\tag{4.11}\\]\n\nThis recurrence is similar to recurrence (2.3) on page 4.2 for merge sort, except for the floor function, which ensures that \\(T(n)\\) is defined over the integers. Let's guess that the asymptotic upper bound is the same--\\(T(n)=O(n\\lg n)\\)--and use the substitution method to prove it.\n\nWe'll adopt the inductive hypothesis that \\(T(n)\\leq cn\\lg n\\) for all \\(n\\geq n_{0}\\), where we'll choose the specific constants \\(c>0\\) and \\(n_{0}>0\\) later, after we see whatconstraints they need to obey. If we can establish this inductive hypothesis, we can conclude that \\(T(n)=O(n\\lg n)\\). It would be dangerous to use \\(T(n)=O(n\\lg n)\\) as the inductive hypothesis because the constants matter, as we'll see in a moment in our discussion of pitfalls.\n\nAssume by induction that this bound holds for all numbers at least as big as \\(n_{0}\\) and less than \\(n\\). In particular, therefore, if \\(n\\geq 2n_{0}\\), it holds for \\(\\lfloor n/2\\rfloor\\), yielding \\(T(\\lfloor n/2\\rfloor)\\leq c\\,\\lfloor n/2\\rfloor\\lg(\\lfloor n/2\\rfloor)\\). Substituting into recurrence (4.11)--hence the name \"substitution\" method--yields\n\n\\[T(n) \\leq\\ 2(c\\,\\lfloor n/2\\rfloor\\lg(\\lfloor n/2\\rfloor))+\\Theta(n)\\] \\[\\leq\\ 2(c(n/2)\\lg(n/2))+\\Theta(n)\\] \\[=\\ cn\\lg(n/2)+\\Theta(n)\\] \\[=\\ cn\\lg n-cn\\lg 2+\\Theta(n)\\] \\[=\\ cn\\lg n-cn+\\Theta(n)\\] \\[\\leq\\ cn\\lg n\\,\\]\n\nwhere the last step holds if we constrain the constants \\(n_{0}\\) and \\(c\\) to be sufficiently large that for \\(n\\geq 2n_{0}\\), the quantity \\(cn\\) dominates the anonymous function hidden by the \\(\\Theta(n)\\) term.\n\nWe've shown that the inductive hypothesis holds for the inductive case, but we also need to prove that the inductive hypothesis holds for the base cases of the induction, that is, that \\(T(n)\\leq cn\\lg n\\) when \\(n_{0}\\leq n<2n_{0}\\). As long as \\(n_{0}>1\\) (a new constraint on \\(n_{0}\\)), we have \\(\\lg n>0\\), which implies that \\(n\\lg n>0\\). So let's pick \\(n_{0}=2\\). Since the base case of recurrence (4.11) is not stated explicitly, by our convention, \\(T(n)\\) is algorithmic, which means that \\(T(2)\\) and \\(T(3)\\) are constant (as they should be if they describe the worst-case running time of any real program on inputs of size 2 or 3). Picking \\(c=\\max\\,\\{T(2),T(3)\\}\\) yields \\(T(2)\\leq c<(2\\lg 2)c\\) and \\(T(3)\\leq c<(3\\lg 3)c\\), establishing the inductive hypothesis for the base cases.\n\nThus, we have \\(T(n)\\leq cn\\lg n\\) for all \\(n\\geq 2\\), which implies that the solution to recurrence (4.11) is \\(T(n)=O(n\\lg n)\\).\n\nIn the algorithms literature, people rarely carry out their substitution proofs to this level of detail, especially in their treatment of base cases. The reason is that for most algorithmic divide-and-conquer recurrences, the base cases are all handled in pretty much the same way. You ground the induction on a range of values from a convenient positive constant \\(n_{0}\\) up to some constant \\(n^{\\prime}_{0}>n_{0}\\) such that for \\(n\\geq n^{\\prime}_{0}\\), the recurrence always bottoms out in a constant-sized base case between \\(n_{0}\\) and \\(n^{\\prime}_{0}\\). (This example used \\(n^{\\prime}_{0}=2n_{0}\\).) Then, it's usually apparent, without spelling out the details, that with a suitably large choice of the leading constant (such as \\(c\\) for this example), the inductive hypothesis can be made to hold for all the values in the range from \\(n_{0}\\) to \\(n^{\\prime}_{0}\\).\n\n### Making a good guess\n\nUnfortunately, there is no general way to correctly guess the tightest asymptotic solution to an arbitrary recurrence. Making a good guess takes experience and, occasionally, creativity. Fortunately, learning some recurrence-solving heuristics, as well as playing around with recurrences to gain experience, can help you become a good guesser. You can also use recursion trees, which we'll see in Section 4.4, to help generate good guesses.\n\nIf a recurrence is similar to one you've seen before, then guessing a similar solution is reasonable. As an example, consider the recurrence\n\n\\(T(n)=2T(n/2+17)+\\Theta(n)\\),\n\ndefined on the reals. This recurrence looks somewhat like the merge-sort recurrence (2.3), but it's more complicated because of the added \"17\" in the argument to \\(T\\) on the right-hand side. Intuitively, however, this additional term shouldn't substantially affect the solution to the recurrence. When \\(n\\) is large, the relative difference between \\(n/2\\) and \\(n/2+17\\) is not that large: both cut \\(n\\) nearly in half. Consequently, it makes sense to guess that \\(T(n)=O(n\\lg n)\\), which you can verify is correct using the substitution method (see Exercise 4.3-1).\n\nAnother way to make a good guess is to determine loose upper and lower bounds on the recurrence and then reduce your range of uncertainty. For example, you might start with a lower bound of \\(T(n)=\\Omega(n)\\) for recurrence (4.11), since the recurrence includes the term \\(\\Theta(n)\\), and you can prove an initial upper bound of \\(T(n)=O(n^{2})\\). Then split your time between trying to lower the upper bound and trying to raise the lower bound until you converge on the correct, asymptotically tight solution, which in this case is \\(T(n)=\\Theta(n\\lg n)\\).\n\n### A trick of the trade: subtracting a low-order term\n\nSometimes, you might correctly guess a tight asymptotic bound on the solution of a recurrence, but somehow the math fails to work out in the induction proof. The problem frequently turns out to be that the inductive assumption is not strong enough. The trick to resolving this problem is to revise your guess by _subtracting_ a lower-order term when you hit such a snag. The math then often goes through.\n\nConsider the recurrence\n\n\\[T(n)=2T(n/2)+\\Theta(1) \\tag{4.12}\\]\n\ndefined on the reals. Let's guess that the solution is \\(T(n)=O(n)\\) and try to show that \\(T(n)\\leq cn\\) for \\(n\\geq n_{0}\\), where we choose the constants \\(c,n_{0}>0\\) suitably. Substituting our guess into the recurrence, we obtain\n\n\\[T(n) \\leq 2(c(n/2))+\\Theta(1)\\] \\[= cn+\\Theta(1)\\,\\]which, unfortunately, does not imply that \\(T(n)\\leq cn\\) for _any_ choice of \\(c\\). We might be tempted to try a larger guess, say \\(T(n)=O(n^{2})\\). Although this larger guess works, it provides only a loose upper bound. It turns out that our original guess of \\(T(n)=O(n)\\) is correct and tight. In order to show that it is correct, however, we must strengthen our inductive hypothesis.\n\nIntuitively, our guess is nearly right: we are off only by \\(\\Theta(1)\\), a lower-order term. Nevertheless, mathematical induction requires us to prove the _exact_ form of the inductive hypothesis. Let's try our trick of subtracting a lower-order term from our previous guess: \\(T(n)\\leq cn-d\\), where \\(d\\geq 0\\) is a constant. We now have\n\n\\[T(n) \\leq\\ 2(c(n/2)-d)\\ +\\ \\Theta(1)\\] \\[=\\ cn-2d\\ +\\ \\Theta(1)\\] \\[\\leq\\ cn-d\\ -(d-\\Theta(1))\\] \\[\\leq\\ cn-d\\]\n\nas long as we choose \\(d\\) to be larger than the anonymous upper-bound constant hidden by the \\(\\Theta\\)-notation. Subtracting a lower-order term works! Of course, we must not forget to handle the base case, which is to choose the constant \\(c\\) large enough that \\(cn-d\\) dominates the implicit base cases.\n\nYou might find the idea of subtracting a lower-order term to be counterintuitive. After all, if the math doesn't work out, shouldn't you increase your guess? Not necessarily! When the recurrence contains more than one recursive invocation (recurrence (4.12) contains two), if you add a lower-order term to the guess, then you end up adding it once for each of the recursive invocations. Doing so takes you even further away from the inductive hypothesis. On the other hand, if you subtract a lower-order term from the guess, then you get to subtract it once for each of the recursive invocations. In the above example, we subtracted the constant \\(d\\) twice because the coefficient of \\(T(n/2)\\) is 2. We ended up with the inequality \\(T(n)\\leq cn-d-(d-\\Theta(1))\\), and we readily found a suitable value for \\(d\\).\n\n#### Avoiding pitfalls\n\nAvoid using asymptotic notation in the inductive hypothesis for the substitution method because it's error prone. For example, for recurrence (4.11), we can falsely \"prove\" that \\(T(n)=O(n)\\) if we unwisely adopt \\(T(n)=O(n)\\) as our inductive hypothesis:\n\n\\[T(n) \\leq\\ 2\\cdot O(\\lfloor n/2\\rfloor)+\\ \\Theta(n)\\] \\[=\\ 2\\cdot O(n)\\ +\\ \\Theta(n)\\] \\[=\\ O(n)\\.\\hskip 28.452756pt\\Longleftarrow\\mbox{\\it wrong}!\\]The problem with this reasoning is that the constant hidden by the \\(O\\)-notation changes. We can expose the fallacy by repeating the \"proof\" using an explicit constant. For the inductive hypothesis, assume that \\(T(n)\\leq cn\\) for all \\(n\\geq n_{0}\\), where \\(c,n_{0}>0\\) are constants. Repeating the first two steps in the inequality chain yields\n\n\\[T(n) \\leq 2(c\\ \\lfloor n/2\\rfloor)\\ +\\ \\Theta(n)\\] \\[\\leq cn\\ +\\ \\Theta(n)\\.\\]\n\nNow, indeed \\(c\\,n+\\Theta(n)\\,=\\,O(n)\\), but the constant hidden by the \\(O\\)-notation must be larger than \\(c\\) because the anonymous function hidden by the \\(\\Theta(n)\\) is asymptotically positive. We cannot take the third step to conclude that \\(cn\\ +\\ \\Theta(n)\\leq cn\\), thus exposing the fallacy.\n\nWhen using the substitution method, or more generally mathematical induction, you must be careful that the constants hidden by any asymptotic notation are the same constants throughout the proof. Consequently, it's best to avoid asymptotic notation in your inductive hypothesis and to name constants explicitly.\n\nHere's another fallacious use of the substitution method to show that the solution to recurrence (4.11) is \\(T(n)\\,=\\,O(n)\\). We guess \\(T(n)\\leq cn\\) and then argue\n\n\\[T(n) \\leq 2(c\\ \\lfloor n/2\\rfloor)\\ +\\ \\Theta(n)\\] \\[\\leq cn\\ +\\ \\Theta(n)\\] \\[= O(n)\\,\\qquad\\quad\\Longleftarrow wrong!\\]\n\nsince \\(c\\) is a positive constant. The mistake stems from the difference between our goal--to prove that \\(T(n)\\,=\\,O(n)\\)--and our inductive hypothesis--to prove that \\(T(n)\\,\\leq\\,cn\\). When using the substitution method, or in any inductive proof, you must prove the _exact_ statement of the inductive hypothesis. In this case, we must explicitly prove that \\(T(n)\\,\\leq\\,cn\\) to show that \\(T(n)\\,=\\,O(n)\\).\n\n#### Exercises\n\n_4.3-1_\n\nUse the substitution method to show that each of the following recurrences defined on the reals has the asymptotic solution specified:\n\n_a._\\(T(n)\\,=\\,T(n-1)+n\\) has solution \\(T(n)\\,=\\,O(n^{2})\\).\n\n_b._\\(T(n)\\,=\\,T(n/2)\\ +\\ \\Theta(1)\\) has solution \\(T(n)\\,=\\,O(\\lg n)\\).\n\n_c._\\(T(n)\\,=\\,2T(n/2)\\ +\\ n\\) has solution \\(T(n)\\,=\\,\\Theta(n\\lg n)\\).\n\n_d._\\(T(n)\\,=\\,2T(n/2+17)\\ +\\ n\\) has solution \\(T(n)\\,=\\,O(n\\lg n)\\).\n\n_e._\\(T(n)\\,=\\,2T(n/3)\\ +\\ \\Theta(n)\\) has solution \\(T(n)\\,=\\,\\Theta(n)\\).\n\n_f._\\(T(n)\\,=\\,4T(n/2)\\ +\\ \\Theta(n)\\) has solution \\(T(n)\\,=\\,\\Theta(n^{2})\\).\n\n### The recursion-tree method for solving recurrences\n\nThe solution to the recurrence \\(T(n)=4T(n/2)+n\\) turns out to be \\(T(n)=\\Theta(n^{2})\\). Show that a substitution proof with the assumption \\(T(n)\\leq cn^{2}\\) fails. Then show how to subtract a lower-order term to make a substitution proof work.\n\n#### 4.3-3\n\nThe recurrence \\(T(n)=2T(n-1)+1\\) has the solution \\(T(n)=O(2^{n})\\). Show that a substitution proof fails with the assumption \\(T(n)\\leq c2^{n}\\), where \\(c>0\\) is constant. Then show how to subtract a lower-order term to make a substitution proof work.\n\n### The recursion-tree method for solving recurrences\n\nAlthough you can use the substitution method to prove that a solution to a recurrence is correct, you might have trouble coming up with a good guess. Drawing out a recursion tree, as we did in our analysis of the merge-sort recurrence in Section 2.3.2, can help. In a _recursion tree_, each node represents the cost of a single subproblem somewhere in the set of recursive function invocations. You typically sum the costs within each level of the tree to obtain the per-level costs, and then you sum all the per-level costs to determine the total cost of all levels of the recursion. Sometimes, however, adding up the total cost takes more creativity.\n\nA recursion tree is best used to generate intuition for a good guess, which you can then verify by the substitution method. If you are meticulous when drawing out a recursion tree and summing the costs, however, you can use a recursion tree as a direct proof of a solution to a recurrence. But if you use it only to generate a good guess, you can often tolerate a small amount of \"sloppiness,\" which can simplify the math. When you verify your guess with the substitution method later on, your math should be precise. This section demonstrates how you can use recursion trees to solve recurrences, generate good guesses, and gain intuition for recurrences.\n\n### An illustrative example\n\nLet's see how a recursion tree can provide a good guess for an upper-bound solution to the recurrence\n\n\\[T(n)=3T(n/4)+\\Theta(n^{2}). \\tag{4.13}\\]\n\nFigure 4.1 shows how to derive the recursion tree for \\(T(n)=3T(n/4)+cn^{2}\\), where the constant \\(c>0\\) is the upper-bound constant in the \\(\\Theta(n^{2})\\) term. Part (a) of the figure shows \\(T(n)\\), which part (b) expands into an equivalent tree representing the recurrence. The \\(cn^{2}\\) term at the root represents the cost at the top level of recursion, and the three subtrees of the root represent the costs incurred by the",
        "chapter": "Part I Foundations",
        "section": "4 Divide-and-Conquer",
        "subsection": "4.3 The substitution method for solving recurrences",
        "subsubsection": "N/A"
    },
    {
        "content": "### The recursion-tree method for solving recurrences\n\nThe solution to the recurrence \\(T(n)=4T(n/2)+n\\) turns out to be \\(T(n)=\\Theta(n^{2})\\). Show that a substitution proof with the assumption \\(T(n)\\leq cn^{2}\\) fails. Then show how to subtract a lower-order term to make a substitution proof work.\n\n#### 4.3-3\n\nThe recurrence \\(T(n)=2T(n-1)+1\\) has the solution \\(T(n)=O(2^{n})\\). Show that a substitution proof fails with the assumption \\(T(n)\\leq c2^{n}\\), where \\(c>0\\) is constant. Then show how to subtract a lower-order term to make a substitution proof work.\n\n### The recursion-tree method for solving recurrences\n\nAlthough you can use the substitution method to prove that a solution to a recurrence is correct, you might have trouble coming up with a good guess. Drawing out a recursion tree, as we did in our analysis of the merge-sort recurrence in Section 2.3.2, can help. In a _recursion tree_, each node represents the cost of a single subproblem somewhere in the set of recursive function invocations. You typically sum the costs within each level of the tree to obtain the per-level costs, and then you sum all the per-level costs to determine the total cost of all levels of the recursion. Sometimes, however, adding up the total cost takes more creativity.\n\nA recursion tree is best used to generate intuition for a good guess, which you can then verify by the substitution method. If you are meticulous when drawing out a recursion tree and summing the costs, however, you can use a recursion tree as a direct proof of a solution to a recurrence. But if you use it only to generate a good guess, you can often tolerate a small amount of \"sloppiness,\" which can simplify the math. When you verify your guess with the substitution method later on, your math should be precise. This section demonstrates how you can use recursion trees to solve recurrences, generate good guesses, and gain intuition for recurrences.\n\n### An illustrative example\n\nLet's see how a recursion tree can provide a good guess for an upper-bound solution to the recurrence\n\n\\[T(n)=3T(n/4)+\\Theta(n^{2}). \\tag{4.13}\\]\n\nFigure 4.1 shows how to derive the recursion tree for \\(T(n)=3T(n/4)+cn^{2}\\), where the constant \\(c>0\\) is the upper-bound constant in the \\(\\Theta(n^{2})\\) term. Part (a) of the figure shows \\(T(n)\\), which part (b) expands into an equivalent tree representing the recurrence. The \\(cn^{2}\\) term at the root represents the cost at the top level of recursion, and the three subtrees of the root represent the costs incurred by theFigure 4.1: Constructing a recursion tree for the recurrence \\(T(n)=3T(n/4)+cn^{2}\\). Part **(a)** shows \\(T(n)\\), which progressively expands in **(b)\u2013(d)** to form the recursion tree. The fully expanded tree in **(d)** has height \\(\\log_{4}n\\).\n\nsubproblems of size \\(n/4\\). Part (c) shows this process carried one step further by expanding each node with cost \\(T(n/4)\\) from part (b). The cost for each of the three children of the root is \\(c(n/4)^{2}\\). We continue expanding each node in the tree by breaking it into its constituent parts as determined by the recurrence.\n\nBecause subproblem sizes decrease by a factor of \\(4\\) every time we go down one level, the recursion must eventually bottom out in a base case where \\(n<n_{0}\\). By convention, the base case is \\(T(n)=\\Theta(1)\\) for \\(n<n_{0}\\), where \\(n_{0}>0\\) is any threshold constant sufficiently large that the recurrence is well defined. For the purpose of intuition, however, let's simplify the math a little. Let's assume that \\(n\\) is an exact power of \\(4\\) and that the base case is \\(T(1)=\\Theta(1)\\). As it turns out, these assumptions don't affect the asymptotic solution.\n\nWhat's the height of the recursion tree? The subproblem size for a node at depth \\(i\\) is \\(n/4^{i}\\). As we descend the tree from the root, the subproblem size hits \\(n=1\\) when \\(n/4^{i}=1\\) or, equivalently, when \\(i=\\log_{4}n\\). Thus, the tree has internal nodes at depths \\(0,1,2,\\ldots,\\log_{4}n-1\\) and leaves at depth \\(\\log_{4}n\\).\n\nPart (d) of Figure 4.1 shows the cost at each level of the tree. Each level has three times as many nodes as the level above, and so the number of nodes at depth \\(i\\) is \\(3^{i}\\). Because subproblem sizes reduce by a factor of \\(4\\) for each level further from the root, each internal node at depth \\(i=0,1,2,\\ldots,\\log_{4}n-1\\) has a cost of \\(c(n/4^{i})^{2}\\). Multiplying, we see that the total cost of all nodes at a given depth \\(i\\) is \\(3^{i}c(n/4^{i})^{2}=(3/16)^{i}cn^{2}\\). The bottom level, at depth \\(\\log_{4}n\\), contains \\(3^{\\log_{4}n}=n^{\\log_{4}3}\\) leaves (using equation (3.21) on page 66). Each leaf contributes \\(\\Theta(1)\\), leading to a total leaf cost of \\(\\Theta(n^{\\log_{4}3})\\).\n\nNow we add up the costs over all levels to determine the cost for the entire tree:\n\n\\[T(n) = cn^{2}+\\frac{3}{16}\\,cn^{2}+\\left(\\frac{3}{16}\\right)^{2}cn^{2}+ \\cdots+\\left(\\frac{3}{16}\\right)^{\\log_{4}n}\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\! \\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\! \\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\! \\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\! \\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\! \\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\! \\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\! \\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\! \\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\! \\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\! \\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\! \\!\\!the root's contribution to the total cost is \\(cn^{2}\\), the cost of the root dominates the total cost of the tree.\n\nIn fact, if \\(O(n^{2})\\) is indeed an upper bound for the recurrence (as we'll verify in a moment), then it must be a tight bound. Why? The first recursive call contributes a cost of \\(\\Theta(n^{2})\\), and so \\(\\Omega(n^{2})\\) must be a lower bound for the recurrence.\n\nLet's now use the substitution method to verify that our guess is correct, namely, that \\(T(n)\\,=\\,O(n^{2})\\) is an upper bound for the recurrence \\(T(n)\\,=\\,3T(n/4)+\\Theta(n^{2})\\). We want to show that \\(T(n)\\,\\leq\\,dn^{2}\\) for some constant \\(d\\,>\\,0\\). Using the same constant \\(c\\,>\\,0\\) as before, we have\n\n\\[T(n) \\leq\\ 3T(n/4)\\,+\\,cn^{2}\\] \\[\\leq\\ 3d(n/4)^{2}\\,+\\,cn^{2}\\] \\[=\\ \\frac{3}{16}\\,d\\,n^{2}\\,+\\,cn^{2}\\] \\[\\leq\\ d\\,n^{2}\\,\\]\n\nwhere the last step holds if we choose \\(d\\,\\geq\\,(16/13)c\\).\n\nFor the base case of the induction, let \\(n_{0}\\,>\\,0\\) be a sufficiently large threshold constant that the recurrence is well defined when \\(T(n)\\,=\\,\\Theta(1)\\) for \\(n\\,<\\,n_{0}\\). We can pick \\(d\\) large enough that \\(d\\) dominates the constant hidden by the \\(\\Theta\\), in which case \\(d\\,n^{2}\\,\\geq\\,d\\,\\geq\\,T(n)\\) for \\(1\\,\\leq\\,n\\,<\\,n_{0}\\), completing the proof of the base case.\n\nThe substitution proof we just saw involves two named constants, \\(c\\) and \\(d\\). We named \\(c\\) and used it to stand for the upper-bound constant hidden and guaranteed to exist by the \\(\\Theta\\)-notation. We cannot pick \\(c\\) arbitrarily\\(-\\,\\)it's given to us\\(-\\,\\)although, for any such \\(c\\), any constant \\(c^{\\prime}\\,\\geq\\,c\\) also suffices. We also named \\(d\\), but we were free to choose any value for it that fit our needs. In this example, the value of \\(d\\) happened to depend on the value of \\(c\\), which is fine, since \\(d\\) is constant if \\(c\\) is constant.\n\n### An irregular example\n\nLet's find an asymptotic upper bound for another, more irregular, example. Figure 4.2 shows the recursion tree for the recurrence\n\n\\[T(n)\\,=\\,T(n/3)\\,+\\,T(2n/3)\\,+\\,\\Theta(n). \\tag{4.14}\\]\n\nThis recursion tree is unbalanced, with different root-to-leaf paths having different lengths. Going left at any node produces a subproblem of one-third the size, and going right produces a subproblem of two-thirds the size. Let \\(n_{0}\\,>\\,0\\) be the implicit threshold constant such that \\(T(n)\\,=\\,\\Theta(1)\\) for \\(0\\,<\\,n\\,<\\,n_{0}\\), and let \\(c\\) represent the upper-bound constant hidden by the \\(\\Theta(n)\\) term for \\(n\\,\\geq\\,n_{0}\\). There are actually two \\(n_{0}\\) constants here\\(-\\)one for the threshold in the recurrence, and the other for the threshold in the \\(\\Theta\\)-notation, so we'll let \\(n_{0}\\) be the larger of the two constants.\n\n### The recursion-tree method for solving recurrences\n\nThe height of the tree runs down the right edge of the tree, corresponding to sub-problems of sizes \\(n\\), \\((2/3)n\\), \\((4/9)n\\), \\(\\ldots\\), \\(\\Theta(1)\\) with costs bounded by \\(cn\\), \\(c(2n/3)\\), \\(c(4n/9)\\), \\(\\ldots\\), \\(\\Theta(1)\\), respectively. We hit the rightmost leaf when \\((2/3)^{h}n<n_{0}\\leq(2/3)^{h-1}n\\), which happens when \\(h=\\lfloor\\log_{3/2}(n/n_{0})\\rfloor+1\\) since, applying the floor bounds in equation (3.2) on page 64 with \\(x=\\log_{3/2}(n/n_{0})\\), we have \\((2/3)^{h}n=(2/3)^{\\lfloor x\\rfloor+1}n<(2/3)^{x}n=(n_{0}/n)n=n_{0}\\) and \\((2/3)^{h-1}n=(2/3)^{\\lfloor x\\rfloor}n>(2/3)^{x}n\\)\\(=(n_{0}/n)n=n_{0}\\). Thus, the height of the tree is \\(h=\\Theta(\\lg n)\\).\n\nWe're now in a position to understand the upper bound. Let's postpone dealing with the leaves for a moment. Summing the costs of internal nodes across each level, we have at most \\(cn\\) per level times the \\(\\Theta(\\lg n)\\) tree height for a total cost of \\(O(n\\lg n)\\) for all internal nodes.\n\nIt remains to deal with the leaves of the recursion tree, which represent base cases, each costing \\(\\Theta(1)\\). How many leaves are there? It's tempting to upper-bound their number by the number of leaves in a complete binary tree of height \\(h=\\lfloor\\log_{3/2}(n/n_{0})\\rfloor+1\\), since the recursion tree is contained within such a complete binary tree. But this approach turns out to give us a poor bound. The complete binary tree has 1 node at the root, 2 nodes at depth 1, and generally \\(2^{k}\\) nodes at depth \\(k\\). Since the height is \\(h=\\lfloor\\log_{3/2}n\\rfloor+1\\), there are\n\nFigure 4.2: A recursion tree for the recurrence \\(T(n)=T(n/3)+T(2n/3)+cn\\).\n\n\\(2^{h}=2^{\\lfloor\\log_{3/2}n\\rfloor+1}\\leq 2n^{\\log_{3/2}2}\\) leaves in the complete binary tree, which is an upper bound on the number of leaves in the recursion tree. Because the cost of each leaf is \\(\\Theta(1)\\), this analysis says that the total cost of all leaves in the recursion tree is \\(O(n^{\\log_{3/2}2})=O(n^{1.71})\\), which is an asymptotically greater bound than the \\(O(n\\lg n)\\) cost of all internal nodes. In fact, as we're about to see, this bound is not tight. The cost of all leaves in the recursion tree is \\(O(n)\\)--asymptotically _less_ than \\(O(n\\lg n)\\). In other words, the cost of the internal nodes dominates the cost of the leaves, not vice versa.\n\nRather than analyzing the leaves, we could quit right now and prove by substitution that \\(T(n)=\\Theta(n\\lg n)\\). This approach works (see Exercise 4.4-3), but it's instructive to understand how many leaves this recursion tree has. You may see recurrences for which the cost of leaves dominates the cost of internal nodes, and then you'll be in better shape if you've had some experience analyzing the number of leaves.\n\nTo figure out how many leaves there really are, let's write a recurrence \\(L(n)\\) for the number of leaves in the recursion tree for \\(T(n)\\). Since all the leaves in \\(T(n)\\) belong either to the left subtree or the right subtree of the root, we have\n\n\\[L(n)=\\left\\{\\begin{array}{ll}1&\\mbox{if $n\\,<\\,n_{0}$,}\\\\ L(n/3)\\,+\\,L(2n/3)&\\mbox{if $n\\,\\geq\\,n_{0}$.}\\end{array}\\right. \\tag{4.15}\\]\n\nThis recurrence is similar to recurrence (4.14), but it's missing the \\(\\Theta(n)\\) term, and it contains an explicit base case. Because this recurrence omits the \\(\\Theta(n)\\) term, it is much easier to solve. Let's apply the substitution method to show that it has solution \\(L(n)=O(n)\\). Using the inductive hypothesis \\(L(n)\\leq d\\,n\\) for some constant \\(d>0\\), and assuming that the inductive hypothesis holds for all values less than \\(n\\), we have\n\n\\[L(n) = L(n/3)\\,+\\,L(2n/3)\\] \\[\\leq d\\,n/3\\,+\\,2(dn)/3\\] \\[\\leq d\\,n\\,\\]\n\nwhich holds for any \\(d\\,>0\\). We can now choose \\(d\\) large enough to handle the base case \\(L(n)=1\\) for \\(0<n<n_{0}\\), for which \\(d\\,=\\,1\\) suffices, thereby completing the substitution method for the upper bound on leaves. (Exercise 4.4-2 asks you to prove that \\(L(n)=\\Theta(n)\\).)\n\nReturning to recurrence (4.14) for \\(T(n)\\), it now becomes apparent that the total cost of leaves over all levels must be \\(L(n)\\cdot\\Theta(1)=\\Theta(n)\\). Since we have derived the bound of \\(O(n\\lg n)\\) on the cost of the internal nodes, it follows that the solution to recurrence (4.14) is \\(T(n)=O(n\\lg n)+\\Theta(n)=O(n\\lg n)\\). (Exercise 4.4-3 asks you to prove that \\(T(n)=\\Theta(n\\lg n)\\).)\n\nIt's wise to verify any bound obtained with a recursion tree by using the substitution method, especially if you've made simplifying assumptions. But another strategy altogether is to use more-powerful mathematics, typically in the form of the master method in the next section (which unfortunately doesn't apply to recurrence (4.14)) or the Akra-Bazzi method (which does, but requires calculus). Even if you use a powerful method, a recursion tree can improve your intuition for what's going on beneath the heavy math.\n\n#### Exercises\n\n##### 4.4-1\n\nFor each of the following recurrences, sketch its recursion tree, and guess a good asymptotic upper bound on its solution. Then use the substitution method to verify your answer.\n\n_a._\\(T(n)=T(n/2)+n^{3}\\).\n\n_b._\\(T(n)=4T(n/3)+n\\).\n\n_c._\\(T(n)=4T(n/2)+n\\).\n\n_d._\\(T(n)=3T(n-1)+1\\).\n\n##### 4.4-2\n\nUse the substitution method to prove that recurrence (4.15) has the asymptotic lower bound \\(L(n)=\\Omega(n)\\). Conclude that \\(L(n)=\\Theta(n)\\).\n\n##### 4.4-3\n\nUse the substitution method to prove that recurrence (4.14) has the solution \\(T(n)=\\Omega(n\\lg n)\\). Conclude that \\(T(n)=\\Theta(n\\lg n)\\).\n\n##### 4.4-4\n\nUse a recursion tree to justify a good guess for the solution to the recurrence \\(T(n)=T(\\alpha\\,n)+T((1-\\alpha)n)+\\Theta(n)\\), where \\(\\alpha\\) is a constant in the range \\(0<\\alpha<1\\).\n\n##### The master method for solving recurrences\n\nThe master method provides a \"cookbook\" method for solving algorithmic recurrences of the form\n\n\\[T(n)=a\\,T(n/b)+f(n)\\, \\tag{4.16}\\]\n\nwhere \\(a>0\\) and \\(b>1\\) are constants. We call \\(f(n)\\) a _driving function_, and we call a recurrence of this general form a _master recurrence_. To use the master method, you need to memorize three cases, but then you'll be able to solve many master recurrences quite easily.",
        "chapter": "Part I Foundations",
        "section": "4 Divide-and-Conquer",
        "subsection": "4.4 The recursion-tree method for solving recurrences",
        "subsubsection": "N/A"
    },
    {
        "content": "strategy altogether is to use more-powerful mathematics, typically in the form of the master method in the next section (which unfortunately doesn't apply to recurrence (4.14)) or the Akra-Bazzi method (which does, but requires calculus). Even if you use a powerful method, a recursion tree can improve your intuition for what's going on beneath the heavy math.\n\n#### Exercises\n\n##### 4.4-1\n\nFor each of the following recurrences, sketch its recursion tree, and guess a good asymptotic upper bound on its solution. Then use the substitution method to verify your answer.\n\n_a._\\(T(n)=T(n/2)+n^{3}\\).\n\n_b._\\(T(n)=4T(n/3)+n\\).\n\n_c._\\(T(n)=4T(n/2)+n\\).\n\n_d._\\(T(n)=3T(n-1)+1\\).\n\n##### 4.4-2\n\nUse the substitution method to prove that recurrence (4.15) has the asymptotic lower bound \\(L(n)=\\Omega(n)\\). Conclude that \\(L(n)=\\Theta(n)\\).\n\n##### 4.4-3\n\nUse the substitution method to prove that recurrence (4.14) has the solution \\(T(n)=\\Omega(n\\lg n)\\). Conclude that \\(T(n)=\\Theta(n\\lg n)\\).\n\n##### 4.4-4\n\nUse a recursion tree to justify a good guess for the solution to the recurrence \\(T(n)=T(\\alpha\\,n)+T((1-\\alpha)n)+\\Theta(n)\\), where \\(\\alpha\\) is a constant in the range \\(0<\\alpha<1\\).\n\n##### The master method for solving recurrences\n\nThe master method provides a \"cookbook\" method for solving algorithmic recurrences of the form\n\n\\[T(n)=a\\,T(n/b)+f(n)\\, \\tag{4.16}\\]\n\nwhere \\(a>0\\) and \\(b>1\\) are constants. We call \\(f(n)\\) a _driving function_, and we call a recurrence of this general form a _master recurrence_. To use the master method, you need to memorize three cases, but then you'll be able to solve many master recurrences quite easily.\n\nA master recurrence describes the running time of a divide-and-conquer algorithm that divides a problem of size \\(n\\) into \\(a\\) subproblems, each of size \\(n/b{<}n\\). The algorithm solves the \\(a\\) subproblems recursively, each in \\(T(n/b)\\) time. The driving function \\(f(n)\\) encompasses the cost of dividing the problem before the recursion, as well as the cost of combining the results of the recursive solutions to subproblems. For example, the recurrence arising from Strassen's algorithm is a master recurrence with \\(a=7\\), \\(b=2\\), and driving function \\(f(n)=\\Theta(n^{2})\\).\n\nAs we have mentioned, in solving a recurrence that describes the running time of an algorithm, one technicality that we'd often prefer to ignore is the requirement that the input size \\(n\\) be an integer. For example, we saw that the running time of merge sort can be described by recurrence (2.3), \\(T(n)=2T(n/2)+\\Theta(n)\\), on page 41. But if \\(n\\) is an odd number, we really don't have two problems of exactly half the size. Rather, to ensure that the problem sizes are integers, we round one subproblem down to size \\(\\lfloor n/2\\rfloor\\) and the other up to size \\(\\lceil n/2\\rceil\\), so the true recurrence is \\(T(n)=T(\\lceil n/2\\rceil+T(\\lfloor n/2\\rfloor)+\\Theta(n)\\). But this floors-and-ceilings recurrence is longer to write and messier to deal with than recurrence (2.3), which is defined on the reals. We'd rather not worry about floors and ceilings, if we don't have to, especially since the two recurrences have the same \\(\\Theta(n\\lg n)\\) solution.\n\nThe master method allows you to state a master recurrence without floors and ceilings and implicitly infer them. No matter how the arguments are rounded up or down to the nearest integer, the asymptotic bounds that it provides remain the same. Moreover, as we'll see in Section 4.6, if you define your master recurrence on the reals, without implicit floors and ceilings, the asymptotic bounds still don't change. Thus you can ignore floors and ceilings for master recurrences. Section 4.7 gives sufficient conditions for ignoring floors and ceilings in more general divide-and-conquer recurrences.\n\n### The master theorem\n\nThe master method depends upon the following theorem.\n\n_Theorem 4.1 (Master theorem)_\n\nLet \\(a>0\\) and \\(b>1\\) be constants, and let \\(f(n)\\) be a driving function that is defined and nonnegative on all sufficiently large reals. Define the recurrence \\(T(n)\\) on \\(n\\in\\mathbb{N}\\) by\n\n\\[T(n)=aT(n/b)+f(n)\\, \\tag{4.17}\\]\n\nwhere \\(aT(n/b)\\) actually means \\(a^{\\prime}T(\\lfloor n/b\\rfloor)+a^{\\prime\\prime}T(\\lceil n/b\\rceil)\\) for some constants \\(a^{\\prime}\\geq 0\\) and \\(a^{\\prime\\prime}\\geq 0\\) satisfying \\(a=a^{\\prime}+a^{\\prime\\prime}\\). Then the asymptotic behavior of \\(T(n)\\) can be characterized as follows:1. If there exists a constant \\(\\epsilon>0\\) such that \\(f(n)=O(n^{\\log_{b}a-\\epsilon})\\), then \\(T(n)=\\Theta(n^{\\log_{b}a})\\).\n2. If there exists a constant \\(k\\geq 0\\) such that \\(f(n)=\\Theta(n^{\\log_{b}a}\\lg^{k}n)\\), then \\(T(n)=\\Theta(n^{\\log_{b}a}\\lg^{k+1}n)\\).\n3. If there exists a constant \\(\\epsilon>0\\) such that \\(f(n)=\\Omega(n^{\\log_{b}a+\\epsilon})\\), and if \\(f(n)\\) additionally satisfies the _regularity condition_\\(af(n/b)\\leq cf(n)\\) for some constant \\(c<1\\) and all sufficiently large \\(n\\), then \\(T(n)=\\Theta(f(n))\\).\n\nBefore applying the master theorem to some examples, let's spend a few moments to understand broadly what it says. The function \\(n^{\\log_{b}a}\\) is called the _watershed function_. In each of the three cases, we compare the driving function \\(f(n)\\) to the watershed function \\(n^{\\log_{b}a}\\). Intuitively, if the watershed function grows asymptotically faster than the driving function, then case 1 applies. Case 2 applies if the two functions grow at nearly the same asymptotic rate. Case 3 is the \"opposite\" of case 1, where the driving function grows asymptotically faster than the watershed function. But the technical details matter.\n\nIn case 1, not only must the watershed function grow asymptotically faster than the driving function, it must grow _polynomially_ faster. That is, the watershed function \\(n^{\\log_{b}a}\\) must be asymptotically larger than the driving function \\(f(n)\\) by at least a factor of \\(\\Theta(n^{\\epsilon})\\) for some constant \\(\\epsilon>0\\). The master theorem then says that the solution is \\(T(n)=\\Theta(n^{\\log_{b}a})\\). In this case, if we look at the recursion tree for the recurrence, the cost per level grows at least geometrically from root to leaves, and the total cost of leaves dominates the total cost of the internal nodes.\n\nIn case 2, the watershed and driving functions grow at nearly the same asymptotic rate. But more specifically, the driving function grows faster than the watershed function by a factor of \\(\\Theta(\\lg^{k}n)\\), where \\(k\\geq 0\\). The master theorem says that we tack on an extra \\(\\lg n\\) factor to \\(f(n)\\), yielding the solution \\(T(n)=\\Theta(n^{\\log_{b}a}\\lg^{k+1}n)\\). In this case, each level of the recursion tree costs approximately the same\\(-\\,\\Theta(n^{\\log_{b}a}\\lg^{k}n)\\)--and there are \\(\\Theta(\\lg n)\\) levels. In practice, the most common situation for case 2 occurs when \\(k=0\\), in which case the watershed and driving functions have the same asymptotic growth, and the solution is \\(T(n)=\\Theta(n^{\\log_{b}a}\\lg n)\\).\n\nCase 3 mirrors case 1. Not only must the driving function grow asymptotically faster than the watershed function, it must grow _polynomially_ faster. That is, the driving function \\(f(n)\\) must be asymptotically larger than the watershed function \\(n^{\\log_{b}a}\\) by at least a factor of \\(\\Theta(n^{\\epsilon})\\) for some constant \\(\\epsilon>0\\). Moreover, the driving function must satisfy the regularity condition that \\(af(n/b)\\leq cf(n)\\). This condition is satisfied by most of the polynomially bounded functions that you're likely to encounter when applying case 3. The regularity condition might not be satisfied if the driving function grows slowly in local areas, yet relatively quickly overall. (Exercise 4.5-5 gives an example of such a function.) For case 3, the master theorem says that the solution is \\(T(n)=\\Theta(f(n))\\). If we look at the recursion tree, the cost per level drops at least geometrically from the root to the leaves, and the root cost dominates the cost of all other nodes.\n\nIt's worth looking again at the requirement that there be polynomial separation between the watershed function and the driving function for either case 1 or case 3 to apply. The separation doesn't need to be much, but it must be there, and it must grow polynomially. For example, for the recurrence \\(T(n)=4T(n/2)+n^{1.99}\\) (admittedly not a recurrence you're likely to see when analyzing an algorithm), the watershed function is \\(n^{\\log_{b}a}=n^{2}\\). Hence the driving function \\(f(n)=n^{1.99}\\) is polynomially smaller by a factor of \\(n^{0.01}\\). Thus case 1 applies with \\(\\epsilon=0.01\\).\n\n#### Using the master method\n\nTo use the master method, you determine which case (if any) of the master theorem applies and write down the answer.\n\nAs a first example, consider the recurrence \\(T(n)=9T(n/3)+n\\). For this recurrence, we have \\(a=9\\) and \\(b=3\\), which implies that \\(n^{\\log_{b}a}=n^{\\log_{3}9}=\\Theta(n^{2})\\). Since \\(f(n)=n=O(n^{2-\\epsilon})\\) for any constant \\(\\epsilon\\leq 1\\), we can apply case 1 of the master theorem to conclude that the solution is \\(T(n)=\\Theta(n^{2})\\).\n\nNow consider the recurrence \\(T(n)=T(2n/3)+1\\), which has \\(a=1\\) and \\(b=3/2\\), which means that the watershed function is \\(n^{\\log_{b}a}=n^{\\log_{3/2}1}=n^{0}=1\\). Case 2 applies since \\(f(n)=1=\\Theta(n^{\\log_{b}a}\\lg^{0}n)=\\Theta(1)\\). The solution to the recurrence is \\(T(n)=\\Theta(\\lg n)\\).\n\nFor the recurrence \\(T(n)=3T(n/4)+n\\lg n\\), we have \\(a=3\\) and \\(b=4\\), which means that \\(n^{\\log_{b}a}=n^{\\log_{4}3}=O(n^{0.793})\\). Since \\(f(n)=n\\lg n=\\Omega(n^{\\log_{4}3+\\epsilon})\\), where \\(\\epsilon\\) can be as large as approximately 0.2, case 3 applies as long as the regularity condition holds for \\(f(n)\\). It does, because for sufficiently large \\(n\\), we have that \\(af(n/b)=3(n/4)\\lg(n/4)\\leq(3/4)n\\lg n=cf(n)\\) for \\(c=3/4\\). By case 3, the solution to the recurrence is \\(T(n)=\\Theta(n\\lg n)\\).\n\nNext, let's look at the recurrence \\(T(n)=2T(n/2)+n\\lg n\\), where we have \\(a=2\\), \\(b=2\\), and \\(n^{\\log_{b}a}=n^{\\log_{2}2}=n\\). Case 2 applies since \\(f(n)=n\\lg n=\\Theta(n^{\\log_{b}a}\\lg^{1}n)\\). We conclude that the solution is \\(T(n)=\\Theta(n\\lg^{2}n)\\).\n\nWe can use the master method to solve the recurrences we saw in Sections 2.3.2, 4.1, and 4.2.\n\nRecurrence (2.3), \\(T(n)=2T(n/2)+\\Theta(n)\\), on page 41, characterizes the running time of merge sort. Since \\(a=2\\) and \\(b=2\\), the watershed function is \\(n^{\\log_{b}a}=n^{\\log_{2}2}=n\\). Case 2 applies because \\(f(n)=\\Theta(n)\\), and the solution is \\(T(n)=\\Theta(n\\lg n)\\).\n\nRecurrence (4.9), \\(T(n)=8T(n/2)+\\Theta(1)\\), on page 84, describes the running time of the simple recursive algorithm for matrix multiplication. We have \\(a=8\\) and \\(b=2\\), which means that the watershed function is \\(n^{\\log_{b}a}=n^{\\log_{2}8}=n^{3}\\). Since \\(n^{3}\\) is polynomially larger than the driving function \\(f(n)=\\Theta(1)-\\)indeed, we have \\(f(n)=O(n^{3-\\epsilon})\\) for any positive \\(\\epsilon<3-\\)case 1 applies. We conclude that \\(T(n)=\\Theta(n^{3})\\).\n\nFinally, recurrence (4.10), \\(T(n)=7T(n/2)+\\Theta(n^{2})\\), on page 87, arose from the analysis of Strassen's algorithm for matrix multiplication. For this recurrence, we have \\(a=7\\) and \\(b=2\\), and the watershed function is \\(n^{\\log_{b}a}=n^{\\lg 7}\\). Observing that \\(\\lg 7=2.807355\\ldots\\), we can let \\(\\epsilon=0.8\\) and bound the driving function \\(f(n)=\\Theta(n^{2})=O(n^{\\lg 7-\\epsilon})\\). Case 1 applies with solution \\(T(n)=\\Theta(n^{\\lg 7})\\).\n\n#### When the master method doesn't apply\n\nThere are situations where you can't use the master theorem. For example, it can be that the watershed function and the driving function cannot be asymptotically compared. We might have that \\(f(n)\\gg n^{\\log_{b}a}\\) for an infinite number of values of \\(n\\) but also that \\(f(n)\\ll n^{\\log_{b}a}\\) for an infinite number of different values of \\(n\\). As a practical matter, however, most of the driving functions that arise in the study of algorithms can be meaningfully compared with the watershed function. If you encounter a master recurrence for which that's not the case, you'll have to resort to substitution or other methods.\n\nEven when the relative growths of the driving and watershed functions can be compared, the master theorem does not cover all the possibilities. There is a gap between cases 1 and 2 when \\(f(n)=o(n^{\\log_{b}a})\\), yet the watershed function does not grow polynomially faster than the driving function. Similarly, there is a gap between cases 2 and 3 when \\(f(n)=\\omega(n^{\\log_{b}a})\\) and the driving function grows more than polylogarithmically faster than the watershed function, but it does not grow polynomially faster. If the driving function falls into one of these gaps, or if the regularity condition in case 3 fails to hold, you'll need to use something other than the master method to solve the recurrence.\n\nAs an example of a driving function falling into a gap, consider the recurrence \\(T(n)=2T(n/2)+n/\\lg n\\). Since \\(a=2\\) and \\(b=2\\), the watershed function is \\(n^{\\log_{b}a}=n^{\\log_{2}2}=n^{1}=n\\). The driving function is \\(n/\\lg n=o(n)\\), which means that it grows asymptotically more slowly than the watershed function \\(n\\). But \\(n/\\lg n\\) grows only _logarithmically_ slower than \\(n\\), not _polynomially_ slower. More precisely, equation (3.24) on page 87 says that \\(\\lg n=o(n^{\\epsilon})\\) for any constant \\(\\epsilon>0\\), which means that \\(1/\\lg n=\\omega(n^{-\\epsilon})\\) and \\(n/\\lg n=\\omega(n^{1-\\epsilon})=\\omega(n^{\\log_{b}a-\\epsilon})\\). Thus no constant \\(\\epsilon>0\\) exists such that \\(n/\\lg n=O(n^{\\log_{b}a-\\epsilon})\\), which is required for case 1 to apply. Case 2 fails to apply as well, since \\(n/\\lg n=\\Theta(n^{\\log_{b}a}\\lg^{k}n)\\), where \\(k=-1\\), but \\(k\\) must be nonnegative for case 2 to apply.\n\nTo solve this kind of recurrence, you must use another method, such as the substitution method (Section 4.3) or the Akra-Bazzi method (Section 4.7). (Exercise 4.6-3 asks you to show that the answer is \\(\\Theta(n\\lg\\lg n)\\).) Although the master theorem doesn't handle this particular recurrence, it does handle the overwhelming majority of recurrences that tend to arise in practice.\n\n#### Exercises\n\n_4.5-1_\n\nUse the master method to give tight asymptotic bounds for the following recurrences.\n\n_a._: \\(T(n)=2T(n/4)+1\\).\n\n_b._: \\(T(n)=2T(n/4)+\\sqrt{n}\\).\n\n_c._: \\(T(n)=2T(n/4)+\\sqrt{n}\\lg^{2}n\\).\n\n_d._: \\(T(n)=2T(n/4)+n\\).\n\n_e._: \\(T(n)=2T(n/4)+n^{2}\\).\n\n#### 4.5-2\n\nProfessor Caesar wants to develop a matrix-multiplication algorithm that is asymptotically faster than Strassen's algorithm. His algorithm will use the divide-and-conquer method, dividing each matrix into \\(n/4\\times n/4\\) submatrices, and the divide and combine steps together will take \\(\\Theta(n^{2})\\) time. Suppose that the professor's algorithm creates \\(a\\) recursive subproblems of size \\(n/4\\). What is the largest integer value of \\(a\\) for which his algorithm could possibly run asymptotically faster than Strassen's?\n\n_4.5-3_\n\nUse the master method to show that the solution to the binary-search recurrence \\(T(n)=T(n/2)+\\Theta(1)\\) is \\(T(n)=\\Theta(\\lg n)\\). (See Exercise 2.3-6 for a description of binary search.)\n\n_4.5-4_\n\nConsider the function \\(f(n)=\\lg n\\). Argue that although \\(f(n/2)\\!<\\!f(n)\\), the regularity condition \\(af(n/b)\\leq cf(n)\\) with \\(a=1\\) and \\(b=2\\) does not hold for any constant \\(c<1\\). Argue further that for any \\(\\epsilon>0\\), the condition in case 3 that \\(f(n)=\\Omega(n^{\\log_{b}a+\\epsilon})\\) does not hold.\n\n### Proof of the continuous master theorem\n\nShow that for suitable constants \\(a,b\\), and \\(\\epsilon\\), the function \\(f(n)=2^{\\lceil\\lg n\\rceil}\\) satisfies all the conditions in case 3 of the master theorem except the regularity condition.\n\n### Proof of the continuous master theorem\n\nProving the master theorem (Theorem 4.1) in its full generality, especially dealing with the knotty technical issue of floors and ceilings, is beyond the scope of this book. This section, however, states and proves a variant of the master theorem, called the _continuous master theorem1_ in which the master recurrence (4.17) is defined over sufficiently large positive real numbers. The proof of this version, uncomplicated by floors and ceilings, contains the main ideas needed to understand how master recurrences behave. Section 4.7 discusses floors and ceilings in divide-and-conquer recurrences at greater length, presenting sufficient conditions for them not to affect the asymptotic solutions.\n\nFootnote 1: This terminology does not mean that either \\(T(n)\\) or \\(f(n)\\) need be continuous, only that the domain of \\(T(n)\\) is the real numbers, as opposed to integers.\n\nOf course, since you need not understand the proof of the master theorem in order to apply the master method, you may choose to skip this section. But if you wish to study more-advanced algorithms beyond the scope of this textbook, you may appreciate a better understanding of the underlying mathematics, which the proof of the continuous master theorem provides.\n\nAlthough we usually assume that recurrences are algorithmic and don't require an explicit statement of a base case, we must be much more careful for proofs that justify the practice. The lemmas and theorem in this section explicitly state the base cases, because the inductive proofs require mathematical grounding. It is common in the world of mathematics to be extraordinarily careful proving theorems that justify acting more casually in practice.\n\nThe proof of the continuous master theorem involves two lemmas. Lemma 4.2 uses a slightly simplified master recurrence with a threshold constant of \\(n_{0}=1\\), rather than the more general \\(n_{0}>0\\) threshold constant implied by the unstated base case. The lemma employs a recursion tree to reduce the solution of the simplified master recurrence to that of evaluating a summation. Lemma 4.3 then provides asymptotic bounds for the summation, mirroring the three cases of the master theorem. Finally, the continuous master theorem itself (Theorem 4.4) gives asymptotic bounds for master recurrences, while generalizing to an arbitrary threshold constant \\(n_{0}>0\\) as implied by the unstated base case.",
        "chapter": "Part I Foundations",
        "section": "4 Divide-and-Conquer",
        "subsection": "4.5 The master method for solving recurrences",
        "subsubsection": "N/A"
    },
    {
        "content": "### Proof of the continuous master theorem\n\nShow that for suitable constants \\(a,b\\), and \\(\\epsilon\\), the function \\(f(n)=2^{\\lceil\\lg n\\rceil}\\) satisfies all the conditions in case 3 of the master theorem except the regularity condition.\n\n### Proof of the continuous master theorem\n\nProving the master theorem (Theorem 4.1) in its full generality, especially dealing with the knotty technical issue of floors and ceilings, is beyond the scope of this book. This section, however, states and proves a variant of the master theorem, called the _continuous master theorem1_ in which the master recurrence (4.17) is defined over sufficiently large positive real numbers. The proof of this version, uncomplicated by floors and ceilings, contains the main ideas needed to understand how master recurrences behave. Section 4.7 discusses floors and ceilings in divide-and-conquer recurrences at greater length, presenting sufficient conditions for them not to affect the asymptotic solutions.\n\nFootnote 1: This terminology does not mean that either \\(T(n)\\) or \\(f(n)\\) need be continuous, only that the domain of \\(T(n)\\) is the real numbers, as opposed to integers.\n\nOf course, since you need not understand the proof of the master theorem in order to apply the master method, you may choose to skip this section. But if you wish to study more-advanced algorithms beyond the scope of this textbook, you may appreciate a better understanding of the underlying mathematics, which the proof of the continuous master theorem provides.\n\nAlthough we usually assume that recurrences are algorithmic and don't require an explicit statement of a base case, we must be much more careful for proofs that justify the practice. The lemmas and theorem in this section explicitly state the base cases, because the inductive proofs require mathematical grounding. It is common in the world of mathematics to be extraordinarily careful proving theorems that justify acting more casually in practice.\n\nThe proof of the continuous master theorem involves two lemmas. Lemma 4.2 uses a slightly simplified master recurrence with a threshold constant of \\(n_{0}=1\\), rather than the more general \\(n_{0}>0\\) threshold constant implied by the unstated base case. The lemma employs a recursion tree to reduce the solution of the simplified master recurrence to that of evaluating a summation. Lemma 4.3 then provides asymptotic bounds for the summation, mirroring the three cases of the master theorem. Finally, the continuous master theorem itself (Theorem 4.4) gives asymptotic bounds for master recurrences, while generalizing to an arbitrary threshold constant \\(n_{0}>0\\) as implied by the unstated base case.\n\nSome of the proofs use the properties described in Problem 3-5 on pages 72-73 to combine and simplify complicated asymptotic expressions. Although Problem 3-5 addresses only \\(\\Theta\\)-notation, the properties enumerated there can be extended to \\(O\\)-notation and \\(\\Omega\\)-notation as well.\n\nHere's the first lemma.\n\n**Lemma 4.2**: Let \\(a>0\\) and \\(b>1\\) be constants, and let \\(f(n)\\) be a function defined over real numbers \\(n\\geq 1.\\) Then the recurrence\n\n\\[T(n)=\\left\\{\\begin{array}{ll}\\Theta(1)&\\mbox{if $0\\leq n\\,<1$}\\,\\\\ a\\,T(n/b)\\,+\\,f(n)&\\mbox{if $n\\geq 1$}\\end{array}\\right.\\]\n\nhas solution\n\n\\[T(n)=\\Theta(n^{\\log_{b}a})+\\sum_{j=0}^{\\lfloor\\log_{b}n\\rfloor}a^{j}\\,f(n/b^{ j}). \\tag{4.18}\\]\n\nProofConsider the recursion tree in Figure 4.3. Let's look first at its internal nodes. The root of the tree has cost \\(f(n),\\) and it has \\(a\\) children, each with cost \\(f(n/b).\\) (It is convenient to think of \\(a\\) as being an integer, especially when visualizing the recursion tree, but the mathematics does not require it.) Each of these children has \\(a\\) children, making \\(a^{2}\\) nodes at depth 2, and each of the \\(a\\) children has cost \\(f(n/b^{2})\\). In general, there are \\(a^{j}\\) nodes at depth \\(j\\), and each node has cost \\(f(n/b^{j}).\\)\n\nNow, let's move on to understanding the leaves. The tree grows downward until \\(n/b^{j}\\) becomes less than 1. Thus, the tree has height \\(\\lfloor\\log_{b}n\\rfloor+1,\\) because \\(n/b^{\\lfloor\\log_{b}n\\rfloor}\\geq n/b^{\\log_{b}n}=1\\) and \\(n/b^{\\lfloor\\log_{b}n\\rfloor+1}<\\!n/b^{\\ \\log_{b}n}=1\\). Since, as we have observed, the number of nodes at depth \\(j\\) is \\(a^{j}\\) and all the leaves are at depth \\(\\lfloor\\log_{b}n\\rfloor+1,\\) the tree contains \\(a^{\\lfloor\\log_{b}n\\rfloor+1}\\) leaves. Using the identity (3.21) on page 66, we have \\(a^{\\lfloor\\log_{b}n\\rfloor+1}\\leq a^{\\log_{b}n+1}=an^{\\log_{b}a}=O(n^{\\log_{b} a}),\\) since \\(a\\) is constant, and \\(a^{\\lfloor\\log_{b}n\\rfloor+1}\\geq a^{\\log_{b}n}=n^{\\log_{b}a}=\\Omega(n^{\\log_{ b}a}).\\) Consequently, the total number of leaves is \\(\\Theta(n^{\\log_{b}a})-\\)asymptotically, the watershed function.\n\nWe are now in a position to derive equation (4.18) by summing the costs of the nodes at each depth in the tree, as shown in the figure. The first term in the equation is the total costs of the leaves. Since each leaf is at depth \\(\\lfloor\\log_{b}n\\rfloor+1\\) and \\(n/b^{\\lfloor\\log_{b}n\\rfloor+1}<1\\), the base case of the recurrence gives the cost of a leaf: \\(T(n/b^{\\lfloor\\log_{b}n\\rfloor+1})=\\Theta(1)\\). Hence the cost of all \\(\\Theta(n^{\\log_{b}a})\\) leaves is \\(\\Theta(n^{\\log_{b}a})\\cdot\\Theta(1)=\\Theta(n^{\\log_{b}a})\\) by Problem 3-5(d). The second term in equation (4.18) is the cost of the internal nodes, which, in the underlying divide-and-conquer algorithm, represents the costs of dividing problems into subproblems and \n\n### Proof of the continuous master theorem\n\nthen recombining the subproblems. Since the cost for all the internal nodes at depth \\(j\\) is \\(a^{\\,j}\\,f(n/b^{\\,j})\\), the total cost of all internal nodes is\n\n\\[\\sum_{j=0}^{\\lfloor\\log_{b}n\\rfloor}a^{\\,j}\\,f(n/b^{\\,j})\\.\\]\n\nAs we'll see, the three cases of the master theorem depend on the distribution of the total cost across levels of the recursion tree:\n\n**Case 1:**: The costs increase geometrically from the root to the leaves, growing by a constant factor with each level.\n**Case 2:**: The costs depend on the value of \\(k\\) in the theorem. With \\(k=0\\), the costs are equal for each level; with \\(k=1\\), the costs grow linearly from the root to the leaves; with \\(k=2\\), the growth is quadratic; and in general, the costs grow polynomially in \\(k\\).\n**Case 3:**: The costs decrease geometrically from the root to the leaves, shrinking by a constant factor with each level.\n\nFigure 4.3: The recursion tree generated by \\(T(n)=aT(n/b)+f(n)\\). The tree is a complete \\(a\\)-ary tree with \\(a^{\\lfloor\\log_{b}n\\rfloor+1}\\) leaves and height \\(\\lfloor\\log_{b}n\\rfloor+1\\). The cost of the nodes at each depth is shown at the right, and their sum is given in equation (4.18).\n\nThe summation in equation (4.18) describes the cost of the dividing and combining steps in the underlying divide-and-conquer algorithm. The next lemma provides asymptotic bounds on the summation's growth.\n\n**Lemma 4.3**: _Let \\(a>0\\) and \\(b>1\\) be constants, and let \\(f(n)\\) be a function defined over real numbers \\(n\\geq 1\\). Then the asymptotic behavior of the function_\n\n\\[g(n)=\\sum_{j=0}^{\\lfloor\\log_{b}n\\rfloor}a^{j}\\,f(n/b^{j})\\, \\tag{4.19}\\]\n\n_defined for \\(n\\geq 1\\), can be characterized as follows:_\n\n1. _If there exists a constant_ \\(\\epsilon>0\\) _such that_ \\(f(n)=O(n^{\\log_{b}a-\\epsilon})\\)_, then_ \\(g(n)=O(n^{\\log_{b}a})\\)_._\n2. _If there exists a constant_ \\(k\\geq 0\\) _such that_ \\(f(n)=\\Theta(n^{\\log_{b}a}\\lg^{k}n)\\)_, then_ \\(g(n)=\\Theta(n^{\\log_{b}a}\\lg^{k+1}n)\\)_._\n3. _If there exists a constant_ \\(c\\) _in the range_ \\(0<c<1\\) _such that_ \\(0{<}af(n/b)\\leq cf(n)\\) _for all_ \\(n\\geq 1\\)_, then_ \\(g(n)=\\Theta(f(n))\\)_._\n\nProofFor case 1, we have \\(f(n)=O(n^{\\log_{b}a-\\epsilon})\\), which implies that \\(f(n/b^{j})=O((n/b^{j})^{\\log_{b}a-\\epsilon})\\). Substituting into equation (4.19) yields\n\n\\[g(n) = \\sum_{j=0}^{\\lfloor\\log_{b}n\\rfloor}a^{j}\\,O\\bigg{(}\\Big{(}\\frac {n}{b^{j}}\\Big{)}^{\\log_{b}a-\\epsilon}\\bigg{)}\\] \\[= O\\left(\\sum_{j=0}^{\\lfloor\\log_{b}n\\rfloor}a^{j}\\,\\Big{(}\\frac{ n}{b^{j}}\\Big{)}^{\\log_{b}a-\\epsilon}\\right)\\] (by Problem 3-5(c), repeatedly) \\[= O\\left(n^{\\log_{b}a-\\epsilon}\\sum_{j=0}^{\\lfloor\\log_{b}n \\rfloor}\\left(\\frac{ab^{\\epsilon}}{b^{\\log_{b}a}}\\right)^{j}\\right)\\] \\[= O\\left(n^{\\log_{b}a-\\epsilon}\\sum_{j=0}^{\\lfloor\\log_{b}n \\rfloor}(b^{\\epsilon})^{j}\\right)\\] (by equation ( 3.17) on page 66 ) \\[= O\\left(n^{\\log_{b}a-\\epsilon}\\left(\\frac{b^{\\epsilon(\\lfloor\\log _{b}n\\rfloor+1)}-1}{b^{\\epsilon}-1}\\right)\\right)\\] (by equation ( ( ( ( ( ( ( ( ( ( ( ( ( ( (((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((                                                                                                                                 0 0 } }}\n\nthe numerator. Since \\(b^{\\epsilon(\\lfloor\\log_{b}n\\rfloor+1)}\\leq\\left(b^{\\log_{b}n+1}\\right)^{\\epsilon} =b^{\\epsilon}n^{\\epsilon}=O(n^{\\epsilon})\\), we obtain \\(g(n)=O(n^{\\log_{b}a-\\epsilon}\\cdot O(n^{\\epsilon}))=O(n^{\\log_{b}a})\\), thereby proving case 1.\n\nCase 2 assumes that \\(f(n)=\\Theta(n^{\\log_{b}a}\\lg^{k}n)\\), from which we can conclude that \\(f(n/b^{j})=\\Theta((n/b^{j})^{\\log_{b}a}\\lg^{k}(n/b^{j}))\\). Substituting into equation (4.19) and repeatedly applying Problem 3-5(c) yields\n\n\\[g(n) = \\Theta\\left(\\sum_{j=0}^{\\lfloor\\log_{b}n\\rfloor}a^{j}\\left(\\frac{ n}{b^{j}}\\right)^{\\log_{b}a}\\lg^{k}\\left(\\frac{n}{b^{j}}\\right)\\right)\\] \\[= \\Theta\\left(n^{\\log_{b}a}\\sum_{j=0}^{\\lfloor\\log_{b}n\\rfloor} \\frac{a^{j}}{b^{j}\\log_{b}a}\\lg^{k}\\left(\\frac{n}{b^{j}}\\right)\\right)\\] \\[= \\Theta\\left(n^{\\log_{b}a}\\sum_{j=0}^{\\lfloor\\log_{b}n\\rfloor} \\lg^{k}\\left(\\frac{n}{b^{j}}\\right)\\right)\\] \\[= \\Theta\\left(n^{\\log_{b}a}\\sum_{j=0}^{\\lfloor\\log_{b}n\\rfloor} \\left(\\frac{\\log_{b}(n/b^{j})}{\\log_{b}2}\\right)^{k}\\right)\\] (by equation (3.19) on page 66) \\[= \\Theta\\left(n^{\\log_{b}a}\\sum_{j=0}^{\\lfloor\\log_{b}n\\rfloor} \\left(\\frac{\\log_{b}n-j}{\\log_{b}2}\\right)^{k}\\right)\\] (by equations (3.17), (3.18), and (3.20)) \\[= \\Theta\\left(\\frac{n^{\\log_{b}a}}{\\log_{b}^{k}2}\\sum_{j=0}^{ \\lfloor\\log_{b}n\\rfloor}(\\log_{b}n-j)^{k}\\right)\\] \\[= \\Theta\\left(n^{\\log_{b}a}\\sum_{j=0}^{\\lfloor\\log_{b}n\\rfloor}( \\log_{b}n-j)^{k}\\right)\\] ( \\[b>1\\] and \\[k\\] are constants).\n\nThe summation within the \\(\\Theta\\)-notation can be bounded from above as follows:\n\n\\[\\sum_{j=0}^{\\lfloor\\log_{b}n\\rfloor}(\\log_{b}n-j)^{k} \\leq \\sum_{j=0}^{\\lfloor\\log_{b}n\\rfloor}(\\lfloor\\log_{b}n\\rfloor+1-j )^{k}\\] \\[= \\sum_{j=1}^{\\lfloor\\log_{b}n\\rfloor+1}j^{k}\\] (reindexing \\[-\\] pages 1143 -1144) \\[= O((\\lfloor\\log_{b}n\\rfloor+1)^{k+1})\\] (by Exercise A.1-5 on page 1144) \\[= O(\\log_{b}^{k+1}n)\\] (by Exercise 3.3-3 on page 70).\n\nExercise 4.6-1 asks you show that the summation can similarly be bounded from below by \\(\\Omega(\\log_{b}^{k+1}n)\\). Since we have tight upper and lower bounds, the summation is \\(\\Theta(\\log_{b}^{k+1}n)\\), from which we can conclude that \\(g(n)=\\Theta\\left(n^{\\log_{b}a}\\log_{b}^{k+1}n\\right)\\), thereby completing the proof of case 2.\n\nFor case 3, observe that \\(f(n)\\) appears in the definition (4.19) of \\(g(n)\\) (when \\(j=0\\)) and that all terms of \\(g(n)\\) are positive. Therefore, we must have \\(g(n)=\\Omega(\\_(f(n)))\\), and it only remains to prove that \\(g(n)=O(f(n))\\). Performing \\(j\\) iterations of the inequality \\(af(n/b)\\leq cf(n)\\) yields \\(a^{\\,j}\\,f(n/b^{\\,j})\\leq c^{\\,j}\\,f(n)\\). Substituting into equation (4.19), we obtain\n\n\\[g(n) = \\sum_{j=0}^{\\lfloor\\log_{b}n\\rfloor}a^{\\,j}\\,f(n/b^{\\,j})\\] \\[\\leq \\sum_{j=0}^{\\lfloor\\log_{b}n\\rfloor}c^{\\,j}\\,f(n)\\] \\[\\leq f(n)\\sum_{j=0}^{\\infty}c^{\\,j}\\] \\[= f(n)\\left(\\frac{1}{1-c}\\right)\\qquad\\text{(by equation (A.7) on page 1142 since $|c|<1$)}\\] \\[= O(f(n))\\.\\] Thus, we can conclude that \\(g(n)=\\Theta(\\,f(n))\\). With case 3 proved, the entire proof of the lemma is complete.\n\nWe can now state and prove the continuous master theorem.\n\n**Theorem 4.4** (Continuous master theorem): _Let \\(a>0\\) and \\(b>1\\) be constants, and let \\(f(n)\\) be a driving function that is defined and nonnegative on all sufficiently large reals. Define the algorithmic recurrence \\(T(n)\\) on the positive real numbers by_\n\n\\(T(n)=a\\,T(n/b)+f(n)\\) _._\n\n_Then the asymptotic behavior of \\(T(n)\\) can be characterized as follows:_\n\n1. _If there exists a constant_ \\(\\epsilon>0\\) _such that_ \\(f(n)=O(n^{\\log_{b}a-\\epsilon})\\)_, then_ \\(T(n)=\\Theta(n^{\\log_{b}a})\\)_._\n2. _If there exists a constant_ \\(k\\geq 0\\) _such that_ \\(f(n)=\\Theta(n^{\\log_{b}a}\\,\\lg^{k}n)\\)_, then_ \\(T(n)=\\Theta(n^{\\log_{b}a}\\,\\lg^{k+1}n)\\)_._\n3. _If there exists a constant_ \\(\\epsilon>0\\) _such that_ \\(f(n)=\\Omega(n^{\\log_{b}a+\\epsilon})\\)_, and if_ \\(f(n)\\) _additionally satisfies the regularity condition_ \\(af(n/b)\\leq cf(n)\\) _for some constant_ \\(c<1\\) _and all sufficiently large_ \\(n\\)_, then_ \\(T(n)=\\Theta(\\,f(n))\\)_._\n\nProof.: The idea is to bound the summation (4.18) from Lemma 4.2 by applying Lemma 4.3. But we must account for Lemma 4.2 using a base case for \\(0<n<1\\)whereas this theorem uses an implicit base case for \\(0<n<n_{0}\\), where \\(n_{0}>0\\) is an arbitrary threshold constant. Since the recurrence is algorithmic, we can assume that \\(f(n)\\) is defined for \\(n\\geq n_{0}\\).\n\nFor \\(n>0\\), let us define two auxiliary functions \\(T^{\\prime}(n)=T(n_{0}\\,n)\\) and \\(f^{\\prime}(n)=f(n_{0}\\,n)\\). We have\n\n\\[T^{\\prime}(n) = T(n_{0}\\,n) \\tag{4.20}\\] \\[= \\left\\{\\begin{array}{ll}\\Theta(1)&\\mbox{if $n_{0}\\,n<n_{0}$,}\\\\ a\\,T(n_{0}\\,n/b)\\,+\\,f(n_{0}\\,n)&\\mbox{if $n_{0}\\,n\\geq n_{0}$}\\end{array}\\right.\\] \\[= \\left\\{\\begin{array}{ll}\\Theta(1)&\\mbox{if $n<1$,}\\\\ a\\,T^{\\prime}(n/b)\\,+\\,f^{\\prime}(n)&\\mbox{if $n\\geq 1$.}\\end{array}\\right.\\]\n\nWe have obtained a recurrence for \\(T^{\\prime}(n)\\) that satisfies the conditions of Lemma 4.2, and by that lemma, the solution is\n\n\\[T^{\\prime}(n)=\\Theta(n^{\\log_{b}\\,a})+\\sum_{j=0}^{\\lfloor\\log_{b}\\,n\\rfloor}a ^{\\,j}\\,f^{\\prime}(n/b^{\\,j}). \\tag{4.21}\\]\n\nTo solve \\(T^{\\prime}(n)\\), we first need to bound \\(f^{\\prime}(n)\\). Let's examine the individual cases in the theorem.\n\nThe condition for case 1 is \\(f(n)=O(n^{\\log_{b}\\,a-\\epsilon})\\) for some constant \\(\\epsilon>0\\). We have\n\n\\[f^{\\prime}(n) = f(n_{0}\\,n)\\] \\[= O((n_{0}\\,n)^{\\log_{b}\\,a-\\epsilon})\\] \\[= O(n^{\\log_{b}\\,a-\\epsilon})\\,\\]\n\nsince \\(a\\), \\(b\\), \\(n_{0}\\), and \\(\\epsilon\\) are all constant. The function \\(f^{\\prime}(n)\\) satisfies the conditions of case 1 of Lemma 4.3, and the summation in equation (4.18) of Lemma 4.2 evaluates to \\(O(n^{\\log_{b}\\,a})\\). Because \\(a\\), \\(b\\) and \\(n_{0}\\) are all constants, we have\n\n\\[T(n) = T^{\\prime}(n/n_{0})\\] \\[= \\Theta((n/n_{0})^{\\log_{b}\\,a})+\\,O((n/n_{0})^{\\log_{b}\\,a})\\] \\[= \\Theta(n^{\\log_{b}\\,a})+\\,O(n^{\\log_{b}\\,a})\\] \\[= \\Theta(n^{\\log_{b}\\,a})\\qquad\\qquad\\qquad\\mbox{(by Problem \\ref{eq:1}-5(b))}\\,\\]\n\nthereby completing case 1 of the theorem.\n\nThe condition for case 2 is \\(f(n)=\\Theta(n^{\\log_{b}\\,a}\\lg^{k}n)\\) for some constant \\(k\\geq 0\\). We have\n\n\\[f^{\\prime}(n) = f(n_{0}\\,n)\\] \\[= \\Theta((n_{0}\\,n)^{\\log_{b}\\,a}\\lg^{k}(n_{0}\\,n))\\] \\[= \\Theta(n^{\\log_{b}\\,a}\\lg^{k}n)\\qquad\\qquad\\mbox{(by eliminating the constant terms)}\\.\\]Similar to the proof of case 1, the function \\(f^{\\prime}(n)\\) satisfies the conditions of case 2 of Lemma 4.3. The summation in equation (4.18) of Lemma 4.2 is therefore \\(\\Theta(n^{\\log_{b}a}\\lg^{k+1}n)\\), which implies that\n\n\\[T(n) = T^{\\prime}(n/n_{0})\\] \\[= \\Theta((n/n_{0})^{\\log_{b}a})+\\Theta((n/n_{0})^{\\log_{b}a}\\lg^{k+ 1}(n/n_{0}))\\] \\[= \\Theta(n^{\\log_{b}a})+\\Theta(n^{\\log_{b}a}\\lg^{k+1}n)\\] \\[= \\Theta(n^{\\log_{b}a}\\lg^{k+1}n)\\qquad\\qquad\\mbox{ (by Problem \\ref{thm:1}-5(c)) },\\]\n\nwhich proves case 2 of the theorem.\n\nFinally, the condition for case 3 is \\(f(n)=\\Omega(n^{\\log_{b}a+\\epsilon})\\) for some constant \\(\\epsilon>0\\) and \\(f(n)\\) additionally satisfies the regularity condition \\(af(n/b)\\leq cf(n)\\) for all \\(n\\geq n_{0}\\) and some constants \\(c<1\\) and \\(n_{0}>1\\). The first part of case 3 is like case 1:\n\n\\[f^{\\prime}(n) = f(n_{0}\\,n)\\] \\[= \\Omega((n_{0}\\,n)^{\\log_{b}a+\\epsilon})\\] \\[= \\Omega(n^{\\log_{b}a+\\epsilon})\\.\\]\n\nUsing the definition of \\(f^{\\prime}(n)\\) and the fact that \\(n_{0}\\,n\\geq n_{0}\\) for all \\(n\\geq 1\\), we have for \\(n\\geq 1\\) that\n\n\\[af^{\\prime}(n/b) = af(n_{0}\\,n/b)\\] \\[\\leq cf(n_{0}\\,n)\\] \\[= cf^{\\prime}(n)\\.\\]\n\nThus \\(f^{\\prime}(n)\\) satisfies the requirements for case 3 of Lemma 4.3, and the summation in equation (4.18) of Lemma 4.2 evaluates to \\(\\Theta(f^{\\prime}(n))\\), yielding\n\n\\[T(n) = T^{\\prime}(n/n_{0})\\] \\[= \\Theta((n/n_{0})^{\\log_{b}a})+\\Theta(f^{\\prime}(n/n_{0}))\\] \\[= \\Theta(f^{\\prime}(n/n_{0}))\\] \\[= \\Theta(f(n))\\,\\]\n\nwhich completes the proof of case 3 of the theorem and thus the whole theorem.\n\n**Exercises**\n\n_4.6-1_\n\nShow that \\(\\sum_{j=0}^{\\lfloor\\log_{b}n\\rfloor}(\\log_{b}n-j)^{k}=\\Omega(\\log_{b}^{k+1}n)\\).\n\n**4.6-2**\n\nShow that case 3 of the master theorem is overstated (which is also why case 3 of Lemma 4.3 does not require that \\(f(n)=\\Omega(n^{\\log_{b}a+\\epsilon})\\)) in the sense that the regularity condition \\(af(n/b)\\leq cf(n)\\) for some constant \\(c<1\\) implies that there exists a constant \\(\\epsilon>0\\) such that \\(f(n)=\\Omega(n^{\\log_{b}a+\\epsilon})\\). \\(\\bigstar\\) _4.6-3_ For \\(f(n)=\\Theta(n^{\\log_{b}a}/\\lg n)\\), prove that the summation in equation (4.19) has solution \\(g(n)=\\Theta(n^{\\log_{b}a}\\lg\\lg n)\\). Conclude that a master recurrence \\(T(n)\\) using \\(f(n)\\) as its driving function has solution \\(T(n)=\\Theta(n^{\\log_{b}a}\\lg\\lg n)\\).\n\n### 4.7 Akra-Bazzi recurrences\n\nThis section provides an overview of two advanced topics related to divide-and-conquer recurrences. The first deals with technicalities arising from the use of floors and ceilings, and the second discusses the Akra-Bazzi method, which involves a little calculus, for solving complicated divide-and-conquer recurrences.\n\nIn particular, we'll look at the class of algorithmic divide-and-conquer recurrences originally studied by M. Akra and L. Bazzi [13]. These _Akra-Bazzi_ recurrences take the form\n\n\\[T(n)=f(n)+\\sum_{i=1}^{k}a_{i}\\,T(n/b_{i})\\, \\tag{4.22}\\]\n\nwhere \\(k\\) is a positive integer; all the constants \\(a_{1},a_{2},\\ldots,a_{k}\\in\\mathbb{R}\\) are strictly positive; all the constants \\(b_{1},b_{2},\\ldots,b_{k}\\in\\mathbb{R}\\) are strictly greater than 1; and the driving function \\(f(n)\\) is defined on sufficiently large nonnegative reals and is itself nonnegative.\n\nAkra-Bazzi recurrences generalize the class of recurrences addressed by the master theorem. Whereas master recurrences characterize the running times of divide-and-conquer algorithms that break a problem into equal-sized subproblems (modulo floors and ceilings), Akra-Bazzi recurrences can describe the running time of divide-and-conquer algorithms that break a problem into different-sized subproblems. The master theorem, however, allows you to ignore floors and ceilings, but the Akra-Bazzi method for solving Akra-Bazzi recurrences needs an additional requirement to deal with floors and ceilings.\n\nBut before diving into the Akra-Bazzi method itself, let's understand the limitations involved in ignoring floors and ceilings in Akra-Bazzi recurrences. As you're aware, algorithms generally deal with integer-sized inputs. The mathematics for recurrences is often easier with real numbers, however, than with integers, where we must cope with floors and ceilings to ensure that terms are well defined. The difference may not seem to be much-- especially because that's often the truth with recurrences--but to be mathematically correct, we must be careful with our",
        "chapter": "Part I Foundations",
        "section": "4 Divide-and-Conquer",
        "subsection": "4.6 Proof of the continuous master theorem",
        "subsubsection": "N/A"
    },
    {
        "content": "regularity condition \\(af(n/b)\\leq cf(n)\\) for some constant \\(c<1\\) implies that there exists a constant \\(\\epsilon>0\\) such that \\(f(n)=\\Omega(n^{\\log_{b}a+\\epsilon})\\). \\(\\bigstar\\) _4.6-3_ For \\(f(n)=\\Theta(n^{\\log_{b}a}/\\lg n)\\), prove that the summation in equation (4.19) has solution \\(g(n)=\\Theta(n^{\\log_{b}a}\\lg\\lg n)\\). Conclude that a master recurrence \\(T(n)\\) using \\(f(n)\\) as its driving function has solution \\(T(n)=\\Theta(n^{\\log_{b}a}\\lg\\lg n)\\).\n\n### 4.7 Akra-Bazzi recurrences\n\nThis section provides an overview of two advanced topics related to divide-and-conquer recurrences. The first deals with technicalities arising from the use of floors and ceilings, and the second discusses the Akra-Bazzi method, which involves a little calculus, for solving complicated divide-and-conquer recurrences.\n\nIn particular, we'll look at the class of algorithmic divide-and-conquer recurrences originally studied by M. Akra and L. Bazzi [13]. These _Akra-Bazzi_ recurrences take the form\n\n\\[T(n)=f(n)+\\sum_{i=1}^{k}a_{i}\\,T(n/b_{i})\\, \\tag{4.22}\\]\n\nwhere \\(k\\) is a positive integer; all the constants \\(a_{1},a_{2},\\ldots,a_{k}\\in\\mathbb{R}\\) are strictly positive; all the constants \\(b_{1},b_{2},\\ldots,b_{k}\\in\\mathbb{R}\\) are strictly greater than 1; and the driving function \\(f(n)\\) is defined on sufficiently large nonnegative reals and is itself non-negative.\n\nAkra-Bazzi recurrences generalize the class of recurrences addressed by the master theorem. Whereas master recurrences characterize the running times of divide-and-conquer algorithms that break a problem into equal-sized subproblems (modulo floors and ceilings), Akra-Bazzi recurrences can describe the running time of divide-and-conquer algorithms that break a problem into different-sized subproblems. The master theorem, however, allows you to ignore floors and ceilings, but the Akra-Bazzi method for solving Akra-Bazzi recurrences needs an additional requirement to deal with floors and ceilings.\n\nBut before diving into the Akra-Bazzi method itself, let's understand the limitations involved in ignoring floors and ceilings in Akra-Bazzi recurrences. As you're aware, algorithms generally deal with integer-sized inputs. The mathematics for recurrences is often easier with real numbers, however, than with integers, where we must cope with floors and ceilings to ensure that terms are well defined. The difference may not seem to be much-- especially because that's often the truth with recurrences--but to be mathematically correct, we must be careful with our assumptions. Since our end goal is to understand algorithms and not the vagaries of mathematical corner cases, we'd like to be casual yet rigorous. How can we treat floors and ceilings casually while still ensuring rigor?\n\nFrom a mathematical point of view, the difficulty in dealing with floors and ceilings is that some driving functions can be really, really weird. So it's not okay in general to ignore floors and ceilings in Akra-Bazzi recurrences. Fortunately, most of the driving functions we encounter in the study of algorithms behave nicely, and floors and ceilings don't make a difference.\n\n##### The polynomial-growth condition\n\nIf the driving function \\(f(n)\\) in equation (4.22) is well behaved in the following sense, it's okay to drop floors and ceilings.\n\nA function \\(f(n)\\) defined on all sufficiently large positive reals satisfies the _polynomial-growth condition_ if there exists a constant \\(\\widehat{n}>0\\) such that the following holds: for every constant \\(\\phi\\geq 1\\), there exists a constant \\(d>1\\) (depending on \\(\\phi\\)) such that \\(f(n)/d\\leq f(\\psi\\,n)\\leq df(n)\\) for all \\(1\\leq\\psi\\leq\\phi\\) and \\(n\\geq\\widehat{n}\\).\n\nThis definition may be one of the hardest in this textbook to get your head around. To a first order, it says that \\(f(n)\\) satisfies the property that \\(f(\\Theta(n))=\\Theta(f(n))\\), although the polynomial-growth condition is actually somewhat stronger (see Exercise 4.7-4). The definition also implies that \\(f(n)\\) is asymptotically positive (see Exercise 4.7-3).\n\nExamples of functions that satisfy the polynomial-growth condition include any function of the form \\(f(n)=\\Theta(n^{\\alpha}\\,\\lg^{\\beta}n\\,\\lg\\lg^{\\gamma}n)\\), where \\(\\alpha\\), \\(\\beta\\), and \\(\\gamma\\) are constants. Most of the polynomially bounded functions used in this book satisfy the condition. Exponentials and superexponentials do not (see Exercise 4.7-2, for example), and there also exist polynomially bounded functions that do not.\n\n##### Floors and ceilings in \"nice\" recurrences\n\nWhen the driving function in an Akra-Bazzi recurrence satisfies the polynomial-growth condition, floors and ceilings don't change the asymptotic behavior of the solution. The following theorem, which is presented without proof, formalizes this notion.\n\n_Theorem 4.5_\n\nLet \\(T(n)\\) be a function defined on the nonnegative reals that satisfies recurrence (4.22), where \\(f(n)\\) satisfies the polynomial-growth condition. Let \\(T^{\\prime}(n)\\) be another function defined on the natural numbers also satisfying recurrence (4.22),except that each \\(T(n/b_{i})\\) is replaced either with \\(T(\\lceil n/b_{i}\\rceil)\\) or with \\(T(\\lfloor n/b_{i}\\rfloor)\\). Then we have \\(T^{\\prime}(n)=\\Theta(T(n))\\).\n\nFloors and ceilings represent a minor perturbation to the arguments in the recursion. By inequality (3.2) on page 64, they perturb an argument by at most 1. But much larger perturbations are tolerable. As long as the driving function \\(f(n)\\) in recurrence (4.22) satisfies the polynomial-growth condition, it turns out that replacing any term \\(T(n/b_{i})\\) with \\(T(n/b_{i}+h_{i}(n))\\), where \\(|h_{i}(n)|=O(n/\\lg^{1+\\epsilon}n)\\) for some constant \\(\\epsilon>0\\) and sufficiently large \\(n\\), leaves the asymptotic solution unaffected. Thus, the divide step in a divide-and-conquer algorithm can be moderately coarse without affecting the solution to its running-time recurrence.\n\n#### The Akra-Bazzi method\n\nThe Akra-Bazzi method, not surprisingly, was developed to solve Akra-Bazzi recurrences (4.22), which by dint of Theorem 4.5, applies in the presence of floors and ceilings or even larger perturbations, as just discussed. The method involves first determining the unique real number \\(p\\) such that \\(\\sum_{i=1}^{k}a_{i}/b_{i}^{\\,p}=1\\). Such a \\(p\\) always exists, because when \\(p\\to-\\infty\\), the sum goes to \\(\\infty\\); it decreases as \\(p\\) increases; and when \\(p\\to\\infty\\), it goes to 0. The Akra-Bazzi method then gives the solution to the recurrence as\n\n\\[T(n)=\\Theta\\left(n^{\\,p}\\left(1+\\int_{1}^{n}\\frac{f(x)}{x^{\\,p+1}}\\,dx\\right) \\right). \\tag{4.23}\\]\n\nAs an example, consider the recurrence\n\n\\[T(n)=T(n/5)+T(7n/10)+n. \\tag{4.24}\\]\n\nWe'll see the similar recurrence (9.1) on page 240 when we study an algorithm for selecting the \\(i\\)th smallest element from a set of \\(n\\) numbers. This recurrence has the form of equation (4.22), where \\(a_{1}=a_{2}=1\\), \\(b_{1}=5\\), \\(b_{2}=10/7\\), and \\(f(n)=n\\). To solve it, the Akra-Bazzi method says that we should determine the unique \\(p\\) satisfying\n\n\\[\\left(\\frac{1}{5}\\right)^{p}+\\left(\\frac{7}{10}\\right)^{p}=1\\.\\]\n\nSolving for \\(p\\) is kind of messy\\(-\\)it turns out that \\(p=0.83978\\ldots\\)--but we can solve the recurrence without actually knowing the exact value for \\(p\\). Observe that \\((1/5)^{0}+(7/10)^{0}=2\\) and \\((1/5)^{1}+(7/10)^{1}=9/10\\), and thus \\(p\\) lies in the range \\(0<p<1\\). That turns out to be sufficient for the Akra-Bazzi method to give us the solution. We'll use the fact from calculus that if \\(k\\neq-1\\), then \\(\\int x^{k}dx=x^{k+1}/(k+1)\\), which we'll apply with \\(k=-p\\neq-1\\). The Akra-Bazzisolution (4.23) gives us \\[T(n) = \\Theta\\left(n^{\\,p}\\left(1+\\int_{1}^{n}\\frac{f(x)}{x^{\\,p+1}}\\,dx \\right)\\right)\\] \\[= \\Theta\\left(n^{\\,p}\\left(1+\\int_{1}^{n}x^{\\,-p}\\,dx\\right)\\right)\\] \\[= \\Theta\\left(n^{\\,p}\\left(1+\\left[\\frac{x^{\\,1-p}}{1-p}\\right]_{1} ^{n}\\right)\\right)\\] \\[= \\Theta\\left(n^{\\,p}\\left(1+\\left(\\frac{n^{\\,1-p}}{1-p}-\\frac{1}{1 -p}\\right)\\right)\\right)\\] \\[= \\Theta\\left(n^{\\,p}\\cdot\\Theta(n^{\\,1-p})\\right)\\] (because \\[1-p\\] is a positive constant) \\[= \\Theta(n)\\] (by Problem 3-5(d)).\n\nAlthough the Akra-Bazzi method is more general than the master theorem, it requires calculus and sometimes a bit more reasoning. You also must ensure that your driving function satisfies the polynomial-growth condition if you want to ignore floors and ceilings, although that's rarely a problem. When it applies, the master method is much simpler to use, but only when subproblem sizes are more or less equal. They are both good tools for your algorithmic toolkit.\n\n**Exercises**\n\n\\(\\bigstar\\) _4.7-1_\n\nConsider an Akra-Bazzi recurrence \\(T(n)\\) on the reals as given in recurrence (4.22), and define \\(T^{\\prime}(n)\\) as\n\n\\[T^{\\prime}(n)=cf(n)+\\sum_{i=1}^{k}a_{i}\\,T^{\\prime}(n/b_{i})\\,\\]\n\nwhere \\(c>0\\) is constant. Prove that whatever the implicit initial conditions for \\(T(n)\\) might be, there exist initial conditions for \\(T^{\\prime}(n)\\) such that \\(T^{\\prime}(n)=c\\,T(n)\\) for all \\(n>0\\). Conclude that we can drop the asymptotics on a driving function in any Akra-Bazzi recurrence without affecting its asymptotic solution.\n\n_4.7-2_\n\nShow that \\(f(n)=n^{2}\\) satisfies the polynomial-growth condition but that \\(f(n)=2^{n}\\) does not.\n\n_4.7-3_\n\nLet \\(f(n)\\) be a function that satisfies the polynomial-growth condition. Prove that \\(f(n)\\) is asymptotically positive, that is, there exists a constant \\(n_{0}\\geq 0\\) such that \\(f(n)\\geq 0\\) for all \\(n\\geq n_{0}\\).\n\n* Give an example of a function \\(f(n)\\) that does not satisfy the polynomial-growth condition but for which \\(f(\\Theta(n))=\\Theta(f(n))\\). _4.7-5_\n* Use the Akra-Bazzi method to solve the following recurrences. _a._ \\(T(n)=T(n/2)+T(n/3)+T(n/6)+n\\lg n\\). _b._ \\(T(n)=3T(n/3)+8T(n/4)+n^{2}/\\lg n\\). _c._ \\(T(n)=(2/3)T(n/3)+(1/3)T(2n/3)+\\lg n\\). _d._ \\(T(n)=(1/3)T(n/3)+1/n\\). _e._ \\(T(n)=3T(n/3)+3T(2n/3)+n^{2}\\). _4.7-6_\n* Use the Akra-Bazzi method to prove the continuous master theorem.\n\n## Problems\n\n### Recurrence examples\n\nGive asymptotically tight upper and lower bounds for \\(T(n)\\) in each of the following algorithmic recurrences. Justify your answers.\n\n* \\(T(n)=2T(n/2)+n^{3}\\). _b._ \\(T(n)=T(8n/11)+n\\). _c._ \\(T(n)=16T(n/4)+n^{2}\\). _d._ \\(T(n)=4T(n/2)+n^{2}\\lg n\\). _e._ \\(T(n)=8T(n/3)+n^{2}\\). _f._ \\(T(n)=7T(n/2)+n^{2}\\lg n\\). _g._ \\(T(n)=2T(n/4)+\\sqrt{n}\\). _h._ \\(T(n)=T(n-2)+n^{2}\\).",
        "chapter": "Part I Foundations",
        "section": "4 Divide-and-Conquer",
        "subsection": "4.7 Akra-Bazzi recurrences",
        "subsubsection": "N/A"
    },
    {
        "content": "* Give an example of a function \\(f(n)\\) that does not satisfy the polynomial-growth condition but for which \\(f(\\Theta(n))=\\Theta(f(n))\\). _4.7-5_\n* Use the Akra-Bazzi method to solve the following recurrences. _a._ \\(T(n)=T(n/2)+T(n/3)+T(n/6)+n\\lg n\\). _b._ \\(T(n)=3T(n/3)+8T(n/4)+n^{2}/\\lg n\\). _c._ \\(T(n)=(2/3)T(n/3)+(1/3)T(2n/3)+\\lg n\\). _d._ \\(T(n)=(1/3)T(n/3)+1/n\\). _e._ \\(T(n)=3T(n/3)+3T(2n/3)+n^{2}\\). _k.7-6_\n* Use the Akra-Bazzi method to prove the continuous master theorem.\n\n## Problems\n\n### Recurrence examples\n\nGive asymptotically tight upper and lower bounds for \\(T(n)\\) in each of the following algorithmic recurrences. Justify your answers.\n\n* \\(T(n)=2T(n/2)+n^{3}\\). _b._ \\(T(n)=T(8n/11)+n\\). _c._ \\(T(n)=16T(n/4)+n^{2}\\). _d._ \\(T(n)=4T(n/2)+n^{2}\\lg n\\). _e._ \\(T(n)=8T(n/3)+n^{2}\\). _f._ \\(T(n)=7T(n/2)+n^{2}\\lg n\\). _g._ \\(T(n)=2T(n/4)+\\sqrt{n}\\). _h._ \\(T(n)=T(n-2)+n^{2}\\).\n\n### 4.2 Parameter-passing costs\n\nThroughout this book, we assume that parameter passing during procedure calls takes constant time, even if an \\(N\\)-element array is being passed. This assumption is valid in most systems because a pointer to the array is passed, not the array itself. This problem examines the implications of three parameter-passing strategies:\n\n1. Arrays are passed by pointer. Time \\(=\\Theta(1)\\).\n2. Arrays are passed by copying. Time \\(=\\Theta(N)\\), where \\(N\\) is the size of the array.\n3. Arrays are passed by copying only the subrange that might be accessed by the called procedure. Time \\(=\\Theta(n)\\) if the subarray contains \\(n\\) elements.\n\nConsider the following three algorithms:\n\n1. The recursive binary-search algorithm for finding a number in a sorted array (see Exercise 2.3-6).\n2. The Merge-Sort procedure from Section 2.3.1.\n3. The Matrix-Multiply-Recursive procedure from Section 4.1.\n\nGive nine recurrences \\(T_{a1}(N,n)\\), \\(T_{a2}(N,n),\\ldots,T_{c3}(N,n)\\) for the worst-case running times of each of the three algorithms above when arrays and matrices are passed using each of the three parameter-passing strategies above. Solve your recurrences, giving tight asymptotic bounds.\n\n### 4.3 Solving recurrences with a change of variables\n\nSometimes, a little algebraic manipulation can make an unknown recurrence similar to one you have seen before. Let's solve the recurrence\n\n\\[T(n)=2T\\left(\\sqrt{n}\\right)+\\Theta(\\lg n) \\tag{4.25}\\]\n\nby using the change-of-variables method.\n\n1. Define \\(m=\\lg n\\) and \\(S(m)=T(2^{m})\\). Rewrite recurrence (4.25) in terms of \\(m\\) and \\(S(m)\\).\n2. Solve your recurrence for \\(S(m)\\).\n3. Use your solution for \\(S(m)\\) to conclude that \\(T(n)=\\Theta(\\lg n\\lg\\lg n)\\).\n4. Sketch the recursion tree for recurrence (4.25), and use it to explain intuitively why the solution is \\(T(n)=\\Theta(\\lg n\\lg\\lg n)\\).\n\nSolve the following recurrences by changing variables:e._ \\(T(n)=2T(\\sqrt{n})+\\Theta(1)\\).\n\nf._ \\(T(n)=3T(\\sqrt[3]{n})+\\Theta(n)\\).\n\n### More recurrence examples\n\nGive asymptotically tight upper and lower bounds for \\(T(n)\\) in each of the following recurrences. Justify your answers.\n\n_a._ \\(T(n)=5T(n/3)+n\\lg n\\).\n\n_b._ \\(T(n)=3T(n/3)+n/\\lg n\\).\n\n_c._ \\(T(n)=8T(n/2)+n^{3}\\sqrt{n}\\).\n\n_d._ \\(T(n)=2T(n/2-2)+n/2\\).\n\n_e._ \\(T(n)=2T(n/2)+n/\\lg n\\).\n\n_f._ \\(T(n)=T(n/2)+T(n/4)+T(n/8)+n\\).\n\n_g._ \\(T(n)=T(n-1)+1/n\\).\n\n_h._ \\(T(n)=T(n-1)+\\lg n\\).\n\n_i._ \\(T(n)=T(n-2)+1/\\lg n\\).\n\n_j._ \\(T(n)=\\sqrt{n}\\,T(\\sqrt{n})+n\\).\n\n### Fibonacci numbers\n\nThis problem develops properties of the Fibonacci numbers, which are defined by recurrence (3.31) on page 69. We'll explore the technique of generating functions to solve the Fibonacci recurrence. Define the _generating function_ (or _formal power series_) \\(\\mathcal{F}\\) as\n\n\\[\\mathcal{F}\\left(z\\right) = \\sum_{i=0}^{\\infty}F_{i}z^{i}\\] \\[= 0+z+z^{2}+2z^{3}+3z^{4}+5z^{5}+8z^{6}+13z^{7}+21z^{8}+\\cdots\\,,\\]\n\nwhere \\(F_{i}\\) is the \\(i\\)th Fibonacci number.\n\n_a._ Show that \\(\\mathcal{F}\\left(z\\right)=z+z\\mathcal{F}(z)+z^{2}\\mathcal{F}(z)\\).\n\nShow that\n\n\\[\\mathcal{F}\\left(z\\right) = \\frac{z}{1-z-z^{2}}\\] \\[= \\frac{z}{(1-\\phi z)(1-\\widehat{\\phi}z)}\\] \\[= \\frac{1}{\\sqrt{5}}\\left(\\frac{1}{1-\\phi z}-\\frac{1}{1-\\widehat{ \\phi}z}\\right)\\,\\]\n\nwhere \\(\\phi\\) is the golden ratio, and \\(\\widehat{\\phi}\\) is its conjugate (see page 69).\n\nShow that\n\n\\[\\mathcal{F}\\left(z\\right)=\\sum_{i\\,=\\,0}^{\\infty}\\frac{1}{\\sqrt{5}}(\\phi^{i}- \\widehat{\\phi}^{i})z^{i}\\.\\]\n\nYou may use without proof the generating-function version of equation (A.7) on page 1142, \\(\\sum_{k\\,=\\,0}^{\\infty}x^{k}=1/(1-x)\\). Because this equation involves a generating function, \\(x\\) is a formal variable, not a real-valued variable, so that you don't have to worry about convergence of the summation or about the requirement in equation (A.7) that \\(|x|<1\\), which doesn't make sense here.\n\nUse part (c) to prove that \\(F_{i}=\\phi^{i}/\\sqrt{5}\\) for \\(i\\,>\\,0\\), rounded to the nearest integer. (_Hint:_ Observe that \\(\\left|\\widehat{\\phi}\\right|<1\\).)\n\nProve that \\(F_{i+2}\\geq\\phi^{i}\\) for \\(i\\,\\geq\\,0\\).\n\n### 4.6 Chip testing\n\nProfessor Diogenes has \\(n\\) supposedly identical integrated-circuit chips that in principle are capable of testing each other. The professor's test jig accommodates two chips at a time. When the jig is loaded, each chip tests the other and reports whether it is good or bad. A good chip always reports accurately whether the other chip is good or bad, but the professor cannot trust the answer of a bad chip. Thus, the four possible outcomes of a test are as follows:\n\n\\begin{tabular}{l l l} Chip \\(A\\) says & Chip \\(B\\) says & Conclusion \\\\ \\hline \\(B\\) is good & \\(A\\) is good & both are good, or both are bad \\\\ \\(B\\) is good & \\(A\\) is bad & at least one is bad \\\\ \\(B\\) is bad & \\(A\\) is good & at least one is bad \\\\ \\(B\\) is bad & \\(A\\) is bad & at least one is bad \\\\ \\end{tabular}\n\nShow that if at least \\(n/2\\) chips are bad, the professor cannot necessarily determine which chips are good using any strategy based on this kind of pairwise test. Assume that the bad chips can conspire to fool the professor.\n\nNow you will design an algorithm to identify which chips are good and which are bad, assuming that more than \\(n/2\\) of the chips are good. First, you will determine how to identify one good chip.\n\n_b._ Show that \\(\\lfloor n/2\\rfloor\\) pairwise tests are sufficient to reduce the problem to one of nearly half the size. That is, show how to use \\(\\lfloor n/2\\rfloor\\) pairwise tests to obtain a set with at most \\(\\lceil n/2\\rceil\\) chips that still has the property that more than half of the chips are good.\n\n_c._ Show how to apply the solution to part (b) recursively to identify one good chip. Give and solve the recurrence that describes the number of tests needed to identify one good chip.\n\nYou have now determined how to identify one good chip.\n\n_d._ Show how to identify all the good chips with an additional \\(\\Theta(n)\\) pairwise tests.\n\n_4-7 Monge arrays_\n\nAn \\(m\\times n\\) array \\(A\\) of real numbers is a _Monge array_ if for all \\(i\\), \\(j\\), \\(k\\), and \\(l\\) such that \\(1\\leq i\\,<k\\,\\leq m\\) and \\(1\\leq j\\,<l\\,\\leq n\\), we have\n\n\\(A[i,j]\\,+\\,A[k,l]\\,\\leq\\,A[i,l]\\,+\\,A[k,j]\\).\n\nIn other words, whenever we pick two rows and two columns of a Monge array and consider the four elements at the intersections of the rows and the columns, the sum of the upper-left and lower-right elements is less than or equal to the sum of the lower-left and upper-right elements. For example, the following array is Monge:\n\n\\(10\\) \\(17\\) \\(13\\) \\(28\\) \\(23\\)\n\n\\(17\\) \\(22\\) \\(16\\) \\(29\\) \\(23\\)\n\n\\(24\\) \\(28\\) \\(22\\) \\(34\\) \\(24\\)\n\n\\(11\\) \\(13\\) \\(6\\) \\(17\\) \\(7\\)\n\n\\(45\\) \\(44\\) \\(32\\) \\(37\\) \\(23\\)\n\n\\(36\\) \\(33\\) \\(19\\) \\(21\\) \\(6\\)\n\n_75\\(66\\) \\(51\\) \\(53\\) \\(34\\)_\n\n_a._ Prove that an array is Monge if and only if for all \\(i\\,=\\,1,2,...,m-1\\) and \\(j\\,=\\,1,2,...,n-1\\), we have\n\n\\(A[i,j]\\,+\\,A[i\\,+\\,1,j\\,+\\,1]\\,\\leq\\,A[i,j\\,+\\,1]\\,+\\,A[i\\,+\\,1,j]\\).\n\n(_Hint:_ For the \"if\" part, use induction separately on rows and columns.)\n\n_b._ The following array is not Monge. Change one element in order to make it Monge. (_Hint:_ Use part (a).)\n\n[MISSING_PAGE_EMPTY:6]",
        "chapter": "Part I Foundations",
        "section": "4 Divide-and-Conquer",
        "subsection": "Problems",
        "subsubsection": "N/A"
    },
    {
        "content": "* [103] [104] [105] [106] [107] [108] [109] [110] [111] [112] [113] [114] [115] [116] [117] [118] [119] [120] [121] [122] [123] [124] [125] [126] [127] [128] [129] [129] [130] [131] [132] [133] [134] [135] [136] [137] [138] [139] [139] [130] [131] [132] [133] [134] [135] [136] [137] [138] [139] [139] [130] [131] [132] [133] [134] [135] [136] [137] [138] [139] [139] [130] [131] [132] [133] [134] [135] [136] [137] [138] [139] [139] [131] [133] [135] [137] [138] [139] [130] [131] [132] [133] [134] [135] [136] [137] [138] [139] [139] [130] [131] [133] [134] [135] [136] [137] [138] [139] [139] [131] [132] [133] [135] [138] [139] [130] [131] [133] [134] [135] [136] [137] [138] [139] [139] [131] [132] [133] [134] [135] [136] [137] [138] [139] [139] [130] [131] [132] [133] [134] [135] [136] [137] [138] [139] [139] [130] [131] [132] [133] [134] [135] [136] [137] [138] [139] [139] [131] [130] [131] [132] [133] [134] [135] [136] [137] [138] [139] [139] [130] [131] [132] [133] [134] [135] [136] [137] [138] [139] [139] [130] [131] [138] [139] [131] [132] [133] [134] [135] [136] [137] [138] [139] [139] [130] [131] [132] [133] [134] [135] [136] [137] [138] [139] [139] [130] [131] [133] [139] [131] [132] [134] [135] [136] [137] [138] [139] [139] [130] [131] [133] [134] [135] [136] [137] [138] [139] [139] [130] [131] [132] [134] [135] [138] [139] [131] [132] [133] [134] [135] [136] [137] [138] [139] [139] [130] [131] [133] [134] [135] [136] [137] [138] [139] [139] [130] [131] [131] [132] [133] [134] [135] [136] [137] [138] [139] [139] [131] [130] [132] [133] [134] [135] [138] [139] [130] [131] [133] [134] [135] [136] [137] [138] [139] [131] [139] [132] [133] [134] [135] [137] [139] [138] [139] [139] [130] [131] [131] [132] [134] [135] [136] [137] [138] [139] [139] [130] [131] [131] [138] [139] [131] [132] [133] [134] [135] [136] [137] [138] [139] [139] [130] [131] [139] [131] [132] [134] [135] [138] [139] [139] [130] [131] [134] [135] [136] [137] [138] [139] [139] [130] [131] [139] [131] [132] [134] [135] [138] [139] [130] [131] [131] [133] [134] [135] [136] [137] [138] [139] [139] [130] [131] [134] [138] [139] [131] [132] [133] [134] [135] [136] [137] [138] [139] [139] [130] [131] [131] [134] [138] [139] [131] [130] [132] [133] [135] [134] [136] [137] [138] [139] [139] [130] [131] [139] [131] [132] [134] [139] [133] [135] [136] [137] [138] [139] [139] [130] [131] [139] [131] [132] [133] [134] [135] [138] [139] [130] [131] [139] [131] [133] [134] [135] [136] [137] [138] [139] [139] [130] [131] [138] [139] [131] [139] [130] [131] [131] [132] [133] [134] [135] [136] [137] [138] [139] [139] [131] [138] [139] [130] [139] [131] [130] [131] [132] [134] [135] [138] [139] [1340] [135] [136] [137] [138] [139] [139] [130] [131] [139] [131] [139] [131] [132] [133] [134] [135] [136] [137] [138] [139] [139] [131] [139] [130] [131] [139] [131] [130] [131] [132] [134] [135] [138] [139] [130] [131] [1340] [1341] [139] [132] [135] [136] [137] [138] [139] [139] [130] [131] [139] [130] [131] [131] [139] [131] [131] [132] [133] [134] [135] [136] [137] [138] [139] [139] [130] [131] [138] [139] [130] [131] [139] [131] [131] [131] [132] [1340] [133] [135] [136] [137] [138] [139] [139] [130] [139] [130] [131] [131] [131] [131] [132] [133] [134] [135] [136] [137] [138] [139] [139] [130] [131] [131] [139] [131] [130] [131] [131] [132] [133] [133] [134] [135] [136] [137] [138] [139] [139] [130] [131] [130] [139] [131] [131] [130] [131] [131] [132] [133] [134] [135] [136] [137] [138] [139] [130] [139] [130] [131] [139] [131] [131] [130] [131] [131] [131] [132]bound to \\(O(n^{2.376})\\) time with a mathematically sophisticated but wildly impractical algorithm based on tensor products. It took approximately 25 years before the asymptotic upper bound was again improved. In 2012 Vassilevska Williams [445] improved it to \\(O(n^{2.37287})\\), and two years later Le Gall [278] achieved \\(O(n^{2.37286})\\), both of them using mathematically fascinating but impractical algorithms. The best lower bound to date is just the obvious \\(\\Omega(n^{2})\\) bound (obvious because any algorithm for matrix multiplication must fill in the \\(n^{2}\\) elements of the product matrix).\n\nThe performance of Matrix-Multiply-Recursive can be improved in practice by coarsening the leaves of the recursion. It also exhibits better cache behavior than Matrix-Multiply, although Matrix-Multiply can be improved by \"tiling.\" Leiserson et al. [293] conducted a performance-engineering study of matrix multiplication in which a parallel and vectorized divide-and-conquer algorithm achieved the highest performance. Strassen's algorithm can be practical for large dense matrices, although large matrices tend to be sparse, and sparse methods can be much faster. When using limited-precision floating-point values, Strassen's algorithm produces larger numerical errors than the \\(\\Theta(n^{3})\\) algorithms do, although Higham [215] demonstrated that Strassen's algorithm is amply accurate for some applications.\n\nRecurrences were studied as early as 1202 by Leonardo Bonacci [66], also known as Fibonacci, for whom the Fibonacci numbers are named, although Indian mathematicians had discovered Fibonacci numbers centuries before. The French mathematician De Moivre [108] introduced the method of generating functions with which he studied Fibonacci numbers (see Problem 4-5). Knuth [259] and Liu [302] are good resources for learning the method of generating functions.\n\nAho, Hopcroft, and Ullman [5, 6] offered one of the first general methods for solving recurrences arising from the analysis of divide-and-conquer algorithms. The master method was adapted from Bentley, Haken, and Saxe [52]. The Akra-Bazzi method is due (unsurprisingly) to Akra and Bazzi [13]. Divide-and-conquer recurrences have been studied by many researchers, including Campbell [79], Graham, Knuth, and Patashnik [199], Kuszmaul and Leiserson [274], Leighton [287], Purdom and Brown [371], Roura [389], Verma [447], and Yap [462].\n\nThe issue of floors and ceilings in divide-and-conquer recurrences, including a theorem similar to Theorem 4.5, was studied by Leighton [287]. Leighton proposed a version of the polynomial-growth condition. Campbell [79] removed several limitations in Leighton's statement of it and showed that there were polynomially bounded functions that do not satisfy Leighton's condition. Campbell also carefully studied many other technical issues, including the well-definedness of divide-and-conquer recurrences. Kuszmaul and Leiserson [274] provided a proof of Theorem 4.5 that does not involve calculus or other higher math. Both Campbell and Leighton explored the perturbations of arguments beyond simple floors and ceilings.\n\n## Chapter Probabilistic Analysis and Randomized Algorithms\n\nThis chapter introduces probabilistic analysis and randomized algorithms. If you are unfamiliar with the basics of probability theory, you should read Sections C.1-C.4 of Appendix C, which review this material. We'll revisit probabilistic analysis and randomized algorithms several times throughout this book.\n\n### 1 The hiring problem\n\nSuppose that you need to hire a new office assistant. Your previous attempts at hiring have been unsuccessful, and you decide to use an employment agency. The employment agency sends you one candidate each day. You interview that person and then decide either to hire that person or not. You must pay the employment agency a small fee to interview an applicant. To actually hire an applicant is more costly, however, since you must fire your current office assistant and also pay a substantial hiring fee to the employment agency. You are committed to having, at all times, the best possible person for the job. Therefore, you decide that, after interviewing each applicant, if that applicant is better qualified than the current office assistant, you will fire the current office assistant and hire the new applicant. You are willing to pay the resulting price of this strategy, but you wish to estimate what that price will be.\n\nThe procedure Hire-Assistant on the facing page expresses this strategy for hiring in pseudocode. The candidates for the office assistant job are numbered 1 through \\(n\\) and interviewed in that order. The procedure assumes that after interviewing candidate \\(i\\), you can determine whether candidate \\(i\\) is the best candidate you have seen so far. It starts by creating a dummy candidate, numbered \\(0\\), who is less qualified than each of the other candidates.\n\nThe cost model for this problem differs from the model described in Chapter 2. We focus not on the running time of Hire-Assistant, but instead on the fees paid for interviewing and hiring. On the surface, analyzing the cost of this algorithm",
        "chapter": "Part I Foundations",
        "section": "4 Divide-and-Conquer",
        "subsection": "Chapter notes",
        "subsubsection": "N/A"
    },
    {
        "content": "## Chapter Probabilistic Analysis and Randomized Algorithms\n\nThis chapter introduces probabilistic analysis and randomized algorithms. If you are unfamiliar with the basics of probability theory, you should read Sections C.1-C.4 of Appendix C, which review this material. We'll revisit probabilistic analysis and randomized algorithms several times throughout this book.\n\n### 1 The hiring problem\n\nSuppose that you need to hire a new office assistant. Your previous attempts at hiring have been unsuccessful, and you decide to use an employment agency. The employment agency sends you one candidate each day. You interview that person and then decide either to hire that person or not. You must pay the employment agency a small fee to interview an applicant. To actually hire an applicant is more costly, however, since you must fire your current office assistant and also pay a substantial hiring fee to the employment agency. You are committed to having, at all times, the best possible person for the job. Therefore, you decide that, after interviewing each applicant, if that applicant is better qualified than the current office assistant, you will fire the current office assistant and hire the new applicant. You are willing to pay the resulting price of this strategy, but you wish to estimate what that price will be.\n\nThe procedure Hire-Assistant on the facing page expresses this strategy for hiring in pseudocode. The candidates for the office assistant job are numbered 1 through \\(n\\) and interviewed in that order. The procedure assumes that after interviewing candidate \\(i\\), you can determine whether candidate \\(i\\) is the best candidate you have seen so far. It starts by creating a dummy candidate, numbered \\(0\\), who is less qualified than each of the other candidates.\n\nThe cost model for this problem differs from the model described in Chapter 2. We focus not on the running time of Hire-Assistant, but instead on the fees paid for interviewing and hiring. On the surface, analyzing the cost of this algorithm\n\n### The hiring problem\n\nHire-Assistant(\\(n\\))\n\n```\n1\\(best=0\\)// candidate 0 is a least-qualified dummy candidate\n2for\\(i=1\\)to\\(n\\)\n3 interview candidate \\(i\\)\n4ifcandidate \\(i\\) is better than candidate \\(best\\)\n5\\(best=i\\)\n6 hire candidate \\(i\\)\n```\n\nListing 10: The hiring problem\n\nIn the worst case, you actually hire every candidate that you interview. This situation occurs if the candidates come in strictly increasing order of quality, in which case you hire \\(n\\) times, for a total hiring cost of \\(O(c_{h}n)\\).\n\nOf course, the candidates do not always come in increasing order of quality. In fact, you have no idea about the order in which they arrive, nor do you have any control over this order. Therefore, it is natural to ask what we expect to happen in a typical or average case.\n\n#### Probabilistic analysis\n\n_Probabilistic analysis_ is the use of probability in the analysis of problems. Most commonly, we use probabilistic analysis to analyze the running time of an algorithm. Sometimes we use it to analyze other quantities, such as the hiring cost inprocedure Hire-Assistant. In order to perform a probabilistic analysis, we must use knowledge of, or make assumptions about, the distribution of the inputs. Then we analyze our algorithm, computing an average-case running time, where we take the average, or expected value, over the distribution of the possible inputs. When reporting such a running time, we refer to it as the _average-case running time_.\n\nYou must be careful in deciding on the distribution of inputs. For some problems, you may reasonably assume something about the set of all possible inputs, and then you can use probabilistic analysis as a technique for designing an efficient algorithm and as a means for gaining insight into a problem. For other problems, you cannot characterize a reasonable input distribution, and in these cases you cannot use probabilistic analysis.\n\nFor the hiring problem, we can assume that the applicants come in a random order. What does that mean for this problem? We assume that you can compare any two candidates and decide which one is better qualified, which is to say that there is a total order on the candidates. (See Section B.2 for the definition of a total order.) Thus, you can rank each candidate with a unique number from \\(1\\) through \\(n\\), using \\(rank(i)\\) to denote the rank of applicant \\(i\\), and adopt the convention that a higher rank corresponds to a better qualified applicant. The ordered list \\(\\langle rank(1),\\)\\(rank(2),\\ldots,rank(n)\\rangle\\) is a permutation of the list \\(\\langle 1,\\)\\(2,\\)\\(\\ldots,\\)\\(n\\rangle\\). Saying that the applicants come in a random order is equivalent to saying that this list of ranks is equally likely to be any one of the \\(n!\\) permutations of the numbers \\(1\\) through \\(n\\). Alternatively, we say that the ranks form a _uniform random permutation_, that is, each of the possible \\(n!\\) permutations appears with equal probability.\n\nSection 5.2 contains a probabilistic analysis of the hiring problem.\n\n### Randomized algorithms\n\nIn order to use probabilistic analysis, you need to know something about the distribution of the inputs. In many cases, you know little about the input distribution. Even if you do know something about the distribution, you might not be able to model this knowledge computationally. Yet, probability and randomness often serve as tools for algorithm design and analysis, by making part of the algorithm behave randomly.\n\nIn the hiring problem, it may seem as if the candidates are being presented to you in a random order, but you have no way of knowing whether they really are. Thus, in order to develop a randomized algorithm for the hiring problem, you need greater control over the order in which you'll interview the candidates. We will, therefore, change the model slightly. The employment agency sends you a list of the \\(n\\) candidates in advance. On each day, you choose, randomly, which candidate to interview. Although you know nothing about the candidates (besides their names), we have made a significant change. Instead of accepting the order given \n\n### 5.1 The hiring problem\n\nThe problem is that the problem is that the problem is that the problem is that the problem is that the problem is that the problem is that the problem is that the problem is that the problem is that the problem is that the problem is that the problem is that the problem is that the problem is that the problem is that the problem is that the problem is that the problem is that the problem is that the problem is that the problem is that the problem is that the problem is that the problem is that the problem is that the problem is that the problem is that the problem is that the problem is that the problem is that the problem is that the problem is that the problem is that the problem is that the problem is that the problem is that the problem is that the problem is that the problem is that the problem is that the problem is that the problem is that the problem is that the problem is that the problem is that the problem is that the problem is that the problem is that the problem is that the problem is that the problem is that the problem is that the problem is that the problem is that the problem is that the problem is that the problem is that the problem is that the problem is that the problem is that the problem is that the problem is that the problem is that the problem is that the problem is that the problem is that the problem is that the problem is that the problem is that the problem is that the problem is that the problem that the problem is that the problem that is the problem that the problem is that the problem is that the problem is that the problem that is the problem that the problem is that the problem is that the problem that is the problem that the problem is that the problem that is the problem that the problem is that the problem that is the problem that the problem that is the problem that the problem is that the problem that is the problem that the problem that is the problem that the problem is that the problem that is the problem that the problem that is the problem that the problem that is the problem that the problem that is the problem that the problem that is the problem that the problem that is the problem that the problem that is the problem that the problem that is the problem that the problem that is the problem that the problem that is the problem that the problem that is the problem that the problem that is the problem that the problem that is the problem that the problem that is the problem that the problem that is the problem that the problem that is the problem that the problem that is the problem that the problem that is the problem that the problem that is the problem that the problem that is the problem that the problem that is the problem that the problem that is the problem that the problem that is the problem that the problem that is the problem that the problem that is the problem that the problem that is the problem that the problem that is the problem that the problem that is the problem that the problem that is the problem that the problem that is the problem that the problem that is the problem that the problem that is the problem that the problem that is the problem that the problem that is the problem that the problem that is the problem that the problem that is the problem that the problem that is the problem that the problem that is the problem that the problem that is the problem that the problem that is the problem that the problem that is the problem that the problem that is the problem that the problem that is the problem that the problem that is the problem that the problem that is the problem that the problem that is the problem that the problem that is the problem that the problem that is the problem that the problem that is the problem that the problem that is the problem that the problem that is the problem that the problem that is the problem that the problem that is the problem that the problem that is the problem that the problem that is the problem that the problem that is the problem that the problem that is the problem that the problem that is the problem that the problem that is the problem that the problem that is the problem that the problem that is the problem that the problem that is the problem that the problem that is the problem that the problem that is the problem that the problem that is the problem that the problem that is the problem that the problem that is the problem that the problem that is the problem that the problem that is the problem that the problem that is the problem that the problem that is the problem that the problem that is the problem that the problem that is the problem that the problem that is the problem that the problem that is the problem that the problem that is the problem that the problem that is the problem that the problem that is the problem that the problem that is the problem that the problem that is the problem that the problem that is the problem that the problem that is the problem that the problem that is the problem that is the problem that the problem that is the problem that the problem that is the problem that is the problem that the problem that is the problem that the problem that is the problem that the problem that is the problem that the problem that is the problem that is the problem that the problem that is the problem that the problem that is the problem that the problem that is the problem that is the problem that the problem that is the problem that is the problem that the problem that is the problem that the problem that is the problem that the problem that is the problem that is the problem that the problem that is the problem that the problem that is the problem that is the problem that the problem that is the problem that is the problem that the problem that is the problem that the problem that is the problem that is the problem that the problem that is the problem that is the problem that the problem that is the problem that is the problem that the problem that is the problem that the problem that is the problem that the problem that is the problem that is the problem that the problem that is the problem that is the problem that the problem that is the problem that is the problem that the problem that is the problem that is the problem that the problem that is the problem that is the problem that the problem that is the problem that the problem that is the problem that the problem that is the problem that is the problem that is the problem that the problem that is the problem that is the problem that is the problem that the problem that is the problem that is the problem that is the problem that the problem that is the problem that the problem that is the problem that is the problem that that is the problem that the problem that is the problem that the problem that is the problem that is the problem that the problem that is the problem that the problem that is the problem that the problem that is the problem that the problem that is the problem that is the problem that the problem that is the problem that the problem that is the problem that the problem that is the problem that the problem that is the problem that the problem that is the problem that the problem that is the problem that is the problem that the problem that is the problem that the problem that is the problem that the problem that is the problem that the problem that is the problem that is the problem that the problem that is the problem that the problem that is the problem that the problem that is the problem that the problem that is the problem that is the problem that the problem that is the problem that is the problem that the problem that is the problem that the problem that is the problem that the problem that is the problem that the problem that is the problem that is the problem that the problem that is the problem that is the problem that is the problem that is the problem that the problem that is the problem that is the problem that the problem that is the problem that the problem that is the problem that is the problem that the problem that is the problem that is the problem that is the problem that is the problem that is the problem that the problem that is the problem that is the problem that is the problem that the problem that is the problem that is the problem that is the problem that the problem that is the problem that is the problem that the problem that is the problem that the problem that is the problem that is the problem that is the problem that the problem that is the problem that is the problem that is the problem that is the problem that is the problem that the problem that is the problem that is the problem that is the problem that the problem that is the problem that is the problem that is the problem that is the problem that the problem that is the problem that the problem that is the problem that is the problem that the problem that is the problem that is the problem that is the problem that the problem that is the problem that is the problem that is the problem that the problem that is the problem that the problem that is the problem that is the problem that is the problem that the problem that is the problem that is the problem that is the problem that is the problem that the problem that is the problem that is the problem that the problem that is the problem that the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that that is the problem that is the problem that is the problem that is the problem that the problem that is the problem that is the problem that is the problem that is the problem that the problem that is the problem that is the problem that that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that that is the problem that is the problem that is the problem that that is the problem that is the problem that the problem that is the problem that is the problem that is the problem that is the problem that that is the problem that is the problem that is the problem that that is the problem that is the problem that is the problem that that is the problem that is the problem that is the problem that the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that that is the problem that is the problem that that is the problem that is the problem that that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that that is the problem that is the problem that is the problem that is the problem that that is the problem that is the problem that is the problem that is the problem that is the problem that that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that that is the problem that is the problem that is the problem that that is the problem that is the problem that is the problem that is the problem that that is the problem that is the problem that is the problem that is the problem that that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is that is the problem that is the problem that is the problem that is the problem that that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that that is the problem that is the problem that is the problem that is that that is the problem that is the problem that is that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is the problem that is that that is the\n\n### 5.2 Indicator random variables\n\nIn order to analyze many algorithms, including the hiring problem, we use indicator random variables. Indicator random variables provide a convenient method for converting between probabilities and expectations. Given a sample space \\(S\\) and an event \\(A\\), the _indicator random variable_\\(\\mathrm{I}\\left\\{A\\right\\}\\) associated with event \\(A\\) is defined as\n\n\\[\\mathrm{I}\\left\\{A\\right\\}=\\left\\{\\begin{array}{ll}1&\\mbox{if $A$ occurs,}\\\\ 0&\\mbox{if $A$ does not occur.}\\end{array}\\right. \\tag{5.1}\\]\n\nAs a simple example, let us determine the expected number of heads obtained when flipping a fair coin. The sample space for a single coin flip is \\(S=\\left\\{H,T\\right\\}\\), with \\(\\Pr\\left\\{H\\right\\}=\\Pr\\left\\{T\\right\\}=1/2\\). We can then define an indicator random variable \\(X_{H}\\), associated with the coin coming up heads, which is the event \\(H\\). This variable counts the number of heads obtained in this flip, and it is 1 if the coin comes up heads and 0 otherwise. We write\n\n\\[X_{H} = \\mathrm{I}\\left\\{H\\right\\}\\] \\[= \\left\\{\\begin{array}{ll}1&\\mbox{if $H$ occurs,}\\\\ 0&\\mbox{if $T$ occurs.}\\end{array}\\right.\\]\n\nThe expected number of heads obtained in one flip of the coin is simply the expected value of our indicator variable \\(X_{H}\\):\n\n\\[\\mathrm{E}\\left[X_{H}\\right] = \\mathrm{E}\\left[\\mathrm{I}\\left\\{H\\right\\}\\right]\\] \\[= 1\\cdot\\Pr\\left\\{H\\right\\}+0\\cdot\\Pr\\left\\{T\\right\\}\\] \\[= 1\\cdot\\left(1/2\\right)+0\\cdot\\left(1/2\\right)\\] \\[= 1/2\\.\\]\n\nThus the expected number of heads obtained by one flip of a fair coin is \\(1/2\\). As the following lemma shows, the expected value of an indicator random variable associated with an event \\(A\\) is equal to the probability that \\(A\\) occurs.\n\n_Lemma 5.1_: Given a sample space \\(S\\) and an event \\(A\\) in the sample space \\(S\\), let \\(X_{A}=\\mathrm{I}\\left\\{A\\right\\}\\). Then \\(\\mathrm{E}\\left[X_{A}\\right]=\\Pr\\left\\{A\\right\\}\\).\n\n_Proof_ By the definition of an indicator random variable from equation (5.1) and the definition of expected value, we have\n\n\\[\\mathrm{E}\\left[X_{A}\\right] = \\mathrm{E}\\left[\\mathrm{I}\\left\\{A\\right\\}\\right]\\] \\[= 1\\cdot\\Pr\\left\\{A\\right\\}+0\\cdot\\Pr\\left\\{\\overline{A}\\right\\}\\] \\[= \\Pr\\left\\{A\\right\\}\\,\\]",
        "chapter": "Part I Foundations",
        "section": "5 Probabilistic Analysis and Randomized Algorithms",
        "subsection": "5.1 The hiring problem",
        "subsubsection": "N/A"
    },
    {
        "content": "### 5.2 Indicator random variables\n\nIn order to analyze many algorithms, including the hiring problem, we use indicator random variables. Indicator random variables provide a convenient method for converting between probabilities and expectations. Given a sample space \\(S\\) and an event \\(A\\), the _indicator random variable_\\(\\mathrm{I}\\left\\{A\\right\\}\\) associated with event \\(A\\) is defined as\n\n\\[\\mathrm{I}\\left\\{A\\right\\}=\\left\\{\\begin{array}{ll}1&\\mbox{if $A$ occurs,}\\\\ 0&\\mbox{if $A$ does not occur.}\\end{array}\\right. \\tag{5.1}\\]\n\nAs a simple example, let us determine the expected number of heads obtained when flipping a fair coin. The sample space for a single coin flip is \\(S=\\left\\{H,T\\right\\}\\), with \\(\\Pr\\left\\{H\\right\\}=\\Pr\\left\\{T\\right\\}=1/2\\). We can then define an indicator random variable \\(X_{H}\\), associated with the coin coming up heads, which is the event \\(H\\). This variable counts the number of heads obtained in this flip, and it is 1 if the coin comes up heads and 0 otherwise. We write\n\n\\[X_{H} = \\mathrm{I}\\left\\{H\\right\\}\\] \\[= \\left\\{\\begin{array}{ll}1&\\mbox{if $H$ occurs,}\\\\ 0&\\mbox{if $T$ occurs.}\\end{array}\\right.\\]\n\nThe expected number of heads obtained in one flip of the coin is simply the expected value of our indicator variable \\(X_{H}\\):\n\n\\[\\mathrm{E}\\left[X_{H}\\right] = \\mathrm{E}\\left[\\mathrm{I}\\left\\{H\\right\\}\\right]\\] \\[= 1\\cdot\\Pr\\left\\{H\\right\\}+0\\cdot\\Pr\\left\\{T\\right\\}\\] \\[= 1\\cdot\\left(1/2\\right)+0\\cdot\\left(1/2\\right)\\] \\[= 1/2\\.\\]\n\nThus the expected number of heads obtained by one flip of a fair coin is \\(1/2\\). As the following lemma shows, the expected value of an indicator random variable associated with an event \\(A\\) is equal to the probability that \\(A\\) occurs.\n\n_Lemma 5.1_: Given a sample space \\(S\\) and an event \\(A\\) in the sample space \\(S\\), let \\(X_{A}=\\mathrm{I}\\left\\{A\\right\\}\\). Then \\(\\mathrm{E}\\left[X_{A}\\right]=\\Pr\\left\\{A\\right\\}\\).\n\n_Proof_ By the definition of an indicator random variable from equation (5.1) and the definition of expected value, we have\n\n\\[\\mathrm{E}\\left[X_{A}\\right] = \\mathrm{E}\\left[\\mathrm{I}\\left\\{A\\right\\}\\right]\\] \\[= 1\\cdot\\Pr\\left\\{A\\right\\}+0\\cdot\\Pr\\left\\{\\overline{A}\\right\\}\\] \\[= \\Pr\\left\\{A\\right\\}\\,\\]where \\(\\overline{A}\\) denotes \\(S-A\\), the complement of \\(A\\).\n\nAlthough indicator random variables may seem cumbersome for an application such as counting the expected number of heads on a flip of a single coin, they are useful for analyzing situations that perform repeated random trials. In Appendix C, for example, indicator random variables provide a simple way to determine the expected number of heads in \\(n\\) coin flips. One option is to consider separately the probability of obtaining 0 heads, 1 head, 2 heads, etc. to arrive at the result of equation (C.41) on page 1199. Alternatively, we can employ the simpler method proposed in equation (C.42), which uses indicator random variables implicitly. Making this argument more explicit, let \\(X_{i}\\) be the indicator random variable associated with the event in which the \\(i\\)th flip comes up heads: \\(X_{i}\\,=\\,\\mathrm{I}\\,\\{\\)the \\(i\\)th flip results in the event \\(H\\}\\). Let \\(X\\) be the random variable denoting the total number of heads in the \\(n\\) coin flips, so that\n\n\\[X\\,=\\,\\sum_{i\\,=\\,1}^{n}X_{i}\\.\\]\n\nIn order to compute the expected number of heads, take the expectation of both sides of the above equation to obtain\n\n\\[\\mathrm{E}\\,[X]=\\mathrm{E}\\left[\\sum_{i\\,=\\,1}^{n}X_{i}\\right]. \\tag{5.2}\\]\n\nBy Lemma 5.1, the expectation of each of the random variables is \\(\\mathrm{E}\\,[X_{i}]\\,=\\,1/2\\) for \\(i\\,=\\,1,2,\\ldots,n\\). Then we can compute the sum of the expectations: \\(\\sum_{i\\,=\\,1}^{n}\\mathrm{E}\\,[X_{i}]\\,=\\,n/2\\). But equation (5.2) calls for the expectation of the sum, not the sum of the expectations. How can we resolve this conundrum? Linearity of expectation, equation (C.24) on page 1192, to the rescue: _the expectation of the sum always equals the sum of the expectations_. Linearity of expectation applies even when there is dependence among the random variables. Combining indicator random variables with linearity of expectation gives us a powerful technique to compute expected values when multiple events occur. We now can compute the expected number of heads:\n\n\\[\\mathrm{E}\\,[X] = \\mathrm{E}\\left[\\sum_{i\\,=\\,1}^{n}X_{i}\\,\\right]\\] \\[= \\sum_{i\\,=\\,1}^{n}\\mathrm{E}\\,[X_{i}]\\] \\[= \\sum_{i\\,=\\,1}^{n}1/2\\] \\[= n/2\\.\\]Thus, compared with the method used in equation (C.41), indicator random variables greatly simplify the calculation. We use indicator random variables throughout this book.\n\n##### Analysis of the hiring problem using indicator random variables\n\nReturning to the hiring problem, we now wish to compute the expected number of times that you hire a new office assistant. In order to use a probabilistic analysis, let's assume that the candidates arrive in a random order, as discussed in Section 5.1. (We'll see in Section 5.3 how to remove this assumption.) Let \\(X\\) be the random variable whose value equals the number of times you hire a new office assistant. We could then apply the definition of expected value from equation (C.23) on page 1192 to obtain\n\n\\[\\mathrm{E}\\left[X\\right]=\\sum_{x=1}^{n}x\\;\\Pr\\left\\{X=x\\right\\}\\;,\\]\n\nbut this calculation would be cumbersome. Instead, let's simplify the calculation by using indicator random variables.\n\nTo use indicator random variables, instead of computing \\(\\mathrm{E}\\left[X\\right]\\) by defining just one variable denoting the number of times you hire a new office assistant, think of the process of hiring as repeated random trials and define \\(n\\) variables indicating whether each particular candidate is hired. In particular, let \\(X_{i}\\) be the indicator random variable associated with the event in which the \\(i\\)th candidate is hired. Thus,\n\n\\[X_{i} = \\mathrm{I}\\left\\{\\text{candidate $i$ is hired}\\right\\}\\] \\[= \\left\\{\\begin{array}{ll}1&\\text{if candidate $i$ is hired },\\\\ 0&\\text{if candidate $i$ is not hired },\\end{array}\\right.\\]\n\nand\n\n\\[X=X_{1}+X_{2}+\\cdots+X_{n}\\;. \\tag{5.3}\\]\n\nLemma 5.1 gives\n\n\\[\\mathrm{E}\\left[X_{i}\\right]=\\Pr\\left\\{\\text{candidate $i$ is hired}\\right\\}\\;,\\]\n\nand we must therefore compute the probability that lines 5-6 of Hire-Assistant are executed.\n\nCandidate \\(i\\) is hired, in line 6, exactly when candidate \\(i\\) is better than each of candidates \\(1\\) through \\(i-1\\). Because we have assumed that the candidates arrive in a random order, the first \\(i\\) candidates have appeared in a random order. Any one of these first \\(i\\) candidates is equally likely to be the best qualified so far. Candidate \\(i\\) has a probability of \\(1/i\\) of being better qualified than candidates \\(1\\) through \\(i-1\\) and thus a probability of \\(1/i\\) of being hired. By Lemma 5.1, we conclude that \\[\\mathrm{E}\\left[X_{i}\\right]=1/i. \\tag{5.4}\\]\n\nNow we can compute \\(\\mathrm{E}\\left[X\\right]\\):\n\n\\[\\mathrm{E}\\left[X\\right] = \\mathrm{E}\\left[\\sum_{i\\,=\\,1}^{n}X_{i}\\right]\\quad\\text{(by equation \\eqref{eq:E1})}\\] \\[= \\sum_{i\\,=\\,1}^{n}\\mathrm{E}\\left[X_{i}\\right]\\quad\\quad\\text{(by equation \\eqref{eq:E1}, linearity of expectation)}\\] \\[= \\sum_{i\\,=\\,1}^{n}\\frac{1}{i}\\quad\\quad\\quad\\quad\\text{(by equation \\eqref{eq:E1})}\\] \\[= \\ln n\\,+\\,O(1)\\quad\\text{(by equation \\eqref{eq:E1}, the harmonic series)}. \\tag{5.6}\\]\n\nEven though you interview \\(n\\) people, you actually hire only approximately \\(\\ln n\\) of them, on average. We summarize this result in the following lemma.\n\n**Lemma 5.2**: _Assuming that the candidates are presented in a random order, algorithm HireAssistant has an average-case total hiring cost of \\(\\,O(c_{h}\\,\\ln n)\\)._\n\n_Proof_The bound follows immediately from our definition of the hiring cost and equation (5.6), which shows that the expected number of hires is approximately \\(\\ln n\\).\n\nThe average-case hiring cost is a significant improvement over the worst-case hiring cost of \\(\\,O(c_{h}n)\\).\n\n### Exercises\n\n#### 5.2-1\n\nIn Hire-Assistant, assuming that the candidates are presented in a random order, what is the probability that you hire exactly one time? What is the probability that you hire exactly \\(n\\) times?\n\n#### 5.2-2\n\nIn Hire-Assistant, assuming that the candidates are presented in a random order, what is the probability that you hire exactly twice?\n\n#### 5.2-3\n\nUse indicator random variables to compute the expected value of the sum of \\(n\\) dice.\n\n#### 5.2-4\n\nThis exercise asks you to (partly) verify that linearity of expectation holds even if the random variables are not independent. Consider two 6-sided dice that are rolled independently. What is the expected value of the sum? Now consider the case where the first die is rolled normally and then the second die is set equal to the value shown on the first die. What is the expected value of the sum? Now consider the case where the first die is rolled normally and the second die is set equal to 7 minus the value of the first die. What is the expected value of the sum?\n\n#### 5.2-5\n\nUse indicator random variables to solve the following problem, which is known as the _hat-check problem_. Each of \\(n\\) customers gives a hat to a hat-check person at a restaurant. The hat-check person gives the hats back to the customers in a random order. What is the expected number of customers who get back their own hat?\n\n#### 5.2-6\n\nLet \\(A[1:n]\\) be an array of \\(n\\) distinct numbers. If \\(i<j\\) and \\(A[i]>A[j]\\), then the pair \\((i,j)\\) is called an _inversion_ of \\(A\\). (See Problem 2-4 on page 47 for more on inversions.) Suppose that the elements of \\(A\\) form a uniform random permutation of \\(\\langle 1,2,\\ldots,n\\rangle\\). Use indicator random variables to compute the expected number of inversions.\n\n### 5.3 Randomized algorithms\n\nIn the previous section, we showed how knowing a distribution on the inputs can help us to analyze the average-case behavior of an algorithm. What if you do not know the distribution? Then you cannot perform an average-case analysis. As mentioned in Section 5.1, however, you might be able to use a randomized algorithm.\n\nFor a problem such as the hiring problem, in which it is helpful to assume that all permutations of the input are equally likely, a probabilistic analysis can guide us when developing a randomized algorithm. Instead of _assuming_ a distribution of inputs, we _impose_ a distribution. In particular, before running the algorithm, let's randomly permute the candidates in order to enforce the property that every permutation is equally likely. Although we have modified the algorithm, we still expect to hire a new office assistant approximately \\(\\ln n\\) times. But now we expect this to be the case for _any_ input, rather than for inputs drawn from a particular distribution.\n\nLet us further explore the distinction between probabilistic analysis and randomized algorithms. In Section 5.2, we claimed that, assuming that the candidates",
        "chapter": "Part I Foundations",
        "section": "5 Probabilistic Analysis and Randomized Algorithms",
        "subsection": "5.2 Indicator random variables",
        "subsubsection": "N/A"
    },
    {
        "content": "#### 5.2-4\n\nThis exercise asks you to (partly) verify that linearity of expectation holds even if the random variables are not independent. Consider two 6-sided dice that are rolled independently. What is the expected value of the sum? Now consider the case where the first die is rolled normally and then the second die is set equal to the value shown on the first die. What is the expected value of the sum? Now consider the case where the first die is rolled normally and the second die is set equal to 7 minus the value of the first die. What is the expected value of the sum?\n\n#### 5.2-5\n\nUse indicator random variables to solve the following problem, which is known as the _hat-check problem_. Each of \\(n\\) customers gives a hat to a hat-check person at a restaurant. The hat-check person gives the hats back to the customers in a random order. What is the expected number of customers who get back their own hat?\n\n#### 5.2-6\n\nLet \\(A[1:n]\\) be an array of \\(n\\) distinct numbers. If \\(i<j\\) and \\(A[i]>A[j]\\), then the pair \\((i,j)\\) is called an _inversion_ of \\(A\\). (See Problem 2-4 on page 4 for more on inversions.) Suppose that the elements of \\(A\\) form a uniform random permutation of \\(\\langle 1,2,\\ldots,n\\rangle\\). Use indicator random variables to compute the expected number of inversions.\n\n### 5.3 Randomized algorithms\n\nIn the previous section, we showed how knowing a distribution on the inputs can help us to analyze the average-case behavior of an algorithm. What if you do not know the distribution? Then you cannot perform an average-case analysis. As mentioned in Section 5.1, however, you might be able to use a randomized algorithm.\n\nFor a problem such as the hiring problem, in which it is helpful to assume that all permutations of the input are equally likely, a probabilistic analysis can guide us when developing a randomized algorithm. Instead of _assuming_ a distribution of inputs, we _impose_ a distribution. In particular, before running the algorithm, let's randomly permute the candidates in order to enforce the property that every permutation is equally likely. Although we have modified the algorithm, we still expect to hire a new office assistant approximately \\(\\ln n\\) times. But now we expect this to be the case for _any_ input, rather than for inputs drawn from a particular distribution.\n\nLet us further explore the distinction between probabilistic analysis and randomized algorithms. In Section 5.2, we claimed that, assuming that the candidatesarrive in a random order, the expected number of times you hire a new office assistant is about \\(\\ln n\\). This algorithm is deterministic: for any particular input, the number of times a new office assistant is hired is always the same. Furthermore, the number of times you hire a new office assistant differs for different inputs, and it depends on the ranks of the various candidates. Since this number depends only on the ranks of the candidates, to represent a particular input, we can just list, in order, the ranks \\(\\langle rank(1),\\,rank(2),\\,\\ldots,\\,rank(n)\\rangle\\) of the candidates. Given the rank list \\(A_{1}=\\langle 1,\\,2,\\,3,\\,4,\\,5,\\,6,\\,7,\\,8,\\,9,\\,10\\rangle\\), a new office assistant is always hired 10 times, since each successive candidate is better than the previous one, and lines 5-6 of Hire-Assistant are executed in each iteration. Given the list of ranks \\(A_{2}=\\langle 10,\\,9,\\,8,\\,7,\\,6,\\,5,\\,4,\\,3,\\,2,\\,1\\rangle\\), a new office assistant is hired only once, in the first iteration. Given a list of ranks \\(A_{3}=\\langle 5,\\,2,\\,1,\\,8,\\,4,\\,7,\\,10,\\,9,\\,3,\\,6\\rangle\\), a new office assistant is hired three times, upon interviewing the candidates with ranks 5, 8, and 10. Recalling that the cost of our algorithm depends on how many times you hire a new office assistant, we see that there are expensive inputs such as \\(A_{1}\\), inexpensive inputs such as \\(A_{2}\\), and moderately expensive inputs such as \\(A_{3}\\).\n\nConsider, on the other hand, the randomized algorithm that first permutes the list of candidates and then determines the best candidate. In this case, we randomize in the algorithm, not in the input distribution. Given a particular input, say \\(A_{3}\\) above, we cannot say how many times the maximum is updated, because this quantity differs with each run of the algorithm. The first time you run the algorithm on \\(A_{3}\\), it might produce the permutation \\(A_{1}\\) and perform 10 updates. But the second time you run the algorithm, it might produce the permutation \\(A_{2}\\) and perform only one update. The third time you run the algorithm, it might perform some other number of updates. Each time you run the algorithm, its execution depends on the random choices made and is likely to differ from the previous execution of the algorithm. For this algorithm and many other randomized algorithms, _no particular input elicits its worst-case behavior_. Even your worst enemy cannot produce a bad input array, since the random permutation makes the input order irrelevant. The randomized algorithm performs badly only if the random-number generator produces an \"unlucky\" permutation.\n\nFor the hiring problem, the only change needed in the code is to randomly permute the array, as done in the Randomized-Hire-Assistant procedure. This simple change creates a randomized algorithm whose performance matches that obtained by assuming that the candidates were presented in a random order.\n\nRandomized-Hire-Assistant(\\(n\\))\n1 randomly permute the list of candidates\n2 Hire-Assistant(\\(n\\))\n\n**Lemma 5.3**: _The expected hiring cost of the procedure Randomized-Hire-Assistant is \\(O(c_{h}\\ln n)\\)._\n\n_Proof_Permuting the input array achieves a situation identical to that of the probabilistic analysis of Hire-Assistant in Section 5.2.\n\nBy carefully comparing Lemmas 5.2 and 5.3, you can see the difference between probabilistic analysis and randomized algorithms. Lemma 5.2 makes an assumption about the input. Lemma 5.3 makes no such assumption, although randomizing the input takes some additional time. To remain consistent with our terminology, we couched Lemma 5.2 in terms of the average-case hiring cost and Lemma 5.3 in terms of the expected hiring cost. In the remainder of this section, we discuss some issues involved in randomly permuting inputs.\n\n### Randomly permuting arrays\n\nMany randomized algorithms randomize the input by permuting a given input array. We'll see elsewhere in this book other ways to randomize an algorithm, but now, let's see how we can randomly permute an array of \\(n\\) elements. The goal is to produce a _uniform random permutation_, that is, a permutation that is as likely as any other permutation. Since there are \\(n!\\) possible permutations, we want the probability that any particular permutation is produced to be \\(1/n!\\).\n\nYou might think that to prove that a permutation is a uniform random permutation, it suffices to show that, for each element \\(A[i]\\), the probability that the element winds up in position \\(j\\) is \\(1/n\\). Exercise 5.3-4 shows that this weaker condition is, in fact, insufficient.\n\nOur method to generate a random permutation permutes the array _in place_: at most a constant number of elements of the input array are ever stored outside the array. The procedure Randomly-Permute permutes an array \\(A[1:n]\\) in place in \\(\\Theta(n)\\) time. In its \\(i\\)th iteration, it chooses the element \\(A[i]\\) randomly from among elements \\(A[i]\\) through \\(A[n]\\). After the \\(i\\)th iteration, \\(A[i]\\) is never altered.\n\n\\[\\begin{array}{l}\\mbox{\\sc Randomly-Permute}(A,n)\\\\ \\mbox{\\sc 1\\quad for $i\\ =\\ 1$ to $n$}\\\\ \\mbox{\\sc 2\\quad swap $A[i]$ with $A[\\mbox{\\sc Random}(i,n)]$}\\end{array}\\]\n\nWe use a loop invariant to show that procedure Randomly-Permute produces a uniform random permutation. A _\\(k\\)-permutation_ on a set of \\(n\\) elements is a sequence containing \\(k\\) of the \\(n\\) elements, with no repetitions. (See page 1180 in Appendix C.) There are \\(n!/(n-k)!\\) such possible \\(k\\)-permutations.\n\n**Lemma 5.4**: Procedure Randomly-Permute computes a uniform random permutation.\n\n_Proof_ We use the following loop invariant:\n\nJust prior to the \\(i\\)th iteration of the **for** loop of lines 1-2, for each possible\n\n\\((i-1)\\)-permutation of the \\(n\\) elements, the subarray \\(A[1:i-1]\\) contains this\n\n\\((i-1)\\)-permutation with probability \\((n-i+1)!/n!\\).\n\nWe need to show that this invariant is true prior to the first loop iteration, that each iteration of the loop maintains the invariant, that the loop terminates, and that the invariant provides a useful property to show correctness when the loop terminates.\n\n**Initialization:**: Consider the situation just before the first loop iteration, so that \\(i=1\\). The loop invariant says that for each possible \\(0\\)-permutation, the subarray \\(A[1:0]\\) contains this \\(0\\)-permutation with probability \\((n-i+1)!/n!=n!/n!=1\\). The subarray \\(A[1:0]\\) is an empty subarray, and a \\(0\\)-permutation has no elements. Thus, \\(A[1:0]\\) contains any \\(0\\)-permutation with probability \\(1\\), and the loop invariant holds prior to the first iteration.\n**Maintenance:**: By the loop invariant, we assume that just before the \\(i\\)th iteration, each possible \\((i-1)\\)-permutation appears in the subarray \\(A[1:i-1]\\) with probability \\((n-i+1)!/n!\\). We shall show that after the \\(i\\)th iteration, each possible \\(i\\)-permutation appears in the subarray \\(A[1:i]\\) with probability \\((n-i)!/n!\\). Incrementing \\(i\\) for the next iteration then maintains the loop invariant.\n\nLet us examine the \\(i\\)th iteration. Consider a particular \\(i\\)-permutation, and denote the elements in it by \\(\\langle x_{1},\\,x_{2},\\,\\ldots,\\,x_{i}\\rangle\\). This permutation consists of an \\((i-1)\\)-permutation \\(\\langle x_{1},\\,\\ldots,\\,x_{i-1}\\rangle\\) followed by the value \\(x_{i}\\) that the algorithm places in \\(A[i]\\). Let \\(E_{1}\\) denote the event in which the first \\(i-1\\) iterations have created the particular \\((i-1)\\)-permutation \\(\\langle x_{1},\\,\\ldots,\\,x_{i-1}\\rangle\\) in \\(A[1:i-1]\\). By the loop invariant, \\(\\Pr\\,\\{E_{1}\\}=(n-i+1)!/n!\\). Let \\(E_{2}\\) be the event that the \\(i\\)th iteration puts \\(x_{i}\\) in position \\(A[i]\\). The \\(i\\)-permutation \\(\\langle x_{1},\\,\\ldots,\\,x_{i}\\rangle\\) appears in \\(A[1:i]\\) precisely when both \\(E_{1}\\) and \\(E_{2}\\) occur, and so we wish to compute \\(\\Pr\\,\\{E_{2}\\,\\cap\\,E_{1}\\}\\). Using equation (C.16) on page 1187, we have\n\n\\[\\Pr\\,\\{E_{2}\\,\\cap\\,E_{1}\\}=\\Pr\\,\\{E_{2}\\,\\mid\\,E_{1}\\}\\Pr\\,\\{E_{1}\\}\\enspace.\\]\n\nThe probability \\(\\Pr\\,\\{E_{2}\\,\\mid\\,E_{1}\\}\\) equals \\(1/(n-i+1)\\) because in line 2 the algorithm chooses \\(x_{i}\\) randomly from the \\(n-i+1\\) values in positions \\(A[i:n]\\). Thus, we have \\[\\Pr\\left\\{E_{2}\\cap E_{1}\\right\\} = \\Pr\\left\\{E_{2}\\mid E_{1}\\right\\}\\Pr\\left\\{E_{1}\\right\\}\\] \\[= \\frac{1}{n-i\\,+\\,1}\\cdot\\frac{(n-i\\,+\\,1)!}{n!}\\] \\[= \\frac{(n-i)!}{n!}\\;.\\]\n**Termination:**: The loop terminates, since it is a **for** loop iterating \\(n\\) times. At termination, \\(i\\,=\\,n\\,+\\,1\\), and we have that the subarray \\(A[1\\!:\\!n]\\) is a given \\(n\\)-permutation with probability \\((n-(n+1)+1)!/n!=0!/n!=1/n!\\). Thus, Randomly-Permute produces a uniform random permutation.\n\nA randomized algorithm is often the simplest and most efficient way to solve a problem.\n\n## Exercises\n\n### 5.3-1\n\nProfessor Marceau objects to the loop invariant used in the proof of Lemma 5.4. He questions whether it holds prior to the first iteration. He reasons that we could just as easily declare that an empty subarray contains no 0-permutations. Therefore, the probability that an empty subarray contains a 0-permutation should be 0, thus invalidating the loop invariant prior to the first iteration. Rewrite the procedure Randomly-Permute so that its associated loop invariant applies to a nonempty subarray prior to the first iteration, and modify the proof of Lemma 5.4 for your procedure.\n\n### 5.3-2\n\nProfessor Kelp decides to write a procedure that produces at random any permutation except the _identity permutation_, in which every element ends up where it started. He proposes the procedure Permute-Without-Identity. Does this procedure do what Professor Kelp intends?\n\n```\nPermute-Without-Identity(\\(A,n\\))\n1for\\(i\\,=\\,1\\)to\\(n-1\\)\n2swap\\(A[i]\\) with \\(A[\\mbox{\\sc Random}(i\\,+\\,1,n)]\\)\n```\n\n### 5.3-3\n\nConsider the Permute-With-All procedure on the facing page, which instead of swapping element \\(A[i]\\) with a random element from the subarray \\(A[i:n]\\), swaps it with a random element from anywhere in the array. Does Permute-With-All produce a uniform random permutation? Why or why not?\n\n### Randomized algorithms\n\nPermute-With-All(\\(A,n\\))\n\n```\n1for\\(i=1\\)to\\(n\\) swap\\(A[i]\\) with\\(A[\\mbox{\\sc Random}(1,n)]\\)\n```\n\n#### 5.3-4\n\nProfessor Knievel suggests the procedure Permute-By-Cycle to generate a uniform random permutation. Show that each element \\(A[i]\\) has a \\(1/n\\) probability of winding up in any particular position in \\(B\\). Then show that Professor Knievel is mistaken by showing that the resulting permutation is not uniformly random.\n\nPermute-By-Cycle(\\(A,n\\))\n\n```\n1let\\(B[1:n]\\) be a new array offset \\(=\\)Random(\\(1,n\\))\n2for\\(i=1\\)to\\(n\\)\n3\\(dest=i+\\)offset if\\(dest>n\\)\n4\\(dest=dest-n\\)\n5\\(B[dest]=A[i]\\)\n6return\\(B\\)\n```\n\n#### 5.3-5\n\nProfessor Gallup wants to create a _random sample_ of the set \\(\\{1,2,3,\\ldots,n\\}\\), that is, an \\(m\\)-element subset \\(S\\), where \\(0\\leq m\\leq n\\), such that each \\(m\\)-subset is equally likely to be created. One way is to set \\(A[i]=i\\), for \\(i=1,2,3,\\ldots,n\\), call Randomly-Permute(\\(A\\)), and then take just the first \\(m\\) array elements. This method makes \\(n\\) calls to the Random procedure. In Professor Gallup's application, \\(n\\) is much larger than \\(m\\), and so the professor wants to create a random sample with fewer calls to Random.\n\nRandom-Sample(\\(m,n\\))\n1\\(S=\\emptyset\\)\n2for\\(k=n-m+1\\)to\\(n\\) // iterates \\(m\\) times\n3\\(i=\\)Random(\\(1,k\\))\n4if\\(i\\in S\\)\n5\\(S=S\\cup\\{k\\}\\)\n6else\\(S=S\\cup\\{i\\}\\)\n7return\\(S\\) ```\n\n**Algorithm 5**Random-Sample(\\(m,n\\))\n\nShow that the procedure Random-Sample on the previous page returns a random \\(m\\)-subset \\(S\\) of \\(\\{1,2,3,\\ldots,n\\}\\), in which each \\(m\\)-subset is equally likely, while making only \\(m\\) calls to Random.\n\n### 5.4 Probabilistic analysis and further uses of indicator random variables\n\nThis advanced section further illustrates probabilistic analysis by way of four examples. The first determines the probability that in a room of \\(k\\) people, two of them share the same birthday. The second example examines what happens when randomly tossing balls into bins. The third investigates \"streaks\" of consecutive heads when flipping coins. The final example analyzes a variant of the hiring problem in which you have to make decisions without actually interviewing all the candidates.\n\n#### The birthday paradox\n\nOur first example is the _birthday paradox_. How many people must there be in a room before there is a 50% chance that two of them were born on the same day of the year? The answer is surprisingly few. The paradox is that it is in fact far fewer than the number of days in a year, or even half the number of days in a year, as we shall see.\n\nTo answer this question, we index the people in the room with the integers \\(1,2,\\ldots,k\\), where \\(k\\) is the number of people in the room. We ignore the issue of leap years and assume that all years have \\(n=365\\) days. For \\(i=1,2,\\ldots,k\\), let \\(b_{i}\\) be the day of the year on which person \\(i\\)'s birthday falls, where \\(1\\leq b_{i}\\leq n\\). We also assume that birthdays are uniformly distributed across the \\(n\\) days of the year, so that \\(\\Pr\\left\\{b_{i}=r\\right\\}=1/n\\) for \\(i=1,2,\\ldots,k\\) and \\(r=1,2,\\ldots,n\\).\n\nThe probability that two given people, say \\(i\\) and \\(j\\), have matching birthdays depends on whether the random selection of birthdays is independent. We assume from now on that birthdays are independent, so that the probability that \\(i\\)'s birthday and \\(j\\)'s birthday both fall on day \\(r\\) is\n\n\\[\\Pr\\left\\{b_{i}=r\\text{ and }b_{j}=r\\right\\} = \\Pr\\left\\{b_{i}=r\\right\\}\\Pr\\left\\{b_{j}=r\\right\\}\\] \\[= \\frac{1}{n^{2}}\\.\\]\n\nThus, the probability that they both fall on the same day is\n\n\\[\\Pr\\left\\{b_{i}=b_{j}\\right\\} = \\sum_{r=1}^{n}\\Pr\\left\\{b_{i}=r\\text{ and }b_{j}=r\\right\\}\\]",
        "chapter": "Part I Foundations",
        "section": "5 Probabilistic Analysis and Randomized Algorithms",
        "subsection": "5.3 Randomized algorithms",
        "subsubsection": "N/A"
    },
    {
        "content": "Show that the procedure Random-Sample on the previous page returns a random \\(m\\)-subset \\(S\\) of \\(\\{1,2,3,\\ldots,n\\}\\), in which each \\(m\\)-subset is equally likely, while making only \\(m\\) calls to Random.\n\n### 5.4 Probabilistic analysis and further uses of indicator random variables\n\nThis advanced section further illustrates probabilistic analysis by way of four examples. The first determines the probability that in a room of \\(k\\) people, two of them share the same birthday. The second example examines what happens when randomly tossing balls into bins. The third investigates \"streaks\" of consecutive heads when flipping coins. The final example analyzes a variant of the hiring problem in which you have to make decisions without actually interviewing all the candidates.\n\n#### The birthday paradox\n\nOur first example is the _birthday paradox_. How many people must there be in a room before there is a 50% chance that two of them were born on the same day of the year? The answer is surprisingly few. The paradox is that it is in fact far fewer than the number of days in a year, or even half the number of days in a year, as we shall see.\n\nTo answer this question, we index the people in the room with the integers \\(1,2,\\ldots,k\\), where \\(k\\) is the number of people in the room. We ignore the issue of leap years and assume that all years have \\(n=365\\) days. For \\(i=1,2,\\ldots,k\\), let \\(b_{i}\\) be the day of the year on which person \\(i\\)'s birthday falls, where \\(1\\leq b_{i}\\leq n\\). We also assume that birthdays are uniformly distributed across the \\(n\\) days of the year, so that \\(\\Pr\\left\\{b_{i}=r\\right\\}=1/n\\) for \\(i=1,2,\\ldots,k\\) and \\(r=1,2,\\ldots,n\\).\n\nThe probability that two given people, say \\(i\\) and \\(j\\), have matching birthdays depends on whether the random selection of birthdays is independent. We assume from now on that birthdays are independent, so that the probability that \\(i\\)'s birthday and \\(j\\)'s birthday both fall on day \\(r\\) is\n\n\\[\\Pr\\left\\{b_{i}=r\\text{ and }b_{j}=r\\right\\} = \\Pr\\left\\{b_{i}=r\\right\\}\\Pr\\left\\{b_{j}=r\\right\\}\\] \\[= \\frac{1}{n^{2}}\\.\\]\n\nThus, the probability that they both fall on the same day is\n\n\\[\\Pr\\left\\{b_{i}=b_{j}\\right\\} = \\sum_{r=1}^{n}\\Pr\\left\\{b_{i}=r\\text{ and }b_{j}=r\\right\\}\\]\\[= \\sum_{r=1}^{n}\\frac{1}{n^{2}} \\tag{5.7}\\] \\[= \\frac{1}{n}\\.\\]\n\nMore intuitively, once \\(b_{i}\\) is chosen, the probability that \\(b_{j}\\) is chosen to be the same day is \\(1/n\\). As long as the birthdays are independent, the probability that \\(i\\) and \\(j\\) have the same birthday is the same as the probability that the birthday of one of them falls on a given day.\n\nWe can analyze the probability of at least 2 out of \\(k\\) people having matching birthdays by looking at the complementary event. The probability that at least two of the birthdays match is 1 minus the probability that all the birthdays are different. The event \\(B_{k}\\) that \\(k\\) people have distinct birthdays is\n\n\\[B_{k}=\\bigcap_{i=1}^{k}A_{i}\\,\\]\n\nwhere \\(A_{i}\\) is the event that person \\(i\\)'s birthday is different from person \\(j\\)'s for all \\(j<i\\). Since we can write \\(B_{k}=A_{k}\\,\\cap\\,B_{k-1}\\), we obtain from equation (C.18) on page 1189 the recurrence\n\n\\[\\Pr\\left\\{B_{k}\\right\\}=\\Pr\\left\\{B_{k-1}\\right\\}\\Pr\\left\\{A_{k}\\ \\mid\\,B_{k-1}\\right\\}\\, \\tag{5.8}\\]\n\nwhere we take \\(\\Pr\\left\\{B_{1}\\right\\}=\\Pr\\left\\{A_{1}\\right\\}=1\\) as an initial condition. In other words, the probability that \\(b_{1},b_{2},\\ldots,b_{k}\\) are distinct birthdays equals the probability that \\(b_{1},b_{2},\\ldots,b_{k-1}\\) are distinct birthdays multiplied by the probability that \\(b_{k}\\neq b_{i}\\) for \\(i=1,2,\\ldots,k-1\\), given that \\(b_{1},b_{2},\\ldots,b_{k-1}\\) are distinct.\n\nIf \\(b_{1},b_{2},\\ldots,b_{k-1}\\) are distinct, the conditional probability that \\(b_{k}\\neq b_{i}\\) for \\(i=1,2,\\ldots,k-1\\) is \\(\\Pr\\left\\{A_{k}\\mid B_{k-1}\\right\\}=(n-k+1)/n\\), since out of the \\(n\\) days, \\(n-(k-1)\\) days are not taken. We iteratively apply the recurrence (5.8) to obtain\n\n\\[\\Pr\\left\\{B_{k}\\right\\} = \\Pr\\left\\{B_{k-1}\\right\\}\\Pr\\left\\{A_{k}\\ \\mid\\,B_{k-1}\\right\\}\\] \\[= \\Pr\\left\\{B_{k-2}\\right\\}\\Pr\\left\\{A_{k-1}\\ \\mid\\,B_{k-2}\\right\\}\\Pr\\left\\{A_{k}\\ \\mid\\,B_{k-1}\\right\\}\\] \\[\\vdots\\] \\[= \\Pr\\left\\{B_{1}\\right\\}\\Pr\\left\\{A_{2}\\ \\mid\\,B_{1}\\right\\}\\Pr\\left\\{A_{3}\\ \\mid\\,B_{2}\\right\\}\\cdots\\Pr\\left\\{A_{k}\\ \\mid\\,B_{k-1}\\right\\}\\] \\[= 1\\cdot\\left(\\frac{n-1}{n}\\right)\\left(\\frac{n-2}{n}\\right) \\cdots\\left(\\frac{n-k+1}{n}\\right)\\] \\[= 1\\cdot\\left(1-\\frac{1}{n}\\right)\\left(1-\\frac{2}{n}\\right) \\cdots\\left(1-\\frac{k-1}{n}\\right)\\.\\]\n\nInequality (3.14) on page 66, \\(1+x\\leq e^{x}\\), gives us \\[\\Pr\\left\\{B_{k}\\right\\} \\leq e^{-1/n}e^{-2/n}\\cdots e^{-(k-1)/n}\\] \\[= e^{-\\sum_{i=1}^{k-1}i/n}\\] \\[= e^{-k(k-1)/2n}\\] \\[\\leq \\frac{1}{2}\\]\n\nwhen \\(-k(k-1)/2n\\leq\\ln(1/2)\\). The probability that all \\(k\\) birthdays are distinct is at most \\(1/2\\) when \\(k(k-1)\\geq 2n\\ln 2\\) or, solving the quadratic equation, when \\(k\\geq(1+\\sqrt{1+(8\\ln 2)n})/2\\). For \\(n=365\\), we must have \\(k\\geq 23\\). Thus, if at least 23 people are in a room, the probability is at least \\(1/2\\) that at least two people have the same birthday. Since a year on Mars is 669 Martian days long, it takes 31 Martians to get the same effect.\n\n##### An analysis using indicator random variables\n\nIndicator random variables afford a simpler but approximate analysis of the birthday paradox. For each pair \\((i,j)\\) of the \\(k\\) people in the room, define the indicator random variable \\(X_{ij}\\), for \\(1\\leq i<j\\leq k\\), by\n\n\\[X_{ij} = \\mathrm{I}\\left\\{\\mathrm{person}\\ i\\ \\mathrm{and}\\ \\mathrm{person}\\ j\\ \\mathrm{have}\\ \\mathrm{the}\\ \\mathrm{same}\\ \\mathrm{birthday}\\right\\}\\] \\[= \\left\\{\\begin{array}{ll}1&\\mathrm{if}\\ \\mathrm{person}\\ i\\ \\mathrm{and}\\ \\mathrm{person}\\ j\\ \\mathrm{have}\\ \\mathrm{the}\\ \\mathrm{same}\\ \\mathrm{birthday}\\,\\\\ 0&\\mathrm{otherwise}\\.\\end{array}\\right.\\]\n\nBy equation (5.7), the probability that two people have matching birthdays is \\(1/n\\), and thus by Lemma 5.1 on page 130, we have\n\n\\[\\mathrm{E}\\left[X_{ij}\\right] = \\Pr\\left\\{\\mathrm{person}\\ i\\ \\mathrm{and}\\ \\mathrm{person}\\ j\\ \\mathrm{have}\\ \\mathrm{the}\\ \\mathrm{same}\\ \\mathrm{birthday}\\right\\}\\] \\[= 1/n\\.\\]\n\nLetting \\(X\\) be the random variable that counts the number of pairs of individuals having the same birthday, we have\n\n\\[X=\\sum_{i=1}^{k-1}\\sum_{j=i+1}^{k}X_{ij}\\.\\]\n\nTaking expectations of both sides and applying linearity of expectation, we obtain\n\n\\[\\mathrm{E}\\left[X\\right] = \\mathrm{E}\\left[\\sum_{i=1}^{k-1}\\sum_{j=i+1}^{k}X_{ij}\\right]\\] \\[= \\sum_{i=1}^{k-1}\\sum_{j=i+1}^{k}\\mathrm{E}\\left[X_{ij}\\right]\\]\\[= \\binom{k}{2}\\frac{1}{n}\\] \\[= \\frac{k(k-1)}{2n}\\.\\]\n\nWhen \\(k(k-1)\\geq 2n\\), therefore, the expected number of pairs of people with the same birthday is at least \\(1\\). Thus, if we have at least \\(\\sqrt{2n}+1\\) individuals in a room, we can expect at least two to have the same birthday. For \\(n=365\\), if \\(k=28\\), the expected number of pairs with the same birthday is \\((28\\cdot 27)/(2\\cdot 365)\\approx 1.0356\\). Thus, with at least \\(28\\) people, we expect to find at least one matching pair of birthdays. On Mars, with \\(669\\) days per year, we need at least \\(38\\) Martians.\n\nThe first analysis, which used only probabilities, determined the number of people required for the probability to exceed \\(1/2\\) that a matching pair of birthdays exists, and the second analysis, which used indicator random variables, determined the number such that the expected number of matching birthdays is \\(1\\). Although the exact numbers of people differ for the two situations, they are the same asymptotically: \\(\\Theta(\\sqrt{n})\\).\n\n#### Balls and bins\n\nConsider a process in which you randomly toss identical balls into \\(b\\) bins, numbered \\(1,2,\\ldots,b\\). The tosses are independent, and on each toss the ball is equally likely to end up in any bin. The probability that a tossed ball lands in any given bin is \\(1/b\\). If we view the ball-tossing process as a sequence of Bernoulli trials (see Appendix C.4), where success means that the ball falls in the given bin, then each trial has a probability \\(1/b\\) of success. This model is particularly useful for analyzing hashing (see Chapter 11), and we can answer a variety of interesting questions about the ball-tossing process. (Problem C-2 asks additional questions about balls and bins.)\n\n* _How many balls fall in a given bin?_ The number of balls that fall in a given bin follows the binomial distribution \\(b(k;n,1/b)\\). If you toss \\(n\\) balls, equation (C.41) on page 1199 tells us that the expected number of balls that fall in the given bin is \\(n/b\\).\n* _How many balls must you toss, on the average, until a given bin contains a ball?_ The number of tosses until the given bin receives a ball follows the geometric distribution with probability \\(1/b\\) and, by equation (C.36) on page 1197, the expected number of tosses until success is \\(1/(1/b)=b\\).\n* _How many balls must you toss until every bin contains at least one ball?_ Let us call a toss in which a ball falls into an empty bin a \"hit.\" We want to know the expected number \\(n\\) of tosses required to get \\(b\\) hits.\n\nUsing the hits, we can partition the \\(n\\) tosses into stages. The \\(i\\)th stage consists of the tosses after the \\((i-1)\\)st hit up to and including the \\(i\\)th hit. The first stage consists of the first toss, since you are guaranteed to have a hit when all bins are empty. For each toss during the \\(i\\)th stage, \\(i-1\\) bins contain balls and \\(b-i+1\\) bins are empty. Thus, for each toss in the \\(i\\)th stage, the probability of obtaining a hit is \\((b-i+1)/b\\).\n\nLet \\(n_{i}\\) denote the number of tosses in the \\(i\\)th stage. The number of tosses required to get \\(b\\) hits is \\(n=\\sum_{i=1}^{b}n_{i}\\). Each random variable \\(n_{i}\\) has a geometric distribution with probability of success \\((b-i+1)/b\\) and thus, by equation (C.36), we have\n\n\\[\\mathrm{E}\\left[n_{i}\\right]=\\frac{b}{b-i+1}\\.\\]\n\nBy linearity of expectation, we have\n\n\\[\\mathrm{E}\\left[n\\right] = \\mathrm{E}\\left[\\sum_{i=1}^{b}n_{i}\\right]\\] \\[= \\sum_{i=1}^{b}\\frac{b}{b-i+1}\\] \\[= b\\sum_{i=1}^{b}\\frac{1}{i}\\] (by equation (A.14) on page 1144) \\[= b(\\ln b+O(1))\\] (by equation (A.9) on page 1142).\n\nIt therefore takes approximately \\(b\\ln b\\) tosses before we can expect that every bin has a ball. This problem is also known as the _coupon collector's problem_, which says that if you are trying to collect each of \\(b\\) different coupons, then you should expect to acquire approximately \\(b\\ln b\\) randomly obtained coupons in order to succeed.\n\n#### Streaks\n\nSuppose that you flip a fair coin \\(n\\) times. What is the longest streak of consecutive heads that you expect to see? We'll prove upper and lower bounds separately to show that the answer is \\(\\Theta(\\lg n)\\).\n\nWe first prove that the expected length of the longest streak of heads is \\(O(\\lg n)\\). The probability that each coin flip is a head is \\(1/2\\). Let \\(A_{ik}\\) be the event that a streak of heads of length at least \\(k\\) begins with the \\(i\\)th coin flip or, more precisely, the event that the \\(k\\) consecutive coin flips \\(i,i+1,\\ldots,i+k-1\\) yield only heads, where \\(1\\leq k\\leq n\\) and \\(1\\leq i\\leq n-k+1\\). Since coin flips are mutually independent, for any given event \\(A_{ik}\\), the probability that all \\(k\\) flips are heads is\n\n\\[\\Pr\\left\\{A_{ik}\\right\\}=\\frac{1}{2^{k}}. \\tag{5.9}\\]\n\nFor \\(k=2\\left\\lceil\\lg n\\right\\rceil\\),\n\n\\[\\Pr\\left\\{A_{i,2\\left\\lceil\\lg n\\right\\rceil}\\right\\} = \\frac{1}{2^{2\\left\\lceil\\lg n\\right\\rceil}}\\] \\[\\leq \\frac{1}{2^{2\\lg n}}\\] \\[= \\frac{1}{n^{2}}\\,\\]\n\nand thus the probability that a streak of heads of length at least \\(2\\left\\lceil\\lg n\\right\\rceil\\) begins in position \\(i\\) is quite small. There are at most \\(n-2\\left\\lceil\\lg n\\right\\rceil+1\\) positions where such a streak can begin. The probability that a streak of heads of length at least \\(2\\left\\lceil\\lg n\\right\\rceil\\) begins anywhere is therefore\n\n\\[\\Pr\\left\\{\\overset{n-2\\left\\lceil\\lg n\\right\\rceil+1}{\\bigcup}A_{i,2 \\left\\lceil\\lg n\\right\\rceil}\\right\\}\\] \\[\\leq \\sum_{i=1}^{n-2\\left\\lceil\\lg n\\right\\rceil+1}\\Pr\\left\\{A_{i,2 \\left\\lceil\\lg n\\right\\rceil}\\right\\}\\quad\\text{(by Boole's inequality (C.21) on page 1190)}\\] \\[\\leq \\sum_{i=1}^{n-2\\left\\lceil\\lg n\\right\\rceil+1}\\frac{1}{n^{2}}\\] \\[< \\sum_{i=1}^{n}\\frac{1}{n^{2}}\\] \\[= \\frac{1}{n}. \\tag{5.10}\\]\n\nWe can use inequality (5.10) to bound the length of the longest streak. For \\(j=0,1,2,\\ldots,n\\), let \\(L_{j}\\) be the event that the longest streak of heads has length exactly \\(j\\), and let \\(L\\) be the length of the longest streak. By the definition of expected value, we have\n\n\\[\\operatorname{E}\\left[L\\right]=\\sum_{j=0}^{n}j\\Pr\\left\\{L_{j}\\right\\}. \\tag{5.11}\\]We could try to evaluate this sum using upper bounds on each \\(\\Pr\\left\\{L_{j}\\right\\}\\) similar to those computed in inequality (5.10). Unfortunately, this method yields weak bounds. We can use some intuition gained by the above analysis to obtain a good bound, however. For no individual term in the summation in equation (5.11) are both the factors \\(j\\) and \\(\\Pr\\left\\{L_{j}\\right\\}\\) large. Why? When \\(j\\geq 2\\left\\lceil\\lg n\\right\\rceil\\), then \\(\\Pr\\left\\{L_{j}\\right\\}\\) is very small, and when \\(j<2\\left\\lceil\\lg n\\right\\rceil\\), then \\(j\\) is fairly small. More precisely, since the events \\(L_{j}\\) for \\(j=0,1,\\ldots,n\\) are disjoint, the probability that a streak of heads of length at least \\(2\\left\\lceil\\lg n\\right\\rceil\\) begins anywhere is \\(\\sum_{j=2\\left\\lceil\\lg n\\right\\rceil}^{n}\\Pr\\left\\{L_{j}\\right\\}\\). Inequality (5.10) tells us that the probability that a streak of heads of length at least \\(2\\left\\lceil\\lg n\\right\\rceil\\) begins anywhere is less than \\(1/n\\), which means that \\(\\sum_{j=2\\left\\lceil\\lg n\\right\\rceil}^{n}\\Pr\\left\\{L_{j}\\right\\}<1/n\\). Also, noting that \\(\\sum_{j=0}^{n}\\Pr\\left\\{L_{j}\\right\\}=1\\), we have that \\(\\sum_{j=0}^{2\\left\\lceil\\lg n\\right\\rceil-1}\\Pr\\left\\{L_{j}\\right\\}\\leq 1\\). Thus, we obtain\n\n\\[\\mathrm{E}\\left[L\\right] = \\sum_{j=0}^{n}j\\Pr\\left\\{L_{j}\\right\\}\\] \\[= \\sum_{j=0}^{2\\left\\lceil\\lg n\\right\\rceil-1}j\\Pr\\left\\{L_{j} \\right\\}+\\sum_{j=2\\left\\lceil\\lg n\\right\\rceil}^{n}j\\Pr\\left\\{L_{j}\\right\\}\\] \\[< \\sum_{j=0}^{2\\left\\lceil\\lg n\\right\\rceil-1}(2\\left\\lceil\\lg n \\right\\rceil)\\Pr\\left\\{L_{j}\\right\\}+\\sum_{j=2\\left\\lceil\\lg n\\right\\rceil}^ {n}n\\Pr\\left\\{L_{j}\\right\\}\\] \\[= 2\\left\\lceil\\lg n\\right\\rceil\\sum_{j=0}^{2\\left\\lceil\\lg n \\right\\rceil-1}\\Pr\\left\\{L_{j}\\right\\}+n\\sum_{j=2\\left\\lceil\\lg n\\right\\rceil }^{n}\\Pr\\left\\{L_{j}\\right\\}\\] \\[< 2\\left\\lceil\\lg n\\right\\rceil\\cdot 1+n\\cdot\\frac{1}{n}\\] \\[= O(\\lg n)\\.\\]\n\nThe probability that a streak of heads exceeds \\(r\\left\\lceil\\lg n\\right\\rceil\\) flips diminishes quickly with \\(r\\). Let's get a rough bound on the probability that a streak of at least \\(r\\left\\lceil\\lg n\\right\\rceil\\) heads occurs, for \\(r\\geq 1\\). The probability that a streak of at least \\(r\\left\\lceil\\lg n\\right\\rceil\\) heads starts in position \\(i\\) is\n\n\\[\\Pr\\left\\{A_{i,r\\left\\lceil\\lg n\\right\\rceil}\\right\\} = \\frac{1}{2^{r\\left\\lceil\\lg n\\right\\rceil}}\\] \\[\\leq \\frac{1}{n^{r}}\\.\\]\n\nA streak of at least \\(r\\left\\lceil\\lg n\\right\\rceil\\) heads cannot start in the last \\(n-r\\left\\lceil\\lg n\\right\\rceil+1\\) flips, but let's overestimate the probability of such a streak by allowing it to start anywhere within the \\(n\\) coin flips. Then the probability that a streak of at least \\(r\\left\\lceil\\lg n\\right\\rceil\\) headsoccurs is at most\n\n\\[\\Pr\\left\\{\\bigcup_{i=1}^{n}A_{i,r\\lceil\\lg n\\rceil}\\right\\} \\leq\\ \\sum_{i=1}^{n}\\Pr\\left\\{A_{i,r\\lceil\\lg n\\rceil}\\right\\}\\qquad \\mbox{(by Boole's inequality (C.21))}\\] \\[\\leq\\ \\sum_{i=1}^{n}\\frac{1}{n^{r}}\\] \\[=\\ \\frac{1}{n^{r-1}}\\.\\]\n\nEquivalently, the probability is at least \\(1-1/n^{r-1}\\) that the longest streak has length less than \\(r\\ \\lceil\\lg n\\rceil\\).\n\nAs an example, during \\(n=1000\\) coin flips, the probability of encountering a streak of at least \\(2\\left\\lceil\\lg n\\right\\rceil=20\\) heads is at most \\(1/n=1/1000\\). The chance of a streak of at least \\(3\\left\\lceil\\lg n\\right\\rceil=30\\) heads is at most \\(1/n^{2}=1/1\\),000,000.\n\nLet's now prove a complementary lower bound: the expected length of the longest streak of heads in \\(n\\) coin flips is \\(\\Omega(\\lg n)\\). To prove this bound, we look for streaks of length \\(s\\) by partitioning the \\(n\\) flips into approximately \\(n/s\\) groups of \\(s\\) flips each. If we choose \\(s=\\lfloor(\\lg n)/2\\rfloor\\), we'll see that it is likely that at least one of these groups comes up all heads, which means that it's likely that the longest streak has length at least \\(s=\\Omega(\\lg n)\\). We'll then show that the longest streak has expected length \\(\\Omega(\\lg n)\\).\n\nLet's partition the \\(n\\) coin flips into at least \\(\\lfloor n/\\left\\lfloor(\\lg n)/2\\right\\rfloor\\rfloor\\) groups of \\(\\lfloor(\\lg n)/2\\rfloor\\) consecutive flips and bound the probability that no group comes up all heads. By equation (5.9), the probability that the group starting in position \\(i\\) comes up all heads is\n\n\\[\\Pr\\left\\{A_{i,\\lfloor(\\lg n)/2\\rfloor}\\right\\} =\\ \\frac{1}{2^{\\lfloor(\\lg n)/2\\rfloor}}\\] \\[\\geq\\ \\frac{1}{\\sqrt{n}}\\.\\]\n\nThe probability that a streak of heads of length at least \\(\\lfloor(\\lg n)/2\\rfloor\\) does not begin in position \\(i\\) is therefore at most \\(1-1/\\sqrt{n}\\). Since the \\(\\lfloor n/\\left\\lfloor(\\lg n)/2\\right\\rfloorrfloor\\) groups are formed from mutually exclusive, independent coin flips, the probability that every one of these groups _fails_ to be a streak of length \\(\\lfloor(\\lg n)/2\\rfloor\\) is at most\n\n\\[\\left(1-1/\\sqrt{n}\\right)^{\\lfloor n/\\lfloor(\\lg n)/2\\rfloor\\rfloor} \\leq\\ \\left(1-1/\\sqrt{n}\\right)^{n/\\lfloor(\\lg n)/2\\rfloor-1}\\] \\[\\leq\\ \\left(1-1/\\sqrt{n}\\right)^{2n/\\lg n-1}\\] \\[\\leq\\ e^{-(2n/\\lg n-1)/\\sqrt{n}}\\] \\[=\\ O(e^{-\\ln n}). \\tag{5.12}\\]For this argument, we used inequality (3.14), \\(1+x\\leq e^{x}\\), on page 66 and the fact, which you may verify, that \\((2n/\\lg n-1)/\\sqrt{n}\\geq\\ln n\\) for sufficiently large \\(n\\).\n\nWe want to bound the probability that the longest streak equals or exceeds \\(\\lfloor(\\lg n)/2\\rfloor\\). To do so, let \\(L\\) be the event that the longest streak of heads equals or exceeds \\(s=\\lfloor(\\lg n)/2\\rfloor\\). Let \\(\\overline{L}\\) be the complementary event, that the longest streak of heads is strictly less than \\(s\\), so that \\(\\Pr\\left\\{L\\right\\}+\\Pr\\left\\{\\overline{L}\\right\\}=1\\). Let \\(F\\) be the event that every group of \\(s\\) flips fails to be a streak of \\(s\\) heads. By inequality (5.12), we have \\(\\Pr\\left\\{F\\right\\}=O(1/n)\\). If the longest streak of heads is less than \\(s\\), then certainly every group of \\(s\\) flips fails to be a streak of \\(s\\) heads, which means that event \\(\\overline{L}\\) implies event \\(F\\). Of course, event \\(F\\) could occur even if event \\(\\overline{L}\\) does not (for example, if a streak of \\(s\\) or more heads crosses over the boundary between two groups), and so we have \\(\\Pr\\left\\{\\overline{L}\\right\\}\\leq\\Pr\\left\\{F\\right\\}=O(1/n)\\). Since \\(\\Pr\\left\\{L\\right\\}+\\Pr\\left\\{\\overline{L}\\right\\}=1\\), we have that\n\n\\[\\Pr\\left\\{L\\right\\} =\\ 1-\\Pr\\left\\{\\overline{L}\\right\\}\\] \\[\\geq\\ 1-\\Pr\\left\\{F\\right\\}\\] \\[=\\ 1-\\mathit{O}(1/n)\\.\\]\n\nThat is, the probability that the longest streak equals or exceeds \\(\\lfloor(\\lg n)/2\\rfloor\\) is\n\n\\[\\sum_{j=\\lfloor(\\lg n)/2\\rfloor}^{n}\\Pr\\left\\{L_{j}\\right\\}\\geq 1-\\mathit{O}(1/n ). \\tag{5.13}\\]\n\nWe can now calculate a lower bound on the expected length of the longest streak, beginning with equation (5.11) and proceeding in a manner similar to our analysis of the upper bound:\n\n\\[\\mathrm{E}\\left[L\\right] =\\ \\sum_{j=0}^{n}j\\Pr\\left\\{L_{j}\\right\\}\\] \\[=\\ \\sum_{j=0}^{\\lfloor(\\lg n)/2\\rfloor-1}j\\Pr\\left\\{L_{j} \\right\\}+\\sum_{j=\\lfloor(\\lg n)/2\\rfloor}^{n}j\\Pr\\left\\{L_{j}\\right\\}\\] \\[\\geq\\ \\sum_{j=0}^{\\lfloor(\\lg n)/2\\rfloor-1}0\\cdot\\Pr\\left\\{L_{j} \\right\\}+\\sum_{j=\\lfloor(\\lg n)/2\\rfloor}^{n}\\lfloor(\\lg n)/2\\rfloor\\Pr \\left\\{L_{j}\\right\\}\\] \\[=\\ 0\\cdot\\sum_{j=0}^{\\lfloor(\\lg n)/2\\rfloor-1}\\Pr\\left\\{L_{j} \\right\\}+\\lfloor(\\lg n)/2\\rfloor\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\! \\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\! \\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\! \\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\! \\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\! \\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\! \\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\! \\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\! \\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\! \\!\\!As with the birthday paradox, we can obtain a simpler, but approximate, analysis using indicator random variables. Instead of determining the expected length of the longest streak, we'll find the expected number of streaks with at least a given length. Let \\(X_{ik}=\\mathrm{I}\\left\\{A_{ik}\\right\\}\\) be the indicator random variable associated with a streak of heads of length at least \\(k\\) beginning with the \\(i\\)th coin flip. To count the total number of such streaks, define\n\n\\[X_{k}=\\sum_{i=1}^{n-k+1}X_{ik}\\.\\]\n\nTaking expectations and using linearity of expectation, we have\n\n\\[\\mathrm{E}\\left[X_{k}\\right] = \\mathrm{E}\\left[\\sum_{i=1}^{n-k+1}X_{ik}\\right]\\] \\[= \\sum_{i=1}^{n-k+1}\\mathrm{E}\\left[X_{ik}\\right]\\] \\[= \\sum_{i=1}^{n-k+1}\\mathrm{Pr}\\left\\{A_{ik}\\right\\}\\] \\[= \\sum_{i=1}^{n-k+1}\\frac{1}{2^{k}}\\] \\[= \\frac{n-k+1}{2^{k}}\\.\\]\n\nBy plugging in various values for \\(k\\), we can calculate the expected number of streaks of length at least \\(k\\). If this expected number is large (much greater than \\(1\\)), then we expect many streaks of length \\(k\\) to occur, and the probability that one occurs is high. If this expected number is small (much less than \\(1\\)), then we expect to see few streaks of length \\(k\\), and the probability that one occurs is low. If \\(k=c\\lg n\\), for some positive constant \\(c\\), we obtain\n\n\\[\\mathrm{E}\\left[X_{c\\lg n}\\right] = \\frac{n-c\\lg n+1}{2^{c\\lg n}}\\] \\[= \\frac{n-c\\lg n+1}{n^{c}}\\] \\[= \\frac{1}{n^{c-1}}-\\frac{(c\\lg n-1)/n}{n^{c-1}}\\] \\[= \\Theta(1/n^{c-1})\\.\\]\n\nIf \\(c\\) is large, the expected number of streaks of length \\(c\\lg n\\) is small, and we conclude that they are unlikely to occur. On the other hand, if \\(c=1/2\\), then we obtain \\(\\operatorname{E}\\left[X_{(1/2)\\lg n}\\right]=\\Theta(1/n^{1/2-1})=\\Theta(n^{1/2})\\), and we expect there to be numerous streaks of length \\((1/2)\\lg n\\). Therefore, one streak of such a length is likely to occur. We can conclude that the expected length of the longest streak is \\(\\Theta(\\lg n)\\).\n\n#### The online hiring problem\n\nAs a final example, let's consider a variant of the hiring problem. Suppose now that you do not wish to interview all the candidates in order to find the best one. You also want to avoid hiring and firing as you find better and better applicants. Instead, you are willing to settle for a candidate who is close to the best, in exchange for hiring exactly once. You must obey one company requirement: after each interview you must either immediately offer the position to the applicant or immediately reject the applicant. What is the trade-off between minimizing the amount of interviewing and maximizing the quality of the candidate hired?\n\nWe can model this problem in the following way. After meeting an applicant, you are able to give each one a score. Let \\(\\mathit{score}(i)\\) denote the score you give to the \\(i\\)th applicant, and assume that no two applicants receive the same score. After you have seen \\(j\\) applicants, you know which of the \\(j\\) has the highest score, but you do not know whether any of the remaining \\(n-j\\) applicants will receive a higher score. You decide to adopt the strategy of selecting a positive integer \\(k<n\\), interviewing and then rejecting the first \\(k\\) applicants, and hiring the first applicant thereafter who has a higher score than all preceding applicants. If it turns out that the best-qualified applicant was among the first \\(k\\) interviewed, then you hire the \\(n\\)th applicant--the last one interviewed. We formalize this strategy in the procedure Online-Maximum\\((k,n)\\), which returns the index of the candidate you wish to hire.\n\n```\nOnline-Maximum\\((k,n)\\)\n1\\(\\mathit{best-score}=-\\infty\\)\n2for\\(i=1\\)to\\(k\\)\n3if\\(\\mathit{score}(i)>\\mathit{best-score}\\)\n4\\(\\mathit{best-score}=\\mathit{score}(i)\\)\n5for\\(i=k+1\\)to\\(n\\)\n6if\\(\\mathit{score}(i)>\\mathit{best-score}\\)\n7return\\(i\\)\n8return\\(n\\)\n```\n\nIf we determine, for each possible value of \\(k\\), the probability that you hire the most qualified applicant, then you can choose the best possible \\(k\\) and implement the strategy with that value. For the moment, assume that \\(k\\) is fixed. Let\\(M(j)=\\max\\,\\{score(i):1\\leq i\\leq j\\,\\}\\) denote the maximum score among applicants \\(1\\) through \\(j\\). Let \\(S\\) be the event that you succeed in choosing the best-qualified applicant, and let \\(S_{i}\\) be the event that you succeed when the best-qualified applicant is the \\(i\\)th one interviewed. Since the various \\(S_{i}\\) are disjoint, we have that \\(\\Pr\\left\\{S\\right\\}=\\sum_{i=1}^{n}\\Pr\\left\\{S_{i}\\right\\}\\). Noting that you never succeed when the best-qualified applicant is one of the first \\(k\\), we have that \\(\\Pr\\left\\{S_{i}\\right\\}=0\\) for \\(i=1,2,\\ldots,k\\). Thus, we obtain\n\n\\[\\Pr\\left\\{S\\right\\}=\\sum_{i=k+1}^{n}\\Pr\\left\\{S_{i}\\right\\}\\;. \\tag{5.14}\\]\n\nWe now compute \\(\\Pr\\left\\{S_{i}\\right\\}\\). In order to succeed when the best-qualified applicant is the \\(i\\)th one, two things must happen. First, the best-qualified applicant must be in position \\(i\\), an event which we denote by \\(B_{i}\\). Second, the algorithm must not select any of the applicants in positions \\(k+1\\) through \\(i-1\\), which happens only if, for each \\(j\\) such that \\(k+1\\leq j\\leq i-1\\), line \\(6\\) finds that \\(score(j)<best\\)-\\(score\\). (Because scores are unique, we can ignore the possibility of \\(score(j)=best\\)-\\(score\\).) In other words, all of the values \\(score(k+1)\\) through \\(score(i-1)\\) must be less than \\(M(k)\\). If any are greater than \\(M(k)\\), the algorithm instead returns the index of the first one that is greater. We use \\(O_{i}\\) to denote the event that none of the applicants in position \\(k+1\\) through \\(i-1\\) are chosen. Fortunately, the two events \\(B_{i}\\) and \\(O_{i}\\) are independent. The event \\(O_{i}\\) depends only on the relative ordering of the values in positions \\(1\\) through \\(i-1\\), whereas \\(B_{i}\\) depends only on whether the value in position \\(i\\) is greater than the values in all other positions. The ordering of the values in positions \\(1\\) through \\(i-1\\) does not affect whether the value in position \\(i\\) is greater than all of them, and the value in position \\(i\\) does not affect the ordering of the values in positions \\(1\\) through \\(i-1\\). Thus, we can apply equation (C.17) on page 1188 to obtain\n\n\\[\\Pr\\left\\{S_{i}\\right\\}=\\Pr\\left\\{B_{i}\\,\\cap\\,O_{i}\\right\\}=\\Pr\\left\\{B_{i} \\right\\}\\Pr\\left\\{O_{i}\\right\\}\\;.\\]\n\nWe have \\(\\Pr\\left\\{B_{i}\\right\\}=1/n\\) since the maximum is equally likely to be in any one of the \\(n\\) positions. For event \\(O_{i}\\) to occur, the maximum value in positions \\(1\\) through \\(i-1\\), which is equally likely to be in any of these \\(i-1\\) positions, must be in one of the first \\(k\\) positions. Consequently, \\(\\Pr\\left\\{O_{i}\\right\\}=k/(i-1)\\) and \\(\\Pr\\left\\{S_{i}\\right\\}=k/(n(i-1))\\). Using equation (5.14), we have\n\n\\[\\Pr\\left\\{S\\right\\} = \\sum_{i=k+1}^{n}\\Pr\\left\\{S_{i}\\right\\}\\] \\[= \\sum_{i=k+1}^{n}\\frac{k}{n(i-1)}\\]\\[= \\frac{k}{n}\\sum_{i=k+1}^{n}\\frac{1}{i-1}\\] \\[= \\frac{k}{n}\\sum_{i=k}^{n-1}\\frac{1}{i}\\.\\]\n\nWe approximate by integrals to bound this summation from above and below. By the inequalities (A.19) on page 1150, we have\n\n\\[\\int_{k}^{n}\\frac{1}{x}\\;dx\\,\\leq\\sum_{i=k}^{n-1}\\frac{1}{i}\\,\\leq\\int_{k-1}^{ n-1}\\frac{1}{x}\\;dx\\.\\]\n\nEvaluating these definite integrals gives us the bounds\n\n\\[\\frac{k}{n}(\\ln n-\\ln k)\\,\\leq\\Pr\\left\\{S\\right\\}\\leq\\frac{k}{n}(\\ln(n-1)-\\ln( k-1))\\,\\]\n\nwhich provide a rather tight bound for \\(\\Pr\\left\\{S\\right\\}\\). Because you wish to maximize your probability of success, let us focus on choosing the value of \\(k\\) that maximizes the lower bound on \\(\\Pr\\left\\{S\\right\\}\\). (Besides, the lower-bound expression is easier to maximize than the upper-bound expression.) Differentiating the expression \\((k/n)(\\ln n-\\ln k)\\) with respect to \\(k\\), we obtain\n\n\\[\\frac{1}{n}(\\ln n-\\ln k-1)\\.\\]\n\nSetting this derivative equal to \\(0\\), we see that you maximize the lower bound on the probability when \\(\\ln k=\\ln n-1=\\ln(n/e)\\) or, equivalently, when \\(k=n/e\\). Thus, if you implement our strategy with \\(k=n/e\\), you succeed in hiring the best-qualified applicant with probability at least \\(1/e\\).\n\n##### Exercises\n\n##### 5.4-1\n\nHow many people must there be in a room before the probability that someone has the same birthday as you do is at least \\(1/2\\)? How many people must there be before the probability that at least two people have a birthday on July 4 is greater than \\(1/2\\)?\n\n##### 5.4-2\n\nHow many people must there be in a room before the probability that two people have the same birthday is at least \\(0.99\\)? For that many people, what is the expected number of pairs of people who have the same birthday?\n\n#### 5.4-3\n\nYou toss balls into \\(b\\) bins until some bin contains two balls. Each toss is independent, and each ball is equally likely to end up in any bin. What is the expected number of ball tosses?\n* _5.4-4_ For the analysis of the birthday paradox, is it important that the birthdays be mutually independent, or is pairwise independence sufficient? Justify your answer.\n* _5.4-5_ How many people should be invited to a party in order to make it likely that there are _three_ people with the same birthday?\n* _5.4-6_ What is the probability that a \\(k\\)-string (defined on page 1179) over a set of size \\(n\\) forms a \\(k\\)-permutation? How does this question relate to the birthday paradox?\n* _5.4-7_ You toss \\(n\\) balls into \\(n\\) bins, where each toss is independent and the ball is equally likely to end up in any bin. What is the expected number of empty bins? What is the expected number of bins with exactly one ball?\n* _5.4-8_ Sharpen the lower bound on streak length by showing that in \\(n\\) flips of a fair coin, the probability is at least \\(1-1/n\\) that a streak of length \\(\\lg n-2\\lg\\lg n\\) consecutive heads occurs.\n\n## Problems\n\n### 5.1 Probabilistic counting\n\nWith a \\(b\\)-bit counter, we can ordinarily only count up to \\(2^{b}-1\\). With R. Morris's _probabilistic counting_, we can count up to a much larger value at the expense of some loss of precision.\n\nWe let a counter value of \\(i\\) represent a count of \\(n_{i}\\) for \\(i=0,1,\\ldots,2^{b}-1\\), where the \\(n_{i}\\) form an increasing sequence of nonnegative values. We assume that the initial value of the counter is 0, representing a count of \\(n_{0}=0\\). The Increment operation works on a counter containing the value \\(i\\) in a probabilistic manner. If \\(i=2^{b}-1\\), then the operation reports an overflow error. Otherwise, the Increment operation increases the counter by 1 with probability \\(1/(n_{i+1}-n_{i})\\), and it leaves the counter unchanged with probability \\(1-1/(n_{i+1}-n_{i})\\).",
        "chapter": "Part I Foundations",
        "section": "5 Probabilistic Analysis and Randomized Algorithms",
        "subsection": "5.4 Probabilistic analysis and further uses of indicator random variables",
        "subsubsection": "N/A"
    },
    {
        "content": "#### 5.4-3\n\nYou toss balls into \\(b\\) bins until some bin contains two balls. Each toss is independent, and each ball is equally likely to end up in any bin. What is the expected number of ball tosses?\n* _5.4-4_ For the analysis of the birthday paradox, is it important that the birthdays be mutually independent, or is pairwise independence sufficient? Justify your answer.\n* _5.4-5_ How many people should be invited to a party in order to make it likely that there are _three_ people with the same birthday?\n* _5.4-6_ What is the probability that a \\(k\\)-string (defined on page 1179) over a set of size \\(n\\) forms a \\(k\\)-permutation? How does this question relate to the birthday paradox?\n* _5.4-7_ You toss \\(n\\) balls into \\(n\\) bins, where each toss is independent and the ball is equally likely to end up in any bin. What is the expected number of empty bins? What is the expected number of bins with exactly one ball?\n* _5.4-8_ Sharpen the lower bound on streak length by showing that in \\(n\\) flips of a fair coin, the probability is at least \\(1-1/n\\) that a streak of length \\(\\lg n-2\\lg\\lg n\\) consecutive heads occurs.\n\n## Problems\n\n### 5.1 Probabilistic counting\n\nWith a \\(b\\)-bit counter, we can ordinarily only count up to \\(2^{b}-1\\). With R. Morris's _probabilistic counting_, we can count up to a much larger value at the expense of some loss of precision.\n\nWe let a counter value of \\(i\\) represent a count of \\(n_{i}\\) for \\(i=0,1,\\ldots,2^{b}-1\\), where the \\(n_{i}\\) form an increasing sequence of nonnegative values. We assume that the initial value of the counter is 0, representing a count of \\(n_{0}=0\\). The Increment operation works on a counter containing the value \\(i\\) in a probabilistic manner. If \\(i=2^{b}-1\\), then the operation reports an overflow error. Otherwise, the Increment operation increases the counter by 1 with probability \\(1/(n_{i+1}-n_{i})\\), and it leaves the counter unchanged with probability \\(1-1/(n_{i+1}-n_{i})\\).\n\nIf we select \\(n_{i}=i\\) for all \\(i\\geq 0\\), then the counter is an ordinary one. More interesting situations arise if we select, say, \\(n_{i}=2^{i-1}\\) for \\(i>0\\) or \\(n_{i}=F_{i}\\) (the \\(i\\)th Fibonacci number--see equation (3.31) on page 3.3).\n\nFor this problem, assume that \\(n_{2^{b}-1}\\) is large enough that the probability of an overflow error is negligible.\n\n* Show that the expected value represented by the counter after \\(n\\) Increment operations have been performed is exactly \\(n\\).\n* The analysis of the variance of the count represented by the counter depends on the sequence of the \\(n_{i}\\). Let us consider a simple case: \\(n_{i}=100i\\) for all \\(i\\geq 0\\). Estimate the variance in the value represented by the register after \\(n\\) Increment operations have been performed.\n\n### Searching an unsorted array\n\nThis problem examines three algorithms for searching for a value \\(x\\) in an unsorted array \\(A\\) consisting of \\(n\\) elements.\n\nConsider the following randomized strategy: pick a random index \\(i\\) into \\(A\\). If \\(A[i]=x\\), then terminate; otherwise, continue the search by picking a new random index into \\(A\\). Continue picking random indices into \\(A\\) until you find an index \\(j\\) such that \\(A[j]=x\\) or until every element of \\(A\\) has been checked. This strategy may examine a given element more than once, because it picks from the whole set of indices each time.\n\n* Write pseudocode for a procedure Random-Search to implement the strategy above. Be sure that your algorithm terminates when all indices into \\(A\\) have been picked.\n* Suppose that there is exactly one index \\(i\\) such that \\(A[i]=x\\). What is the expected number of indices into \\(A\\) that must be picked before \\(x\\) is found and Random-Search terminates?\n* Generalizing your solution to part (b), suppose that there are \\(k\\geq 1\\) indices \\(i\\) such that \\(A[i]=x\\). What is the expected number of indices into \\(A\\) that must be picked before \\(x\\) is found and Random-Search terminates? Your answer should be a function of \\(n\\) and \\(k\\).\n* Suppose that there are no indices \\(i\\) such that \\(A[i]=x\\). What is the expected number of indices into \\(A\\) that must be picked before \\(x\\) is found and Random-Search terminates?\n\nNow consider a deterministic linear search algorithm. The algorithm, which we call Deterministic-Search, searches \\(A\\) for \\(x\\) in order, considering \\(A[1]\\), \\(A[2]\\)\\(A[3],\\ldots,A[n]\\) until either it finds \\(A[i]=x\\) or it reaches the end of the array. Assume that all possible permutations of the input array are equally likely. _e._ Suppose that there is exactly one index \\(i\\) such that \\(A[i]=x\\). What is the average-case running time of Deterministic-Search? What is the worst-case running time of Deterministic-Search?\n* Generalizing your solution to part (e), suppose that there are \\(k\\geq 1\\) indices \\(i\\) such that \\(A[i]=x\\). What is the average-case running time of Deterministic-Search? What is the worst-case running time of Deterministic-Search? Your answer should be a function of \\(n\\) and \\(k\\).\n* Suppose that there are no indices \\(i\\) such that \\(A[i]=x\\). What is the average-case running time of Deterministic-Search?\n\nFinally, consider a randomized algorithm Scramble-Search that first randomly permutes the input array and then runs the deterministic linear search given above on the resulting permuted array.\n\n* Letting \\(k\\) be the number of indices \\(i\\) such that \\(A[i]=x\\), give the worst-case and expected running times of Scramble-Search for the cases in which \\(k=0\\) and \\(k=1\\). Generalize your solution to handle the case in which \\(k\\geq 1\\).\n* Which of the three searching algorithms would you use? Explain your answer.\n\n## Chapter notes\n\nBollobas [65], Hofri [223], and Spencer [420] contain a wealth of advanced probabilistic techniques. The advantages of randomized algorithms are discussed and surveyed by Karp [249] and Rabin [372]. The textbook by Motwani and Raghavan [336] gives an extensive treatment of randomized algorithms.\n\nThe Randomly-Permute procedure is by Durstenfeld [128], based on an earlier procedure by Fisher and Yates [143, p. 34].\n\nSeveral variants of the hiring problem have been widely studied. These problems are more commonly referred to as \"secretary problems.\" Examples of work in this area are the paper by Ajtai, Meggido, and Waarts [11] and another by Kleinberg [258], which ties the secretary problem to online ad auctions.",
        "chapter": "Part I Foundations",
        "section": "5 Probabilistic Analysis and Randomized Algorithms",
        "subsection": "Problems",
        "subsubsection": "N/A"
    },
    {
        "content": "\\(A[3],\\ldots,A[n]\\) until either it finds \\(A[i]=x\\) or it reaches the end of the array. Assume that all possible permutations of the input array are equally likely. _e._ Suppose that there is exactly one index \\(i\\) such that \\(A[i]=x\\). What is the average-case running time of Deterministic-Search? What is the worst-case running time of Deterministic-Search?\n* Generalizing your solution to part (e), suppose that there are \\(k\\geq 1\\) indices \\(i\\) such that \\(A[i]=x\\). What is the average-case running time of Deterministic-Search? What is the worst-case running time of Deterministic-Search? Your answer should be a function of \\(n\\) and \\(k\\).\n* Suppose that there are no indices \\(i\\) such that \\(A[i]=x\\). What is the average-case running time of Deterministic-Search?\n\nFinally, consider a randomized algorithm Scramble-Search that first randomly permutes the input array and then runs the deterministic linear search given above on the resulting permuted array.\n\n* Letting \\(k\\) be the number of indices \\(i\\) such that \\(A[i]=x\\), give the worst-case and expected running times of Scramble-Search for the cases in which \\(k=0\\) and \\(k=1\\). Generalize your solution to handle the case in which \\(k\\geq 1\\).\n* Which of the three searching algorithms would you use? Explain your answer.\n\n## Chapter notes\n\nBollobas [65], Hofri [223], and Spencer [420] contain a wealth of advanced probabilistic techniques. The advantages of randomized algorithms are discussed and surveyed by Karp [249] and Rabin [372]. The textbook by Motwani and Raghavan [336] gives an extensive treatment of randomized algorithms.\n\nThe Randomly-Permute procedure is by Durstenfeld [128], based on an earlier procedure by Fisher and Yates [143, p. 34].\n\nSeveral variants of the hiring problem have been widely studied. These problems are more commonly referred to as \"secretary problems.\" Examples of work in this area are the paper by Ajtai, Meggido, and Waarts [11] and another by Kleinberg [258], which ties the secretary problem to online ad auctions.",
        "chapter": "Part I Foundations",
        "section": "5 Probabilistic Analysis and Randomized Algorithms",
        "subsection": "Chapter notes",
        "subsubsection": "N/A"
    },
    {
        "content": "## Introduction\n\nThis part presents several algorithms that solve the following _sorting problem_:\n\n**Input:**: A sequence of \\(n\\) numbers \\(\\langle a_{1},a_{2},\\ldots,a_{n}\\rangle\\).\n**Output:**: A permutation (reordering) \\(\\langle a^{\\prime}_{1},a^{\\prime}_{2},\\ldots,a^{\\prime}_{n}\\rangle\\) of the input sequence such that \\(a^{\\prime}_{1}\\leq a^{\\prime}_{2}\\leq\\cdots\\leq a^{\\prime}_{n}\\).\n\nThe input sequence is usually an \\(n\\)-element array, although it may be represented in some other fashion, such as a linked list.\n\n## The structure of the data\n\nIn practice, the numbers to be sorted are rarely isolated values. Each is usually part of a collection of data called a _record_. Each record contains a _key_, which is the value to be sorted. The remainder of the record consists of _satellite data_, which are usually carried around with the key. In practice, when a sorting algorithm permutes the keys, it must permute the satellite data as well. If each record includes a large amount of satellite data, it often pays to permute an array of pointers to the records rather than the records themselves in order to minimize data movement.\n\nIn a sense, it is these implementation details that distinguish an algorithm from a full-blown program. A sorting algorithm describes the _method_ to determine the sorted order, regardless of whether what's being sorted are individual numbers or large records containing many bytes of satellite data. Thus, when focusing on the problem of sorting, we typically assume that the input consists only of numbers. Translating an algorithm for sorting numbers into a program for sorting records is conceptually straightforward, although in a given engineering situation other subtleties may make the actual programming task a challenge.\n\n### Why sorting?\n\nMany computer scientists consider sorting to be the most fundamental problem in the study of algorithms. There are several reasons:\n\n* Sometimes an application inherently needs to sort information. For example, in order to prepare customer statements, banks need to sort checks by check number.\n* Algorithms often use sorting as a key subroutine. For example, a program that renders graphical objects which are layered on top of each other might have to sort the objects according to an \"above\" relation so that it can draw these objects from bottom to top. We will see numerous algorithms in this text that use sorting as a subroutine.\n* We can draw from among a wide variety of sorting algorithms, and they employ a rich set of techniques. In fact, many important techniques used throughout algorithm design appear in sorting algorithms that have been developed over the years. In this way, sorting is also a problem of historical interest.\n* We can prove a nontrivial lower bound for sorting (as we'll do in Chapter 8). Since the best upper bounds match the lower bound asymptotically, we can conclude that certain of our sorting algorithms are asymptotically optimal. Moreover, we can use the lower bound for sorting to prove lower bounds for various other problems.\n* Many engineering issues come to the fore when implementing sorting algorithms. The fastest sorting program for a particular situation may depend on many factors, such as prior knowledge about the keys and satellite data, the memory hierarchy (caches and virtual memory) of the host computer, and the software environment. Many of these issues are best dealt with at the algorithmic level, rather than by \"tweaking\" the code.\n\n### Sorting algorithms\n\nWe introduced two algorithms that sort \\(n\\) real numbers in Chapter 2. Insertion sort takes \\(\\Theta(n^{2})\\) time in the worst case. Because its inner loops are tight, however, it is a fast sorting algorithm for small input sizes. Moreover, unlike merge sort, it sorts _in place_, meaning that at most a constant number of elements of the input array are ever stored outside the array, which can be advantageous for space efficiency. Merge sort has a better asymptotic running time, \\(\\Theta(n\\lg n)\\), but the Merge procedure it uses does not operate in place. (We'll see a parallelized version of merge sort in Section 26.3.)This part introduces two more algorithms that sort arbitrary real numbers. Heapsort, presented in Chapter 6, sorts \\(n\\) numbers in place in \\(\\,O(n\\lg n)\\) time. It uses an important data structure, called a heap, which can also implement a priority queue.\n\nQuicksort, in Chapter 7, also sorts \\(n\\) numbers in place, but its worst-case running time is \\(\\Theta(n^{2})\\). Its expected running time is \\(\\Theta(n\\lg n)\\), however, and it generally outperforms heapsort in practice. Like insertion sort, quicksort has tight code, and so the hidden constant factor in its running time is small. It is a popular algorithm for sorting large arrays.\n\nInsertion sort, merge sort, heapsort, and quicksort are all comparison sorts: they determine the sorted order of an input array by comparing elements. Chapter 8 begins by introducing the decision-tree model in order to study the performance limitations of comparison sorts. Using this model, we prove a lower bound of \\(\\,\\Omega(n\\lg n)\\) on the worst-case running time of any comparison sort on \\(n\\) inputs, thus showing that heapsort and merge sort are asymptotically optimal comparison sorts.\n\nChapter 8 then goes on to show that we might be able to beat this lower bound of \\(\\Omega(n\\lg n)\\) if an algorithm can gather information about the sorted order of the input by means other than comparing elements. The counting sort algorithm, for example, assumes that the input numbers belong to the set \\(\\{0,1,\\ldots,k\\}\\). By using array indexing as a tool for determining relative order, counting sort can sort \\(n\\) numbers in \\(\\Theta(k+n)\\) time. Thus, when \\(k=O(n)\\), counting sort runs in time that is linear in the size of the input array. A related algorithm, radix sort, can be used to extend the range of counting sort. If there are \\(n\\) integers to sort, each integer has \\(d\\) digits, and each digit can take on up to \\(k\\) possible values, then radix sort can sort the numbers in \\(\\Theta(d(n+k))\\) time. When \\(d\\) is a constant and \\(k\\) is \\(O(n)\\), radix sort runs in linear time. A third algorithm, bucket sort, requires knowledge of the probabilistic distribution of numbers in the input array. It can sort \\(n\\) real numbers uniformly distributed in the half-open interval \\([0,1)\\) in average-case \\(\\,O(n)\\) time.\n\nThe table on the following page summarizes the running times of the sorting algorithms from Chapters 2 and 6-8. As usual, \\(n\\) denotes the number of items to sort. For counting sort, the items to sort are integers in the set \\(\\{0,1,\\ldots,k\\}\\). For radix sort, each item is a \\(d\\)-digit number, where each digit takes on \\(k\\) possible values. For bucket sort, we assume that the keys are real numbers uniformly distributed in the half-open interval \\([0,1)\\). The rightmost column gives the average-case or expected running time, indicating which one it gives when it differs from the worst-case running time. We omit the average-case running time of heapsort because we do not analyze it in this book.\n\n### Order statistics\n\nThe \\(i\\)th order statistic of a set of \\(n\\) numbers is the \\(i\\)th smallest number in the set. You can, of course, select the \\(i\\)th order statistic by sorting the input and indexing the \\(i\\)th element of the output. With no assumptions about the input distribution, this method runs in \\(\\Omega(n\\lg n)\\) time, as the lower bound proved in Chapter 8 shows.\n\nChapter 9 shows how to find the \\(i\\)th smallest element in \\(O(n)\\) time, even when the elements are arbitrary real numbers. We present a randomized algorithm with tight pseudocode that runs in \\(\\Theta(n^{2})\\) time in the worst case, but whose expected running time is \\(O(n)\\). We also give a more complicated algorithm that runs in \\(O(n)\\) worst-case time.\n\n### Background\n\nAlthough most of this part does not rely on difficult mathematics, some sections do require mathematical sophistication. In particular, analyses of quicksort, bucket sort, and the order-statistic algorithm use probability, which is reviewed in Appendix C, and the material on probabilistic analysis and randomized algorithms in Chapter 5.\n\n## Chapter 6 Heapsort\n\nThis chapter introduces another sorting algorithm: heapsort. Like merge sort, but unlike insertion sort, heapsort's running time is \\(O(n\\lg n)\\). Like insertion sort, but unlike merge sort, heapsort sorts in place: only a constant number of array elements are stored outside the input array at any time. Thus, heapsort combines the better attributes of the two sorting algorithms we have already discussed.\n\nHeapsort also introduces another algorithm design technique: using a data structure, in this case one we call a \"heap,\" to manage information. Not only is the heap data structure useful for heapsort, but it also makes an efficient priority queue. The heap data structure will reappear in algorithms in later chapters.\n\nThe term \"heap\" was originally coined in the context of heapsort, but it has since come to refer to \"garbage-collected storage,\" such as the programming languages Java and Python provide. Please don't be confused. The heap data structure is _not_ garbage-collected storage. This book is consistent in using the term \"heap\" to refer to the data structure, not the storage class.\n\n### Heaps\n\nThe _(binary) heap_ data structure is an array object that we can view as a nearly complete binary tree (see Section B.5.3), as shown in Figure 6.1. Each node of the tree corresponds to an element of the array. The tree is completely filled on all levels except possibly the lowest, which is filled from the left up to a point. An array \\(A[1:n]\\) that represents a heap is an object with an attribute \\(A.\\mathit{heap\\text{-}size}\\), which represents how many elements in the heap are stored within array \\(A\\). That is, although \\(A[1:n]\\) may contain numbers, only the elements in \\(A[1:A.\\mathit{heap\\text{-}size}]\\), where \\(0\\leq A.\\mathit{heap\\text{-}size}\\leq n\\), are valid elements of the heap. If \\(A.\\mathit{heap\\text{-}size}=0\\), then the heap is empty. The root of the tree is \\(A[1]\\), and given the index \\(i\\) of a node,",
        "chapter": "Part II Sorting and Order Statistics",
        "section": "Introduction",
        "subsection": "N/A",
        "subsubsection": "N/A"
    },
    {
        "content": "## Chapter 6 Heapsort\n\nThis chapter introduces another sorting algorithm: heapsort. Like merge sort, but unlike insertion sort, heapsort's running time is \\(O(n\\lg n)\\). Like insertion sort, but unlike merge sort, heapsort sorts in place: only a constant number of array elements are stored outside the input array at any time. Thus, heapsort combines the better attributes of the two sorting algorithms we have already discussed.\n\nHeapsort also introduces another algorithm design technique: using a data structure, in this case one we call a \"heap,\" to manage information. Not only is the heap data structure useful for heapsort, but it also makes an efficient priority queue. The heap data structure will reappear in algorithms in later chapters.\n\nThe term \"heap\" was originally coined in the context of heapsort, but it has since come to refer to \"garbage-collected storage,\" such as the programming languages Java and Python provide. Please don't be confused. The heap data structure is _not_ garbage-collected storage. This book is consistent in using the term \"heap\" to refer to the data structure, not the storage class.\n\n### Heaps\n\nThe _(binary) heap_ data structure is an array object that we can view as a nearly complete binary tree (see Section B.5.3), as shown in Figure 6.1. Each node of the tree corresponds to an element of the array. The tree is completely filled on all levels except possibly the lowest, which is filled from the left up to a point. An array \\(A[1:n]\\) that represents a heap is an object with an attribute \\(A.\\mathit{heap\\text{-}size}\\), which represents how many elements in the heap are stored within array \\(A\\). That is, although \\(A[1:n]\\) may contain numbers, only the elements in \\(A[1:A.\\mathit{heap\\text{-}size}]\\), where \\(0\\leq A.\\mathit{heap\\text{-}size}\\leq n\\), are valid elements of the heap. If \\(A.\\mathit{heap\\text{-}size}=0\\), then the heap is empty. The root of the tree is \\(A[1]\\), and given the index \\(i\\) of a node,there's a simple way to compute the indices of its parent, left child, and right child with the one-line procedures Parent, Left, and Right.\n\nParent(_i_)\n\n1**return**\\(\\lfloor i/2\\rfloor\\)\n\nLeft(_i_)\n\n1**return**\\(2i\\)\n\nRight(_i_)\n\n1**return**\\(2i+1\\)\n\nOn most computers, the Left procedure can compute \\(2i\\) in one instruction by simply shifting the binary representation of \\(i\\) left by one bit position. Similarly, the Right procedure can quickly compute \\(2i+1\\) by shifting the binary representation of \\(i\\) left by one bit position and then adding 1. The Parent procedure can compute \\(\\lfloor i/2\\rfloor\\) by shifting \\(i\\) right one bit position. Good implementations of heapsort often implement these procedures as macros or inline procedures.\n\nThere are two kinds of binary heaps: max-heaps and min-heaps. In both kinds, the values in the nodes satisfy a _heap property_, the specifics of which depend on the kind of heap. In a _max-heap_, the _max-heap property_ is that for every node \\(i\\) other than the root,\n\n\\[A[\\textsc{Parent}(i)]\\geq A[i]\\,\\]\n\nFigure 6.1: A max-heap viewed as **(a)** a binary tree and **(b)** an array. The number within the circle at each node in the tree is the value stored at that node. The number above a node is the corresponding index in the array. Above and below the array are lines showing parent-child relationships, with parents always to the left of their children. The tree has height 3, and the node at index 4 (with value 8) has height 1.\n\nthat is, the value of a node is at most the value of its parent. Thus, the largest element in a max-heap is stored at the root, and the subtree rooted at a node contains values no larger than that contained at the node itself. A _min-heap_ is organized in the opposite way: the _min-heap property_ is that for every node \\(i\\) other than the root,\n\n\\[A[\\textsc{Parent}(i)]\\leq A[i]\\.\\]\n\nThe smallest element in a min-heap is at the root.\n\nThe heapsort algorithm uses max-heaps. Min-heaps commonly implement priority queues, which we discuss in Section 6.5. We'll be precise in specifying whether we need a max-heap or a min-heap for any particular application, and when properties apply to either max-heaps or min-heaps, we just use the term \"heap.\"\n\nViewing a heap as a tree, we define the _height_ of a node in a heap to be the number of edges on the longest simple downward path from the node to a leaf, and we define the height of the heap to be the height of its root. Since a heap of \\(n\\) elements is based on a complete binary tree, its height is \\(\\Theta(\\lg n)\\) (see Exercise 6.1-2). As we'll see, the basic operations on heaps run in time at most proportional to the height of the tree and thus take \\(O(\\lg n)\\) time. The remainder of this chapter presents some basic procedures and shows how they are used in a sorting algorithm and a priority-queue data structure.\n\n* The Max-Heapify procedure, which runs in \\(O(\\lg n)\\) time, is the key to maintaining the max-heap property.\n* The Build-Max-Heap procedure, which runs in linear time, produces a max-heap from an unordered input array.\n* The Heapsort procedure, which runs in \\(O(n\\lg n)\\) time, sorts an array in place.\n* The procedures Max-Heap-Insert, Max-Heap-Extract-Max, Max-Heap-Increase-Key, and Max-Heap-Maximum allow the heap data structure to implement a priority queue. They run in \\(O(\\lg n)\\) time plus the time for mapping between objects being inserted into the priority queue and indices in the heap.\n\n#### Exercises\n\n_6.1-1_\n\nWhat are the minimum and maximum numbers of elements in a heap of height \\(h\\)?\n\n_6.1-2_\n\nShow that an \\(n\\)-element heap has height \\(\\lfloor\\lg n\\rfloor\\).\n\n### 6.1-3\n\nShow that in any subtree of a max-heap, the root of the subtree contains the largest value occurring anywhere in that subtree.\n\n### 6.1-4\n\nWhere in a max-heap might the smallest element reside, assuming that all elements are distinct?\n\n### 6.1-5\n\nAt which levels in a max-heap might the \\(k\\)th largest element reside, for \\(2\\leq k\\leq\\lfloor n/2\\rfloor\\), assuming that all elements are distinct?\n\n### 6.1-6\n\nIs an array that is in sorted order a min-heap?\n\n### 6.1-7\n\nIs the array with values \\(\\langle 33,19,20,15,13,10,2,13,16,12\\rangle\\) a max-heap?\n\n### 6.1-8\n\nShow that, with the array representation for storing an \\(n\\)-element heap, the leaves are the nodes indexed by \\(\\lfloor n/2\\rfloor+1\\), \\(\\lfloor n/2\\rfloor+2,\\ldots,n\\).\n\n### Maintaining the heap property\n\nThe procedure Max-Heapify on the facing page maintains the max-heap property. Its inputs are an array \\(A\\) with the _heap-size_ attribute and an index \\(i\\) into the array. When it is called, Max-Heapify assumes that the binary trees rooted at Left(\\(i\\)) and Right(\\(i\\)) are max-heaps, but that \\(A[i]\\) might be smaller than its children, thus violating the max-heap property. Max-Heapify lets the value at \\(A[i]\\) \"float down\" in the max-heap so that the subtree rooted at index \\(i\\) obeys the max-heap property.\n\nFigure 6.2 illustrates the action of Max-Heapify. Each step determines the largest of the elements \\(A[i]\\), \\(A[\\textsc{Left}(i)]\\), and \\(A[\\textsc{Right}(i)]\\) and stores the index of the largest element in _largest_. If \\(A[i]\\) is largest, then the subtree rooted at node \\(i\\) is already a max-heap and nothing else needs to be done. Otherwise, one of the two children contains the largest element. Positions \\(i\\) and _largest_ swap their contents, which causes node \\(i\\) and its children to satisfy the max-heap property. The node indexed by _largest_, however, just had its value decreased, and thus the subtree rooted at _largest_ might violate the max-heap property. Consequently, Max-Heapify calls itself recursively on that subtree.",
        "chapter": "Part II Sorting and Order Statistics",
        "section": "6 Heapsort",
        "subsection": "6.1 Heaps",
        "subsubsection": "N/A"
    },
    {
        "content": "### 6.1-3\n\nShow that in any subtree of a max-heap, the root of the subtree contains the largest value occurring anywhere in that subtree.\n\n### 6.1-4\n\nWhere in a max-heap might the smallest element reside, assuming that all elements are distinct?\n\n### 6.1-5\n\nAt which levels in a max-heap might the \\(k\\)th largest element reside, for \\(2\\leq k\\leq\\lfloor n/2\\rfloor\\), assuming that all elements are distinct?\n\n### 6.1-6\n\nIs an array that is in sorted order a min-heap?\n\n### 6.1-7\n\nIs the array with values \\(\\langle 33,19,20,15,13,10,2,13,16,12\\rangle\\) a max-heap?\n\n### 6.1-8\n\nShow that, with the array representation for storing an \\(n\\)-element heap, the leaves are the nodes indexed by \\(\\lfloor n/2\\rfloor+1\\), \\(\\lfloor n/2\\rfloor+2,\\ldots,n\\).\n\n### Maintaining the heap property\n\nThe procedure Max-Heapify on the facing page maintains the max-heap property. Its inputs are an array \\(A\\) with the _heap-size_ attribute and an index \\(i\\) into the array. When it is called, Max-Heapify assumes that the binary trees rooted at Left(\\(i\\)) and Right(\\(i\\)) are max-heaps, but that \\(A[i]\\) might be smaller than its children, thus violating the max-heap property. Max-Heapify lets the value at \\(A[i]\\) \"float down\" in the max-heap so that the subtree rooted at index \\(i\\) obeys the max-heap property.\n\nFigure 6.2 illustrates the action of Max-Heapify. Each step determines the largest of the elements \\(A[i]\\), \\(A[\\textsc{Left}(i)]\\), and \\(A[\\textsc{Right}(i)]\\) and stores the index of the largest element in _largest_. If \\(A[i]\\) is largest, then the subtree rooted at node \\(i\\) is already a max-heap and nothing else needs to be done. Otherwise, one of the two children contains the largest element. Positions \\(i\\) and _largest_ swap their contents, which causes node \\(i\\) and its children to satisfy the max-heap property. The node indexed by _largest_, however, just had its value decreased, and thus the subtree rooted at _largest_ might violate the max-heap property. Consequently, Max-Heapify calls itself recursively on that subtree.\n\n### Maintaining the heap property\n\nFigure 6.2: The action of Max-Heapify\\((A,2)\\), where \\(A.\\mathit{heap\\text{-}size}=10\\). The node that potentially violates the max-heap property is shown in blue. **(a)** The initial configuration, with \\(A[2]\\) at node \\(i=2\\) violating the max-heap property since it is not larger than both children. The max-heap property is restored for node 2 in **(b)** by exchanging \\(A[2]\\) with \\(A[4]\\), which destroys the max-heap property for node 4. The recursive call Max-Heapify\\((A,4)\\) now has \\(i=4\\). After \\(A[4]\\) and \\(A[9]\\) are swapped, as shown in **(c)**, node 4 is fixed up, and the recursive call Max-Heapify\\((A,9)\\) yields no further change to the data structure.\n\nTo analyze Max-Heapify, let \\(T(n)\\) be the worst-case running time that the procedure takes on a subtree of size at most \\(n\\). For a tree rooted at a given node \\(i\\), the running time is the \\(\\Theta(1)\\) time to fix up the relationships among the elements \\(A[i]\\), \\(A[\\mbox{\\sc Left}(i)]\\), and \\(A[\\mbox{\\sc Right}(i)]\\), plus the time to run Max-Heapify on a subtree rooted at one of the children of node \\(i\\) (assuming that the recursive call occurs). The children's subtrees each have size at most \\(2n/3\\) (see Exercise 6.2-2), and therefore we can describe the running time of Max-Heapify by the recurrence\n\n\\[T(n)\\,\\leq T(2n/3)\\,+\\,\\Theta(1). \\tag{6.1}\\]\n\nThe solution to this recurrence, by case 2 of the master theorem (Theorem 4.1 on page 4.2), is \\(T(n)\\,=\\,O(\\lg n)\\). Alternatively, we can characterize the running time of Max-Heapify on a node of height \\(h\\) as \\(O(h)\\).\n\n#### Exercises\n\n##### 6.2-1\n\nUsing Figure 6.2 as a model, illustrate the operation of Max-Heapify\\((A,3)\\) on the array \\(A=\\langle 27,17,3,16,13,10,1,5,7,12,4,8,9,0\\rangle\\).\n\n##### 6.2-2\n\nShow that each child of the root of an \\(n\\)-node heap is the root of a subtree containing at most \\(2n/3\\) nodes. What is the smallest constant \\(\\alpha\\) such that each subtree has at most \\(\\alpha n\\) nodes? How does that affect the recurrence (6.1) and its solution?\n\n##### 6.2-3\n\nStarting with the procedure Max-Heapify, write pseudocode for the procedure Min-Heapify\\((A,i)\\), which performs the corresponding manipulation on a min-heap. How does the running time of Min-Heapify compare with that of Max-Heapify?\n\n##### 6.2-4\n\nWhat is the effect of calling Max-Heapify\\((A,i)\\) when the element \\(A[i]\\) is larger than its children?\n\n##### 6.2-5\n\nWhat is the effect of calling Max-Heapify\\((A,i)\\) for \\(i\\,>\\,A\\)._heap-size\\(/2\\)_?\n\n##### 6.2-6\n\nThe code for Max-Heapify is quite efficient in terms of constant factors, except possibly for the recursive call in line 10, for which some compilers might produce inefficient code. Write an efficient Max-Heapify that uses an iterative control construct (a loop) instead of recursion.\n\n### Building a heap\n\nThe procedure Build-Max-Heap converts an array \\(A[1:n]\\) into a max-heap by calling Max-Heapify in a bottom-up manner. Exercise 6.1-8 says that the elements in the subarray \\(A[\\lfloor n/2\\rfloor+1:n]\\) are all leaves of the tree, and so each is a 1-element heap to begin with. Build-Max-Heap goes through the remaining nodes of the tree and runs Max-Heapify on each one. Figure 6.3 shows an example of the action of Build-Max-Heap.\n\nBuild-Max-Heap(\\(A,n\\))\n\n\\(A.\\)_heap-size \\(=n\\)_\n\n\\(i\\ =\\lfloor n/2\\rfloor\\)**downto \\(1\\)**\n\n\\(\\",
        "chapter": "Part II Sorting and Order Statistics",
        "section": "6 Heapsort",
        "subsection": "6.2 Maintaining the heap property",
        "subsubsection": "N/A"
    },
    {
        "content": "### Building a heap\n\nThe procedure Build-Max-Heap converts an array \\(A[1:n]\\) into a max-heap by calling Max-Heapify in a bottom-up manner. Exercise 6.1-8 says that the elements in the subarray \\(A[\\lfloor n/2\\rfloor+1:n]\\) are all leaves of the tree, and so each is a 1-element heap to begin with. Build-Max-Heap goes through the remaining nodes of the tree and runs Max-Heapify on each one. Figure 6.3 shows an example of the action of Build-Max-Heap.\n\nBuild-Max-Heap(\\(A,n\\))\n\n\\(A.\\)_heap-size \\(=n\\)_\n\n\\(i\\ =\\lfloor n/2\\rfloor\\)**downto \\(1\\)**\n\n\\(\\\nFigure 6.3: The operation of Build-Max-Heap, showing the data structure before the call to Max-Heapify in line 3 of Build-Max-Heap. The node indexed by \\(i\\) in each iteration is shown in blue. **(a)** A 10-element input array \\(A\\) and the binary tree it represents. The loop index \\(i\\) refers to node 5 before the call Max-Heapify\\((A,i)\\). **(b)** The data structure that results. The loop index \\(i\\) for the next iteration refers to node 4. **(c)\u2013(e)** Subsequent iterations of the **for** loop in Build-Max-Heap. Observe that whenever Max-Heapify is called on a node, the two subtrees of that node are both max-heaps. **(f)** The max-heap after Build-Max-Heap finishes.\n\n**Termination:**: The loop makes exactly \\(\\lfloor n/2\\rfloor\\) iterations, and so it terminates. At termination, \\(i=0\\). By the loop invariant, each node \\(1,2,\\ldots,n\\) is the root of a max-heap. In particular, node 1 is.\n\nWe can compute a simple upper bound on the running time of Build-Max-Heap as follows. Each call to Max-Heapify costs \\(O(\\lg n)\\) time, and Build-Max-Heap makes \\(O(n)\\) such calls. Thus, the running time is \\(O(n\\lg n)\\). This upper bound, though correct, is not as tight as it can be.\n\nWe can derive a tighter asymptotic bound by observing that the time for Max-Heapify to run at a node varies with the height of the node in the tree, and that the heights of most nodes are small. Our tighter analysis relies on the properties that an \\(n\\)-element heap has height \\(\\lfloor\\lg n\\rfloor\\) (see Exercise 6.1-2) and at most \\(\\left\\lceil n/2^{h+1}\\right\\rceil\\) nodes of any height \\(h\\) (see Exercise 6.3-4).\n\nThe time required by Max-Heapify when called on a node of height \\(h\\) is \\(O(h)\\). Letting \\(c\\) be the constant implicit in the asymptotic notation, we can express the total cost of Build-Max-Heap as being bounded from above by \\(\\sum_{h=0}^{\\lfloor\\lg n\\rfloor}\\left\\lceil n/2^{h+1}\\right\\rceil c\\,h\\). As Exercise 6.3-2 shows, we have \\(\\left\\lceil n/2^{h+1}\\right\\rceil\\geq 1/2\\) for \\(0\\leq h\\leq\\lfloor\\lg n\\rfloor\\). Since \\(\\left\\lceil x\\right\\rceil\\leq 2x\\) for any \\(x\\geq 1/2\\), we have \\(\\left\\lceil n/2^{h+1}\\right\\rceil\\leq n/2^{h}\\). We thus obtain\n\n\\[\\sum_{h=0}^{\\lfloor\\lg n\\rfloor}\\left\\lceil\\frac{n}{2^{h+1}} \\right\\rceil c\\,h\\] \\[\\leq\\,\\sum_{h=0}^{\\lfloor\\lg n\\rfloor}\\frac{n}{2^{h}}ch\\] \\[=\\,cn\\,\\sum_{h=0}^{\\lfloor\\lg n\\rfloor}\\frac{h}{2^{h}}\\] \\[\\leq\\,cn\\,\\sum_{h=0}^{\\infty}\\frac{h}{2^{h}}\\] \\[\\leq\\,cn\\cdot\\frac{1/2}{(1-1/2)^{2}}\\quad\\text{(by equation (A.11) on page \\ref{eq:H11} with $x=1/2$)}\\] \\[=\\,O(n)\\.\\]\n\nHence, we can build a max-heap from an unordered array in linear time.\n\nTo build a min-heap, use the procedure Build-Min-Heap, which is the same as Build-Max-Heap but with the call to Max-Heapify in line 3 replaced by a call to Min-Heapify (see Exercise 6.2-3). Build-Min-Heap produces a min-heap from an unordered linear array in linear time.\n\n### Exercises\n\n#### 6.3-1\n\nUsing Figure 6.3 as a model, illustrate the operation of Build-Max-Heap on the array \\(A=\\langle 5,3,17,10,84,19,6,22,9\\rangle\\).\n\n#### 6.3-2\n\nShow that \\(\\left\\lceil n/2^{h+1}\\right\\rceil\\geq 1/2\\) for \\(0\\leq h\\leq\\lfloor\\lg n\\rfloor\\).\n\n#### 6.3-3\n\nWhy does the loop index \\(i\\) in line 2 of Build-Max-Heap decrease from \\(\\lfloor n/2\\rfloor\\) to 1 rather than increase from 1 to \\(\\lfloor n/2\\rfloor\\)?\n\n#### 6.3-4\n\nShow that there are at most \\(\\left\\lceil n/2^{h+1}\\right\\rceil\\) nodes of height \\(h\\) in any \\(n\\)-element heap.\n\n### The heapsort algorithm\n\nThe heapsort algorithm, given by the procedure Heapsort, starts by calling the Build-Max-Heap procedure to build a max-heap on the input array \\(A[1\\!:\\!n]\\). Since the maximum element of the array is stored at the root \\(A[1]\\), Heapsort can place it into its correct final position by exchanging it with \\(A[n]\\). If the procedure then discards node \\(n\\) from the heap--and it can do so by simply decrementing \\(A\\)._heap-size_--the children of the root remain max-heaps, but the new root element might violate the max-heap property. To restore the max-heap property, the procedure just calls Max-Heapify\\((A,1)\\), which leaves a max-heap in \\(A[1\\!:\\!n-1]\\). The Heapsort procedure then repeats this process for the max-heap of size \\(n-1\\) down to a heap of size 2. (See Exercise 6.4-2 for a precise loop invariant.)\n\nHeapsort(\\(A,n\\))\n\nBuild-Max-Heap(\\(A,n\\))\n\n**for \\(i\\ =\\ n\\) downto 2**\n\nexchange \\(A[1]\\) with \\(A[i]\\)\n\n\\(A\\)._heap-size \\(=\\ A\\).heap-size \\(-1\\)_\n\nMax-Heapify(\\(A,1\\))\n\nFigure 6.4 shows an example of the operation of Heapsort after line 1 has built the initial max-heap. The figure shows the max-heap before the first iteration of the **for** loop of lines 2-5 and after each iteration.",
        "chapter": "Part II Sorting and Order Statistics",
        "section": "6 Heapsort",
        "subsection": "6.3 Building a heap",
        "subsubsection": "N/A"
    },
    {
        "content": "### Exercises\n\n#### 6.3-1\n\nUsing Figure 6.3 as a model, illustrate the operation of Build-Max-Heap on the array \\(A=\\langle 5,3,17,10,84,19,6,22,9\\rangle\\).\n\n#### 6.3-2\n\nShow that \\(\\left\\lceil n/2^{h+1}\\right\\rceil\\geq 1/2\\) for \\(0\\leq h\\leq\\left\\lfloor\\lg n\\right\\rfloor\\).\n\n#### 6.3-3\n\nWhy does the loop index \\(i\\) in line 2 of Build-Max-Heap decrease from \\(\\left\\lfloor n/2\\right\\rfloor\\) to 1 rather than increase from 1 to \\(\\left\\lfloor n/2\\right\\rfloor\\)?\n\n#### 6.3-4\n\nShow that there are at most \\(\\left\\lceil n/2^{h+1}\\right\\rceil\\) nodes of height \\(h\\) in any \\(n\\)-element heap.\n\n### The heapsort algorithm\n\nThe heapsort algorithm, given by the procedure Heapsort, starts by calling the Build-Max-Heap procedure to build a max-heap on the input array \\(A[1\\!:\\!n]\\). Since the maximum element of the array is stored at the root \\(A[1]\\), Heapsort can place it into its correct final position by exchanging it with \\(A[n]\\). If the procedure then discards node \\(n\\) from the heap--and it can do so by simply decrementing \\(A\\)._heap-size_ --the children of the root remain max-heaps, but the new root element might violate the max-heap property. To restore the max-heap property, the procedure just calls Max-Heapify\\((A,1)\\), which leaves a max-heap in \\(A[1\\!:\\!n-1]\\). The Heapsort procedure then repeats this process for the max-heap of size \\(n-1\\) down to a heap of size 2. (See Exercise 6.4-2 for a precise loop invariant.)\n\nHeapsort(\\(A,n\\))\n\nBuild-Max-Heap(\\(A,n\\))\n\n\\(i\\ =\\ n\\)**downto** 2\n\nexchange \\(A[1]\\) with \\(A[i]\\)\n\n\\(A\\)._heap-size_ \\(=\\ A\\)._heap-size_ \\(-1\\)\n\nMax-Heapify(\\(A,1\\))\n\nFigure 6.4 shows an example of the operation of Heapsort after line 1 has built the initial max-heap. The figure shows the max-heap before the first iteration of the **for** loop of lines 2-5 and after each iteration.\n\n### The heapsort algorithm\n\nFigure 6.4: The operation of Heapsort. **(a)** The max-heap data structure just after Build-Max-Heap has built it in line 1. **(b)\u2013(j)** The max-heap just after each call of Max-Heapify in line 5, showing the value of \\(i\\) at that time. Only blue nodes remain in the heap. Tan nodes contain the largest values in the array, in sorted order. **(k)** The resulting sorted array \\(A\\).\n\nThe Heapsort procedure takes \\(O(n\\lg n)\\) time, since the call to Build-Max-Heap takes \\(O(n)\\) time and each of the \\(n-1\\) calls to Max-Heapify takes \\(O(\\lg n)\\) time.\n\n##### Exercises\n\n##### 6.4-1\n\nUsing Figure 6.4 as a model, illustrate the operation of Heapsort on the array \\(A=\\langle 5,13,2,25,7,17,20,8,4\\rangle\\).\n\n##### 6.4-2\n\nArgue the correctness of Heapsort using the following loop invariant:\n\nAt the start of each iteration of the **for** loop of lines 2-5, the subarray \\(A[1:i]\\) is a max-heap containing the \\(i\\) smallest elements of \\(A[1:n]\\), and the subarray \\(A[i\\,+\\,1:n]\\) contains the \\(n-i\\) largest elements of \\(A[1:n]\\), sorted.\n\n##### 6.4-3\n\nWhat is the running time of Heapsort on an array \\(A\\) of length \\(n\\) that is already sorted in increasing order? How about if the array is already sorted in decreasing order?\n\n##### 6.4-4\n\nShow that the worst-case running time of Heapsort is \\(\\Omega(n\\lg n)\\).\n\n##### 6.4-5\n\nShow that when all the elements of \\(A\\) are distinct, the best-case running time of Heapsort is \\(\\Omega(n\\lg n)\\).\n\n### 6.5 Priority queues\n\nIn Chapter 8, we will see that any comparison-based sorting algorithm requires \\(\\Omega(n\\lg n)\\) comparisons and hence \\(\\Omega(n\\lg n)\\) time. Therefore, heapsort is asymptotically optimal among comparison-based sorting algorithms. Yet, a good implementation of quicksort, presented in Chapter 7, usually beats it in practice. Nevertheless, the heap data structure itself has many uses. In this section, we present one of the most popular applications of a heap: as an efficient priority queue. As with heaps, priority queues come in two forms: max-priority queues and min-priority queues. We'll focus here on how to implement max-priority queues, which are in turn based on max-heaps. Exercise 6.5-3 asks you to write the procedures for min-priority queues.",
        "chapter": "Part II Sorting and Order Statistics",
        "section": "6 Heapsort",
        "subsection": "6.4 The heapsort algorithm",
        "subsubsection": "N/A"
    },
    {
        "content": "The Heapsort procedure takes \\(O(n\\lg n)\\) time, since the call to Build-Max-Heap takes \\(O(n)\\) time and each of the \\(n-1\\) calls to Max-Heapify takes \\(O(\\lg n)\\) time.\n\n##### Exercises\n\n##### 6.4-1\n\nUsing Figure 6.4 as a model, illustrate the operation of Heapsort on the array \\(A=\\langle 5,13,2,25,7,17,20,8,4\\rangle\\).\n\n##### 6.4-2\n\nArgue the correctness of Heapsort using the following loop invariant:\n\nAt the start of each iteration of the **for** loop of lines 2-5, the subarray \\(A[1:i]\\) is a max-heap containing the \\(i\\) smallest elements of \\(A[1:n]\\), and the subarray \\(A[i+1:n]\\) contains the \\(n-i\\) largest elements of \\(A[1:n]\\), sorted.\n\n##### 6.4-3\n\nWhat is the running time of Heapsort on an array \\(A\\) of length \\(n\\) that is already sorted in increasing order? How about if the array is already sorted in decreasing order?\n\n##### 6.4-4\n\nShow that the worst-case running time of Heapsort is \\(\\Omega(n\\lg n)\\).\n\n##### 6.4-5\n\nShow that when all the elements of \\(A\\) are distinct, the best-case running time of Heapsort is \\(\\Omega(n\\lg n)\\).\n\n##### Priority queues\n\nIn Chapter 8, we will see that any comparison-based sorting algorithm requires \\(\\Omega(n\\lg n)\\) comparisons and hence \\(\\Omega(n\\lg n)\\) time. Therefore, heapsort is asymptotically optimal among comparison-based sorting algorithms. Yet, a good implementation of quicksort, presented in Chapter 7, usually beats it in practice. Nevertheless, the heap data structure itself has many uses. In this section, we present one of the most popular applications of a heap: as an efficient priority queue. As with heaps, priority queues come in two forms: max-priority queues and min-priority queues. We'll focus here on how to implement max-priority queues, which are in turn based on max-heaps. Exercise 6.5-3 asks you to write the procedures for min-priority queues.\n\nA _priority queue_ is a data structure for maintaining a set \\(S\\) of elements, each with an associated value called a _key_. A _max-priority queue_ supports the following operations:\n\nInsert(\\(S,x,k\\)) inserts the element \\(x\\) with key \\(k\\) into the set \\(S\\), which is equivalent to the operation \\(S=S\\cup\\{x\\}\\).\n\nMaximum(\\(S\\)) returns the element of \\(S\\) with the largest key.\n\nExtract-Max(\\(S\\)) removes and returns the element of \\(S\\) with the largest key.\n\nIncrease-Key(\\(S,x,k\\)) increases the value of element \\(x\\)'s key to the new value \\(k\\), which is assumed to be at least as large as \\(x\\)'s current key value.\n\nAmong their other applications, you can use max-priority queues to schedule jobs on a computer shared among multiple users. The max-priority queue keeps track of the jobs to be performed and their relative priorities. When a job is finished or interrupted, the scheduler selects the highest-priority job from among those pending by calling Extract-Max. The scheduler can add a new job to the queue at any time by calling Insert.\n\nAlternatively, a _min-priority queue_ supports the operations Insert, Minimum, Extract-Min, and Decrease-Key. A min-priority queue can be used in an event-driven simulator. The items in the queue are events to be simulated, each with an associated time of occurrence that serves as its key. The events must be simulated in order of their time of occurrence, because the simulation of an event can cause other events to be simulated in the future. The simulation program calls Extract-Min at each step to choose the next event to simulate. As new events are produced, the simulator inserts them into the min-priority queue by calling Insert. We'll see other uses for min-priority queues, highlighting the Decrease-Key operation, in Chapters 21 and 22.\n\nWhen you use a heap to implement a priority queue within a given application, elements of the priority queue correspond to objects in the application. Each object contains a key. If the priority queue is implemented by a heap, you need to determine which application object corresponds to a given heap element, and vice versa. Because the heap elements are stored in an array, you need a way to map application objects to and from array indices.\n\nOne way to map between application objects and heap elements uses _handles_, which are additional information stored in the objects and heap elements that give enough information to perform the mapping. Handles are often implemented to be opaque to the surrounding code, thereby maintaining an abstraction barrier between the application and the priority queue. For example, the handle within an application object might contain the corresponding index into the heap array. But since only the code for the priority queue accesses this index, the index is entirely hidden from the application code. Because heap elements change locations within the array during heap operations, an actual implementation of the priority queue, upon relocating a heap element, must also update the array indices in the corresponding handles. Conversely, each element in the heap might contain a pointer to the corresponding application object, but the heap element knows this pointer as only an opaque handle and the application maps this handle to an application object. Typically, the worst-case overhead for maintaining handles is \\(O(1)\\) per access.\n\nAs an alternative to incorporating handles in application objects, you can store within the priority queue a mapping from application objects to array indices in the heap. The advantage of doing so is that the mapping is contained entirely within the priority queue, so that the application objects need no further embellishment. The disadvantage lies in the additional cost of establishing and maintaining the mapping. One option for the mapping is a hash table (see Chapter 11).1 The added expected time for a hash table to map an object to an array index is just \\(O(1)\\), though the worst-case time can be as bad as \\(\\Theta(n)\\).\n\nFootnote 1: In Python, dictionaries are implemented with hash tables.\n\nLet's see how to implement the operations of a max-priority queue using a max-heap. In the previous sections, we treated the array elements as the keys to be sorted, implicitly assuming that any satellite data moved with the corresponding keys. When a heap implements a priority queue, we instead treat each array element as a pointer to an object in the priority queue, so that the object is analogous to the satellite data when sorting. We further assume that each such object has an attribute _key_, which determines where in the heap the object belongs. For a heap implemented by an array \\(A\\), we refer to \\(A[i]\\)._key_.\n\nThe procedure Max-Heap-Maximum on the facing page implements the Maximum operation in \\(\\Theta(1)\\) time, and Max-Heap-Extract-Max implements the operation Extract-Max. Max-Heap-Extract-Max is similar to the **for** loop body (lines 3-5) of the Heapsort procedure. We implicitly assume that Max-Heapify compares priority-queue objects based on their _key_ attributes. We also assume that when Max-Heapify exchanges elements in the array, it is exchanging pointers and also that it updates the mapping between objects and array indices. The running time of Max-Heap-Extract-Max is \\(O(\\lg n)\\), since it performs only a constant amount of work on top of the \\(O(\\lg n)\\) time for Max-Heapify, plus whatever overhead is incurred within Max-Heapify for mapping priority-queue objects to array indices.\n\nThe procedure Max-Heap-Increase-Key on page 176 implements the Increase-Key operation. It first verifies that the new key \\(k\\) will not cause the key in the object \\(x\\) to decrease, and if there is no problem, it gives \\(x\\) the new key value. The procedure then finds the index \\(i\\) in the array corresponding to object \\(x\\)\n\n[MISSING_PAGE_EMPTY:4]\n\n#### Exercises\n\n#### 6.5-1\n\nSuppose that the objects in a max-priority queue are just keys. Illustrate the operation of Max-Heap-Extract-Max on the heap \\(A=\\langle 15,13,9,5,12,8,7,4,0,6,2,1\\rangle\\).\n\n#### 6.5-2\n\nSuppose that the objects in a max-priority queue are just keys. Illustrate the operation of Max-Heap-Insert(\\(A,10\\)) on the heap \\(A=\\langle 15,13,9,5,12,8,7,4,0,6,2,1\\rangle\\).\n\n#### 6.5-3\n\nWrite pseudocode to implement a min-priority queue with a min-heap by writing the procedures Min-Heap-Minimum, Min-Heap-Extract-Min, Min-Heap-Decrease-Key, and Min-Heap-Insert.\n\n#### 6.5-4\n\nWrite pseudocode for the procedure Max-Heap-Decrease-Key(\\(A,x,k\\)) in a max-heap. What is the running time of your procedure?\n\n### Priority queues\n\nWhy does Max-Heap-Insert bother setting the key of the inserted object to \\(-\\infty\\) in line 5 given that line 8 will set the object's key to the desired value?\n\n### 6.5-6\n\nProfessor Uriah suggests replacing the **while** loop of lines 5-7 in Max-Heap-Increase-Key by a call to Max-Heapify. Explain the flaw in the professor's idea.\n\n### 6.5-7\n\nArgue the correctness of Max-Heap-Increase-Key using the following loop invariant:\n\nFigure 6.5: The operation of Max-Heap-Increase-Key. Only the key of each element in the priority queue is shown. The node indexed by \\(i\\) in each iteration is shown in blue. **(a)** The max-heap of Figure 6.4(a) with \\(i\\) indexing the node whose key is about to be increased. **(b)** This node has its key increased to 15. **(c)** After one iteration of the **while** loop of lines 5\u20137, the node and its parent have exchanged keys, and the index \\(i\\) moves up to the parent. **(d)** The max-heap after one more iteration of the **while** loop. At this point, \\(A[\\textsc{Parent}(i)]\\geq A[i]\\). The max-heap property now holds and the procedure terminates.\n\nAt the start of each iteration of the **while** loop of lines 5-7:\n\n1. If both nodes \\(\\textsc{Parent}(i)\\) and \\(\\textsc{Left}(i)\\) exist, then \\(A[\\textsc{Parent}(i)].\\mathit{key}\\geq A[\\textsc{Left}(i)].\\mathit{key}\\).\n2. If both nodes \\(\\textsc{Parent}(i)\\) and \\(\\textsc{Right}(i)\\) exist, then \\(A[\\textsc{Parent}(i)].\\mathit{key}\\geq A[\\textsc{Right}(i)].\\mathit{key}\\).\n3. The subarray \\(A[1:A.\\mathit{heap-size}]\\) satisfies the max-heap property, except that there may be one violation, which is that \\(A[i].\\mathit{key}\\) may be greater than \\(A[\\textsc{Parent}(i)].\\mathit{key}\\).\n\nYou may assume that the subarray \\(A[1:A.\\mathit{heap-size}]\\) satisfies the max-heap property at the time Max-Heap-Increase-Key is called.\n\n#### 6.5-8\n\nEach exchange operation on line 6 of Max-Heap-Increase-Key typically requires three assignments, not counting the updating of the mapping from objects to array indices. Show how to use the idea of the inner loop of Insertion-Sort to reduce the three assignments to just one assignment.\n\n#### 6.5-9\n\nShow how to implement a first-in, first-out queue with a priority queue. Show how to implement a stack with a priority queue. (Queues and stacks are defined in Section 10.1.3.)\n\n#### 6.5-10\n\nThe operation Max-Heap-Delete\\((A,x)\\) deletes the object \\(x\\) from max-heap \\(A\\). Give an implementation of Max-Heap-Delete for an \\(n\\)-element max-heap that runs in \\(O(\\lg n)\\) time plus the overhead for mapping priority queue objects to array indices.\n\n#### 6.5-11\n\nGive an \\(O(n\\lg k)\\)-time algorithm to merge \\(k\\) sorted lists into one sorted list, where \\(n\\) is the total number of elements in all the input lists. (_Hint:_ Use a min-heap for \\(k\\)-way merging.)\n\n## Problems\n\n### 6-1 Building a heap using insertion\n\nOne way to build a heap is by repeatedly calling Max-Heap-Insert to insert the elements into the heap. Consider the procedure Build-Max-Heap\\({}^{\\prime}\\) on the facing page. It assumes that the objects being inserted are just the heap elements.",
        "chapter": "Part II Sorting and Order Statistics",
        "section": "6 Heapsort",
        "subsection": "6.5 Priority queues",
        "subsubsection": "N/A"
    },
    {
        "content": "At the start of each iteration of the **while** loop of lines 5-7:\n\n1. If both nodes \\(\\textsc{Parent}(i)\\) and \\(\\textsc{Left}(i)\\) exist, then \\(A[\\textsc{Parent}(i)].\\mathit{key}\\geq A[\\textsc{Left}(i)].\\mathit{key}\\).\n2. If both nodes \\(\\textsc{Parent}(i)\\) and \\(\\textsc{Right}(i)\\) exist, then \\(A[\\textsc{Parent}(i)].\\mathit{key}\\geq A[\\textsc{Right}(i)].\\mathit{key}\\).\n3. The subarray \\(A[1:A.\\mathit{heap-size}]\\) satisfies the max-heap property, except that there may be one violation, which is that \\(A[i].\\mathit{key}\\) may be greater than \\(A[\\textsc{Parent}(i)].\\mathit{key}\\).\n\nYou may assume that the subarray \\(A[1:A.\\mathit{heap-size}]\\) satisfies the max-heap property at the time Max-Heap-Increase-Key is called.\n\n#### 6.5-8\n\nEach exchange operation on line 6 of Max-Heap-Increase-Key typically requires three assignments, not counting the updating of the mapping from objects to array indices. Show how to use the idea of the inner loop of Insertion-Sort to reduce the three assignments to just one assignment.\n\n#### 6.5-9\n\nShow how to implement a first-in, first-out queue with a priority queue. Show how to implement a stack with a priority queue. (Queues and stacks are defined in Section 10.1.3.)\n\n#### 6.5-10\n\nThe operation Max-Heap-Delete\\((A,x)\\) deletes the object \\(x\\) from max-heap \\(A\\). Give an implementation of Max-Heap-Delete for an \\(n\\)-element max-heap that runs in \\(O(\\lg n)\\) time plus the overhead for mapping priority queue objects to array indices.\n\n#### 6.5-11\n\nGive an \\(O(n\\lg k)\\)-time algorithm to merge \\(k\\) sorted lists into one sorted list, where \\(n\\) is the total number of elements in all the input lists. (_Hint:_ Use a min-heap for \\(k\\)-way merging.)\n\n## Problems\n\n### 6-1 Building a heap using insertion\n\nOne way to build a heap is by repeatedly calling Max-Heap-Insert to insert the elements into the heap. Consider the procedure Build-Max-Heap\\({}^{\\prime}\\) on the facing page. It assumes that the objects being inserted are just the heap elements.\n\n_a._ Do the procedures Build-Max-Heap and Build-Max-Heap\\({}^{\\prime}\\) always create the same heap when run on the same input array? Prove that they do, or provide a counterexample. _b._ Show that in the worst case, Build-Max-Heap\\({}^{\\prime}\\) requires \\(\\Theta(n\\lg n)\\) time to build an \\(n\\)-element heap.\n\n_6-2 Analysis of \\(d\\)-ary heaps_\n\nA _\\(d\\)-ary heap_ is like a binary heap, but (with one possible exception) nonleaf nodes have \\(d\\) children instead of two children. In all parts of this problem, assume that the time to maintain the mapping between objects and heap elements is \\(O(1)\\) per operation.\n\n_a._ Describe how to represent a \\(d\\)-ary heap in an array. _b._ Using \\(\\Theta\\)-notation, express the height of a \\(d\\)-ary heap of \\(n\\) elements in terms of \\(n\\) and \\(d\\). _c._ Give an efficient implementation of Extract-Max in a \\(d\\)-ary max-heap. Analyze its running time in terms of \\(d\\) and \\(n\\). _d._ Give an efficient implementation of Increase-Key in a \\(d\\)-ary max-heap. Analyze its running time in terms of \\(d\\) and \\(n\\). _e._ Give an efficient implementation of Insert in a \\(d\\)-ary max-heap. Analyze its running time in terms of \\(d\\) and \\(n\\). _6-3 Young tableaus_\n\nAn \\(m\\times n\\)_Young tableau_ is an \\(m\\times n\\) matrix such that the entries of each row are in sorted order from left to right and the entries of each column are in sorted order from top to bottom. Some of the entries of a Young tableau may be \\(\\infty\\), which we treat as nonexistent elements. Thus, a Young tableau can be used to hold \\(r\\leq mn\\) finite numbers.\n\n_a._ Draw a \\(4\\times 4\\) Young tableau containing the elements \\(\\{9,16,3,2,4,8,5,14,12\\}\\).\n\n* Argue that an \\(m\\times n\\) Young tableau \\(Y\\) is empty if \\(Y[1,1]=\\infty\\). Argue that \\(Y\\) is full (contains \\(mn\\) elements) if \\(Y[m,n]<\\infty\\).\n* Give an algorithm to implement Extract-Min on a nonempty \\(m\\times n\\) Young tableau that runs in \\(O(m+n)\\) time. Your algorithm should use a recursive subroutine that solves an \\(m\\times n\\) problem by recursively solving either an \\((m-1)\\times n\\) or an \\(m\\times(n-1)\\) subproblem. (_Hint:_ Think about Max-Heapify.) Explain why your implementation of Extract-Min runs in \\(O(m+n)\\) time.\n* Show how to insert a new element into a nonfull \\(m\\times n\\) Young tableau in \\(O(m+n)\\) time.\n* Using no other sorting method as a subroutine, show how to use an \\(n\\times n\\) Young tableau to sort \\(n^{2}\\) numbers in \\(O(n^{3})\\) time.\n* Give an \\(O(m+n)\\)-time algorithm to determine whether a given number is stored in a given \\(m\\times n\\) Young tableau.\n\n## Chapter notes\n\nThe heapsort algorithm was invented by Williams [456], who also described how to implement a priority queue with a heap. The Build-Max-Heap procedure was suggested by Floyd [145]. Schaffer and Sedgewick [395] showed that in the best case, the number of times elements move in the heap during heapsort is approximately \\((n/2)\\lg n\\) and that the average number of moves is approximately \\(n\\lg n\\).\n\nWe use min-heaps to implement min-priority queues in Chapters 15, 21, and 22. Other, more complicated, data structures give better time bounds for certain min-priority queue operations. Fredman and Tarjan [156] developed Fibonacci heaps, which support Insert and Decrease-Key in \\(O(1)\\) amortized time (see Chapter 16). That is, the average worst-case running time for these operations is \\(O(1)\\). Brodal, Lagogiannis, and Tarjan [73] subsequently devised strict Fibonacci heaps, which make these time bounds the actual running times. If the keys are unique and drawn from the set \\(\\{0,1,\\ldots,n-1\\}\\) of nonnegative integers, van Emde Boas trees [440, 441] support the operations Insert, Delete, Search, Minimum, Maximum, Predecessor, and Successor in \\(O(\\lg\\lg n)\\) time.\n\nIf the data are \\(b\\)-bit integers, and the computer memory consists of addressable \\(b\\)-bit words, Fredman and Willard [157] showed how to implement Minimum in \\(O(1)\\) time and Insert and Extract-Min in \\(O(\\sqrt{\\lg n})\\) time. Thorup [436] has",
        "chapter": "Part II Sorting and Order Statistics",
        "section": "6 Heapsort",
        "subsection": "Problems",
        "subsubsection": "N/A"
    },
    {
        "content": "* Argue that an \\(m\\times n\\) Young tableau \\(Y\\) is empty if \\(Y[1,1]=\\infty\\). Argue that \\(Y\\) is full (contains \\(mn\\) elements) if \\(Y[m,n]<\\infty\\).\n* Give an algorithm to implement Extract-Min on a nonempty \\(m\\times n\\) Young tableau that runs in \\(O(m+n)\\) time. Your algorithm should use a recursive subroutine that solves an \\(m\\times n\\) problem by recursively solving either an \\((m-1)\\times n\\) or an \\(m\\times(n-1)\\) subproblem. (_Hint:_ Think about Max-Heapify.) Explain why your implementation of Extract-Min runs in \\(O(m+n)\\) time.\n* Show how to insert a new element into a nonfull \\(m\\times n\\) Young tableau in \\(O(m+n)\\) time.\n* Using no other sorting method as a subroutine, show how to use an \\(n\\times n\\) Young tableau to sort \\(n^{2}\\) numbers in \\(O(n^{3})\\) time.\n* Give an \\(O(m+n)\\)-time algorithm to determine whether a given number is stored in a given \\(m\\times n\\) Young tableau.\n\n## Chapter notes\n\nThe heapsort algorithm was invented by Williams [456], who also described how to implement a priority queue with a heap. The Build-Max-Heap procedure was suggested by Floyd [145]. Schaffer and Sedgewick [395] showed that in the best case, the number of times elements move in the heap during heapsort is approximately \\((n/2)\\lg n\\) and that the average number of moves is approximately \\(n\\lg n\\).\n\nWe use min-heaps to implement min-priority queues in Chapters 15, 21, and 22. Other, more complicated, data structures give better time bounds for certain min-priority queue operations. Fredman and Tarjan [156] developed Fibonacci heaps, which support Insert and Decrease-Key in \\(O(1)\\) amortized time (see Chapter 16). That is, the average worst-case running time for these operations is \\(O(1)\\). Brodal, Lagogiannis, and Tarjan [73] subsequently devised strict Fibonacci heaps, which make these time bounds the actual running times. If the keys are unique and drawn from the set \\(\\{0,1,\\ldots,n-1\\}\\) of nonnegative integers, van Emde Boas trees [440, 441] support the operations Insert, Delete, Search, Minimum, Maximum, Predecessor, and Successor in \\(O(\\lg\\lg n)\\) time.\n\nIf the data are \\(b\\)-bit integers, and the computer memory consists of addressable \\(b\\)-bit words, Fredman and Willard [157] showed how to implement Minimum in \\(O(1)\\) time and Insert and Extract-Min in \\(O(\\sqrt{\\lg n})\\) time. Thorup [436] hasimproved the \\(O(\\sqrt{\\lg n})\\) bound to \\(O(\\lg\\lg n)\\) time by using randomized hashing, requiring only linear space.\n\nAn important special case of priority queues occurs when the sequence of Extract-Min operations is _monotone_, that is, the values returned by successive Extract-Min operations are monotonically increasing over time. This case arises in several important applications, such as Dijkstra's single-source shortest-paths algorithm, which we discuss in Chapter 22, and in discrete-event simulation. For Dijkstra's algorithm it is particularly important that the Decrease-Key operation be implemented efficiently. For the monotone case, if the data are integers in the range \\(1,2,\\ldots,C\\), Ahuja, Mehlhorn, Orlin, and Tarjan [8] describe how to implement Extract-Min and Insert in \\(O(\\lg C)\\) amortized time (Chapter 16 presents amortized analysis) and Decrease-Key in \\(O(1)\\) time, using a data structure called a radix heap. The \\(O(\\lg C)\\) bound can be improved to \\(O(\\sqrt{\\lg C})\\) using Fibonacci heaps in conjunction with radix heaps. Cherkassky, Goldberg, and Silverstein [90] further improved the bound to \\(O(\\lg^{1/3+\\epsilon}C)\\) expected time by combining the multilevel bucketing structure of Denardo and Fox [112] with the heap of Thorup mentioned earlier. Raman [375] further improved these results to obtain a bound of \\(O\\left(\\min\\left\\{\\lg^{1/4+\\epsilon}C,\\lg^{1/3+\\epsilon}n\\right\\}\\right)\\), for any fixed \\(\\epsilon>0\\).\n\nMany other variants of heaps have been proposed. Brodal [72] surveys some of these developments.\n\nQuicksort\n\nThe quicksort algorithm has a worst-case running time of \\(\\Theta(n^{2})\\) on an input array of \\(n\\) numbers. Despite this slow worst-case running time, quicksort is often the best practical choice for sorting because it is remarkably efficient on average: its expected running time is \\(\\Theta(n\\lg n)\\) when all numbers are distinct, and the constant factors hidden in the \\(\\Theta(n\\lg n)\\) notation are small. Unlike merge sort, it also has the advantage of sorting in place (see page 158), and it works well even in virtual-memory environments.\n\nOur study of quicksort is broken into four sections. Section 7.1 describes the algorithm and an important subroutine used by quicksort for partitioning. Because the behavior of quicksort is complex, we'll start with an intuitive discussion of its performance in Section 7.2 and analyze it precisely at the end of the chapter. Section 7.3 presents a randomized version of quicksort. When all elements are distinct,1 this randomized algorithm has a good expected running time and no particular input elicits its worst-case behavior. (See Problem 7-2 for the case in which elements may be equal.) Section 7.4 analyzes the randomized algorithm, showing that it runs in \\(\\Theta(n^{2})\\) time in the worst case and, assuming distinct elements, in expected \\(O(n\\lg n)\\) time.\n\nFootnote 1: You can enforce the assumption that the values in an array \\(A\\) are distinct at the cost of \\(\\Theta(n)\\) additional space and only constant overhead in running time by converting each input value \\(A[i]\\) to an ordered pair \\((A[i],i)\\) with \\((A[i],i)<(A[j],j)\\) if \\(A[i]{<}A[j]\\) or if \\(A[i]=A[j]\\) and \\(i<j\\). There are also more practical variants of quicksort that work well when elements are not distinct.",
        "chapter": "Part II Sorting and Order Statistics",
        "section": "6 Heapsort",
        "subsection": "Chapter notes",
        "subsubsection": "N/A"
    },
    {
        "content": "### Description of quicksort\n\nQuicksort, like merge sort, applies the divide-and-conquer method introduced in Section 2.3.1. Here is the three-step divide-and-conquer process for sorting a subarray \\(A[p:r]\\):\n\n**Divide** by partitioning (rearranging) the array \\(A[p:r]\\) into two (possibly empty) subarrays \\(A[p:q-1]\\) (the _low side_) and \\(A[q+1:r]\\) (the _high side_) such that each element in the low side of the partition is less than or equal to the _pivot_\\(A[q]\\), which is, in turn, less than or equal to each element in the high side. Compute the index \\(q\\) of the pivot as part of this partitioning procedure.\n**Conquer** by calling quicksort recursively to sort each of the subarrays \\(A[p:q-1]\\) and \\(A[q+1:r]\\).\n**Combine** by doing nothing: because the two subarrays are already sorted, no work is needed to combine them. All elements in \\(A[p:q-1]\\) are sorted and less than or equal to \\(A[q]\\), and all elements in \\(A[q+1:r]\\) are sorted and greater than or equal to the pivot \\(A[q]\\). The entire subarray \\(A[p:r]\\) cannot help but be sorted!\n\nThe Quicksort procedure implements quicksort. To sort an entire \\(n\\)-element array \\(A[1:n]\\), the initial call is Quicksort(\\(A,1,n\\)).\n\nQuicksort(\\(A,p,r\\))\n\n**Partitioning the array**\n\nThe key to the algorithm is the Partition procedure on the next page, which rearranges the subarray \\(A[p:r]\\) in place, returning the index of the dividing point between the two sides of the partition.\n\nFigure 7.1 shows how Partition works on an 8-element array. Partition always selects the element \\(x=A[r]\\) as the pivot. As the procedure runs, each element falls into exactly one of four regions, some of which may be empty. At the start of each iteration of the **for** loop in lines 3-6, the regions satisfy certain properties, shown in Figure 7.2. We state these properties as a loop invariant:At the beginning of each iteration of the loop of lines 3-6, for any array index \\(k\\), the following conditions hold:\n\n1. if \\(p\\leq k\\leq i\\), then \\(A[k]\\leq x\\) (the tan region of Figure 7.2);\n2. if \\(i+1\\leq k\\leq j-1\\), then \\(A[k]>x\\) (the blue region);\n3. if \\(k=r\\), then \\(A[k]=x\\) (the yellow region).\n\nWe need to show that this loop invariant is true prior to the first iteration, that each iteration of the loop maintains the invariant, that the loop terminates, and that correctness follows from the invariant when the loop terminates.\n\n**Initialization:**: Prior to the first iteration of the loop, we have \\(i=p-1\\) and \\(j=p\\). Because no values lie between \\(p\\) and \\(i\\) and no values lie between \\(i+1\\) and \\(j-1\\), the first two conditions of the loop invariant are trivially satisfied. The assignment in line 1 satisfies the third condition.\n**Maintenance:**: As Figure 7.3 shows, we consider two cases, depending on the outcome of the test in line 4. Figure 7.3(a) shows what happens when \\(A[j]>x\\): the only action in the loop is to increment \\(j\\). After \\(j\\) has been incremented, the second condition holds for \\(A[j-1]\\) and all other entries remain unchanged. Figure 7.3(b) shows what happens when \\(A[j]\\leq x\\): the loop increments \\(i\\), swaps \\(A[i]\\) and \\(A[j]\\), and then increments \\(j\\). Because of the swap, we now have that \\(A[i]\\leq x\\), and condition 1 is satisfied. Similarly, we also have that \\(A[j-1]>x\\), since the item that was swapped into \\(A[j-1]\\) is, by the loop invariant, greater than \\(x\\).\n**Termination:**: Since the loop makes exactly \\(r-p\\) iterations, it terminates, whereupon \\(j=r\\). At that point, the unexamined subarray \\(A[j:r-1]\\) is empty, and every entry in the array belongs to one of the other three sets described by the invariant. Thus, the values in the array have been partitioned into three sets: those less than or equal to \\(x\\) (the low side), those greater than \\(x\\) (the high side), and a singleton set containing \\(x\\) (the pivot).\n\n### Description of quicksort\n\nThe final two lines of Partition finish up by swapping the pivot with the leftmost element greater than \\(x\\), thereby moving the pivot into its correct place in the partitioned array, and then returning the pivot's new index. The output of Partition now satisfies the specifications given for the divide step. In fact, it satisfies a slightly stronger condition: after line 3 of Quicksort, \\(A[q]\\) is strictly less than every element of \\(A[q+1:r]\\).\n\nFigure 7.1: The operation of Partition on a sample array. Array entry \\(A[r]\\) becomes the pivot element \\(x\\). Tan array elements all belong to the low side of the partition, with values at most \\(x\\). Blue elements belong to the high side, with values greater than \\(x\\). White elements have not yet been put into either side of the partition, and the yellow element is the pivot \\(x\\). **(a)** The initial array and variable settings. None of the elements have been placed into either side of the partition. **(b)** The value 2 is \u201cswapped with itself\u201d and put into the low side. **(c)\u2013(d)** The values 8 and 7 are placed into to high side. **(e)** The values 1 and 8 are swapped, and the low side grows. **(f)** The values 3 and 7 are swapped, and the low side grows. **(g)\u2013(h)** The high side of the partition grows to include 5 and 6, and the loop terminates. **(i)** Line 7 swaps the pivot element so that it lies between the two sides of the partition, and line 8 returns the pivot\u2019s new index.\n\nExercise 7.1-3 asks you to show that the running time of Partition on a subarray \\(A[p:r]\\) of \\(n=r-p+1\\) elements is \\(\\Theta(n)\\).\n\n#### Exercises\n\n_7.1-1_\n\nUsing Figure 7.1 as a model, illustrate the operation of Partition on the array \\(A=(13,19,9,5,12,8,7,4,21,2,6,11)\\).\n\nFigure 7.2: The four regions maintained by the procedure Partition on a subarray \\(A[p:r]\\). The tan values in \\(A[p:i]\\) are all less than or equal to \\(x\\), the blue values in \\(A[i+1:j-1]\\) are all greater than \\(x\\), the white values in \\(A[j:r-1]\\) have unknown relationships to \\(x\\), and \\(A[r]=x\\).\n\nFigure 7.3: The two cases for one iteration of procedure Partition. **(a)** If \\(A[j]{>}x\\), the only action is to increment \\(j\\), which maintains the loop invariant. **(b)** If \\(A[j]\\leq x\\), index \\(i\\) is incremented, \\(A[i]\\) and \\(A[j]\\) are swapped, and then \\(j\\) is incremented. Again, the loop invariant is maintained.\n\n### Performance of quicksort\n\n#### 7.1-2\n\nWhat value of \\(q\\) does Partition return when all elements in the subarray \\(A[p:r]\\) have the same value? Modify Partition so that \\(q=\\lfloor(p+r)/2\\rfloor\\) when all elements in the subarray \\(A[p:r]\\) have the same value.\n\n#### 7.1-3\n\nGive a brief argument that the running time of Partition on a subarray of size \\(n\\) is \\(\\Theta(n)\\).\n\n#### 7.1-4\n\nModify Quicksort to sort into monotonically decreasing order.\n\n### Performance of quicksort\n\nThe running time of quicksort depends on how balanced each partitioning is, which in turn depends on which elements are used as pivots. If the two sides of a partition are about the same size -- the partitioning is balanced-- then the algorithm runs asymptotically as fast as merge sort. If the partitioning is unbalanced, however, it can run asymptotically as slowly as insertion sort. To allow you to gain some intuition before diving into a formal analysis, this section informally investigates how quicksort performs under the assumptions of balanced versus unbalanced partitioning.\n\nBut first, let's briefly look at the maximum amount of memory that quicksort requires. Although quicksort sorts in place according to the definition on page 158, the amount of memory it uses-- aside from the array being sorted-- is not constant. Since each recursive call requires a constant amount of space on the runtime stack, outside of the array being sorted, quicksort requires space proportional to the maximum depth of the recursion. As we'll see now, that could be as bad as \\(\\Theta(n)\\) in the worst case.\n\n#### Worst-case partitioning\n\nThe worst-case behavior for quicksort occurs when the partitioning produces one subproblem with \\(n-1\\) elements and one with \\(0\\) elements. (See Section 7.4.1.) Let us assume that this unbalanced partitioning arises in each recursive call. The partitioning costs \\(\\Theta(n)\\) time. Since the recursive call on an array of size \\(0\\) just returns without doing anything, \\(T(0)=\\Theta(1)\\), and the recurrence for the running time is",
        "chapter": "Part II Sorting and Order Statistics",
        "section": "7 Quicksort",
        "subsection": "7.1 Description of quicksort",
        "subsubsection": "N/A"
    },
    {
        "content": "### Performance of quicksort\n\n#### 7.1-2\n\nWhat value of \\(q\\) does Partition return when all elements in the subarray \\(A[p:r]\\) have the same value? Modify Partition so that \\(q=\\lfloor(p+r)/2\\rfloor\\) when all elements in the subarray \\(A[p:r]\\) have the same value.\n\n#### 7.1-3\n\nGive a brief argument that the running time of Partition on a subarray of size \\(n\\) is \\(\\Theta(n)\\).\n\n#### 7.1-4\n\nModify Quicksort to sort into monotonically decreasing order.\n\n### Performance of quicksort\n\nThe running time of quicksort depends on how balanced each partitioning is, which in turn depends on which elements are used as pivots. If the two sides of a partition are about the same size -- the partitioning is balanced-- then the algorithm runs asymptotically as fast as merge sort. If the partitioning is unbalanced, however, it can run asymptotically as slowly as insertion sort. To allow you to gain some intuition before diving into a formal analysis, this section informally investigates how quicksort performs under the assumptions of balanced versus unbalanced partitioning.\n\nBut first, let's briefly look at the maximum amount of memory that quicksort requires. Although quicksort sorts in place according to the definition on page 158, the amount of memory it uses-- aside from the array being sorted-- is not constant. Since each recursive call requires a constant amount of space on the runtime stack, outside of the array being sorted, quicksort requires space proportional to the maximum depth of the recursion. As we'll see now, that could be as bad as \\(\\Theta(n)\\) in the worst case.\n\n#### Worst-case partitioning\n\nThe worst-case behavior for quicksort occurs when the partitioning produces one subproblem with \\(n-1\\) elements and one with \\(0\\) elements. (See Section 7.4.1.) Let us assume that this unbalanced partitioning arises in each recursive call. The partitioning costs \\(\\Theta(n)\\) time. Since the recursive call on an array of size \\(0\\) just returns without doing anything, \\(T(0)=\\Theta(1)\\), and the recurrence for the running time is\\[T(n) = T(n-1)+T(0)+\\Theta(n)\\] \\[= T(n-1)+\\Theta(n)\\.\\]\n\nBy summing the costs incurred at each level of the recursion, we obtain an arithmetic series (equation (A.3) on page 1141), which evaluates to \\(\\Theta(n^{2})\\). Indeed, the substitution method can be used to prove that the recurrence \\(T(n)=T(n-1)+\\Theta(n)\\) has the solution \\(T(n)=\\Theta(n^{2})\\). (See Exercise 7.2-1.)\n\nThus, if the partitioning is maximally unbalanced at every recursive level of the algorithm, the running time is \\(\\Theta(n^{2})\\). The worst-case running time of quicksort is therefore no better than that of insertion sort. Moreover, the \\(\\Theta(n^{2})\\) running time occurs when the input array is already completely sorted--a situation in which insertion sort runs in \\(O(n)\\) time.\n\n##### Best-case partitioning\n\nIn the most even possible split, Partition produces two subproblems, each of size no more than \\(n/2\\), since one is of size \\(\\lfloor(n-1)/2\\rfloor\\leq n/2\\) and one of size \\(\\lceil(n-1)/2\\rceil-1\\leq n/2\\). In this case, quicksort runs much faster. An upper bound on the running time can then be described by the recurrence\n\n\\[T(n)=2T(n/2)+\\Theta(n)\\.\\]\n\nBy case 2 of the master theorem (Theorem 4.1 on page 102), this recurrence has the solution \\(T(n)=\\Theta(n\\lg n)\\). Thus, if the partitioning is equally balanced at every level of the recursion, an asymptotically faster algorithm results.\n\n##### Balanced partitioning\n\nAs the analyses in Section 7.4 will show, the average-case running time of quicksort is much closer to the best case than to the worst case. By appreciating how the balance of the partitioning affects the recurrence describing the running time, we can gain an understanding of why.\n\nSuppose, for example, that the partitioning algorithm always produces a 9-to-1 proportional split, which at first blush seems quite unbalanced. We then obtain the recurrence\n\n\\[T(n)=T(9n/10)+T(n/10)+\\Theta(n)\\,\\]\n\non the running time of quicksort. Figure 7.4 shows the recursion tree for this recurrence, where for simplicity the \\(\\Theta(n)\\) driving function has been replaced by \\(n\\), which won't affect the asymptotic solution of the recurrence (as Exercise 4.7-1 on page 118 justifies). Every level of the tree has cost \\(n\\), until the recursion bottoms out in a base case at depth \\(\\log_{10}n=\\Theta(\\lg n)\\), and then the levels have cost \n\n### Performance of quicksort\n\nIn this section, we present a general algorithm for quicksort in which quicksort is a 9-to-1 split, yielding a running time of \\(O(n\\lg n)\\). The algorithm is based on the fact that quicksort is a 9-to-1 split, yielding a running time of \\(O(n\\lg n)\\).\n\nWe expect that some of the splits will be reasonably well balanced and that some will be fairly unbalanced. For example, Exercise 7.2-6 asks you to show that about 80% of the time Partition produces a split that is at least as balanced as 9 to 1, and about 20% of the time it produces a split that is less balanced than 9 to 1.\n\nIn the average case, Partition produces a mix of \"good\" and \"bad\" splits. In a recursion tree for an average-case execution of Partition, the good and bad splits are distributed randomly throughout the tree. Suppose for the sake of intuition that the good and bad splits alternate levels in the tree, and that the good splits are best-case splits and the bad splits are worst-case splits. Figure 7.5(a) shows the splits at two consecutive levels in the recursion tree. At the root of the tree, the cost is \\(n\\) for partitioning, and the subarrays produced have sizes \\(n-1\\) and \\(0\\): the worst case. At the next level, the subarray of size \\(n-1\\) undergoes best-case partitioning into subarrays of size \\((n-1)/2-1\\) and \\((n-1)/2\\). Let's assume that the base-case cost is 1 for the subarray of size 0.\n\nThe combination of the bad split followed by the good split produces three subarrays of sizes 0, \\((n-1)/2-1\\), and \\((n-1)/2\\) at a combined partitioning cost of \\(\\Theta(n)+\\Theta(n-1)=\\Theta(n)\\). This situation is at most a constant factor worse than that in Figure 7.5(b), namely, where a single level of partitioning produces two subarrays of size \\((n-1)/2\\), at a cost of \\(\\Theta(n)\\). Yet this latter situation is balanced! Intuitively, the \\(\\Theta(n-1)\\) cost of the bad split in Figure 7.5(a) can be absorbed into the \\(\\Theta(n)\\) cost of the good split, and the resulting split is good. Thus, the running time of quicksort, when levels alternate between good and bad splits, is like the running time for good splits alone: still \\(O(n\\lg n)\\), but with a slightly larger constant hidden by the \\(O\\)-notation. We'll analyze the expected running time of a randomized version of quicksort rigorously in Section 7.4.2.\n\nFigure 7.5: **(a)** Two levels of a recursion tree for quicksort. The partitioning at the root costs \\(n\\) and produces a \u201cbad\u201d split: two subarrays of sizes 0 and \\(n-1\\). The partitioning of the subarray of size \\(n-1\\) costs \\(n-1\\) and produces a \u201cgood\u201d split: subarrays of size \\((n-1)/2-1\\) and \\((n-1)/2\\). **(b)** A single level of a recursion tree that is well balanced. In both parts, the partitioning cost for the subproblems shown with blue shading is \\(\\Theta(n)\\). Yet the subproblems remaining to be solved in (a), shown with tan shading, are no larger than the corresponding subproblems remaining to be solved in (b).\n\n### Exercises\n\n#### 7.2-1\n\nUse the substitution method to prove that the recurrence \\(T(n)=T(n-1)+\\Theta(n)\\) has the solution \\(T(n)=\\Theta(n^{2})\\), as claimed at the beginning of Section 7.2.\n\n#### 7.2-2\n\nWhat is the running time of Quicksort when all elements of array \\(A\\) have the same value?\n\n#### 7.2-3\n\nShow that the running time of Quicksort is \\(\\Theta(n^{2})\\) when the array \\(A\\) contains distinct elements and is sorted in decreasing order.\n\n#### 7.2-4\n\nBanks often record transactions on an account in order of the times of the transactions, but many people like to receive their bank statements with checks listed in order by check number. People usually write checks in order by check number, and merchants usually cash them with reasonable dispatch. The problem of converting time-of-transaction ordering to check-number ordering is therefore the problem of sorting almost-sorted input. Explain persuasively why the procedure Insertion-Sort might tend to beat the procedure Quicksort on this problem.\n\n#### 7.2-5\n\nSuppose that the splits at every level of quicksort are in the constant proportion \\(\\alpha\\) to \\(\\beta\\), where \\(\\alpha+\\beta=1\\) and \\(0<\\alpha\\leq\\beta<1\\). Show that the minimum depth of a leaf in the recursion tree is approximately \\(\\log_{1/\\alpha}n\\) and that the maximum depth is approximately \\(\\log_{1/\\beta}n\\). (Don't worry about integer round-off.)\n\n#### 7.2-6\n\nConsider an array with distinct elements and for which all permutations of the elements are equally likely. Argue that for any constant \\(0<\\alpha\\leq 1/2\\), the probability is approximately \\(1-2\\alpha\\) that Partition produces a split at least as balanced as \\(1-\\alpha\\) to \\(\\alpha\\).\n\n### A randomized version of quicksort\n\nIn exploring the average-case behavior of quicksort, we have assumed that all permutations of the input numbers are equally likely. This assumption does not always hold, however, as, for example, in the situation laid out in the premise for",
        "chapter": "Part II Sorting and Order Statistics",
        "section": "7 Quicksort",
        "subsection": "7.2 Performance of quicksort",
        "subsubsection": "N/A"
    },
    {
        "content": "### Exercises\n\n#### 7.2-1\n\nUse the substitution method to prove that the recurrence \\(T(n)=T(n-1)+\\Theta(n)\\) has the solution \\(T(n)=\\Theta(n^{2})\\), as claimed at the beginning of Section 7.2.\n\n#### 7.2-2\n\nWhat is the running time of Quicksort when all elements of array \\(A\\) have the same value?\n\n#### 7.2-3\n\nShow that the running time of Quicksort is \\(\\Theta(n^{2})\\) when the array \\(A\\) contains distinct elements and is sorted in decreasing order.\n\n#### 7.2-4\n\nBanks often record transactions on an account in order of the times of the transactions, but many people like to receive their bank statements with checks listed in order by check number. People usually write checks in order by check number, and merchants usually cash them with reasonable dispatch. The problem of converting time-of-transaction ordering to check-number ordering is therefore the problem of sorting almost-sorted input. Explain persuasively why the procedure Insertion-Sort might tend to beat the procedure Quicksort on this problem.\n\n#### 7.2-5\n\nSuppose that the splits at every level of quicksort are in the constant proportion \\(\\alpha\\) to \\(\\beta\\), where \\(\\alpha+\\beta=1\\) and \\(0<\\alpha\\leq\\beta<1\\). Show that the minimum depth of a leaf in the recursion tree is approximately \\(\\log_{1/\\alpha}n\\) and that the maximum depth is approximately \\(\\log_{1/\\beta}n\\). (Don't worry about integer round-off.)\n\n#### 7.2-6\n\nConsider an array with distinct elements and for which all permutations of the elements are equally likely. Argue that for any constant \\(0<\\alpha\\leq 1/2\\), the probability is approximately \\(1-2\\alpha\\) that Partition produces a split at least as balanced as \\(1-\\alpha\\) to \\(\\alpha\\).\n\n### A randomized version of quicksort\n\nIn exploring the average-case behavior of quicksort, we have assumed that all permutations of the input numbers are equally likely. This assumption does not always hold, however, as, for example, in the situation laid out in the premise forExercise 7.2-4. Section 5.3 showed that judicious randomization can sometimes be added to an algorithm to obtain good expected performance over all inputs. For quicksort, randomization yields a fast and practical algorithm. Many software libraries provide a randomized version of quicksort as their algorithm of choice for sorting large data sets.\n\nIn Section 5.3, the Randomized-Hire-Assistant procedure explicitly permutes its input and then runs the deterministic Hire-Assistant procedure. We could do the same for quicksort as well, but a different randomization technique yields a simpler analysis. Instead of always using \\(A[r]\\) as the pivot, a randomized version randomly chooses the pivot from the subarray \\(A[p:r]\\), where each element in \\(A[p:r]\\) has an equal probability of being chosen. It then exchanges that element with \\(A[r]\\) before partitioning. Because the pivot is chosen randomly, we expect the split of the input array to be reasonably well balanced on average.\n\nThe changes to Partition and Quicksort are small. The new partitioning procedure, Randomized-Partition, simply swaps before performing the partitioning. The new quicksort procedure, Randomized-Quicksort, calls Randomized-Partition instead of Partition. We'll analyze this algorithm in the next section.\n\n```\nRandomized-Partition(\\(A\\), \\(p,r\\))\n1\\(i=\\textsc{Random}(p,r)\\)\n2exchange\\(A[r]\\) with \\(A[i]\\)\n3returnPartition(\\(A\\), \\(p,r\\))\n4Randomized-Quicksort(\\(A\\), \\(p,r\\))\n5if\\(p<r\\)\n6\\(q=\\textsc{Randomized-Partition}(A,p,r)\\)\n7Randomized-Quicksort(\\(A\\), \\(p,q-1\\))\n8Randomized-Quicksort(\\(A\\), \\(q+1,r\\))\n```\n\n**Exercises**\n\nWhy do we analyze the expected running time of a randomized algorithm and not its worst-case running time?\n\n### Analysis of quicksort\n\nWhen Randomized-Quicksort runs, how many calls are made to the random-number generator Random in the worst case? How about in the best case? Give your answer in terms of \\(\\Theta\\)-notation.\n\n### Analysis of quicksort\n\nSection 7.2 gave some intuition for the worst-case behavior of quicksort and for why we expect the algorithm to run quickly. This section analyzes the behavior of quicksort more rigorously. We begin with a worst-case analysis, which applies to either Quicksort or Randomized-Quicksort, and conclude with an analysis of the expected running time of Randomized-Quicksort.\n\n#### Worst-case analysis\n\nWe saw in Section 7.2 that a worst-case split at every level of recursion in quicksort produces a \\(\\Theta(n^{2})\\) running time, which, intuitively, is the worst-case running time of the algorithm. We now prove this assertion.\n\nWe'll use the substitution method (see Section 4.3) to show that the running time of quicksort is \\(O(n^{2})\\). Let \\(T(n)\\) be the worst-case time for the procedure Quicksort on an input of size \\(n\\). Because the procedure Partition produces two subproblems with total size \\(n-1\\), we obtain the recurrence\n\n\\[T(n)=\\max\\left\\{T(q)+T(n-1-q):0\\leq q\\leq n-1\\right\\}+\\Theta(n)\\, \\tag{7.1}\\]\n\nWe guess that \\(T(n)\\leq cn^{2}\\) for some constant \\(c>0\\). Substituting this guess into recurrence (7.1) yields\n\n\\[T(n) \\leq\\max\\left\\{cq^{2}+c(n-1-q)^{2}:0\\leq q\\leq n-1\\right\\}+\\Theta(n)\\] \\[=\\ c\\cdot\\max\\left\\{q^{2}+(n-1-q)^{2}:0\\leq q\\leq n-1\\right\\}+ \\Theta(n)\\.\\]\n\nLet's focus our attention on the maximization. For \\(q=0,1,\\ldots,n-1\\), we have\n\n\\[q^{2}+(n-1-q)^{2} =\\ q^{2}+(n-1)^{2}-2q(n-1)+q^{2}\\] \\[=\\ (n-1)^{2}+2q(q-(n-1))\\] \\[\\leq\\ (n-1)^{2}\\]\n\nbecause \\(q\\leq n-1\\) implies that \\(2q(q-(n-1))\\leq 0\\). Thus every term in the maximization is bounded by \\((n-1)^{2}\\).\n\nContinuing with our analysis of \\(T(n)\\), we obtain",
        "chapter": "Part II Sorting and Order Statistics",
        "section": "7 Quicksort",
        "subsection": "7.3 A randomized version of quicksort",
        "subsubsection": "N/A"
    },
    {
        "content": "### Analysis of quicksort\n\nWhen Randomized-Quicksort runs, how many calls are made to the random-number generator Random in the worst case? How about in the best case? Give your answer in terms of \\(\\Theta\\)-notation.\n\n### Analysis of quicksort\n\nSection 7.2 gave some intuition for the worst-case behavior of quicksort and for why we expect the algorithm to run quickly. This section analyzes the behavior of quicksort more rigorously. We begin with a worst-case analysis, which applies to either Quicksort or Randomized-Quicksort, and conclude with an analysis of the expected running time of Randomized-Quicksort.\n\n#### Worst-case analysis\n\nWe saw in Section 7.2 that a worst-case split at every level of recursion in quicksort produces a \\(\\Theta(n^{2})\\) running time, which, intuitively, is the worst-case running time of the algorithm. We now prove this assertion.\n\nWe'll use the substitution method (see Section 4.3) to show that the running time of quicksort is \\(O(n^{2})\\). Let \\(T(n)\\) be the worst-case time for the procedure Quicksort on an input of size \\(n\\). Because the procedure Partition produces two subproblems with total size \\(n-1\\), we obtain the recurrence\n\n\\[T(n)=\\max\\left\\{T(q)+T(n-1-q):0\\leq q\\leq n-1\\right\\}+\\Theta(n)\\, \\tag{7.1}\\]\n\nWe guess that \\(T(n)\\leq cn^{2}\\) for some constant \\(c>0\\). Substituting this guess into recurrence (7.1) yields\n\n\\[T(n) \\leq\\max\\left\\{cq^{2}+c(n-1-q)^{2}:0\\leq q\\leq n-1\\right\\}+\\Theta (n)\\] \\[=\\ c\\cdot\\max\\left\\{q^{2}+(n-1-q)^{2}:0\\leq q\\leq n-1\\right\\}+ \\Theta(n)\\.\\]\n\nLet's focus our attention on the maximization. For \\(q=0,1,\\ldots,n-1\\), we have\n\n\\[q^{2}+(n-1-q)^{2} =\\ q^{2}+(n-1)^{2}-2q(n-1)+q^{2}\\] \\[=\\ (n-1)^{2}+2q(q-(n-1))\\] \\[\\leq\\ (n-1)^{2}\\]\n\nbecause \\(q\\leq n-1\\) implies that \\(2q(q-(n-1))\\leq 0\\). Thus every term in the maximization is bounded by \\((n-1)^{2}\\).\n\nContinuing with our analysis of \\(T(n)\\), we obtain\\[T(n) \\leq\\ c(n-1)^{2}+\\Theta(n)\\] \\[\\leq\\ cn^{2}-c(2n-1)+\\Theta(n)\\] \\[\\leq\\ cn^{2}\\,\\] by picking the constant \\(c\\) large enough that the \\(c\\,(2n-1)\\) term dominates the \\(\\Theta(n)\\) term. Thus \\(T(n)=O(n^{2})\\). Section 7.2 showed a specific case where quicksort takes \\(\\Omega(n^{2})\\) time: when partitioning is maximally unbalanced. Thus, the worst-case running time of quicksort is \\(\\Theta(n^{2})\\).\n\n#### Expected running time\n\nWe have already seen the intuition behind why the expected running time of Randomized-Quicksort is \\(O(n\\lg n)\\): if, in each level of recursion, the split induced by Randomized-Partition puts any constant fraction of the elements on one side of the partition, then the recursion tree has depth \\(\\Theta(\\lg n)\\) and \\(O(n)\\) work is performed at each level. Even if we add a few new levels with the most unbalanced split possible between these levels, the total time remains \\(O(n\\lg n)\\). We can analyze the expected running time of Randomized-Quicksort precisely by first understanding how the partitioning procedure operates and then using this understanding to derive an \\(O(n\\lg n)\\) bound on the expected running time. This upper bound on the expected running time, combined with the \\(\\Theta(n\\lg n)\\) best-case bound we saw in Section 7.2, yields a \\(\\Theta(n\\lg n)\\) expected running time. We assume throughout that the values of the elements being sorted are distinct.\n\n##### Running time and comparisons\n\nThe Quicksort and Randomized-Quicksort procedures differ only in how they select pivot elements. They are the same in all other respects. We can therefore analyze Randomized-Quicksort by considering the Quicksort and Partition procedures, but with the assumption that pivot elements are selected randomly from the subarray passed to Randomized-Partition. Let's start by relating the asymptotic running time of Quicksort to the number of times elements are compared (all in line 4 of Partition), understanding that this analysis also applies to Randomized-Quicksort. Note that we are counting the number of times that _array elements_ are compared, not comparisons of indices.\n\n##### Lemma 7.1\n\nThe running time of Quicksort on an \\(n\\)-element array is \\(O(n+X)\\), where \\(X\\) is the number of element comparisons performed.\n\n_Proof_ The running time of Quicksort is dominated by the time spent in the Partition procedure. Each time Partition is called, it selects a pivot element, which is never included in any future recursive calls to Quicksort and Partition. Thus, there can be at most \\(n\\) calls to Partition over the entire execution of the quicksort algorithm. Each time Quicksort calls Partition, it also recursively calls itself twice, so there are at most \\(2n\\) calls to the Quicksort procedure itself.\n\nOne call to Partition takes \\(O(1)\\) time plus an amount of time that is proportional to the number of iterations of the **for** loop in lines 3-6. Each iteration of this **for** loop performs one comparison in line 4, comparing the pivot element to another element of the array \\(A\\). Therefore, the total time spent in the **for** loop across all executions is proportional to \\(X\\). Since there are at most \\(n\\) calls to Partition and the time spent outside the **for** loop is \\(O(1)\\) for each call, the total time spent in Partition outside of the **for** loop is \\(O(n)\\). Thus the total time for quicksort is \\(O(n+X)\\).\n\nOur goal for analyzing Randomized-Quicksort, therefore, is to compute the expected value \\(\\operatorname{E}\\left[X\\right]\\) of the random variable \\(X\\) denoting the total number of comparisons performed in all calls to Partition. To do so, we must understand when the quicksort algorithm compares two elements of the array and when it does not. For ease of analysis, let's index the elements of the array \\(A\\) by their position in the sorted output, rather than their position in the input. That is, although the elements in \\(A\\) may start out in any order, we'll refer to them by \\(z_{1},z_{2},\\ldots,z_{n}\\), where \\(z_{1}<z_{2}<\\cdots<z_{n}\\), with strict inequality because we assume that all elements are distinct. We denote the set \\(\\{z_{i},z_{i+1},\\ldots,z_{j}\\}\\) by \\(Z_{ij}\\).\n\nThe next lemma characterizes when two elements are compared.\n\n_Lemma 7.2_\n\nDuring the execution of Randomized-Quicksort on an array of \\(n\\) distinct elements \\(z_{1}<z_{2}<\\cdots<z_{n}\\), an element \\(z_{i}\\) is compared with an element \\(z_{j}\\), where \\(i<j\\), if and only if one of them is chosen as a pivot before any other element in the set \\(Z_{ij}\\). Moreover, no two elements are ever compared twice.\n\n_Proof_ Let's look at the first time that an element \\(x\\in Z_{ij}\\) is chosen as a pivot during the execution of the algorithm. There are three cases to consider. If \\(x\\) is neither \\(z_{i}\\) nor \\(z_{j}\\) --that is, \\(z_{i}<x<z_{j}\\) --then \\(z_{i}\\) and \\(z_{j}\\) are not compared at any subsequent time, because they fall into different sides of the partition around \\(x\\). If \\(x=z_{i}\\), then Partition compares \\(z_{i}\\) with every other item in \\(Z_{ij}\\). Similarly, if \\(x=z_{j}\\), then Partition compares \\(z_{j}\\) with every other item in \\(Z_{ij}\\). Thus, \\(z_{i}\\) and \\(z_{j}\\) are compared if and only if the first element to be chosen as a pivot from \\(Z_{ij}\\) is either \\(z_{i}\\) or \\(z_{j}\\). In the latter two cases, where one of \\(z_{i}\\) and \\(z_{j}\\) is chosen as a pivot, since the pivot is removed from future comparisons, it is never compared again with the other element.\n\nAs an example of this lemma, consider an input to quicksort of the numbers 1 through 10 in some arbitrary order. Suppose that the first pivot element is 7. Then the first call to Partition separates the numbers into two sets: \\(\\{1,2,3,4,5,6\\}\\) and \\(\\{8,9,10\\}\\). In the process, the pivot element 7 is compared with all other elements, but no number from the first set (e.g., 2) is or ever will be compared with any number from the second set (e.g., 9). The values 7 and 9 are compared because 7 is the first item from \\(Z_{7,9}\\) to be chosen as a pivot. In contrast, 2 and 9 are never compared because the first pivot element chosen from \\(Z_{2,9}\\) is 7.\n\nThe next lemma gives the probability that two elements are compared.\n\n**Lemma 7.3**: _Consider an execution of the procedure Randomized-Quicksort on an array of \\(n\\) distinct elements \\(z_{1}<z_{2}<\\cdots<z_{n}\\). Given two arbitrary elements \\(z_{i}\\) and \\(z_{j}\\) where \\(i\\,<j\\), the probability that they are compared is \\(2/(j\\,-\\,i\\,+\\,1)\\)._\n\nLet's look at the tree of recursive calls that Randomized-Quicksort makes, and consider the sets of elements provided as input to each call. Initially, the root set contains all the elements of \\(Z_{ij}\\), since the root set contains every element in \\(A\\). The elements belonging to \\(Z_{ij}\\) all stay together for each recursive call of Randomized-Quicksort until Partition chooses some element \\(x\\in Z_{ij}\\) as a pivot. From that point on, the pivot \\(x\\) appears in no subsequent input set. The first time that Randomized-Select chooses a pivot \\(x\\in Z_{ij}\\) from a set containing all the elements of \\(Z_{ij}\\), each element in \\(Z_{ij}\\) is equally likely to be \\(x\\) because the pivot is chosen uniformly at random. Since \\(|Z_{ij}|=j\\,-\\,i\\,+\\,1\\), the probability is \\(1/(j\\,-\\,i\\,+\\,1)\\) that any given element in \\(Z_{ij}\\) is the first pivot chosen from \\(Z_{ij}\\). Thus, by Lemma 7.2, we have\n\n\\[\\Pr\\left\\{z_{i}\\text{ is compared with }z_{j}\\right\\} \\!\\!\\!= \\Pr\\left\\{z_{i}\\text{ or }z_{j}\\text{ is the first pivot chosen from }Z_{ij}\\right\\}\\] \\[\\!\\!\\!= \\Pr\\left\\{z_{i}\\text{ is the first pivot chosen from }Z_{ij}\\right\\}\\] \\[\\!\\!\\!\\!+\\Pr\\left\\{z_{j}\\text{ is the first pivot chosen from }Z_{ij}\\right\\}\\] \\[\\!\\!\\!= \\frac{2}{j\\,-\\,i\\,+\\,1}\\,\\]\n\nwhere the second line follows from the first because the two events are mutually exclusive.\n\nWe can now complete the analysis of randomized quicksort.\n\n**Theorem 7.4**: _The expected running time of Randomized-Quicksort on an input of \\(n\\) distinct elements is \\(O(n\\lg n)\\)._\n\n_Proof_The analysis uses indicator random variables (see Section 5.2). Let the \\(n\\) distinct elements be \\(z_{1}<z_{2}<\\cdots<z_{n}\\), and for \\(1\\leq i<j\\leq n\\), define the indicator random variable \\(X_{ij}=\\mbox{I}\\left\\{z_{i}\\mbox{ is compared with }z_{j}\\right\\}\\). From Lemma 7.2, each pair is compared at most once, and so we can express \\(X\\) as follows:\n\n\\[X=\\sum_{i=1}^{n-1}\\sum_{j=i+1}^{n}X_{ij}\\.\\]\n\nBy taking expectations of both sides and using linearity of expectation (equation (C.24) on page 1192) and Lemma 5.1 on page 130, we obtain\n\n\\[\\mbox{E}\\left[X\\right] = \\mbox{E}\\left[\\sum_{i=1}^{n-1}\\sum_{j=i+1}^{n}X_{ij}\\right]\\] \\[= \\sum_{i=1}^{n-1}\\sum_{j=i+1}^{n}\\mbox{E}\\left[X_{ij}\\right]\\] (by linearity of expectation) \\[= \\sum_{i=1}^{n-1}\\sum_{j=i+1}^{n}\\mbox{Pr}\\left\\{z_{i}\\mbox{ is compared with }z_{j}\\right\\}\\] (by Lemma 5.1) \\[= \\sum_{i=1}^{n-1}\\sum_{j=i+1}^{n}\\frac{2}{j-i+1}\\] (by Lemma 7.3).\n\nWe can evaluate this sum using a change of variables (\\(k=j-i\\)) and the bound on the harmonic series in equation (A.9) on page 1142:\n\n\\[\\mbox{E}\\left[X\\right] = \\sum_{i=1}^{n-1}\\sum_{j=i+1}^{n}\\frac{2}{j-i+1}\\] \\[= \\sum_{i=1}^{n-1}\\sum_{k=1}^{n-i}\\frac{2}{k+1}\\] \\[< \\sum_{i=1}^{n-1}\\sum_{k=1}^{n}\\frac{2}{k}\\] \\[= \\sum_{i=1}^{n-1}O(\\lg n)\\] \\[= O(n\\lg n)\\.\\]This bound and Lemma 7.1 allow us to conclude that the expected running time of Randomized-Quicksort is \\(O(n\\lg n)\\) (assuming that the element values are distinct).\n\n### Exercises\n\n#### 7.4-1\n\nShow that the recurrence\n\n\\[T(n)=\\max\\left\\{T(q)+T(n-q-1):0\\leq q\\leq n-1\\right\\}+\\Theta(n)\\]\n\nhas a lower bound of \\(T(n)=\\Omega(n^{2})\\).\n\n#### 7.4-2\n\nShow that quicksort's best-case running time is \\(\\Omega(n\\lg n)\\).\n\n#### 7.4-3\n\nShow that the expression \\(q^{2}+(n-q-1)^{2}\\) achieves its maximum value over \\(q=0,1,\\ldots,n-1\\) when \\(q=0\\) or \\(q=n-1\\).\n\n#### 7.4-4\n\nShow that Randomized-Quicksort's expected running time is \\(\\Omega(n\\lg n)\\).\n\n#### 7.4-5\n\nCoarsening the recursion, as we did in Problem 2-1 for merge sort, is a common way to improve the running time of quicksort in practice. We modify the base case of the recursion so that if the array has fewer than \\(k\\) elements, the subarray is sorted by insertion sort, rather than by continued recursive calls to quicksort. Argue that the randomized version of this sorting algorithm runs in \\(O(n\\,k+n\\lg(n/k))\\) expected time. How should you pick \\(k\\), both in theory and in practice?\n\n* _7.4-6_ Consider modifying the Partition procedure by randomly picking three elements from subarray \\(A[p:r]\\) and partitioning about their median (the middle value of the three elements). Approximate the probability of getting worse than an \\(\\alpha\\)-to-\\((1-\\alpha)\\) split, as a function of \\(\\alpha\\) in the range \\(0<\\alpha<1/2\\).\n\n## Problems\n\n### 7.1 Hoare partition correctness\n\nThe version of Partition given in this chapter is not the original partitioning algorithm. Here is the original partitioning algorithm, which is due to C. A. R. Hoare.\n\n1. \\(x\\,=\\,A[p]\\)\n2. \\(i\\,=\\,p-1\\)\n3. \\(j\\,=\\,r+1\\)\n4. **while** true\n5. **repeat**\n6. \\(j\\,=\\,j-1\\)\n7. **until**\\(A[j]\\leq x\\)\n8. **repeat**\n9. \\(i\\,=\\,i+1\\)\n10. **until**\\(A[i]\\geq x\\)\n11. **if**\\(i\\,<\\,j\\)\n12. **exchange**\\(A[i]\\) **with**\\(A[j]\\)\n13. **else return**\\(j\\)\n\n### 1.1.\n\nDemonstrate the operation of Hoare-Partition on the array \\(A=\\langle 13,\\,19,\\) 9, 5, 12, 8, 7, 4, 11, 2, 6, 21\\(\\rangle\\), showing the values of the array and the indices \\(i\\) and \\(j\\) after each iteration of the **while** loop in lines 4-13.\n\n### 1.2.\n\nDescribe how the Partition procedure in Section 7.1 differs from Hoare-Partition when all elements in \\(A[p:r]\\) are equal. Describe a practical advantage of Hoare-Partition over Partition for use in quicksort.\n\nThe next three questions ask you to give a careful argument that the procedure Hoare-Partition is correct. Assuming that the subarray \\(A[p:r]\\) contains at least two elements, prove the following:\n\n1. **The indices \\(i\\) and \\(j\\) are such that the procedure never accesses an element of \\(A\\) outside the subarray \\(A[p:r]\\).\n2. **When Hoare-Partition terminates, it returns a value \\(j\\) such that \\(p\\,\\leq\\,j\\,<\\,r\\).\n3. Every element of \\(A[p:j]\\) is less than or equal to every element of \\(A[j\\,+\\,1:r]\\) when Hoare-Partition terminates.",
        "chapter": "Part II Sorting and Order Statistics",
        "section": "7 Quicksort",
        "subsection": "7.4 Analysis of quicksort",
        "subsubsection": "N/A"
    },
    {
        "content": "## Problems\n\n### 7.1 Hoare partition correctness\n\nThe version of Partition given in this chapter is not the original partitioning algorithm. Here is the original partitioning algorithm, which is due to C. A. R. Hoare.\n\n1. [label=]\n2. \\(x\\,=\\,A[p]\\)\n3. \\(i\\,=\\,p-1\\)\n4. \\(j\\,=\\,r+1\\)\n5. **while** true\n6. \\(j\\,=\\,j-1\\)\n7. **until**\\(A[j]\\leq x\\)\n8. **repeat**\n9. \\(i\\,=\\,i+1\\)\n10. **until**\\(A[i]\\geq x\\)\n11. **if**\\(i\\,<\\,j\\)\n12. **exchange**\\(A[i]\\) **with**\\(A[j]\\)\n13. **else** return**\\(j\\)\n\n### 1.1.\n\nDemonstrate the operation of Hoare-Partition on the array \\(A=\\langle 13,\\,19,\\) 9, 5, 12, 8, 7, 4, 11, 2, 6, 21\\(\\rangle\\), showing the values of the array and the indices \\(i\\) and \\(j\\) after each iteration of the **while** loop in lines 4-13.\n\n### 1.2.\n\nDescribe how the Partition procedure in Section 7.1 differs from Hoare-Partition when all elements in \\(A[p:r]\\) are equal. Describe a practical advantage of Hoare-Partition over Partition for use in quicksort.\n\nThe next three questions ask you to give a careful argument that the procedure Hoare-Partition is correct. Assuming that the subarray \\(A[p:r]\\) contains at least two elements, prove the following:\n\n1. [label=]\n2. The indices \\(i\\) and \\(j\\) are such that the procedure never accesses an element of \\(A\\) outside the subarray \\(A[p:r]\\).\n3. When Hoare-Partition terminates, it returns a value \\(j\\) such that \\(p\\,\\leq\\,j\\,<\\,r\\).\n4. Every element of \\(A[p:j]\\) is less than or equal to every element of \\(A[j\\,+\\,1:r]\\) when Hoare-Partition terminates.\n\nThe Partition procedure in Section 7.1 separates the pivot value (originally in \\(A[r]\\)) from the two partitions it forms. The Hoare-Partition procedure, on the other hand, always places the pivot value (originally in \\(A[p]\\)) into one of the two partitions \\(A[p:j]\\) and \\(A[j+1:r]\\). Since \\(p\\leq j<r\\), neither partition is empty.\n\n_f._ Rewrite the Quicksort procedure to use Hoare-Partition.\n\n#### 7.2 Quicksort with equal element values\n\nThe analysis of the expected running time of randomized quicksort in Section 7.4.2 assumes that all element values are distinct. This problem examines what happens when they are not.\n\n_a._ Suppose that all element values are equal. What is randomized quicksort's running time in this case?\n\n_b._ The Partition procedure returns an index \\(q\\) such that each element of \\(A[p:q-1]\\) is less than or equal to \\(A[q]\\) and each element of \\(A[q+1:r]\\) is greater than \\(A[q]\\). Modify the Partition procedure to produce a procedure Partition\\({}^{\\prime}(A,\\,p,r)\\), which permutes the elements of \\(A[p:r]\\) and returns two indices \\(q\\) and \\(t\\), where \\(p\\leq q\\leq t\\leq r\\), such that\n\nall elements of \\(A[q:t]\\) are equal,\n\neach element of \\(A[p:q-1]\\) is less than \\(A[q]\\), and\n\neach element of \\(A[t+1:r]\\) is greater than \\(A[q]\\).\n\nLike Partition, your Partition\\({}^{\\prime}\\) procedure should take \\(\\Theta(r-p)\\) time.\n\n_c._ Modify the Randomized-Partition procedure to call Partition\\({}^{\\prime}\\), and name the new procedure Randomized-Partition\\({}^{\\prime}\\). Then modify the Quicksort procedure to produce a procedure Quicksort\\({}^{\\prime}(A,\\,p,r)\\) that calls Randomized-Partition\\({}^{\\prime}\\) and recurses only on partitions where elements are not known to be equal to each other.\n\n_d._ Using Quicksort\\({}^{\\prime}\\), adjust the analysis in Section 7.4.2 to avoid the assumption that all elements are distinct.\n\n#### 7.3 Alternative quicksort analysis\n\nAn alternative analysis of the running time of randomized quicksort focuses on the expected running time of each individual recursive call to Randomized-Quicksort, rather than on the number of comparisons performed. As in the analysis of Section 7.4.2, assume that the values of the elements are distinct.\n\n_a._ Argue that, given an array of size \\(n\\), the probability that any particular element is chosen as the pivot is \\(1/n\\). Use this probability to define indicator random variables \\(X_{i}=\\mathrm{I}\\left\\{i\\,\\mathrm{th}\\;\\mathrm{smallest}\\;\\mathrm{element}\\; \\mathrm{is}\\;\\mathrm{chosen}\\;\\mathrm{as}\\;\\mathrm{the}\\;\\mathrm{pivot}\\right\\}\\). What is \\(\\mathrm{E}\\left[X_{i}\\right]\\)?\n\n_b._ Let \\(T(n)\\) be a random variable denoting the running time of quicksort on an array of size \\(n\\). Argue that\n\n\\[\\mathrm{E}\\left[T(n)\\right]=\\mathrm{E}\\left[\\sum_{q=1}^{n}X_{q}\\;\\left(T(q-1) +T(n-q)+\\Theta(n)\\right)\\right]\\,. \\tag{7.2}\\]\n\n_c._ Show how to rewrite equation (7.2) as\n\n\\[\\mathrm{E}\\left[T(n)\\right]=\\frac{2}{n}\\sum_{q=1}^{n-1}\\mathrm{E}\\left[T(q) \\right]+\\Theta(n)\\,. \\tag{7.3}\\]\n\n_d._ Show that\n\n\\[\\sum_{q=1}^{n-1}q\\lg q\\,\\leq\\frac{n^{2}}{2}\\lg n-\\frac{n^{2}}{8} \\tag{7.4}\\]\n\nfor \\(n\\geq 2\\). (_Hint:_ Split the summation into two parts, one summation for \\(q=1,2,\\ldots,\\lceil n/2\\rceil-1\\) and one summation for \\(q=\\lceil n/2\\rceil,\\ldots,n-1\\).)\n\n_e._ Using the bound from equation (7.4), show that the recurrence in equation (7.3) has the solution \\(\\mathrm{E}\\left[T(n)\\right]=O(n\\lg n)\\). (_Hint:_ Show, by substitution, that \\(\\mathrm{E}\\left[T(n)\\right]\\leq a\\lg n\\) for sufficiently large \\(n\\) and for some positive constant \\(a\\).)\n\n_7-4 Stooge sort_\n\nProfessors Howard, Fine, and Howard have proposed a deceptively simple sorting algorithm, named stooge sort in their honor, appearing on the following page.\n\n_a._ Argue that the call Stooge-Sort\\((A,1,n)\\) correctly sorts the array \\(A[1:n]\\).\n\n_b._ Give a recurrence for the worst-case running time of Stooge-Sort and a tight asymptotic (\\(\\Theta\\)-notation) bound on the worst-case running time.\n\n_c._ Compare the worst-case running time of Stooge-Sort with that of insertion sort, merge sort, heapsort, and quicksort. Do the professors deserve tenure?\n#### 7.5.1 Stack depth for quicksort\n\nThe Quicksort procedure of Section 7.1 makes two recursive calls to itself. After Quicksort calls Partition, it recursively sorts the low side of the partition and then it recursively sorts the high side of the partition. The second recursive call in Quicksort is not really necessary, because the procedure can instead use an iterative control structure. This transformation technique, called _tail-recursion elimination_, is provided automatically by good compilers. Applying tail-recursion elimination transforms Quicksort into the TRE-Quicksort procedure.\n\n\\begin{tabular}{l l} TRE-Quicksort(\\(A\\), \\(p\\), \\(r\\)) \\\\\n1 & **while**\\(p<r\\) \\\\\n2 & // Partition and then sort the low side. \\\\\n3 & \\(q=\\) Partition(\\(A\\), \\(p\\), \\(r\\)) \\\\\n4 & TRE-Quicksort(\\(A\\), \\(p\\), \\(q-1\\)) \\\\\n5 & \\(p\\,=\\,q\\,+\\,1\\) \\\\ \\end{tabular}\n\nArgue that TRE-Quicksort(\\(A\\), \\(1\\), \\(n\\)) correctly sorts the array \\(A[1\\) : \\(n]\\).\n\nCompilers usually execute recursive procedures by using a _stack_ that contains pertinent information, including the parameter values, for each recursive call. The information for the most recent call is at the top of the stack, and the information for the initial call is at the bottom. When a procedure is called, its information is _pushed_ onto the stack, and when it terminates, its information is _popped_. Since we assume that array parameters are represented by pointers, the information for each procedure call on the stack requires \\(\\,O(1)\\) stack space. The _stack depth_ is the maximum amount of stack space used at any time during a computation.\n\nDescribe a scenario in which TRE-Quicksort's stack depth is \\(\\Theta(n)\\) on an \\(n\\)-element input array.\n\n_c._ Modify TRE-Quicksort so that the worst-case stack depth is \\(\\Theta(\\lg n)\\). Maintain the \\(O(n\\lg n)\\) expected running time of the algorithm.\n\n### Median-of-3 partition\n\nOne way to improve the Randomized-Quicksort procedure is to partition around a pivot that is chosen more carefully than by picking a random element from the subarray. A common approach is the _median-of-3_ method: choose the pivot as the median (middle element) of a set of 3 elements randomly selected from the subarray. (See Exercise 7.4-6.) For this problem, assume that the \\(n\\) elements in the input subarray \\(A[p:r]\\) are distinct and that \\(n\\geq 3\\). Denote the sorted version of \\(A[p:r]\\) by \\(z_{1},z_{2},\\ldots,z_{n}\\). Using the median-of-3 method to choose the pivot element \\(x\\), define \\(p_{i}=\\Pr\\left\\{x=z_{i}\\right\\}\\).\n\n_a._ Give an exact formula for \\(p_{i}\\) as a function of \\(n\\) and \\(i\\) for \\(i=2,3,\\ldots,n-1\\). (Observe that \\(p_{1}=p_{n}=0\\).) _b._ By what amount does the median-of-3 method increase the likelihood of choosing the pivot to be \\(x=z_{\\lfloor(n+1)/2\\rfloor}\\), the median of \\(A[p:r]\\), compared with the ordinary implementation? Assume that \\(n\\to\\infty\\), and give the limiting ratio of these probabilities. _c._ Suppose that we define a \"good\" split to mean choosing the pivot as \\(x=z_{i}\\), where \\(n/3\\leq i\\leq 2n/3\\). By what amount does the median-of-3 method increase the likelihood of getting a good split compared with the ordinary implementation? (_Hint:_ Approximate the sum by an integral.) _d._ Argue that in the \\(\\Omega(n\\lg n)\\) running time of quicksort, the median-of-3 method affects only the constant factor.\n\n### Fuzzy sorting of intervals\n\nConsider a sorting problem in which you do not know the numbers exactly. Instead, for each number, you know an interval on the real line to which it belongs. That is, you are given \\(n\\) closed intervals of the form \\([a_{i},b_{i}]\\), where \\(a_{i}\\leq b_{i}\\). The goal is to _fuzzy-sort_ these intervals: to produce a permutation \\(\\left\\langle i_{1},\\,i_{2},\\,\\ldots,\\,i_{n}\\right\\rangle\\) of the intervals such that for \\(j=1,2,\\ldots,n\\), there exist \\(c_{j}\\in[a_{i_{j}},b_{i_{j}}]\\) satisfying \\(c_{1}\\leq c_{2}\\leq\\cdots\\leq c_{n}\\).\n\n_a._ Design a randomized algorithm for fuzzy-sorting \\(n\\) intervals. Your algorithm should have the general structure of an algorithm that quicksorts the left endpoints (the \\(a_{i}\\) values), but it should take advantage of overlapping intervals to improve the running time. (As the intervals overlap more and more, the prob lem of fuzzy-sorting the intervals becomes progressively easier. Your algorithm should take advantage of such overlapping, to the extent that it exists.) _b._ Argue that your algorithm runs in \\(\\Theta(n\\lg n)\\) expected time in general, but runs in \\(\\Theta(n)\\) expected time when all of the intervals overlap (i.e., when there exists a value \\(x\\) such that \\(x\\in[a_{i},b_{i}]\\) for all \\(i\\)). Your algorithm should not be checking for this case explicitly, but rather, its performance should naturally improve as the amount of overlap increases.\n\n## Chapter notes\n\nQuicksort was invented by Hoare [219], and his version of Partition appears in Problem 7-1. Bentley [51, p. 117] attributes the Partition procedure given in Section 7.1 to N. Lomuto. The analysis in Section 7.4 based on an analysis due to Motwani and Raghavan [336]. Sedgewick [401] and Bentley [51] provide good references on the details of implementation and how they matter.\n\nMcIlroy [323] shows how to engineer a \"killer adversary\" that produces an array on which virtually any implementation of quicksort takes \\(\\Theta(n^{2})\\) time.",
        "chapter": "Part II Sorting and Order Statistics",
        "section": "7 Quicksort",
        "subsection": "Problems",
        "subsubsection": "N/A"
    },
    {
        "content": "lem of fuzzy-sorting the intervals becomes progressively easier. Your algorithm should take advantage of such overlapping, to the extent that it exists.) _b._ Argue that your algorithm runs in \\(\\Theta(n\\lg n)\\) expected time in general, but runs in \\(\\Theta(n)\\) expected time when all of the intervals overlap (i.e., when there exists a value \\(x\\) such that \\(x\\in[a_{i},b_{i}]\\) for all \\(i\\)). Your algorithm should not be checking for this case explicitly, but rather, its performance should naturally improve as the amount of overlap increases.\n\n## Chapter notes\n\nQuicksort was invented by Hoare [219], and his version of Partition appears in Problem 7-1. Bentley [51, p. 117] attributes the Partition procedure given in Section 7.1 to N. Lomuto. The analysis in Section 7.4 based on an analysis due to Motwani and Raghavan [336]. Sedgewick [401] and Bentley [51] provide good references on the details of implementation and how they matter.\n\nMcIlroy [323] shows how to engineer a \"killer adversary\" that produces an array on which virtually any implementation of quicksort takes \\(\\Theta(n^{2})\\) time.\n\n## 8 Sorting in Linear Time\n\nWe have now seen a handful of algorithms that can sort \\(n\\) numbers in \\(O(n\\lg n)\\) time. Whereas merge sort and heapsort achieve this upper bound in the worst case, quicksort achieves it on average. Moreover, for each of these algorithms, we can produce a sequence of \\(n\\) input numbers that causes the algorithm to run in \\(\\Omega(n\\lg n)\\) time.\n\nThese algorithms share an interesting property: _the sorted order they determine is based only on comparisons between the input elements_. We call such sorting algorithms _comparison sorts_. All the sorting algorithms introduced thus far are comparison sorts.\n\nIn Section 8.1, we'll prove that any comparison sort must make \\(\\Omega(n\\lg n)\\) comparisons in the worst case to sort \\(n\\) elements. Thus, merge sort and heapsort are asymptotically optimal, and no comparison sort exists that is faster by more than a constant factor.\n\nSections 8.2, 8.3, and 8.4 examine three sorting algorithms --counting sort, radix sort, and bucket sort--that run in linear time on certain types of inputs. Of course, these algorithms use operations other than comparisons to determine the sorted order. Consequently, the \\(\\Omega(n\\lg n)\\) lower bound does not apply to them.\n\n### Lower bounds for sorting\n\nA comparison sort uses only comparisons between elements to gain order information about an input sequence \\(\\langle a_{1},a_{2},\\ldots,a_{n}\\rangle\\). That is, given two elements \\(a_{i}\\) and \\(a_{j}\\), it performs one of the tests \\(a_{i}<a_{j},a_{i}\\leq a_{j},a_{i}=a_{j},a_{i}\\geq a_{j},\\) or \\(a_{i}>a_{j}\\) to determine their relative order. It may not inspect the values of the elements or gain order information about them in any other way.\n\nSince we are proving a lower bound, we assume without loss of generality in this section that all the input elements are distinct. After all, a lower bound for distinct elements applies when elements may or may not be distinct. Consequently,",
        "chapter": "Part II Sorting and Order Statistics",
        "section": "7 Quicksort",
        "subsection": "Chapter notes",
        "subsubsection": "N/A"
    },
    {
        "content": "## 8 Sorting in Linear Time\n\nWe have now seen a handful of algorithms that can sort \\(n\\) numbers in \\(O(n\\lg n)\\) time. Whereas merge sort and heapsort achieve this upper bound in the worst case, quicksort achieves it on average. Moreover, for each of these algorithms, we can produce a sequence of \\(n\\) input numbers that causes the algorithm to run in \\(\\Omega(n\\lg n)\\) time.\n\nThese algorithms share an interesting property: _the sorted order they determine is based only on comparisons between the input elements_. We call such sorting algorithms _comparison sorts_. All the sorting algorithms introduced thus far are comparison sorts.\n\nIn Section 8.1, we'll prove that any comparison sort must make \\(\\Omega(n\\lg n)\\) comparisons in the worst case to sort \\(n\\) elements. Thus, merge sort and heapsort are asymptotically optimal, and no comparison sort exists that is faster by more than a constant factor.\n\nSections 8.2, 8.3, and 8.4 examine three sorting algorithms --counting sort, radix sort, and bucket sort--that run in linear time on certain types of inputs. Of course, these algorithms use operations other than comparisons to determine the sorted order. Consequently, the \\(\\Omega(n\\lg n)\\) lower bound does not apply to them.\n\n### Lower bounds for sorting\n\nA comparison sort uses only comparisons between elements to gain order information about an input sequence \\(\\langle a_{1},a_{2},\\ldots,a_{n}\\rangle\\). That is, given two elements \\(a_{i}\\) and \\(a_{j}\\), it performs one of the tests \\(a_{i}<a_{j},a_{i}\\leq a_{j},a_{i}=a_{j},a_{i}\\geq a_{j},\\) or \\(a_{i}>a_{j}\\) to determine their relative order. It may not inspect the values of the elements or gain order information about them in any other way.\n\nSince we are proving a lower bound, we assume without loss of generality in this section that all the input elements are distinct. After all, a lower bound for distinct elements applies when elements may or may not be distinct. Consequently,comparisons of the form \\(a_{i}=a_{j}\\) are useless, which means that we can assume that no comparisons for exact equality occur. Moreover, the comparisons \\(a_{i}\\leq a_{j}\\), \\(a_{i}\\geq a_{j}\\), \\(a_{i}>a_{j}\\), and \\(a_{i}<a_{j}\\) are all equivalent in that they yield identical information about the relative order of \\(a_{i}\\) and \\(a_{j}\\). We therefore assume that all comparisons have the form \\(a_{i}\\leq a_{j}\\).\n\n### The decision-tree model\n\nWe can view comparison sorts abstractly in terms of decision trees. A _decision tree_ is a full binary tree (each node is either a leaf or has both children) that represents the comparisons between elements that are performed by a particular sorting algorithm operating on an input of a given size. Control, data movement, and all other aspects of the algorithm are ignored. Figure 8.1 shows the decision tree corresponding to the insertion sort algorithm from Section 2.1 operating on an input sequence of three elements.\n\nA decision tree has each internal node annotated by \\(i\\!:\\!j\\) for some \\(i\\) and \\(j\\) in the range \\(1\\leq i,j\\leq n\\), where \\(n\\) is the number of elements in the input sequence. We also annotate each leaf by a permutation \\(\\langle\\pi(1),\\pi(2),\\pi(n)\\qquad\\rangle\\). (See Section C.1 for background on permutations.) Indices in the internal nodes and the leaves always refer to the original positions of the array elements at the start of the sorting algorithm. The execution of the comparison sorting algorithm corresponds to tracing a simple path from the root of the decision tree down to a leaf. Each internal node indicates a comparison \\(a_{i}\\leq a_{j}\\). The left subtree then dictates sub\n\nFigure 8.1: The decision tree for insertion sort operating on three elements. An internal node (shown in blue) annotated by \\(i\\!:\\!j\\) indicates a comparison between \\(a_{i}\\) and \\(a_{j}\\). A leaf annotated by the permutation \\(\\langle\\pi(1),\\pi(2),\\pi(n)\\qquad\\rangle\\) indicates the ordering \\(a_{\\pi(1)}\\leq a_{\\pi(2)}\\leq\\cdots\\leq a_{\\pi(n)}\\). The highlighted path indicates the decisions made when sorting the input sequence \\(\\langle a_{1}=6,a_{2}=8,a_{3}=5\\rangle\\). Going left from the root node, labeled 1:2, indicates that \\(a_{1}\\leq a_{2}\\). Going right from the node labeled 2:3 indicates that \\(a_{2}>a_{3}\\). Going right from the node labeled 1:3 indicates that \\(a_{1}>a_{3}\\). Therefore, we have the ordering \\(a_{3}\\leq a_{1}\\leq a_{2}\\), as indicated in the leaf labeled \\(\\langle 3,1,2\\rangle\\). Because the three input elements have \\(3!=6\\) possible permutations, the decision tree must have at least 6 leaves.\n\nsequent comparisons once we know that \\(a_{i}\\leq a_{j}\\), and the right subtree dictates subsequent comparisons when \\(a_{i}>a_{j}\\). Arriving at a leaf, the sorting algorithm has established the ordering \\(a_{\\pi(1)}\\leq a_{\\pi(2)}\\leq\\cdots\\leq a_{\\pi(n)}\\). Because any correct sorting algorithm must be able to produce each permutation of its input, each of the \\(n!\\) permutations on \\(n\\) elements must appear as at least one of the leaves of the decision tree for a comparison sort to be correct. Furthermore, each of these leaves must be reachable from the root by a downward path corresponding to an actual execution of the comparison sort. (We call such leaves \"reachable.\") Thus, we consider only decision trees in which each permutation appears as a reachable leaf.\n\n##### A lower bound for the worst case\n\nThe length of the longest simple path from the root of a decision tree to any of its reachable leaves represents the worst-case number of comparisons that the corresponding sorting algorithm performs. Consequently, the worst-case number of comparisons for a given comparison sort algorithm equals the height of its decision tree. A lower bound on the heights of all decision trees in which each permutation appears as a reachable leaf is therefore a lower bound on the running time of any comparison sort algorithm. The following theorem establishes such a lower bound.\n\n**Theorem 8.1**: _Any comparison sort algorithm requires \\(\\Omega(n\\lg n)\\) comparisons in the worst case._\n\nProofFrom the preceding discussion, it suffices to determine the height of a decision tree in which each permutation appears as a reachable leaf. Consider a decision tree of height \\(h\\) with \\(l\\) reachable leaves corresponding to a comparison sort on \\(n\\) elements. Because each of the \\(n!\\) permutations of the input appears as one or more leaves, we have \\(n!\\leq l\\). Since a binary tree of height \\(h\\) has no more than \\(2^{h}\\) leaves, we have\n\n\\[n!\\leq l\\leq 2^{h}\\,\\]\n\nwhich, by taking logarithms, implies\n\n\\[h \\geq \\lg(n!)\\qquad\\mbox{(since the $\\lg$ function is monotonically increasing)}\\] \\[= \\Omega(n\\lg n)\\quad\\mbox{(by equation (\\ref{eq:h-1}) on page \\ref{eq:h-1})}\\.\\]\n\n**Corollary 8.2**: _Heapsort and merge sort are asymptotically optimal comparison sorts._\n\nProofThe \\(O(n\\lg n)\\) upper bounds on the running times for heapsort and merge sort match the \\(\\Omega(n\\lg n)\\) worst-case lower bound from Theorem 8.1.\n\n### Exercises\n\n#### 8.1-1\n\nWhat is the smallest possible depth of a leaf in a decision tree for a comparison sort?\n\n#### 8.1-2\n\nObtain asymptotically tight bounds on \\(\\lg(n!)\\) without using Stirling's approximation. Instead, evaluate the summation \\(\\sum_{k=1}^{n}\\lg k\\) using techniques from Section A.2.\n\n#### 8.1-3\n\nShow that there is no comparison sort whose running time is linear for at least half of the \\(n!\\) inputs of length \\(n\\). What about a fraction of \\(1/n\\) of the inputs of length \\(n\\)? What about a fraction \\(1/2^{n}\\)?\n\n#### 8.1-4\n\nYou are given an \\(n\\)-element input sequence, and you know in advance that it is partly sorted in the following sense. Each element initially in position \\(i\\) such that \\(i\\)\\(\\bmod\\)\\(4=0\\) is either already in its correct position, or it is one place away from its correct position. For example, you know that after sorting, the element initially in position 12 belongs in position 11, 12, or 13. You have no advance information about the other elements, in positions \\(i\\) where \\(i\\)\\(\\bmod\\)\\(4\\neq 0\\). Show that an \\(\\Omega(n\\lg n)\\) lower bound on comparison-based sorting still holds in this case.\n\n### Counting sort\n\n_Counting sort_ assumes that each of the \\(n\\) input elements is an integer in the range 0 to \\(k\\), for some integer \\(k\\). It runs in \\(\\Theta(n+k)\\) time, so that when \\(k=O(n)\\), counting sort runs in \\(\\Theta(n)\\) time.\n\nCounting sort first determines, for each input element \\(x\\), the number of elements less than or equal to \\(x\\). It then uses this information to place element \\(x\\) directly into its position in the output array. For example, if 17 elements are less than or equal to \\(x\\), then \\(x\\) belongs in output position 17. We must modify this scheme slightly to handle the situation in which several elements have the same value, since we do not want them all to end up in the same position.\n\nThe Counting-Sort procedure on the facing page takes as input an array \\(A[1:n]\\), the size \\(n\\) of this array, and the limit \\(k\\) on the nonnegative integer values in \\(A\\). It returns its sorted output in the array \\(B[1:n]\\) and uses an array \\(C[0:k]\\) for temporary working storage.",
        "chapter": "Part II Sorting and Order Statistics",
        "section": "8 Sorting in Linear Time",
        "subsection": "8.1 Lower bounds for sorting",
        "subsubsection": "N/A"
    },
    {
        "content": "### Exercises\n\n#### 8.1-1\n\nWhat is the smallest possible depth of a leaf in a decision tree for a comparison sort?\n\n#### 8.1-2\n\nObtain asymptotically tight bounds on \\(\\lg(n!)\\) without using Stirling's approximation. Instead, evaluate the summation \\(\\sum_{k=1}^{n}\\lg k\\) using techniques from Section A.2.\n\n#### 8.1-3\n\nShow that there is no comparison sort whose running time is linear for at least half of the \\(n!\\) inputs of length \\(n\\). What about a fraction of \\(1/n\\) of the inputs of length \\(n\\)? What about a fraction \\(1/2^{n}\\)?\n\n#### 8.1-4\n\nYou are given an \\(n\\)-element input sequence, and you know in advance that it is partly sorted in the following sense. Each element initially in position \\(i\\) such that \\(i\\)\\(\\bmod\\)\\(4=0\\) is either already in its correct position, or it is one place away from its correct position. For example, you know that after sorting, the element initially in position 12 belongs in position 11, 12, or 13. You have no advance information about the other elements, in positions \\(i\\) where \\(i\\)\\(\\bmod\\)\\(4\\neq 0\\). Show that an \\(\\Omega(n\\lg n)\\) lower bound on comparison-based sorting still holds in this case.\n\n### Counting sort\n\n_Counting sort_ assumes that each of the \\(n\\) input elements is an integer in the range 0 to \\(k\\), for some integer \\(k\\). It runs in \\(\\Theta(n+k)\\) time, so that when \\(k=O(n)\\), counting sort runs in \\(\\Theta(n)\\) time.\n\nCounting sort first determines, for each input element \\(x\\), the number of elements less than or equal to \\(x\\). It then uses this information to place element \\(x\\) directly into its position in the output array. For example, if 17 elements are less than or equal to \\(x\\), then \\(x\\) belongs in output position 17. We must modify this scheme slightly to handle the situation in which several elements have the same value, since we do not want them all to end up in the same position.\n\nThe Counting-Sort procedure on the facing page takes as input an array \\(A[1:n]\\), the size \\(n\\) of this array, and the limit \\(k\\) on the nonnegative integer values in \\(A\\). It returns its sorted output in the array \\(B[1:n]\\) and uses an array \\(C[0:k]\\) for temporary working storage.\n\nFigure 8.2 illustrates counting sort. After the **for** loop of lines 2-3 initializes the array \\(C\\) to all zeros, the **for** loop of lines 4-5 makes a pass over the array \\(A\\) to inspect each input element. Each time it finds an input element whose value is \\(i\\), it increments \\(C[i]\\). Thus, after line 5, \\(C[i]\\) holds the number of input elements equal to \\(i\\) for each integer \\(i=0,1,\\ldots,k\\). Lines 7-8 determine for each \\(i=0,1,\\ldots,k\\) how many input elements are less than or equal to \\(i\\) by keeping a running sum of the array \\(C\\).\n\nFinally, the **for** loop of lines 11-13 makes another pass over \\(A\\), but in reverse, to place each element \\(A[j]\\) into its correct sorted position in the output array \\(B\\). If all \\(n\\) elements are distinct, then when line 11 is first entered, for each \\(A[j]\\), the value \\(C[A[j]]\\) is the correct final position of \\(A[j]\\) in the output array, since there are \\(C[A[j]]\\) elements less than or equal to \\(A[j]\\). Because the elements might not be distinct, the loop decrements \\(C[A[j]]\\) each time it places a value \\(A[j]\\) into \\(B\\). Decrementing \\(C[A[j]]\\) causes the previous element in \\(A\\) with a value equal to \\(A[j]\\), if one exists, to go to the position immediately before \\(A[j]\\) in the output array \\(B\\).\n\nHow much time does counting sort require? The **for** loop of lines 2-3 takes \\(\\Theta(k)\\) time, the **for** loop of lines 4-5 takes \\(\\Theta(n)\\) time, the **for** loop of lines 7-8 takes \\(\\Theta(k)\\) time, and the **for** loop of lines 11-13 takes \\(\\Theta(n)\\) time. Thus, the overall time is \\(\\Theta(k+n)\\). In practice, we usually use counting sort when we have \\(k=O(n)\\), in which case the running time is \\(\\Theta(n)\\).\n\nCounting sort can beat the lower bound of \\(\\Omega(n\\lg n)\\) proved in Section 8.1 because it is not a comparison sort. In fact, no comparisons between input elements occur anywhere in the code. Instead, counting sort uses the actual values of the elements to index into an array. The \\(\\Omega(n\\lg n)\\) lower bound for sorting does not apply when we depart from the comparison sort model.\n\nAn important property of counting sort is that it is _stable_: elements with the same value appear in the output array in the same order as they do in the input array. That is, it breaks ties between two elements by the rule that whichever element appears first in the input array appears first in the output array. Normally, the property of stability is important only when satellite data are carried around with the element being sorted. Counting sort's stability is important for another reason: counting sort is often used as a subroutine in radix sort. As we shall see in the next section, in order for radix sort to work correctly, counting sort must be stable.\n\n##### Exercises\n\n##### 8.2-1\n\nUsing Figure 8.2 as a model, illustrate the operation of Counting-Sort on the array \\(A=\\langle 6,0,2,0,1,3,4,6,1,3,2\\rangle\\).\n\n##### 8.2-2\n\nProve that Counting-Sort is stable.\n\nFigure 8.2: The operation of Counting-Sort on an input array \\(A[1:8]\\), where each element of \\(A\\) is a nonnegative integer no larger than \\(k=5\\). **(a)** The array \\(A\\) and the auxiliary array \\(C\\) after line 5. **(b)** The array \\(C\\) after line 8. **(c)\u2013(e)** The output array \\(B\\) and the auxiliary array \\(C\\) after one, two, and three iterations of the loop in lines 11\u201313, respectively. Only the tan elements of array \\(B\\) have been filled in. **(f)** The final sorted output array \\(B\\).\n\n#### 8.2-3\n\nSuppose that we were to rewrite the **for** loop header in line 11 of the CountingSort as\n\n11 **for \\(j\\ =\\ 1\\) to \\(n\\)**\n\nShow that the algorithm still works properly, but that it is not stable. Then rewrite the pseudocode for counting sort so that elements with the same value are written into the output array in order of increasing index and the algorithm is stable.\n\n#### 8.2-4\n\nProve the following loop invariant for Counting-Sort:\n\nAt the start of each iteration of the **for** loop of lines 11-13, the last element in \\(A\\) with value \\(i\\) that has not yet been copied into \\(B\\) belongs in \\(B[C[i]]\\).\n\n#### 8.2-5\n\nSuppose that the array being sorted contains only integers in the range 0 to \\(k\\) and that there are no satellite data to move with those keys. Modify counting sort to use just the arrays \\(A\\) and \\(C\\), putting the sorted result back into array \\(A\\) instead of into a new array \\(B\\).\n\n#### 8.2-6\n\nDescribe an algorithm that, given \\(n\\) integers in the range 0 to \\(k\\), preprocesses its input and then answers any query about how many of the \\(n\\) integers fall into a range \\([a:b]\\) in \\(O(1)\\) time. Your algorithm should use \\(\\Theta(n+k)\\) preprocessing time.\n\n#### 8.2-7\n\nCounting sort can also work efficiently if the input values have fractional parts, but the number of digits in the fractional part is small. Suppose that you are given \\(n\\) numbers in the range 0 to \\(k\\), each with at most \\(d\\) decimal (base 10) digits to the right of the decimal point. Modify counting sort to run in \\(\\Theta(n+10^{d}k)\\) time.\n\n### Radix sort\n\n_Radix sort_ is the algorithm used by the card-sorting machines you now find only in computer museums. The cards have 80 columns, and in each column a machine can punch a hole in one of 12 places. The sorter can be mechanically \"programmed\" to examine a given column of each card in a deck and distribute the card into one",
        "chapter": "Part II Sorting and Order Statistics",
        "section": "8 Sorting in Linear Time",
        "subsection": "8.2 Counting sort",
        "subsubsection": "N/A"
    },
    {
        "content": "#### 8.2-3\n\nSuppose that we were to rewrite the **for** loop header in line 11 of the CountingSort as\n\n11 **for \\(j\\ =\\ 1\\) to \\(n\\)**\n\nShow that the algorithm still works properly, but that it is not stable. Then rewrite the pseudocode for counting sort so that elements with the same value are written into the output array in order of increasing index and the algorithm is stable.\n\n#### 8.2-4\n\nProve the following loop invariant for Counting-Sort:\n\nAt the start of each iteration of the **for** loop of lines 11-13, the last element in \\(A\\) with value \\(i\\) that has not yet been copied into \\(B\\) belongs in \\(B[C[i]]\\).\n\n#### 8.2-5\n\nSuppose that the array being sorted contains only integers in the range 0 to \\(k\\) and that there are no satellite data to move with those keys. Modify counting sort to use just the arrays \\(A\\) and \\(C\\), putting the sorted result back into array \\(A\\) instead of into a new array \\(B\\).\n\n#### 8.2-6\n\nDescribe an algorithm that, given \\(n\\) integers in the range 0 to \\(k\\), preprocesses its input and then answers any query about how many of the \\(n\\) integers fall into a range \\([a:b]\\) in \\(O(1)\\) time. Your algorithm should use \\(\\Theta(n+k)\\) preprocessing time.\n\n#### 8.2-7\n\nCounting sort can also work efficiently if the input values have fractional parts, but the number of digits in the fractional part is small. Suppose that you are given \\(n\\) numbers in the range 0 to \\(k\\), each with at most \\(d\\) decimal (base 10) digits to the right of the decimal point. Modify counting sort to run in \\(\\Theta(n+10^{d}k)\\) time.\n\n### Radix sort\n\n_Radix sort_ is the algorithm used by the card-sorting machines you now find only in computer museums. The cards have 80 columns, and in each column a machine can punch a hole in one of 12 places. The sorter can be mechanically \"programmed\" to examine a given column of each card in a deck and distribute the card into oneof 12 bins depending on which place has been punched. An operator can then gather the cards bin by bin, so that cards with the first place punched are on top of cards with the second place punched, and so on.\n\nFor decimal digits, each column uses only 10 places. (The other two places are reserved for encoding nonnumeric characters.) A \\(d\\) -digit number occupies a field of \\(d\\) columns. Since the card sorter can look at only one column at a time, the problem of sorting \\(n\\) cards on a \\(d\\) -digit number requires a sorting algorithm.\n\nIntuitively, you might sort numbers on their _most significant_ (leftmost) digit, sort each of the resulting bins recursively, and then combine the decks in order. Unfortunately, since the cards in 9 of the 10 bins must be put aside to sort each of the bins, this procedure generates many intermediate piles of cards that you would have to keep track of. (See Exercise 8.3-6.)\n\nRadix sort solves the problem of card sorting--counterintuitively--by sorting on the _least significant_ digit first. The algorithm then combines the cards into a single deck, with the cards in the 0 bin preceding the cards in the 1 bin preceding the cards in the 2 bin, and so on. Then it sorts the entire deck again on the second-least significant digit and recombines the deck in a like manner. The process continues until the cards have been sorted on all \\(d\\) digits. Remarkably, at that point the cards are fully sorted on the \\(d\\) -digit number. Thus, only \\(d\\) passes through the deck are required to sort. Figure 8.3 shows how radix sort operates on a \"deck\" of seven 3-digit numbers.\n\nIn order for radix sort to work correctly, the digit sorts must be stable. The sort performed by a card sorter is stable, but the operator must be careful not to change the order of the cards as they come out of a bin, even though all the cards in a bin have the same digit in the chosen column.\n\nIn a typical computer, which is a sequential random-access machine, we sometimes use radix sort to sort records of information that are keyed by multiple fields. For example, we might wish to sort dates by three keys: year, month, and day. We could run a sorting algorithm with a comparison function that, given two dates,\n\nFigure 8.3: The operation of radix sort on seven 3-digit numbers. The leftmost column is the input. The remaining columns show the numbers after successive sorts on increasingly significant digit positions. Tan shading indicates the digit position sorted on to produce each list from the previous one.\n\ncompares years, and if there is a tie, compares months, and if another tie occurs, compares days. Alternatively, we could sort the information three times with a stable sort: first on day (the \"least significant\" part), next on month, and finally on year.\n\nThe code for radix sort is straightforward. The Radix-Sort procedure assumes that each element in array \\(A[1:n]\\) has \\(d\\) digits, where digit 1 is the lowest-order digit and digit \\(d\\) is the highest-order digit.\n\n\\[\\textsc{Radix-Sort}(A,n,d)\\]\n\nAlthough the pseudocode for Radix-Sort does not specify which stable sort to use, Counting-Sort is commonly used. If you use Counting-Sort as the stable sort, you can make Radix-Sort a little more efficient by revising Counting-Sort to take a pointer to the output array as a parameter, having Radix-Sort preallocate this array, and alternating input and output between the two arrays in successive iterations of the **for** loop in Radix-Sort.\n\n**Lemma 8.3**: _Given \\(n\\)\\(d\\)-digit numbers in which each digit can take on up to \\(k\\) possible values, Radix-Sort correctly sorts these numbers in \\(\\Theta(d(n+k))\\) time if the stable sort it uses takes \\(\\Theta(n+k)\\) time._\n\n_Proof_ The correctness of radix sort follows by induction on the column being sorted (see Exercise 8.3-3). The analysis of the running time depends on the stable sort used as the intermediate sorting algorithm. When each digit lies in the range 0 to \\(k-1\\) (so that it can take on \\(k\\) possible values), and \\(k\\) is not too large, counting sort is the obvious choice. Each pass over \\(n\\)\\(d\\)-digit numbers then takes \\(\\Theta(n+k)\\) time. There are \\(d\\) passes, and so the total time for radix sort is \\(\\Theta(d(n+k))\\).\n\nWhen \\(d\\) is constant and \\(k=O(n)\\), we can make radix sort run in linear time. More generally, we have some flexibility in how to break each key into digits.\n\n**Lemma 8.4**: _Given \\(n\\)\\(b\\)-bit numbers and any positive integer \\(r\\leq b\\), Radix-Sort correctly sorts these numbers in \\(\\Theta((b/r)(n+2^{r}))\\) time if the stable sort it uses takes \\(\\Theta(n+k)\\) time for inputs in the range 0 to \\(k\\).__Proof_ For a value \\(r\\leq b\\), view each key as having \\(d=\\lceil b/r\\rceil\\) digits of \\(r\\) bits each. Each digit is an integer in the range \\(0\\) to \\(2^{r}-1\\), so that we can use counting sort with \\(k=2^{r}-1\\). (For example, we can view a 32-bit word as having four 8-bit digits, so that \\(b=32,r=8,k=2^{r}-1=255\\), and \\(d=b/r=4\\).) Each pass of counting sort takes \\(\\Theta(n+k)=\\Theta(n+2^{r})\\) time and there are \\(d\\) passes, for a total running time of \\(\\Theta(d(n+2^{r}))=\\Theta((b/r)(n+2^{r}))\\).\n\nGiven \\(n\\) and \\(b\\), what value of \\(r\\leq b\\) minimizes the expression \\((b/r)(n+2^{r})\\)? As \\(r\\) decreases, the factor \\(b/r\\) increases, but as \\(r\\) increases so does \\(2^{r}\\). The answer depends on whether \\(b<\\lfloor\\lg n\\rfloor\\). If \\(b<\\lfloor\\lg n\\rfloor\\), then \\(r\\leq b\\) implies \\((n+2^{r})=\\Theta(n)\\). Thus, choosing \\(r=b\\) yields a running time of \\((b/b)(n+2^{b})=\\Theta(n)\\), which is asymptotically optimal. If \\(b\\geq\\lfloor\\lg n\\rfloor\\), then choosing \\(r=\\lfloor\\lg n\\rfloor\\) gives the best running time to within a constant factor, which we can see as follows.1 Choosing \\(r=\\lfloor\\lg n\\rfloor\\) yields a running time of \\(\\Theta(bn/\\lg n)\\). As \\(r\\) increases above \\(\\lfloor\\lg n\\rfloor\\), the \\(2^{r}\\) term in the numerator increases faster than the \\(r\\) term in the denominator, and so increasing \\(r\\) above \\(\\lfloor\\lg n\\rfloor\\) yields a running time of \\(\\Omega(bn/\\lg n)\\). If instead \\(r\\) were to decrease below \\(\\lfloor\\lg n\\rfloor\\), then the \\(b/r\\) term increases and the \\(n+2^{r}\\) term remains at \\(\\Theta(n)\\).\n\nFootnote 1: The choice of \\(r=\\lfloor\\lg n\\rfloor\\) assumes that \\(n>1\\). If \\(n\\leq 1\\), there is nothing to sort.\n\nIs radix sort preferable to a comparison-based sorting algorithm, such as quicksort? If \\(b=O(\\lg n)\\), as is often the case, and \\(r\\approx\\lg n\\), then radix sort's running time is \\(\\Theta(n)\\), which appears to be better than quicksort's expected running time of \\(\\Theta(n\\lg n)\\). The constant factors hidden in the \\(\\Theta\\)-notation differ, however. Although radix sort may make fewer passes than quicksort over the \\(n\\) keys, each pass of radix sort may take significantly longer. Which sorting algorithm to prefer depends on the characteristics of the implementations, of the underlying machine (e.g., quicksort often uses hardware caches more effectively than radix sort), and of the input data. Moreover, the version of radix sort that uses counting sort as the intermediate stable sort does not sort in place, which many of the \\(\\Theta(n\\lg n)\\)-time comparison sorts do. Thus, when primary memory storage is at a premium, an in-place algorithm such as quicksort could be the better choice.\n\n## 8.3-1\n\nUsing Figure 8.3 as a model, illustrate the operation of Radix-Sort on the following list of English words: COW, DOG, SEA, RUG, ROW, MOB, BOX, TAB, BAR, EAR, TAR, DIG, BIG, TEA, NOW, FOX.\n\n### Bucket sort\n\nWhich of the following sorting algorithms are stable: insertion sort, merge sort, heapsort, and quicksort? Give a simple scheme that makes any comparison sort stable. How much additional time and space does your scheme entail?\n\n### 8.3-3\n\nUse induction to prove that radix sort works. Where does your proof need the assumption that the intermediate sort is stable?\n\n### 8.3-4\n\nSuppose that Counting-Sort is used as the stable sort within Radix-Sort. If Radix-Sort calls Counting-Sort\\(d\\) times, then since each call of Counting-Sort makes two passes over the data (lines 4-5 and 11-13), altogether \\(2d\\) passes over the data occur. Describe how to reduce the total number of passes to \\(d\\,+\\,1\\).\n\n### 8.3-5\n\nShow how to sort \\(n\\) integers in the range \\(0\\) to \\(n^{3}-1\\) in \\(O(n)\\) time.\n\n### 8.3-6\n\nIn the first card-sorting algorithm in this section, which sorts on the most significant digit first, exactly how many sorting passes are needed to sort \\(d\\)-digit decimal numbers in the worst case? How many piles of cards does an operator need to keep track of in the worst case?\n\n### Bucket sort\n\n_Bucket sort_ assumes that the input is drawn from a uniform distribution and has an average-case running time of \\(O(n)\\). Like counting sort, bucket sort is fast because it assumes something about the input. Whereas counting sort assumes that the input consists of integers in a small range, bucket sort assumes that the input is generated by a random process that distributes elements uniformly and independently over the interval \\([0,1)\\). (See Section C.2 for a definition of a uniform distribution.)\n\nBucket sort divides the interval \\([0,1)\\) into \\(n\\) equal-sized subintervals, or _buckets_, and then distributes the \\(n\\) input numbers into the buckets. Since the inputs are uniformly and independently distributed over \\([0,1)\\), we do not expect many numbers to fall into each bucket. To produce the output, we simply sort the numbers in each bucket and then go through the buckets in order, listing the elements in each.\n\nThe Bucket-Sort procedure on the next page assumes that the input is an array \\(A[1:n]\\) and that each element \\(A[i]\\) in the array satisfies \\(0\\leq A[i]<1\\). The code requires an auxiliary array \\(B[0:n-1]\\) of linked lists (buckets) and assumes",
        "chapter": "Part II Sorting and Order Statistics",
        "section": "8 Sorting in Linear Time",
        "subsection": "8.3 Radix sort",
        "subsubsection": "N/A"
    },
    {
        "content": "### Bucket sort\n\nWhich of the following sorting algorithms are stable: insertion sort, merge sort, heapsort, and quicksort? Give a simple scheme that makes any comparison sort stable. How much additional time and space does your scheme entail?\n\n### 8.3-3\n\nUse induction to prove that radix sort works. Where does your proof need the assumption that the intermediate sort is stable?\n\n### 8.3-4\n\nSuppose that Counting-Sort is used as the stable sort within Radix-Sort. If Radix-Sort calls Counting-Sort\\(d\\) times, then since each call of Counting-Sort makes two passes over the data (lines 4-5 and 11-13), altogether \\(2d\\) passes over the data occur. Describe how to reduce the total number of passes to \\(d\\,+\\,1\\).\n\n### 8.3-5\n\nShow how to sort \\(n\\) integers in the range \\(0\\) to \\(n^{3}-1\\) in \\(O(n)\\) time.\n\n### 8.3-6\n\nIn the first card-sorting algorithm in this section, which sorts on the most significant digit first, exactly how many sorting passes are needed to sort \\(d\\)-digit decimal numbers in the worst case? How many piles of cards does an operator need to keep track of in the worst case?\n\n### Bucket sort\n\n_Bucket sort_ assumes that the input is drawn from a uniform distribution and has an average-case running time of \\(O(n)\\). Like counting sort, bucket sort is fast because it assumes something about the input. Whereas counting sort assumes that the input consists of integers in a small range, bucket sort assumes that the input is generated by a random process that distributes elements uniformly and independently over the interval \\([0,1)\\). (See Section C.2 for a definition of a uniform distribution.)\n\nBucket sort divides the interval \\([0,1)\\) into \\(n\\) equal-sized subintervals, or _buckets_, and then distributes the \\(n\\) input numbers into the buckets. Since the inputs are uniformly and independently distributed over \\([0,1)\\), we do not expect many numbers to fall into each bucket. To produce the output, we simply sort the numbers in each bucket and then go through the buckets in order, listing the elements in each.\n\nThe Bucket-Sort procedure on the next page assumes that the input is an array \\(A[1:n]\\) and that each element \\(A[i]\\) in the array satisfies \\(0\\leq A[i]<1\\). The code requires an auxiliary array \\(B[0:n-1]\\) of linked lists (buckets) and assumesthat there is a mechanism for maintaining such lists. (Section 10.2 describes how to implement basic operations on linked lists.) Figure 8.4 shows the operation of bucket sort on an input array of 10 numbers.\n\n\\[\\begin{array}{ll}\\mbox{Bucket-Sort}(A,n)\\\\ 1&\\mbox{let }B[0:n-1]\\mbox{ be a new array}\\\\ 2&\\mbox{for }i\\ =\\ 0\\mbox{\\ \\bf to }n-1\\\\ 3&\\mbox{make }B[i]\\mbox{ an empty list}\\\\ 4&\\mbox{for }i\\ =\\ 1\\mbox{\\ \\bf to }n\\\\ 5&\\mbox{insert }A[i]\\mbox{ into list }B[\\lfloor n\\cdot A[i]\\rfloor]\\\\ 6&\\mbox{for }i\\ =\\ 0\\mbox{\\ \\bf to }n-1\\\\ 7&\\mbox{sort list }B[i]\\mbox{ with insertion sort}\\\\ 8&\\mbox{concatenate the lists }B[0],B[1],\\ldots,B[n-1]\\mbox{ together in order}\\\\ 9&\\mbox{return the concatenated lists}\\end{array}\\]\n\nTo see that this algorithm works, consider two elements \\(A[i]\\) and \\(A[j]\\). Assume without loss of generality that \\(A[i]\\leq A[j]\\). Since \\(\\lfloor n\\cdot A[i]\\rfloor\\leq\\lfloor n\\cdot A[j]\\rfloor\\), either element \\(A[i]\\) goes into the same bucket as \\(A[j]\\) or it goes into a bucket with a lower index. If \\(A[i]\\) and \\(A[j]\\) go into the same bucket, then the **for** loop of lines 6-7 puts them into the proper order. If \\(A[i]\\) and \\(A[j]\\) go into different buckets, then line 8 puts them into the proper order. Therefore, bucket sort works correctly.\n\nFigure 8.4: The operation of Bucket-Sort for \\(n=10\\). **(a)** The input array \\(A[1:10]\\). **(b)** The array \\(B[0:9]\\) of sorted lists (buckets) after line 7 of the algorithm, with slashes indicating the end of each bucket. Bucket \\(i\\) holds values in the half-open interval \\([i/10,(i+1)/10)\\). The sorted output consists of a concatenation of the lists \\(B[0]\\), \\(B[1],\\ldots,B[9]\\) in order.\n\nTo analyze the running time, observe that, together, all lines except line 7 take \\(O(n)\\) time in the worst case. We need to analyze the total time taken by the \\(n\\) calls to insertion sort in line 7.\n\nTo analyze the cost of the calls to insertion sort, let \\(n_{i}\\) be the random variable denoting the number of elements placed in bucket \\(B[i]\\). Since insertion sort runs in quadratic time (see Section 2.2), the running time of bucket sort is\n\n\\[T(n)=\\Theta(n)+\\sum_{i=0}^{n-1}O(n_{i}^{2}). \\tag{8.1}\\]\n\nWe now analyze the average-case running time of bucket sort, by computing the expected value of the running time, where we take the expectation over the input distribution. Taking expectations of both sides and using linearity of expectation (equation (C.24) on page 1192), we have\n\n\\[\\mathrm{E}\\left[T(n)\\right] = \\mathrm{E}\\left[\\,\\Theta(n)+\\sum_{i=0}^{n-1}O(n_{i}^{2})\\,\\right] \\tag{8.2}\\] \\[= \\Theta(n)+\\sum_{i=0}^{n-1}\\mathrm{E}\\left[O(n_{i}^{2})\\,\\right] \\quad\\text{(by linearity of expectation)}\\] \\[= \\Theta(n)+\\sum_{i=0}^{n-1}O\\left(\\mathrm{E}\\left[n_{i}^{2}\\right] \\right)\\quad\\text{(by equation (C.25) on page 1193)}\\.\\]\n\nWe claim that\n\n\\[\\mathrm{E}\\left[n_{i}^{2}\\right]=2-1/n \\tag{8.3}\\]\n\nfor \\(i=0,1,\\ldots,n-1\\). It is no surprise that each bucket \\(i\\) has the same value of \\(\\mathrm{E}\\left[n_{i}^{2}\\right]\\), since each value in the input array \\(A\\) is equally likely to fall in any bucket.\n\nTo prove equation (8.3), view each random variable \\(n_{i}\\) as the number of successes in \\(n\\) Bernoulli trials (see Section C.4). Success in a trial occurs when an element goes into bucket \\(B[i]\\), with a probability \\(p=1/n\\) of success and \\(q=1-1/n\\) of failure. A binomial distribution counts \\(n_{i}\\), the number of successes, in the \\(n\\) trials. By equations (C.41) and (C.44) on pages 1199-1200, we have \\(\\mathrm{E}\\left[n_{i}\\right]=np=n(1/n)=1\\) and \\(\\mathrm{Var}\\left[n_{i}\\right]=npq=1-1/n\\). Equation (C.31) on page 1194 gives\n\n\\[\\mathrm{E}\\left[n_{i}^{2}\\right] = \\mathrm{Var}\\left[n_{i}\\right]+\\mathrm{E}^{2}\\left[n_{i}\\right]\\] \\[= (1-1/n)+1^{2}\\] \\[= 2-1/n\\,\\]which proves equation (8.3). Using this expected value in equation (8.2), we get that the average-case running time for bucket sort is \\(\\Theta(n)+n\\cdot O(2-1/n)=\\Theta(n)\\).\n\nEven if the input is not drawn from a uniform distribution, bucket sort may still run in linear time. As long as the input has the property that the sum of the squares of the bucket sizes is linear in the total number of elements, equation (8.1) tells us that bucket sort runs in linear time.\n\n##### Exercises\n\n##### 8.4-1\n\nUsing Figure 8.4 as a model, illustrate the operation of Bucket-Sort on the array \\(A=\\langle.79,\\!13,\\!16,\\!64,\\!39,\\!20,\\!89,\\!53,\\!71,\\!42\\rangle\\).\n\n##### 8.4-2\n\nExplain why the worst-case running time for bucket sort is \\(\\Theta(n^{2})\\). What simple change to the algorithm preserves its linear average-case running time and makes its worst-case running time \\(O(n\\lg n)\\)?\n\n##### 8.4-3\n\nLet \\(X\\) be a random variable that is equal to the number of heads in two flips of a fair coin. What is \\(\\mathrm{E}\\left[X^{2}\\right]\\)? What is \\(\\mathrm{E}^{2}\\left[X\\right]\\)?\n\n##### 8.4-4\n\nAn array \\(A\\) of size \\(n>10\\) is filled in the following way. For each element \\(A[i]\\), choose two random variables \\(x_{i}\\) and \\(y_{i}\\) uniformly and independently from \\([0,1)\\). Then set\n\n\\[A[i]=\\frac{\\left\\lfloor 10x_{i}\\right\\rfloor}{10}+\\frac{y_{i}}{n}\\.\\]\n\nModify bucket sort so that it sorts the array \\(A\\) in \\(O(n)\\) expected time.\n\n##### 8.4-5\n\nYou are given \\(n\\) points in the unit disk, \\(p_{i}=(x_{i},y_{i})\\), such that \\(0<x_{i}^{2}+y_{i}^{2}\\leq 1\\) for \\(i=1,2,\\ldots,n\\). Suppose that the points are uniformly distributed, that is, the probability of finding a point in any region of the disk is proportional to the area of that region. Design an algorithm with an average-case running time of \\(\\Theta(n)\\) to sort the \\(n\\) points by their distances \\(d_{i}=\\sqrt{x_{i}^{2}+y_{i}^{2}}\\) from the origin. (_Hint:_ Design the bucket sizes in Bucket-Sort to reflect the uniform distribution of the points in the unit disk.)\n\n##### 8.4-6\n\nA _probability distribution function_\\(P(x)\\) for a random variable \\(X\\) is defined by \\(P(x)=\\Pr\\left\\{X\\leq x\\right\\}\\). Suppose that you draw a list of \\(n\\) random variables\\(X_{1},X_{2},\\ldots,X_{n}\\) from a continuous probability distribution function \\(P\\) that is computable in \\(O(1)\\) time (given \\(y\\) you can find \\(x\\) such that \\(P(x)=y\\) in \\(O(1)\\) time). Give an algorithm that sorts these numbers in linear average-case time.\n\n## Problems\n\n### Probabilistic lower bounds on comparison sorting\n\nIn this problem, you will prove a probabilistic \\(\\Omega(n\\lg n)\\) lower bound on the running time of any deterministic or randomized comparison sort on \\(n\\) distinct input elements. You'll begin by examining a deterministic comparison sort \\(A\\) with decision tree \\(T_{A}\\). Assume that every permutation of \\(A\\)'s inputs is equally likely.\n\n* Suppose that each leaf of \\(T_{A}\\) is labeled with the probability that it is reached given a random input. Prove that exactly \\(n!\\) leaves are labeled \\(1/n!\\) and that the rest are labeled \\(0\\).\n* Let \\(D(T)\\) denote the external path length of a decision tree \\(T\\)--the sum of the depths of all the leaves of \\(T\\). Let \\(T\\) be a decision tree with \\(k>1\\) leaves, and let \\(LT\\) and \\(RT\\) be the left and right subtrees of \\(T\\). Show that \\(D(T)=D(LT)+D(RT)+k\\).\n* Let \\(d(k)\\) be the minimum value of \\(D(T)\\) over all decision trees \\(T\\) with \\(k>1\\) leaves. Show that \\(d(k)=\\min\\left\\{d(i)+d(k-i)+k:1\\leq i\\leq k-1\\right\\}\\). (_Hint:_ Consider a decision tree \\(T\\) with \\(k\\) leaves that achieves the minimum. Let \\(i_{0}\\) be the number of leaves in \\(LT\\) and \\(k-i_{0}\\) the number of leaves in \\(RT\\).)\n* Prove that for a given value of \\(k>1\\) and \\(i\\) in the range \\(1\\leq i\\leq k-1\\), the function \\(i\\lg i+(k-i)\\lg(k-i)\\) is minimized at \\(i=k/2\\). Conclude that \\(d(k)=\\Omega(k\\lg k)\\).\n* Prove that \\(D(T_{A})=\\Omega(n!\\lg(n!))\\), and conclude that the average-case time to sort \\(n\\) elements is \\(\\Omega(n\\lg n)\\).\n\nNow consider a _randomized_ comparison sort \\(B\\). We can extend the decision-tree model to handle randomization by incorporating two kinds of nodes: ordinary comparison nodes and \"randomization\" nodes. A randomization node models a random choice of the form \\(\\textsc{Random}(1,r)\\) made by algorithm \\(B\\). The node has \\(r\\) children, each of which is equally likely to be chosen during an execution of the algorithm.\n\n* Show that for any randomized comparison sort \\(B\\), there exists a deterministic comparison sort \\(A\\) whose expected number of comparisons is no more than those made by \\(B\\).",
        "chapter": "Part II Sorting and Order Statistics",
        "section": "8 Sorting in Linear Time",
        "subsection": "8.4 Bucket sort",
        "subsubsection": "N/A"
    },
    {
        "content": "\\(X_{1},X_{2},\\ldots,X_{n}\\) from a continuous probability distribution function \\(P\\) that is computable in \\(O(1)\\) time (given \\(y\\) you can find \\(x\\) such that \\(P(x)=y\\) in \\(O(1)\\) time). Give an algorithm that sorts these numbers in linear average-case time.\n\n## Problems\n\n### Probabilistic lower bounds on comparison sorting\n\nIn this problem, you will prove a probabilistic \\(\\Omega(n\\lg n)\\) lower bound on the running time of any deterministic or randomized comparison sort on \\(n\\) distinct input elements. You'll begin by examining a deterministic comparison sort \\(A\\) with decision tree \\(T_{A}\\). Assume that every permutation of \\(A\\)'s inputs is equally likely.\n\n* Suppose that each leaf of \\(T_{A}\\) is labeled with the probability that it is reached given a random input. Prove that exactly \\(n!\\) leaves are labeled \\(1/n!\\) and that the rest are labeled \\(0\\).\n* Let \\(D(T)\\) denote the external path length of a decision tree \\(T\\)--the sum of the depths of all the leaves of \\(T\\). Let \\(T\\) be a decision tree with \\(k>1\\) leaves, and let \\(LT\\) and \\(RT\\) be the left and right subtrees of \\(T\\). Show that \\(D(T)=D(LT)+D(RT)+k\\).\n* Let \\(d(k)\\) be the minimum value of \\(D(T)\\) over all decision trees \\(T\\) with \\(k>1\\) leaves. Show that \\(d(k)=\\min\\left\\{d(i)+d(k-i)+k:1\\leq i\\leq k-1\\right\\}\\). (_Hint:_ Consider a decision tree \\(T\\) with \\(k\\) leaves that achieves the minimum. Let \\(i_{0}\\) be the number of leaves in \\(LT\\) and \\(k-i_{0}\\) the number of leaves in \\(RT\\).)\n* Prove that for a given value of \\(k>1\\) and \\(i\\) in the range \\(1\\leq i\\leq k-1\\), the function \\(i\\lg i+(k-i)\\lg(k-i)\\) is minimized at \\(i=k/2\\). Conclude that \\(d(k)=\\Omega(k\\lg k)\\).\n* Prove that \\(D(T_{A})=\\Omega(n!\\lg(n!))\\), and conclude that the average-case time to sort \\(n\\) elements is \\(\\Omega(n\\lg n)\\).\n\nNow consider a _randomized_ comparison sort \\(B\\). We can extend the decision-tree model to handle randomization by incorporating two kinds of nodes: ordinary comparison nodes and \"randomization\" nodes. A randomization node models a random choice of the form \\(\\textsc{Random}(1,r)\\) made by algorithm \\(B\\). The node has \\(r\\) children, each of which is equally likely to be chosen during an execution of the algorithm.\n\n* Show that for any randomized comparison sort \\(B\\), there exists a deterministic comparison sort \\(A\\) whose expected number of comparisons is no more than those made by \\(B\\).\n\n### 8.2 Sorting in place in linear time\n\nYou have an array of \\(n\\) data records to sort, each with a key of 0 or 1. An algorithm for sorting such a set of records might possess some subset of the following three desirable characteristics:\n\n1. The algorithm runs in \\(O(n)\\) time.\n2. The algorithm is stable.\n3. The algorithm sorts in place, using no more than a constant amount of storage space in addition to the original array. _a._ Give an algorithm that satisfies criteria 1 and 2 above. _b._ Give an algorithm that satisfies criteria 1 and 3 above. _c._ Give an algorithm that satisfies criteria 2 and 3 above. _d._ Can you use any of your sorting algorithms from parts (a)-(c) as the sorting method used in line 2 of Radix-Sort, so that Radix-Sort sorts \\(n\\) records with \\(b\\)-bit keys in \\(O(bn)\\) time? Explain how or why not. _e._ Suppose that the \\(n\\) records have keys in the range from 1 to \\(k\\). Show how to modify counting sort so that it sorts the records in place in \\(O(n+k)\\) time. You may use \\(O(k)\\) storage outside the input array. Is your algorithm stable?\n\n### 8.3 Sorting variable-length items\n\nYou are given an array of integers, where different integers may have different numbers of digits, but the total number of digits over _all_ the integers in the array is \\(n\\). Show how to sort the array in \\(O(n)\\) time. _b._ You are given an array of strings, where different strings may have different numbers of characters, but the total number of characters over all the strings is \\(n\\). Show how to sort the strings in \\(O(n)\\) time. (The desired order is the standard alphabetical order: for example, \\(\\texttt{a}<\\texttt{ab}<\\texttt{b}\\).)\n\n### 8.4 Water jugs\n\nYou are given \\(n\\) red and \\(n\\) blue water jugs, all of different shapes and sizes. All the red jugs hold different amounts of water, as do all the blue jugs, and you cannot tell from the size of a jug how much water it holds. Moreover, for every jug of one color, there is a jug of the other color that holds the same amount of water.\n\nYour task is to group the jugs into pairs of red and blue jugs that hold the same amount of water. To do so, you may perform the following operation: pick a pairof jugs in which one is red and one is blue, fill the red jug with water, and then pour the water into the blue jug. This operation tells you whether the red jug or the blue jug can hold more water, or that they have the same volume. Assume that such a comparison takes one time unit. Your goal is to find an algorithm that makes a minimum number of comparisons to determine the grouping. Remember that you may not directly compare two red jugs or two blue jugs.\n\n1. Describe a deterministic algorithm that uses \\(\\Theta(n^{2})\\) comparisons to group the jugs into pairs.\n2. Prove a lower bound of \\(\\Omega(n\\lg n)\\) for the number of comparisons that an algorithm solving this problem must make.\n3. Give a randomized algorithm whose expected number of comparisons is \\(O(n\\lg n)\\), and prove that this bound is correct. What is the worst-case number of comparisons for your algorithm?\n\n### 8.5 Average sorting\n\nSuppose that, instead of sorting an array, we just require that the elements increase on average. More precisely, we call an \\(n\\)-element array \\(A\\)_k-sorted_ if, for all \\(i=1,2,\\ldots,n-k\\), the following holds:\n\n\\[\\frac{\\sum_{j=i}^{i+k-1}A[j]}{k}\\leq\\frac{\\sum_{j=i+1}^{i+k}A[j]}{k}\\.\\]\n\n1. What does it mean for an array to be 1-sorted?\n2. Give a permutation of the numbers \\(1,2,\\ldots,10\\) that is 2-sorted, but not sorted.\n3. Prove that an \\(n\\)-element array is \\(k\\)-sorted if and only if \\(A[i]\\leq A[i+k]\\) for all \\(i=1,2,\\ldots,n-k\\).\n4. Give an algorithm that \\(k\\)-sorts an \\(n\\)-element array in \\(O(n\\lg(n/k))\\) time.\n\nWe can also show a lower bound on the time to produce a \\(k\\)-sorted array, when \\(k\\) is a constant.\n\n1. Show how to sort a \\(k\\)-sorted array of length \\(n\\) in \\(O(n\\lg k)\\) time. (_Hint:_ Use the solution to Exercise 6.5-11.)\n2. Show that when \\(k\\) is a constant, \\(k\\)-sorting an \\(n\\)-element array requires \\(\\Omega(n\\lg n)\\) time. (_Hint:_ Use the solution to part (e) along with the lower bound on comparison sorts.)\n\n### 8.6 Lower bound on merging sorted lists\n\nThe problem of merging two sorted lists arises frequently. We have seen a procedure for it as the subroutine Merge in Section 2.3.1. In this problem, you will prove a lower bound of \\(2n-1\\) on the worst-case number of comparisons required to merge two sorted lists, each containing \\(n\\) items. First, you will show a lower bound of \\(2n-o(n)\\) comparisons by using a decision tree.\n\n1. Given \\(2n\\) numbers, compute the number of possible ways to divide them into two sorted lists, each with \\(n\\) numbers.\n2. Using a decision tree and your answer to part (a), show that any algorithm that correctly merges two sorted lists must perform at least \\(2n-o(n)\\) comparisons. Now you will show a slightly tighter \\(2n-1\\) bound.\n3. Show that if two elements are consecutive in the sorted order and from different lists, then they must be compared.\n4. Use your answer to part (c) to show a lower bound of \\(2n-1\\) comparisons for merging two sorted lists.\n\n### 8.7 The 0-1 sorting lemma and columnsort\n\nA _compare-exchange_ operation on two array elements \\(A[i]\\) and \\(A[j]\\), where \\(i<j\\), has the form\n\n\\[\\begin{array}{ll}\\mbox{Compare-Exchange}(A,i,j)\\\\ 1&\\mbox{if }A[i]>A[j]\\\\ 2&\\mbox{exchange }A[i]\\mbox{ with }A[j]\\end{array}\\]\n\nAfter the compare-exchange operation, we know that \\(A[i]\\leq A[j]\\).\n\nAn _oblivious compare-exchange algorithm_ operates solely by a sequence of prespecified compare-exchange operations. The indices of the positions compared in the sequence must be determined in advance, and although they can depend on the number of elements being sorted, they cannot depend on the values being sorted, nor can they depend on the result of any prior compare-exchange operation. For example, the Compare-Exchange-Insertion-Sort procedure on the facing page shows a variation of insertion sort as an oblivious compare-exchange algorithm. (Unlike the Insertion-Sort procedure on page 19, the oblivious version runs in \\(\\Theta(n^{2})\\) time in all cases.)\n\nThe _0-1 sorting lemma_ provides a powerful way to prove that an oblivious compare-exchange algorithm produces a sorted result. It states that if an oblivious compare-exchange algorithm correctly sorts all input sequences consisting of only 0s and 1s, then it correctly sorts all inputs containing arbitrary values.\n\nYou will prove the 0-1 sorting lemma by proving its contrapositive: if an oblivious compare-exchange algorithm fails to sort an input containing arbitrary values, then it fails to sort some 0-1 input. Assume that an oblivious compare-exchange algorithm X fails to correctly sort the array \\(A[1:n]\\). Let \\(A[p]\\) be the smallest value in \\(A\\) that algorithm X puts into the wrong location, and let \\(A[q]\\) be the value that algorithm X moves to the location into which \\(A[p]\\) should have gone. Define an array \\(B[1:n]\\) of 0s and 1s as follows:\n\n\\[B[i]=\\left\\{\\begin{array}{ll}0&\\mbox{if }A[i]\\leq A[p]\\;,\\\\ 1&\\mbox{if }A[i]>A[p]\\;.\\end{array}\\right.\\]\n\n_a._ Argue that \\(A[q]>A[p]\\), so that \\(B[p]=0\\) and \\(B[q]=1\\).\n\n_b._ To complete the proof of the 0-1 sorting lemma, prove that algorithm X fails to sort array \\(B\\) correctly.\n\nNow you will use the 0-1 sorting lemma to prove that a particular sorting algorithm works correctly. The algorithm, _columnsort_, works on a rectangular array of \\(n\\) elements. The array has \\(r\\) rows and \\(s\\) columns (so that \\(n=rs\\)), subject to three restrictions:\n\n* \\(r\\) must be even,\n* \\(s\\) must be a divisor of \\(r\\), and\n* \\(r\\geq 2s^{2}\\).\n\nWhen columnsort completes, the array is sorted in _column-major order_: reading down each column in turn, from left to right, the elements monotonically increase.\n\nColumnsort operates in eight steps, regardless of the value of \\(n\\). The odd steps are all the same: sort each column individually. Each even step is a fixed permutation. Here are the steps:\n\n1. Sort each column.\n2. Transpose the array, but reshape it back to \\(r\\) rows and \\(s\\) columns. In other words, turn the leftmost column into the top \\(r/s\\) rows, in order; turn the next column into the next \\(r/s\\) rows, in order; and so on.\n\n3. Sort each column.\n4. Perform the inverse of the permutation performed in step 2.\n5. Sort each column.\n6. Shift the top half of each column into the bottom half of the same column, and shift the bottom half of each column into the top half of the next column to the right. Leave the top half of the leftmost column empty. Shift the bottom half of the last column into the top half of a new rightmost column, and leave the bottom half of this new column empty.\n7. Sort each column.\n8. Perform the inverse of the permutation performed in step 6.\n\nYou can think of steps 6-8 as a single step that sorts the bottom half of each column and the top half of the next column. Figure 8.5 shows an example of the steps of columnsort with \\(r=6\\) and \\(s=3\\). (Even though this example violates the requirement that \\(r\\geq 2s^{2}\\), it happens to work.)Although it might seem hard to believe that columnsort actually sorts, you will use the 0-1 sorting lemma to prove that it does. The 0-1 sorting lemma applies because we can treat columnsort as an oblivious compare-exchange algorithm. A couple of definitions will help you apply the 0-1 sorting lemma. We say that an area of an array is _clean_ if we know that it contains either all 0s or all 1s or if it is empty. Otherwise, the area might contain mixed 0s and 1s, and it is _dirty_. From here on, assume that the input array contains only 0s and 1s, and that we can treat it as an array with \\(r\\) rows and \\(s\\) columns. _d._ Prove that after steps 1-3, the array consists of clean rows of 0s at the top, clean rows of 1s at the bottom, and at most \\(s\\) dirty rows between them. (One of the clean rows could be empty.) _e._ Prove that after step 4, the array, read in column-major order, starts with a clean area of 0s, ends with a clean area of 1s, and has a dirty area of at most \\(s^{2}\\) elements in the middle. (Again, one of the clean areas could be empty.) _f._ Prove that steps 5-8 produce a fully sorted 0-1 output. Conclude that column-sort correctly sorts all inputs containing arbitrary values. _g._ Now suppose that \\(s\\) does not divide \\(r\\). Prove that after steps 1-3, the array consists of clean rows of 0s at the top, clean rows of 1s at the bottom, and at most \\(2s-1\\) dirty rows between them. (Once again, one of the clean areas could be empty.) How large must \\(r\\) be, compared with \\(s\\), for columnsort to correctly sort when \\(s\\) does not divide \\(r\\)? _h._ Suggest a simple change to step 1 that allows us to maintain the requirement that \\(r\\geq 2s^{2}\\) even when \\(s\\) does not divide \\(r\\), and prove that with your change, columnsort correctly sorts.\n\n## Chapter notes\n\nThe decision-tree model for studying comparison sorts was introduced by Ford and Johnson [150]. Knuth's comprehensive treatise on sorting [261] covers many variations on the sorting problem, including the information-theoretic lower bound on the complexity of sorting given here. Ben-Or [46] studied lower bounds for sorting using generalizations of the decision-tree model.\n\nKnuth credits H. H. Seward with inventing counting sort in 1954, as well as with the idea of combining counting sort with radix sort. Radix sorting starting with the least significant digit appears to be a folk algorithm widely used by operators of",
        "chapter": "Part II Sorting and Order Statistics",
        "section": "8 Sorting in Linear Time",
        "subsection": "Problems",
        "subsubsection": "N/A"
    },
    {
        "content": "Although it might seem hard to believe that columnsort actually sorts, you will use the 0-1 sorting lemma to prove that it does. The 0-1 sorting lemma applies because we can treat columnsort as an oblivious compare-exchange algorithm. A couple of definitions will help you apply the 0-1 sorting lemma. We say that an area of an array is _clean_ if we know that it contains either all 0s or all 1s or if it is empty. Otherwise, the area might contain mixed 0s and 1s, and it is _dirty_. From here on, assume that the input array contains only 0s and 1s, and that we can treat it as an array with \\(r\\) rows and \\(s\\) columns. _d._ Prove that after steps 1-3, the array consists of clean rows of 0s at the top, clean rows of 1s at the bottom, and at most \\(s\\) dirty rows between them. (One of the clean rows could be empty.) _e._ Prove that after step 4, the array, read in column-major order, starts with a clean area of 0s, ends with a clean area of 1s, and has a dirty area of at most \\(s^{2}\\) elements in the middle. (Again, one of the clean areas could be empty.) _f._ Prove that steps 5-8 produce a fully sorted 0-1 output. Conclude that column-sort correctly sorts all inputs containing arbitrary values. _g._ Now suppose that \\(s\\) does not divide \\(r\\). Prove that after steps 1-3, the array consists of clean rows of 0s at the top, clean rows of 1s at the bottom, and at most \\(2s-1\\) dirty rows between them. (Once again, one of the clean areas could be empty.) How large must \\(r\\) be, compared with \\(s\\), for columnsort to correctly sort when \\(s\\) does not divide \\(r\\)? _h._ Suggest a simple change to step 1 that allows us to maintain the requirement that \\(r\\geq 2s^{2}\\) even when \\(s\\) does not divide \\(r\\), and prove that with your change, columnsort correctly sorts.\n\n## Chapter notes\n\nThe decision-tree model for studying comparison sorts was introduced by Ford and Johnson [150]. Knuth's comprehensive treatise on sorting [261] covers many variations on the sorting problem, including the information-theoretic lower bound on the complexity of sorting given here. Ben-Or [46] studied lower bounds for sorting using generalizations of the decision-tree model.\n\nKnuth credits H. H. Seward with inventing counting sort in 1954, as well as with the idea of combining counting sort with radix sort. Radix sorting starting with the least significant digit appears to be a folk algorithm widely used by operators of mechanical card-sorting machines. According to Knuth, the first published reference to the method is a 1929 document by L. J. Comrie describing punched-card equipment. Bucket sorting has been in use since 1956, when the basic idea was proposed by Isaac and Singleton [235].\n\nMunro and Raman [338] give a stable sorting algorithm that performs \\(O(n^{1+\\epsilon})\\) comparisons in the worst case, where \\(0<\\epsilon\\leq 1\\) is any fixed constant. Although any of the \\(O(n\\lg n)\\)-time algorithms make fewer comparisons, the algorithm by Munro and Raman moves data only \\(O(n)\\) times and operates in place.\n\nThe case of sorting \\(n\\)\\(b\\)-bit integers in \\(o(n\\lg n)\\) time has been considered by many researchers. Several positive results have been obtained, each under slightly different assumptions about the model of computation and the restrictions placed on the algorithm. All the results assume that the computer memory is divided into addressable \\(b\\)-bit words. Fredman and Willard [157] introduced the fusion tree data structure and used it to sort \\(n\\) integers in \\(O(n\\lg n/\\lg\\lg n)\\) time. This bound was later improved to \\(O(n\\sqrt{\\lg n})\\) time by Andersson [17]. These algorithms require the use of multiplication and several precomputed constants. Andersson, Hagerup, Nilsson, and Raman [18] have shown how to sort \\(n\\) integers in \\(O(n\\lg\\lg n)\\) time without using multiplication, but their method requires storage that can be unbounded in terms of \\(n\\). Using multiplicative hashing, we can reduce the storage needed to \\(O(n)\\), but then the \\(O(n\\lg\\lg n)\\) worst-case bound on the running time becomes an expected-time bound. Generalizing the exponential search trees of Andersson [17], Thorup [434] gave an \\(O(n(\\lg\\lg n)^{2})\\)-time sorting algorithm that does not use multiplication or randomization, and it uses linear space. Combining these techniques with some new ideas, Han [207] improved the bound for sorting to \\(O(n\\lg\\lg n\\lg\\lg\\lg n)\\) time. Although these algorithms are important theoretical breakthroughs, they are all fairly complicated and at the present time seem unlikely to compete with existing sorting algorithms in practice.\n\nThe columnsort algorithm in Problem 8-7 is by Leighton [286].\n\n## Chapter 9 Medians and Order Statistics\n\nThe _i_th _order statistic_ of a set of \\(n\\) elements is the _i_th smallest element. For example, the _minimum_ of a set of elements is the first order statistic (\\(i=1\\)), and the _maximum_ is the _n_th order statistic (\\(i=n\\)). A _median_, informally, is the \"halfway point\" of the set. When \\(n\\) is odd, the median is unique, occurring at \\(i=(n+1)/2\\). When \\(n\\) is even, there are two medians, the _lower median_ occurring at \\(i=n/2\\) and the _upper median_ occurring at \\(i=n/2+1\\). Thus, regardless of the parity of \\(n\\), medians occur at \\(i=\\lfloor(n+1)/2\\rfloor\\) and \\(i=\\lceil(n+1)/2\\rceil\\). For simplicity in this text, however, we consistently use the phrase \"the median\" to refer to the lower median.\n\nThis chapter addresses the problem of selecting the _i_th order statistic from a set of \\(n\\) distinct numbers. We assume for convenience that the set contains distinct numbers, although virtually everything that we do extends to the situation in which a set contains repeated values. We formally specify the _selection problem_ as follows:\n\n**Input:** A set \\(A\\) of \\(n\\) distinct numbers1 and an integer \\(i\\), with \\(1\\leq i\\leq n\\).\n\nFootnote 1: As in the footnote on page 182, you can enforce the assumption that the numbers are distinct by converting each input value \\(A[i]\\) to an ordered pair \\((A[i],i)\\) with \\((A[i],i)\\!<\\!(A[j],j)\\) if either \\(A[i]<A[j]\\) or \\(A[i]=A[j]\\) and \\(i<j\\).\n\n**Output:** The element \\(x\\in A\\) that is larger than exactly \\(i-1\\) other elements of \\(A\\). We can solve the selection problem in \\(O(n\\lg n)\\) time simply by sorting the numbers using heapsort or merge sort and then outputting the _i_th element in the sorted array. This chapter presents asymptotically faster algorithms.\n\nSection 9.1 examines the problem of selecting the minimum and maximum of a set of elements. More interesting is the general selection problem, which we investigate in the subsequent two sections. Section 9.2 analyzes a practical randomized algorithm that achieves an \\(O(n)\\) expected running time, assuming dis",
        "chapter": "Part II Sorting and Order Statistics",
        "section": "8 Sorting in Linear Time",
        "subsection": "Chapter notes",
        "subsubsection": "N/A"
    },
    {
        "content": "tinct elements. Section 9.3 contains an algorithm of more theoretical interest that achieves the \\(O(n)\\) running time in the worst case.\n\n### 9.1 Minimum and maximum\n\nHow many comparisons are necessary to determine the minimum of a set of \\(n\\) elements? To obtain an upper bound of \\(n-1\\) comparisons, just examine each element of the set in turn and keep track of the smallest element seen so far. The Minimum procedure assumes that the set resides in array \\(A[1:n]\\).\n\n\\[\\begin{array}{l}\\mbox{Minimum}(A,n)\\\\ 1\\;\\;\\;min\\;=\\;A[1]\\\\ 2\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\; \\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\; \\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\; \\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\; \\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\; \\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\; \\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\; \\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\; \\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\; \\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\; \\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\; \\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\; \\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\; \\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\; \\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\; \n\n### 9.1 Minimum and maximum\n\nAlthough \\(2n-2\\) comparisons is asymptotically optimal, it is possible to improve the leading constant. We can find both the minimum and the maximum using at most \\(3\\left\\lfloor n/2\\right\\rfloor\\) comparisons. The trick is to maintain both the minimum and maximum elements seen thus far. Rather than processing each element of the input by comparing it against the current minimum and maximum, at a cost of \\(2\\) comparisons per element, process elements in pairs. Compare pairs of elements from the input first _with each other_, and then compare the smaller with the current minimum and the larger to the current maximum, at a cost of \\(3\\) comparisons for every \\(2\\) elements.\n\nHow you set up initial values for the current minimum and maximum depends on whether \\(n\\) is odd or even. If \\(n\\) is odd, set both the minimum and maximum to the value of the first element, and then process the rest of the elements in pairs. If \\(n\\) is even, perform \\(1\\) comparison on the first \\(2\\) elements to determine the initial values of the minimum and maximum, and then process the rest of the elements in pairs as in the case for odd \\(n\\).\n\nLet's count the total number of comparisons. If \\(n\\) is odd, then \\(3\\left\\lfloor n/2\\right\\rfloor\\) comparisons occur. If \\(n\\) is even, \\(1\\) initial comparison occurs, followed by another \\(3(n-2)/2\\) comparisons, for a total of \\(3n/2-2\\). Thus, in either case, the total number of comparisons is at most \\(3\\left\\lfloor n/2\\right\\rfloor\\).\n\n**Exercises**\n\n_9.1-1_\n\nShow that the second smallest of \\(n\\) elements can be found with \\(n+\\left\\lceil\\lg n\\right\\rceil-2\\) comparisons in the worst case. (_Hint:_ Also find the smallest element.)\n\n_9.1-2_\n\nGiven \\(n>2\\) distinct numbers, you want to find a number that is neither the minimum nor the maximum. What is the smallest number of comparisons that you need to perform?\n\n_9.1-3_\n\nA racetrack can run races with five horses at a time to determine their relative speeds. For \\(25\\) horses, it takes six races to determine the fastest horse, assuming transitivity (see page 1159). What's the minimum number of races it takes to determine the fastest three horses out of \\(25\\)?\n\n**4**: _9.1-4_\n\nProve the lower bound of \\(\\left\\lceil 3n/2\\right\\rceil-2\\) comparisons in the worst case to find both the maximum and minimum of \\(n\\) numbers. (_Hint:_ Consider how many numbers are potentially either the maximum or minimum, and investigate how a comparison affects these counts.)\n\n### 9.2 Selection in expected linear time\n\nThe general selection problem--finding the \\(i\\)th order statistic for any value of \\(i\\) -- appears more difficult than the simple problem of finding a minimum. Yet, surprisingly, the asymptotic running time for both problems is the same: \\(\\Theta(n)\\). This section presents a divide-and-conquer algorithm for the selection problem. The algorithm Randomized-Select is modeled after the quicksort algorithm of Chapter 7. Like quicksort it partitions the input array recursively. But unlike quicksort, which recursively processes both sides of the partition, Randomized-Select works on only one side of the partition. This difference shows up in the analysis: whereas quicksort has an expected running time of \\(\\Theta(n\\lg n)\\), the expected running time of Randomized-Select is \\(\\Theta(n)\\), assuming that the elements are distinct.\n\nRandomized-Select uses the procedure Randomized-Partition introduced in Section 7.3. Like Randomized-Quicksort, it is a randomized algorithm, since its behavior is determined in part by the output of a random-number generator. The Randomized-Select procedure returns the \\(i\\)th smallest element of the array \\(A[p:r]\\), where \\(1\\leq i\\leq r-p+1\\).\n\nRandomized-Select(\\(A\\), \\(p,r,i\\))\n\n**if**\\(p==r\\)\n\n**return**\\(A[p]\\) // \\(1\\leq i\\leq r-p+1\\) when \\(p==r\\) means that \\(i=1\\)\n\n\\(q=\\) Randomized-Partition(\\(A\\), \\(p,r\\))\n\n\\(k=q-p+1\\)\n\n**if**\\(i==k\\)\n\n**return**\\(A[q]\\) // the pivot value is the answer\n\n**elseif**\\(i<k\\)\n\n**return**Randomized-Select(\\(A\\), \\(p,q-1,i\\))\n\n**else**return**Randomized-Select(\\(A\\), \\(q+1,r,i-k\\))\n\nFigure 9.1 illustrates how the Randomized-Select procedure works. Line 1 checks for the base case of the recursion, in which the subarray \\(A[p:r]\\) consists of just one element. In this case, \\(i\\) must equal \\(1\\), and line 2 simply returns \\(A[p]\\) as the \\(i\\)th smallest element. Otherwise, the call to Randomized-Partition in line 3 partitions the array \\(A[p:r]\\) into two (possibly empty) subarrays \\(A[p:q-1]\\) and \\(A[q+1:r]\\) such that each element of \\(A[p:q-1]\\) is less than or equal to \\(A[q]\\), which in turn is less than each element of \\(A[q+1:r]\\). (Although our analysis assumes that the elements are distinct, the procedure still yields the correct result even if equal elements are present.) As in quicksort, we'll refer to \\(A[q]\\) as the _pivot_ element. Line 4 computes the number \\(k\\) of elements in the subarray \\(A[p:q]\\), that is,",
        "chapter": "Part II Sorting and Order Statistics",
        "section": "9 Medians and Order Statistics",
        "subsection": "9.1 Minimum and maximum",
        "subsubsection": "N/A"
    },
    {
        "content": "### 9.2 Selection in expected linear time\n\nThe general selection problem--finding the \\(i\\)th order statistic for any value of \\(i\\) -- appears more difficult than the simple problem of finding a minimum. Yet, surprisingly, the asymptotic running time for both problems is the same: \\(\\Theta(n)\\). This section presents a divide-and-conquer algorithm for the selection problem. The algorithm Randomized-Select is modeled after the quicksort algorithm of Chapter 7. Like quicksort it partitions the input array recursively. But unlike quicksort, which recursively processes both sides of the partition, Randomized-Select works on only one side of the partition. This difference shows up in the analysis: whereas quicksort has an expected running time of \\(\\Theta(n\\lg n)\\), the expected running time of Randomized-Select is \\(\\Theta(n)\\), assuming that the elements are distinct.\n\nRandomized-Select uses the procedure Randomized-Partition introduced in Section 7.3. Like Randomized-Quicksort, it is a randomized algorithm, since its behavior is determined in part by the output of a random-number generator. The Randomized-Select procedure returns the \\(i\\)th smallest element of the array \\(A[p:r]\\), where \\(1\\leq i\\leq r-p+1\\).\n\nRandomized-Select(\\(A\\), \\(p,r,i\\))\n\n**if**\\(p==r\\)\n\n**return**\\(A[p]\\) // \\(1\\leq i\\leq r-p+1\\) when \\(p==r\\) means that \\(i=1\\)\n\n\\(q=\\) Randomized-Partition(\\(A\\), \\(p,r\\))\n\n\\(k=q-p+1\\)\n\n**if**\\(i==k\\)\n\n**return**\\(A[q]\\) // the pivot value is the answer\n\n**elseif**\\(i<k\\)\n\n**return**Randomized-Select(\\(A\\), \\(p,q-1,i\\))\n\n**else**return**Randomized-Select(\\(A\\), \\(q+1,r,i-k\\))\n\nFigure 9.1 illustrates how the Randomized-Select procedure works. Line 1 checks for the base case of the recursion, in which the subarray \\(A[p:r]\\) consists of just one element. In this case, \\(i\\) must equal \\(1\\), and line 2 simply returns \\(A[p]\\) as the \\(i\\)th smallest element. Otherwise, the call to Randomized-Partition in line 3 partitions the array \\(A[p:r]\\) into two (possibly empty) subarrays \\(A[p:q-1]\\) and \\(A[q+1:r]\\) such that each element of \\(A[p:q-1]\\) is less than or equal to \\(A[q]\\), which in turn is less than each element of \\(A[q+1:r]\\). (Although our analysis assumes that the elements are distinct, the procedure still yields the correct result even if equal elements are present.) As in quicksort, we'll refer to \\(A[q]\\) as the _pivot_ element. Line 4 computes the number \\(k\\) of elements in the subarray \\(A[p:q]\\), that is,\n\n### Selection in expected linear time\n\nthe number of elements in the low side of the partition, plus 1 for the pivot element. Line 5 then checks whether \\(A[q]\\) is the \\(i\\)th smallest element. If it is, then line 6 returns \\(A[q]\\). Otherwise, the algorithm determines in which of the two subarrays \\(A[p:q-1]\\) and \\(A[q+1:r]\\) the \\(i\\)th smallest element lies. If \\(i<k\\), then the desired element lies on the low side of the partition, and line 8 recursively selects it from the subarray. If \\(i>k\\), however, then the desired element lies on the high side of the partition. Since we already know \\(k\\) values that are smaller than the \\(i\\)th smallest element of \\(A[p:r]\\)--namely, the elements of \\(A[p:q]\\)--the desired element is the \\((i-k)\\)th smallest element of \\(A[q+1:r]\\), which line 9 finds recursively. The code appears to allow recursive calls to subarrays with 0 elements, but Exercise 9.2-1 asks you to show that this situation cannot happen.\n\nThe worst-case running time for Randomized-Select is \\(\\Theta(n^{2})\\), even to find the minimum, because it could be extremely unlucky and always partition around the largest remaining element before identifying the \\(i\\)th smallest when only one element remains. In this worst case, each recursive step removes only the pivot from consideration. Because partitioning \\(n\\) elements takes \\(\\Theta(n)\\) time, the recurrence for the worst-case running time is the same as for Quicksort:\n\nFigure 9.1: The action of Randomized-Select as successive partitionings narrow the subarray \\(A[p:r]\\), showing the values of the parameters \\(p,r\\), and \\(i\\) at each recursive call. The subarray \\(A[p:r]\\) in each recursive step is shown in tan, with the dark tan element selected as the pivot for the next partitioning. Blue elements are outside \\(A[p:r]\\). The answer is the tan element in the bottom array, where \\(p=r=5\\) and \\(i=1\\). The array designations \\(A^{(0)}\\), \\(A^{(1)},\\ldots,A^{(5)}\\), the partitioning numbers, and whether the partitioning is helpful are explained on the following page.\n\n\\(T(n)=T(n-1)+\\Theta(n)\\), with the solution \\(T(n)=\\Theta(n^{2})\\). We'll see that the algorithm has a linear expected running time, however, and because it is randomized, no particular input elicits the worst-case behavior.\n\nTo see the intuition behind the linear expected running time, suppose that each time the algorithm randomly selects a pivot element, the pivot lies somewhere within the second and third quartiles--the \"middle half\"--of the remaining elements in sorted order. If the \\(i\\)th smallest element is less than the pivot, then all the elements greater than the pivot are ignored in all future recursive calls. These ignored elements include at least the uppermost quartile, and possibly more. Likewise, if the \\(i\\)th smallest element is greater than the pivot, then all the elements less than the pivot--at least the first quartile--are ignored in all future recursive calls. Either way, therefore, at least \\(1/4\\) of the remaining elements are ignored in all future recursive calls, leaving at most \\(3/4\\) of the remaining elements _in play_: residing in the subarray \\(A[p\\!:\\!r]\\). Since Randomized-Partition takes \\(\\Theta(n)\\) time on a subarray of \\(n\\) elements, the recurrence for the worst-case running time is \\(T(n)=T(3n/4)+\\Theta(n)\\). By case 3 of the master method (Theorem 4.1 on page 4.1), this recurrence has solution \\(T(n)=\\Theta(n)\\).\n\nOf course, the pivot does not necessarily fall into the middle half every time. Since the pivot is selected at random, the probability that it falls into the middle half is about \\(1/2\\) each time. We can view the process of selecting the pivot as a Bernoulli trial (see Section C.4) with success equating to the pivot residing in the middle half. Thus the expected number of trials needed for success is given by a geometric distribution: just two trials on average (equation (C.36) on page 4.1). In other words, we expect that half of the partitionings reduce the number of elements still in play by at least \\(3/4\\) and that half of the partitionings do not help as much. Consequently, the expected number of partitionings at most doubles from the case when the pivot always falls into the middle half. The cost of each extra partitioning is less than the one that preceded it, so that the expected running time is still \\(\\Theta(n)\\).\n\nTo make the above argument rigorous, we start by defining the random variable \\(A^{(j)}\\) as the set of elements of \\(A\\) that are still in play after \\(j\\) partitionings (that is, within the subarray \\(A[p\\!:\\!r]\\) after \\(j\\) calls of Randomized-Select), so that \\(A^{(0)}\\) consists of all the elements in \\(A\\). Since each partitioning removes at least one element--the pivot--from being in play, the sequence \\(|A^{(0)}|,|A^{(1)}|,|A^{(2)}|,\\ldots\\) strictly decreases. Set \\(A^{(j-1)}\\) is in play before the \\(j\\)th partitioning, and set \\(A^{(j)}\\) remains in play afterward. For convenience, assume that the initial set \\(A^{(0)}\\) is the result of a 0th \"dummy\" partitioning.\n\nLet's call the \\(j\\)th partitioning _helpful_ if \\(|A^{(j)}|\\leq(3/4)|A^{(j-1)}|\\). Figure 9.1 shows the sets \\(A^{(j)}\\) and whether partitionings are helpful for an example array. A helpful partitioning corresponds to a successful Bernoulli trial. The following lemma shows that a partitioning is at least as likely to be helpful as not.\n\n### Selection in expected linear time\n\nA partitioning is helpful with probability at least \\(1/2\\).\n\nProofWhether a partitioning is helpful depends on the randomly chosen pivot. We discussed the \"middle half\" in the informal argument above. Let's more precisely define the middle half of an \\(n\\)-element subarray as all but the smallest \\(\\lceil n/4\\rceil-1\\) and greatest \\(\\lceil n/4\\rceil-1\\) elements (that is, all but the first \\(\\lceil n/4\\rceil-1\\) and last \\(\\lceil n/4\\rceil-1\\) elements if the subarray were sorted). We'll prove that if the pivot falls into the middle half, then the pivot leads to a helpful partitioning, and we'll also prove that the probability of the pivot falling into the middle half is at least \\(1/2\\).\n\nRegardless of where the pivot falls, either all the elements greater than it or all the elements less than it, along with the pivot itself, will no longer be in play after partitioning. If the pivot falls into the middle half, therefore, at least \\(\\lceil n/4\\rceil-1\\) elements less than the pivot or \\(\\lceil n/4\\rceil-1\\) elements greater than the pivot, plus the pivot, will no longer be in play after partitioning. That is, at least \\(\\lceil n/4\\rceil\\) elements will no longer be in play. The number of elements remaining in play will be at most \\(n-\\lceil n/4\\rceil\\), which equals \\(\\lfloor 3n/4\\rfloor\\) by Exercise 3.3-2 on page 70. Since \\(\\lfloor 3n/4\\rfloor\\leq 3n/4\\), the partitioning is helpful.\n\nTo determine a lower bound on the probability that a randomly chosen pivot falls into the middle half, we determine an upper bound on the probability that it does not. That probability is\n\n\\[\\frac{2(\\lceil n/4\\rceil-1)}{n} \\leq\\ \\frac{2((n/4+1)-1)}{n}\\quad\\mbox{(by inequality \\eqref{eq:prob_eq} on page 64)}\\] \\[=\\ \\frac{n/2}{n}\\] \\[=\\ 1/2\\.\\]\n\nThus, the pivot has a probability of at least \\(1/2\\) of falling into the middle half, and so the probability is at least \\(1/2\\) that a partitioning is helpful.\n\nWe can now bound the expected running time of Randomized-Select.\n\n**Theorem 9.2**: _The procedure Randomized-Select on an input array of \\(n\\) distinct elements has an expected running time of \\(\\Theta(n)\\)._\n\nProofSince not every partitioning is necessarily helpful, let's give each partitioning an index starting at \\(0\\) and denote by \\(\\langle h_{0},\\,h_{1},\\,h_{2},\\,\\ldots,\\,h_{m}\\rangle\\) the sequence of partitionings that are helpful, so that the \\(h_{k}\\)th partitioning is helpful for \\(k=0,1,2,\\ldots,m\\). Although the number \\(m\\) of helpful partitionings is a random variable, we can bound it, since after at most \\(\\lceil\\log_{4/3}n\\rceil\\) helpful partitionings, only one element remains in play. Consider the dummy 0th partitioning as helpful, so that \\(h_{0}=0\\). Denote \\(|A^{(h_{k})}|\\) by \\(n_{k}\\), where \\(n_{0}=|A^{(0)}|\\) is the original problem size. Since the \\(h_{k}\\)th partitioning is helpful and the sizes of the sets \\(A^{(j)}\\) strictly decrease, we have \\(n_{k}=|A^{(h_{k})}|\\leq(3/4)|A^{(h_{k}-1)}|=(3/4)\\,n_{k-1}\\) for \\(k=1,2,\\ldots,m\\). By iterating \\(n_{k}\\leq(3/4)\\,n_{k-1}\\), we have that \\(n_{k}\\leq(3/4)^{k}n_{0}\\) for \\(k=0,1,2,\\ldots,m\\).\n\nAs Figure 9.2 depicts, we break up the sequence of sets \\(A^{(j)}\\) into \\(m\\)_generations_ consisting of consecutively partitioned sets, starting with the result \\(A^{(h_{k})}\\) of a helpful partitioning and ending with the last set \\(A^{(h_{k+1}-1)}\\) before the next helpful partitioning, so that the sets in generation \\(k\\) are \\(A^{(h_{k})}\\), \\(A^{(h_{k}+1)},\\ldots,A^{(h_{k+1}-1)}\\). Then for each set of elements \\(A^{(j)}\\)in the \\(k\\)th generation, we have that \\(|A^{(j)}|\\leq|A^{(h_{k})}|=n_{k}\\leq(3/4)^{k}n_{0}\\).\n\nNext, we define the random variable\n\n\\[X_{k}=h_{k+1}-h_{k}\\]\n\nfor \\(k=0,1,2,\\ldots,m-1\\). That is, \\(X_{k}\\) is the number of sets in the \\(k\\)th generation, so that the sets in the \\(k\\)th generation are \\(A^{(h_{k})}\\), \\(A^{(h_{k}+1)},\\ldots,A^{(h_{k}+X_{k}-1)}\\).\n\nBy Lemma 9.1, the probability that a partitioning is helpful is at least \\(1/2\\). The probability is actually even higher, since a partitioning is helpful even if the pivot\n\nFigure 9.2: The sets within each generation in the proof of Theorem 9.2. Vertical lines represent the sets, with the height of each line indicating the size of the set, which equals the number of elements in play. Each generation starts with a set \\(A^{(h_{k})}\\), which is the result of a helpful partitioning. These sets are drawn in black and are at most \\(3/4\\) the size of the sets to their immediate left. Sets drawn in orange are not the first within a generation. A generation may contain just one set. The sets in generation \\(k\\) are \\(A^{(h_{k})}\\), \\(A^{(h_{k}+1)}\\), \\(\\ldots,A^{(h_{k}+1-1)}\\). The sets \\(A^{(h_{k})}\\) are defined so that \\(|A^{(h_{k})}|\\leq(3/4)|A^{(h_{k}-1)}|\\). If the partitioning gets all the way to generation \\(h_{m}\\), set \\(A^{(h_{m})}\\) has at most one element in play.\n\ndoes not fall into the middle half but the \\(i\\)th smallest element happens to lie in the smaller side of the partitioning. We'll just use the lower bound of \\(1/2\\), however, and then equation (C.36) gives that \\(\\mathrm{E}\\left[X_{k}\\right]\\leq 2\\) for \\(k=0,1,2,\\ldots,m-1\\).\n\nLet's derive an upper bound on how many comparisons are made altogether during partitioning, since the running time is dominated by the comparisons. Since we are calculating an upper bound, assume that the recursion goes all the way until only one element remains in play. The \\(j\\)th partitioning takes the set \\(A^{(j-1)}\\) of elements in play, and it compares the randomly chosen pivot with all the other \\(|A^{(j-1)}|-1\\) elements, so that the \\(j\\)th partitioning makes fewer than \\(|A^{(j-1)}|\\) comparisons. The sets in the \\(k\\)th generation have sizes \\(|A^{(h_{k})}|,|A^{(h_{k}+1)}|,\\ldots,\\)\\(|A^{(h_{k}+X_{k}-1)}|\\). Thus, the total number of comparisons during partitioning is less than\n\n\\[\\sum_{k=0}^{m-1}\\sum_{j=h_{k}}^{h_{k}+X_{k}-1}|A^{(j)}| \\leq \\sum_{k=0}^{m-1}\\sum_{j=h_{k}}^{h_{k}+X_{k}-1}|A^{(h_{k})}|\\] \\[= \\sum_{k=0}^{m-1}X_{k}\\ |A^{(h_{k})}|\\] \\[\\leq \\sum_{k=0}^{m-1}X_{k}\\left(\\frac{3}{4}\\right)^{k}n_{0}\\.\\]\n\nSince \\(\\mathrm{E}\\left[X_{k}\\right]\\leq 2\\), we have that the expected total number of comparisons during partitioning is less than\n\n\\[\\mathrm{E}\\left[\\sum_{k=0}^{m-1}X_{k}\\left(\\frac{3}{4}\\right)^{k }n_{0}\\right] = \\sum_{k=0}^{m-1}\\mathrm{E}\\left[X_{k}\\left(\\frac{3}{4}\\right)^{k }n_{0}\\right]\\Partition, giving a lower bound of \\(\\Omega(n)\\). Hence the expected running time is \\(\\Theta(n)\\). \n\n### Exercises\n\n#### 9.2-1\n\nShow that Randomized-Select never makes a recursive call to a 0-length array.\n\n#### 9.2-2\n\nWrite an iterative version of Randomized-Select.\n\n#### 9.2-3\n\nSuppose that Randomized-Select is used to select the minimum element of the array \\(A=\\langle 2,3,0,5,7,9,1,8,6,4\\rangle\\). Describe a sequence of partitions that results in a worst-case performance of Randomized-Select.\n\n#### 9.2-4\n\nArgue that the expected running time of Randomized-Select does not depend on the order of the elements in its input array \\(A[p:r]\\). That is, the expected running time is the same for any permutation of the input array \\(A[p:r]\\). (_Hint:_ Argue by induction on the length \\(n\\) of the input array.)\n\n### Selection in worst-case linear time\n\nWe'll now examine a remarkable and theoretically interesting selection algorithm whose running time is \\(\\Theta(n)\\) in the worst case. Although the Randomized-Select algorithm from Section 9.2 achieves linear expected time, we saw that its running time in the worst case was quadratic. The selection algorithm presented in this section achieves linear time in the worst case, but it is not nearly as practical as Randomized-Select. It is mostly of theoretical interest.\n\nLike the expected linear-time Randomized-Select, the worst-case linear-time algorithm Select finds the desired element by recursively partitioning the input array. Unlike Randomized-Select, however, Select_guarantees_ a good split by choosing a provably good pivot when partitioning the array. The cleverness in the algorithm is that it finds the pivot recursively. Thus, there are two invocations of Select: one to find a good pivot, and a second to recursively find the desired order statistic.\n\nThe partitioning algorithm used by Select is like the deterministic partitioning algorithm Partition from quicksort (see Section 7.1), but modified to take the element to partition around as an additional input parameter. Like Partition, the",
        "chapter": "Part II Sorting and Order Statistics",
        "section": "9 Medians and Order Statistics",
        "subsection": "9.2 Selection in expected linear time",
        "subsubsection": "N/A"
    },
    {
        "content": "Partition, giving a lower bound of \\(\\Omega(n)\\). Hence the expected running time is \\(\\Theta(n)\\). \n\n### Exercises\n\n#### 9.2-1\n\nShow that Randomized-Select never makes a recursive call to a 0-length array.\n\n#### 9.2-2\n\nWrite an iterative version of Randomized-Select.\n\n#### 9.2-3\n\nSuppose that Randomized-Select is used to select the minimum element of the array \\(A=\\langle 2,3,0,5,7,9,1,8,6,4\\rangle\\). Describe a sequence of partitions that results in a worst-case performance of Randomized-Select.\n\n#### 9.2-4\n\nArgue that the expected running time of Randomized-Select does not depend on the order of the elements in its input array \\(A[p:r]\\). That is, the expected running time is the same for any permutation of the input array \\(A[p:r]\\). (_Hint:_ Argue by induction on the length \\(n\\) of the input array.)\n\n### Selection in worst-case linear time\n\nWe'll now examine a remarkable and theoretically interesting selection algorithm whose running time is \\(\\Theta(n)\\) in the worst case. Although the Randomized-Select algorithm from Section 9.2 achieves linear expected time, we saw that its running time in the worst case was quadratic. The selection algorithm presented in this section achieves linear time in the worst case, but it is not nearly as practical as Randomized-Select. It is mostly of theoretical interest.\n\nLike the expected linear-time Randomized-Select, the worst-case linear-time algorithm Select finds the desired element by recursively partitioning the input array. Unlike Randomized-Select, however, Select_guarantees_ a good split by choosing a provably good pivot when partitioning the array. The cleverness in the algorithm is that it finds the pivot recursively. Thus, there are two invocations of Select: one to find a good pivot, and a second to recursively find the desired order statistic.\n\nThe partitioning algorithm used by Select is like the deterministic partitioning algorithm Partition from quicksort (see Section 7.1), but modified to take the element to partition around as an additional input parameter. Like Partition, the \n\n### Selection in worst-case linear time\n\nPartition-Around algorithm returns the index of the pivot. Since it's so similar to Partition, the pseudocode for Partition-Around is omitted.\n\nThe Select procedure takes as input a subarray \\(A[p:r]\\) of \\(n=r-p+1\\) elements and an integer \\(i\\) in the range \\(1\\leq i\\leq n\\). It returns the \\(i\\)th smallest element of \\(A\\). The pseudocode is actually more understandable than it might appear at first.\n\nSelect(\\(A\\), \\(p\\), \\(r\\), \\(i\\))\n\n```\n1while(\\(r-p+1\\)) mod \\(5\\neq 0\\)\n2for\\(j=p+1\\)to\\(r\\)// put the minimum into \\(A[p]\\)\n3if\\(A[p]>A[j]\\)\n4 exchange \\(A[p]\\) with \\(A[j]\\)\n5// If we want the minimum of \\(A[p:r]\\), we're done.\n6if\\(i==1\\)return\\(A[p]\\)\n7// Otherwise, we want the \\((i-1)\\)st element of \\(A[p+1:r]\\).\n8\\(p=p+1\\)\n9\\(i=i-1\\)\n10\\(g=(r-p+1)/5\\)// number of 5-element groups\n11for\\(j=p\\)to\\(p+g-1\\)// sort each group\n12sort \\(\\langle A[j],A[j+g],A[j+2g],A[j+3g],A[j+4g]\\rangle\\) in place\n13// All group medians now lie in the middle fifth of \\(A[p:r]\\).\n14// Find the pivot \\(x\\) recursively as the median of the group medians.\n15\\(x=\\)Select(\\(A\\), \\(p+2g\\), \\(p+3g-1,\\lceil g/2\\rceil\\))\n16\\(q=\\)Partition-Around(\\(A\\), \\(p\\), \\(r\\)) // partition around the pivot\n17// The rest is just like lines 3-9 of Randomized-Select.\n18\\(k=q-p+1\\)\n19if\\(i==k\\)\n20return\\(A[q]\\)// the pivot value is the answer\n21elseif\\(i<k\\)\n22returnSelect(\\(A\\), \\(p\\), \\(q-1\\), \\(i\\))\n23elsereturnSelect(\\(A\\), \\(q+1\\), \\(r\\), \\(i-k\\))\n```\n\nThe pseudocode starts by executing the **while** loop in lines 1-10 to reduce the number \\(r-p+1\\) of elements in the subarray until it is divisible by 5. The **while** loop executes 0 to 4 times, each time rearranging the elements of \\(A[p:r]\\) so that \\(A[p]\\) contains the minimum element. If \\(i=1\\), which means that we actually want the minimum element, then the procedure simply returns it in line 7. Otherwise, Select eliminates the minimum from the subarray \\(A[p:r]\\) and iterates to find the \\((i-1)\\)st element in \\(A[p+1:r]\\). Lines 9-10 do so by incrementing \\(p\\) and decrementing \\(i\\). If the **while** loop completes all of its iterations without returning aresult, the procedure executes the core of the algorithm in lines 11-24, assured that the number \\(r-p+1\\) of elements in \\(A[p:r]\\) is evenly divisible by 5.\n\nThe next part of the algorithm implements the following idea, illustrated in Figure 9.3. Divide the elements in \\(A[p:r]\\) into \\(g=(r-p+1)/5\\) groups of 5 elements each. The first 5-element group is\n\n\\[\\langle A[p],A[p+g],A[p+2g],A[p+3g],A[p+4g]\\rangle\\,\\]\n\nthe second is\n\n\\[\\langle A[p+1],A[p+g+1],A[p+2g+1],A[p+3g+1],A[p+4g+1]\\rangle\\,\\]\n\nand so forth until the last, which is\n\n\\[\\langle A[p+g-1],A[p+2g-1],A[p+3g-1],A[p+4g-1],A[r]\\rangle\\.\\]\n\n(Note that \\(r=p+5g-1\\).) Line 13 puts each group in order using, for example, insertion sort (Section 2.1), so that for \\(j=p\\), \\(p+1,\\ldots,p+g-1\\), we have\n\nFigure 9.3: The relationships between elements (shown as circles) immediately after line 17 of the selection algorithm Select. There are \\(g=(r-p+1)/5\\) groups of 5 elements, each of which occupies a column. For example, the leftmost column contains elements \\(A[p]\\), \\(A[p+g]\\), \\(A[p+2g]\\), \\(A[p+3g]\\), \\(A[p+4g]\\), and the next column contains \\(A[p+1]\\), \\(A[p+g+1]\\), \\(A[p+2g+1]\\), \\(A[p+3g+1]\\), \\(A[p+4g+1]\\). The medians of the groups are red, and the pivot \\(x\\) is labeled. Arrows go from smaller elements to larger. The elements on the blue background are all known to be less than or equal to \\(x\\) and cannot fall into the high side of the partition around \\(x\\). The elements on the yellow background are known to be greater than or equal to \\(x\\) and cannot fall into the low side of the partition around \\(x\\). The pivot \\(x\\) belongs to both the blue and yellow regions and is shown on a green background. The elements on the white background could lie on either side of the partition.\n\n\\(A[j]\\leq A[j\\,+\\,g]\\leq A[j\\,+\\,2g]\\leq A[j\\,+\\,3g]\\leq A[j\\,+\\,4g]\\).\n\nEach vertical column in Figure 9.3 depicts a sorted group of 5 elements. The median of each 5-element group is \\(A[j\\,+\\,2g]\\), and thus all the 5-element medians, shown in red, lie in the range \\(A[p\\,+\\,2g\\,:\\,p\\,+\\,3g\\,-\\,1]\\).\n\nNext, line 16 determines the pivot \\(x\\) by recursively calling Select to find the median (specifically, the \\(\\lceil g/2\\rceil\\)th smallest) of the \\(g\\) group medians. Line 17 uses the modified Partition-Around algorithm to partition the elements of \\(A[p\\,:\\,r]\\) around \\(x\\), returning the index \\(q\\) of \\(x\\), so that \\(A[q]=x\\), elements in \\(A[p\\,:\\,q]\\) are all at most \\(x\\), and elements in \\(A[q\\,:\\,r]\\) are greater than or equal to \\(x\\).\n\nThe remainder of the code mirrors that of Randomized-Select. If the pivot \\(x\\) is the \\(i\\)th largest, the procedure returns it. Otherwise, the procedure recursively calls itself on either \\(A[p\\,:\\,q-1]\\) or \\(A[q\\,+\\,1\\,:\\,r]\\), depending on the value of \\(i\\).\n\nLet's analyze the running time of Select and see how the judicious choice of the pivot \\(x\\) plays into a guarantee on its worst-case running time.\n\n**Theorem 9.3**: _The running time of Select on an input of \\(n\\) elements is \\(\\Theta(n)\\)._\n\nProofDefine \\(T(n)\\) as the worst-case time to run Select on any input subarray \\(A[p\\,:\\,r]\\) of size at most \\(n\\), that is, for which \\(r-p+1\\leq n\\). By this definition, \\(T(n)\\) is monotonically increasing.\n\nWe first determine an upper bound on the time spent outside the recursive calls in lines 16, 23, and 24. The **while** loop in lines 1-10 executes 0 to 4 times, which is \\(O(1)\\) times. Since the dominant time within the loop is the computation of the minimum in lines 2-4, which takes \\(\\Theta(n)\\) time, lines 1-10 execute in \\(O(1)\\cdot\\Theta(n)=O(n)\\) time. The sorting of the 5-element groups in lines 12-13 takes \\(\\Theta(n)\\) time because each 5-element group takes \\(\\Theta(1)\\) time to sort (even using an asymptotically inefficient sorting algorithm such as insertion sort), and there are \\(g\\) elements to sort, where \\(n/5-1<g\\leq n/5\\). Finally, the time to partition in line 17 is \\(\\Theta(n)\\), as Exercise 7.1-3 on page 187 asks you to show. Because the remaining bookkeeping only costs \\(\\Theta(1)\\) time, the total amount of time spent outside of the recursive calls is \\(O(n)\\) + \\(\\Theta(n)\\) + \\(\\Theta(n)\\) + \\(\\Theta(1)=\\Theta(n)\\).\n\nNow let's determine the running time for the recursive calls. The recursive call to find the pivot in line 16 takes \\(T(g)\\leq T(n/5)\\) time, since \\(g\\leq n/5\\) and \\(T(n)\\) monotonically increases. Of the two recursive calls in lines 23 and 24, at most one is executed. But we'll see that no matter which of these two recursive calls to Select actually executes, the number of elements in the recursive call turns out to be at most \\(7n/10\\), and hence the worst-case cost for lines 23 and 24 is at most \\(T(7n/10)\\). Let's now show that the machinations with group medians and the choice of the pivot \\(x\\) as the median of the group medians guarantees this property.\n\nFigure 9.3 helps to visualize what's going on. There are \\(g\\leq n/5\\) groups of 5 elements, with each group shown as a column sorted from bottom to top. The arrows show the ordering of elements within the columns. The columns are ordered from left to right with groups to the left of \\(x\\)'s group having a group median less than \\(x\\) and those to the right of \\(x\\)'s group having a group median greater than \\(x\\). Although the relative order within each group matters, the relative order among groups to the left of \\(x\\)'s column doesn't really matter, and neither does the relative order among groups to the right of \\(x\\)'s column. The important thing is that the groups to the left have group medians less than \\(x\\) (shown by the horizontal arrows entering \\(x\\)), and that the groups to the right have group medians greater than \\(x\\) (shown by the horizontal arrows leaving \\(x\\)). Thus, the yellow region contains elements that we know are greater than or equal to \\(x\\), and the blue region contains elements that we know are less than or equal to \\(x\\).\n\nThese two regions each contain at least \\(3g/2\\) elements. The number of group medians in the yellow region is \\(\\lfloor g/2\\rfloor+1\\), and for each group median, two additional elements are greater than it, making a total of \\(3(\\lfloor g/2\\rfloor+1)\\geq 3g/2\\) elements. Similarly, the number of group medians in the blue region is \\(\\lceil g/2\\rceil\\), and for each group median, two additional elements are less than it, making a total of \\(3\\lceil g/2\\rceil\\geq 3g/2\\).\n\nThe elements in the yellow region cannot fall into the low side of the partition around \\(x\\), and those in the blue region cannot fall into the high side. The elements in neither region--those lying on a white background--could fall into either side of the partition. But since the low side of the partition excludes the elements in the yellow region, and there are a total of \\(5g\\) elements, we know that the low side of the partition can contain at most \\(5g-3g/2=7g/2\\leq 7n/10\\) elements. Likewise, the high side of the partition excludes the elements in the blue region, and a similar calculation shows that it also contains at most \\(7n/10\\) elements.\n\nAll of which leads to the following recurrence for the worst-case running time of Select:\n\n\\[T(n)\\leq T(n/5)+T(7n/10)+\\Theta(n). \\tag{9.1}\\]\n\nWe can show that \\(T(n)=O(n)\\) by substitution.2 More specifically, we'll prove that \\(T(n)\\leq cn\\) for some suitably large constant \\(c>0\\) and all \\(n>0\\). Substituting this inductive hypothesis into the right-hand side of recurrence (9.1) and assuming that \\(n\\geq 5\\) yields\n\nFootnote 2: We could also use the Akra-Bazzi method from Section 4.7, which involves calculus, to solve this recurrence. Indeed, a similar recurrence (4.24) on page 117 was used to illustrate that method.\n\n\\[T(n) \\leq c(n/5)+c(7n/10)+\\Theta(n)\\] \\[\\leq 9cn/10+\\Theta(n)\\] \\[= cn-cn/10+\\Theta(n)\\] \\[\\leq cn\\]\n\nif \\(c\\) is chosen large enough that \\(c/10\\) dominates the upper-bound constant hidden by the \\(\\Theta(n)\\). In addition to this constraint, we can pick \\(c\\) large enough that \\(T(n)\\leq cn\\) for all \\(n\\leq 4\\), which is the base case of the recursion within Select. The running time of Select is therefore \\(O(n)\\) in the worst case, and because line 13 alone takes \\(\\Theta(n)\\) time, the total time is \\(\\Theta(n)\\).\n\nAs in a comparison sort (see Section 8.1), Select and Randomized-Select determine information about the relative order of elements only by comparing elements. Recall from Chapter 8 that sorting requires \\(\\Omega(n\\lg n)\\) time in the comparison model, even on average (see Problem 8-1). The linear-time sorting algorithms in Chapter 8 make assumptions about the type of the input. In contrast, the linear-time selection algorithms in this chapter do not require any assumptions about the input's type, only that the elements are distinct and can be pairwise compared according to a linear order. The algorithms in this chapter are not subject to the \\(\\Omega(n\\lg n)\\) lower bound, because they manage to solve the selection problem without sorting all the elements. Thus, solving the selection problem by sorting and indexing, as presented in the introduction to this chapter, is asymptotically inefficient in the comparison model.\n\n### Exercises\n\n#### 9.3-1\n\nIn the algorithm Select, the input elements are divided into groups of 5. Show that the algorithm works in linear time if the input elements are divided into groups of 7 instead of 5.\n\n#### 9.3-2\n\nSuppose that the preprocessing in lines 1-10 of Select is replaced by a base case for \\(n\\geq n_{0}\\), where \\(n_{0}\\) is a suitable constant; that \\(g\\) is chosen as \\(\\lfloor r-p+1)/5\\rfloor\\); and that the elements in \\(A[5g:n]\\) belong to no group. Show that although the recurrence for the running time becomes messier, it still solves to \\(\\Theta(n)\\).\n\n#### 9.3-3\n\nShow how to use Select as a subroutine to make quicksort run in \\(O(n\\lg n)\\) time in the worst case, assuming that all elements are distinct.\n\n* _9.3-4_ Suppose that an algorithm uses only comparisons to find the \\(i\\)th smallest element in a set of \\(n\\) elements. Show that it can also find the \\(i-1\\) smaller elements and the \\(n-i\\) larger elements without performing any additional comparisons. _9.3-5_ Show how to determine the median of a 5-element set using only 6 comparisons. _9.3-6_ You have a \"black-box\" worst-case linear-time median subroutine. Give a simple, linear-time algorithm that solves the selection problem for an arbitrary order statistic. _9.3-7_ Professor Olay is consulting for an oil company, which is planning a large pipeline running east to west through an oil field of \\(n\\) wells. The company wants to connect a spur pipeline from each well directly to the main pipeline along a shortest route (either north or south), as shown in Figure 9.4. Given the \\(x\\)- and \\(y\\)-coordinates of the wells, how should the professor pick an optimal location of the main pipeline to minimize the total length of the spurs? Show how to determine an optimal location in linear time. _9.3-8_ The \\(k\\)th _quantiles_ of an \\(n\\)-element set are the \\(k-1\\) order statistics that divide the sorted set into \\(k\\) equal-sized sets (to within 1). Give an \\(O(n\\lg k)\\)-time algorithm to list the \\(k\\)th quantiles of a set.\n\nFigure 9.4: Professor Olay needs to determine the position of the east-west oil pipeline that minimizes the total length of the north-south spurs.\n\nDescribe an \\(O(n)\\)-time algorithm that, given a set \\(S\\) of \\(n\\) distinct numbers and a positive integer \\(k\\leq n\\), determines the \\(k\\) numbers in \\(S\\) that are closest to the median of \\(S\\).\n\nLet \\(X[1:n]\\) and \\(Y[1:n]\\) be two arrays, each containing \\(n\\) numbers already in sorted order. Give an \\(O(\\lg n)\\)-time algorithm to find the median of all \\(2n\\) elements in arrays \\(X\\) and \\(Y\\). Assume that all \\(2n\\) numbers are distinct.\n\n## Problems\n\n1 \\(\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\! \\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\! \\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\! \\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\! \\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\! \\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\! \\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\! \\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\! \\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\! \\!\\!",
        "chapter": "Part II Sorting and Order Statistics",
        "section": "9 Medians and Order Statistics",
        "subsection": "9.3 Selection in worst-case linear time",
        "subsubsection": "N/A"
    },
    {
        "content": "Describe an \\(O(n)\\)-time algorithm that, given a set \\(S\\) of \\(n\\) distinct numbers and a positive integer \\(k\\leq n\\), determines the \\(k\\) numbers in \\(S\\) that are closest to the median of \\(S\\).\n\nLet \\(X[1:n]\\) and \\(Y[1:n]\\) be two arrays, each containing \\(n\\) numbers already in sorted order. Give an \\(O(\\lg n)\\)-time algorithm to find the median of all \\(2n\\) elements in arrays \\(X\\) and \\(Y\\). Assume that all \\(2n\\) numbers are distinct.\n\n## Problems\n\n1 \\(\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\! \\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\! \\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\! \\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\! \\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\! \\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\! \\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\! \\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\! \\!\\!\nArgue that in the worst case, Simpler-Randomized-Select never terminates.\n\nProve that the expected running time of Simpler-Randomized-Select is still \\(O(n)\\).\n\n### Weighted median\n\nConsider \\(n\\) elements \\(x_{1},x_{2},\\ldots,x_{n}\\) with positive weights \\(w_{1},w_{2},\\ldots,w_{n}\\) such that \\(\\sum_{i=1}^{n}w_{i}=1\\). The _weighted (lower) median_ is an element \\(x_{k}\\) satisfying\n\n\\[\\sum_{x_{i}\\prec x_{k}}w_{i}\\,<\\frac{1}{2}\\]\n\nand\n\n\\[\\sum_{x_{i}\\,\\succ\\,x_{k}}w_{i}\\,\\leq\\frac{1}{2}\\.\\]\n\nFor example, consider the following elements \\(x_{i}\\) and weights \\(w_{i}\\):\n\n\\begin{tabular}{l|c c c c c c c} \\(i\\) & 1 & 2 & 3 & 4 & 5 & 6 & 7 \\\\ \\hline \\(x_{i}\\) & 3 & 8 & 2 & 5 & 4 & 1 & 6 \\\\ \\(w_{i}\\) & 0.12 & 0.35 & 0.025 & 0.08 & 0.15 & 0.075 & 0.2 \\\\ \\end{tabular} For these elements, the median is \\(x_{5}=4\\), but the weighted median is \\(x_{7}=6\\). To see why the weighted median is \\(x_{7}\\), observe that the elements less than \\(x_{7}\\) are \\(x_{1}\\), \\(x_{3}\\), \\(x_{4}\\), \\(x_{5}\\), and \\(x_{6}\\), and the sum \\(w_{1}+w_{3}+w_{4}+w_{5}+w_{6}=0.45\\), which is less than \\(1/2\\). Furthermore, only element \\(x_{2}\\) is greater than \\(x_{7}\\), and \\(w_{2}=0.35\\), which is no greater than \\(1/2\\).\n\nArgue that the median of \\(x_{1},x_{2},\\ldots,x_{n}\\) is the weighted median of the \\(x_{i}\\) with weights \\(w_{i}=1/n\\) for \\(i=1,2,\\ldots,n\\).\n\nShow how to compute the weighted median of \\(n\\) elements in \\(O(n\\lg n)\\) worst-case time using sorting.\n\nShow how to compute the weighted median in \\(\\Theta(n)\\) worst-case time using a linear-time median algorithm such as Select from Section 9.3.\n\nThe _post-office location problem_ is defined as follows. The input is \\(n\\) points \\(p_{1},\\,p_{2},\\ldots,p_{n}\\) with associated weights \\(w_{1},w_{2},\\ldots,w_{n}\\). A solution is a point \\(p\\) (not necessarily one of the input points) that minimizes the sum \\(\\sum_{i=1}^{n}w_{i}\\,d(p,\\,p_{i})\\), where \\(d(a,b)\\) is the distance between points \\(a\\) and \\(b\\).\n\n_d._ Argue that the weighted median is a best solution for the one-dimensional post-office location problem, in which points are simply real numbers and the distance between points \\(a\\) and \\(b\\) is \\(d(a,b)=|a-b|\\).\n\n_e._ Find the best solution for the two-dimensional post-office location problem, in which the points are \\((x,y)\\) coordinate pairs and the distance between points \\(a=(x_{1},y_{1})\\) and \\(b=(x_{2},y_{2})\\) is the _Manhattan distance_ given by \\(d(a,b)=|x_{1}-x_{2}|+|y_{1}-y_{2}|\\).\n\n### Small order statistics\n\nLet's denote by \\(S(n)\\) the worst-case number of comparisons used by Select to select the \\(i\\)th order statistic from \\(n\\) numbers. Although \\(S(n)=\\Theta(n)\\), the constant hidden by the \\(\\Theta\\)-notation is rather large. When \\(i\\) is small relative to \\(n\\), there is an algorithm that uses Select as a subroutine but makes fewer comparisons in the worst case.\n\n_a._ Describe an algorithm that uses \\(U_{i}(n)\\) comparisons to find the \\(i\\)th smallest of \\(n\\) elements, where\n\n\\[U_{i}(n)=\\left\\{\\begin{array}{ll}S(n)&\\mbox{if $i\\,\\geq n/2$}\\;,\\\\ \\lfloor n/2\\rfloor+U_{i}(\\lceil n/2\\rceil)+S(2i)&\\mbox{otherwise}\\;.\\end{array}\\right.\\]\n\n(_Hint:_ Begin with \\(\\lfloor n/2\\rfloor\\) disjoint pairwise comparisons, and recurse on the set containing the smaller element from each pair.)\n\n_b._ Show that, if \\(i\\,<n/2\\), then \\(U_{i}(n)=n\\,+\\,O(S(2i)\\lg(n/i))\\).\n\n_c._ Show that if \\(i\\) is a constant less than \\(n/2\\), then \\(U_{i}(n)=n\\,+\\,O(\\lg n)\\).\n\n_d._ Show that if \\(i\\,=n/k\\) for \\(k\\geq 2\\), then \\(U_{i}(n)=n\\,+\\,O(S(2n/k)\\lg k)\\).\n\n### Alternative analysis of randomized selection\n\nIn this problem, you will use indicator random variables to analyze the procedure Randomized-Select in a manner akin to our analysis of Randomized-Quicksort in Section 7.4.2.\n\nAs in the quicksort analysis, we assume that all elements are distinct, and we rename the elements of the input array \\(A\\) as \\(z_{1},z_{2},\\ldots,z_{n}\\), where \\(z_{i}\\) is the \\(i\\)th smallest element. Thus the call Randomized-Select(\\(A,1,n,i\\)) returns \\(z_{i}\\).\n\nFor \\(1\\,\\leq\\,j\\,<k\\,\\leq n\\), let\n\n\\[X_{ijk}=\\mbox{I}\\left\\{\\begin{array}{ll}z_{j}&\\mbox{is $z_{k}$ sometime during the execution of the algorithm to find $z_{i}$}\\end{array}\\right.\\]* Give an exact expression for \\(\\mathrm{E}\\left[X_{ijk}\\right]\\). (_Hint:_ Your expression may have different values, depending on the values of \\(i\\), \\(j\\), and \\(k\\).)\n* Let \\(X_{i}\\) denote the total number of comparisons between elements of array \\(A\\) when finding \\(z_{i}\\). Show that \\[\\mathrm{E}\\left[X_{i}\\right]\\leq 2\\left(\\sum_{j=1}^{i}\\sum_{k=i}^{n}\\frac{1}{k-j \\,+\\,1}\\,+\\,\\sum_{k=i\\,+\\,1}^{n}\\frac{k-i\\,-\\,1}{k-i\\,+\\,1}\\,+\\,\\sum_{j=1}^{i -2}\\frac{i\\,-\\,j\\,-\\,1}{i\\,-\\,j\\,+\\,1}\\right)\\.\\]\n* Show that \\(\\mathrm{E}\\left[X_{i}\\right]\\leq 4n\\).\n* Conclude that, assuming all elements of array \\(A\\) are distinct, Randomized-Select runs in \\(O(n)\\) expected time.\n\n### 9.6 Select with groups of 3\n\nExercise 9.3-1 asks you to show that the Select algorithm still runs in linear time if the elements are divided into groups of 7. This problem asks about dividing into groups of 3.\n\n* Show that Select runs in linear time if you divide the elements into groups whose size is any odd constant greater than 3.\n* Show that Select runs in \\(O(n\\lg n)\\) time if you divide the elements into groups of size 3.\n\nBecause the bound in part (b) is just an upper bound, we do not know whether the groups-of-3 strategy actually runs in \\(O(n)\\) time. But by repeating the groups-of-3 idea on the middle group of medians, we can pick a pivot that guarantees \\(O(n)\\) time. The Select3 algorithm on the next page determines the \\(i\\)th smallest of an input array of \\(n>1\\) distinct elements.\n* Describe in English how the Select3 algorithm works. Include in your description one or more suitable diagrams.\n* Show that Select3 runs in \\(O(n)\\) time in the worst case.\n\n## Chapter notes\n\nThe worst-case linear-time median-finding algorithm was devised by Blum, Floyd, Pratt, Rivest, and Tarjan [62]. The fast randomized version is due to Hoare [218]. Floyd and Rivest [147] have developed an improved randomized version that partitions around an element recursively selected from a small sample of the elements.",
        "chapter": "Part II Sorting and Order Statistics",
        "section": "9 Medians and Order Statistics",
        "subsection": "Problems",
        "subsubsection": "N/A"
    },
    {
        "content": "* Give an exact expression for \\(\\mathrm{E}\\left[X_{ijk}\\right]\\). (_Hint:_ Your expression may have different values, depending on the values of \\(i\\), \\(j\\), and \\(k\\).)\n* Let \\(X_{i}\\) denote the total number of comparisons between elements of array \\(A\\) when finding \\(z_{i}\\). Show that \\[\\mathrm{E}\\left[X_{i}\\right]\\leq 2\\left(\\sum_{j=1}^{i}\\sum_{k=i}^{n}\\frac{1}{k-j \\,+\\,1}\\,+\\,\\sum_{k=i\\,+\\,1}^{n}\\frac{k-i\\,-\\,1}{k-i\\,+\\,1}\\,+\\,\\sum_{j=1}^{i -2}\\frac{i\\,-\\,j\\,-\\,1}{i\\,-\\,j\\,+\\,1}\\right)\\.\\]\n* Show that \\(\\mathrm{E}\\left[X_{i}\\right]\\leq 4n\\).\n* Conclude that, assuming all elements of array \\(A\\) are distinct, Randomized-Select runs in \\(O(n)\\) expected time.\n\n### Select with groups of 3\n\nExercise 9.3-1 asks you to show that the Select algorithm still runs in linear time if the elements are divided into groups of 7. This problem asks about dividing into groups of 3.\n\n* Show that Select runs in linear time if you divide the elements into groups whose size is any odd constant greater than 3.\n* Show that Select runs in \\(O(n\\lg n)\\) time if you divide the elements into groups of size 3.\n\nBecause the bound in part (b) is just an upper bound, we do not know whether the groups-of-3 strategy actually runs in \\(O(n)\\) time. But by repeating the groups-of-3 idea on the middle group of medians, we can pick a pivot that guarantees \\(O(n)\\) time. The Select3 algorithm on the next page determines the \\(i\\)th smallest of an input array of \\(n>1\\) distinct elements.\n* Describe in English how the Select3 algorithm works. Include in your description one or more suitable diagrams.\n* Show that Select3 runs in \\(O(n)\\) time in the worst case.\n\n## Chapter notes\n\nThe worst-case linear-time median-finding algorithm was devised by Blum, Floyd, Pratt, Rivest, and Tarjan [62]. The fast randomized version is due to Hoare [218]. Floyd and Rivest [147] have developed an improved randomized version that partitions around an element recursively selected from a small sample of the elements.\n\nIt is still unknown exactly how many comparisons are needed to determine the median. Bent and John [49] gave a lower bound of \\(2n\\) comparisons for median finding, and Schonhage, Paterson, and Pippenger [398] gave an upper bound of \\(3n\\). Dor and Zwick have improved on both of these bounds. Their upper bound [124] is slightly less than \\(2.95n\\), and their lower bound [125] is \\((2+\\epsilon)n\\), for a small positive constant \\(\\epsilon\\), thereby improving slightly on related work by Dor et al. [123]. Paterson [355] describes some of these results along with other related work.\n\nProblem 9-6 was inspired by a paper by Chen and Dumitrescu [85].\n\n## Part III Data Structures",
        "chapter": "Part II Sorting and Order Statistics",
        "section": "9 Medians and Order Statistics",
        "subsection": "Chapter notes",
        "subsubsection": "N/A"
    },
    {
        "content": "## Introduction\n\nSets are as fundamental to computer science as they are to mathematics. Whereas mathematical sets are unchanging, the sets manipulated by algorithms can grow, shrink, or otherwise change over time. We call such sets _dynamic_. The next four chapters present some basic techniques for representing finite dynamic sets and manipulating them on a computer.\n\nAlgorithms may require several types of operations to be performed on sets. For example, many algorithms need only the ability to insert elements into, delete elements from, and test membership in a set. We call a dynamic set that supports these operations a _dictionary_. Other algorithms require more complicated operations. For example, min-priority queues, which Chapter 6 introduced in the context of the heap data structure, support the operations of inserting an element into and extracting the smallest element from a set. The best way to implement a dynamic set depends upon the operations that you need to support.\n\n## Elements of a dynamic set\n\nIn a typical implementation of a dynamic set, each element is represented by an object whose attributes can be examined and manipulated given a pointer to the object. Some kinds of dynamic sets assume that one of the object's attributes is an identifying _key_. If the keys are all different, we can think of the dynamic set as being a set of key values. The object may contain _satellite data_, which are carried around in other object attributes but are otherwise unused by the set implementation. It may also have attributes that are manipulated by the set operations. These attributes may contain data or pointers to other objects in the set.\n\nSome dynamic sets presuppose that the keys are drawn from a totally ordered set, such as the real numbers, or the set of all words under the usual alphabeticordering. A total ordering allows us to define the minimum element of the set, for example, or to speak of the next element larger than a given element in a set.\n\n### Operations on dynamic sets\n\nOperations on a dynamic set can be grouped into two categories: _queries_, which simply return information about the set, and _modifying operations_, which change the set. Here is a list of typical operations. Any specific application will usually require only a few of these to be implemented.\n\nSearch\\((S,k)\\)\n\nA query that, given a set \\(S\\) and a key value \\(k\\), returns a pointer \\(x\\) to an element in \\(S\\) such that \\(x\\)._key_\\(=k\\), or nil if no such element belongs to \\(S\\).\n\nInsert\\((S,x)\\)\n\nA modifying operation that adds the element pointed to by \\(x\\) to the set \\(S\\). We usually assume that any attributes in element \\(x\\) needed by the set implementation have already been initialized.\n\nDelete\\((S,x)\\)\n\nA modifying operation that, given a pointer \\(x\\) to an element in the set \\(S\\), removes \\(x\\) from \\(S\\). (Note that this operation takes a pointer to an element \\(x\\), not a key value.)\n\nMinimum\\((S)\\) and Maximum\\((S)\\)\n\nQueries on a totally ordered set \\(S\\) that return a pointer to the element of \\(S\\) with the smallest (for Minimum) or largest (for Maximum) key.\n\nSuccessor\\((S,x)\\)\n\nA query that, given an element \\(x\\) whose key is from a totally ordered set \\(S\\), returns a pointer to the next larger element in \\(S\\), or nil if \\(x\\) is the maximum element.\n\nPredecessor\\((S,x)\\)\n\nA query that, given an element \\(x\\) whose key is from a totally ordered set \\(S\\), returns a pointer to the next smaller element in \\(S\\), or nil if \\(x\\) is the minimum element.\n\nIn some situations, we can extend the queries Successor and Predecessor so that they apply to sets with nondistinct keys. For a set on \\(n\\) keys, the normal presumption is that a call to Minimum followed by \\(n-1\\) calls to Successor enumerates the elements in the set in sorted order.\n\nWe usually measure the time taken to execute a set operation in terms of the size of the set. For example, Chapter 13 describes a data structure that can support any of the operations listed above on a set of size \\(n\\) in \\(O(\\lg n)\\) time.\n\nOf course, you can always choose to implement a dynamic set with an array. The advantage of doing so is that the algorithms for the dynamic-set operations are simple. The downside, however, is that many of these operations have a worst-case running time of \\(\\Theta(n)\\). If the array is not sorted, Insert and Delete can take \\(\\Theta(1)\\) time, but the remaining operations take \\(\\Theta(n)\\) time. If instead the array is maintained in sorted order, then Minimum, Maximum, Successor, and Predecessor take \\(\\Theta(1)\\) time; Search takes \\(\\mathit{O}(\\lg n)\\) time if implemented with binary search; but Insert and Delete take \\(\\Theta(n)\\) time in the worst case. The data structures studied in this part improve on the array implementation for many of the dynamic-set operations.\n\n#### Overview of Part III\n\nChapters 10-13 describe several data structures that we can use to implement dynamic sets. We'll use many of these data structures later to construct efficient algorithms for a variety of problems. We already saw another important data structure --the heap-- in Chapter 6.\n\nChapter 10 presents the essentials of working with simple data structures such as arrays, matrices, stacks, queues, linked lists, and rooted trees. If you have taken an introductory programming course, then much of this material should be familiar to you.\n\nChapter 11 introduces hash tables, a widely used data structure supporting the dictionary operations Insert, Delete, and Search. In the worst case, hash tables require \\(\\Theta(n)\\) time to perform a Search operation, but the expected time for hash-table operations is \\(\\mathit{O}(1)\\). We rely on probability to analyze hash-table operations, but you can understand how the operations work even without probability.\n\nBinary search trees, which are covered in Chapter 12, support all the dynamic-set operations listed above. In the worst case, each operation takes \\(\\Theta(n)\\) time on a tree with \\(n\\) elements. Binary search trees serve as the basis for many other data structures.\n\nChapter 13 introduces red-black trees, which are a variant of binary search trees. Unlike ordinary binary search trees, red-black trees are guaranteed to perform well: operations take \\(\\mathit{O}(\\lg n)\\) time in the worst case. A red-black tree is a balanced search tree. Chapter 18 in Part V presents another kind of balanced search tree, called a B-tree. Although the mechanics of red-black trees are somewhat intricate, you can glean most of their properties from the chapter without studying the mechanics in detail. Nevertheless, you probably will find walking through the code to be instructive.\n\n## Chapter 10 Elementary Data Structures\n\nIn this chapter, we examine the representation of dynamic sets by simple data structures that use pointers. Although you can construct many complex data structures using pointers, we present only the rudimentary ones: arrays, matrices, stacks, queues, linked lists, and rooted trees.\n\n### 10.1 Simple array-based data structures: arrays, matrices, stacks, queues\n\n#### Arrays\n\nWe assume that, as in most programming languages, an array is stored as a contiguous sequence of bytes in memory. If the first element of an array has index \\(s\\) (for example, in an array with 1-origin indexing, \\(s=1\\)), the array starts at memory address \\(a\\), and each array element occupies \\(b\\) bytes, then the \\(i\\)th element occupies bytes \\(a+b(i-s)\\) through \\(a+b(i-s+1)-1\\). Since most of the arrays in this book are indexed starting at 1, and a few starting at 0, we can simplify these formulas a little. When \\(s=1\\), the \\(i\\)th element occupies bytes \\(a+b(i-1)\\) through \\(a+bi-1\\), and when \\(s=0\\), the \\(i\\)th element occupies bytes \\(a+bi\\) through \\(a+b(i+1)-1\\). Assuming that the computer can access all memory locations in the same amount of time (as in the RAM model described in Section 2.2), it takes constant time to access any array element, regardless of the index.\n\nMost programming languages require each element of a particular array to be the same size. If the elements of a given array might occupy different numbers of bytes, then the above formulas fail to apply, since the element size \\(b\\) is not a constant. In such cases, the array elements are usually objects of varying sizes, and what actually appears in each array element is a pointer to the object. The number of bytes occupied by a pointer is typically the same, no matter what the pointer references, so that to access an object in an array, the above formulas give the address of the pointer to the object and then the pointer must be followed to access the object itself.",
        "chapter": "Part III Data Structures",
        "section": "Introduction",
        "subsection": "N/A",
        "subsubsection": "N/A"
    },
    {
        "content": "## Chapter 10 Elementary Data Structures\n\nIn this chapter, we examine the representation of dynamic sets by simple data structures that use pointers. Although you can construct many complex data structures using pointers, we present only the rudimentary ones: arrays, matrices, stacks, queues, linked lists, and rooted trees.\n\n### 10.1 Simple array-based data structures: arrays, matrices, stacks, queues\n\n#### Arrays\n\nWe assume that, as in most programming languages, an array is stored as a contiguous sequence of bytes in memory. If the first element of an array has index \\(s\\) (for example, in an array with 1-origin indexing, \\(s=1\\)), the array starts at memory address \\(a\\), and each array element occupies \\(b\\) bytes, then the \\(i\\)th element occupies bytes \\(a+b(i-s)\\) through \\(a+b(i-s+1)-1\\). Since most of the arrays in this book are indexed starting at 1, and a few starting at 0, we can simplify these formulas a little. When \\(s=1\\), the \\(i\\)th element occupies bytes \\(a+b(i-1)\\) through \\(a+bi-1\\), and when \\(s=0\\), the \\(i\\)th element occupies bytes \\(a+bi\\) through \\(a+b(i+1)-1\\). Assuming that the computer can access all memory locations in the same amount of time (as in the RAM model described in Section 2.2), it takes constant time to access any array element, regardless of the index.\n\nMost programming languages require each element of a particular array to be the same size. If the elements of a given array might occupy different numbers of bytes, then the above formulas fail to apply, since the element size \\(b\\) is not a constant. In such cases, the array elements are usually objects of varying sizes, and what actually appears in each array element is a pointer to the object. The number of bytes occupied by a pointer is typically the same, no matter what the pointer references, so that to access an object in an array, the above formulas give the address of the pointer to the object and then the pointer must be followed to access the object itself.\n\n#### 10.1.2 Matrices\n\nWe typically represent a matrix or two-dimensional array by one or more one-dimensional arrays. The two most common ways to store a matrix are row-major and column-major order. Let's consider an \\(m\\times n\\) matrix -- a matrix with \\(m\\) rows and \\(n\\) columns. In _row-major order_, the matrix is stored row by row, and in _column-major order_, the matrix is stored column by column. For example, consider the \\(2\\times 3\\) matrix\n\n\\[M\\,=\\,\\left(\\begin{array}{ccc}1&2&3\\\\ 4&5&6\\end{array}\\right)\\,. \\tag{10.1}\\]\n\nRow-major order stores the two rows \\(1\\)\\(2\\)\\(3\\) and \\(4\\)\\(5\\)\\(6\\), whereas column-major order stores the three columns \\(1\\)\\(4\\); \\(2\\)\\(5\\); and \\(3\\)\\(6\\).\n\nParts (a) and (b) of Figure 10.1 show how to store this matrix using a single one-dimensional array. It's stored in row-major order in part (a) and in column-major order in part (b). If the rows, columns, and the single array all are indexed starting at \\(s\\), then \\(M[i,j]\\)--the element in row \\(i\\) and column \\(j\\,\\)--is at array index \\(s\\,+\\,(n(i-s))\\,+\\,(j-s)\\) with row-major order and \\(s\\,+\\,(m(j-s))\\,+\\,(i-s)\\) with column-major order. When \\(s=1\\), the single-array indices are \\(n(i-1)\\,+\\,j\\) with row-major order and \\(i\\,+\\,m(j-1)\\) with column-major order. When \\(s=0\\), the single-array indices are simpler: \\(n\\,i\\,+\\,j\\) with row-major order and \\(i\\,+\\,mj\\) with column-major order. For the example matrix \\(M\\) with 1-origin indexing, element \\(M[2,1]\\) is stored at index \\(3(2-1)+1\\,=\\,4\\) in the single array using row-major order and at index \\(2\\,+\\,2(1-1)\\,=\\,2\\) using column-major order.\n\nParts (c) and (d) of Figure 10.1 show multiple-array strategies for storing the example matrix. In part (c), each row is stored in its own array of length \\(n\\), shown in tan. Another array, with \\(m\\) elements, shown in blue, points to the \\(m\\) row arrays. If we call the blue array \\(A\\), then \\(A[i]\\) points to the array storing the entries for row \\(i\\) of \\(M\\), and array element \\(A[i][j]\\) stores matrix element \\(M[i,j]\\). Part (d) shows the column-major version of the multiple-array representation, with \\(n\\) arrays, each of\n\nFigure 10.1: Four ways to store the \\(2\\times 3\\) matrix \\(M\\) from equation (10.1). **(a)** In row-major order, in a single array. **(b)** In column-major order, in a single array. **(c)** In row-major order, with one array per row (tan) and a single array (blue) of pointers to the row arrays. **(d)** In column-major order, with one array per column (tan) and a single array (blue) of pointers to the column arrays.\n\nlength \\(m\\), representing the \\(n\\) columns. Matrix element \\(M[i,j]\\) is stored in array element \\(A[j][i]\\).\n\nSingle-array representations are typically more efficient on modern machines than multiple-array representations. But multiple-array representations can sometimes be more flexible, for example, allowing for \"ragged arrays,\" in which the rows in the row-major version may have different lengths, or symmetrically for the column-major version, where columns may have different lengths.\n\nOccasionally, other schemes are used to store matrices. In the _block representation_, the matrix is divided into blocks, and each block is stored contiguously. For example, a \\(4\\times 4\\) matrix that is divided into \\(2\\times 2\\) blocks, such as\n\n\\[\\left(\\begin{array}{cccc}1&2&3&4\\\\ 5&6&7&8\\\\ \\hline 9&10&11&12\\\\ 13&14&15&16\\\\ \\end{array}\\right)\\]\n\nmight be stored in a single array in the order \\(\\langle 1,2,5,6,3,4,7,8,9,10,13,14,11,\\)\\(12,15,16\\rangle\\).\n\n#### Stacks and queues\n\nStacks and queues are dynamic sets in which the element removed from the set by the Delete operation is prespecified. In a _stack_, the element deleted from the set is the one most recently inserted: the stack implements a _last-in_, _first-out_, or _LIFO_, policy. Similarly, in a _queue_, the element deleted is always the one that has been in the set for the longest time: the queue implements a _first-in_, _first-out_, or _FIFO_, policy. There are several efficient ways to implement stacks and queues on a computer. Here, you will see how to use an array with attributes to store them.\n\n#### Stacks\n\nThe Insert operation on a stack is often called Push, and the Delete operation, which does not take an element argument, is often called Pop. These names are allusions to physical stacks, such as the spring-loaded stacks of plates used in cafeterias. The order in which plates are popped from the stack is the reverse of the order in which they were pushed onto the stack, since only the top plate is accessible.\n\nFigure 10.2 shows how to implement a stack of at most \\(n\\) elements with an array \\(S[1:n]\\). The stack has attributes \\(S.top\\), indexing the most recently inserted element, and \\(S.size\\), equaling the size \\(n\\) of the array. The stack consists of elements \\(S[1:S.top]\\), where \\(S[1]\\) is the element at the bottom of the stack and \\(S[S.top]\\) is the element at the top.\n\nWhen \\(S.top=0\\), the stack contains no elements and is _empty_. We can test whether the stack is empty with the query operation Stack-Empty. Upon an attempt to pop an empty stack, the stack _underflows_, which is normally an error. If \\(S.top\\) exceeds \\(S.size\\), the stack _overflows_.\n\nThe procedures Stack-Empty, Push, and Pop implement each of the stack operations with just a few lines of code. Figure 10.2 shows the effects of the modifying operations Push and Pop. Each of the three stack operations takes \\(O(1)\\) time.\n\nFigure 10.2: An array implementation of a stack \\(S\\). Stack elements appear only in the tan positions. **(a)** Stack \\(S\\) has 4 elements. The top element is 9. **(b)** Stack \\(S\\) after the calls Push\\((S,17)\\) and Push\\((S,3)\\). **(c)** Stack \\(S\\) after the call Pop\\((S)\\) has returned the element 3, which is the one most recently pushed. Although element 3 still appears in the array, it is no longer in the stack. The top is element 17.\n\n3 A queue implemented using an array \\(\\,Q[1:12]\\). Queue elements appear only in the tan positions. **(a)** The queue has 5 elements, in locations \\(\\,Q[7:11]\\). **(b)** The configuration of the queue after the calls \\(\\,\\)Enqueue(\\(Q,17\\)), \\(\\,\\)Enqueue(\\(Q,3\\)), and \\(\\,\\)Enqueue(\\(Q,5\\)). **(c)** The configuration of the queue after the call \\(\\,\\)Dequeue(\\(Q\\)) returns the key value 15 formerly at the head of the queue. The new head has key 6.\n\n### 10.4 Queue\n\nWe call the Insert operation on a queue \\(\\,\\)Enqueue, and we call the \\(\\,\\)Delete operation \\(\\,\\)Dequeue. Like the stack operation \\(\\,\\)Pop, \\(\\,\\)Dequeue takes no element argument. The FIFO property of a queue causes it to operate like a line of customers waiting for service. The queue has a \\(\\,\\)_head_ and a \\(\\,\\)_tail_. When an element is enqueued, it takes its place at the tail of the queue, just as a newly arriving customer takes a place at the end of the line. The element dequeued is always the one at the head of the queue, like the customer at the head of the line, who has waited the longest.\n\nFigure 10.3 shows one way to implement a queue of at most \\(n-1\\) elements using an array \\(\\,Q[1:n]\\), with the attribute \\(\\,Q.\\,\\)_size_ equaling the size \\(n\\) of the array. The queue has an attribute \\(\\,Q.\\,\\)_head_ that indexes, or points to, its head. The attribute \\(\\,Q.\\,\\)_tail_ indexes the next location at which a newly arriving element will be inserted into the queue. The elements in the queue reside in locations \\(\\,Q.\\,\\)_head_, \\(\\,Q.\\,\\)_head_\\(+\\) 1, \\(\\,\\ldots,\\,Q.\\,\\)_tail_\\(-\\) 1, where we \"wrap around\" in the sense that location 1 immediately follows location \\(n\\) in a circular order. When \\(\\,Q.\\,\\)_head_\\(=\\,Q.\\,\\)_tail_, the queue is empty. Initially, we have \\(\\,Q.\\,\\)_head_\\(=\\,Q.\\,\\)_tail_\\(=\\) 1. An attempt to dequeue an element from an empty queue causes the queue to underflow. When \\(\\,Q.\\,\\)_head_\\(=\\,Q.\\,\\)_tail_\\(+\\) 1 or both\n\nFigure 10.3: A queue implemented using an array \\(\\,Q[1:12]\\). Queue elements appear only in the tan positions. **(a)** The queue has 5 elements, in locations \\(\\,Q[7:11]\\). **(b)** The configuration of the queue after the calls \\(\\,\\)Enqueue(\\(Q,17\\)), \\(\\,\\)Enqueue(\\(Q,3\\)), and \\(\\,\\)Enqueue(\\(Q,5\\)). **(c)** The configuration of the queue after the call \\(\\,\\)Dequeue(\\(Q\\)) returns the key value 15 formerly at the head of the queue. The new head has key 6.\n\n\\(Q.\\mathit{head}=1\\) and \\(Q.\\mathit{tail}=Q.\\mathit{size}\\), the queue is full, and an attempt to enqueue an element causes the queue to overflow.\n\nIn the procedures Enqueue and Dequeue, we have omitted the error checking for underflow and overflow. (Exercise 10.1-5 asks you to supply these checks.) Figure 10.3 shows the effects of the Enqueue and Dequeue operations. Each operation takes \\(Q(1)\\) time.\n\n\\[\\begin{array}{l}\\textsc{Enqueue}(Q,x)\\\\ \\\\ 1\\;\\;Q[Q.\\mathit{tail}]=x\\\\ \\\\ 2\\;\\;\\mathit{if}\\;Q.\\mathit{tail}==Q.\\mathit{size}\\\\ \\\\ 3\\;\\;Q.\\mathit{tail}=1\\\\ \\\\ 4\\;\\;\\mathit{else}\\;Q.\\mathit{tail}=Q.\\mathit{tail}+1\\\\ \\\\ \\end{array}\\]\n\n\\[\\begin{array}{l}\\textsc{Dequeue}(Q)\\\\ \\\\ 1\\;\\;x=Q[Q.\\mathit{head}]\\\\ \\\\ 2\\;\\;\\mathit{if}\\;Q.\\mathit{head}==Q.\\mathit{size}\\\\ \\\\ 3\\;\\;Q.\\mathit{head}=1\\\\ \\\\ 4\\;\\;\\mathit{else}\\;Q.\\mathit{head}=Q.\\mathit{head}+1\\\\ \\\\ 5\\;\\;\\mathit{return}\\;x\\\\ \\end{array}\\]\n\n## Exercises\n\n### 10.1-1\n\nConsider an \\(m\\times n\\) matrix in row-major order, where both \\(m\\) and \\(n\\) are powers of \\(2\\) and rows and columns are indexed from \\(0\\). We can represent a row index \\(i\\) in binary by the \\(\\lg m\\) bits \\(\\langle i_{\\lg m-1},i_{\\lg m-2},\\ldots,i_{0}\\rangle\\) and a column index \\(j\\) in binary by the \\(\\lg n\\) bits \\(\\langle j_{\\lg n-1},j_{\\lg n-2},\\ldots,j_{0}\\rangle\\). Suppose that this matrix is a \\(2\\times 2\\) block matrix, where each block has \\(m/2\\) rows and \\(n/2\\) columns, and it is to be represented by a single array with \\(0\\)-origin indexing. Show how to construct the binary representation of the \\((\\lg m+\\lg n)\\)-bit index into the single array from the binary representations of \\(i\\) and \\(j\\).\n\n### 10.1-2\n\nUsing Figure 10.2 as a model, illustrate the result of each operation in the sequence Push\\((S,4)\\), Push\\((S,1)\\), Push\\((S,3)\\), Pop\\((S)\\), Push\\((S,8)\\), and Pop\\((S)\\) on an initially empty stack \\(S\\) stored in array \\(S[1:6]\\)\n\n### 10.1-3\n\nExplain how to implement two stacks in one array \\(A[1:n]\\) in such a way that neither stack overflows unless the total number of elements in both stacks together is \\(n\\). The Push and Pop operations should run in \\(O(1)\\) time.\n\n### 10.1-4\n\nUsing Figure 10.3 as a model, illustrate the result of each operation in the sequence \\(\\textsc{Enqueue}(Q,4)\\), \\(\\textsc{Enqueue}(Q,1)\\), \\(\\textsc{Enqueue}(Q,3)\\), \\(\\textsc{Dequeue}(Q)\\), \\(\\textsc{Enqueue}(Q,8)\\), and \\(\\textsc{Dequeue}(Q)\\) on an initially empty queue \\(Q\\) stored in array \\(Q[1:6]\\).\n\n### 10.1-5\n\nRewrite \\(\\textsc{Enqueue}\\) and \\(\\textsc{Dequeue}\\) to detect underflow and overflow of a queue.\n\n### 10.1-6\n\nWhereas a stack allows insertion and deletion of elements at only one end, and a queue allows insertion at one end and deletion at the other end, a _deque_ (double-ended queue, pronounced like \"deck\") allows insertion and deletion at both ends. Write four \\(O(1)\\)-time procedures to insert elements into and delete elements from both ends of a deque implemented by an array.\n\n### 10.1-7\n\nShow how to implement a queue using two stacks. Analyze the running time of the queue operations.\n\n### 10.1-8\n\nShow how to implement a stack using two queues. Analyze the running time of the stack operations.\n\n### 10.2 Linked lists\n\nA _linked list_ is a data structure in which the objects are arranged in a linear order. Unlike an array, however, in which the linear order is determined by the array indices, the order in a linked list is determined by a pointer in each object. Since the elements of linked lists often contain keys that can be searched for, linked lists are sometimes called _search lists_. Linked lists provide a simple, flexible representation for dynamic sets, supporting (though not necessarily efficiently) all the operations listed on page 250.\n\nAs shown in Figure 10.4, each element of a _doubly linked list_\\(L\\) is an object with an attribute _key_ and two pointer attributes: _next_ and _prev_. The object may",
        "chapter": "Part III Data Structures",
        "section": "10 Elementary Data Structures",
        "subsection": "10.1 Simple array-based data structures: arrays, matrices, stacks, queues",
        "subsubsection": "N/A"
    },
    {
        "content": "### 10.1-3\n\nExplain how to implement two stacks in one array \\(A[1:n]\\) in such a way that neither stack overflows unless the total number of elements in both stacks together is \\(n\\). The Push and Pop operations should run in \\(O(1)\\) time.\n\n### 10.1-4\n\nUsing Figure 10.3 as a model, illustrate the result of each operation in the sequence \\(\\textsc{Enqueue}(Q,4)\\), \\(\\textsc{Enqueue}(Q,1)\\), \\(\\textsc{Enqueue}(Q,3)\\), \\(\\textsc{Dequeue}(Q)\\), \\(\\textsc{Enqueue}(Q,8)\\), and \\(\\textsc{Dequeue}(Q)\\) on an initially empty queue \\(Q\\) stored in array \\(Q[1:6]\\).\n\n### 10.1-5\n\nRewrite \\(\\textsc{Enqueue}\\) and \\(\\textsc{Dequeue}\\) to detect underflow and overflow of a queue.\n\n### 10.1-6\n\nWhereas a stack allows insertion and deletion of elements at only one end, and a queue allows insertion at one end and deletion at the other end, a _deque_ (double-ended queue, pronounced like \"deck\") allows insertion and deletion at both ends. Write four \\(O(1)\\)-time procedures to insert elements into and delete elements from both ends of a deque implemented by an array.\n\n### 10.1-7\n\nShow how to implement a queue using two stacks. Analyze the running time of the queue operations.\n\n### 10.1-8\n\nShow how to implement a stack using two queues. Analyze the running time of the stack operations.\n\n### 10.2 Linked lists\n\nA _linked list_ is a data structure in which the objects are arranged in a linear order. Unlike an array, however, in which the linear order is determined by the array indices, the order in a linked list is determined by a pointer in each object. Since the elements of linked lists often contain keys that can be searched for, linked lists are sometimes called _search lists_. Linked lists provide a simple, flexible representation for dynamic sets, supporting (though not necessarily efficiently) all the operations listed on page 250.\n\nAs shown in Figure 10.4, each element of a _doubly linked list_\\(L\\) is an object with an attribute _key_ and two pointer attributes: _next_ and _prev_. The object mayalso contain other satellite data. Given an element \\(x\\) in the list, \\(x\\)._next_ points to its successor in the linked list, and \\(x\\)._prev_ points to its predecessor. If \\(x\\)._prev_\\(=\\) nil, the element \\(x\\) has no predecessor and is therefore the first element, or _head_, of the list. If \\(x\\)._next_\\(=\\) nil, the element \\(x\\) has no successor and is therefore the last element, or _tail_, of the list. An attribute \\(L\\)._head_ points to the first element of the list. If \\(L\\)._head_\\(=\\) nil, the list is empty.\n\nA list may have one of several forms. It may be either singly linked or doubly linked, it may be sorted or not, and it may be circular or not. If a list is _singly linked_, each element has a _next_ pointer but not a _prev_ pointer. If a list is _sorted_, the linear order of the list corresponds to the linear order of keys stored in elements of the list. The minimum element is then the head of the list, and the maximum element is the tail. If the list is _unsorted_, the elements can appear in any order. In a _circular list_, the _prev_ pointer of the head of the list points to the tail, and the _next_ pointer of the tail of the list points to the head. You can think of a circular list as a ring of elements. In the remainder of this section, we assume that the lists we are working with are unsorted and doubly linked.\n\nFigure 10.4: **(a)** A doubly linked list \\(L\\) representing the dynamic set \\(\\{1,4,9,16\\}\\). Each element in the list is an object with attributes for the key and pointers (shown by arrows) to the next and previous objects. The _next_ attribute of the tail and the _prev_ attribute of the head are nil, indicated by a diagonal slash. The attribute \\(L\\)._head_ points to the head. **(b)** Following the execution of List-Prepend(\\(L,x\\)), where \\(x\\)._key_\\(=25\\), the linked list has an object with key \\(25\\) as the new head. This new object points to the old head with key \\(9\\). **(c)** The result of calling List-Insert(\\(x,y\\)), where \\(x\\)._key_\\(=36\\) and \\(y\\) points to the object with key \\(9\\). **(d)** The result of the subsequent call List-Delete(\\(L,x\\)), where \\(x\\) points to the object with key \\(4\\).\n\n### Searching a linked list\n\nThe procedure List-Search(\\(L,k\\)) finds the first element with key \\(k\\) in list \\(L\\) by a simple linear search, returning a pointer to this element. If no object with key \\(k\\) appears in the list, then the procedure returns nil. For the linked list in Figure 10.4(a), the call List-Search(\\(L,4\\)) returns a pointer to the third element, and the call List-Search(\\(L,7\\)) returns nil. To search a list of \\(n\\) objects, the List-Search procedure takes \\(\\Theta(n)\\) time in the worst case, since it may have to search the entire list.\n\nList-Search(\\(L,k\\))\n\n\\(x=L.head\\)\n\n\\(x\\neq\\) nil and \\(x.key\\neq k\\)\n\n\\(x=x.next\\)\n\n### Inserting into a linked list\n\nGiven an element \\(x\\) whose _key_ attribute has already been set, the List-Prepend procedure adds \\(x\\) to the front of the linked list, as shown in Figure 10.4(b). (Recall that our attribute notation can cascade, so that \\(L.head.prev\\) denotes the _prev_ attribute of the object that \\(L.head\\) points to.) The running time for List-Prepend on a list of \\(n\\) elements is \\(O(1)\\).\n\nList-Prepend(\\(L,x\\))\n\n\\(x.next=L.head\\)\n\n\\(x.prev=nil\\)\n\n\\(L.head\\neq nil\\)\n\n\\(L.head.prev=x\\)\n\n\\(L.head=x\\)\n\nYou can insert anywhere within a linked list. As Figure 10.4(c) shows, if you have a pointer \\(y\\) to an object in the list, the List-Insert procedure on the facing page \"splices\" a new element \\(x\\) into the list, immediately following \\(y\\), in \\(O(1)\\) time. Since List-Insert never references the list object \\(L\\), it is not supplied as a parameter.\n\n### Linked lists\n\nList-Insert(\\(x\\), \\(y\\))\n\n\\(x\\)._next_\\(=\\)\\(y\\)._next_\n\n\\(x\\)._prev_\\(=\\)\\(y\\)\n\n**if**\\(y\\)._next_\\(\\neq\\)nil\n\n\\(y\\)._next.prev_\\(=\\)\\(x\\)\n\n\\(y\\)._next_\\(=\\)\\(x\\)\n\n#### Deleting from a linked list\n\nThe procedure List-Delete removes an element \\(x\\) from a linked list \\(L\\). It must be given a pointer to \\(x\\), and it then \"'splices\" \\(x\\) out of the list by updating pointers. To delete an element with a given key, first call List-Search to retrieve a pointer to the element. Figure 10.4(d) shows how an element is deleted from a linked list. List-Delete runs in \\(O(1)\\) time, but to delete an element with a given key, the call to List-Search makes the worst-case running time be \\(\\Theta(n)\\).\n\nList-Delete(\\(L\\), \\(x\\))\n\n**if**\\(x\\)._prev_\\(\\neq\\)nil\n\n\\(x\\)._prev_._next_\\(=\\)\\(x\\)._next_\n\n**else**\\(L\\)._head_\\(=\\)\\(x\\)._next_\n\n**if**\\(x\\)._next_\\(\\neq\\)nil\n\n\\(x\\)._next_._prev_\\(=\\)\\(x\\)._prev_\n\nInsertion and deletion are faster operations on doubly linked lists than on arrays. If you want to insert a new first element into an array or delete the first element in an array, maintaining the relative order of all the existing elements, then each of the existing elements needs to be moved by one position. In the worst case, therefore, insertion and deletion take \\(\\Theta(n)\\) time in an array, compared with \\(O(1)\\) time for a doubly linked list. (Exercise 10.2-1 asks you to show that deleting an element from a singly linked list takes \\(\\Theta(n)\\) time in the worst case.) If, however, you want to find the \\(k\\)th element in the linear order, it takes just \\(O(1)\\) time in an array regardless of \\(k\\), but in a linked list, you'd have to traverse \\(k\\) elements, taking \\(\\Theta(k)\\) time.\n\n#### Sentinels\n\nThe code for List-Delete is simpler if you ignore the boundary conditions at the head and tail of the list:List-Delete\\({}^{\\prime}(x)\\)\n\n\\(1\\quad x.prev.next\\,=\\,x.next\\)\n\n\\(2\\quad x.next.prev\\,=\\,x.prev\\)\n\nA _sentinel_ is a dummy object that allows us to simplify boundary conditions. In a linked list \\(L\\), the sentinel is an object \\(L\\)._nil_ that represents nil but has all the attributes of the other objects in the list. References to nil are replaced by references to the sentinel \\(L\\)._nil_. As shown in Figure 10.5, this change turns a regular doubly linked list into a _circular, doubly linked list with a sentinel_, in which the sentinel \\(L\\)._nil_ lies between the head and tail. The attribute \\(L\\)._nil._next_ points to the head of the list, and \\(L\\)._nil._prev_ points to the tail. Similarly, both the _next_ attribute of the tail and the _prev_ attribute of the head point to \\(L\\)._nil_. Since \\(L\\)._nil._next_ points to the head, the attribute \\(L\\)._head_ is eliminated altogether, with references to it replaced by references to \\(L\\)._nil._next_. Figure 10.5(a) shows that an empty list consists of just the sentinel, and both \\(L\\)._nil._next_ and \\(L\\)._nil._prev_ point to \\(L\\)._nil_.\n\nTo delete an element from the list, just use the two-line procedure List-Delete\\({}^{\\prime}\\) from before. Just as List-Insert never references the list object \\(L\\), neither does\n\nFigure 10.5: A circular, doubly linked list with a sentinel. The sentinel \\(L\\)._nil_, in blue, appears between the head and tail. The attribute \\(L\\)._head_ is no longer needed, since the head of the list is \\(L\\)._nil._next_. **(a)** An empty list. **(b)** The linked list from Figure 10.4(a), with key 9 at the head and key 1 at the tail. **(c)** The list after executing List-Insert\\({}^{\\prime}(x,L\\)._nil_), where \\(x\\)._key_\\(=25\\). The new object becomes the head of the list. **(d)** The list after deleting the object with key 1. The new tail is the object with key 4. **(e)** The list after executing List-Insert\\({}^{\\prime}(x,y)\\), where \\(x\\)._key_\\(=36\\) and \\(y\\) points to the object with key 9.\n\nList-Delete\\({}^{\\prime}\\). You should never delete the sentinel \\(L\\)._nil_ unless you are deleting the entire list!\n\nThe List-Insert\\({}^{\\prime}\\) procedure inserts an element \\(x\\) into the list following object \\(y\\). No separate procedure for prepending is necessary: to insert at the head of the list, let \\(y\\) be \\(L\\)._nil_; and to insert at the tail, let \\(y\\) be \\(L\\)._nil_._prev_. Figure 10.5 shows the effects of List-Insert\\({}^{\\prime}\\) and List-Delete\\({}^{\\prime}\\) on a sample list.\n\n```\nList-Insert\\({}^{\\prime}(x,y)\\)\n1\\(x\\)._next_ = \\(y\\)._next_\n2\\(x\\)._prev_ = \\(y\\)\n3\\(y\\)._next_._prev_ = \\(x\\)\n4\\(y\\)._next_ = \\(x\\)\n```\n\nSearching a circular, doubly linked list with a sentinel has the same asymptotic running time as without a sentinel, but it is possible to decrease the constant factor. The test in line 2 of List-Search makes two comparisons: one to check whether the search has run off the end of the list and, if not, one to check whether the key resides in the current element \\(x\\). Suppose that you _know_ that the key is somewhere in the list. Then you do not need to check whether the search runs off the end of the list, thereby eliminating one comparison in each iteration of the **while** loop.\n\nThe sentinel provides a place to put the key before starting the search. The search starts at the head \\(L\\)._nil_._next_ of list \\(L\\), and it stops if it finds the key somewhere in the list. Now the search is guaranteed to find the key, either in the sentinel or before reaching the sentinel. If the key is found before reaching the sentinel, then it really is in the element where the search stops. If, however, the search goes through all the elements in the list and finds the key only in the sentinel, then the key is not really in the list, and the search returns nil. The procedure List-Search\\({}^{\\prime}\\) embodies this idea. (If your sentinel requires its _key_ attribute to be nil, then you might want to assign \\(L\\)._nil_._key_ = nil before line 5.)\n\n``` List-Search\\({}^{\\prime}(L,k)\\)\n1\\(L\\)._nil_._key_ = \\(k\\)// store the key in the sentinel to guarantee it is in list\n2\\(x\\) = \\(L\\)._nil_._next_ // start at the head of the list\n3while\\(x\\)._key_ \\(\\neq k\\)\n4\\(x\\) = \\(x\\)._next_\n5if\\(x\\) == \\(L\\)._nil_ // found \\(k\\) in the sentinel\n6return nil //\\(k\\) was not really in the list\n7elsereturn\\(x\\) // found \\(k\\) in element \\(x\\)Sentinels often simplify code and, as in searching a linked list, they might speed up code by a small constant factor, but they don't typically improve the asymptotic running time. Use them judiciously. When there are many small lists, the extra storage used by their sentinels can represent significant wasted memory. In this book, we use sentinels only when they significantly simplify the code.\n\n##### Exercises\n\n##### 10.2-1\n\nExplain why the dynamic-set operation Insert on a singly linked list can be implemented in \\(O(1)\\) time, but the worst-case time for Delete is \\(\\Theta(n)\\).\n\n##### 10.2-2\n\nImplement a stack using a singly linked list. The operations Push and Pop should still take \\(O(1)\\) time. Do you need to add any attributes to the list?\n\n##### 10.2-3\n\nImplement a queue using a singly linked list. The operations Enqueue and Dequeue should still take \\(O(1)\\) time. Do you need to add any attributes to the list?\n\n##### 10.2-4\n\nThe dynamic-set operation Union takes two disjoint sets \\(S_{1}\\) and \\(S_{2}\\) as input, and it returns a set \\(S=S_{1}\\cup S_{2}\\) consisting of all the elements of \\(S_{1}\\) and \\(S_{2}\\). The sets \\(S_{1}\\) and \\(S_{2}\\) are usually destroyed by the operation. Show how to support Union in \\(O(1)\\) time using a suitable list data structure.\n\n##### 10.2-5\n\nGive a \\(\\Theta(n)\\)-time nonrecursive procedure that reverses a singly linked list of \\(n\\) elements. The procedure should use no more than constant storage beyond that needed for the list itself.\n\n##### 10.2-6\n\nExplain how to implement doubly linked lists using only one pointer value \\(x.np\\) per item instead of the usual two (_next_ and _prev_). Assume that all pointer values can be interpreted as \\(k\\)-bit integers, and define \\(x.np=x.next\\) XOR \\(x.prev\\), the \\(k\\)-bit \"exclusive-or\" of \\(x.next\\) and \\(x.prev\\). The value nil is represented by 0. Be sure to describe what information you need to access the head of the list. Show how to implement the Search, Insert, and Delete operations on such a list. Also show how to reverse such a list in \\(O(1)\\) time.\n\n### 10.3 Representing rooted trees\n\nLinked lists work well for representing linear relationships, but not all relationships are linear. In this section, we look specifically at the problem of representing rooted trees by linked data structures. We first look at binary trees, and then we present a method for rooted trees in which nodes can have an arbitrary number of children.\n\nWe represent each node of a tree by an object. As with linked lists, we assume that each node contains a _key_ attribute. The remaining attributes of interest are pointers to other nodes, and they vary according to the type of tree.\n\n##### Binary trees\n\nFigure 10.6 shows how to use the attributes \\(p\\), _left_, and _right_ to store pointers to the parent, left child, and right child of each node in a binary tree \\(T\\). If \\(x.p=\\textsc{nil}\\), then \\(x\\) is the root. If node \\(x\\) has no left child, then \\(x.\\textit{left}=\\textsc{nil}\\), and similarly for the right child. The root of the entire tree \\(T\\) is pointed to by the attribute \\(T.\\textit{root}\\). If \\(T.\\textit{root}=\\textsc{nil}\\), then the tree is empty.\n\n##### Rooted trees with unbounded branching\n\nIt's simple to extend the scheme for representing a binary tree to any class of trees in which the number of children of each node is at most some constant \\(k\\): replace the _left_ and _right_ attributes by \\(\\textit{child}_{1},\\textit{child}_{2},\\ldots,\\textit{child}_{k}\\). This scheme no longer works when the number of children of a node is unbounded, however, since we do not know how many attributes to allocate in advance. Moreover, if \\(k\\), the number of children, is bounded by a large constant but most nodes have a small number of children, we may waste a lot of memory.\n\nFortunately, there is a clever scheme to represent trees with arbitrary numbers of children. It has the advantage of using only \\(O(n)\\) space for any \\(n\\)-node rooted tree. The _left-child_, _right-sibling representation_ appears in Figure 10.7. As before, each node contains a parent pointer \\(p\\), and \\(T.\\textit{root}\\) points to the root of tree \\(T\\). Instead of having a pointer to each of its children, however, each node \\(x\\) has only two pointers:\n\n1. \\(x.\\textit{left-child}\\) points to the leftmost child of node \\(x\\), and\n2. \\(x.\\textit{right-sibling}\\) points to the sibling of \\(x\\) immediately to its right.\n\nIf node \\(x\\) has no children, then \\(x.\\textit{left-child}=\\textsc{nil}\\), and if node \\(x\\) is the rightmost child of its parent, then \\(x.\\textit{right-sibling}=\\textsc{nil}\\).",
        "chapter": "Part III Data Structures",
        "section": "10 Elementary Data Structures",
        "subsection": "10.2 Linked lists",
        "subsubsection": "N/A"
    },
    {
        "content": "### 10.3 Representing rooted trees\n\nLinked lists work well for representing linear relationships, but not all relationships are linear. In this section, we look specifically at the problem of representing rooted trees by linked data structures. We first look at binary trees, and then we present a method for rooted trees in which nodes can have an arbitrary number of children.\n\nWe represent each node of a tree by an object. As with linked lists, we assume that each node contains a _key_ attribute. The remaining attributes of interest are pointers to other nodes, and they vary according to the type of tree.\n\n##### Binary trees\n\nFigure 10.6 shows how to use the attributes \\(p\\), _left_, and _right_ to store pointers to the parent, left child, and right child of each node in a binary tree \\(T\\). If \\(x.p=\\textsc{nil}\\), then \\(x\\) is the root. If node \\(x\\) has no left child, then \\(x.\\textit{left}=\\textsc{nil}\\), and similarly for the right child. The root of the entire tree \\(T\\) is pointed to by the attribute \\(T.\\textit{root}\\). If \\(T.\\textit{root}=\\textsc{nil}\\), then the tree is empty.\n\n##### Rooted trees with unbounded branching\n\nIt's simple to extend the scheme for representing a binary tree to any class of trees in which the number of children of each node is at most some constant \\(k\\): replace the _left_ and _right_ attributes by \\(\\textit{child}_{1},\\textit{child}_{2},\\ldots,\\textit{child}_{k}\\). This scheme no longer works when the number of children of a node is unbounded, however, since we do not know how many attributes to allocate in advance. Moreover, if \\(k\\), the number of children, is bounded by a large constant but most nodes have a small number of children, we may waste a lot of memory.\n\nFortunately, there is a clever scheme to represent trees with arbitrary numbers of children. It has the advantage of using only \\(O(n)\\) space for any \\(n\\)-node rooted tree. The _left-child_, _right-sibling representation_ appears in Figure 10.7. As before, each node contains a parent pointer \\(p\\), and \\(T.\\textit{root}\\) points to the root of tree \\(T\\). Instead of having a pointer to each of its children, however, each node \\(x\\) has only two pointers:\n\n1. \\(x.\\textit{left-child}\\) points to the leftmost child of node \\(x\\), and\n2. \\(x.\\textit{right-sibling}\\) points to the sibling of \\(x\\) immediately to its right.\n\nIf node \\(x\\) has no children, then \\(x.\\textit{left-child}=\\textsc{nil}\\), and if node \\(x\\) is the rightmost child of its parent, then \\(x.\\textit{right-sibling}=\\textsc{nil}\\).\n\n## Chapter 10 Elementary Data Structures\n\nFigure 10.7: The left-child, right-sibling representation of a tree \\(T\\). Each node \\(x\\) has attributes \\(x.p\\) (top), \\(x.\\)_left-child_ (lower left), and \\(x.\\)_right-sibling_ (lower right). The _key_ attributes are not shown.\n\nFigure 10.6: The representation of a binary tree \\(T\\). Each node \\(x\\) has the attributes \\(x.p\\) (top), \\(x.\\)_left-_ (lower left), and \\(x.\\)_right_ (lower right). The _key_ attributes are not shown.\n\n### 10.3 Representing rooted trees\n\n#### Other tree representations\n\nWe sometimes represent rooted trees in other ways. In Chapter 6, for example, we represented a heap, which is based on a complete binary tree, by a single array along with an attribute giving the index of the last node in the heap. The trees that appear in Chapter 19 are traversed only toward the root, and so only the parent pointers are present: there are no pointers to children. Many other schemes are possible. Which scheme is best depends on the application.\n\n#### Exercises\n\n_10.3-1_\n\nDraw the binary tree rooted at index 6 that is represented by the following attributes:\n\n\\begin{tabular}{c c c c} index & _key_ & _left_ & _right_ \\\\ \\hline\n1 & 17 & 8 & 9 \\\\\n2 & 14 & nil & nil \\\\\n3 & 12 & nil & nil \\\\\n4 & 20 & 10 & nil \\\\\n5 & 33 & 2 & nil \\\\\n6 & 15 & 1 & 4 \\\\\n7 & 28 & nil & nil \\\\\n8 & 22 & nil & nil \\\\\n9 & 13 & 3 & 7 \\\\\n10 & 25 & nil & 5 \\\\ \\end{tabular}\n\n#### 10.3-2\n\nWrite an \\(O(n)\\)-time recursive procedure that, given an \\(n\\)-node binary tree, prints out the key of each node in the tree.\n\n#### 10.3-3\n\nWrite an \\(O(n)\\)-time nonrecursive procedure that, given an \\(n\\)-node binary tree, prints out the key of each node in the tree. Use a stack as an auxiliary data structure.\n\n#### 10.3-4\n\nWrite an \\(O(n)\\)-time procedure that prints out all the keys of an arbitrary rooted tree with \\(n\\) nodes, where the tree is stored using the left-child, right-sibling representation.\n\n#### 10.3-5\n\nWrite an \\(O(n)\\)-time nonrecursive procedure that, given an \\(n\\)-node binary tree, prints out the key of each node. Use no more than constant extra space outsideof the tree itself and do not modify the tree, even temporarily, during the procedure. \\(\\bigstar\\) _10.3-6_ The left-child, right-sibling representation of an arbitrary rooted tree uses three pointers in each node: _left-child_, _right-sibling_, and _parent_. From any node, its parent can be accessed in constant time and all its children can be accessed in time linear in the number of children. Show how to use only two pointers and one boolean value in each node \\(x\\) so that \\(x\\)'s parent or all of \\(x\\)'s children can be accessed in time linear in the number of \\(x\\)'s children.\n\n## Problems\n\n### 10.1 Comparisons among lists\n\nFor each of the four types of lists in the following table, what is the asymptotic worst-case running time for each dynamic-set operation listed?\n\n\\begin{tabular}{l|c|c|c|c|}  & unsorted, & sorted, & unsorted, & sorted, \\\\  & singly & singly & doubly & doubly \\\\  & linked & linked & linked \\\\ \\hline Search & & & & \\\\ \\hline Insert & & & & \\\\ \\hline Delete & & & & \\\\ \\hline Successor & & & & \\\\ \\hline Predecessor & & & & \\\\ \\hline Minimum & & & & \\\\ \\hline Maximum & & & & \\\\ \\hline \\end{tabular}\n\n### 10.2 Mergeable heaps using linked lists\n\nA _mergeable heap_ supports the following operations: Make-Heap (which creates an empty mergeable heap), Insert, Minimum, Extract-Min, and Union.1",
        "chapter": "Part III Data Structures",
        "section": "10 Elementary Data Structures",
        "subsection": "10.3 Representing rooted trees",
        "subsubsection": "N/A"
    },
    {
        "content": "of the tree itself and do not modify the tree, even temporarily, during the procedure. \\(\\bigstar\\) _10.3-6_ The left-child, right-sibling representation of an arbitrary rooted tree uses three pointers in each node: _left-child_, _right-sibling_, and _parent_. From any node, its parent can be accessed in constant time and all its children can be accessed in time linear in the number of children. Show how to use only two pointers and one boolean value in each node \\(x\\) so that \\(x\\)'s parent or all of \\(x\\)'s children can be accessed in time linear in the number of \\(x\\)'s children.\n\n## Problems\n\n### 10.1 Comparisons among lists\n\nFor each of the four types of lists in the following table, what is the asymptotic worst-case running time for each dynamic-set operation listed?\n\n\\begin{tabular}{l|c|c|c|c|}  & unsorted, & sorted, & unsorted, & sorted, \\\\  & singly & singly & doubly & doubly \\\\  & linked & linked & linked \\\\ \\hline Search & & & & \\\\ \\hline Insert & & & & \\\\ \\hline Delete & & & & \\\\ \\hline Successor & & & & \\\\ \\hline Predecessor & & & & \\\\ \\hline Minimum & & & & \\\\ \\hline Maximum & & & & \\\\ \\hline \\end{tabular}\n\n### 10.2 Mergeable heaps using linked lists\n\nA _mergeable heap_ supports the following operations: Make-Heap (which creates an empty mergeable heap), Insert, Minimum, Extract-Min, and Union.1Show how to implement mergeable heaps using linked lists in each of the following cases. Try to make each operation as efficient as possible. Analyze the running time of each operation in terms of the size of the dynamic set(s) being operated on.\n\n_a._ Lists are sorted.\n\n_b._ Lists are unsorted.\n\n_c._ Lists are unsorted, and dynamic sets to be merged are disjoint.\n\n_10-3 Searching a sorted compact list_\n\nWe can represent a singly linked list with two arrays, _key_ and _next_. Given the index \\(i\\) of an element, its value is stored in \\(\\mathit{key}[i]\\), and the index of its successor is given by \\(\\mathit{next}[i]\\), where \\(\\mathit{next}[i]=\\textsc{nil}\\) for the last element. We also need the index _head_ of the first element in the list. An \\(n\\)-element list stored in this way is _compact_ if it is stored only in positions \\(1\\) through \\(n\\) of the _key_ and _next_ arrays.\n\nLet's assume that all keys are distinct and that the compact list is also sorted, that is, \\(\\mathit{key}[i]<\\mathit{key}[\\mathit{next}[i]]\\) for all \\(i=1,2,\\ldots,n\\) such that \\(\\mathit{next}[i]\\neq\\textsc{nil}\\). Under these assumptions, you will show that the randomized algorithm Compact-List-Search searches the list for key \\(k\\) in \\(O(\\sqrt{n})\\) expected time.\n\n```\n1\\(i=\\mathit{head}\\)\n2while\\(i\\neq\\textsc{nil}\\) and \\(\\mathit{key}[i]<k\\)\n3\\(j=\\textsc{Random}(1,n)\\)\n4if\\(\\mathit{key}[i]<\\mathit{key}[j]\\) and \\(\\mathit{key}[j]\\leq k\\)\n5\\(i=j\\)\n6if\\(\\mathit{key}[i]==k\\)\n7return\\(i\\)\n8\\(i=\\mathit{next}[i]\\)\n9if\\(i==\\textsc{nil}\\) or \\(\\mathit{key}[i]>k\\)\n10return\\(\\textsc{nil}\\)\n11elsereturn\\(i\\)\n```\n\nIf you ignore lines 3-7 of the procedure, you can see that it's an ordinary algorithm for searching a sorted linked list, in which index \\(i\\) points to each position of the list in turn. The search terminates once the index \\(i\\) \"falls off\" the end of the list or once \\(\\mathit{key}[i]\\geq k\\). In the latter case, if \\(\\mathit{key}[i]=k\\), the procedure has found a key with the value \\(k\\). If, however, \\(\\mathit{key}[i]>k\\), then the search will never find a key with the value \\(k\\), so that terminating the search was the correct action.\n\nLines 3-7 attempt to skip ahead to a randomly chosen position \\(j\\). Such a skip helps if \\(\\mathit{key}[j]\\) is larger than \\(\\mathit{key}[i]\\) and no larger than \\(k\\). In such a case, \\(j\\) marks a position in the list that \\(i\\) would reach during an ordinary list search. Because the list is compact, we know that any choice of \\(j\\) between 1 and \\(n\\) indexes some element in the list.\n\nInstead of analyzing the performance of Compact-List-Search directly, you will analyze a related algorithm, Compact-List-Search\\({}^{\\prime}\\), which executes two separate loops. This algorithm takes an additional parameter \\(t\\), which specifies an upper bound on the number of iterations of the first loop.\n\n```\n1\\(i=\\mathit{head}\\)\n2for\\(q=1\\)to\\(t\\)\n3\\(j=\\textsc{Random}(1,n)\\)\n4if\\(\\mathit{key}[i]<\\mathit{key}[j]\\) and \\(\\mathit{key}[j]\\leq k\\)\n5\\(i=j\\)\n6if\\(\\mathit{key}[i]==k\\)\n7return\\(i\\)\n8while\\(i\\neq\\textsc{nil}\\) and \\(\\mathit{key}[i]<k\\)\n9\\(i=\\mathit{next}[i]\\)\n10if\\(i==\\textsc{nil}\\) or \\(\\mathit{key}[i]>k\\)\n11return\\(\\textsc{nil}\\)\n12elsereturn\\(i\\)\n```\n\nTo compare the execution of the two algorithms, assume that the sequence of calls of Random\\((1,n)\\) yields the same sequence of integers for both algorithms.\n\n1. Argue that for any value of \\(t\\), Compact-List-Search\\((\\mathit{key},\\mathit{next},\\mathit{head},n,k)\\) and Compact-List-Search\\({}^{\\prime}(\\mathit{key},\\mathit{next},\\mathit{head},n,k,t)\\) return the same result and that the number of iterations of the **while** loop of lines 2-8 in Compact-List-Search is at most the total number of iterations of both the **for** and **while** loops in Compact-List-Search\\({}^{\\prime}\\).\n\nIn the call Compact-List-Search\\({}^{\\prime}(\\mathit{key},\\mathit{next},\\mathit{head},n,k,t)\\), let \\(X_{t}\\) be the random variable that describes the distance in the linked list (that is, through the chain of _next_ pointers) from position \\(i\\) to the desired key \\(k\\) after \\(t\\) iterations of the **for** loop of lines 2-7 have occurred.\n\n1. Argue that Compact-List-Search\\({}^{\\prime}(\\mathit{key},\\mathit{next},\\mathit{head},n,k,t)\\) has an expected running time of \\(O(t+\\mathrm{E}\\left[X_{t}\\right])\\).\n2. Show that \\(\\mathrm{E}\\left[X_{t}\\right]=\\sum_{r=1}^{n}(1-r/n)^{t}\\). (_Hint:_ Use equation (C.28) on page 1193.)_d._ Show that \\(\\sum_{r=0}^{n-1}r^{t}\\leq n^{t+1}/(t+1)\\). (_Hint:_ Use inequality (A.18) on page 1150.) _e._ Prove that \\(\\mathrm{E}\\left[X_{t}\\right]\\leq n/(t+1)\\). _f._ Show that Compact-List-Search\\({}^{\\prime}(key,next,head,n,k,t)\\) has an expected running time of \\(O(t+n/t)\\). _g._ Conclude that Compact-List-Search runs in \\(O(\\sqrt{n})\\) expected time. _h._ Why do we assume that all keys are distinct in Compact-List-Search? Argue that random skips do not necessarily help asymptotically when the list contains repeated key values.\n\n## Chapter notes\n\nAho, Hopcroft, and Ullman [6] and Knuth [259] are excellent references for elementary data structures. Many other texts cover both basic data structures and their implementation in a particular programming language. Examples of these types of textbooks include Goodrich and Tamassia [196], Main [311], Shaffer [406], and Weiss [452, 453, 454]. The book by Gonnet and Baeza-Yates [193] provides experimental data on the performance of many data-structure operations.\n\nThe origin of stacks and queues as data structures in computer science is unclear, since corresponding notions already existed in mathematics and paper-based business practices before the introduction of digital computers. Knuth [259] cites A. M. Turing for the development of stacks for subroutine linkage in 1947.\n\nPointer-based data structures also seem to be a folk invention. According to Knuth, pointers were apparently used in early computers with drum memories. The A-1 language developed by G. M. Hopper in 1951 represented algebraic formulas as binary trees. Knuth credits the IPL-II language, developed in 1956 by A. Newell, J. C. Shaw, and H. A. Simon, for recognizing the importance and promoting the use of pointers. Their IPL-III language, developed in 1957, included explicit stack operations.",
        "chapter": "Part III Data Structures",
        "section": "10 Elementary Data Structures",
        "subsection": "Problems",
        "subsubsection": "N/A"
    },
    {
        "content": "_d._ Show that \\(\\sum_{r=0}^{n-1}r^{t}\\leq n^{t+1}/(t+1)\\). (_Hint:_ Use inequality (A.18) on page 1150.) _e._ Prove that \\(\\mathrm{E}\\left[X_{t}\\right]\\leq n/(t+1)\\). _f._ Show that Compact-List-Search\\({}^{\\prime}(key,next,head,n,k,t)\\) has an expected running time of \\(O(t+n/t)\\). _g._ Conclude that Compact-List-Search runs in \\(O(\\sqrt{n})\\) expected time. _h._ Why do we assume that all keys are distinct in Compact-List-Search? Argue that random skips do not necessarily help asymptotically when the list contains repeated key values.\n\n## Chapter notes\n\nAho, Hopcroft, and Ullman [6] and Knuth [259] are excellent references for elementary data structures. Many other texts cover both basic data structures and their implementation in a particular programming language. Examples of these types of textbooks include Goodrich and Tamassia [196], Main [311], Shaffer [406], and Weiss [452, 453, 454]. The book by Gonnet and Baeza-Yates [193] provides experimental data on the performance of many data-structure operations.\n\nThe origin of stacks and queues as data structures in computer science is unclear, since corresponding notions already existed in mathematics and paper-based business practices before the introduction of digital computers. Knuth [259] cites A. M. Turing for the development of stacks for subroutine linkage in 1947.\n\nPointer-based data structures also seem to be a folk invention. According to Knuth, pointers were apparently used in early computers with drum memories. The A-1 language developed by G. M. Hopper in 1951 represented algebraic formulas as binary trees. Knuth credits the IPL-II language, developed in 1956 by A. Newell, J. C. Shaw, and H. A. Simon, for recognizing the importance and promoting the use of pointers. Their IPL-III language, developed in 1957, included explicit stack operations.\n\n## Chapter 1 Hash Tables\n\nMany applications require a dynamic set that supports only the dictionary operations Insert, Search, and Delete. For example, a compiler that translates a programming language maintains a symbol table, in which the keys of elements are arbitrary character strings corresponding to identifiers in the language. A hash table is an effective data structure for implementing dictionaries. Although searching for an element in a hash table can take as long as searching for an element in a linked list -- \\(\\Theta(n)\\) time in the worst case -- in practice, hashing performs extremely well. Under reasonable assumptions, the average time to search for an element in a hash table is \\(O(1)\\). Indeed, the built-in dictionaries of Python are implemented with hash tables.\n\nA hash table generalizes the simpler notion of an ordinary array. Directly addressing into an ordinary array takes advantage of the \\(O(1)\\) access time for any array element. Section 11.1 discusses direct addressing in more detail. To use direct addressing, you must be able to allocate an array that contains a position for every possible key.\n\nWhen the number of keys actually stored is small relative to the total number of possible keys, hash tables become an effective alternative to directly addressing an array, since a hash table typically uses an array of size proportional to the number of keys actually stored. Instead of using the key as an array index directly, we _compute_ the array index from the key. Section 11.2 presents the main ideas, focusing on \"chaining\" as a way to handle \"collisions,\" in which more than one key maps to the same array index. Section 11.3 describes how to compute array indices from keys using hash functions. We present and analyze several variations on the basic theme. Section 11.4 looks at \"open addressing,\" which is another way to deal with collisions. The bottom line is that hashing is an extremely effective and practical technique: the basic dictionary operations require only \\(O(1)\\) time on the average. Section 11.5 discusses the hierarchical memory systems of modern computer systems have and illustrates how to design hash tables that work well in such systems.",
        "chapter": "Part III Data Structures",
        "section": "10 Elementary Data Structures",
        "subsection": "Chapter notes",
        "subsubsection": "N/A"
    },
    {
        "content": "### Direct-address tables\n\nDirect addressing is a simple technique that works well when the universe \\(U\\) of keys is reasonably small. Suppose that an application needs a dynamic set in which each element has a distinct key drawn from the universe \\(U=\\{0,1,\\ldots,m-1\\}\\), where \\(m\\) is not too large.\n\nTo represent the dynamic set, you can use an array, or _direct-address table_, denoted by \\(T[0\\!:\\!m-1]\\), in which each position, or _slot_, corresponds to a key in the universe \\(U\\). Figure 11 illustrates this approach. Slot \\(k\\) points to an element in the set with key \\(k\\). If the set contains no element with key \\(k\\), then \\(T[k]=\\textsc{nil}\\).\n\nThe dictionary operations Direct-Address-Search, Direct-Address-Insert, and Direct-Address-Delete on the following page are trivial to implement. Each takes only \\(O(1)\\) time.\n\nFor some applications, the direct-address table itself can hold the elements in the dynamic set. That is, rather than storing an element's key and satellite data in an object external to the direct-address table, with a pointer from a slot in the table to the object, save space by storing the object directly in the slot. To indicate an empty slot, use a special key. Then again, why store the key of the object at all? The index of the object _is_ its key! Of course, then you'd need some way to tell whether slots are empty.\n\nFigure 11: How to implement a dynamic set by a direct-address table \\(T\\). Each key in the universe \\(U=\\{0,1,\\ldots,9\\}\\) corresponds to an index into the table. The set \\(K=\\{2,3,5,8\\}\\) of actual keys determines the slots in the table that contain pointers to elements. The other slots, in blue, contain Nil.\n\n#### Exercises\n\n##### 11.1-1\n\nA dynamic set \\(S\\) is represented by a direct-address table \\(T\\) of length \\(m\\). Describe a procedure that finds the maximum element of \\(S\\). What is the worst-case performance of your procedure?\n\n##### 11.1-2\n\nA _bit vector_ is simply an array of bits (each either 0 or 1). A bit vector of length \\(m\\) takes much less space than an array of \\(m\\) pointers. Describe how to use a bit vector to represent a dynamic set of distinct elements drawn from the set \\(\\{0,1,\\ldots,m-1\\}\\) and with no satellite data. Dictionary operations should run in \\(O(1)\\) time.\n\n##### 11.1-3\n\nSuggest how to implement a direct-address table in which the keys of stored elements do not need to be distinct and the elements can have satellite data. All three dictionary operations (Insert, Delete, and Search) should run in \\(O(1)\\) time. (Don't forget that Delete takes as an argument a pointer to an object to be deleted, not a key.)\n\n##### 11.1-4\n\nSuppose that you want to implement a dictionary by using direct addressing on a _huge_ array. That is, if the array size is \\(m\\) and the dictionary contains at most \\(n\\) elements at any one time, then \\(m\\gg n\\). At the start, the array entries may contain garbage, and initializing the entire array is impractical because of its size. Describe a scheme for implementing a direct-address dictionary on a huge array. Each stored object should use \\(O(1)\\) space; the operations Search, Insert, and Delete should take \\(O(1)\\) time each; and initializing the data structure should take \\(O(1)\\) time. (_Hint_: Use an additional array, treated somewhat like a stack whose size is the number of keys actually stored in the dictionary, to help determine whether a given entry in the huge array is valid or not.)\n\n### Hash tables\n\nThe downside of direct addressing is apparent: if the universe \\(U\\) is large or infinite, storing a table \\(T\\) of size \\(|U|\\) may be impractical, or even impossible, given the memory available on a typical computer. Furthermore, the set \\(K\\) of keys _actually stored_ may be so small relative to \\(U\\) that most of the space allocated for \\(T\\) would be wasted.\n\nWhen the set \\(K\\) of keys stored in a dictionary is much smaller than the universe \\(U\\) of all possible keys, a hash table requires much less storage than a direct-address table. Specifically, the storage requirement reduces to \\(\\Theta(|K|)\\) while maintaining the benefit that searching for an element in the hash table still requires only \\(O(1)\\) time. The catch is that this bound is for the _average-case time_,1 whereas for direct addressing it holds for the _worst-case time_.\n\nFootnote 1: The definition of \u201caverage-case\u201d requires care\u2014are we assuming an input distribution over the keys, or are we randomizing the choice of hash function itself? We\u2019ll consider both approaches, but with an emphasis on the use of a randomly chosen hash function.\n\nWith direct addressing, an element with key \\(k\\) is stored in slot \\(k\\), but with hashing, we use a _hash function_\\(h\\) to compute the slot number from the key \\(k\\), so that the element goes into slot \\(h(k)\\). The hash function \\(h\\) maps the universe \\(U\\) of keys into the slots of a _hash table_\\(T[0:m-1]\\):\n\n\\[h:U\\to\\{0,1,\\ldots,m-1\\}\\enspace,\\]\n\nwhere the size \\(m\\) of the hash table is typically much less than \\(|U|\\). We say that an element with key \\(k\\)_hashes_ to slot \\(h(k)\\), and we also say that \\(h(k)\\) is the _hash value_ of key \\(k\\). Figure 11.2 illustrates the basic idea. The hash function reduces the range of array indices and hence the size of the array. Instead of a size of \\(|U|\\), the array can have size \\(m\\). An example of a simple, but not particularly good, hash function is \\(h(k)=k\\) mod \\(m\\).\n\nThere is one hitch, namely that two keys may hash to the same slot. We call this situation a _collision_. Fortunately, there are effective techniques for resolving the conflict created by collisions.\n\nOf course, the ideal solution is to avoid collisions altogether. We might try to achieve this goal by choosing a suitable hash function \\(h\\). One idea is to make \\(h\\) appear to be \"random,\" thus avoiding collisions or at least minimizing their number. The very term \"to hash,\" evoking images of random mixing and chopping, captures the spirit of this approach. (Of course, a hash function \\(h\\) must be deterministic in that a given input \\(k\\) must always produce the same output \\(h(k)\\).) Because \\(|U|>m\\), however, there must be at least two keys that have the same hash value,",
        "chapter": "Part III Data Structures",
        "section": "11 Hash Tables",
        "subsection": "11.1 Direct-address tables",
        "subsubsection": "N/A"
    },
    {
        "content": "### Hash tables\n\nThe downside of direct addressing is apparent: if the universe \\(U\\) is large or infinite, storing a table \\(T\\) of size \\(|U|\\) may be impractical, or even impossible, given the memory available on a typical computer. Furthermore, the set \\(K\\) of keys _actually stored_ may be so small relative to \\(U\\) that most of the space allocated for \\(T\\) would be wasted.\n\nWhen the set \\(K\\) of keys stored in a dictionary is much smaller than the universe \\(U\\) of all possible keys, a hash table requires much less storage than a direct-address table. Specifically, the storage requirement reduces to \\(\\Theta(|K|)\\) while maintaining the benefit that searching for an element in the hash table still requires only \\(O(1)\\) time. The catch is that this bound is for the _average-case time_,1 whereas for direct addressing it holds for the _worst-case time_.\n\nFootnote 1: The definition of \u201caverage-case\u201d requires care\u2014are we assuming an input distribution over the keys, or are we randomizing the choice of hash function itself? We\u2019ll consider both approaches, but with an emphasis on the use of a randomly chosen hash function.\n\nWith direct addressing, an element with key \\(k\\) is stored in slot \\(k\\), but with hashing, we use a _hash function_\\(h\\) to compute the slot number from the key \\(k\\), so that the element goes into slot \\(h(k)\\). The hash function \\(h\\) maps the universe \\(U\\) of keys into the slots of a _hash table_\\(T[0:m-1]\\):\n\n\\[h:U\\to\\{0,1,\\ldots,m-1\\}\\enspace,\\]\n\nwhere the size \\(m\\) of the hash table is typically much less than \\(|U|\\). We say that an element with key \\(k\\)_hashes_ to slot \\(h(k)\\), and we also say that \\(h(k)\\) is the _hash value_ of key \\(k\\). Figure 11.2 illustrates the basic idea. The hash function reduces the range of array indices and hence the size of the array. Instead of a size of \\(|U|\\), the array can have size \\(m\\). An example of a simple, but not particularly good, hash function is \\(h(k)=k\\) mod \\(m\\).\n\nThere is one hitch, namely that two keys may hash to the same slot. We call this situation a _collision_. Fortunately, there are effective techniques for resolving the conflict created by collisions.\n\nOf course, the ideal solution is to avoid collisions altogether. We might try to achieve this goal by choosing a suitable hash function \\(h\\). One idea is to make \\(h\\) appear to be \"random,\" thus avoiding collisions or at least minimizing their number. The very term \"to hash,\" evoking images of random mixing and chopping, captures the spirit of this approach. (Of course, a hash function \\(h\\) must be deterministic in that a given input \\(k\\) must always produce the same output \\(h(k)\\).) Because \\(|U|>m\\), however, there must be at least two keys that have the same hash value,and avoiding collisions altogether is impossible. Thus, although a well-designed, \"random\"-looking hash function can reduce the number of collisions, we still need a method for resolving the collisions that do occur.\n\nThe remainder of this section first presents a definition of \"independent uniform hashing,\" which captures the simplest notion of what it means for a hash function to be \"random.\" It then presents and analyzes the simplest collision resolution technique, called chaining. Section 11.4 introduces an alternative method for resolving collisions, called open addressing.\n\n##### Independent uniform hashing\n\nAn \"ideal\" hashing function \\(h\\) would have, for each possible input \\(k\\) in the domain \\(U\\), an output \\(h(k)\\) that is an element randomly and independently chosen uniformly from the range \\(\\{0,1,\\ldots,m-1\\}\\). Once a value \\(h(k)\\) is randomly chosen, each subsequent call to \\(h\\) with the same input \\(k\\) yields the same output \\(h(k)\\).\n\nWe call such an ideal hash function an _independent uniform hash function_. Such a function is also often called a _random oracle_[43]. When hash tables are implemented with an independent uniform hash function, we say we are using _independent uniform hashing_.\n\nIndependent uniform hashing is an ideal theoretical abstraction, but it is not something that can reasonably be implemented in practice. Nonetheless, we'll analyze the efficiency of hashing under the assumption of independent uniform hashing and then present ways of achieving useful practical approximations to this ideal.\n\nFigure 11.2: Using a hash function \\(h\\) to map keys to hash-table slots. Because keys \\(k_{2}\\) and \\(k_{5}\\) map to the same slot, they collide.\n\n### Hash tables\n\n#### Collision resolution by chaining\n\nAt a high level, you can think of hashing with chaining as a nonrecursive form of divide-and-conquer: the input set of \\(n\\) elements is divided randomly into \\(m\\) subsets, each of approximate size \\(n/m\\). A hash function determines which subset an element belongs to. Each subset is managed independently as a list.\n\nFigure 11.3 shows the idea behind _chaining_: each nonempty slot points to a linked list, and all the elements that hash to the same slot go into that slot's linked list. Slot \\(j\\) contains a pointer to the head of the list of all stored elements with hash value \\(j\\). If there are no such elements, then slot \\(j\\) contains nil.\n\nWhen collisions are resolved by chaining, the dictionary operations are straightforward to implement. They appear on the next page and use the linked-list procedures from Section 10.2. The worst-case running time for insertion is \\(O(1)\\). The insertion procedure is fast in part because it assumes that the element \\(x\\) being inserted is not already present in the table. To enforce this assumption, you can search (at additional cost) for an element whose key is \\(x\\)._key_ before inserting. For searching, the worst-case running time is proportional to the length of the list. (We'll analyze this operation more closely below.) Deletion takes \\(O(1)\\) time if the lists are doubly linked, as in Figure 11.3. (Since Chained-Hash-Delete takes as input an element \\(x\\) and not its key \\(k\\), no search is needed. If the hash table supports deletion, then its linked lists should be doubly linked in order to delete an item quickly. If the lists were only singly linked, then by Exercise 10.2-1, deletion\n\nFigure 11.3: Collision resolution by chaining. Each nonempty hash-table slot \\(T[j]\\) points to a linked list of all the keys whose hash value is \\(j\\). For example, \\(h(k_{1})=h(k_{4})\\) and \\(h(k_{5})=h(k_{2})=h(k_{7})\\). The list can be either singly or doubly linked. We show it as doubly linked because deletion may be faster that way when the deletion procedure knows which list element (not just which key) is to be deleted.\n\ncould take time proportional to the length of the list. With singly linked lists, both deletion and searching would have the same asymptotic running times.)\n\n##### Analysis of hashing with chaining\n\nHow well does hashing with chaining perform? In particular, how long does it take to search for an element with a given key?\n\nGiven a hash table \\(T\\) with \\(m\\) slots that stores \\(n\\) elements, we define the _load factor_\\(\\alpha\\) for \\(T\\) as \\(n/m\\), that is, the average number of elements stored in a chain. Our analysis will be in terms of \\(\\alpha\\), which can be less than, equal to, or greater than 1.\n\nThe worst-case behavior of hashing with chaining is terrible: all \\(n\\) keys hash to the same slot, creating a list of length \\(n\\). The worst-case time for searching is thus \\(\\Theta(n)\\) plus the time to compute the hash function--no better than using one linked list for all the elements. We clearly don't use hash tables for their worst-case performance.\n\nThe average-case performance of hashing depends on how well the hash function \\(h\\) distributes the set of keys to be stored among the \\(m\\) slots, on the average (meaning with respect to the distribution of keys to be hashed and with respect to the choice of hash function, if this choice is randomized). Section 11.3 discusses these issues, but for now we assume that any given element is equally likely to hash into any of the \\(m\\) slots. That is, the hash function is _uniform_. We further assume that where a given element hashes to is _independent_ of where any other elements hash to. In other words, we assume that we are using _independent uniform hashing_.\n\nBecause hashes of distinct keys are assumed to be independent, independent uniform hashing is _universal_: the chance that any two distinct keys \\(k_{1}\\) and \\(k_{2}\\) collide is at most \\(1/m\\). Universality is important in our analysis and also in the specification of universal families of hash functions, which we'll see in Section 11.3.2.\n\nFor \\(j=0,1,\\ldots,m-1\\), denote the length of the list \\(T[j]\\) by \\(n_{j}\\), so that \\(n=n_{0}+n_{1}+\\cdots+n_{m-1}\\),\n\nand the expected value of \\(n_{j}\\) is \\(\\mathrm{E}\\left[n_{j}\\right]=\\alpha=n/m\\).\n\nWe assume that \\(O(1)\\) time suffices to compute the hash value \\(h(k)\\), so that the time required to search for an element with key \\(k\\) depends linearly on the length \\(n_{h(k)}\\) of the list \\(T[h(k)]\\). Setting aside the \\(O(1)\\) time required to compute the hash function and to access slot \\(h(k)\\), we'll consider the expected number of elements examined by the search algorithm, that is, the number of elements in the list \\(T[h(k)]\\) that the algorithm checks to see whether any have a key equal to \\(k\\). We consider two cases. In the first, the search is unsuccessful: no element in the table has key \\(k\\). In the second, the search successfully finds an element with key \\(k\\).\n\n**Theorem 11.1**: _In a hash table in which collisions are resolved by chaining, an unsuccessful search takes \\(\\Theta(1+\\alpha)\\) time on average, under the assumption of independent uniform hashing._\n\nProofUnder the assumption of independent uniform hashing, any key \\(k\\) not already stored in the table is equally likely to hash to any of the \\(m\\) slots. The expected time to search unsuccessfully for a key \\(k\\) is the expected time to search to the end of list \\(T[h(k)]\\), which has expected length \\(\\mathrm{E}\\left[n_{h(k)}\\right]=\\alpha\\). Thus, the expected number of elements examined in an unsuccessful search is \\(\\alpha\\), and the total time required (including the time for computing \\(h(k)\\)) is \\(\\Theta(1+\\alpha)\\).\n\nThe situation for a successful search is slightly different. An unsuccessful search is equally likely to go to any slot of the hash table. A successful search, however, cannot go to an empty slot, since it is for an element that is present in one of the linked lists. We assume that the element searched for is equally likely to be any one of the elements in the table, so the longer the list, the more likely that the search is for one of its elements. Even so, the expected search time still turns out to be \\(\\Theta(1+\\alpha)\\).\n\n**Theorem 11.2**: _In a hash table in which collisions are resolved by chaining, a successful search takes \\(\\Theta(1+\\alpha)\\) time on average, under the assumption of independent uniform hashing._\n\nProofWe assume that the element being searched for is equally likely to be any of the \\(n\\) elements stored in the table. The number of elements examined during a successful search for an element \\(x\\) is 1 more than the number of elements that appear before \\(x\\) in \\(x\\)'s list. Because new elements are placed at the front of the list,elements before \\(x\\) in the list were all inserted after \\(x\\) was inserted. Let \\(x_{i}\\) denote the \\(i\\)th element inserted into the table, for \\(i=1,2,\\ldots,n\\), and let \\(k_{i}=x_{i}\\)._key_.\n\nOur analysis uses indicator random variables extensively. For each slot \\(q\\) in the table and for each pair of distinct keys \\(k_{i}\\) and \\(k_{j}\\), we define the indicator random variable\n\n\\[X_{ijq}=\\mbox{I}\\left\\{\\mbox{the search is for $x_{i}$, $h(k_{i})=q$, and $h(k_{j})=q$}\\right\\}\\.\\]\n\nThat is, \\(X_{ijq}=1\\) when keys \\(k_{i}\\) and \\(k_{j}\\) collide at slot \\(q\\) and the search is for element \\(x_{i}\\). Because \\(\\Pr\\left\\{\\mbox{the search is for $x_{i}$}\\right\\}=\\ 1/n\\), \\(\\Pr\\left\\{h(k_{i})=q\\right\\}=\\ 1/m\\), \\(\\Pr\\left\\{h(k_{j})=q\\right\\}=\\ 1/m\\), and these events are all independent, we have that \\(\\Pr\\left\\{X_{ijq}=1\\right\\}=1/n\\,m^{2}\\). Lemma 5.1 on page 130 gives \\(\\mbox{E}\\left[X_{ijq}\\right]=1/n\\,m^{2}\\).\n\nNext, we define, for each element \\(x_{j}\\), the indicator random variable\n\n\\[Y_{j} = \\mbox{I}\\left\\{x_{j}\\mbox{ appears in a list prior to the element being searched for}\\right\\}\\] \\[= \\sum_{q=0}^{m-1}\\sum_{i=1}^{j-1}X_{ijq}\\,\\]\n\nsince at most one of the \\(X_{ijq}\\) equals 1, namely when the element \\(x_{i}\\) being searched for belongs to the same list as \\(x_{j}\\) (pointed to by slot \\(q\\)), and \\(i<j\\) (so that \\(x_{i}\\) appears after \\(x_{j}\\) in the list).\n\nOur final random variable is \\(Z\\), which counts how many elements appear in the list prior to the element being searched for:\n\n\\[Z=\\sum_{j=1}^{n}Y_{j}\\.\\]\n\nBecause we must count the element being searched for as well as all those preceding it in its list, we wish to compute \\(\\mbox{E}\\left[Z+1\\right]\\). Using linearity of expectation (equation (C.24) on page 1192), we have\n\n\\[\\mbox{E}\\left[Z+1\\right] = \\mbox{E}\\left[1+\\sum_{j=1}^{n}Y_{j}\\right]\\] \\[= 1+\\mbox{E}\\left[\\sum_{j=1}^{n}\\sum_{q=0}^{m-1}\\sum_{i=1}^{j-1}X _{ijq}\\right]\\] \\[= 1+\\mbox{E}\\left[\\sum_{q=0}^{m-1}\\sum_{j=1}^{n}\\sum_{i=1}^{j-1}X _{ijq}\\right]\\] \\[= 1+\\sum_{q=0}^{m-1}\\sum_{j=1}^{n}\\sum_{i=1}^{j-1}\\mbox{E}\\left[X _{ijq}\\right]\\ \\ \\ \\ \\ \\mbox{(by linearity of expectation)}\\]\n\n### 11.2 Hash tables\n\n\\[= 1+\\sum_{q=0}^{m-1}\\sum_{j=1}^{n}\\sum_{i=1}^{j-1}\\frac{1}{n\\,m^{2}}\\] \\[= 1+m\\cdot\\frac{n(n-1)}{2}\\cdot\\frac{1}{n\\,m^{2}}\\qquad\\mbox{(by equation (A.2) on page 1141)}\\] \\[= 1+\\frac{n-1}{2m}\\] \\[= 1+\\frac{n}{2m}-\\frac{1}{2m}\\] \\[= 1+\\frac{\\alpha}{2}-\\frac{\\alpha}{2n}\\.\\]\n\nThus, the total time required for a successful search (including the time for computing the hash function) is \\(\\Theta(2+\\alpha/2-\\alpha/2n)=\\Theta(1+\\alpha)\\).\n\nWhat does this analysis mean? If the number of elements in the table is at most proportional to the number of hash-table slots, we have \\(n=O(m)\\) and, consequently, \\(\\alpha=n/m=O(m)/m=O(1)\\). Thus, searching takes constant time on average. Since insertion takes \\(O(1)\\) worst-case time and deletion takes \\(O(1)\\) worst-case time when the lists are doubly linked (assuming that the list element to be deleted is known, and not just its key), we can support all dictionary operations in \\(O(1)\\) time on average.\n\nThe analysis in the preceding two theorems depends only on two essential properties of independent uniform hashing: uniformity (each key is equally likely to hash to any one of the \\(m\\) slots), and independence (so any two distinct keys collide with probability \\(1/m\\)).\n\n#### Exercises\n\n##### 11.2-1\n\nYou use a hash function \\(h\\) to hash \\(n\\) distinct keys into an array \\(T\\) of length \\(m\\). Assuming independent uniform hashing, what is the expected number of collisions? More precisely, what is the expected cardinality of \\(\\{\\{k_{1},k_{2}\\}:k_{1}\\neq k_{2}\\) and \\(h(k_{1})=h(k_{2})\\}\\)?\n\n##### 11.2-2\n\nConsider a hash table with 9 slots and the hash function \\(h(k)=k\\) mod 9. Demonstrate what happens upon inserting the keys \\(5,28,19,15,20,33,12,17,10\\) with collisions resolved by chaining.\n\n#### 11.2-3\n\nProfessor Marley hypothesizes that he can obtain substantial performance gains by modifying the chaining scheme to keep each list in sorted order. How does the professor's modification affect the running time for successful searches, unsuccessful searches, insertions, and deletions?\n\n#### 11.2-4\n\nSuggest how to allocate and deallocate storage for elements within the hash table itself by creating a \"free list\": a linked list of all the unused slots. Assume that one slot can store a flag and either one element plus a pointer or two pointers. All dictionary and free-list operations should run in \\(O(1)\\) expected time. Does the free list need to be doubly linked, or does a singly linked free list suffice?\n\n#### 11.2-5\n\nYou need to store a set of \\(n\\) keys in a hash table of size \\(m\\). Show that if the keys are drawn from a universe \\(U\\) with \\(|U|>(n-1)m\\), then \\(U\\) has a subset of size \\(n\\) consisting of keys that all hash to the same slot, so that the worst-case searching time for hashing with chaining is \\(\\Theta(n)\\).\n\n#### 11.2-6\n\nYou have stored \\(n\\) keys in a hash table of size \\(m\\), with collisions resolved by chaining, and you know the length of each chain, including the length \\(L\\) of the longest chain. Describe a procedure that selects a key uniformly at random from among the keys in the hash table and returns it in expected time \\(O(L\\cdot(1+1/\\alpha))\\).\n\n### 11.3 Hash functions\n\nFor hashing to work well, it needs a good hash function. Along with being efficiently computable, what properties does a good hash function have? How do you design good hash functions?\n\nThis section first attempts to answer these questions based on two ad hoc approaches for creating hash functions: hashing by division and hashing by multiplication. Although these methods work well for some sets of input keys, they are limited because they try to provide a single fixed hash function that works well on any data--an approach called _static hashing_.\n\nWe then see that provably good average-case performance for _any_ data can be obtained by designing a suitable _family_ of hash functions and choosing a hash function at random from this family at runtime, independent of the data to be hashed. The approach we examine is called random hashing. A particular kind of random",
        "chapter": "Part III Data Structures",
        "section": "11 Hash Tables",
        "subsection": "11.2 Hash tables",
        "subsubsection": "N/A"
    },
    {
        "content": "#### 11.2-3\n\nProfessor Marley hypothesizes that he can obtain substantial performance gains by modifying the chaining scheme to keep each list in sorted order. How does the professor's modification affect the running time for successful searches, unsuccessful searches, insertions, and deletions?\n\n#### 11.2-4\n\nSuggest how to allocate and deallocate storage for elements within the hash table itself by creating a \"free list\": a linked list of all the unused slots. Assume that one slot can store a flag and either one element plus a pointer or two pointers. All dictionary and free-list operations should run in \\(O(1)\\) expected time. Does the free list need to be doubly linked, or does a singly linked free list suffice?\n\n#### 11.2-5\n\nYou need to store a set of \\(n\\) keys in a hash table of size \\(m\\). Show that if the keys are drawn from a universe \\(U\\) with \\(|U|>(n-1)m\\), then \\(U\\) has a subset of size \\(n\\) consisting of keys that all hash to the same slot, so that the worst-case searching time for hashing with chaining is \\(\\Theta(n)\\).\n\n#### 11.2-6\n\nYou have stored \\(n\\) keys in a hash table of size \\(m\\), with collisions resolved by chaining, and you know the length of each chain, including the length \\(L\\) of the longest chain. Describe a procedure that selects a key uniformly at random from among the keys in the hash table and returns it in expected time \\(O(L\\cdot(1+1/\\alpha))\\).\n\n### 11.3 Hash functions\n\nFor hashing to work well, it needs a good hash function. Along with being efficiently computable, what properties does a good hash function have? How do you design good hash functions?\n\nThis section first attempts to answer these questions based on two ad hoc approaches for creating hash functions: hashing by division and hashing by multiplication. Although these methods work well for some sets of input keys, they are limited because they try to provide a single fixed hash function that works well on any data--an approach called _static hashing_.\n\nWe then see that provably good average-case performance for _any_ data can be obtained by designing a suitable _family_ of hash functions and choosing a hash function at random from this family at runtime, independent of the data to be hashed. The approach we examine is called random hashing. A particular kind of randomhashing, universal hashing, works well. As we saw with quicksort in Chapter 7, randomization is a powerful algorithmic design tool.\n\n##### What makes a good hash function?\n\nA good hash function satisfies (approximately) the assumption of independent uniform hashing: each key is equally likely to hash to any of the \\(m\\) slots, independently of where any other keys have hashed to. What does \"equally likely\" mean here? If the hash function is fixed, any probabilities would have to be based on the probability distribution of the input keys.\n\nUnfortunately, you typically have no way to check this condition, unless you happen to know the probability distribution from which the keys are drawn. Moreover, the keys might not be drawn independently.\n\nOccasionally you might know the distribution. For example, if you know that the keys are random real numbers \\(k\\) independently and uniformly distributed in the range \\(0\\leq k<1\\), then the hash function\n\n\\[h(k)=\\lfloor km\\rfloor\\]\n\nsatisfies the condition of independent uniform hashing.\n\nA good static hashing approach derives the hash value in a way that you expect to be independent of any patterns that might exist in the data. For example, the \"division method\" (discussed in Section 11.3.1) computes the hash value as the remainder when the key is divided by a specified prime number. This method may give good results, if you (somehow) choose a prime number that is unrelated to any patterns in the distribution of keys.\n\nRandom hashing, described in Section 11.3.2, picks the hash function to be used at random from a suitable family of hashing functions. This approach removes any need to know anything about the probability distribution of the input keys, as the randomization necessary for good average-case behavior then comes from the (known) random process used to pick the hash function from the family of hash functions, rather than from the (unknown) process used to create the input keys. We recommend that you use random hashing.\n\n##### Keys are integers, vectors, or strings\n\nIn practice, a hash function is designed to handle keys that are one of the following two types:\n\n* A short nonnegative integer that fits in a \\(w\\)-bit machine word. Typical values for \\(w\\) would be 32 or 64.\n\n* A short vector of nonnegative integers, each of bounded size. For example, each element might be an 8-bit byte, in which case the vector is often called a (byte) string. The vector might be of variable length.\n\nTo begin, we assume that keys are short nonnegative integers. Handling vector keys is more complicated and discussed in Sections 11.3.5 and 11.5.2.\n\n#### Static hashing\n\nStatic hashing uses a single, fixed hash function. The only randomization available is through the (usually unknown) distribution of input keys. This section discusses two standard approaches for static hashing: the division method and the multiplication method. Although static hashing is no longer recommended, the multiplication method also provides a good foundation for \"nonstatic\" hashing--better known as random hashing--where the hash function is chosen at random from a suitable family of hash functions.\n\n##### The division method\n\nThe _division method_ for creating hash functions maps a key \\(k\\) into one of \\(m\\) slots by taking the remainder of \\(k\\) divided by \\(m\\). That is, the hash function is\n\n\\(h(k)=k\\mod m\\).\n\nFor example, if the hash table has size \\(m=12\\) and the key is \\(k=100\\), then \\(h(k)=4\\). Since it requires only a single division operation, hashing by division is quite fast.\n\nThe division method may work well when \\(m\\) is a prime not too close to an exact power of 2. There is no guarantee that this method provides good average-case performance, however, and it may complicate applications since it constrains the size of the hash tables to be prime.\n\n##### The multiplication method\n\nThe general _multiplication method_ for creating hash functions operates in two steps. First, multiply the key \\(k\\) by a constant \\(A\\) in the range \\(0<A<1\\) and extract the fractional part of \\(kA\\). Then, multiply this value by \\(m\\) and take the floor of the result. That is, the hash function is\n\n\\(h(k)=\\lfloor m\\;(kA\\mod 1)\\rfloor\\),\n\nwhere \"\\(kA\\mod 1\\)\" means the fractional part of \\(kA\\), that is, \\(kA-\\lfloor kA\\rfloor\\). The general multiplication method has the advantage that the value of \\(m\\) is not critical and you can choose it independently of how you choose the multiplicative constant \\(A\\).\n\n### 11.3 Hash functions\n\n#### The multiply-shift method\n\nIn practice, the multiplication method is best in the special case where the number \\(m\\) of hash-table slots is an exact power of 2, so that \\(m=2^{\\ell}\\) for some integer \\(\\ell\\), where \\(\\ell\\leq w\\) and \\(w\\) is the number of bits in a machine word. If you choose a fixed \\(w\\)-bit positive integer \\(a=A\\,2^{w}\\), where \\(0<A<1\\) as in the multiplication method so that \\(a\\) is in the range \\(0<a<2^{w}\\), you can implement the function on most computers as follows. We assume that a key \\(k\\) fits into a single \\(w\\)-bit word.\n\nReferring to Figure 11.4, first multiply \\(k\\) by the \\(w\\)-bit integer \\(a\\). The result is a \\(2w\\)-bit value \\(r_{1}2^{w}+r_{0}\\), where \\(r_{1}\\) is the high-order \\(w\\)-bit word of the product and \\(r_{0}\\) is the low-order \\(w\\)-bit word of the product. The desired \\(\\ell\\)-bit hash value consists of the \\(\\ell\\) most significant bits of \\(r_{0}\\). (Since \\(r_{1}\\) is ignored, the hash function can be implemented on a computer that produces only a \\(w\\)-bit product given two \\(w\\)-bit inputs, that is, where the multiplication operation computes modulo \\(2^{w}\\).)\n\nIn other words, you define the hash function \\(h=h_{a}\\), where\n\n\\[h_{a}(k)=(ka\\bmod 2^{w})\\ggg(w-\\ell) \\tag{11.2}\\]\n\nfor a fixed nonzero \\(w\\)-bit value \\(a\\). Since the product \\(ka\\) of two \\(w\\)-bit words occupies \\(2w\\) bits, taking this product modulo \\(2^{w}\\) zeroes out the high-order \\(w\\) bits (\\(r_{1}\\)), leaving only the low-order \\(w\\) bits (\\(r_{0}\\)). The \\(\\ggg\\) operator performs a logical right shift by \\(w-\\ell\\) bits, shifting zeros into the vacated positions on the left, so that the \\(\\ell\\) most significant bits of \\(r_{0}\\) move into the \\(\\ell\\) rightmost positions. (It's the same as dividing by \\(2^{w-\\ell}\\) and taking the floor of the result.) The resulting value equals the \\(\\ell\\) most significant bits of \\(r_{0}\\). The hash function \\(h_{a}\\) can be implemented with three machine instructions: multiplication, subtraction, and logical right shift.\n\nAs an example, suppose that \\(k=123456\\), \\(\\ell=14\\), \\(m=2^{14}=16384\\), and \\(w=32\\). Suppose further that we choose \\(a=2654435769\\) (following a suggestion\n\nFigure 11.4: The multiply-shift method to compute a hash function. The \\(w\\)-bit representation of the key \\(k\\) is multiplied by the \\(w\\)-bit value \\(a=A\\cdot 2^{w}\\). The \\(\\ell\\) highest-order bits of the lower \\(w\\)-bit half of the product form the desired hash value \\(h_{a}(k)\\).\n\nof Knuth [261]). Then \\(ka=327706022297664=(76300\\cdot 2^{32})+17612864\\), and so \\(r_{1}=76300\\) and \\(r_{0}=17612864\\). The 14 most significant bits of \\(r_{0}\\) yield the value \\(h_{a}(k)=67\\).\n\nEven though the multiply-shift method is fast, it doesn't provide any guarantee of good average-case performance. The universal hashing approach presented in the next section provides such a guarantee. A simple randomized variant of the multiply-shift method works well on the average, when the program begins by picking \\(a\\) as a randomly chosen odd integer.\n\n#### Random hashing\n\nSuppose that a malicious adversary chooses the keys to be hashed by some fixed hash function. Then the adversary can choose \\(n\\) keys that all hash to the same slot, yielding an average retrieval time of \\(\\Theta(n)\\). Any static hash function is vulnerable to such terrible worst-case behavior. The only effective way to improve the situation is to choose the hash function _randomly_ in a way that is _independent_ of the keys that are actually going to be stored. This approach is called _random hashing_. A special case of this approach, called _universal hashing_, can yield provably good performance on average when collisions are handled by chaining, no matter which keys the adversary chooses.\n\nTo use random hashing, at the beginning of program execution you select the hash function at random from a suitable family of functions. As in the case of quicksort, randomization guarantees that no single input always evokes worst-case behavior. Because you randomly select the hash function, the algorithm can behave differently on each execution, even for the same set of keys to be hashed, guaranteeing good average-case performance.\n\nLet \\(\\mathcal{H}\\) be a finite family of hash functions that map a given universe \\(U\\) of keys into the range \\(\\{0,1,\\ldots,m-1\\}\\). Such a family is said to be _universal_ if for each pair of distinct keys \\(k_{1},k_{2}\\in U\\), the number of hash functions \\(h\\in\\mathcal{H}\\) for which \\(h(k_{1})=h(k_{2})\\) is at most \\(\\left|\\mathcal{H}\\right|/m\\). In other words, with a hash function randomly chosen from \\(\\mathcal{H}\\), the chance of a collision between distinct keys \\(k_{1}\\) and \\(k_{2}\\) is no more than the chance \\(1/m\\) of a collision if \\(h(k_{1})\\) and \\(h(k_{2})\\) were randomly and independently chosen from the set \\(\\{0,1,\\ldots,m-1\\}\\).\n\nIndependent uniform hashing is the same as picking a hash function uniformly at random from a family of \\(m^{n}\\) hash functions, each member of that family mapping the \\(n\\) keys to the \\(m\\) hash values in a different way.\n\nEvery independent uniform random family of hash function is universal, but the converse need not be true: consider the case where \\(U=\\{0,1,\\ldots,m-1\\}\\) and the only hash function in the family is the identity function. The probability that two distinct keys collide is zero, even though each key is hashes to a fixed value.\n\nThe following corollary to Theorem 11.2 on page 279 says that universal hashing provides the desired payoff: it becomes impossible for an adversary to pick a sequence of operations that forces the worst-case running time.\n\n**Corollary 11.3**: _Using universal hashing and collision resolution by chaining in an initially empty table with slots, it takes expected time to handle any sequence of Insert, Search, and Delete operations containing._\n\nProofThe Insert and Delete operations take constant time. Since the number of insertions is, we have that. Furthermore, the expected time for each Search operation is, which can be seen by examining the proof of Theorem 11.2. That analysis depends only on collision probabilities, which are for any pair of keys by the choice of an independent uniform hash function in that theorem. Using a universal family of hash functions here instead of using independent uniform hashing changes the probability of collision from to at most. By linearity of expectation, therefore, the expected time for the entire sequence of operations is. Since each operation takes time, the bound follows.\n\n#### Achievable properties of random hashing\n\nThere is a rich literature on the properties a family of hash functions can have, and how they relate to the efficiency of hashing. We summarize a few of the most interesting ones here.\n\nLet be a family of hash functions, each with domain and range, and let be any hash function that is picked uniformly at random from. The probabilities mentioned are probabilities over the picks of.\n\n* The family is if any key in and any slot in the range, the probability that is is.\n* The family is if for any distinct keys in, the probability that is at most. Therefore, a universal family of hash functions is also -universal.2 Footnote 2: In the literature, a -universal hash function is sometimes called -universal or -approximately universal. We\u2019ll stick with the notation -universal.\n\n* The family \\(\\mathcal{H}\\) is \\(\\boldsymbol{d}\\)_-independent_ if for any distinct keys \\(k_{1}\\), \\(k_{2}\\),..., \\(k_{d}\\) in \\(U\\) and any slots \\(q_{1}\\), \\(q_{2}\\),..., \\(q_{d}\\), not necessarily distinct, in \\(\\{0,1,\\ldots,m-1\\}\\) the probability that \\(h(k_{i})=q_{i}\\) for \\(i=1,2,\\ldots,d\\) is \\(1/m^{d}\\). Universal hash-function families are of particular interest, as they are the simplest type supporting provably efficient hash-table operations for any input data set. Many other interesting and desirable properties, such as those noted above, are also possible and allow for efficient specialized hash-table operations.\n\n#### 11.3.4 Designing a universal family of hash functions\n\nThis section present two ways to design a universal (or \\(\\epsilon\\)-universal) family of hash functions: one based on number theory and another based on a randomized variant of the multiply-shift method presented in Section 11.3.1. The first method is a bit easier to prove universal, but the second method is newer and faster in practice.\n\n#### A universal family of hash functions based on number theory\n\nWe can design a universal family of hash functions using a little number theory. You may wish to refer to Chapter 31 if you are unfamiliar with basic concepts in number theory.\n\nBegin by choosing a prime number \\(p\\) large enough so that every possible key \\(k\\) lies in the range \\(0\\) to \\(p-1\\), inclusive. We assume here that \\(p\\) has a \"reasonable\" length. (See Section 11.3.5 for a discussion of methods for handling long input keys, such as variable-length strings.) Let \\(\\mathbb{Z}_{p}\\) denote the set \\(\\{0,1,\\ldots,\\,p-1\\}\\), and let \\(\\mathbb{Z}_{p}^{\\,*}\\) denote the set \\(\\{1,2,\\ldots,\\,p-1\\}\\). Since \\(p\\) is prime, we can solve equations modulo \\(p\\) with the methods given in Chapter 31. Because the size of the universe of keys is greater than the number of slots in the hash table (otherwise, just use direct addressing), we have \\(p>m\\).\n\nGiven any \\(a\\in\\mathbb{Z}_{p}^{\\,*}\\) and any \\(b\\in\\mathbb{Z}_{p}\\), define the hash function \\(h_{ab}\\) as a linear transformation followed by reductions modulo \\(p\\) and then modulo \\(m\\):\n\n\\[h_{ab}(k)=((ak+b)\\bmod p)\\bmod m. \\tag{11.3}\\]\n\nFor example, with \\(p=17\\) and \\(m=6\\), we have\n\n\\[h_{3,4}(8) = ((3\\cdot 8+4)\\bmod 17)\\bmod 6\\] \\[= (28\\bmod 17)\\bmod 6\\] \\[= 11\\bmod 6\\] \\[= 5\\.\\] Given \\(p\\) and \\(m\\), the family of all such hash functions is\n\n\\[\\mathcal{H}_{pm}=\\left\\{h_{ab}:a\\in\\mathbb{Z}_{p}^{\\,*}\\mbox{ and }b\\in\\mathbb{Z}_{p} \\right\\}. \\tag{11.4}\\]\n\n### Hash functions\n\nEach hash function \\(h_{ab}\\) maps \\(\\mathbb{Z}_{p}\\) to \\(\\mathbb{Z}_{m}\\). This family of hash functions has the nice property that the size \\(m\\) of the output range (which is the size of the hash table) is arbitrary -- it need not be prime. Since you can choose from among \\(p-1\\) values for \\(a\\) and \\(p\\) values for \\(b\\), the family \\(\\mathcal{H}_{pm}\\) contains \\(p(p-1)\\) hash functions.\n\n**Theorem 11.4**: _The family \\(\\mathcal{H}_{pm}\\) of hash functions defined by equations (11.3) and (11.4) is universal._\n\n_Proof_ Consider two distinct keys \\(k_{1}\\) and \\(k_{2}\\) from \\(\\mathbb{Z}_{p}\\), so that \\(k_{1}\\neq k_{2}\\). For a given hash function \\(h_{ab}\\), let\n\n\\(r_{1}\\ =\\ (a\\,k_{1}+b)\\bmod\\,p\\),\n\n\\(r_{2}\\ =\\ (a\\,k_{2}+b)\\bmod\\,p\\).\n\nWe first note that \\(r_{1}\\neq r_{2}\\). Why? Since we have \\(r_{1}-r_{2}=a(k_{1}-k_{2})\\pmod{p}\\), it follows that \\(r_{1}\\neq r_{2}\\) because \\(p\\) is prime and both \\(a\\) and \\((k_{1}-k_{2})\\) are nonzero modulo \\(p\\). By Theorem 31.6 on page 908, their product must also be nonzero modulo \\(p\\). Therefore, when computing any \\(h_{ab}\\in\\mathcal{H}_{pm}\\), distinct inputs \\(k_{1}\\) and \\(k_{2}\\) map to distinct values \\(r_{1}\\) and \\(r_{2}\\) modulo \\(p\\), and there are no collisions yet at the \"mod \\(p\\) level.\" Moreover, each of the possible \\(p(p-1)\\) choices for the pair \\((a,b)\\) with \\(a\\neq 0\\) yields a _different_ resulting pair \\((r_{1},r_{2})\\) with \\(r_{1}\\neq r_{2}\\), since we can solve for \\(a\\) and \\(b\\) given \\(r_{1}\\) and \\(r_{2}\\):\n\n\\(a\\ =\\ \\big{(}(r_{1}-r_{2})((k_{1}-k_{2})^{-1}\\bmod\\,p)\\big{)}\\bmod\\,p\\),\n\n\\(b\\ =\\ (r_{1}-ak_{1})\\bmod\\,p\\),\n\nwhere (\\((k_{1}-k_{2})^{-1}\\bmod\\,p\\)) denotes the unique multiplicative inverse, modulo \\(p\\), of \\(k_{1}-k_{2}\\). For each of the \\(p\\) possible values of \\(r_{1}\\), there are only \\(p-1\\) possible values of \\(r_{2}\\) that do not equal \\(r_{1}\\), making only \\(p(p-1)\\) possible pairs \\((r_{1},r_{2})\\) with \\(r_{1}\\neq r_{2}\\). Therefore, there is a one-to-one correspondence between pairs \\((a,b)\\) with \\(a\\neq 0\\) and pairs \\((r_{1},r_{2})\\) with \\(r_{1}\\neq r_{2}\\). Thus, for any given pair of distinct inputs \\(k_{1}\\) and \\(k_{2}\\), if we pick \\((a,b)\\) uniformly at random from \\(\\mathbb{Z}_{p}^{*}\\times\\mathbb{Z}_{p}\\), the resulting pair \\((r_{1},r_{2})\\) is equally likely to be any pair of distinct values modulo \\(p\\).\n\nTherefore, the probability that distinct keys \\(k_{1}\\) and \\(k_{2}\\) collide is equal to the probability that \\(r_{1}=r_{2}\\pmod{m}\\) when \\(r_{1}\\) and \\(r_{2}\\) are randomly chosen as distinct values modulo \\(p\\). For a given value of \\(r_{1}\\), of the \\(p-1\\) possible remaining values for \\(r_{2}\\), the number of values \\(r_{2}\\) such that \\(r_{2}\\neq r_{1}\\) and \\(r_{2}=r_{1}\\pmod{m}\\) is at most\n\n\\[\\left\\lceil\\,\\frac{p}{m}\\,\\right\\rceil-1 \\ \\leq\\ \\frac{p+m-1}{m}-1\\quad\\text{(by inequality (\\ref{eq:11}) on page 908})\\] \\[=\\ \\frac{p-1}{m}\\.\\]The probability that \\(r_{2}\\) collides with \\(r_{1}\\) when reduced modulo \\(m\\) is at most \\(((p-1)/m)/(p-1)=1/m\\), since \\(r_{2}\\) is equally likely to be any of the \\(p-1\\) values in \\(Z_{p}\\) that are different from \\(r_{1}\\), but at most \\((p-1)/m\\) of those values are equivalent to \\(r_{1}\\) modulo \\(m\\).\n\nTherefore, for any pair of distinct values \\(k_{1},k_{2}\\in\\mathbb{Z}_{p}\\),\n\n\\[\\Pr\\left\\{h_{ab}\\left(k_{1}\\right)=h_{ab}\\left(k_{2}\\right)\\right\\}\\leq 1/m\\,\\]\n\nso that \\(\\mathcal{H}_{pm}\\) is indeed universal.\n\n### A \\(2/m\\)-universal family of hash functions based on the multiply-shift method\n\nWe recommend that in practice you use the following hash-function family based on the multiply-shift method. It is exceptionally efficient and (although we omit the proof) provably \\(2/m\\)-universal. Define \\(\\mathcal{H}\\) to be the family of multiply-shift hash functions with odd constants \\(a\\):\n\n\\[\\mathcal{H}=\\left\\{h_{a}:a\\text{ is odd, }1\\leq a<m\\text{, and }h_{a}\\text{ is defined by equation }\\eqref{eq:hash-function-}\\right\\}. \\tag{11.5}\\]\n\n**Theorem 11.5**: The family of hash functions \\(\\mathcal{H}\\) given by equation (11.5) is \\(2/m\\)-universal.\n\nThat is, the probability that any two distinct keys collide is at most \\(2/m\\). In many practical situations, the speed of computing the hash function more than compensates for the higher upper bound on the probability that two distinct keys collide when compared with a universal hash function.\n\n#### Hashing long inputs such as vectors or strings\n\nSometimes hash function inputs are so long that they cannot be easily encoded modulo a reasonably sized prime number \\(p\\) or encoded within a single word of, say, 64 bits. As an example, consider the class of vectors, such as vectors of \\(8\\)-bit bytes (which is how strings in many programming languages are stored). A vector might have an arbitrary nonnegative length, in which case the length of the input to the hash function may vary from input to input.\n\n### Number-theoretic approaches\n\nOne way to design good hash functions for variable-length inputs is to extend the ideas used in Section 11.3.4 to design universal hash functions. Exercise 11.3-6 explores one such approach.\n\n### Cryptographic hashing\n\nAnother way to design a good hash function for variable-length inputs is to use a hash function designed for cryptographic applications. _Cryptographic hash functions_ are complex pseudorandom functions, designed for applications requiring properties beyond those needed here, but are robust, widely implemented, and usable as hash functions for hash tables.\n\nA cryptographic hash function takes as input an arbitrary byte string and returns a fixed-length output. For example, the NIST standard deterministic cryptographic hash function SHA-256 [346] produces a 256-bit (32-byte) output for any input.\n\nSome chip manufacturers include instructions in their CPU architectures to provide fast implementations of some cryptographic functions. Of particular interest are instructions that efficiently implement rounds of the Advanced Encryption Standard (AES), the \"AES-NI\" instructions. These instructions execute in a few tens of nanoseconds, which is generally fast enough for use with hash tables. A message authentication code such as CBC-MAC based on AES and the use of the AES-NI instructions could be a useful and efficient hash function. We don't pursue the potential use of specialized instruction sets further here.\n\nCryptographic hash functions are useful because they provide a way of implementing an approximate version of a random oracle. As noted earlier, a random oracle is equivalent to an independent uniform hash function family. From a theoretical point of view, a random oracle is an unachievable ideal: a deterministic function that provides a randomly selected output for each input. Because it is deterministic, it provides the same output if queried again for the same input. From a practical point of view, constructions of hash function families based on cryptographic hash functions are sensible substitutes for random oracles.\n\nThere are many ways to use a cryptographic hash function as a hash function. For example, we could define\n\n\\[h(k)=\\mbox{SHA-256}\\,(k)\\mbox{ mod }m\\.\\]\n\nTo define a family of such hash functions one may prepend a \"salt\" string \\(a\\) to the input before hashing it, as in\n\n\\[h_{a}(k)=\\mbox{SHA-256}\\,(a\\parallel k)\\mbox{ mod }m\\,\\]\n\nwhere \\(a\\parallel k\\) denotes the string formed by concatenating the strings \\(a\\) and \\(k\\). The literature on message authentication codes (MACs) provides additional approaches.\n\nCryptographic approaches to hash-function design are becoming more practical as computers arrange their memories in hierarchies of differing capacities and speeds. Section 11.5 discusses one hash-function design based on the RC6 encryption method.\n\n### Exercises\n\n#### 11.3-1\n\nYou wish to search a linked list of length \\(n\\), where each element contains a key \\(k\\) along with a hash value \\(h(k)\\). Each key is a long character string. How might you take advantage of the hash values when searching the list for an element with a given key?\n\n#### 11.3-2\n\nYou hash a string of \\(r\\) characters into \\(m\\) slots by treating it as a radix-128 number and then using the division method. You can represent the number \\(m\\) as a 32-bit computer word, but the string of \\(r\\) characters, treated as a radix-128 number, takes many words. How can you apply the division method to compute the hash value of the character string without using more than a constant number of words of storage outside the string itself?\n\n#### 11.3-3\n\nConsider a version of the division method in which \\(h(k)=k\\bmod m\\), where \\(m=2^{p}-1\\) and \\(k\\) is a character string interpreted in radix \\(2^{p}\\). Show that if string \\(x\\) can be converted to string \\(y\\) by permuting its characters, then \\(x\\) and \\(y\\) hash to the same value. Give an example of an application in which this property would be undesirable in a hash function.\n\n#### 11.3-4\n\nConsider a hash table of size \\(m=1000\\) and a corresponding hash function \\(h(k)=\\lfloor m\\ (kA\\bmod 1)\\rfloor\\) for \\(A=(\\sqrt{5}-1)/2\\). Compute the locations to which the keys 61, 62, 63, 64, and 65 are mapped.\n\n* _11.3-5_ Show that any \\(\\epsilon\\)-universal family \\(\\mathcal{H}\\) of hash functions from a finite set \\(U\\) to a finite set \\(Q\\) has \\(\\epsilon\\geq 1/\\left\\lvert Q\\right\\rvert-1/\\left\\lvert U\\right\\rvert\\).\n* _11.3-6_ Let \\(U\\) be the set of \\(d\\)-tuples of values drawn from \\(\\mathbb{Z}_{p}\\), and let \\(Q=\\mathbb{Z}_{p}\\), where \\(p\\) is prime. Define the hash function \\(h_{b}:U\\to Q\\) for \\(b\\in\\mathbb{Z}_{p}\\) on an input \\(d\\)-tuple \\(\\langle a_{0},a_{1},\\ldots,a_{d-1}\\rangle\\) from \\(U\\) as \\[h_{b}(\\langle a_{0},a_{1},\\ldots,a_{d-1}\\rangle)=\\left(\\sum_{j=0}^{d-1}a_{j}b^ {j}\\right)\\bmod\\ p\\,\\] and let \\(\\mathcal{H}=\\{h_{b}:b\\in\\mathbb{Z}_{p}\\}\\). Argue that \\(\\mathcal{H}\\) is \\(\\epsilon\\)-universal for \\(\\epsilon=(d-1)/p\\). (_Hint:_ See Exercise 31.4-4.)\n\n### Open addressing\n\nThis section describes open addressing, a method for collision resolution that, unlike chaining, does not make use of storage outside of the hash table itself. In _open addressing_, all elements occupy the hash table itself. That is, each table entry contains either an element of the dynamic set or nil. No lists or elements are stored outside the table, unlike in chaining. Thus, in open addressing, the hash table can \"fill up\" so that no further insertions can be made. One consequence is that the load factor \\(\\alpha\\) can never exceed 1.\n\nCollisions are handled as follows: when a new element is to be inserted into the table, it is placed in its \"first-choice\" location if possible. If that location is already occupied, the new element is placed in its \"second-choice\" location. The process continues until an empty slot is found in which to place the new element. Different elements have different preference orders for the locations.\n\nTo search for an element, systematically examine the preferred table slots for that element, in order of decreasing preference, until either you find the desired element or you find an empty slot and thus verify that the element is not in the table.\n\nOf course, you could use chaining and store the linked lists inside the hash table, in the otherwise unused hash-table slots (see Exercise 11.2-4), but the advantage of open addressing is that it avoids pointers altogether. Instead of following pointers, you compute the sequence of slots to be examined. The memory freed by not storing pointers provides the hash table with a larger number of slots in the same amount of memory, potentially yielding fewer collisions and faster retrieval.\n\nTo perform insertion using open addressing, successively examine, or _probe_, the hash table until you find an empty slot in which to put the key. Instead of being fixed in the order \\(0,1,\\ldots,m-1\\) (which implies a \\(\\Theta(n)\\) search time), the sequence of positions probed depends upon the key being inserted. To determine which slots to probe, the hash function includes the probe number (starting from \\(0\\)) as a second input. Thus, the hash function becomes\n\n\\[h:U\\times\\{0,1,\\ldots,m-1\\}\\rightarrow\\{0,1,\\ldots,m-1\\}\\enspace.\\]\n\nOpen addressing requires that for every key \\(k\\), the _probe sequence_\\(\\langle h(k,0),h(k,1),\\)\\(\\ldots,h(k,m-1)\\rangle\\) be a permutation of \\(\\langle 0,1,\\ldots,m-1\\rangle\\), so that every hash-table position is eventually considered as a slot for a new key as the table fills up. The Hash-Insert procedure on the following page assumes that the elements in the hash table \\(T\\) are keys with no satellite information: the key \\(k\\) is identical to the element containing key \\(k\\). Each slot contains either a key or nil (if the slot is empty). The Hash-Insert procedure takes as input a hash table \\(T\\) and a key",
        "chapter": "Part III Data Structures",
        "section": "11 Hash Tables",
        "subsection": "11.3 Hash functions",
        "subsubsection": "N/A"
    },
    {
        "content": "### Open addressing\n\nThis section describes open addressing, a method for collision resolution that, unlike chaining, does not make use of storage outside of the hash table itself. In _open addressing_, all elements occupy the hash table itself. That is, each table entry contains either an element of the dynamic set or nil. No lists or elements are stored outside the table, unlike in chaining. Thus, in open addressing, the hash table can \"fill up\" so that no further insertions can be made. One consequence is that the load factor \\(\\alpha\\) can never exceed 1.\n\nCollisions are handled as follows: when a new element is to be inserted into the table, it is placed in its \"first-choice\" location if possible. If that location is already occupied, the new element is placed in its \"second-choice\" location. The process continues until an empty slot is found in which to place the new element. Different elements have different preference orders for the locations.\n\nTo search for an element, systematically examine the preferred table slots for that element, in order of decreasing preference, until either you find the desired element or you find an empty slot and thus verify that the element is not in the table.\n\nOf course, you could use chaining and store the linked lists inside the hash table, in the otherwise unused hash-table slots (see Exercise 11.2-4), but the advantage of open addressing is that it avoids pointers altogether. Instead of following pointers, you compute the sequence of slots to be examined. The memory freed by not storing pointers provides the hash table with a larger number of slots in the same amount of memory, potentially yielding fewer collisions and faster retrieval.\n\nTo perform insertion using open addressing, successively examine, or _probe_, the hash table until you find an empty slot in which to put the key. Instead of being fixed in the order \\(0,1,\\ldots,m-1\\) (which implies a \\(\\Theta(n)\\) search time), the sequence of positions probed depends upon the key being inserted. To determine which slots to probe, the hash function includes the probe number (starting from \\(0\\)) as a second input. Thus, the hash function becomes\n\n\\[h:U\\times\\{0,1,\\ldots,m-1\\}\\rightarrow\\{0,1,\\ldots,m-1\\}\\enspace.\\]\n\nOpen addressing requires that for every key \\(k\\), the _probe sequence_\\(\\langle h(k,0),h(k,1),\\)\\(\\ldots,h(k,m-1)\\rangle\\) be a permutation of \\(\\langle 0,1,\\ldots,m-1\\rangle\\), so that every hash-table position is eventually considered as a slot for a new key as the table fills up. The Hash-Insert procedure on the following page assumes that the elements in the hash table \\(T\\) are keys with no satellite information: the key \\(k\\) is identical to the element containing key \\(k\\). Each slot contains either a key or nil (if the slot is empty). The Hash-Insert procedure takes as input a hash table \\(T\\) and a keythat is assumed to be not already present in the hash table. It either returns the slot number where it stores key \\(k\\) or flags an error because the hash table is already full.\n\n\\[\\begin{array}{ll}\\mbox{Hash-Insert}(T,k)\\\\ \\\\ 1\\\n\n### 11.4 Open addressing\n\nThe main challenge of this thesis is to develop a new approach to the problem of computing the number of nodes in a given node. The main challenge is to develop a new approach to the problem of computing the number of nodes in a given node.\n\ncould choose \\(m\\) prime and let\n\n\\[h_{1}(k)\\ =\\ k\\ \\bmod\\ m\\,\\] \\[h_{2}(k)\\ =\\ 1\\ +\\ (k\\ \\bmod\\ m^{\\prime})\\,\\]\n\nwhere \\(m^{\\prime}\\) is chosen to be slightly less than \\(m\\) (say, \\(m-1\\)). For example, if \\(k=123456\\), \\(m=701\\), and \\(m^{\\prime}=700\\), then \\(h_{1}(k)=80\\) and \\(h_{2}(k)=257\\), so that the first probe goes to position \\(80\\), and successive probes examine every \\(257\\)th slot (modulo \\(m\\)) until the key has been found or every slot has been examined.\n\nAlthough values of \\(m\\) other than primes or exact powers of \\(2\\) can in principle be used with double hashing, in practice it becomes more difficult to efficiently generate \\(h_{2}(k)\\) (other than choosing \\(h_{2}(k)=1\\), which gives linear probing) in a way that ensures that it is relatively prime to \\(m\\), in part because the relative density \\(\\phi(m)/m\\) of such numbers for general \\(m\\) may be small (see equation (31.25) on page 921).\n\nWhen \\(m\\) is prime or an exact power of \\(2\\), double hashing produces \\(\\Theta(m^{2})\\) probe sequences, since each possible \\((h_{1}(k),h_{2}(k))\\) pair yields a distinct probe sequence. As a result, for such values of \\(m\\), double hashing appears to perform close to the \"ideal\" scheme of independent uniform permutation hashing.\n\nFigure 11.5: Insertion by double hashing. The hash table has size \\(13\\) with \\(h_{1}(k)=k\\ \\bmod 13\\) and \\(h_{2}(k)=1+(k\\ \\bmod 11)\\). Since \\(14=1\\pmod{13}\\) and \\(14=3\\pmod{11}\\), the key \\(14\\) goes into empty slot \\(9\\), after slots \\(1\\) and \\(5\\) are examined and found to be occupied.\n\n### Linear probing\n\n_Linear probing_, a special case of double hashing, is the simplest open-addressing approach to resolving collisions. As with double hashing, an auxiliary hash function \\(h_{1}\\) determines the first probe position \\(h_{1}(k)\\) for inserting an element. If slot \\(T[h_{1}(k)]\\) is already occupied, probe the next position \\(T[h_{1}(k)+1]\\). Keep going as necessary, on up to slot \\(T[m-1]\\), and then wrap around to slots \\(T[0]\\), \\(T[1]\\), and so on, but never going past slot \\(T[h_{1}(k)-1]\\). To view linear probing as a special case of double hashing, just set the double-hashing step function \\(h_{2}\\) to be fixed at \\(1\\): \\(h_{2}(k)=1\\) for all \\(k\\). That is, the hash function is\n\n\\[h(k,i)=(h_{1}(k)+i)\\bmod m \\tag{11.6}\\]\n\nfor \\(i=0,1,\\ldots,m-1\\). The value of \\(h_{1}(k)\\) determines the entire probe sequence, and so assuming that \\(h_{1}(k)\\) can take on any value in \\(\\{0,1,\\ldots,m-1\\}\\), linear probing allows only \\(m\\) distinct probe sequences.\n\nWe'll revisit linear probing in Section 11.5.1.\n\n### Analysis of open-address hashing\n\nAs in our analysis of chaining in Section 11.2, we analyze open addressing in terms of the load factor \\(\\alpha=n/m\\) of the hash table. With open addressing, at most one element occupies each slot, and thus \\(n\\leq m\\), which implies \\(\\alpha\\leq 1\\). The analysis below requires \\(\\alpha\\) to be strictly less than \\(1\\), and so we assume that at least one slot is empty. Because deleting from an open-address hash table does not really free up a slot, we assume as well that no deletions occur.\n\nFor the hash function, we assume independent uniform permutation hashing. In this idealized scheme, the probe sequence \\(\\langle h(k,0),h(k,1),\\ldots,h(k,m-1)\\rangle\\) used to insert or search for each key \\(k\\) is equally likely to be any permutation of \\(\\langle 0,\\,1,\\allowbreak\\ldots,m-1\\rangle\\). Of course, any given key has a unique fixed probe sequence associated with it. What we mean here is that, considering the probability distribution on the space of keys and the operation of the hash function on the keys, each possible probe sequence is equally likely.\n\nWe now analyze the expected number of probes for hashing with open addressing under the assumption of independent uniform permutation hashing, beginning with the expected number of probes made in an unsuccessful search (assuming, as stated above, that \\(\\alpha<1\\)).\n\nThe bound proven, of \\(1/(1-\\alpha)=1+\\alpha+\\alpha^{2}+\\alpha^{3}+\\cdots\\), has an intuitive interpretation. The first probe always occurs. With probability approximately \\(\\alpha\\), the first probe finds an occupied slot, so that a second probe happens. With probability approximately \\(\\alpha^{2}\\), the first two slots are occupied so that a third probe ensues, and so on.\n\n**Theorem 11.6**: _Given an open-address hash table with load factor \\(\\alpha=n/m{<}1\\), the expected number of probes in an unsuccessful search is at most \\(1/(1-\\alpha)\\), assuming independent uniform permutation hashing and no deletions._\n\nProofIn an unsuccessful search, every probe but the last accesses an occupied slot that does not contain the desired key, and the last slot probed is empty. Let the random variable \\(X\\) denote the number of probes made in an unsuccessful search, and define the event \\(A_{i}\\), for \\(i=1,2,\\ldots\\), as the event that an \\(i\\)th probe occurs and it is to an occupied slot. Then the event \\(\\{X\\geq i\\}\\) is the intersection of events \\(A_{1}\\cap A_{2}\\cap\\cdots\\cap A_{i-1}\\). We bound \\(\\Pr\\left\\{X\\geq i\\right\\}\\) by bounding \\(\\Pr\\left\\{A_{1}\\cap A_{2}\\cap\\cdots\\cap A_{i-1}\\right\\}\\). By Exercise C.2-5 on page 1190,\n\n\\[\\Pr\\left\\{A_{1}\\cap A_{2}\\cap\\cdots\\cap A_{i-1}\\right\\} = \\Pr\\left\\{A_{1}\\right\\}\\cdot\\Pr\\left\\{A_{2}\\mid A_{1}\\right\\} \\cdot\\Pr\\left\\{A_{3}\\mid A_{1}\\cap A_{2}\\right\\}\\cdots\\] \\[\\Pr\\left\\{A_{i-1}\\mid A_{1}\\cap A_{2}\\cap\\cdots\\cap A_{i-2} \\right\\}\\;.\\]\n\nSince there are \\(n\\) elements and \\(m\\) slots, \\(\\Pr\\left\\{A_{1}\\right\\}=n/m\\). For \\(j>1\\), the probability that there is a \\(j\\)th probe and it is to an occupied slot, given that the first \\(j-1\\) probes were to occupied slots, is \\((n-j+1)/(m-j+1)\\). This probability follows because the \\(j\\)th probe would be finding one of the remaining \\((n-(j-1))\\) elements in one of the \\((m-(j-1))\\) unexamined slots, and by the assumption of independent uniform permutation hashing, the probability is the ratio of these quantities. Since \\(n<m\\) implies that \\((n-j)/(m-j)\\leq n/m\\) for all \\(j\\) in the range \\(0\\leq j<m\\), it follows that for all \\(i\\) in the range \\(1\\leq i\\leq m\\), we have\n\n\\[\\Pr\\left\\{X\\geq i\\right\\} = \\frac{n}{m}\\cdot\\frac{n-1}{m-1}\\cdot\\frac{n-2}{m-2}\\cdots\\frac{n- i+2}{m-i+2}\\] \\[\\leq \\left(\\frac{n}{m}\\right)^{i-1}\\] \\[= \\alpha^{i-1}\\;.\\]\n\nThe product in the first line has \\(i-1\\) factors. When \\(i=1\\), the product is 1, the identity for multiplication, and we get \\(\\Pr\\left\\{X\\geq 1\\right\\}=1\\), which makes sense, since there must always be at least 1 probe. If each of the first \\(n\\) probes is to an occupied slot, then all occupied slots have been probed. Then, the \\((n+1)\\)st probe must be to an empty slot, which gives \\(\\Pr\\left\\{X\\geq i\\right\\}=0\\) for \\(i>n+1\\). Now, we use equation (C.28) on page 1193 to bound the expected number of probes:\n\n\\[\\mathrm{E}\\left[X\\right] = \\sum_{i=1}^{\\infty}\\Pr\\left\\{X\\geq i\\right\\}\\] \\[= \\sum_{i=1}^{n+1}\\Pr\\left\\{X\\geq i\\right\\}+\\sum_{i>n+1}\\Pr\\left\\{X \\geq i\\right\\}\\]\n\n### Open addressing\n\n\\[\\leq \\sum_{i=1}^{\\infty}\\alpha^{i-1}+0\\] \\[= \\sum_{i=0}^{\\infty}\\alpha^{i}\\] \\[= \\frac{1}{1-\\alpha}\\qquad\\text{(by equation (A.7) on page 1142 because $0\\leq\\alpha<1$)}\\.\\]\n\nIf \\(\\alpha\\) is a constant, Theorem 11.6 predicts that an unsuccessful search runs in \\(O(1)\\) time. For example, if the hash table is half full, the average number of probes in an unsuccessful search is at most \\(1/(1-.5)=2\\). If it is 90% full, the average number of probes is at most \\(1/(1-.9)=10\\).\n\nTheorem 11.6 yields almost immediately how well the Hash-Insert procedure performs.\n\n**Corollary 11.7**: _Inserting an element into an open-address hash table with load factor \\(\\alpha\\), where \\(\\alpha<1\\), requires at most \\(1/(1-\\alpha)\\) probes on average, assuming independent uniform permutation hashing and no deletions._\n\n_Proof_An element is inserted only if there is room in the table, and thus \\(\\alpha<1\\). Inserting a key requires an unsuccessful search followed by placing the key into the first empty slot found. Thus, the expected number of probes is at most \\(1/(1-\\alpha)\\).\n\nIt takes a little more work to compute the expected number of probes for a successful search.\n\n**Theorem 11.8**: _Given an open-address hash table with load factor \\(\\alpha<1\\), the expected number of probes in a successful search is at most_\n\n\\[\\frac{1}{\\alpha}\\ln\\frac{1}{1-\\alpha}\\,\\]\n\n_assuming independent uniform permutation hashing with no deletions and assuming that each key in the table is equally likely to be searched for._\n\n_Proof_A search for a key \\(k\\) reproduces the same probe sequence as when the element with key \\(k\\) was inserted. If \\(k\\) was the (\\(i+1\\))st key inserted into the hash table, then the load factor at the time it was inserted was \\(i/m\\), and so by Corollary 11.7, the expected number of probes made in a search for \\(k\\) is at most \\(1/(1-i/m)=m/(m-i)\\). Averaging over all \\(n\\) keys in the hash table gives usthe expected number of probes in a successful search:\n\n\\[\\frac{1}{n}\\sum_{i=0}^{n-1}\\frac{m}{m-i} = \\frac{m}{n}\\sum_{i=0}^{n-1}\\frac{1}{m-i}\\] \\[= \\frac{1}{\\alpha}\\sum_{k=m-n+1}^{m}\\frac{1}{k}\\] \\[\\leq \\frac{1}{\\alpha}\\int_{m-n}^{m}\\frac{1}{x}\\;dx\\qquad\\mbox{(by inequality (A.19) on page 1150)}\\] \\[= \\frac{1}{\\alpha}\\;(\\ln m-\\ln(m-n))\\] \\[= \\frac{1}{\\alpha}\\ln\\frac{m}{m-n}\\] \\[= \\frac{1}{\\alpha}\\ln\\frac{1}{1-\\alpha}\\;.\\]\n\nIf the hash table is half full, the expected number of probes in a successful search is less than \\(1.387\\). If the hash table is \\(90\\%\\) full, the expected number of probes is less than \\(2.559\\). If \\(\\alpha=1\\), then in an unsuccessful search, all \\(m\\) slots must be probed. Exercise 11.4-4 asks you to analyze a successful search when \\(\\alpha=1\\).\n\n##### Exercises\n\n##### 11.4-1\n\nConsider inserting the keys \\(10,22,31,4,15,28,17,88,59\\) into a hash table of length \\(m=11\\) using open addressing. Illustrate the result of inserting these keys using linear probing with \\(h(k,i)=(k+i)\\) mod \\(m\\) and using double hashing with \\(h_{1}(k)=k\\) and \\(h_{2}(k)=1+(k\\) mod \\((m-1))\\).\n\n##### 11.4-2\n\nWrite pseudocode for Hash-Delete that fills the deleted key's slot with the special value deleted, and modify Hash-Search and Hash-Insert as needed to handle deleted.\n\n##### 11.4-3\n\nConsider an open-address hash table with independent uniform permutation hashing and no deletions. Give upper bounds on the expected number of probes in an unsuccessful search and on the expected number of probes in a successful search when the load factor is \\(3/4\\) and when it is \\(7/8\\).\n\n### Practical considerations\n\n**11.4-4**: Show that the expected number of probes required for a successful search when \\(\\alpha=1\\) (that is, when \\(n=m\\)), is \\(H_{m}\\), the \\(m\\)th harmonic number.\n**\\(\\bigstar\\)**: _11.4-5_: Show that, with double hashing, if \\(m\\) and \\(h_{2}(k)\\) have greatest common divisor \\(d\\geq 1\\) for some key \\(k\\), then an unsuccessful search for key \\(k\\) examines \\((1/d)\\)th of the hash table before returning to slot \\(h_{1}(k)\\). Thus, when \\(d=1\\), so that \\(m\\) and \\(h_{2}(k)\\) are relatively prime, the search may examine the entire hash table. (_Hint:_ See Chapter 31.)\n**\\(\\bigstar\\)**: _11.4-6_: Consider an open-address hash table with a load factor \\(\\alpha\\). Approximate the nonzero value \\(\\alpha\\) for which the expected number of probes in an unsuccessful search equals twice the expected number of probes in a successful search. Use the upper bounds given by Theorems 11.6 and 11.8 for these expected numbers of probes.\n\n### Practical considerations\n\nEfficient hash table algorithms are not only of theoretical interest, but also of immense practical importance. Constant factors can matter. For this reason, this section discusses two aspects of modern CPUs that are not included in the standard RAM model presented in Section 2.2:\n**Memory hierarchies:**: The memory of modern CPUs has a number of levels, from the fast registers, through one or more levels of _cache memory_, to the main-memory level. Each successive level stores more data than the previous level, but access is slower. As a consequence, a complex computation (such as a complicated hash function) that works entirely within the fast registers can take less time than a single read operation from main memory. Furthermore, cache memory is organized in _cache blocks_ of (say) 64 bytes each, which are always fetched together from main memory. There is a substantial benefit for ensuring that memory usage is local: reusing the same cache block is much more efficient than fetching a different cache block from main memory.\n\nThe standard RAM model measures efficiency of a hash-table operation by counting the number of hash-table slots probed. In practice, this metric is only a crude approximation to the truth, since once a cache block is in the cache, successive probes to that cache block are much faster than probes that must access main memory.",
        "chapter": "Part III Data Structures",
        "section": "11 Hash Tables",
        "subsection": "11.4 Open addressing",
        "subsubsection": "N/A"
    },
    {
        "content": "### Practical considerations\n\n**11.4-4**: Show that the expected number of probes required for a successful search when \\(\\alpha=1\\) (that is, when \\(n=m\\)), is \\(H_{m}\\), the \\(m\\)th harmonic number.\n**\\(\\bigstar\\)**: _11.4-5_: Show that, with double hashing, if \\(m\\) and \\(h_{2}(k)\\) have greatest common divisor \\(d\\geq 1\\) for some key \\(k\\), then an unsuccessful search for key \\(k\\) examines \\((1/d)\\)th of the hash table before returning to slot \\(h_{1}(k)\\). Thus, when \\(d=1\\), so that \\(m\\) and \\(h_{2}(k)\\) are relatively prime, the search may examine the entire hash table. (_Hint:_ See Chapter 31.)\n**\\(\\bigstar\\)**: _11.4-6_: Consider an open-address hash table with a load factor \\(\\alpha\\). Approximate the nonzero value \\(\\alpha\\) for which the expected number of probes in an unsuccessful search equals twice the expected number of probes in a successful search. Use the upper bounds given by Theorems 11.6 and 11.8 for these expected numbers of probes.\n\n### Practical considerations\n\nEfficient hash table algorithms are not only of theoretical interest, but also of immense practical importance. Constant factors can matter. For this reason, this section discusses two aspects of modern CPUs that are not included in the standard RAM model presented in Section 2.2:\n\n**Memory hierarchies:**: The memory of modern CPUs has a number of levels, from the fast registers, through one or more levels of _cache memory_, to the main-memory level. Each successive level stores more data than the previous level, but access is slower. As a consequence, a complex computation (such as a complicated hash function) that works entirely within the fast registers can take less time than a single read operation from main memory. Furthermore, cache memory is organized in _cache blocks_ of (say) 64 bytes each, which are always fetched together from main memory. There is a substantial benefit for ensuring that memory usage is local: reusing the same cache block is much more efficient than fetching a different cache block from main memory.\n\nThe standard RAM model measures efficiency of a hash-table operation by counting the number of hash-table slots probed. In practice, this metric is only a crude approximation to the truth, since once a cache block is in the cache, successive probes to that cache block are much faster than probes that must access main memory.\n\n**Advanced instruction sets:**: Modern CPUs may have sophisticated instruction sets that implement advanced primitives useful for encryption or other forms of cryptography. These instructions may be useful in the design of exceptionally efficient hash functions.\n\nSection 11.5.1 discusses linear probing, which becomes the collision-resolution method of choice in the presence of a memory hierarchy. Section 11.5.2 suggests how to construct \"advanced\" hash functions based on cryptographic primitives, suitable for use on computers with hierarchical memory models.\n\n#### Linear probing\n\nLinear probing is often disparaged because of its poor performance in the standard RAM model. But linear probing excels for hierarchical memory models, because successive probes are usually to the same cache block of memory.\n\n##### Deletion with linear probing\n\nAnother reason why linear probing is often not used in practice is that deletion seems complicated or impossible without using the special deleted value. Yet we'll now see that deletion from a hash table based on linear probing is not all that difficult, even without the deleted marker. The deletion procedure works for linear probing, but not for open-address probing in general, because with linear probing keys all follow the same simple cyclic probing sequence (albeit with different starting points).\n\nThe deletion procedure relies on an \"inverse\" function to the linear-probing hash function \\(h(k,i)=(h_{1}(k)+i)\\bmod m\\), which maps a key \\(k\\) and a probe number \\(i\\) to a slot number in the hash table. The inverse function \\(g\\) maps a key \\(k\\) and a slot number \\(q\\), where \\(0\\leq q<m\\), to the probe number that reaches slot \\(q\\):\n\n\\[g(k,q)=(q-h_{1}(k))\\bmod m\\.\\]\n\nIf \\(h(k,i)=q\\), then \\(g(k,q)=i\\), and so \\(h(k,g(k,q))=q\\).\n\nThe procedure Linear-Probing-Hash-Delete on the facing page deletes the key stored in position \\(q\\) from hash table \\(T\\). Figure 11.6 shows how it works. The procedure first deletes the key in position \\(q\\) by setting \\(T[q]\\) to nil in line 2. It then searches for a slot \\(q^{\\prime}\\) (if any) that contains a key that should be moved to the slot \\(q\\) just vacated by key \\(k\\). Line 9 asks the critical question: does the key \\(k^{\\prime}\\) in slot \\(q^{\\prime}\\) need to be moved to the vacated slot \\(q\\) in order to preserve the accessibility of \\(k^{\\prime}\\)? If \\(g(k^{\\prime},q)<g(k^{\\prime},q^{\\prime})\\), then during the insertion of \\(k^{\\prime}\\) into the table, slot \\(q\\) was examined but found to be already occupied. But now slot \\(q\\), where a search will look for \\(k^{\\prime}\\), is empty. In this case, key \\(k^{\\prime}\\) moves to slot \\(q\\) in line 10, and thesearch continues, to see whether any later key also needs to be moved to the slot \\(q^{\\prime}\\) that was just freed up when \\(k^{\\prime}\\) moved.\n\nLinear-Probing-Hash-Delete(\\(T,q\\))\n1. **while** true\n2. \\(T[q]\\,=\\,\\textsc{nil}\\) // make slot \\(q\\) empty\n3. \\(q^{\\prime}\\,=\\,q\\) // starting point for search\n4. **repeat**\n5. \\(q^{\\prime}\\,=\\,(q^{\\prime}\\,+\\,1)\\) mod \\(m\\) // next slot number with linear probing\n6. \\(k^{\\prime}\\,=\\,T[q^{\\prime}]\\) // next key to try to move\n7. **if**\\(k^{\\prime}\\,=\\,\\textsc{nil}\\)\n8. **return**\n9. **until**\\(g(k^{\\prime},q)\\,<\\,g(k^{\\prime},q^{\\prime})\\) // was empty slot \\(q\\) probed before \\(q^{\\prime}\\)?\n10. \\(T[q]\\,=\\,k^{\\prime}\\) // move \\(k^{\\prime}\\) into slot \\(q\\)\n11. \\(q\\,=\\,q^{\\prime}\\) // free up slot \\(q^{\\prime}\\)\n\nAnalysis of linear probing\n\nLinear probing is popular to implement, but it exhibits a phenomenon known as _primary clustering_. Long runs of occupied slots build up, increasing the average\n\nFigure 11.6: Deletion in a hash table that uses linear probing. The hash table has size 10 with \\(h_{1}(k)\\,=\\,k\\) mod 10. **(a)** The hash table after inserting keys in the order 74, 43, 93, 18, 82, 38, 92. **(b)** The hash table after deleting the key 43 from slot 3. Key 93 moves up to slot 3 to keep it accessible, and then key 92 moves up to slot 5 just vacated by key 93. No other keys need to be moved.\n\nsearch time. Clusters arise because an empty slot preceded by \\(i\\) full slots gets filled next with probability \\((i+1)/m\\). Long runs of occupied slots tend to get longer, and the average search time increases.\n\nIn the standard RAM model, primary clustering is a problem, and general double hashing usually performs better than linear probing. By contrast, in a hierarchical memory model, primary clustering is a beneficial property, as elements are often stored together in the same cache block. Searching proceeds through one cache block before advancing to search the next cache block. With linear probing, the running time for a key \\(k\\) of Hash-Insert, Hash-Search, or Linear-Probing-Hash-Delete is at most proportional to the distance from \\(h_{1}(k)\\) to the next empty slot.\n\nThe following theorem is due to Pagh et al. [351]. A more recent proof is given by Thorup [438]. We omit the proof here. The need for 5-independence is by no means obvious; see the cited proofs.\n\n**Theorem 11.9**: _If \\(h_{1}\\) is 5-independent and \\(\\alpha\\leq 2/3\\), then it takes expected constant time to search for, insert, or delete a key in a hash table using linear probing._\n\n(Indeed, the expected operation time is \\(O(1/\\epsilon^{2})\\) for \\(\\alpha=1-\\epsilon\\).)\n\n#### 11.5.2 Hash functions for hierarchical memory models\n\nThis section illustrates an approach for designing efficient hash tables in a modern computer system having a memory hierarchy.\n\nBecause of the memory hierarchy, linear probing is a good choice for resolving collisions, as probe sequences are sequential and tend to stay within cache blocks. But linear probing is most efficient when the hash function is complex (for example, 5-independent as in Theorem 11.9). Fortunately, having a memory hierarchy means that complex hash functions can be implemented efficiently.\n\nAs noted in Section 11.3.5, one approach is to use a cryptographic hash function such as SHA-256. Such functions are complex and sufficiently random for hash table applications. On machines with specialized instructions, cryptographic functions can be quite efficient.\n\nInstead, we present here a simple hash function based only on addition, multiplication, and swapping the halves of a word. This function can be implemented entirely within the fast registers, and on a machine with a memory hierarchy, its latency is small compared with the time taken to access a random slot of the hash table. It is related to the RC6 encryption algorithm and can for practical purposes be considered a \"random oracle,\"\n\n### Practical considerations\n\n#### The wee hash function\n\nLet \\(w\\) denote the word size of the machine (e.g., \\(w=64\\)), assumed to be even, and let \\(a\\) and \\(b\\) be \\(w\\)-bit unsigned (nonnegative) integers such that \\(a\\) is odd. Let \\(\\operatorname{swap}(x)\\) denote the \\(w\\)-bit result of swapping the two \\(w/2\\)-bit halves of \\(w\\)-bit input \\(x\\). That is,\n\n\\[\\operatorname{swap}(x)=(x\\ggg(w/2))+(x\\lll(w/2))\\]\n\nwhere \"\\(\\ggg\\)\" is \"logical right shift\" (as in equation (11.2)) and \"\\(\\lll\\) is \"left shift.\" Define\n\n\\[f_{a}(k)=\\operatorname{swap}((2k^{2}+ak)\\bmod 2^{w})\\.\\]\n\nThus, to compute \\(f_{a}(k)\\), evaluate the quadratic function \\(2k^{2}+ak\\) modulo \\(2^{w}\\) and then swap the left and right halves of the result.\n\nLet \\(r\\) denote a desired number of \"rounds\" for the computation of the hash function. We'll use \\(r=4\\), but the hash function is well defined for any nonnegative \\(r\\). Denote by \\(f_{a}^{(r)}(k)\\) the result of iterating \\(f_{a}\\) a total of \\(r\\) times (that is, \\(r\\) rounds) starting with input value \\(k\\). For any odd \\(a\\) and any \\(r\\geq 0\\), the function \\(f_{a}^{(r)}\\), although complicated, is one-to-one (see Exercise 11.5-1). A cryptographer would view \\(f_{a}^{(r)}\\) as a simple block cipher operating on \\(w\\)-bit input blocks, with \\(r\\) rounds and key \\(a\\).\n\nWe first define the wee hash function \\(h\\) for short inputs, where by \"short\" we means \"whose length \\(t\\) is at most \\(w\\)-bits,\" so that the input fits within one computer word. We would like inputs of different lengths to be hashed differently. The _wee hash function_\\(h_{a,b,t,r}(k)\\) for parameters \\(a\\), \\(b\\), and \\(r\\) on \\(t\\)-bit input \\(k\\) is defined as\n\n\\[h_{a,b,t,r}(k)=\\big{(}f_{a+2t}^{(r)}(k+b)\\big{)}\\bmod m. \\tag{11.7}\\]\n\nThat is, the hash value for \\(t\\)-bit input \\(k\\) is obtained by applying \\(f_{a+2t}^{(r)}\\) to \\(k+b\\), then taking the final result modulo \\(m\\). Adding the value \\(b\\) provides hash-dependent randomization of the input, in a way that ensures that for variable-length inputs the 0-length input does not have a fixed hash value. Adding the value \\(2t\\) to \\(a\\) ensures that the hash function acts differently for inputs of different lengths. (We use \\(2t\\) rather than \\(t\\) to ensure that the key \\(a+2t\\) is odd if \\(a\\) is odd.) We call this hash function \"wee\" because it uses a tiny amount of memory--more precisely, it can be implemented efficiently using only the computer's fast registers. (This hash function does not have a name in the literature; it is a variant we developed for this textbook.)\n\n#### Speed of the wee hash function\n\nIt is surprising how much efficiency can be bought with locality. Experiments (unpublished, by the authors) suggest that evaluating the wee hash function takes lesstime than probing a _single_ randomly chosen slot in a hash table. These experiments were run on a laptop (2019 MacBook Pro) with \\(w=64\\) and \\(a=123\\). For large hash tables, evaluating the wee hash function was 2 to 10 times faster than performing a single probe of the hash table.\n\n### The wee hash function for variable-length inputs\n\nSometimes inputs are long-- more than one \\(w\\)-bit word in length-- or have variable length, as discussed in Section 11.3.5. We can extend the wee hash function, defined above for inputs that are at most single \\(w\\)-bit word in length, to handle long or variable-length inputs. Here is one method for doing so.\n\nSuppose that an input \\(k\\) has length \\(t\\) (measured in bits). Break \\(k\\) into a sequence \\(\\langle k_{1},k_{2},\\ldots,k_{u}\\rangle\\) of \\(w\\)-bit words, where \\(u=\\lceil t/w\\rceil,k_{1}\\) contains the least-significant \\(w\\) bits of \\(k\\), and \\(k_{u}\\) contains the most significant bits. If \\(t\\) is not a multiple of \\(w\\), then \\(k_{u}\\) contains fewer than \\(w\\) bits, in which case, pad out the unused high-order bits of \\(k_{u}\\) with 0-bits. Define the function chop to return a sequence of the \\(w\\)-bit words in \\(k\\):\n\n\\[\\mbox{chop}(k)=\\langle k_{1},k_{2},\\ldots,k_{u}\\rangle\\.\\]\n\nThe most important property of the chop operation is that it is one-to-one, given \\(t\\): for any two \\(t\\)-bit keys \\(k\\) and \\(k^{\\prime}\\), if \\(k\\neq k^{\\prime}\\) then chop\\((k)\\neq\\) chop\\((k^{\\prime})\\), and \\(k\\) can be derived from chop\\((k)\\) and \\(t\\). The chop operation also has the useful property that a single-word input key yields a single-word output sequence: chop\\((k)=\\langle k\\rangle\\).\n\nWith the chop function in hand, we specify the wee hash function \\(h_{a,b,t,r}(k)\\) for an input \\(k\\) of length \\(t\\) bits as follows:\n\n\\[h_{a,b,t,r}(k)=\\mbox{\\sc Wee}(k,a,b,t,r,m)\\,\\]\n\nwhere the procedure Wee defined on the facing page iterates through the elements of the \\(w\\)-bit words returned by chop\\((k)\\), applying \\(f^{r}_{a}\\) to the sum of the current word \\(k_{i}\\) and the previously computed hash value so far, finally returning the result obtained modulo \\(m\\). This definition for variable-length and long (multiple-word) inputs is a consistent extension of the definition in equation (11.7) for short (single-word) inputs. For practical use, we recommend that \\(a\\) be a randomly chosen odd \\(w\\)-bit word, \\(b\\) be a randomly chosen \\(w\\)-bit word, and that \\(r=4\\).\n\nNote that the wee hash function is really a hash function family, with individual hash functions determined by parameters \\(a,b,t,r\\), and \\(m\\). The (approximate) 5-independence of the wee hash function family for variable-length inputs can be argued based on the assumption that the 1-word wee hash function is a random oracle and on the security of the cipher-block-chaining message authentication code (CBC-MAC), as studied by Bellare et al. [42]. The case here is actually simpler than that studied in the literature, since if two messages have different lengths \\(t\\) and \\(t^{\\prime}\\), then their \"keys\" are different: \\(a+2t\\neq a+2t^{\\prime}\\). We omit the details.\n\n### Practical considerations\n\nThis definition of a cryptographically inspired hash-function family is meant to be realistic, yet only illustrative, and many variations and improvements are possible. See the chapter notes for suggestions.\n\nIn summary, we see that when the memory system is hierarchical, it becomes advantageous to use linear probing (a special case of double hashing), since successive probes tend to stay in the same cache block. Furthermore, hash functions that can be implemented using only the computer's fast registers are exceptionally efficient, so they can be quite complex and even cryptographically inspired, providing the high degree of independence needed for linear probing to work most efficiently.\n\n**Exercises**\n\n* _11.5-1_ Complete the argument that for any odd positive integer \\(a\\) and any integer \\(r\\geq 0\\), the function \\(f_{a}^{(r)}\\) is one-to-one. Use a proof by contradiction and make use of the fact that the function \\(f_{a}\\) works modulo \\(2^{w}\\).\n* _11.5-2_ Argue that a random oracle is 5-independent.\n* _11.5-3_ Consider what happens to the value \\(f_{a}^{(r)}(k)\\) as we flip a single bit \\(k_{i}\\) of the input value \\(k\\), for various values of \\(r\\). Let \\(k=\\sum_{i=0}^{w-1}k_{i}2^{i}\\) and \\(g_{a}(k)=\\sum_{j=0}^{w-1}b_{j}2^{j}\\) define the bit values \\(k_{i}\\) in the input (with \\(k_{0}\\) the least-significant bit) and the bit values \\(b_{j}\\) in \\(g_{a}(k)=(2k^{2}+ak)\\bmod 2^{w}\\) (where \\(g_{a}(k)\\) is the value that, when its halves are swapped, becomes \\(f_{a}(k)\\)). Suppose that flipping a single bit \\(k_{i}\\) of the input \\(k\\) may cause any bit \\(b_{j}\\) of \\(g_{a}(k)\\) to flip, for \\(j\\geq i\\). What is the least value of \\(r\\) for which flipping the value of any single bit \\(k_{i}\\) may cause _any_ bit of the output \\(f_{a}^{(r)}(k)\\) to flip? Explain.\n\n## Problems\n\n### 11-1 Longest-probe bound for hashing\n\nSuppose you are using an open-addressed hash table of size \\(m\\) to store \\(n\\leq m/2\\) items.\n\n**a.**: Assuming independent uniform permutation hashing, show that for \\(i=1,2,\\ldots,n\\), the probability is at most \\(2^{-p}\\) that the \\(i\\)th insertion requires strictly more than \\(p\\) probes.\n**b.**: Show that for \\(i=1,2,\\ldots,n\\), the probability is \\(O(1/n^{2})\\) that the \\(i\\)th insertion requires more than \\(2\\lg n\\) probes.\n\nLet the random variable \\(X_{i}\\) denote the number of probes required by the \\(i\\)th insertion. You have shown in part (b) that \\(\\Pr\\left\\{X_{i}>2\\lg n\\right\\}=O(1/n^{2})\\). Let the random variable \\(X=\\max\\left\\{X_{i}:1\\leq i\\leq n\\right\\}\\) denote the maximum number of probes required by any of the \\(n\\) insertions.\n**c.**: Show that \\(\\Pr\\left\\{X>2\\lg n\\right\\}=O(1/n)\\).\n**d.**: Show that the expected length \\(\\mathrm{E}\\left[X\\right]\\) of the longest probe sequence is \\(O(\\lg n)\\).\n\n### 11-2 Searching a static set\n\nYou are asked to implement a searchable set of \\(n\\) elements in which the keys are numbers. The set is static (no Insert or Delete operations), and the only operation required is Search. You are given an arbitrary amount of time to preprocess the \\(n\\) elements so that Search operations run quickly.\n\n**a.**: Show how to implement Search in \\(O(\\lg n)\\) worst-case time using no extra storage beyond what is needed to store the elements of the set themselves.\n**b.**: Consider implementing the set by open-address hashing on \\(m\\) slots, and assume independent uniform permutation hashing. What is the minimum amount of extra storage \\(m-n\\) required to make the average performance of an unsuccessful Search operation be at least as good as the bound in part (a)? Your answer should be an asymptotic bound on \\(m-n\\) in terms of \\(n\\).\n\n### 11-3 Slot-size bound for chaining\n\nGiven a hash table with \\(n\\) slots, with collisions resolved by chaining, suppose that \\(n\\) keys are inserted into the table. Each key is equally likely to be hashed to each slot. Let \\(M\\) be the maximum number of keys in any slot after all the keys have",
        "chapter": "Part III Data Structures",
        "section": "11 Hash Tables",
        "subsection": "11.5 Practical considerations",
        "subsubsection": "N/A"
    },
    {
        "content": "## Problems\n\n### 11-1 Longest-probe bound for hashing\n\nSuppose you are using an open-addressed hash table of size \\(m\\) to store \\(n\\leq m/2\\) items.\n\n**a.**: Assuming independent uniform permutation hashing, show that for \\(i=1,2,\\ldots,n\\), the probability is at most \\(2^{-p}\\) that the \\(i\\)th insertion requires strictly more than \\(p\\) probes.\n**b.**: Show that for \\(i=1,2,\\ldots,n\\), the probability is \\(O(1/n^{2})\\) that the \\(i\\)th insertion requires more than \\(2\\lg n\\) probes.\n\nLet the random variable \\(X_{i}\\) denote the number of probes required by the \\(i\\)th insertion. You have shown in part (b) that \\(\\Pr\\left\\{X_{i}>2\\lg n\\right\\}=O(1/n^{2})\\). Let the random variable \\(X=\\max\\left\\{X_{i}:1\\leq i\\leq n\\right\\}\\) denote the maximum number of probes required by any of the \\(n\\) insertions.\n**c.**: Show that \\(\\Pr\\left\\{X>2\\lg n\\right\\}=O(1/n)\\).\n**d.**: Show that the expected length \\(\\mathrm{E}\\left[X\\right]\\) of the longest probe sequence is \\(O(\\lg n)\\).\n\n### 11-2 Searching a static set\n\nYou are asked to implement a searchable set of \\(n\\) elements in which the keys are numbers. The set is static (no Insert or Delete operations), and the only operation required is Search. You are given an arbitrary amount of time to preprocess the \\(n\\) elements so that Search operations run quickly.\n**a.**: Show how to implement Search in \\(O(\\lg n)\\) worst-case time using no extra storage beyond what is needed to store the elements of the set themselves.\n**b.**: Consider implementing the set by open-address hashing on \\(m\\) slots, and assume independent uniform permutation hashing. What is the minimum amount of extra storage \\(m-n\\) required to make the average performance of an unsuccessful Search operation be at least as good as the bound in part (a)? Your answer should be an asymptotic bound on \\(m-n\\) in terms of \\(n\\).\n\n### 11-3 Slot-size bound for chaining\n\nGiven a hash table with \\(n\\) slots, with collisions resolved by chaining, suppose that \\(n\\) keys are inserted into the table. Each key is equally likely to be hashed to each slot. Let \\(M\\) be the maximum number of keys in any slot after all the keys havebeen inserted. Your mission is to prove an \\(\\,O(\\lg n/\\lg\\lg n)\\) upper bound on \\(\\mathrm{E}\\left[M\\right]\\), the expected value of \\(\\,M\\,\\).\n\n_a._ Argue that the probability \\(\\,Q_{k}\\) that exactly \\(k\\) keys hash to a particular slot is given by\n\n\\[Q_{k}\\,=\\,\\left(\\frac{1}{n}\\right)^{k}\\left(1-\\frac{1}{n}\\right)^{n-k}\\binom{n} {k}\\,\\,.\\]\n\n_b._ Let \\(P_{k}\\) be the probability that \\(M\\,=\\,k\\,\\), that is, the probability that the slot containing the most keys contains \\(k\\) keys. Show that \\(\\,P_{k}\\,\\leq n\\,Q_{k}\\,\\).\n\n_c._ Show that \\(\\,Q_{k}\\,<\\,e^{k}/\\,k^{k}\\,\\). _Hint:_ Use Stirling's approximation, equation (3.25) on page 3.\n\n_d._ Show that there exists a constant \\(c\\,>\\,1\\) such that \\(\\,Q_{k_{0}}\\,<\\,1/n\\,\\)[3] for \\(\\,k_{0}\\,=\\,c\\,\\lg n/\\lg\\lg n\\,\\). Conclude that \\(\\,P_{k}\\,<\\,1/n^{2}\\,\\) for \\(\\,k\\,\\geq k_{0}\\,=\\,c\\lg n/\\lg\\lg n\\,\\).\n\n_e._ Argue that\n\n\\[\\mathrm{E}\\left[M\\right]\\leq\\Pr\\left\\{M\\,>\\,\\frac{c\\lg n}{\\lg\\lg n}\\right\\} \\cdot n\\,+\\Pr\\left\\{M\\,\\leq\\,\\frac{c\\lg n}{\\lg\\lg n}\\right\\}\\cdot\\frac{c\\lg n }{\\lg\\lg n}\\,\\,.\\]\n\nConclude that \\(\\mathrm{E}\\left[M\\right]\\,=\\,O(\\lg n/\\lg\\lg n)\\).\n\n_11-4__Hashing and authentication_\n\nLet \\(\\,\\mathcal{H}\\,\\) be a family of hash functions in which each hash function \\(\\,h\\in\\mathcal{H}\\,\\) maps the universe \\(U\\) of keys to \\(\\{0,1,\\ldots,m-1\\}\\).\n\n_a._ Show that if the family \\(\\,\\mathcal{H}\\,\\) of hash functions is \\(2\\)-independent, then it is universal.\n\n_b._ Suppose that the universe \\(\\,U\\,\\) is the set of \\(n\\)-tuples of values drawn from \\(\\,\\mathbb{Z}_{p}\\,=\\,\\{0,1,\\ldots,p-1\\}\\), where \\(\\,p\\,\\) is prime. Consider an element \\(\\,x\\,=\\,\\langle x_{0},x_{1},\\ldots,x_{n-1}\\rangle\\in U\\,\\). For any \\(n\\)-tuple \\(a\\,=\\,\\langle a_{0},\\,a_{1},\\,\\ldots,\\,a_{n-1}\\rangle\\in U\\,\\), define the hash function \\(h_{a}\\) by\n\n\\[h_{a}(x)=\\left(\\,\\sum_{j\\,=\\,0}^{n-1}a_{j}x_{j}\\,\\right)\\bmod\\,p\\,\\,.\\]\n\nLet \\(\\,\\mathcal{H}\\,=\\,\\{h_{a}:a\\in U\\,\\}\\,\\). Show that \\(\\,\\mathcal{H}\\,\\) is universal, but not \\(2\\)-independent. (_Hint:_ Find a key for which all hash functions in \\(\\,\\mathcal{H}\\,\\) produce the same value.)\n* Suppose that we modify \\(\\mathcal{H}\\) slightly from part (b): for any \\(a\\in U\\) and for any \\(b\\in\\mathbb{Z}_{p}\\), define \\[h^{\\prime}_{ab}(x)=\\left(\\sum_{j=0}^{n-1}a_{j}x_{j}+b\\right)\\bmod\\ p\\] and \\(\\mathcal{H}^{\\prime}=\\{h^{\\prime}_{ab}:a\\in U\\text{ and }b\\in\\mathbb{Z}_{p}\\}\\). Argue that \\(\\mathcal{H}^{\\prime}\\) is 2-independent. (_Hint:_ Consider fixed \\(n\\)-tuples \\(x\\in U\\) and \\(y\\in U\\), with \\(x_{i}\\neq y_{i}\\) for some \\(i\\). What happens to \\(h^{\\prime}_{ab}(x)\\) and \\(h^{\\prime}_{ab}(y)\\) as \\(a_{i}\\) and \\(b\\) range over \\(\\mathbb{Z}_{p}\\)?)\n* Alice and Bob secretly agree on a hash function \\(h\\) from a 2-independent family \\(\\mathcal{H}\\) of hash functions. Each \\(h\\in\\mathcal{H}\\) maps from a universe of keys \\(U\\) to \\(\\mathbb{Z}_{p}\\), where \\(p\\) is prime. Later, Alice sends a message \\(m\\) to Bob over the internet, where \\(m\\in U\\). She authenticates this message to Bob by also sending an authentication tag \\(t=h(m)\\), and Bob checks that the pair \\((m,t)\\) he receives indeed satisfies \\(t=h(m)\\). Suppose that an adversary intercepts \\((m,t)\\) en route and tries to fool Bob by replacing the pair \\((m,t)\\) with a different pair \\((m^{\\prime},t^{\\prime})\\). Argue that the probability that the adversary succeeds in fooling Bob into accepting \\((m^{\\prime},t^{\\prime})\\) is at most \\(1/p\\), no matter how much computing power the adversary has, even if the adversary knows the family \\(\\mathcal{H}\\) of hash functions used.\n\n## Chapter notes\n\nThe books by Knuth [261] and Gonnet and Baeza-Yates [193] are excellent references for the analysis of hashing algorithms. Knuth credits H. P. Luhn (1953) for inventing hash tables, along with the chaining method for resolving collisions. At about the same time, G. M. Amdahl originated the idea of open addressing. The notion of a random oracle was introduced by Bellare et al. [43]. Carter and Wegman [80] introduced the notion of universal families of hash functions in 1979.\n\nDietzfelbinger et al. [113] invented the multiply-shift hash function and gave a proof of Theorem 11.5. Thorup [437] provides extensions and additional analysis. Thorup [438] gives a simple proof that linear probing with 5-independent hashing takes constant expected time per operation. Thorup also describes the method for deletion in a hash table using linear probing.\n\nFredman, Komlos, and Szemeredi [154] developed a perfect hashing scheme for static sets--\"perfect\" because all collisions are avoided. An extension of their method to dynamic sets, handling insertions and deletions in amortized expected time \\(O(1)\\), has been given by Dietzfelbinger et al. [114].\n\nThe wee hash function is based on the RC6 encryption algorithm [379]. Leiserson et al. [292] propose an \"RC6mix\" function that is essentially the same as the",
        "chapter": "Part III Data Structures",
        "section": "11 Hash Tables",
        "subsection": "Problems",
        "subsubsection": "N/A"
    },
    {
        "content": "* Suppose that we modify \\(\\mathcal{H}\\) slightly from part (b): for any \\(a\\in U\\) and for any \\(b\\in\\mathbb{Z}_{p}\\), define \\[h^{\\prime}_{ab}(x)=\\left(\\sum_{j=0}^{n-1}a_{j}x_{j}+b\\right)\\bmod\\ p\\] and \\(\\mathcal{H}^{\\prime}=\\{h^{\\prime}_{ab}:a\\in U\\text{ and }b\\in\\mathbb{Z}_{p}\\}\\). Argue that \\(\\mathcal{H}^{\\prime}\\) is 2-independent. (_Hint:_ Consider fixed \\(n\\)-tuples \\(x\\in U\\) and \\(y\\in U\\), with \\(x_{i}\\neq y_{i}\\) for some \\(i\\). What happens to \\(h^{\\prime}_{ab}(x)\\) and \\(h^{\\prime}_{ab}(y)\\) as \\(a_{i}\\) and \\(b\\) range over \\(\\mathbb{Z}_{p}\\)?)\n* Alice and Bob secretly agree on a hash function \\(h\\) from a 2-independent family \\(\\mathcal{H}\\) of hash functions. Each \\(h\\in\\mathcal{H}\\) maps from a universe of keys \\(U\\) to \\(\\mathbb{Z}_{p}\\), where \\(p\\) is prime. Later, Alice sends a message \\(m\\) to Bob over the internet, where \\(m\\in U\\). She authenticates this message to Bob by also sending an authentication tag \\(t=h(m)\\), and Bob checks that the pair \\((m,t)\\) he receives indeed satisfies \\(t=h(m)\\). Suppose that an adversary intercepts \\((m,t)\\) en route and tries to fool Bob by replacing the pair \\((m,t)\\) with a different pair \\((m^{\\prime},t^{\\prime})\\). Argue that the probability that the adversary succeeds in fooling Bob into accepting \\((m^{\\prime},t^{\\prime})\\) is at most \\(1/p\\), no matter how much computing power the adversary has, even if the adversary knows the family \\(\\mathcal{H}\\) of hash functions used.\n\n## Chapter notes\n\nThe books by Knuth [261] and Gonnet and Baeza-Yates [193] are excellent references for the analysis of hashing algorithms. Knuth credits H. P. Luhn (1953) for inventing hash tables, along with the chaining method for resolving collisions. At about the same time, G. M. Amdahl originated the idea of open addressing. The notion of a random oracle was introduced by Bellare et al. [43]. Carter and Wegman [80] introduced the notion of universal families of hash functions in 1979.\n\nDietzfelbinger et al. [113] invented the multiply-shift hash function and gave a proof of Theorem 11.5. Thorup [437] provides extensions and additional analysis. Thorup [438] gives a simple proof that linear probing with 5-independent hashing takes constant expected time per operation. Thorup also describes the method for deletion in a hash table using linear probing.\n\nFredman, Komlos, and Szemeredi [154] developed a perfect hashing scheme for static sets--\"perfect\" because all collisions are avoided. An extension of their method to dynamic sets, handling insertions and deletions in amortized expected time \\(O(1)\\), has been given by Dietzfelbinger et al. [114].\n\nThe wee hash function is based on the RC6 encryption algorithm [379]. Leiserson et al. [292] propose an \"RC6mix\" function that is essentially the same as the wee hash function. They give experimental evidence that it has good randomness, and they also give a \"DotMix\" function for dealing with variable-length inputs. Bellare et al. [42] provide an analysis of the security of the cipher-block-chaining message authentication code. This analysis implies that the wee hash function has the desired pseudorandomness properties.\n\n## Chapter 12 Binary Search Trees\n\nThe search tree data structure supports each of the dynamic-set operations listed on page 250: Search, Minimum, Maximum, Predecessor, Successor, Insert, and Delete. Thus, you can use a search tree both as a dictionary and as a priority queue.\n\nBasic operations on a binary search tree take time proportional to the height of the tree. For a complete binary tree with \\(n\\) nodes, such operations run in \\(\\Theta(\\lg n)\\) worst-case time. If the tree is a linear chain of \\(n\\) nodes, however, the same operations take \\(\\Theta(n)\\) worst-case time. In Chapter 13, we'll see a variation of binary search trees, red-black trees, whose operations guarantee a height of \\(O(\\lg n)\\). We won't prove it here, but if you build a binary search tree on a random set of \\(n\\) keys, its expected height is \\(O(\\lg n)\\) even if you don't try to limit its height.\n\nAfter presenting the basic properties of binary search trees, the following sections show how to walk a binary search tree to print its values in sorted order, how to search for a value in a binary search tree, how to find the minimum or maximum element, how to find the predecessor or successor of an element, and how to insert into or delete from a binary search tree. The basic mathematical properties of trees appear in Appendix B.\n\n### What is a binary search tree?\n\nA binary search tree is organized, as the name suggests, in a binary tree, as shown in Figure 12.1. You can represent such a tree with a linked data structure, as in Section 10.3. In addition to a _key_ and satellite data, each node object contains attributes _left_, _right_, and \\(p\\) that point to the nodes corresponding to its left child, its right child, and its parent, respectively. If a child or the parent is missing, the appropriate attribute contains the value nil. The tree itself has an attribute _root_",
        "chapter": "Part III Data Structures",
        "section": "11 Hash Tables",
        "subsection": "Chapter notes",
        "subsubsection": "N/A"
    },
    {
        "content": "## Chapter 12 Binary Search Trees\n\nThe search tree data structure supports each of the dynamic-set operations listed on page 250: Search, Minimum, Maximum, Predecessor, Successor, Insert, and Delete. Thus, you can use a search tree both as a dictionary and as a priority queue.\n\nBasic operations on a binary search tree take time proportional to the height of the tree. For a complete binary tree with \\(n\\) nodes, such operations run in \\(\\Theta(\\lg n)\\) worst-case time. If the tree is a linear chain of \\(n\\) nodes, however, the same operations take \\(\\Theta(n)\\) worst-case time. In Chapter 13, we'll see a variation of binary search trees, red-black trees, whose operations guarantee a height of \\(O(\\lg n)\\). We won't prove it here, but if you build a binary search tree on a random set of \\(n\\) keys, its expected height is \\(O(\\lg n)\\) even if you don't try to limit its height.\n\nAfter presenting the basic properties of binary search trees, the following sections show how to walk a binary search tree to print its values in sorted order, how to search for a value in a binary search tree, how to find the minimum or maximum element, how to find the predecessor or successor of an element, and how to insert into or delete from a binary search tree. The basic mathematical properties of trees appear in Appendix B.\n\n### What is a binary search tree?\n\nA binary search tree is organized, as the name suggests, in a binary tree, as shown in Figure 12.1. You can represent such a tree with a linked data structure, as in Section 10.3. In addition to a _key_ and satellite data, each node object contains attributes _left_, _right_, and \\(p\\) that point to the nodes corresponding to its left child, its right child, and its parent, respectively. If a child or the parent is missing, the appropriate attribute contains the value nil. The tree itself has an attribute _root_that points to the root node, or nil if the tree is empty. The root node \\(T.root\\) is the only node in a tree \\(T\\) whose parent is nil.\n\nThe keys in a binary search tree are always stored in such a way as to satisfy the _binary-search-tree property_:\n\nFigure 12.1: Binary search trees. For any node \\(x\\), the keys in the left subtree of \\(x\\) are at most \\(x.key\\), and the keys in the right subtree of \\(x\\) are at least \\(x.key\\). Different binary search trees can represent the same set of values. The worst-case running time for most search-tree operations is proportional to the height of the tree. **(a)** A binary search tree on 6 nodes with height 2. The top figure shows how to view the tree conceptually, and the bottom figure shows the _left_, _right_, and \\(p\\) attributes in each node, in the style of Figure 10.6 on page 266. **(b)** A less efficient binary search tree, with height 4, that contains the same keys.\n\nLet \\(x\\) be a node in a binary search tree. If \\(y\\) is a node in the left subtree of \\(x\\), then \\(y.\\mathit{key}\\leq x.\\mathit{key}\\). If \\(y\\) is a node in the right subtree of \\(x\\), then \\(y.\\mathit{key}\\geq x.\\mathit{key}\\).\n\nThus, in Figure 12.1(a), the key of the root is \\(6\\), the keys \\(2\\), \\(5\\), and \\(5\\) in its left subtree are no larger than \\(6\\), and the keys \\(7\\) and \\(8\\) in its right subtree are no smaller than \\(6\\). The same property holds for every node in the tree. For example, looking at the root's left child as the root of a subtree, this subtree root has the key \\(5\\), the key \\(2\\) in its left subtree is no larger than \\(5\\), and the key \\(5\\) in its right subtree is no smaller than \\(5\\).\n\nBecause of the binary-search-tree property, you can print out all the keys in a binary search tree in sorted order by a simple recursive algorithm, called an _inorder tree walk_, given by the procedure Inorder-Tree-Walk. This algorithm is so named because it prints the key of the root of a subtree between printing the values in its left subtree and printing those in its right subtree. (Similarly, a _preorder tree walk_ prints the root before the values in either subtree, and a _postorder tree walk_ prints the root after the values in its subtrees.) To print all the elements in a binary search tree \\(T\\), call Inorder-Tree-Walk\\((T.root)\\). For example, the inorder tree walk prints the keys in each of the two binary search trees from Figure 12.1 in the order \\(2,5,5,6,7,8\\). The correctness of the algorithm follows by induction directly from the binary-search-tree property.\n\nIt takes \\(\\Theta(n)\\) time to walk an \\(n\\)-node binary search tree, since after the initial call, the procedure calls itself recursively exactly twice for each node in the tree--once for its left child and once for its right child. The following theorem gives a formal proof that it takes linear time to perform an inorder tree walk.\n\n**Theorem 12.1**: _If \\(x\\) is the root of an \\(n\\)-node subtree, then the call Inorder-Tree-Walk\\((x)\\) takes \\(\\Theta(n)\\) time._\n\n_Proof_ Let \\(T(n)\\) denote the time taken by Inorder-Tree-Walk when it is called on the root of an \\(n\\)-node subtree. Since Inorder-Tree-Walk visits all \\(n\\) nodes of the subtree, we have \\(T(n)=\\Omega(n)\\). It remains to show that \\(T(n)=O(n)\\)\n\n### What is a binary search tree?\n\nSince Inorder-Tree-Walk takes a small, constant amount of time on an empty subtree (for the test \\(x\\neq\\textsc{nil}\\)), we have \\(T(0)=c\\) for some constant \\(c>0\\).\n\nFor \\(n>0\\), suppose that Inorder-Tree-Walk is called on a node \\(x\\) whose left subtree has \\(k\\) nodes and whose right subtree has \\(n-k-1\\) nodes. The time to perform Inorder-Tree-Walk (\\(x\\)) is bounded by \\(T(n)\\leq T(k)+T(n-k-1)+d\\) for some constant \\(d>0\\) that reflects an upper bound on the time to execute the body of Inorder-Tree-Walk (\\(x\\)), exclusive of the time spent in recursive calls.\n\nWe use the substitution method to show that \\(T(n)=O(n)\\) by proving that \\(T(n)\\leq(c+d)n+c\\). For \\(n=0\\), we have \\((c+d)\\cdot 0+c=c=T(0)\\). For \\(n>0\\), we have\n\n\\[T(n) \\leq T(k)+T(n-k-1)+d\\] \\[\\leq ((c+d)k+c)+((c+d)(n-k-1)+c)+d\\] \\[= (c+d)n+c-(c+d)+c+d\\] \\[= (c+d)n+c\\,\\]\n\nwhich completes the proof.\n\n### Exercises\n\n#### 12.1-1\n\nFor the set \\(\\{1,4,5,10,16,17,21\\}\\) of keys, draw binary search trees of heights \\(2,3,\\)\\(4,\\)\\(5,\\) and \\(6\\).\n\n#### 12.1-2\n\nWhat is the difference between the binary-search-tree property and the min-heap property on page 163? Can the min-heap property be used to print out the keys of an \\(n\\)-node tree in sorted order in \\(O(n)\\) time? Show how, or explain why not.\n\n#### 12.1-3\n\nGive a nonrecursive algorithm that performs an inorder tree walk. (_Hint:_ An easy solution uses a stack as an auxiliary data structure. A more complicated, but elegant, solution uses no stack but assumes that you can test two pointers for equality.)\n\n#### 12.1-4\n\nGive recursive algorithms that perform preorder and postorder tree walks in \\(\\Theta(n)\\) time on a tree of \\(n\\) nodes.\n\n#### 12.1-5\n\nArgue that since sorting \\(n\\) elements takes \\(\\Omega(n\\lg n)\\) time in the worst case in the comparison model, any comparison-based algorithm for constructing a binary search tree from an arbitrary list of \\(n\\) elements takes \\(\\Omega(n\\lg n)\\) time in the worst case.\n\n### 12.2 Querying a binary search tree\n\nBinary search trees can support the queries Minimum, Maximum, Successor, and Predecessor, as well as Search. This section examines these operations and shows how to support each one in \\(O(h)\\) time on any binary search tree of height \\(h\\).\n\n#### Searching\n\nTo search for a node with a given key in a binary search tree, call the TreeSearch procedure. Given a pointer \\(x\\) to the root of a subtree and a key \\(k\\), Tree-Search\\((x,k)\\) returns a pointer to a node with key \\(k\\) if one exists in the subtree; otherwise, it returns nil. To search for key \\(k\\) in the entire binary search tree \\(T\\), call Tree-Search\\((T.root,k)\\).\n\n```\nTree-Search\\((x,k)\\)\n1if\\(x==\\)nil or \\(k==x.key\\)\n2return\\(x\\)\n3if\\(k<x.key\\)\n4returnTree-Search\\((x.left,k)\\)\n5elsereturnTree-Search\\((x.right,k)\\)\n``` Iterative-Tree-Search\\((x,k)\\)\n1while\\(x\\neq\\)nil and \\(k\\neq x.key\\)\n2if\\(k<x.key\\)\n3\\(x=x.left\\)\n4else\\(x=x.right\\)\n5return\\(x\\) ```\n\nThe Tree-Search procedure begins its search at the root and traces a simple path downward in the tree, as shown in Figure 12.2(a). For each node \\(x\\) it encounters, it compares the key \\(k\\) with \\(x.key\\). If the two keys are equal, the search terminates. If \\(k\\) is smaller than \\(x.key\\), the search continues in the left subtree of \\(x\\), since the binary-search-tree property implies that \\(k\\) cannot reside in the right subtree. Symmetrically, if \\(k\\) is larger than \\(x.key\\), the search continues in the right subtree. The nodes encountered during the recursion form a simple path downward from the root of the tree, and thus the running time of Tree-Search is \\(O(h)\\), where \\(h\\) is the height of the tree.",
        "chapter": "Part III Data Structures",
        "section": "12 Binary Search Trees",
        "subsection": "12.1 What is a binary search tree?",
        "subsubsection": "N/A"
    },
    {
        "content": "### 12.2 Querying a binary search tree\n\nBinary search trees can support the queries Minimum, Maximum, Successor, and Predecessor, as well as Search. This section examines these operations and shows how to support each one in \\(O(h)\\) time on any binary search tree of height \\(h\\).\n\n#### Searching\n\nTo search for a node with a given key in a binary search tree, call the TreeSearch procedure. Given a pointer \\(x\\) to the root of a subtree and a key \\(k\\), Tree-Search\\((x,k)\\) returns a pointer to a node with key \\(k\\) if one exists in the subtree; otherwise, it returns nil. To search for key \\(k\\) in the entire binary search tree \\(T\\), call Tree-Search\\((T.root,k)\\).\n\n```\nTree-Search\\((x,k)\\)\n1if\\(x==\\) nil or \\(k==x.key\\)\n2return\\(x\\)\n3if\\(k<x.key\\)\n4returnTree-Search\\((x.left,k)\\)\n5elsereturnTree-Search\\((x.right,k)\\)\n``` Iterative-Tree-Search\\((x,k)\\)\n1while\\(x\\neq\\) nil and \\(k\\neq x.key\\)\n2if\\(k<x.key\\)\n3\\(x=x.left\\)\n4else\\(x=x.right\\)\n5return\\(x\\) ```\n\nThe Tree-Search procedure begins its search at the root and traces a simple path downward in the tree, as shown in Figure 12.2(a). For each node \\(x\\) it encounters, it compares the key \\(k\\) with \\(x.key\\). If the two keys are equal, the search terminates. If \\(k\\) is smaller than \\(x.key\\), the search continues in the left subtree of \\(x\\), since the binary-search-tree property implies that \\(k\\) cannot reside in the right subtree. Symmetrically, if \\(k\\) is larger than \\(x.key\\), the search continues in the right subtree. The nodes encountered during the recursion form a simple path downward from the root of the tree, and thus the running time of Tree-Search is \\(O(h)\\), where \\(h\\) is the height of the tree.\n\n### 12.2 Querying a binary search tree\n\nSince the Tree-Search procedure recurses on either the left subtree or the right subtree, but not both, we can rewrite the algorithm to \"unroll\" the recursion into a **while** loop. On most computers, the Iterative-Tree-Search procedure on the facing page is more efficient.\n\n#### Minimum and maximum\n\nTo find an element in a binary search tree whose key is a minimum, just follow _left_ child pointers from the root until you encounter a nil, as shown in Figure 12.2(b).\n\nFigure 12.2: Queries on a binary search tree. Nodes and paths followed in each query are colored blue. **(a)** A search for the key 13 in the tree follows the path \\(15\\to 6\\to 7\\to 13\\) from the root. **(b)** The minimum key in the tree is 2, which is found by following _left_ pointers from the root. The maximum key 20 is found by following _right_ pointers from the root. **(c)** The successor of the node with key 15 is the node with key 17, since it is the minimum key in the right subtree of 15. **(d)** The node with key 13 has no right subtree, and thus its successor is its lowest ancestor whose left child is also an ancestor. In this case, the node with key 15 is its successor.\n\nThe Tree-Minimum procedure returns a pointer to the minimum element in the subtree rooted at a given node \\(x\\), which we assume to be non-nil.\n\n```\nTree-Minimum(\\(x\\))\n1while\\(x\\).left\\(\\neq\\)nil\n2\\(x\\)\\(=\\)\\(x\\).left\n3return\\(x\\)\n\nTree-Maximum(\\(x\\))\n1while\\(x\\).right\\(\\neq\\)nil\n2\\(x\\)\\(=\\)\\(x\\).right\n3return\\(x\\)\n```\n\nThe binary-search-tree property guarantees that Tree-Minimum is correct. If node \\(x\\) has no left subtree, then since every key in the right subtree of \\(x\\) is at least as large as \\(x\\).key, the minimum key in the subtree rooted at \\(x\\) is \\(x\\).key. If node \\(x\\) has a left subtree, then since no key in the right subtree is smaller than \\(x\\).key and every key in the left subtree is not larger than \\(x\\).key, the minimum key in the subtree rooted at \\(x\\) resides in the subtree rooted at \\(x\\).left.\n\nThe pseudocode for Tree-Maximum is symmetric. Both Tree-Minimum and Tree-Maximum run in \\(O(h)\\) time on a tree of height \\(h\\) since, as in Tree-Search, the sequence of nodes encountered forms a simple path downward from the root.\n\n#### Successor and predecessor\n\nGiven a node in a binary search tree, how can you find its successor in the sorted order determined by an inorder tree walk? If all keys are distinct, the successor of a node \\(x\\) is the node with the smallest key greater than \\(x\\).key. Regardless of whether the keys are distinct, we define the _successor_ of a node as the next node visited in an inorder tree walk. The structure of a binary search tree allows you to determine the successor of a node without comparing keys. The Tree-Successor procedure on the facing page returns the successor of a node \\(x\\) in a binary search tree if it exists, or nil if \\(x\\) is the last node that would be visited during an inorder walk.\n\nThe code for Tree-Successor has two cases. If the right subtree of node \\(x\\) is nonempty, then the successor of \\(x\\) is just the leftmost node in \\(x\\)'s right subtree, which line 2 finds by calling Tree-Minimum(\\(x\\).right). For example, the successor of the node with key 15 in Figure 12.2(c) is the node with key 17.\n\nOn the other hand, as Exercise 12.2-6 asks you to show, if the right subtree of node \\(x\\) is empty and \\(x\\) has a successor \\(y\\), then \\(y\\) is the lowest ancestor of \\(x\\) whose left child is also an ancestor of \\(x\\). In Figure 12.2(d), the successor of the node with key 13 is the node with key 15. To find \\(y\\), go up the tree from \\(x\\) until you encounter either the root or a node that is the left child of its parent. Lines 4-8 of Tree-Successor handle this case.\n\nThe running time of Tree-Successor on a tree of height \\(h\\) is \\(O(h)\\), since it either follows a simple path up the tree or follows a simple path down the tree. The procedure Tree-Predecessor, which is symmetric to Tree-Successor, also runs in \\(O(h)\\) time.\n\nIn summary, we have proved the following theorem.\n\n**Theorem 12.2**: _The dynamic-set operations Search, Minimum, Maximum, Successor, and Predecessor can be implemented so that each one runs in \\(O(h)\\) time on a binary search tree of height \\(h\\)._\n\n#### Exercises\n\nYou are searching for the number 363 in a binary search tree containing numbers between 1 and 1000. Which of the following sequences _cannot_ be the sequence of nodes examined?\n\n_a._: 2, 252, 401, 398, 330, 344, 397, 363.\n\n_b._: 924, 220, 911, 244, 898, 258, 362, 363.\n\n_c._: 925, 202, 911, 240, 912, 245, 363.\n\n_d._: 2, 399, 387, 219, 266, 382, 381, 278, 363.\n\n_e._: 935, 278, 347, 621, 299, 392, 358, 363.\n\n_12.2-2_\n\nWrite recursive versions of Tree-Minimum and Tree-Maximum.\n\n_12.2-3_\n\nWrite the Tree-Predecessor procedure.\n\n_12.2-4_\n\nProfessor Kilmer claims to have discovered a remarkable property of binary search trees. Suppose that the search for key \\(k\\) in a binary search tree ends up at a leaf. Consider three sets: \\(A\\), the keys to the left of the search path; \\(B\\), the keys on the search path; and \\(C\\), the keys to the right of the search path. Professor Kilmer claims that any three keys \\(a\\in A,b\\in B\\), and \\(c\\in C\\) must satisfy \\(a\\leq b\\leq c\\). Give a smallest possible counterexample to the professor's claim.\n\n_12.2-5_\n\nShow that if a node in a binary search tree has two children, then its successor has no left child and its predecessor has no right child.\n\n_12.2-6_\n\nConsider a binary search tree \\(T\\) whose keys are distinct. Show that if the right subtree of a node \\(x\\) in \\(T\\) is empty and \\(x\\) has a successor \\(y\\), then \\(y\\) is the lowest ancestor of \\(x\\) whose left child is also an ancestor of \\(x\\). (Recall that every node is its own ancestor.)\n\n_12.2-7_\n\nAn alternative method of performing an inorder tree walk of an \\(n\\)-node binary search tree finds the minimum element in the tree by calling Tree-Minimum and then making \\(n-1\\) calls to Tree-Successor. Prove that this algorithm runs in \\(\\Theta(n)\\) time.\n\n_12.2-8_\n\nProve that no matter what node you start at in a height-\\(h\\) binary search tree, \\(k\\) successive calls to Tree-Successor take \\(O(k+h)\\) time.\n\n_12.2-9_\n\nLet \\(T\\) be a binary search tree whose keys are distinct, let \\(x\\) be a leaf node, and let \\(y\\) be its parent. Show that \\(y.\\mathit{key}\\) is either the smallest key in \\(T\\) larger than \\(x.\\mathit{key}\\) or the largest key in \\(T\\) smaller than \\(x.\\mathit{key}\\).\n\n### Insertion and deletion\n\nThe operations of insertion and deletion cause the dynamic set represented by a binary search tree to change. The data structure must be modified to reflect this change, but in such a way that the binary-search-tree property continues to hold. We'll see that modifying the tree to insert a new element is relatively straightforward, but deleting a node from a binary search tree is more complicated.\n\n#### Insertion\n\nThe Tree-Insert procedure inserts a new node into a binary search tree. The procedure takes a binary search tree \\(T\\) and a node \\(z\\) for which \\(z.\\mathit{key}\\) has already been filled in, \\(z.\\mathit{left}\\,=\\,\\textsc{nil}\\), and \\(z.\\mathit{right}\\,=\\,\\textsc{nil}\\). It modifies \\(T\\) and some of the attributes of \\(z\\) so as to insert \\(z\\) into an appropriate position in the tree.\n\nFigure 12.3 shows how Tree-Insert works. Just like the procedures Tree-Search and Iterative-Tree-Search, Tree-Insert begins at the root of the tree and the pointer \\(x\\) traces a simple path downward looking for a nil to replace with the input node \\(z\\). The procedure maintains the _trailing pointer_\\(y\\) as the parent of \\(x\\). After initialization, the **while** loop in lines 3-7 causes these two pointers to move down the tree, going left or right depending on the comparison of \\(z.\\mathit{key}\\) with \\(x.\\mathit{key}\\), until \\(x\\) becomes nil. This nil occupies the position where node \\(z\\) will go. More precisely, this nil is a _left_ or _right_ attribute of the node that will become \\(z\\)'s parent, or it is \\(T.\\mathit{root}\\) if tree \\(T\\) is currently empty. The procedure needs the",
        "chapter": "Part III Data Structures",
        "section": "12 Binary Search Trees",
        "subsection": "12.2 Querying a binary search tree",
        "subsubsection": "N/A"
    },
    {
        "content": "### Insertion and deletion\n\nThe operations of insertion and deletion cause the dynamic set represented by a binary search tree to change. The data structure must be modified to reflect this change, but in such a way that the binary-search-tree property continues to hold. We'll see that modifying the tree to insert a new element is relatively straightforward, but deleting a node from a binary search tree is more complicated.\n\n#### Insertion\n\nThe Tree-Insert procedure inserts a new node into a binary search tree. The procedure takes a binary search tree \\(T\\) and a node \\(z\\) for which \\(z.\\mathit{key}\\) has already been filled in, \\(z.\\mathit{left}\\,=\\,\\textsc{nil}\\), and \\(z.\\mathit{right}\\,=\\,\\textsc{nil}\\). It modifies \\(T\\) and some of the attributes of \\(z\\) so as to insert \\(z\\) into an appropriate position in the tree.\n\nFigure 12.3 shows how Tree-Insert works. Just like the procedures Tree-Search and Iterative-Tree-Search, Tree-Insert begins at the root of the tree and the pointer \\(x\\) traces a simple path downward looking for a nil to replace with the input node \\(z\\). The procedure maintains the _trailing pointer_\\(y\\) as the parent of \\(x\\). After initialization, the **while** loop in lines 3-7 causes these two pointers to move down the tree, going left or right depending on the comparison of \\(z.\\mathit{key}\\) with \\(x.\\mathit{key}\\), until \\(x\\) becomes nil. This nil occupies the position where node \\(z\\) will go. More precisely, this nil is a _left_ or _right_ attribute of the node that will become \\(z\\)'s parent, or it is \\(T.\\mathit{root}\\) if tree \\(T\\) is currently empty. The procedure needs thetrailing pointer \\(y\\), because by the time it finds the nil where \\(z\\) belongs, the search has proceeded one step beyond the node that needs to be changed. Lines 8-13 set the pointers that cause \\(z\\) to be inserted.\n\nLike the other primitive operations on search trees, the procedure Tree-Insert runs in \\(O(h)\\) time on a tree of height \\(h\\).\n\n##### Deletion\n\nThe overall strategy for deleting a node \\(z\\) from a binary search tree \\(T\\) has three basic cases and, as we'll see, one of the cases is a bit tricky.\n\n* If \\(z\\) has no children, then simply remove it by modifying its parent to replace \\(z\\) with nil as its child.\n* If \\(z\\) has just one child, then elevate that child to take \\(z\\)'s position in the tree by modifying \\(z\\)'s parent to replace \\(z\\) by \\(z\\)'s child.\n* If \\(z\\) has two children, find \\(z\\)'s successor \\(y\\) --which must belong to \\(z\\)'s right subtree --and move \\(y\\) to take \\(z\\)'s position in the tree. The rest of \\(z\\)'s original right subtree becomes \\(y\\)'s new right subtree, and \\(z\\)'s left subtree becomes \\(y\\)'s new left subtree. Because \\(y\\) is \\(z\\)'s successor, it cannot have a left child, and \\(y\\)'s original right child moves into \\(y\\)'s original position, with the rest of \\(y\\)'s original right subtree following automatically. This case is the tricky one because, as we'll see, it matters whether \\(y\\) is \\(z\\)'s right child.\n\nThe procedure for deleting a given node \\(z\\) from a binary search tree \\(T\\) takes as arguments pointers to \\(T\\) and \\(z\\). It organizes its cases a bit differently from the three cases outlined previously by considering the four cases shown in Figure 12.4.\n\n* If \\(z\\) has no left child, then as in part (a) of the figure, replace \\(z\\) by its right child, which may or may not be nil. When \\(z\\)'s right child is nil, this case deals with\n\nFigure 12.3: Inserting a node with key 13 into a binary search tree. The simple path from the root down to the position where the node is inserted is shown in blue. The new node and the link to its parent are highlighted in orange.\n\n### Insertion and deletion\n\nFigure 12.4: Deleting a node \\(z\\), in blue, from a binary search tree. Node \\(z\\) may be the root, a left child of node \\(q\\), or a right child of \\(q\\). The node that will replace node \\(z\\) in its position in the tree is colored orange. **(a)** Node \\(z\\) has no left child. Replace \\(z\\) by its right child \\(r\\), which may or may not be nil. **(b)** Node \\(z\\) has a left child \\(l\\) but no right child. Replace \\(z\\) by \\(l\\). **(c)** Node \\(z\\) has two children. Its left child is node \\(l\\), its right child is its successor \\(y\\) (which has no left child), and \\(y\\)\u2019s right child is node \\(x\\). Replace \\(z\\) by \\(y\\), updating \\(y\\)\u2019s left child to become \\(l\\), but leaving \\(x\\) as \\(y\\)\u2019s right child. **(d)** Node \\(z\\) has two children (left child \\(l\\) and right child \\(r\\)), and its successor \\(y\\neq r\\) lies within the subtree rooted at \\(r\\). First replace \\(y\\) by its own right child \\(x\\), and set \\(y\\) to be \\(r\\)\u2019s parent. Then set \\(y\\) to be \\(q\\)\u2019s child and the parent of \\(l\\).\n\nthe situation in which \\(z\\) has no children. When \\(z\\)'s right child is non-nil, this case handles the situation in which \\(z\\) has just one child, which is its right child.\n* Otherwise, if \\(z\\) has just one child, then that child is a left child. As in part (b) of the figure, replace \\(z\\) by its left child.\n* Otherwise, \\(z\\) has both a left and a right child. Find \\(z\\)'s successor \\(y\\), which lies in \\(z\\)'s right subtree and has no left child (see Exercise 12.2-5). Splice node \\(y\\) out of its current location and replace \\(z\\) by \\(y\\) in the tree. How to do so depends on whether \\(y\\) is \\(z\\)'s right child:\n* If \\(y\\) is \\(z\\)'s right child, then as in part (c) of the figure, replace \\(z\\) by \\(y\\), leaving \\(y\\)'s right child alone.\n* Otherwise, \\(y\\) lies within \\(z\\)'s right subtree but is not \\(z\\)'s right child. In this case, as in part (d) of the figure, first replace \\(y\\) by its own right child, and then replace \\(z\\) by \\(y\\).\n\nAs part of the process of deleting a node, subtrees need to move around within the binary search tree. The subroutine Transplant replaces one subtree as a child of its parent with another subtree. When Transplant replaces the subtree rooted at node \\(u\\) with the subtree rooted at node \\(v\\), node \\(u\\)'s parent becomes node \\(v\\)'s parent, and \\(u\\)'s parent ends up having \\(v\\) as its appropriate child. Transplant allows \\(v\\) to be nil instead of a pointer to a node.\n\n\\[\\begin{array}{l}\\mbox{Transplant}(T,u,v)\\\\ \\\\ 1\\quad\\mbox{\\bf if }u.p==\\mbox{nil}\\\\ 2\\quad\\mbox{\\bf T.root }=v\\\\ 3\\quad\\mbox{\\bf elseif }u==u.p.\\mbox{\\it left}\\\\ 4\\quad\\mbox{\\bf u.p.left }=v\\\\ 5\\quad\\mbox{\\bf else }u.p.right =v\\\\ 6\\quad\\mbox{\\bf if }v\\neq\\mbox{nil}\\\\ 7\\quad\\mbox{\\bf v.p }=u.p\\\\ \\end{array}\\]\n\nHere is how Transplant works. Lines 1-2 handle the case in which \\(u\\) is the root of \\(T\\). Otherwise, \\(u\\) is either a left child or a right child of its parent. Lines 3-4 take care of updating \\(u.p.\\mbox{\\it left}\\) if \\(u\\) is a left child, and line 5 updates \\(u.p.\\mbox{\\it right}\\) if \\(u\\) is a right child. Because \\(v\\) may be nil, lines 6-7 update \\(v.p\\) only if \\(v\\) is non-nil. The procedure Transplant does not attempt to update \\(v.\\mbox{\\it left}\\) and \\(v.\\mbox{\\it right}\\). Doing so, or not doing so, is the responsibility of Transplant's caller.\n\nThe procedure Tree-Delete on the facing page uses Transplant to delete node \\(z\\) from binary search tree \\(T\\). It executes the four cases as follows. Lines 1-2 handle the case in which node \\(z\\) has no left child (Figure 12.4(a)), and lines 3-4handle the case in which \\(z\\) has a left child but no right child (Figure 12.4(b)). Lines 5-12 deal with the remaining two cases, in which \\(z\\) has two children. Line 5 finds node \\(y\\), which is the successor of \\(z\\). Because \\(z\\) has a nonempty right subtree, its successor must be the node in that subtree with the smallest key; hence the call to Tree-Minimum\\((z.right)\\). As we noted before, \\(y\\) has no left child. The procedure needs to splice \\(y\\) out of its current location and replace \\(z\\) by \\(y\\) in the tree. If \\(y\\) is \\(z\\)'s right child (Figure 12.4(c)), then lines 10-12 replace \\(z\\) as a child of its parent by \\(y\\) and replace \\(y\\)'s left child by \\(z\\)'s left child. Node \\(y\\) retains its right child (\\(x\\) in Figure 12.4(c)), and so no change to \\(y.right\\) needs to occur. If \\(y\\) is not \\(z\\)'s right child (Figure 12.4(d)), then two nodes have to move. Lines 7-9 replace \\(y\\) as a child of its parent by \\(y\\)'s right child (\\(x\\) in Figure 12.4(c)) and make \\(z\\)'s right child (\\(r\\) in the figure) become \\(y\\)'s right child instead. Finally, lines 10-12 replace \\(z\\) as a child of its parent by \\(y\\) and replace \\(y\\)'s left child by \\(z\\)'s left child.\n\nTree-Delete\\((T,z)\\)\n\n```\n1if\\(z.left==nil\\)\n2Transplant\\((T,z,z.right)\\)// replace \\(z\\) by its right child\n3elseif\\(z.right==nil\\)\n4Transplant\\((T,z,z.left)\\)// replace \\(z\\) by its left child\n5else\\(y=Tree-Minimum(z.right)\\)//\\(y\\) is \\(z\\)'s successor\n6if\\(y\\neq z.right\\)// is \\(y\\) farther down the tree?\n7Transplant\\((T,y,y.right)\\)// replace \\(y\\) by its right child\n8\\(y.right=z.right\\)//\\(z\\)'s right child becomes\n9\\(y.right.p=y\\)//\\(y\\)'s right child\n10Transplant\\((T,z,y)\\)// replace \\(z\\) by its successor \\(y\\)\n11\\(y.left=z.left\\)// and give \\(z\\)'s left child to y,\n12\\(y.left.p=y\\)// which had no left child\n```\n\nEach line of Tree-Delete, including the calls to Transplant, takes constant time, except for the call to Tree-Minimum in line 5. Thus, Tree-Delete runs in \\(O(h)\\) time on a tree of height \\(h\\).\n\nIn summary, we have proved the following theorem.\n\n**Theorem 12.3**: _The dynamic-set operations Insert and Delete can be implemented so that each one runs in \\(O(h)\\) time on a binary search tree of height \\(h\\)._\n\n### Exercises\n\n#### 12.3-1\n\nGive a recursive version of the Tree-Insert procedure.\n\n#### 12.3-2\n\nSuppose that you construct a binary search tree by repeatedly inserting distinct values into the tree. Argue that the number of nodes examined in searching for a value in the tree is 1 plus the number of nodes examined when the value was first inserted into the tree.\n\n#### 12.3-3\n\nYou can sort a given set of \\(n\\) numbers by first building a binary search tree containing these numbers (using Tree-Insert repeatedly to insert the numbers one by one) and then printing the numbers by an inorder tree walk. What are the worst-case and best-case running times for this sorting algorithm?\n\n#### 12.3-4\n\nWhen Tree-Delete calls Transplant, under what circumstances can the parameter \\(v\\) of Transplant be nil?\n\n#### 12.3-5\n\nIs the operation of deletion \"commutative\" in the sense that deleting \\(x\\) and then \\(y\\) from a binary search tree leaves the same tree as deleting \\(y\\) and then \\(x\\)? Argue why it is or give a counterexample.\n\n#### 12.3-6\n\nSuppose that instead of each node \\(x\\) keeping the attribute \\(x.p\\), pointing to \\(x\\)'s parent, it keeps \\(x.succ\\), pointing to \\(x\\)'s successor. Give pseudocode for Tree-Search, Tree-Insert, and Tree-Delete on a binary search tree \\(T\\) using this representation. These procedures should operate in \\(O(h)\\) time, where \\(h\\) is the height of the tree \\(T\\). You may assume that all keys in the binary search tree are distinct. (_Hint_: You might wish to implement a subroutine that returns the parent of a node.)\n\n#### 12.3-7\n\nWhen node \\(z\\) in Tree-Delete has two children, you can choose node \\(y\\) to be its predecessor rather than its successor. What other changes to Tree-Delete are necessary if you do so? Some have argued that a fair strategy, giving equal priority to predecessor and successor, yields better empirical performance. How might Tree-Delete be minimally changed to implement such a fair strategy?\n\n## Problems\n\n### Binary search trees with equal keys\n\nEqual keys pose a problem for the implementation of binary search trees.\n\nWhat is the asymptotic performance of Tree-Insert when used to insert \\(n\\) items with identical keys into an initially empty binary search tree?\n\nConsider changing Tree-Insert to test whether \\(z.\\mathit{key}=x.\\mathit{key}\\) before line 5 and to test whether \\(z.\\mathit{key}=y.\\mathit{key}\\) before line 11. If equality holds, implement one of the following strategies. For each strategy, find the asymptotic performance of inserting \\(n\\) items with identical keys into an initially empty binary search tree. (The strategies are described for line 5, which compares the keys of \\(z\\) and \\(x\\). Substitute \\(y\\) for \\(x\\) to arrive at the strategies for line 11.)\n\nKeep a boolean flag \\(x.\\mathit{b}\\) at node \\(x\\), and set \\(x\\) to either \\(x.\\mathit{left}\\) or \\(x.\\mathit{right}\\) based on the value of \\(x.\\mathit{b}\\), which alternates between false and true each time Tree-Insert visits \\(x\\) while inserting a node with the same key as \\(x\\).\n\nKeep a list of nodes with equal keys at \\(x\\), and insert \\(z\\) into the list.\n\nRandomly set \\(x\\) to either \\(x.\\mathit{left}\\) or \\(x.\\mathit{right}\\). (Give the worst-case performance and informally derive the expected running time.)\n\n### Radix trees\n\nGiven two strings \\(a=a_{0}a_{1}\\ldots a_{p}\\) and \\(b=b_{0}b_{1}\\ldots b_{q}\\), where each \\(a_{i}\\) and each \\(b_{j}\\) belongs to some ordered set of characters, we say that string \\(a\\) is _lexicographically less than_ string \\(b\\) if either\n\nthere exists an integer \\(j\\), where \\(0\\leq j\\leq\\min\\left\\{p,q\\right\\}\\), such that \\(a_{i}=b_{i}\\) for all \\(i=0,1,\\ldots,j-1\\) and \\(a_{j}<b_{j}\\), or\n\n\\(p<q\\) and \\(a_{i}=b_{i}\\) for all \\(i=0,1,\\ldots,p\\).\n\nFor example, if \\(a\\) and \\(b\\) are bit strings, then 10100\\(<\\)10110 by rule 1 (letting \\(j=3\\)) and 10100\\(<\\)101000 by rule 2. This ordering is similar to that used in English-language dictionaries.\n\nThe _radix tree_ data structure shown in Figure 12.5 (also known as a _trie_) stores the bit strings 1011, 10, 011, 100, and 0. When searching for a key \\(a=a_{0}a_{1}\\ldots a_{p}\\), go left at a node of depth \\(i\\) if \\(a_{i}=0\\) and right if \\(a_{i}=1\\). Let \\(S\\) be a set of distinct bit strings whose lengths sum to \\(n\\). Show how to use a radix tree to sort \\(S\\) lexicographically in \\(\\Theta(n)\\) time. For the example in Figure 12.5, the output of the sort should be the sequence 0, 011, 10, 100, 1011.",
        "chapter": "Part III Data Structures",
        "section": "12 Binary Search Trees",
        "subsection": "12.3 Insertion and deletion",
        "subsubsection": "N/A"
    },
    {
        "content": "## Problems\n\n### Binary search trees with equal keys\n\nEqual keys pose a problem for the implementation of binary search trees.\n\nWhat is the asymptotic performance of Tree-Insert when used to insert \\(n\\) items with identical keys into an initially empty binary search tree?\n\nConsider changing Tree-Insert to test whether \\(z.\\mathit{key}=x.\\mathit{key}\\) before line 5 and to test whether \\(z.\\mathit{key}=y.\\mathit{key}\\) before line 11. If equality holds, implement one of the following strategies. For each strategy, find the asymptotic performance of inserting \\(n\\) items with identical keys into an initially empty binary search tree. (The strategies are described for line 5, which compares the keys of \\(z\\) and \\(x\\). Substitute \\(y\\) for \\(x\\) to arrive at the strategies for line 11.)\n\nKeep a boolean flag \\(x.\\mathit{b}\\) at node \\(x\\), and set \\(x\\) to either \\(x.\\mathit{left}\\) or \\(x.\\mathit{right}\\) based on the value of \\(x.\\mathit{b}\\), which alternates between false and true each time Tree-Insert visits \\(x\\) while inserting a node with the same key as \\(x\\).\n\nKeep a list of nodes with equal keys at \\(x\\), and insert \\(z\\) into the list.\n\nRandomly set \\(x\\) to either \\(x.\\mathit{left}\\) or \\(x.\\mathit{right}\\). (Give the worst-case performance and informally derive the expected running time.)\n\n### Radix trees\n\nGiven two strings \\(a=a_{0}a_{1}\\ldots a_{p}\\) and \\(b=b_{0}b_{1}\\ldots b_{q}\\), where each \\(a_{i}\\) and each \\(b_{j}\\) belongs to some ordered set of characters, we say that string \\(a\\) is _lexicographically less than_ string \\(b\\) if either\n\nthere exists an integer \\(j\\), where \\(0\\leq j\\leq\\min\\left\\{p,q\\right\\}\\), such that \\(a_{i}=b_{i}\\) for all \\(i=0,1,\\ldots,j-1\\) and \\(a_{j}<b_{j}\\), or\n\n\\(p<q\\) and \\(a_{i}=b_{i}\\) for all \\(i=0,1,\\ldots,p\\).\n\nFor example, if \\(a\\) and \\(b\\) are bit strings, then 10100\\(<\\)10110 by rule 1 (letting \\(j=3\\)) and 10100\\(<\\)101000 by rule 2. This ordering is similar to that used in English-language dictionaries.\n\nThe _radix tree_ data structure shown in Figure 12.5 (also known as a _trie_) stores the bit strings 1011, 10, 011, 100, and 0. When searching for a key \\(a=a_{0}a_{1}\\ldots a_{p}\\), go left at a node of depth \\(i\\) if \\(a_{i}=0\\) and right if \\(a_{i}=1\\). Let \\(S\\) be a set of distinct bit strings whose lengths sum to \\(n\\). Show how to use a radix tree to sort \\(S\\) lexicographically in \\(\\Theta(n)\\) time. For the example in Figure 12.5, the output of the sort should be the sequence 0, 011, 10, 100, 1011.\n\n#### 12.3 Average node depth in a randomly built binary search tree\n\nA _randomly built binary search tree_ on \\(n\\) keys is a binary search tree created by starting with an empty tree and inserting the keys in random order, where each of the \\(n!\\) permutations of the keys is equally likely. In this problem, you will prove that the average depth of a node in a randomly built binary search tree with \\(n\\) nodes is \\(O(\\lg n)\\). The technique reveals a surprising similarity between the building of a binary search tree and the execution of Randomized-Quicksort from Section 7.3.\n\nDenote the depth of any node \\(x\\) in tree \\(T\\) by \\(d(x,T)\\). Then the _total path length_\\(P(T)\\) of a tree \\(T\\) is the sum, over all nodes \\(x\\) in \\(T\\), of \\(d(x,T)\\).\n\n_a._ Argue that the average depth of a node in \\(T\\) is\n\n\\[\\frac{1}{n}\\sum_{x\\in T}d(x,T)=\\frac{1}{n}\\,P(T)\\.\\]\n\nThus, you need to show that the expected value of \\(P(T)\\) is \\(O(n\\lg n)\\).\n\n_b._ Let \\(T_{L}\\) and \\(T_{R}\\) denote the left and right subtrees of tree \\(T\\), respectively. Argue that if \\(T\\) has \\(n\\) nodes, then\n\n\\[P(T)=P(T_{L})+P(T_{R})+n-1\\.\\]\n\n_c._ Let \\(P(n)\\) denote the average total path length of a randomly built binary search tree with \\(n\\) nodes. Show that\n\nFigure 12.5: A radix tree storing the bit strings 1011, 10, 011, 100, and 0. To determine each node\u2019s key, traverse the simple path from the root to that node. There is no need, therefore, to store the keys in the nodes. The keys appear here for illustrative purposes only. Keys corresponding to blue nodes are not in the tree. Such nodes are present only to establish a path to other nodes.\n\n\\[P(n)=\\frac{1}{n}\\sum_{i=0}^{n-1}(P(i)+P(n-i-1)+n-1)\\.\\]\n\n_d._ Show how to rewrite \\(P(n)\\) as\n\n\\[P(n)=\\frac{2}{n}\\sum_{k=1}^{n-1}P(k)+\\Theta(n)\\.\\]\n\n_e._ Recalling the alternative analysis of the randomized version of quicksort given in Problem 7-3, conclude that \\(P(n)=O(n\\lg n)\\).\n\nEach recursive invocation of randomized quicksort chooses a random pivot element to partition the set of elements being sorted. Each node of a binary search tree partitions the set of elements that fall into the subtree rooted at that node.\n\n_f._ Describe an implementation of quicksort in which the comparisons to sort a set of elements are exactly the same as the comparisons to insert the elements into a binary search tree. (The order in which comparisons are made may differ, but the same comparisons must occur.)\n\n_12-4 Number of different binary trees_\n\nLet \\(b_{n}\\) denote the number of different binary trees with \\(n\\) nodes. In this problem, you will find a formula for \\(b_{n}\\), as well as an asymptotic estimate.\n\n_a._ Show that \\(b_{0}=1\\) and that, for \\(n\\geq 1\\),\n\n\\[b_{n}=\\sum_{k=0}^{n-1}b_{k}b_{n-1-k}\\.\\]\n\n_b._ Referring to Problem 4-5 on page 121 for the definition of a generating function, let \\(B(x)\\) be the generating function\n\n\\[B(x)=\\sum_{n=0}^{\\infty}b_{n}x^{n}\\.\\]\n\nShow that \\(B(x)=xB(x)^{2}+1\\), and hence one way to express \\(B(x)\\) in closed form is\n\n\\[B(x)=\\frac{1}{2x}\\left(1-\\sqrt{1-4x}\\right)\\.\\]\n\nThe _Taylor expansion_ of \\(f(x)\\) around the point \\(x=a\\) is given by \\[f(x)=\\sum_{k=0}^{\\infty}\\frac{f^{(k)}(a)}{k!}(x-a)^{k}\\,\\]\n\nwhere \\(f^{(k)}(x)\\) is the \\(k\\)th derivative of \\(f\\) evaluated at \\(x\\).\n\n**c.** Show that\n\n\\[b_{n}=\\frac{1}{n+1}\\binom{2n}{n}\\]\n\n(the \\(n\\)th _Catalan number_) by using the Taylor expansion of \\(\\sqrt{1-4x}\\) around \\(x=0\\). (If you wish, instead of using the Taylor expansion, you may use the generalization of the binomial theorem, equation (C.4) on page 1181, to noninteger exponents \\(n\\), where for any real number \\(n\\) and for any integer \\(k\\), you can interpret \\(\\binom{n}{k}\\) to be \\(n(n-1)\\cdots(n-k+1)/k!\\) if \\(k\\geq 0\\), and \\(0\\) otherwise.)\n\n**d.** Show that\n\n\\[b_{n}=\\frac{4^{n}}{\\sqrt{\\pi}n^{3/2}}\\ (1+O(1/n)).\\]\n\n**Chapter notes**\n\nKnuth [261] contains a good discussion of simple binary search trees as well as many variations. Binary search trees seem to have been independently discovered by a number of people in the late 1950s. Radix trees are often called \"tries,\" which comes from the middle letters in the word _retrieval_. Knuth [261] also discusses them.\n\nMany texts, including the first two editions of this book, describe a somewhat simpler method of deleting a node from a binary search tree when both of its children are present. Instead of replacing node \\(z\\) by its successor \\(y\\), delete node \\(y\\) but copy its key and satellite data into node \\(z\\). The downside of this approach is that the node actually deleted might not be the node passed to the delete procedure. If other components of a program maintain pointers to nodes in the tree, they could mistakenly end up with \"stale\" pointers to nodes that have been deleted. Although the deletion method presented in this edition of this book is a bit more complicated, it guarantees that a call to delete node \\(z\\) deletes node \\(z\\) and only node \\(z\\).\n\nSection 14.5 will show how to construct an optimal binary search tree when you know the search frequencies before constructing the tree. That is, given the frequencies of searching for each key and the frequencies of searching for values that fall between keys in the tree, a set of searches in the constructed binary search tree examines the minimum number of nodes.",
        "chapter": "Part III Data Structures",
        "section": "12 Binary Search Trees",
        "subsection": "Problems",
        "subsubsection": "N/A"
    },
    {
        "content": "\\[f(x)=\\sum_{k=0}^{\\infty}\\frac{f^{(k)}(a)}{k!}(x-a)^{k}\\,\\]\n\nwhere \\(f^{(k)}(x)\\) is the \\(k\\)th derivative of \\(f\\) evaluated at \\(x\\).\n\n**c.** Show that\n\n\\[b_{n}=\\frac{1}{n+1}\\binom{2n}{n}\\]\n\n(the \\(n\\)th _Catalan number_) by using the Taylor expansion of \\(\\sqrt{1-4x}\\) around \\(x=0\\). (If you wish, instead of using the Taylor expansion, you may use the generalization of the binomial theorem, equation (C.4) on page 1181, to noninteger exponents \\(n\\), where for any real number \\(n\\) and for any integer \\(k\\), you can interpret \\(\\binom{n}{k}\\) to be \\(n(n-1)\\cdots(n-k+1)/k!\\) if \\(k\\geq 0\\), and \\(0\\) otherwise.)\n\n**d.** Show that\n\n\\[b_{n}=\\frac{4^{n}}{\\sqrt{\\pi}n^{3/2}}\\ (1+O(1/n)).\\]\n\n**Chapter notes**\n\nKnuth [261] contains a good discussion of simple binary search trees as well as many variations. Binary search trees seem to have been independently discovered by a number of people in the late 1950s. Radix trees are often called \"tries,\" which comes from the middle letters in the word _retrieval_. Knuth [261] also discusses them.\n\nMany texts, including the first two editions of this book, describe a somewhat simpler method of deleting a node from a binary search tree when both of its children are present. Instead of replacing node \\(z\\) by its successor \\(y\\), delete node \\(y\\) but copy its key and satellite data into node \\(z\\). The downside of this approach is that the node actually deleted might not be the node passed to the delete procedure. If other components of a program maintain pointers to nodes in the tree, they could mistakenly end up with \"stale\" pointers to nodes that have been deleted. Although the deletion method presented in this edition of this book is a bit more complicated, it guarantees that a call to delete node \\(z\\) deletes node \\(z\\) and only node \\(z\\).\n\nSection 14.5 will show how to construct an optimal binary search tree when you know the search frequencies before constructing the tree. That is, given the frequencies of searching for each key and the frequencies of searching for values that fall between keys in the tree, a set of searches in the constructed binary search tree examines the minimum number of nodes.\n\n## Chapter 12 Red-Black Trees\n\nChapter 12 showed that a binary search tree of height \\(h\\) can support any of the basic dynamic-set operations--such as Search, Predecessor, Successor, Minimum, Maximum, Insert, and Delete--in \\(O(h)\\) time. Thus, the set operations are fast if the height of the search tree is small. If its height is large, however, the set operations may run no faster than with a linked list. Red-black trees are one of many search-tree schemes that are \"balanced\" in order to guarantee that basic dynamic-set operations take \\(O(\\lg n)\\) time in the worst case.\n\n### Properties of red-black trees\n\nA _red-black tree_ is a binary search tree with one extra bit of storage per node: its _color_, which can be either red or black. By constraining the node colors on any simple path from the root to a leaf, red-black trees ensure that no such path is more than twice as long as any other, so that the tree is approximately _balanced_. Indeed, as we're about to see, the height of a red-black tree with \\(n\\) keys is at most \\(2\\lg(n+1)\\), which is \\(O(\\lg n)\\).\n\nEach node of the tree now contains the attributes _color_, _key_, _left_, _right_, and \\(p\\). If a child or the parent of a node does not exist, the corresponding pointer attribute of the node contains the value nil. Think of these nils as pointers to leaves (external nodes) of the binary search tree and the normal, key-bearing nodes as internal nodes of the tree.\n\nA red-black tree is a binary search tree that satisfies the following _red-black properties_:\n\n1. Every node is either red or black.\n2. The root is black.\n3. Every leaf (nil) is black.",
        "chapter": "Part III Data Structures",
        "section": "12 Binary Search Trees",
        "subsection": "Chapter notes",
        "subsubsection": "N/A"
    },
    {
        "content": "## Chapter 12 Red-Black Trees\n\nChapter 12 showed that a binary search tree of height \\(h\\) can support any of the basic dynamic-set operations--such as Search, Predecessor, Successor, Minimum, Maximum, Insert, and Delete--in \\(O(h)\\) time. Thus, the set operations are fast if the height of the search tree is small. If its height is large, however, the set operations may run no faster than with a linked list. Red-black trees are one of many search-tree schemes that are \"balanced\" in order to guarantee that basic dynamic-set operations take \\(O(\\lg n)\\) time in the worst case.\n\n### Properties of red-black trees\n\nA _red-black tree_ is a binary search tree with one extra bit of storage per node: its _color_, which can be either red or black. By constraining the node colors on any simple path from the root to a leaf, red-black trees ensure that no such path is more than twice as long as any other, so that the tree is approximately _balanced_. Indeed, as we're about to see, the height of a red-black tree with \\(n\\) keys is at most \\(2\\lg(n+1)\\), which is \\(O(\\lg n)\\).\n\nEach node of the tree now contains the attributes \\(color\\), \\(key\\), \\(left\\), \\(right\\), and \\(p\\). If a child or the parent of a node does not exist, the corresponding pointer attribute of the node contains the value nil. Think of these nils as pointers to leaves (external nodes) of the binary search tree and the normal, key-bearing nodes as internal nodes of the tree.\n\nA red-black tree is a binary search tree that satisfies the following _red-black properties_:\n\n1. Every node is either red or black.\n2. The root is black.\n3. Every leaf (nil) is black.\n\n4. If a node is red, then both its children are black.\n5. For each node, all simple paths from the node to descendant leaves contain the same number of black nodes.\n\nFigure 13.1(a) shows an example of a red-black tree.\n\nAs a matter of convenience in dealing with boundary conditions in red-black tree code, we use a single sentinel to represent nil (see page 262). For a red-black tree \\(T\\), the sentinel \\(T.nil\\) is an object with the same attributes as an ordinary node in the tree. Its _color_ attribute is black, and its other attributes--\\(p\\), _left_, _right_, and _key_--can take on arbitrary values. As Figure 13.1(b) shows, all pointers to nil are replaced by pointers to the sentinel \\(T.nil\\).\n\nWhy use the sentinel? The sentinel makes it possible to treat a nil child of a node \\(x\\) as an ordinary node whose parent is \\(x\\). An alternative design would use a distinct sentinel node for each nil in the tree, so that the parent of each nil is well defined. That approach needlessly wastes space, however. Instead, just the one sentinel \\(T.nil\\) represents all the nils--all leaves and the root's parent. The values of the attributes \\(p,\\)_left_, _right_, and _key_ of the sentinel are immaterial. The red-black tree procedures can place whatever values in the sentinel that yield simpler code.\n\nWe generally confine our interest to the internal nodes of a red-black tree, since they hold the key values. The remainder of this chapter omits the leaves in drawings of red-black trees, as shown in Figure 13.1(c).\n\nWe call the number of black nodes on any simple path from, but not including, a node \\(x\\) down to a leaf the _black-height_ of the node, denoted \\(\\operatorname{bh}(x)\\). By property 5, the notion of black-height is well defined, since all descending simple paths from the node have the same number of black nodes. The black-height of a red-black tree is the black-height of its root.\n\nThe following lemma shows why red-black trees make good search trees.\n\n**Lemma 13.1**: _A red-black tree with \\(n\\) internal nodes has height at most \\(2\\lg(n\\,+\\,1)\\)._\n\n_Proof_ We start by showing that the subtree rooted at any node \\(x\\) contains at least \\(2^{\\operatorname{bh}(x)}-1\\) internal nodes. We prove this claim by induction on the height of \\(x\\). If the height of \\(x\\) is \\(0\\), then \\(x\\) must be a leaf (\\(T.nil\\)), and the subtree rooted at \\(x\\) indeed contains at least \\(2^{\\operatorname{bh}(x)}-1=2^{0}-1=0\\) internal nodes. For the inductive step, consider a node \\(x\\) that has positive height and is an internal node. Then node \\(x\\) has two children, either or both of which may be a leaf. If a child is black, then it contributes \\(1\\) to \\(x\\)'s black-height but not to its own. If a child is red, then it contributes to neither \\(x\\)'s black-height nor its own. Therefore, each child has a black-height of either \\(\\operatorname{bh}(x)-1\\) (if it's black) or \\(\\operatorname{bh}(x)\\) (if it's red). Since the height of a child of \\(x\\) is less than the height of \\(x\\) itself, we can apply the inductive \n\n### 13.1 Properties of red-black trees\n\nFigure 13.1: A red-black tree. Every node in a red-black tree is either red or black, the children of a red node are both black, and every simple path from a node to a descendant leaf contains the same number of black nodes. **(a)** Every leaf, shown as a nil, is black. Each non-nil node is marked with its black-height, where nils have black-height 0. **(b)** The same red-black tree but with each nil replaced by the single sentinel \\(T.nil\\), which is always black, and with black-heights omitted. The root\u2019s parent is also the sentinel. **(c)** The same red-black tree but with leaves and the root\u2019s parent omitted entirely. The remainder of this chapter uses this drawing style.\n\nhypothesis to conclude that each child has at least \\(2^{\\text{bh}(x)-1}-1\\) internal nodes. Thus, the subtree rooted at \\(x\\) contains at least \\((2^{\\text{bh}(x)-1}-1)+(2^{\\text{bh}(x)-1}-1)+1=2^{\\text{bh}(x)}-1\\) internal nodes, which proves the claim.\n\nTo complete the proof of the lemma, let \\(h\\) be the height of the tree. According to property 4, at least half the nodes on any simple path from the root to a leaf, not including the root, must be black. Consequently, the black-height of the root must be at least \\(h/2\\), and thus,\n\n\\[n\\geq 2^{h/2}-1\\.\\]\n\nMoving the 1 to the left-hand side and taking logarithms on both sides yields \\(\\lg(n+1)\\geq h/2\\), or \\(h\\leq 2\\lg(n+1)\\). \n\nAs an immediate consequence of this lemma, each of the dynamic-set operations Search, Minimum, Maximum, Successor, and Predecessor runs in \\(O(\\lg n)\\) time on a red-black tree, since each can run in \\(O(h)\\) time on a binary search tree of height \\(h\\) (as shown in Chapter 12) and any red-black tree on \\(n\\) nodes is a binary search tree with height \\(O(\\lg n)\\). (Of course, references to nil in the algorithms of Chapter 12 have to be replaced by \\(T.nil.\\)) Although the procedures Tree-Insert and Tree-Delete from Chapter 12 run in \\(O(\\lg n)\\) time when given a red-black tree as input, you cannot just use them to implement the dynamic-set operations Insert and Delete. They do not necessarily maintain the red-black properties, so you might not end up with a legal red-black tree. The remainder of this chapter shows how to insert into and delete from a red-black tree in \\(O(\\lg n)\\) time.\n\n##### Exercises\n\n##### 13.1-1\n\nIn the style of Figure 13.1(a), draw the complete binary search tree of height 3 on the keys \\(\\{1,2,\\ldots,15\\}\\). Add the nil leaves and color the nodes in three different ways such that the black-heights of the resulting red-black trees are 2, 3, and 4.\n\n##### 13.1-2\n\nDraw the red-black tree that results after Tree-Insert is called on the tree in Figure 13.1 with key 36. If the inserted node is colored red, is the resulting tree a red-black tree? What if it is colored black?\n\n##### 13.1-3\n\nDefine a _relaxed red-black tree_ as a binary search tree that satisfies red-black properties 1, 3, 4, and 5, but whose root may be either red or black. Consider a relaxed red-black tree \\(T\\) whose root is red. If the root of \\(T\\) is changed to black but no other changes occur, is the resulting tree a red-black tree?\n\n### Rotations\n\nThe search-tree operations Tree-Insert and Tree-Delete, when run on a red-black tree with \\(n\\) keys, take \\(O(\\lg n)\\) time. Because they modify the tree, the result may violate the red-black properties enumerated in Section 13.1. To restore these properties, colors and pointers within nodes need to change.\n\nThe pointer structure changes through _rotation_, which is a local operation in a search tree that preserves the binary-search-tree property. Figure 13.2 shows the two kinds of rotations: left rotations and right rotations. Let's look at a left rotation on a node \\(x\\), which transforms the structure on the right side of the figure to the structure on the left. Node \\(x\\) has a right child \\(y\\), which must not be \\(T.nil\\). The left rotation changes the subtree originally rooted at \\(x\\) by \"twisting\" the link between \\(x\\) and \\(y\\) to the left. The new root of the subtree is node \\(y\\), with \\(x\\) as \\(y\\)'s left child and \\(y\\)'s original left child (the subtree represented by \\(\\beta\\) in the figure) as \\(x\\)'s right child.\n\nThe pseudocode for Left-Rotate appearing on the following page assumes that \\(x.right\\neq T.nil\\) and that the root's parent is \\(T.nil\\). Figure 13.3 shows an",
        "chapter": "Part III Data Structures",
        "section": "13 Red-Black Trees",
        "subsection": "13.1 Properties of red-black trees",
        "subsubsection": "N/A"
    },
    {
        "content": "### Rotations\n\nThe search-tree operations Tree-Insert and Tree-Delete, when run on a red-black tree with \\(n\\) keys, take \\(O(\\lg n)\\) time. Because they modify the tree, the result may violate the red-black properties enumerated in Section 13.1. To restore these properties, colors and pointers within nodes need to change.\n\nThe pointer structure changes through _rotation_, which is a local operation in a search tree that preserves the binary-search-tree property. Figure 13.2 shows the two kinds of rotations: left rotations and right rotations. Let's look at a left rotation on a node \\(x\\), which transforms the structure on the right side of the figure to the structure on the left. Node \\(x\\) has a right child \\(y\\), which must not be \\(T.nil\\). The left rotation changes the subtree originally rooted at \\(x\\) by \"twisting\" the link between \\(x\\) and \\(y\\) to the left. The new root of the subtree is node \\(y\\), with \\(x\\) as \\(y\\)'s left child and \\(y\\)'s original left child (the subtree represented by \\(\\beta\\) in the figure) as \\(x\\)'s right child.\n\nThe pseudocode for Left-Rotate appearing on the following page assumes that \\(x.right\\neq T.nil\\) and that the root's parent is \\(T.nil\\). Figure 13.3 shows anexample of how Left-Rotate modifies a binary search tree. The code for Right-Rotate is symmetric. Both Left-Rotate and Right-Rotate run in \\(O(1)\\) time. Only pointers are changed by a rotation, and all other attributes in a node remain the same.\n\n#### Exercises\n\n#### 13.2-1\n\nWrite pseudocode for Right-Rotate.\n\nFigure 13.2: The rotation operations on a binary search tree. The operation Left-Rotate(\\(T,x\\)) transforms the configuration of the two nodes on the right into the configuration on the left by changing a constant number of pointers. The inverse operation Right-Rotate(\\(T,y\\)) transforms the configuration on the left into the configuration on the right. The letters \\(\\alpha\\), \\(\\beta\\), and \\(\\gamma\\) represent arbitrary subtrees. A rotation operation preserves the binary-search-tree property: the keys in \\(\\alpha\\) precede \\(x.key\\), which precedes the keys in \\(\\beta\\), which precede \\(y.key\\), which precedes the keys in \\(\\gamma\\).\n\n### 13.2 Rotations\n\nArgue that in every \\(n\\)-node binary search tree, there are exactly \\(n-1\\) possible rotations.\n\n### 13.2-3\n\nLet \\(a\\), \\(b\\), and \\(c\\) be arbitrary nodes in subtrees \\(\\alpha\\), \\(\\beta\\), and \\(\\gamma\\), respectively, in the right tree of Figure 13.2. How do the depths of \\(a\\), \\(b\\), and \\(c\\) change when a left rotation is performed on node \\(x\\) in the figure?\n\n### 13.2-4\n\nShow that any arbitrary \\(n\\)-node binary search tree can be transformed into any other arbitrary \\(n\\)-node binary search tree using \\(O(n)\\) rotations. (_Hint:_ First show that at most \\(n-1\\) right rotations suffice to transform the tree into a right-going chain.)\n\n* _13.2-5_ We say that a binary search tree \\(T_{1}\\) can be _right-converted_ to binary search tree \\(T_{2}\\) if it is possible to obtain \\(T_{2}\\) from \\(T_{1}\\) via a series of calls to Right-Rotate. Give an example of two trees \\(T_{1}\\) and \\(T_{2}\\) such that \\(T_{1}\\) cannot be right-converted to \\(T_{2}\\). Then, show that if a tree \\(T_{1}\\) can be right-converted to \\(T_{2}\\), it can be right-converted using \\(O(n^{2})\\) calls to Right-Rotate.\n\nFigure 13.3: An example of how the procedure Left-Rotate(\\(T,x\\)) modifies a binary search tree. Inorder tree walks of the input tree and the modified tree produce the same listing of key values.\n\n### Insertion\n\nIn order to insert a node into a red-black tree with \\(n\\) internal nodes in \\(O(\\lg n)\\) time and maintain the red-black properties, we'll need to slightly modify the Tree-Insert procedure on page 321. The procedure RB-Insert starts by inserting node \\(z\\) into the tree \\(T\\) as if it were an ordinary binary search tree, and then it colors \\(z\\) red. (Exercise 13.3-1 asks you to explain why to make node \\(z\\) red rather than black.) To guarantee that the red-black properties are preserved, an auxiliary procedure RB-Insert-Fixup on the facing page recolors nodes and performs rotations. The call RB-Insert\\((T,z)\\) inserts node \\(z\\), whose _key_ is assumed to have already been filled in, into the red-black tree \\(T\\).\n\nRB-Insert\\((T,z)\\)\n\n\\(x\\) = _T.root_\n\n\\(y\\) = _T.nil_\n\n\\(x\\) \\(\\neq\\) _T.nil_\n\n\\(y\\) = \\(x\\)\n\n\\(z\\)_.key_ \\(<\\) _x.key_\n\n\\(x\\) = _x.left_\n\n\\(z\\)_.p_ = \\(y\\)\n\n\\(y\\) == _T.nil_\n\n\\(T\\).root = \\(z\\)\n\n\\(y\\) == _T.nil_\n\n\\(z\\).key \\(<\\) _y.key_\n\n\\(y\\).left = \\(z\\)\n\n\\(z\\).left = \\(T\\).nil_\n\n\\(z\\).right = _T.nil_\n\n\\(z\\).color = red\n\n\\(y\\).left = \\(z\\)\n\n\\(z\\).left = \\(T\\).nil_\n\n\\(z\\).color = red\n\n\\(z\\).color = red\n\n\\(y\\).left = \\(z\\)\n\n\\(z\\).left = \\(T\\).nil_\n\n\\(z\\).color = red\n\n\\(y\\).left = \\(z\\)\n\n\\(z\\).right = _T.nil_\n\n\\(z\\).color = red\n\n\\(y\\).left = \\(z\\).right = _T.nil_\n\n\\(z\\).color = red\n\n\\(y\\).left = \\(z\\).right = _T.nil_\n\n\\(z\\).color = red\n\n\\(y\\).left = \\(z\\).right = _T.nil_\n\n\\(z\\).color = red\n\n\\(y\\).left = \\(z\\).right = _T.nil_\n\n\\(z\\).color = red\n\n\\(y\\).left = \\(z\\).right = _T.nil_\n\n\\(z\\).color = red\n\n\\(y\\).left = \\(z\\).right = _T.nil_\n\n\\(z\\).color = red\n\n\\(y\\).left = \\(z\\).right = _T.nil_\n\n\\(z\\).color = red\n\n\\(y\\).left = \\(z\\).right = _T.nil_\n\n\\(z\\).color = red\n\n\\(y\\).left = \\(z\\).right = _T.nil_\n\n\\(z\\).color = red\n\n\\(y\\).left = \\(z\\).right = _T.nil_\n\n\\(z\\).color = red\n\n\\(y\\).left = \\(z\\).right = _T.nil_\n\n\\(z\\).color = red\n\n\\(y\\).left = \\(z\\).right = _T.nil_\n\n\\(z\\).color = red\n\n\\(y\\).left = \\(z\\).right = _T.nil_\n\n\\(z\\).color = red\n\n\\(y\\).left = \\(z\\).right = _T.nil_\n\n\\(z\\).color = red\n\n\\(y\\).left = \\(z\\).right = _T.nil_\n\n\\(z\\).color = red\n\n\\(y\\).left = \\(z\\).right = _T.nil_\n\n\\(z\\).color = red\n\n\\(y\\).left = \\(z\\).right = _T.nil_\n\n\\(z\\).color = red\n\n\\(y\\).left = \\(z\\).right = _T.nil_\n\n\\(z\\).color = red\n\n\\(y\\).left = \\(z\\).right = _T.nil_\n\n\\(z\\).color = red\n\n\\(y\\).left = \\(z\\).right = _T.nil_\n\n\\(z\\).color = red\n\n\\(y\\).left = \\(z\\).right = _T.nil_\n\n\\(z\\).color = red\n\n\\(y\\).left = \\(z\\).right = _T.nil_\n\n\\(z\\).color = red\n\n\\(y\\).left = \\(z\\).right = _T.nil_\n\n\\(z\\).color = red\n\n\\(y\\).left = \\(z\\).right = _T.nil_\n\n\\(z\\).color = red\n\n\\(y\\).left = \\(z\\).right = _T.nil_\n\n\\(z\\).color = red\n\n\\(y\\).left = \\(z\\).right = _T.nil_\n\n\\(z\\).color = red\n\n\\(y\\).left = \\(z\\).right = _T.nil_\n\n\\(z\\).color = red\n\n\\(y\\).left = \\(z\\).right = _T.nil_\n\n\\(z\\).color = red\n\n\\(y\\).left = \\(z\\).right = _T.nil_\n\n\\(z\\).color = red\n\n\\(y\\).left = \\(z\\).right = _T.nil_\n\n\\(z\\).color = red\n\n\\(y\\).left = \\(z\\).right = _T.nil_\n\n\\(z\\).color = red\n\n\\(y\\).left = \\(z\\).right = _T.nil_\n\n\\(z\\).color = red\n\n\\(y\\).left = \\(z\\).right = _T.nil_\n\n\\(z\\).color = red\n\n\\(y\\).left = \\(z\\).right = _T.nil_\n\n\\(z\\).color = red\n\n\\(y\\).left = \\(z\\).right = _T.nil_\n\n\\(z\\).color = red\n\n\\(y\\).left = \\(z\\).right = _T.nil_\n\n\\(z\\).color = red\n\n\\(y\\).left = \\(z\\).right = _T.nil_\n\n\\(z\\).color = red\n\n\\(y\\).left = \\(z\\).right = _T.nil_\n\n\\(z\\).color = red\n\n\\(y\\).left = \\(z\\).right = _T.nil_\n\n\\(z\\).color = red\n\n\\(y\\).left = \\(z\\).right = _T.nil_\n\n\\(z\\).color = red\n\n\\(y\\).left = \\(z\\).right = _T.nil_\n\n\\(z\\).color = red\n\n\\(y\\).left = \\(z\\).right = _T.nil_\n\n\\(z\\).color = red\n\n\\(y\\).left = \\(z\\).right = _T.nil_\n\n\\(z\\).color = red\n\n\\(y\\).left = \\(z\\).right = _T.nil_\n\n\\(z\\).color = red\n\n\\(y\\).left = \\(z\\).right = _T.nil_\n\n\\(z\\).color = red\n\n\\(y\\).left = \\(z\\).right = _T.nil_\n\n\\(z\\).color = red\n\n\\(y\\).left = \\(z\\).right = _T.nil_\n\n\\(z\\).color = red\n\n\\(y\\).left = \\(z\\).right = _T.nil_\n\n\\(z\\).color = red\n\n\\(y\\).left = \\(z\\).right = _T.nil_\n\n\\(z\\).color = red\n\n\\(y\\).left = \\(z\\).right = _T.nil_\n\n\\(z\\).color = red\n\n\\(y\\).left = \\(z\\).right = _T.nil_\n\n\\(z\\).color = red\n\n\\(y\\).left = \\(z\\).right = _T.nil_\n\n\\(z\\).color = red\n\n\\(y\\).left = \\(z\\).right = _T.nil_\n\n\\(z\\).color = red\n\n\\(y\\).left = \\(z\\).right = _T.nil_\n\n\\(z\\).color = red\n\n\\(y\\).left = \\(z\\).right = _T.nil_\n\n\\(z\\).color = red\n\n\\(y\\).left = \\(z\\).right = _T.nil_\n\n\\(z\\).color = red\n\n\\(y\\).left = \\(z\\).right = _T.nil_\n\n\\(z\\).color = red\n\n\\(y\\).left = \\(z\\).right = _T.nil_\n\n\\(z\\).color = red\n\n\\(y\\).left = \\(z\\).right = _T.nil_\n\n\\(z\\).color = red\n\n\\(y\\).left = \\(z\\).right = _T.nil_\n\n\\(z\\).color = red\n\n\\(y\\).left = \\(z\\).right = _T.nil_\n\n\\(z\\).color = red\n\n\\(y\\).left = \\(z\\).right = _T.nil_\n\n\\(z\\).color = red\n\n\\(y\\).left = \\(z\\).right = _T.nil_\n\n\\(z\\).color = red\n\n\\(y\\).left = \\(z\\).right = _T.nil_\n\n\\(z\\).color = red\n\n\\(y\\).left = \\(z\\).right = _T.nil_\n\n\\(z\\).color = red\n\n\\(y\\).left = \\(z\\).right = _T.nil_\n\n\\(z\\).color = red\n\n\\(y\\).left = \\(z\\).right = _T.nil_\n\n\\(z\\).color = red\n\n\\(y\\).left = \\(z\\).right = _T.nil_\n\n\\(z\\).color = red\n\n\\(y\\).left = \\(z\\).right = _T.nil_\n\n\\(z\\).color = red\n\n\\(y\\).left = \\(z\\).right = _T.nil_\n\n\\(z\\).color = red\n\n\\(y\\).left = \\(z\\).right = _T.nil_\n\n\\(z\\).color = red\n\n\\(y\\).left = \\(z\\).right = _T.nil_\n\n\\(z\\).color = red\n\n\\(y\\).left = \\(z\\).right = _T.nil_\n\n\\(z\\).color = red\n\n\\(y\\).left = \\(z\\).right = _T.nil_",
        "chapter": "Part III Data Structures",
        "section": "13 Red-Black Trees",
        "subsection": "13.2 Rotations",
        "subsubsection": "N/A"
    },
    {
        "content": "### Insertion\n\nIn order to insert a node into a red-black tree with \\(n\\) internal nodes in \\(O(\\lg n)\\) time and maintain the red-black properties, we'll need to slightly modify the Tree-Insert procedure on page 321. The procedure RB-Insert starts by inserting node \\(z\\) into the tree \\(T\\) as if it were an ordinary binary search tree, and then it colors \\(z\\) red. (Exercise 13.3-1 asks you to explain why to make node \\(z\\) red rather than black.) To guarantee that the red-black properties are preserved, an auxiliary procedure RB-Insert-Fixup on the facing page recolors nodes and performs rotations. The call RB-Insert\\((T,z)\\) inserts node \\(z\\), whose _key_ is assumed to have already been filled in, into the red-black tree \\(T\\).\n\nRB-Insert\\((T,z)\\)\n\n\\(x\\) = _T.root_\n\n\\(y\\) = _T.nil_\n\n\\(x\\) \\(\\neq\\) _T.nil_\n\n\\(y\\) = \\(x\\)\n\n\\(z.\\)_key_ \\(<\\) _x.key_\n\n\\(x\\) = _x.left_\n\n\\(z.\\)_p_ = \\(y\\)\n\n\\(y\\) == _T.nil_\n\n\\(T.\\)_root_ = \\(z\\)\n\n\\(y.\\)_left_ = \\(z\\)\n\n\\(z.\\)_left_ = \\(z\\)\n\n\\(z.\\)_left_ = _T.nil_\n\n\\(z.\\)_color_ = red\n\n\\(y.\\)_left_ = \\(z\\)\n\n\\(z.\\)_left_ = _T.nil_\n\n\\(z.\\)_right_ = _T.nil_\n\n\\(z.\\)_color_ = red\n\n\\(y.\\)_left_ = \\(z\\)\n\n\\(z.\\)_right_ = _T.nil_\n\n\\(z.\\)_color_ = red\n\n\\(y.\\)_left_ = _T.nil_\n\n\\(z.\\)_color_ = red\n\n\\(y.\\)_left_ = _T.nil_\n\n\\(z.\\)_color_ = red\n\n\\(y.\\)_left_ = _T.nil_\n\n\\(z.\\)_right_ = _T.nil_\n\n\\(z.\\)_color_ = red\n\n\\(y.\\)_left_ = _T.nil_\n\n\\(z.\\)_right_ = _T.nil_\n\nTo understand how RB-Insert-Fixup works, let's examine the code in three major steps. First, we'll determine which violations of the red-black properties might arise in RB-Insert upon inserting node \\(z\\) and coloring it red. Second, we'll consider the overall goal of the **while** loop in lines 1-29. Finally, we'll explore each of the three cases within the **while** loop's body (case 2 falls through into case 3, so these two cases are not mutually exclusive) and see how they accomplish the goal.\n\nIn describing the structure of a red-black tree, we'll often need to refer to the sibling of a node's parent. We use the term _uncle_ for such a node.1 Figure 13.4 shows how RB-Insert-Fixup operates on a sample red-black tree, with cases depending in part on the colors of a node, its parent, and its uncle.\n\nFootnote 1: Although we try to avoid gendered language in this book, the English language lacks a gender-neutral word for a parent\u2019s sibling.\n\nWhat violations of the red-black properties might occur upon the call to RB-Insert-Fixup? Property 1 certainly continues to hold (every node is either red or black), as does property 3 (every leaf is black), since both children of the newly inserted red node are the sentinel \\(T.nil\\). Property 5, which says that the number of black nodes is the same on every simple path from a given node, is satisfied as well, because node \\(z\\) replaces the (black) sentinel, and node \\(z\\) is red with sentinel children. Thus, the only properties that might be violated are property 2, which requires the root to be black, and property 4, which says that a red node cannot have a red child. Both possible violations may arise because \\(z\\) is colored red. Property 2 is violated if \\(z\\) is the root, and property 4 is violated if \\(z\\)'s parent is red. Figure 13.4(a) shows a violation of property 4 after the node \\(z\\) has been inserted.\n\nThe **while** loop of lines 1-29 has two symmetric possibilities: lines 3-15 deal with the situation in which node \\(z\\)'s parent \\(z.p\\) is a left child of \\(z\\)'s grandparent \\(z.p.p\\), and lines 17-29 apply when \\(z\\)'s parent is a right child. Our proof will focus only on lines 3-15, relying on the symmetry in lines 17-29.\n\nWe'll show that the **while** loop maintains the following three-part invariant at the start of each iteration of the loop:\n\n1. Node \\(z\\) is red.\n2. If \\(z.p\\) is the root, then \\(z.p\\) is black.\n3. If the tree violates any of the red-black properties, then it violates at most one of them, and the violation is of either property 2 or property 4, but not both. If the tree violates property 2, it is because \\(z\\) is the root and is red. If the tree violates property 4, it is because both \\(z\\) and \\(z.p\\) are red.\n\nPart (c), which deals with violations of red-black properties, is more central to showing that RB-Insert-Fixup restores the red-black properties than parts (a) and (b), which we'll use along the way to understand situations in the code. Because we'll be focusing on node \\(z\\) and nodes near it in the tree, it helps to know from part (a) that \\(z\\) is red. Part (b) will help show that \\(z\\)'s grandparent \\(z.p.p\\) exists when it's referenced in lines 2, 3, 7, 8, 14, and 15 (recall that we're focusing only on lines 3-15).\n\n### Insertion\n\nFigure 13.4: The operation of RB-Insert-Fixup. **(a)** A node \\(z\\) after insertion. Because both \\(z\\) and its parent \\(z.p\\) are red, a violation of property 4 occurs. Since \\(z\\)\u2019s uncle \\(y\\) is red, case 1 in the code applies. Node \\(z\\)\u2019s grandparent \\(z.p.p\\) must be black, and its blackness transfers down one level to \\(z\\)\u2019s parent and uncle. Once the pointer \\(z\\) moves up two levels in the tree, the tree shown in **(b)** results. Once again, \\(z\\) and its parent are both red, but this time \\(z\\)\u2019s uncle \\(y\\) is black. Since \\(z\\) is the right child of \\(z.p\\), case 2 applies. Performing a left rotation results in the tree in **(c)**. Now \\(z\\) is the left child of its parent, and case 3 applies. Recoloring and right rotation yield the tree in **(d)**, which is a legal red-black tree.\n\nRecall that to use a loop invariant, we need to show that the invariant is true upon entering the first iteration of the loop, that each iteration maintains it, that the loop terminates, and that the loop invariant gives us a useful property at loop termination. We'll see that each iteration of the loop has two possible outcomes: either the pointer \\(z\\) moves up the tree, or some rotations occur and then the loop terminates.\n\n**Initialization:**: Before RB-Insert is called, the red-black tree has no violations. RB-Insert adds a red node \\(z\\) and calls RB-Insert-Fixup. We'll show that each part of the invariant holds at the time RB-Insert-Fixup is called:\n\n1. When RB-Insert-Fixup is called, \\(z\\) is the red node that was added.\n2. If \\(z.p\\) is the root, then \\(z.p\\) started out black and did not change before the call of RB-Insert-Fixup.\n3. We have already seen that properties 1, 3, and 5 hold when RB-Insert-Fixup is called.\n\nIf the tree violates property 2 (the root must be black), then the red root must be the newly added node \\(z\\), which is the only internal node in the tree. Because the parent and both children of \\(z\\) are the sentinel, which is black, the tree does not also violate property 4 (both children of a red node are black). Thus this violation of property 2 is the only violation of red-black properties in the entire tree.\n\nIf the tree violates property 4, then, because the children of node \\(z\\) are black sentinels and the tree had no other violations prior to \\(z\\) being added, the violation must be because both \\(z\\) and \\(z.p\\) are red. Moreover, the tree violates no other red-black properties.\n**Maintenance:**: There are six cases within the **while** loop, but we'll examine only the three cases in lines 3-15, when node \\(z\\)'s parent \\(z.p\\) is a left child of \\(z\\)'s grandparent \\(z.p.p\\). The proof for lines 17-29 is symmetric. The node \\(z.p.p\\) exists, since by part (b) of the loop invariant, if \\(z.p\\) is the root, then \\(z.p\\) is black. Since RB-Insert-Fixup enters a loop iteration only if \\(z.p\\) is red, we know that \\(z.p\\) cannot be the root. Hence, \\(z.p.p\\) exists.\n\nCase 1 differs from cases 2 and 3 by the color of \\(z\\)'s uncle \\(y\\). Line 3 makes \\(y\\) point to \\(z\\)'s uncle \\(z.p.p.right\\), and line 4 tests \\(y\\)'s color. If \\(y\\) is red, then case 1 executes. Otherwise, control passes to cases 2 and 3. In all three cases, \\(z\\)'s grandparent \\(z.p.p\\) is black, since its parent \\(z.p\\) is red, and property 4 is violated only between \\(z\\) and \\(z.p\\).\n\n### 13.3 Insertion\n\n#### Case 1: \\(z\\)'s uncle \\(y\\) is red\n\nFigure 13.5 shows the situation for case 1 (lines 5-8), which occurs when both \\(z.p\\) and \\(y\\) are red. Because \\(z\\)'s grandparent \\(z.p.p\\) is black, its blackness can transfer down one level to both \\(z.p\\) and \\(y\\), thereby fixing the problem of \\(z\\) and \\(z.p\\) both being red. Having had its blackness transferred down one level, \\(z\\)'s grandparent becomes red, thereby maintaining property 5. The **while** loop repeats with \\(z.p.p\\) as the new node \\(z\\), so that the pointer \\(z\\) moves up two levels in the tree.\n\nNow, we show that case 1 maintains the loop invariant at the start of the next iteration. We use \\(z\\) to denote node \\(z\\) in the current iteration, and \\(z^{\\prime}=z.p.p\\) to denote the node that will be called node \\(z\\) at the test in line 1 upon the next iteration.\n\n1. Because this iteration colors \\(z.p.p\\) red, node \\(z^{\\prime}\\) is red at the start of the next iteration.\n2. The node \\(z^{\\prime}.p\\) is \\(z.p.p.p\\) in this iteration, and the color of this node does not change. If this node is the root, it was black prior to this iteration, and it remains black at the start of the next iteration.\n\n3. We have already argued that case 1 maintains property 5, and it does not introduce a violation of properties 1 or 3. If node \\(z^{\\prime}\\) is the root at the start of the next iteration, then case 1 corrected the lone violation of property 4 in this iteration. Since \\(z^{\\prime}\\) is red and it is the root, property 2 becomes the only one that is violated, and this violation is due to \\(z^{\\prime}\\). If node \\(z^{\\prime}\\) is not the root at the start of the next iteration, then case 1 has not created a violation of property 2. Case 1 corrected the lone violation of property 4 that existed at the start of this iteration. It then made \\(z^{\\prime}\\) red and left \\(z^{\\prime}.p\\) alone. If \\(z^{\\prime}.p\\) was black, there is no violation of property 4. If \\(z^{\\prime}.p\\) was red, coloring \\(z^{\\prime}\\) red created one violation of property 4, between \\(z^{\\prime}\\) and \\(z^{\\prime}.p\\).\n\n_Case 2: \\(z\\)'s uncle \\(y\\) is black and \\(z\\) is a right child Case 3: \\(z\\)'s uncle \\(y\\) is black and \\(z\\) is a left child_ In cases 2 and 3, the color of \\(z\\)'s uncle \\(y\\) is black. We distinguish the two cases, which assume that \\(z\\)'s parent \\(z.p\\) is red and a left child, according to whether \\(z\\) is a right or left child of \\(z.p\\). Lines 11-12 constitute case 2, which is shown in Figure 13.6 together with case 3. In case 2, node \\(z\\) is a right child of its parent. A left rotation immediately transforms the situation into case 3 (lines 13-15), in which node \\(z\\) is a left child. Because both \\(z\\) and \\(z.p\\) are red, the rotation affects neither the black-heights of nodes nor property 5. Whether case 3 executes directly or through case 2, \\(z\\)'s uncle \\(y\\) is black, since otherwise case 1 would have run. Additionally, the node \\(z.p.p\\) exists, since we have argued that this\n\nFigure 13.6: Cases 2 and 3 of the procedure RB-Insert-Fixup. As in case 1, property 4 is violated in either case 2 or case 3 because \\(z\\) and its parent \\(z.p\\) are both red. Each of the subtrees \\(\\alpha\\), \\(\\beta\\), \\(\\gamma\\), and \\(\\delta\\) has a black root (\\(\\alpha\\), \\(\\beta\\), and \\(\\gamma\\) from property 4, and \\(\\delta\\) because otherwise case 1 would apply), and each has the same black-height. Case 2 transforms into case 3 by a left rotation, which preserves property 5: all downward simple paths from a node to a leaf have the same number of blacks. Case 3 causes some color changes and a right rotation, which also preserve property 5. The **while** loop then terminates, because property 4 is satisfied: there are no longer two red nodes in a row.\n\nnode existed at the time that lines 2 and 3 were executed, and after moving \\(z\\) up one level in line 11 and then down one level in line 12, the identity of \\(z.p.p\\) remains unchanged. Case 3 performs some color changes and a right rotation, which preserve property 5. At this point, there are no longer two red nodes in a row. The **while** loop terminates upon the next test in line 1, since \\(z.p\\) is now black. We now show that cases 2 and 3 maintain the loop invariant. (As we have just argued, \\(z.p\\) will be black upon the next test in line 1, and the loop body will not execute again.)\n\n1. Case 2 makes \\(z\\) point to \\(z.p\\), which is red. No further change to \\(z\\) or its color occurs in cases 2 and 3.\n2. Case 3 makes \\(z.p\\) black, so that if \\(z.p\\) is the root at the start of the next iteration, it is black.\n3. As in case 1, properties 1, 3, and 5 are maintained in cases 2 and 3. Since node \\(z\\) is not the root in cases 2 and 3, we know that there is no violation of property 2. Cases 2 and 3 do not introduce a violation of property 2, since the only node that is made red becomes a child of a black node by the rotation in case 3. Cases 2 and 3 correct the lone violation of property 4, and they do not introduce another violation.\n\n**Termination:**: To see that the loop terminates, observe that if only case 1 occurs, then the node pointer \\(z\\) moves toward the root in each iteration, so that eventually \\(z.p\\) is black. (If \\(z\\) is the root, then \\(z.p\\) is the sentinel \\(T.nil\\), which is black.) If either case 2 or case 3 occurs, then we've seen that the loop terminates. Since the loop terminates because \\(z.p\\) is black, the tree does not violate property 4 at loop termination. By the loop invariant, the only property that might fail to hold is property 2. Line 3 restores this property by coloring the root black, so that when RB-Insert-Fixup terminates, all the red-black properties hold.\n\nThus, we have shown that RB-Insert-Fixup correctly restores the red-black properties.\n\n#### Analysis\n\nWhat is the running time of RB-Insert? Since the height of a red-black tree on \\(n\\) nodes is \\(O(\\lg n)\\), lines 1-16 of RB-Insert take \\(O(\\lg n)\\) time. In RB-Insert-Fixup, the **while** loop repeats only if case 1 occurs, and then the pointer \\(z\\) moves two levels up the tree. The total number of times the **while** loop can be executed is therefore \\(O(\\lg n)\\). Thus, RB-Insert takes a total of \\(O(\\lg n)\\) time. Moreover, it never performs more than two rotations, since the **while** loop terminates if case 2 or case 3 is executed.\n\n#### Exercises\n\n##### 13.3-1\n\nLine 16 of RB-Insert sets the color of the newly inserted node \\(z\\) to red. If instead \\(z\\)'s color were set to black, then property 4 of a red-black tree would not be violated. Why not set \\(z\\)'s color to black?\n\n##### 13.3-2\n\nShow the red-black trees that result after successively inserting the keys \\(41\\), \\(38\\), \\(31\\), \\(12,19,8\\) into an initially empty red-black tree.\n\n##### 13.3-3\n\nSuppose that the black-height of each of the subtrees \\(\\alpha,\\beta,\\gamma,\\delta,\\varepsilon\\) in Figures 13.5 and 13.6 is \\(k\\). Label each node in each figure with its black-height to verify that the indicated transformation preserves property 5.\n\n##### 13.3-4\n\nProfessor Teach is concerned that RB-Insert-Fixup might set \\(T.nil.color\\) to red, in which case the test in line 1 would not cause the loop to terminate when \\(z\\) is the root. Show that the professor's concern is unfounded by arguing that RB-Insert-Fixup never sets \\(T.nil.color\\) to red.\n\n##### 13.3-5\n\nConsider a red-black tree formed by inserting \\(n\\) nodes with RB-Insert. Argue that if \\(n>1\\), the tree has at least one red node.\n\n##### 13.3-6\n\nSuggest how to implement RB-Insert efficiently if the representation for red-black trees includes no storage for parent pointers.\n\n##### Deletion\n\nLike the other basic operations on an \\(n\\)-node red-black tree, deletion of a node takes \\(O(\\lg n)\\) time. Deleting a node from a red-black tree is more complicated than inserting a node.\n\nThe procedure for deleting a node from a red-black tree is based on the Tree-Delete procedure on page 325. First, we need to customize the Transplant",
        "chapter": "Part III Data Structures",
        "section": "13 Red-Black Trees",
        "subsection": "13.3 Insertion",
        "subsubsection": "N/A"
    },
    {
        "content": "never performs more than two rotations, since the **while** loop terminates if case 2 or case 3 is executed.\n\n#### Exercises\n\n##### 13.3-1\n\nLine 16 of RB-Insert sets the color of the newly inserted node \\(z\\) to red. If instead \\(z\\)'s color were set to black, then property 4 of a red-black tree would not be violated. Why not set \\(z\\)'s color to black?\n\n##### 13.3-2\n\nShow the red-black trees that result after successively inserting the keys \\(41,38,31,\\)\\(12,19,8\\) into an initially empty red-black tree.\n\n##### 13.3-3\n\nSuppose that the black-height of each of the subtrees \\(\\alpha,\\beta,\\gamma,\\delta,\\varepsilon\\) in Figures 13.5 and 13.6 is \\(k\\). Label each node in each figure with its black-height to verify that the indicated transformation preserves property 5.\n\n##### 13.3-4\n\nProfessor Teach is concerned that RB-Insert-Fixup might set \\(T.nil.color\\) to red, in which case the test in line 1 would not cause the loop to terminate when \\(z\\) is the root. Show that the professor's concern is unfounded by arguing that RB-Insert-Fixup never sets \\(T.nil.color\\) to red.\n\n##### 13.3-5\n\nConsider a red-black tree formed by inserting \\(n\\) nodes with RB-Insert. Argue that if \\(n>1\\), the tree has at least one red node.\n\n##### 13.3-6\n\nSuggest how to implement RB-Insert efficiently if the representation for red-black trees includes no storage for parent pointers.\n\n##### Deletion\n\nLike the other basic operations on an \\(n\\)-node red-black tree, deletion of a node takes \\(O(\\lg n)\\) time. Deleting a node from a red-black tree is more complicated than inserting a node.\n\nThe procedure for deleting a node from a red-black tree is based on the Tree-Delete procedure on page 13.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.33.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.33.3.3.3.33.3.3.3.3.3.3.3.3.33.3.3.3.3.3.3.3.3.3.3.3.33.3.3.3.33.3.3.3.33.3.3.33.3.3.3.3.3.33.3.3.33.3.3.33.3.3.3.33.3.3.33.3.33.3.33.3.33.3.33.33.3.33.3.33.3.33.3.33.3.33.33.33.33.33.3.3.33.33.33.3.33.33.33.33.3.33.33.33.33.3.33.33.33.33.3.33.33.33.33.33.33.33.33.33.33.33.33.33.33.333.33.333.33.333.33.3subroutine on page 324 that Tree-Delete calls so that it applies to a red-black tree. Like Transplant, the new procedure RB-Transplant replaces the subtree rooted at node \\(u\\) by the subtree rooted at node \\(v\\). The RB-Transplant procedure differs from Transplant in two ways. First, line 1 references the sentinel \\(T.nil\\) instead of nil. Second, the assignment to \\(v.p\\) in line 6 occurs unconditionally: the procedure can assign to \\(v.p\\) even if \\(v\\) points to the sentinel. We'll take advantage of the ability to assign to \\(v.p\\) when \\(v=T.nil\\).\n\n```\nRB-Transplant(\\(T,u,v\\))\n1if\\(u.p==T.nil\\)\n2\\(T.root=v\\)\n3elseif\\(u==u.p.left\\)\n4\\(u.p.left=v\\)\n5else\\(u.p.right=v\\)\n6\\(v.p=u.p\\)\n```\n\nThe procedure RB-Delete on the next page is like the Tree-Delete procedure, but with additional lines of pseudocode. The additional lines deal with nodes \\(x\\) and \\(y\\) that may be involved in violations of the red-black properties. When the node \\(z\\) being deleted has at most one child, then \\(y\\) will be \\(z\\). When \\(z\\) has two children, then, as in Tree-Delete, \\(y\\) will be \\(z\\)'s successor, which has no left child and moves into \\(z\\)'s position in the tree. Additionally, \\(y\\) takes on \\(z\\)'s color. In either case, node \\(y\\) has at most one child: node \\(x\\), which takes \\(y\\)'s place in the tree. (Node \\(x\\) will be the sentinel \\(T.nil\\) if \\(y\\) has no children.) Since node \\(y\\) will be either removed from the tree or moved within the tree, the procedure needs to keep track of \\(y\\)'s original color. If the red-black properties might be violated after deleting node \\(z\\), RB-Delete calls the auxiliary procedure RB-Delete-Fixup, which changes colors and performs rotations to restore the red-black properties.\n\nAlthough RB-Delete contains almost twice as many lines of pseudocode as Tree-Delete, the two procedures have the same basic structure. You can find each line of Tree-Delete within RB-Delete (with the changes of replacing nil by \\(T.nil\\) and replacing calls to Transplant by calls to RB-Transplant), executed under the same conditions.\n\nIn detail, here are the other differences between the two procedures:\n\n* Lines 1 and 9 set node \\(y\\) as described above: line 1 when node \\(z\\) has at most one child and line 9 when \\(z\\) has two children.\n* Because node \\(y\\)'s color might change, the variable \\(y\\)_-original-color_ stores \\(y\\)'s color before any changes occur. Lines 2 and 10 set this variable immediately after assignments to \\(y\\). When node \\(z\\) has two children, then nodes \\(y\\) and \\(z\\) are distinct. In this case, line 17 moves \\(y\\) into \\(z\\)'s original position in the tree (that is, \\(z\\)'s location in the tree at the time RB-Delete was called), and line 20 gives \\(y\\) the same color as \\(z\\). When node \\(y\\) was originally black, removing or moving it could cause violations of the red-black properties, which are corrected by the call of RB-Delete-Fixup in line 22.\n* As discussed, the procedure keeps track of the node \\(x\\) that moves into node \\(y\\)'s original position at the time of call. The assignments in lines 4, 7, and 11 set \\(x\\) to point to either \\(y\\)'s only child or, if \\(y\\) has no children, the sentinel \\(T.nil\\).\n* Since node \\(x\\) moves into node \\(y\\)'s original position, the attribute \\(x.p\\) must be set correctly. If node \\(z\\) has two children and \\(y\\) is \\(z\\)'s right child, then \\(y\\) just moves into \\(z\\)'s position, with \\(x\\) remaining a child of \\(y\\). Line 12 checks for this case. Although you might think that setting \\(x.p\\) to \\(y\\) in line 16 is unnecessary since \\(x\\) is a child of \\(y\\), the call of RB-Delete-Fixup relies on \\(x.p\\) being \\(y\\) even if \\(x\\) is \\(T.nil\\). Thus, when \\(z\\) has two children and \\(y\\) is \\(z\\)'s right child, executingline 16 is necessary if \\(y\\)'s right child is \\(T.nil\\), and otherwise it does not change anything. Otherwise, node \\(z\\) is either the same as node \\(y\\) or it is a proper ancestor of \\(y\\)'s original parent. In these cases, the calls of RB-Transplant in lines 5, 8, and 13 set \\(x.p\\) correctly in line 6 of RB-Transplant. (In these calls of RB-Transplant, the third parameter passed is the same as \\(x\\).)\n* Finally, if node \\(y\\) was black, one or more violations of the red-black properties might arise. The call of RB-Delete-Fixup in line 22 restores the red-black properties. If \\(y\\) was red, the red-black properties still hold when \\(y\\) is removed or moved, for the following reasons: 1. No black-heights in the tree have changed. (See Exercise 13.4-1.) 2. No red nodes have been made adjacent. If \\(z\\) has at most one child, then \\(y\\) and \\(z\\) are the same node. That node is removed, with a child taking its place. If the removed node was red, then neither its parent nor its children can also be red, so moving a child to take its place cannot cause two red nodes to become adjacent. If, on the other hand, \\(z\\) has two children, then \\(y\\) takes \\(z\\)'s place in the tree, along with \\(z\\)'s color, so there cannot be two adjacent red nodes at \\(y\\)'s new position in the tree. In addition, if \\(y\\) was not \\(z\\)'s right child, then \\(y\\)'s original right child \\(x\\) replaces \\(y\\) in the tree. Since \\(y\\) is red, \\(x\\) must be black, and so replacing \\(y\\) by \\(x\\) cannot cause two red nodes to become adjacent. 3. Because \\(y\\) could not have been the root if it was red, the root remains black.\n\nIf node \\(y\\) was black, three problems may arise, which the call of RB-Delete-Fixup will remedy. First, if \\(y\\) was the root and a red child of \\(y\\) became the new root, property 2 is violated. Second, if both \\(x\\) and its new parent are red, then a violation of property 4 occurs. Third, moving \\(y\\) within the tree causes any simple path that previously contained \\(y\\) to have one less black node. Thus, property 5 is now violated by any ancestor of \\(y\\) in the tree. We can correct the violation of property 5 by saying that when the black node \\(y\\) is removed or moved, its blackness transfers to the node \\(x\\) that moves into \\(y\\)'s original position, giving \\(x\\) an \"extra\" black. That is, if we add 1 to the count of black nodes on any simple path that contains \\(x\\), then under this interpretation, property 5 holds. But now another problem emerges: node \\(x\\) is neither red nor black, thereby violating property 1. Instead, node \\(x\\) is either \"doubly black\" or \"red-and-black,\" and it contributes either 2 or 1, respectively, to the count of black nodes on simple paths containing \\(x\\). The _color_ attribute of \\(x\\) will still be either red (if \\(x\\) is red-and-black) or black (if \\(x\\) is doubly black). In other words, the extra black on a node is reflected in \\(x\\)'s pointing to the node rather than in the _color_ attribute.\n\nThe procedure RB-Delete-Fixup on the next page restores properties 1, 2, and 4. Exercises 13.4-2 and 13.4-3 ask you to show that the procedure restores properties 2 and 4, and so in the remainder of this section, we focus on property 1. The goal of the **while** loop in lines 1-43 is to move the extra black up the tree until\n\n1. \\(x\\) points to a red-and-black node, in which case line 44 colors \\(x\\) (singly) black;\n2. \\(x\\) points to the root, in which case the extra black simply vanishes; or\n3. having performed suitable rotations and recolorings, the loop exits.\n\nLike RB-Insert-Fixup, the RB-Delete-Fixup procedure handles two symmetric situations: lines 3-22 for when node \\(x\\) is a left child, and lines 24-43 for when \\(x\\) is a right child. Our proof focuses on the four cases shown in lines 3-22.\n\nWithin the **while** loop, \\(x\\) always points to a nonroot doubly black node. Line 2 determines whether \\(x\\) is a left child or a right child of its parent \\(x.p\\) so that either lines 3-22 or 24-43 will execute in a given iteration. The sibling of \\(x\\) is always denoted by a pointer \\(w\\). Since node \\(x\\) is doubly black, node \\(w\\) cannot be \\(T.nil\\), because otherwise, the number of blacks on the simple path from \\(x.p\\) to the (singly black) leaf \\(w\\) would be smaller than the number on the simple path from \\(x.p\\) to \\(x\\).\n\nRecall that the RB-Delete procedure always assigns to \\(x.p\\) before calling RB-Delete-Fixup (either within the call of RB-Transplant in line 13 or the assignment in line 16), even when node \\(x\\) is the sentinel \\(T.nil\\). That is because RB-Delete-Fixup references \\(x\\)'s parent \\(x.p\\) in several places, and this attribute must point to the node that became \\(x\\)'s parent in RB-Delete--even if \\(x\\) is \\(T.nil\\).\n\nFigure 13.7 demonstrates the four cases in the code when node \\(x\\) is a left child. (As in RB-Insert-Fixup, the cases in RB-Delete-Fixup are not mutually exclusive.) Before examining each case in detail, let's look more generally at how we can verify that the transformation in each of the cases preserves property 5. The key idea is that in each case, the transformation applied preserves the number of black nodes (including \\(x\\)'s extra black) from (and including) the root of the subtree shown to the roots of each of the subtrees \\(\\alpha,\\beta,\\ldots,\\zeta\\). Thus, if property 5 holds prior to the transformation, it continues to hold afterward. For example, in Figure 13.7(a), which illustrates case 1, the number of black nodes from the root to the root of either subtree \\(\\alpha\\) or \\(\\beta\\) is 3, both before and after the transformation. (Again, remember that node \\(x\\) adds an extra black.) Similarly, the number of black nodes from the root to the root of any of \\(\\gamma\\), \\(\\delta\\), \\(\\varepsilon\\), and \\(\\zeta\\) is 2, both before and after the transformation.2 In Figure 13.7(b), the counting must involve the value \\(c\\) of the _color_ attribute of the root of the subtree shown, which can be either red or black.\n\n### 13.4 Deletion\n\n```\n1while\\(x\\neq T.root\\) and \\(x.color\\) == black\n2if\\(x==x.p.left\\) // is \\(x\\) a left child?\n3\\(w=x.p.right\\) // \\(w\\) is \\(x\\)'s sibling\n4if\\(w.color\\) == red\n5\\(w.color\\) = black\n6\\(x.p.color\\) = red\n7 Left-Rotate(\\(T,x.p\\)) \\(w=x.p.right\\)\n9if\\(w.left.color\\) == black and \\(w.right.color\\) == black\n10\\(x=x.p\\) \\(x=\\) black\n11else\n12if\\(w.right.color\\) == black\n13\\(w.left.color\\) = black\n14\\(w.left.color\\) = black\n15\\(w.color\\) = red\n16 Right-Rotate(\\(T,w\\)) \\(w=x.p.right\\)\n17\\(w.color\\) = \\(x.p.color\\)\n18\\(x.p.color\\) = black\n19\\(w.right.color\\) = black\n20\\(w.right.color\\) = black\n21 Left-Rotate(\\(T,x.p\\)) \\(x=\\) T.root\n23else // same as lines 3-22, but with \"right\" and \"left\" exchanged\n24\\(w=x.p.left\\)\n25if\\(w.color\\) == red\n26\\(w.color\\) = black\n27\\(x.p.color\\) = red\n28 Right-Rotate(\\(T,x.p\\)) \\(w=x.p.left\\)\n29if\\(w.right.color\\) == black and \\(w.left.color\\) == black\n30\\(w.color\\) = red\n31\\(x=x.p\\)\n32\\(x=x.p\\)\n33else\n34if\\(w.left.color\\) == black\n35\\(w.right.color\\) = black\n36\\(w.color\\) = red\n37 Left-Rotate(\\(T,w\\)) \\(w=x.p.left\\)\n38\\(w.color\\) = \\(x.p.color\\)\n39\\(x.p.color\\) = black\n40\\(w.left.color\\) = black\n41\\(w.left.color\\) = black\n42 Right-Rotate(\\(T,x.p\\)) \\(x=\\) T.root\n43\\(x.color\\) = black\nFigure 13.7: The cases in lines 3\u201322 of the procedure RB-Delete-Fixup. Brown nodes have _color_ attributes represented by \\(c\\) and \\(c^{\\prime}\\), which may be either red or black. The letters \\(\\alpha\\), \\(\\beta\\), \\(\\ldots\\), \\(\\zeta\\) represent arbitrary subtrees. Each case transforms the configuration on the left into the configuration on the right by changing some colors and/or performing a rotation. Any node pointed to by \\(x\\) has an extra black and is either doubly black or red-and-black. Only case 2 causes the loop to repeat. **(a)** Case 1 is transformed into case 2, 3, or 4 by exchanging the colors of nodes \\(B\\) and \\(D\\) and performing a left rotation. **(b)** In case 2, the extra black represented by the pointer \\(x\\) moves up the tree by coloring node \\(D\\) red and setting \\(x\\) to point to node \\(B\\). If case 2 is entered through case 1, the **while** loop terminates because the new node \\(x\\) is red-and-black, and therefore the value \\(c\\) of its _color_ attribute is red. **(c)** Case 3 is transformed to case 4 by exchanging the colors of nodes \\(C\\) and \\(D\\) and performing a right rotation. **(d)** Case 4 removes the extra black represented by \\(x\\) by changing some colors and performing a left rotation (without violating the red-black properties), and then the loop terminates.\n\n### 13.4 Deletion\n\nIf we define \\(\\operatorname{count}(\\operatorname{\\textsc{red}})=0\\) and \\(\\operatorname{count}(\\operatorname{\\textsc{black}})=1\\), then the number of black nodes from the root to \\(\\alpha\\) is \\(2+\\operatorname{count}(c)\\), both before and after the transformation. In this case, after the transformation, the new node \\(x\\) has _color_ attribute \\(c\\), but this node is really either red-and-black (if \\(c=\\operatorname{\\textsc{red}}\\)) or doubly black (if \\(c=\\operatorname{\\textsc{black}}\\)). You can verify the other cases similarly (see Exercise 13.4-6).\n\n_Case 1: \\(x\\)'s sibling \\(w\\) is red_\n\nCase 1 (lines 5-8 and Figure 13.7(a)) occurs when node \\(w\\), the sibling of node \\(x\\), is red. Because \\(w\\) is red, it must have black children. This case switches the colors of \\(w\\) and \\(x\\).\\(p\\) and then performs a left-rotation on \\(x\\).\\(p\\) without violating any of the red-black properties. The new sibling of \\(x\\), which is one of \\(w\\)'s children prior to the rotation, is now black, and thus case 1 converts into one of cases 2, 3, or 4.\n\nCases 2, 3, and 4 occur when node \\(w\\) is black and are distinguished by the colors of \\(w\\)'s children.\n\n_Case 2: \\(x\\)'s sibling \\(w\\) is black, and both of \\(w\\)'s children are black_\n\nIn case 2 (lines 10-11 and Figure 13.7(b)), both of \\(w\\)'s children are black. Since \\(w\\) is also black, this case removes one black from both \\(x\\) and \\(w\\), leaving \\(x\\) with only one black and leaving \\(w\\) red. To compensate for \\(x\\) and \\(w\\) each losing one black, \\(x\\)'s parent \\(x\\).\\(p\\) can take on an extra black. Line 11 does so by moving \\(x\\) up one level, so that the **while** loop repeats with \\(x\\).\\(p\\) as the new node \\(x\\). If case 2 enters through case 1, the new node \\(x\\) is red-and-black, since the original \\(x\\).\\(p\\) was red. Hence, the value \\(c\\) of the _color_ attribute of the new node \\(x\\) is red, and the loop terminates when it tests the loop condition. Line 44 then colors the new node \\(x\\) (singly) black.\n\n_Case 3: \\(x\\)'s sibling \\(w\\) is black, \\(w\\)'s left child is red, and \\(w\\)'s right child is black_\n\nCase 3 (lines 14-17 and Figure 13.7(c)) occurs when \\(w\\) is black, its left child is red, and its right child is black. This case switches the colors of \\(w\\) and its left child \\(w\\)._left_ and then performs a right rotation on \\(w\\) without violating any of the red-black properties. The new sibling \\(w\\) of \\(x\\) is now a black node with a red right child, and thus case 3 falls through into case 4.\n\n_Case 4: \\(x\\)'s sibling \\(w\\) is black, and \\(w\\)'s right child is red_\n\nCase 4 (lines 18-22 and Figure 13.7(d)) occurs when node \\(x\\)'s sibling \\(w\\) is black and \\(w\\)'s right child is red. Some color changes and a left rotation on \\(x\\).\\(p\\) allow the extra black on \\(x\\) to vanish, making it singly black, without violating any of the red-black properties. Line 22 sets \\(x\\) to be the root, and the **while** loop terminates when it next tests the loop condition.\n\n### Analysis\n\nWhat is the running time of RB-Delete? Since the height of a red-black tree of \\(n\\) nodes is \\(O(\\lg n)\\), the total cost of the procedure without the call to RB-Delete-Fixup takes \\(O(\\lg n)\\) time. Within RB-Delete-Fixup, each of cases 1, 3, and 4 lead to termination after performing a constant number of color changes and at most three rotations. Case 2 is the only case in which the **while** loop can be repeated, and then the pointer \\(x\\) moves up the tree at most \\(O(\\lg n)\\) times, performing no rotations. Thus, the procedure RB-Delete-Fixup takes \\(O(\\lg n)\\) time and performs at most three rotations, and the overall time for RB-Delete is therefore also \\(O(\\lg n)\\).\n\n### Exercises\n\n#### 13.4-1\n\nShow that if node \\(y\\) in RB-Delete is red, then no black-heights change.\n\n#### 13.4-2\n\nArgue that after RB-Delete-Fixup executes, the root of the tree must be black.\n\n#### 13.4-3\n\nArgue that if in RB-Delete both \\(x\\) and \\(x.p\\) are red, then property 4 is restored by the call to RB-Delete-Fixup\\((T,x)\\).\n\n#### 13.4-4\n\nIn Exercise 13.3-2 on page 346, you found the red-black tree that results from successively inserting the keys \\(41,38,31,12,19,8\\) into an initially empty tree. Now show the red-black trees that result from the successive deletion of the keys in the order \\(8,12,19,31,38,41\\).\n\n#### 13.4-5\n\nWhich lines of the code for RB-Delete-Fixup might examine or modify the sentinel \\(T.nil\\)?\n\n#### 13.4-6\n\nIn each of the cases of Figure 13.7, give the count of black nodes from the root of the subtree shown to the roots of each of the subtrees \\(\\alpha,\\beta,\\ldots,\\xi\\), and verify that each count remains the same after the transformation. When a node has a _color_ attribute \\(c\\) or \\(c^{\\prime}\\), use the notation count\\((c)\\) or count\\((c^{\\prime})\\) symbolically in your count.\n\n#### 13.4-7\n\nProfessors Skelton and Baron worry that at the start of case 1 of RB-Delete-Fixup, the node \\(x.p\\) might not be black. If \\(x.p\\) is not black, then lines 5-6 arewrong. Show that \\(x.p\\) must be black at the start of case 1, so that the professors need not be concerned. _13.4-8_ A node \\(x\\) is inserted into a red-black tree with RB-Insert and then is immediately deleted with RB-Delete. Is the resulting red-black tree always the same as the initial red-black tree? Justify your answer. \\(\\bigstar\\) _13.4-9_ Consider the operation RB-Enumerate(\\(T,r,a,b\\)), which outputs all the keys \\(k\\) such that \\(a\\leq k\\leq b\\) in a subtree rooted at node \\(r\\) in an \\(n\\)-node red-black tree \\(T\\). Describe how to implement RB-Enumerate in \\(\\Theta(m+\\lg n)\\) time, where \\(m\\) is the number of keys that are output. Assume that the keys in \\(T\\) are unique and that the values \\(a\\) and \\(b\\) appear as keys in \\(T\\). How does your solution change if \\(a\\) and \\(b\\) might not appear in \\(T\\)?\n\n## Problems\n\n### Persistent dynamic sets\n\nDuring the course of an algorithm, you sometimes find that you need to maintain past versions of a dynamic set as it is updated. We call such a set _persistent_. One way to implement a persistent set is to copy the entire set whenever it is modified, but this approach can slow down a program and also consume a lot of space. Sometimes, you can do much better.\n\nConsider a persistent set \\(S\\) with the operations Insert, Delete, and Search, which you implement using binary search trees as shown in Figure 13.8(a). Maintain a separate root for every version of the set. In order to insert the key 5 into the set, create a new node with key 5. This node becomes the left child of a new node with key 7, since you cannot modify the existing node with key 7. Similarly, the new node with key 7 becomes the left child of a new node with key 8 whose right child is the existing node with key 10. The new node with key 8 becomes, in turn, the right child of a new root \\(r^{\\prime}\\) with key 4 whose left child is the existing node with key 3. Thus, you copy only part of the tree and share some of the nodes with the original tree, as shown in Figure 13.8(b).\n\nAssume that each tree node has the attributes _key_, _left_, and _right_ but no parent. (See also Exercise 13.3-6 on page 346.)\n\n* For a persistent binary search tree (not a red-black tree, just a binary search tree), identify the nodes that need to change to insert or delete a node.",
        "chapter": "Part III Data Structures",
        "section": "13 Red-Black Trees",
        "subsection": "13.4 Deletion",
        "subsubsection": "N/A"
    },
    {
        "content": "wrong. Show that \\(x.p\\) must be black at the start of case 1, so that the professors need not be concerned. _13.4-8_ A node \\(x\\) is inserted into a red-black tree with RB-Insert and then is immediately deleted with RB-Delete. Is the resulting red-black tree always the same as the initial red-black tree? Justify your answer. \\(\\bigstar\\) _13.4-9_ Consider the operation RB-Enumerate(\\(T,r,a,b\\)), which outputs all the keys \\(k\\) such that \\(a\\leq k\\leq b\\) in a subtree rooted at node \\(r\\) in an \\(n\\)-node red-black tree \\(T\\). Describe how to implement RB-Enumerate in \\(\\Theta(m+\\lg n)\\) time, where \\(m\\) is the number of keys that are output. Assume that the keys in \\(T\\) are unique and that the values \\(a\\) and \\(b\\) appear as keys in \\(T\\). How does your solution change if \\(a\\) and \\(b\\) might not appear in \\(T\\)?\n\n## Problems\n\n### Persistent dynamic sets\n\nDuring the course of an algorithm, you sometimes find that you need to maintain past versions of a dynamic set as it is updated. We call such a set _persistent_. One way to implement a persistent set is to copy the entire set whenever it is modified, but this approach can slow down a program and also consume a lot of space. Sometimes, you can do much better.\n\nConsider a persistent set \\(S\\) with the operations Insert, Delete, and Search, which you implement using binary search trees as shown in Figure 13.8(a). Maintain a separate root for every version of the set. In order to insert the key 5 into the set, create a new node with key 5. This node becomes the left child of a new node with key 7, since you cannot modify the existing node with key 7. Similarly, the new node with key 7 becomes the left child of a new node with key 8 whose right child is the existing node with key 10. The new node with key 8 becomes, in turn, the right child of a new root \\(r^{\\prime}\\) with key 4 whose left child is the existing node with key 3. Thus, you copy only part of the tree and share some of the nodes with the original tree, as shown in Figure 13.8(b).\n\nAssume that each tree node has the attributes _key_, _left_, and _right_ but no parent. (See also Exercise 13.3-6 on page 346.)\n\n* For a persistent binary search tree (not a red-black tree, just a binary search tree), identify the nodes that need to change to insert or delete a node.\n\n* Write a procedure Persistent-Tree-Insert\\((T,z)\\) that, given a persistent binary search tree \\(T\\) and a node \\(z\\) to insert, returns a new persistent tree \\(T^{\\prime}\\) that is the result of inserting \\(z\\) into \\(T\\). Assume that you have a procedure Copy-Node\\((x)\\) that makes a copy of node \\(x\\), including all of its attributes.\n* If the height of the persistent binary search tree \\(T\\) is \\(h\\), what are the time and space requirements of your implementation of Persistent-Tree-Insert? (The space requirement is proportional to the number of nodes that are copied.)\n* Suppose that you include the parent attribute in each node. In this case, the Persistent-Tree-Insert procedure needs to perform additional copying. Prove that Persistent-Tree-Insert then requires \\(\\Omega(n)\\) time and space, where \\(n\\) is the number of nodes in the tree.\n* Show how to use red-black trees to guarantee that the worst-case running time and space are \\(O(\\lg n)\\) per insertion or deletion. You may assume that all keys are distinct.\n\n### 13-2 Join operation on red-black trees\n\nThe _join_ operation takes two dynamic sets \\(S_{1}\\) and \\(S_{2}\\) and an element \\(x\\) such that for any \\(x_{1}\\in S_{1}\\) and \\(x_{2}\\in S_{2}\\), we have \\(x_{1}.key\\leq x.key\\leq x_{2}.key\\). It returns a set \\(S=S_{1}\\cup\\{x\\}\\cup S_{2}\\). In this problem, we investigate how to implement the join operation on red-black trees.\n\n* Suppose that you store the black-height of a red-black tree \\(T\\) as the new attribute \\(T.bh\\). Argue that RB-Insert and RB-Delete can maintain the _bh\n\nFigure 13.8: **(a)** A binary search tree with keys \\(2,3,4,7,8,10\\). **(b)** The persistent binary search tree that results from the insertion of key \\(5\\). The most recent version of the set consists of the nodes reachable from the root \\(r^{\\prime}\\), and the previous version consists of the nodes reachable from \\(r\\). Blue nodes are added when key \\(5\\) is inserted.\n\nattribute without requiring extra storage in the nodes of the tree and without increasing the asymptotic running times. Show how to determine the black-height of each node visited while descending through \\(T\\), using \\(O(1)\\) time per node visited.\n\nLet \\(T_{1}\\) and \\(T_{2}\\) be red-black trees and \\(x\\) be a key value such that for any nodes \\(x_{1}\\) in \\(T_{1}\\) and \\(x_{2}\\) in \\(T_{2}\\), we have \\(x_{1}.key\\leq x.key\\leq x_{2}.key\\). You will show how to implement the operation RB-Join\\((T_{1},x,T_{2})\\), which destroys \\(T_{1}\\) and \\(T_{2}\\) and returns a red-black tree \\(T=T_{1}\\cup\\{x\\}\\cup T_{2}\\). Let \\(n\\) be the total number of nodes in \\(T_{1}\\) and \\(T_{2}\\).\n\n_b._: Assume that \\(T_{1}.bh\\geq T_{2}.bh\\). Describe an \\(O(\\lg n)\\)-time algorithm that finds a black node \\(y\\) in \\(T_{1}\\) with the largest key from among those nodes whose black-height is \\(T_{2}.bh\\).\n\n_c._: Let \\(T_{y}\\) be the subtree rooted at \\(y\\). Describe how \\(T_{y}\\cup\\{x\\}\\cup T_{2}\\) can replace \\(T_{y}\\) in \\(O(1)\\) time without destroying the binary-search-tree property.\n\n_d._: What color should you make \\(x\\) so that red-black properties 1, 3, and 5 are maintained? Describe how to enforce properties 2 and 4 in \\(O(\\lg n)\\) time.\n\n_e._: Argue that no generality is lost by making the assumption in part (b). Describe the symmetric situation that arises when \\(T_{1}.bh\\leq T_{2}.bh\\).\n\n_f._: Argue that the running time of RB-Join is \\(O(\\lg n)\\).\n\n_13-3 AVL trees_: An _AVL tree_ is a binary search tree that is _height balanced_: for each node \\(x\\), the heights of the left and right subtrees of \\(x\\) differ by at most 1. To implement an AVL tree, maintain an extra attribute \\(h\\) in each node such that \\(x.h\\) is the height of node \\(x\\). As for any other binary search tree \\(T\\), assume that \\(T.root\\) points to the root node.\n\n_a._: Prove that an AVL tree with \\(n\\) nodes has height \\(O(\\lg n)\\). (_Hint_: Prove that an AVL tree of height \\(h\\) has at least \\(F_{h}\\) nodes, where \\(F_{h}\\) is the \\(h\\)th Fibonacci number.)\n\n_b._: To insert into an AVL tree, first place a node into the appropriate place in binary search tree order. Afterward, the tree might no longer be height balanced. Specifically, the heights of the left and right children of some node might differ by 2. Describe a procedure Balance\\((x)\\), which takes a subtree rooted at \\(x\\) whose left and right children are height balanced and have heights that differ by at most 2, so that \\(|x.right.h-x.left.h|\\leq 2\\), and alters the subtree rooted at \\(x\\) to be height balanced. The procedure should return a pointer to the node that is the root of the subtree after alterations occur. (_Hint_: Use rotations.) _c._ Using part (b), describe a recursive procedure AVL-Insert(\\(T,z\\)) that takes an AVL tree \\(T\\) and a newly created node \\(z\\) (whose key has already been filled in), and adds \\(z\\) into \\(T\\), maintaining the property that \\(T\\) is an AVL tree. As in Tree-Insert from Section 12.3, assume that \\(z.key\\) has already been filled in and that \\(z.left=\\textsc{nil}\\) and \\(z.right=\\textsc{nil}\\). Assume as well that \\(z.h=0\\). _d._ Show that AVL-Insert, run on an \\(n\\)-node AVL tree, takes \\(O(\\lg n)\\) time and performs \\(O(\\lg n)\\) rotations.\n\n## Chapter notes\n\nThe idea of balancing a search tree is due to Adel'son-Vel'skii and Landis [2], who introduced a class of balanced search trees called \"AVL trees\" in 1962, described in Problem 13-3. Another class of search trees, called \"2-3 trees,\" was introduced by J. E. Hopcroft (unpublished) in 1970. A 2-3 tree maintains balance by manipulating the degrees of nodes in the tree, where each node has either two or three children. Chapter 18 covers a generalization of 2-3 trees introduced by Bayer and McCreight [39], called \"B-trees.\"\n\nRed-black trees were invented by Bayer [38] under the name \"symmetric binary B-trees.\" Guibas and Sedgewick [202] studied their properties at length and introduced the red/black color convention. Andersson [16] gives a simpler-to-code variant of red-black trees. Weiss [451] calls this variant AA-trees. An AA-tree is similar to a red-black tree except that left children can never be red.\n\nSedgewick and Wayne [402] present red-black trees as a modified version of 2-3 trees in which a node with three children is split into two nodes with two children each. One of these nodes becomes the left child of the other, and only left children can be red. They call this structure a \"left-leaning red-black binary search tree.\" Although the code for left-leaning red-black binary search trees is more concise than the red-black tree pseudocode in this chapter, operations on left-leaning red-black binary search trees do not limit the number of rotations per operation to a constant. This distinction will matter in Chapter 17.\n\nTreaps, a hybrid of binary search trees and heaps, were proposed by Seidel and Aragon [404]. They are the default implementation of a dictionary in LEDA [324], which is a well-implemented collection of data structures and algorithms.\n\nThere are many other variations on balanced binary trees, including weight-balanced trees [344], \\(k\\)-neighbor trees [318], and scapegoat trees [174]. Perhaps",
        "chapter": "Part III Data Structures",
        "section": "13 Red-Black Trees",
        "subsection": "Problems",
        "subsubsection": "N/A"
    },
    {
        "content": "by at most 2, so that \\(|x.right.h-x.left.h|\\leq 2\\), and alters the subtree rooted at \\(x\\) to be height balanced. The procedure should return a pointer to the node that is the root of the subtree after alterations occur. (_Hint_: Use rotations.)\n* Using part (b), describe a recursive procedure AVL-Insert(\\(T,z\\)) that takes an AVL tree \\(T\\) and a newly created node \\(z\\) (whose key has already been filled in), and adds \\(z\\) into \\(T\\), maintaining the property that \\(T\\) is an AVL tree. As in Tree-Insert from Section 12.3, assume that \\(z.key\\) has already been filled in and that \\(z.left=\\textsc{nil}\\) and \\(z.right=\\textsc{nil}\\). Assume as well that \\(z.h=0\\).\n* Show that AVL-Insert, run on an \\(n\\)-node AVL tree, takes \\(O(\\lg n)\\) time and performs \\(O(\\lg n)\\) rotations.\n\n## Chapter notes\n\nThe idea of balancing a search tree is due to Adel'son-Vel'skii and Landis [2], who introduced a class of balanced search trees called \"AVL trees\" in 1962, described in Problem 13-3. Another class of search trees, called \"2-3 trees,\" was introduced by J. E. Hopcroft (unpublished) in 1970. A 2-3 tree maintains balance by manipulating the degrees of nodes in the tree, where each node has either two or three children. Chapter 18 covers a generalization of 2-3 trees introduced by Bayer and McCreight [39], called \"B-trees.\"\n\nRed-black trees were invented by Bayer [38] under the name \"symmetric binary B-trees.\" Guibas and Sedgewick [202] studied their properties at length and introduced the red/black color convention. Andersson [16] gives a simpler-to-code variant of red-black trees. Weiss [451] calls this variant AA-trees. An AA-tree is similar to a red-black tree except that left children can never be red.\n\nSedgewick and Wayne [402] present red-black trees as a modified version of 2-3 trees in which a node with three children is split into two nodes with two children each. One of these nodes becomes the left child of the other, and only left children can be red. They call this structure a \"left-leaning red-black binary search tree.\" Although the code for left-leaning red-black binary search trees is more concise than the red-black tree pseudocode in this chapter, operations on left-leaning red-black binary search trees do not limit the number of rotations per operation to a constant. This distinction will matter in Chapter 17.\n\nTreaps, a hybrid of binary search trees and heaps, were proposed by Seidel and Aragon [404]. They are the default implementation of a dictionary in LEDA [324], which is a well-implemented collection of data structures and algorithms.\n\nThere are many other variations on balanced binary trees, including weight-balanced trees [344], \\(k\\)-neighbor trees [318], and scapegoat trees [174]. Perhapsthe most intriguing are the \"splay trees\" introduced by Sleator and Tarjan [418], which are \"self-adjusting.\" (See Tarjan [429] for a good description of splay trees.) Splay trees maintain balance without any explicit balance condition such as color. Instead, \"splay operations\" (which involve rotations) are performed within the tree every time an access is made. The amortized cost (see Chapter 16) of each operation on an \\(n\\)-node tree is \\(O(\\lg n)\\). Splay trees have been conjectured to perform within a constant factor of the best offline rotation-based tree. The best known competitive ratio (see Chapter 27) for a rotation-based tree is the Tango Tree of Demaine et al. [109].\n\nSkip lists [369] provide an alternative to balanced binary trees. A skip list is a linked list that is augmented with a number of additional pointers. Each dictionary operation runs in \\(O(\\lg n)\\) expected time on a skip list of \\(n\\) items.",
        "chapter": "Part III Data Structures",
        "section": "13 Red-Black Trees",
        "subsection": "Chapter notes",
        "subsubsection": "N/A"
    },
    {
        "content": "## Introduction\n\nThis part covers three important techniques used in designing and analyzing efficient algorithms: dynamic programming (Chapter 14), greedy algorithms (Chapter 15), and amortized analysis (Chapter 16). Earlier parts have presented other widely applicable techniques, such as divide-and-conquer, randomization, and how to solve recurrences. The techniques in this part are somewhat more sophisticated, but you will be able to use them solve many computational problems. The themes introduced in this part will recur later in this book.\n\nDynamic programming typically applies to optimization problems in which you make a set of choices in order to arrive at an optimal solution, each choice generates subproblems of the same form as the original problem, and the same subproblems arise repeatedly. The key strategy is to store the solution to each such subproblem rather than recompute it. Chapter 14 shows how this simple idea can sometimes transform exponential-time algorithms into polynomial-time algorithms.\n\nLike dynamic-programming algorithms, greedy algorithms typically apply to optimization problems in which you make a set of choices in order to arrive at an optimal solution. The idea of a greedy algorithm is to make each choice in a locally optimal manner, resulting in a faster algorithm than you get with dynamic programming. Chapter 15 will help you determine when the greedy approach works.\n\nThe technique of amortized analysis applies to certain algorithms that perform a sequence of similar operations. Instead of bounding the cost of the sequence of operations by bounding the actual cost of each operation separately, an amortized analysis provides a worst-case bound on the actual cost of the entire sequence. One advantage of this approach is that although some operations might be expensive, many others might be cheap. You can use amortized analysis when designing algorithms, since the design of an algorithm and the analysis of its running time are often closely intertwined. Chapter 16 introduces three ways to perform an amortized analysis of an algorithm.\n\nDynamic programming, like the divide-and-conquer method, solves problems by combining the solutions to subproblems. (\"Programming\" in this context refers to a tabular method, not to writing computer code.) As we saw in Chapters 2 and 4, divide-and-conquer algorithms partition the problem into disjoint subproblems, solve the subproblems recursively, and then combine their solutions to solve the original problem. In contrast, dynamic programming applies when the subproblems overlap--that is, when subproblems share subsubproblems. In this context, a divide-and-conquer algorithm does more work than necessary, repeatedly solving the common subsubproblems. A dynamic-programming algorithm solves each subsubproblem just once and then saves its answer in a table, thereby avoiding the work of recomputing the answer every time it solves each subsubproblem.\n\nDynamic programming typically applies to _optimization problems_. Such problems can have many possible solutions. Each solution has a value, and you want to find a solution with the optimal (minimum or maximum) value. We call such a solution _an_ optimal solution to the problem, as opposed to _the_ optimal solution, since there may be several solutions that achieve the optimal value.\n\nTo develop a dynamic-programming algorithm, follow a sequence of four steps:\n\n1. Characterize the structure of an optimal solution.\n2. Recursively define the value of an optimal solution.\n3. Compute the value of an optimal solution, typically in a bottom-up fashion.\n4. Construct an optimal solution from computed information.\n\nSteps 1-3 form the basis of a dynamic-programming solution to a problem. If you need only the value of an optimal solution, and not the solution itself, then you can omit step 4. When you do perform step 4, it often pays to maintain additional information during step 3 so that you can easily construct an optimal solution.\n\nThe sections that follow use the dynamic-programming method to solve some optimization problems. Section 14.1 examines the problem of cutting a rod into",
        "chapter": "Part IV Advanced Design and Analysis Techniques",
        "section": "Introduction",
        "subsection": "N/A",
        "subsubsection": "N/A"
    },
    {
        "content": "rods of smaller length in a way that maximizes their total value. Section 14.2 shows how to multiply a chain of matrices while performing the fewest total scalar multiplications. Given these examples of dynamic programming, Section 14.3 discusses two key characteristics that a problem must have for dynamic programming to be a viable solution technique. Section 14.4 then shows how to find the longest common subsequence of two sequences via dynamic programming. Finally, Section 14.5 uses dynamic programming to construct binary search trees that are optimal, given a known distribution of keys to be looked up.\n\n### 14.1 Rod cutting\n\nOur first example uses dynamic programming to solve a simple problem in deciding where to cut steel rods. Serling Enterprises buys long steel rods and cuts them into shorter rods, which it then sells. Each cut is free. The management of Serling Enterprises wants to know the best way to cut up the rods.\n\nSerling Enterprises has a table giving, for \\(i=1,2,\\ldots\\), the price \\(p_{i}\\) in dollars that they charge for a rod of length \\(i\\) inches. The length of each rod in inches is always an integer. Figure 14.1 gives a sample price table.\n\nThe _rod-cutting problem_ is the following. Given a rod of length \\(n\\) inches and a table of prices \\(p_{i}\\) for \\(i=1,2,\\ldots,n\\), determine the maximum revenue \\(r_{n}\\) obtainable by cutting up the rod and selling the pieces. If the price \\(p_{n}\\) for a rod of length \\(n\\) is large enough, an optimal solution might require no cutting at all.\n\nConsider the case when \\(n=4\\). Figure 14.2 shows all the ways to cut up a rod of 4 inches in length, including the way with no cuts at all. Cutting a 4-inch rod into two 2-inch pieces produces revenue \\(p_{2}+p_{2}=5+5=10\\), which is optimal.\n\nSerling Enterprises can cut up a rod of length \\(n\\) in \\(2^{n-1}\\) different ways, since they have an independent option of cutting, or not cutting, at distance \\(i\\) inches from the left end, for \\(i=1,2,\\ldots,n-1\\).1 We denote a decomposition into pieces using ordinary additive notation, so that \\(7=2+2+3\\) indicates that a rod of length 7 is cut into three pieces--two of length 2 and one of length 3. If an optimal solution cuts the rod into \\(k\\) pieces, for some \\(1\\leq k\\leq n\\), then an optimal decomposition\n\nFootnote 1: If pieces are required to be cut in order of monotonically increasing size, there are fewer ways to consider. For \\(n=4\\), only 5 such ways are possible: parts (a), (b), (c), (e), and (h) in Figure 14.2. The number of ways is called the _partition function_, which is approximately equal to \\(e^{\\pi\\sqrt{2n/3}}/4n\\sqrt{3}\\). This quantity is less than \\(2^{n-1}\\), but still much greater than any polynomial in \\(n\\). We won\u2019t pursue this line of inquiry further, however.\n\n\\[n=i_{1}+i_{2}+\\cdots+i_{k}\\]of the rod into pieces of lengths \\(i_{1},\\,i_{2},\\,\\ldots,\\,i_{k}\\) provides maximum corresponding revenue\n\n\\[r_{n}=p_{i_{1}}+p_{i_{2}}+\\cdots+p_{i_{k}}\\.\\]\n\nFor the sample problem in Figure 14.1, you can determine the optimal revenue figures \\(r_{i}\\), for \\(i=1,2,\\ldots,10\\), by inspection, with the corresponding optimal decompositions\n\n\\[r_{1} = 1\\quad\\text{ from solution }1=1\\quad\\text{(no cuts)}\\,\\] \\[r_{2} = 5\\quad\\text{ from solution }2=2\\quad\\text{(no cuts)}\\,\\] \\[r_{3} = 8\\quad\\text{ from solution }3=3\\quad\\text{(no cuts)}\\,\\] \\[r_{4} = 10\\quad\\text{from solution }4=2+2\\,\\] \\[r_{5} = 13\\quad\\text{from solution }5=2+3\\,\\] \\[r_{6} = 17\\quad\\text{from solution }6=6\\quad\\text{(no cuts)}\\,\\] \\[r_{7} = 18\\quad\\text{from solution }7=1+6\\ \\text{ or }\\ 7=2+2+3\\,\\] \\[r_{8} = 22\\quad\\text{from solution }8=2+6\\,\\] \\[r_{9} = 25\\quad\\text{from solution }9=3+6\\,\\] \\[r_{10} = 30\\quad\\text{from solution }10=10\\quad\\text{(no cuts)}\\.\\]\n\nFigure 14.2: The 8 possible ways of cutting up a rod of length 4. Above each piece is the value of that piece, according to the sample price chart of Figure 14.1. The optimal strategy is part (c)\u2014 cutting the rod into two pieces of length \\(2\\)\u2014which has total value 10.\n\nFigure 14.1: A sample price table for rods. Each rod of length \\(i\\) inches earns the company \\(p_{i}\\) dollars of revenue.\n\n### 14.1 Rod cutting\n\nMore generally, we can express the values \\(r_{n}\\) for \\(n\\geq 1\\) in terms of optimal revenues from shorter rods:\n\n\\[r_{n}=\\max\\left\\{p_{n},r_{1}+r_{n-1},r_{2}+r_{n-2},\\ldots,r_{n-1}+r_{1}\\right\\}. \\tag{14.1}\\]\n\nThe first argument, \\(p_{n}\\), corresponds to making no cuts at all and selling the rod of length \\(n\\) as is. The other \\(n-1\\) arguments to max correspond to the maximum revenue obtained by making an initial cut of the rod into two pieces of size \\(i\\) and \\(n-i\\), for each \\(i\\,=\\,1,2,\\ldots,n-1\\), and then optimally cutting up those pieces further, obtaining revenues \\(r_{i}\\) and \\(r_{n-i}\\) from those two pieces. Since you don't know ahead of time which value of \\(i\\) optimizes revenue, you have to consider all possible values for \\(i\\) and pick the one that maximizes revenue. You also have the option of picking no \\(i\\) at all if the greatest revenue comes from selling the rod uncut.\n\nTo solve the original problem of size \\(n\\), you solve smaller problems of the same type. Once you make the first cut, the two resulting pieces form independent instances of the rod-cutting problem. The overall optimal solution incorporates optimal solutions to the two resulting subproblems, maximizing revenue from each of those two pieces. We say that the rod-cutting problem exhibits _optimal substructure_: optimal solutions to a problem incorporate optimal solutions to related subproblems, which you may solve independently.\n\nIn a related, but slightly simpler, way to arrange a recursive structure for the rod-cutting problem, let's view a decomposition as consisting of a first piece of length \\(i\\) cut off the left-hand end, and then a right-hand remainder of length \\(n-i\\). Only the remainder, and not the first piece, may be further divided. Think of every decomposition of a length-\\(n\\) rod in this way: as a first piece followed by some decomposition of the remainder. Then we can express the solution with no cuts at all by saying that the first piece has size \\(i\\,=\\,n\\) and revenue \\(p_{n}\\) and that the remainder has size \\(0\\) with corresponding revenue \\(r_{0}=0\\). We thus obtain the following simpler version of equation (14.1):\n\n\\[r_{n}=\\max\\left\\{p_{i}\\,+r_{n-i}:1\\leq i\\,\\leq n\\right\\}. \\tag{14.2}\\]\n\nIn this formulation, an optimal solution embodies the solution to only _one_ related subproblem--the remainder--rather than two.\n\n### Recursive top-down implementation\n\nThe Cut-Rod procedure on the following page implements the computation implicit in equation (14.2) in a straightforward, top-down, recursive manner. It takes as input an array \\(p[1\\!:\\!n]\\) of prices and an integer \\(n\\), and it returns the maximum revenue possible for a rod of length \\(n\\). For length \\(n\\,=\\,0\\), no revenue is possible, and so Cut-Rod returns \\(0\\) in line 2. Line 3 initializes the maximum revenue \\(q\\) to \\(-\\infty\\), so that the **for** loop in lines 4-5 correctly computes\\(q=\\max\\left\\{p_{i}+\\textsc{Cut-Rod}(p,n-i):1\\leq i\\leq n\\right\\}\\). Line 6 then returns this value. A simple induction on \\(n\\) proves that this answer is equal to the desired answer \\(r_{n}\\), using equation (14.2).\n\n\\[\\textsc{Cut-Rod}(p,n)\\]\n\n```\n1if\\(n==0\\)\n2return\\(0\\)\n3\\(q=-\\infty\\)\n4for\\(i=1\\)to\\(n\\)\n5\\(q=\\max\\left\\{q,\\,p[i]+\\textsc{Cut-Rod}(p,n-i)\\right\\}\\)\n6return\\(q\\)\n```\n\nIf you code up Cut-Rod in your favorite programming language and run it on your computer, you'll find that once the input size becomes moderately large, your program takes a long time to run. For \\(n=40\\), your program may take several minutes and possibly more than an hour. For large values of \\(n\\), you'll also discover that each time you increase \\(n\\) by 1, your program's running time approximately doubles.\n\nWhy is Cut-Rod so inefficient? The problem is that Cut-Rod calls itself recursively over and over again with the same parameter values, which means that it solves the same subproblems repeatedly. Figure 14.3 shows a recursion tree demonstrating what happens for \\(n=4\\): \\(\\textsc{Cut-Rod}(p,n)\\) calls \\(\\textsc{Cut-Rod}(p,n-i)\\) for \\(i=1,2,\\ldots,n\\). Equivalently, \\(\\textsc{Cut-Rod}(p,n)\\) calls \\(\\textsc{Cut-Rod}(p,j)\\) for each \\(j=0,1,\\ldots,n-1\\). When this process unfolds recursively, the amount of work done, as a function of \\(n\\), grows explosively.\n\nTo analyze the running time of Cut-Rod, let \\(T(n)\\) denote the total number of calls made to \\(\\textsc{Cut-Rod}(p,n)\\) for a particular value of \\(n\\). This expression equals the number of nodes in a subtree whose root is labeled \\(n\\) in the recursion tree. The count includes the initial call at its root. Thus, \\(T(0)=1\\) and\n\n\\[T(n)=1+\\sum_{j=0}^{n-1}T(j). \\tag{14.3}\\]\n\nThe initial 1 is for the call at the root, and the term \\(T(j)\\) counts the number of calls (including recursive calls) due to the call \\(\\textsc{Cut-Rod}(p,n-i)\\), where \\(j=n-i\\). As Exercise 14.1-1 asks you to show,\n\n\\[T(n)=2^{n}\\, \\tag{14.4}\\]\n\nand so the running time of Cut-Rod is exponential in \\(n\\).\n\nIn retrospect, this exponential running time is not so surprising. Cut-Rod explicitly considers all possible ways of cutting up a rod of length \\(n\\). How many ways are there? A rod of length \\(n\\) has \\(n-1\\) potential locations to cut. Each possible way to cut up the rod makes a cut at some subset of these \\(n-1\\) locations, including the empty set, which makes for no cuts. Viewing each cut location as a distinct member of a set of \\(n-1\\) elements, you can see that there are \\(2^{n-1}\\) subsets. Each leaf in the recursion tree of Figure 14.3 corresponds to one possible way to cut up the rod. Hence, the recursion tree has \\(2^{n-1}\\) leaves. The labels on the simple path from the root to a leaf give the sizes of each remaining right-hand piece before making each cut. That is, the labels give the corresponding cut points, measured from the right-hand end of the rod.\n\n##### Using dynamic programming for optimal rod cutting\n\nNow, let's see how to use dynamic programming to convert Cut-Rod into an efficient algorithm.\n\nThe dynamic-programming method works as follows. Instead of solving the same subproblems repeatedly, as in the naive recursion solution, arrange for each subproblem to be solved _only once_. There's actually an obvious way to do so: the first time you solve a subproblem, _save its solution_. If you need to refer to this subproblem's solution again later, just look it up, rather than recomputing it.\n\nSaving subproblem solutions comes with a cost: the additional memory needed to store solutions. Dynamic programming thus serves as an example of a _time-memory trade-off_. The savings may be dramatic. For example, we're about to use dynamic programming to go from the exponential-time algorithm for rod cutting\n\nFigure 14.3: The recursion tree showing recursive calls resulting from a call Cut-Rod\\((p,n)\\) for \\(n=4\\). Each node label gives the size \\(n\\) of the corresponding subproblem, so that an edge from a parent with label \\(s\\) to a child with label \\(t\\) corresponds to cutting off an initial piece of size \\(s-t\\) and leaving a remaining subproblem of size \\(t\\). A path from the root to a leaf corresponds to one of the \\(2^{n-1}\\) ways of cutting up a rod of length \\(n\\). In general, this recursion tree has \\(2^{n}\\) nodes and \\(2^{n-1}\\) leaves.\n\ndown to a \\(\\Theta(n^{2})\\)-time algorithm. A dynamic-programming approach runs in polynomial time when the number of _distinct_ subproblems involved is polynomial in the input size and you can solve each such subproblem in polynomial time.\n\nThere are usually two equivalent ways to implement a dynamic-programming approach. Solutions to the rod-cutting problem illustrate both of them.\n\nThe first approach is _top-down_ with _memoization_.2 In this approach, you write the procedure recursively in a natural manner, but modified to save the result of each subproblem (usually in an array or hash table). The procedure now first checks to see whether it has previously solved this subproblem. If so, it returns the saved value, saving further computation at this level. If not, the procedure computes the value in the usual manner but also saves it. We say that the recursive procedure has been _memoized_: it \"remembers\" what results it has computed previously.\n\nFootnote 2: The technical term \u201cmemoization\u201d is not a misspelling of \u201cmemorization.\u201d The word \u201cmemoization\u201d comes from \u201cmemo,\u201d since the technique consists of recording a value to be looked up later.\n\nThe second approach is the _bottom-up method_. This approach typically depends on some natural notion of the \"size\" of a subproblem, such that solving any particular subproblem depends only on solving \"smaller\" subproblems. Solve the subproblems in size order, smallest first, storing the solution to each subproblem when it is first solved. In this way, when solving a particular subproblem, there are already saved solutions for all of the smaller subproblems its solution depends upon. You need to solve each subproblem only once, and when you first see it, you have already solved all of its prerequisite subproblems.\n\nThese two approaches yield algorithms with the same asymptotic running time, except in unusual circumstances where the top-down approach does not actually recurse to examine all possible subproblems. The bottom-up approach often has much better constant factors, since it has lower overhead for procedure calls.\n\nThe procedures Memoized-Cut-Rod and Memoized-Cut-Rod-Aux on the facing page demonstrate how to memoize the top-down Cut-Rod procedure. The main procedure Memoized-Cut-Rod initializes a new auxiliary array \\(r[0:n]\\) with the value \\(-\\infty\\) which, since known revenue values are always nonnegative, is a convenient choice for denoting \"unknown.\" Memoized-Cut-Rod then calls its helper procedure, Memoized-Cut-Rod-Aux, which is just the memorized version of the exponential-time procedure, Cut-Rod. It first checks in line 1 to see whether the desired value is already known and, if it is, then line 2 returns it. Otherwise, lines 3-7 compute the desired value \\(q\\) in the usual manner, line 8 saves it in \\(r[n]\\), and line 9 returns it.\n\nThe bottom-up version, Bottom-Up-Cut-Rod on the next page, is even simpler. Using the bottom-up dynamic-programming approach, Bottom-Up-Cut-Rod takes advantage of the natural ordering of the subproblems: a subproblem of \n\n### Rod cutting\n\nMemoized-Cut-Rod\\((p,n)\\)\n\n```\n1 let \\(r[0\\!:\\!n]\\) be a new array // will remember solution values in \\(r\\)\n2for\\(i\\,=\\,0\\)to\\(n\\)\n3\\(r[i]\\,=\\,-\\infty\\)\n4returnMemoized-Cut-Rod-Aux\\((p,n,r)\\)\n5\n6Memoized-Cut-Rod-Aux\\((p,n,r)\\)\n7if\\(r[n]\\geq 0\\)// already have a solution for length \\(n\\)?\n8return\\(r[n]\\)\n9if\\(n==0\\)\n10\\(q\\,=\\,0\\)\n11else\\(q\\,=\\,-\\infty\\)\n12for\\(i\\,=\\,1\\)to\\(n\\)//\\(i\\) is the position of the first cut\n13\\(q\\,=\\,\\max\\,\\{q,\\,p[i]+\\text{Memoized-Cut-Rod-Aux}(p,n-i,r)\\}\\)\n14\\(r[n]\\,=\\,q\\)// remember the solution value for length \\(n\\)\n15return\\(q\\)\n16Bottom-Up-Cut-Rod\\((p,n)\\)\n17 let \\(r[0\\!:\\!n]\\) be a new array // will remember solution values in \\(r\\)\n18\\(r[0]\\,=\\,0\\)\n19for\\(j\\,=\\,1\\)to\\(n\\)// for increasing rod length \\(j\\)\n20\\(q\\,=\\,-\\infty\\)\n21for\\(i\\,=\\,1\\)to\\(j\\)//\\(i\\) is the position of the first cut\n22\\(q\\,=\\,\\max\\,\\{q,\\,p[i]+r[j-i]\\}\\)\n23\\(r[j]\\,=\\,q\\)// remember the solution value for length \\(j\\)\n24return\\(r[n]\\)\n25\n26\n27\n28\n29\n30\n31\n32\n334\n35\n36\n37\n38\n390\n400\n41\n420\n439\n442\n450\n461\n472\n483\n491\n492\n503\n5104\n5204\n5393\n5405\n5406\n5507\n5608\n57091\n58092\n5900\n60000\n61000\n62000\n63000\n64000\n65093\n6600\n66000\n67000\n68000\n69000\n70000\n71000\n72000\n73000\n74000\n75000\n76000\n77000\n78000\n79000\n80000\n81000\n82000\n83000\n84000\n85000\n86000\n87000\n88900\n90000\n910000\n92000\n930000\n94000\n95000\n96000\n97000\n98000\n99000\n100000\n100000\n100000\n100000\n100000\n100000\n100000\n100000\n100000\n100000\n100000\n100000\n1000000\n1000000\n100000\n1000000\n100000\n1000000\n1000000\n1000000\n1000000\n1000000\n1000000\n1000000\n1000000\n1000000\n10000000\n1000000\n10000000\n1000000\n10000000\n10000000\n10000000\n10000000\n10000000\n10000000\n10000000\n10000000\n100000000\n10000000\n100000000\n100000000\n100000000\n100000000\n10000000\n100000000\n100000000\n1000000000\n1000000000\n100000000\n100000000\n1000000000\n1000000000\n1000000000\n1000000000\n10000000000\n10000000000\n100000000000\n100000000000\n100000000000\n1000000000000\n10000000000000\n1000000000000000\n1loop structure. The number of iterations of its inner **for** loop, in lines 5-6, forms an arithmetic series. The running time of its top-down counterpart, MemoizedCut-Rod, is also \\(\\Theta(n^{2})\\), although this running time may be a little harder to see. Because a recursive call to solve a previously solved subproblem returns immediately, Memoized-Cut-Rod solves each subproblem just once. It solves subproblems for sizes \\(0,1,\\ldots,n\\). To solve a subproblem of size \\(n\\), the **for** loop of lines 6-7 iterates \\(n\\) times. Thus, the total number of iterations of this **for** loop, over all recursive calls of Memoized-Cut-Rod, forms an arithmetic series, giving a total of \\(\\Theta(n^{2})\\) iterations, just like the inner **for** loop of Bottom-Up-Cut-Rod. (We actually are using a form of aggregate analysis here. We'll see aggregate analysis in detail in Section 16.1.)\n\n##### Subproblem graphs\n\nWhen you think about a dynamic-programming problem, you need to understand the set of subproblems involved and how subproblems depend on one another.\n\nThe _subproblem graph_ for the problem embodies exactly this information. Figure 14.4 shows the subproblem graph for the rod-cutting problem with \\(n=4\\). It is a directed graph, containing one vertex for each distinct subproblem. The subproblem graph has a directed edge from the vertex for subproblem \\(x\\) to the vertex for subproblem \\(y\\) if determining an optimal solution for subproblem \\(x\\) involves directly considering an optimal solution for subproblem \\(y\\). For example, the subproblem graph contains an edge from \\(x\\) to \\(y\\) if a top-down recursive procedure for solving \\(x\\) directly calls itself to solve \\(y\\). You can think of the subproblem graph as\n\nFigure 14.4: The subproblem graph for the rod-cutting problem with \\(n=4\\). The vertex labels give the sizes of the corresponding subproblems. A directed edge \\((x,y)\\) indicates that solving subproblem \\(x\\) requires a solution to subproblem \\(y\\). This graph is a reduced version of the recursion tree of Figure 14.3, in which all nodes with the same label are collapsed into a single vertex and all edges go from parent to child.\n\na \"reduced\" or \"collapsed\" version of the recursion tree for the top-down recursive method, with all nodes for the same subproblem coalesced into a single vertex and all edges directed from parent to child.\n\nThe bottom-up method for dynamic programming considers the vertices of the subproblem graph in such an order that you solve the subproblems \\(y\\) adjacent to a given subproblem \\(x\\) before you solve subproblem \\(x\\). (As Section B.4 notes, the adjacency relation in a directed graph is not necessarily symmetric.) Using terminology that we'll see in Section 20.4, in a bottom-up dynamic-programming algorithm, you consider the vertices of the subproblem graph in an order that is a \"reverse topological sort,\" or a \"topological sort of the transpose\" of the subproblem graph. In other words, no subproblem is considered until all of the subproblems it depends upon have been solved. Similarly, using notions that we'll visit in Section 20.3, you can view the top-down method (with memoization) for dynamic programming as a \"depth-first search\" of the subproblem graph.\n\nThe size of the subproblem graph \\(G=(V,E)\\) can help you determine the running time of the dynamic-programming algorithm. Since you solve each subproblem just once, the running time is the sum of the times needed to solve each subproblem. Typically, the time to compute the solution to a subproblem is proportional to the degree (number of outgoing edges) of the corresponding vertex in the subproblem graph, and the number of subproblems is equal to the number of vertices in the subproblem graph. In this common case, the running time of dynamic programming is linear in the number of vertices and edges.\n\n##### Reconstructing a solution\n\nThe procedures Memoized-Cut-Rod and Bottom-Up-Cut-Rod return the _value_ of an optimal solution to the rod-cutting problem, but they do not return the solution _itself_: a list of piece sizes.\n\nLet's see how to extend the dynamic-programming approach to record not only the optimal _value_ computed for each subproblem, but also a _choice_ that led to the optimal value. With this information, you can readily print an optimal solution. The procedure Extended-Bottom-Up-Cut-Rod on the next page computes, for each rod size \\(j\\), not only the maximum revenue \\(r_{j}\\), but also \\(s_{j}\\), the optimal size of the first piece to cut off. It's similar to Bottom-Up-Cut-Rod, except that it creates the array \\(s\\) in line 1, and it updates \\(s[j]\\) in line 8 to hold the optimal size \\(i\\) of the first piece to cut off when solving a subproblem of size \\(j\\).\n\nThe procedure Print-Cut-Rod-Solution on the following page takes as input an array \\(p[1:n]\\) of prices and a rod size \\(n\\). It calls Extended-Bottom-Up-Cut-Rod to compute the array \\(s[1:n]\\) of optimal first-piece sizes. Then it prints out the complete list of piece sizes in an optimal decomposition of a rod of length \\(n\\). For the sample price chart appearing in Figure 14.1, the call Extended-Bottom-Up-Cut-Rod(\\(p\\), 10) returns the following arrays:\n\n\\begin{tabular}{l|r r r r r r r r r r r r} \\(i\\) & 0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 \\\\ \\hline \\(r[i]\\) & 0 & 1 & 5 & 8 & 10 & 13 & 17 & 18 & 22 & 25 & 30 & & \\\\ \\(s[i]\\) & & & 1 & 2 & 3 & 2 & 2 & 6 & 1 & 2 & 3 & 10 \\\\ \\end{tabular}\n\nA call to Print-Cut-Rod-Solution(\\(p\\), 10) prints just 10, but a call with \\(n=7\\) prints the cuts 1 and 6, which correspond to the first optimal decomposition for \\(r_{7}\\) given earlier.\n\nExtended-Bottom-Up-Cut-Rod(\\(p\\), \\(n\\))\n\n let \\(r[0:n]\\) and \\(s[1:n]\\) be new arrays\n\n let \\(r[0:n]\\) and \\(s[1:n]\\) be new arrays\n\n let \\(r[0]=0\\)\n\n let \\(r[j-i]\\) be new arrays\n\n let \\(r[j-i]\\) be new arrays\ndensity. It then continues by applying the greedy strategy to the remaining piece of length \\(n-i\\).\n\n#### 14.1-3\n\nConsider a modification of the rod-cutting problem in which, in addition to a price \\(p_{i}\\) for each rod, each cut incurs a fixed cost of \\(c\\). The revenue associated with a solution is now the sum of the prices of the pieces minus the costs of making the cuts. Give a dynamic-programming algorithm to solve this modified problem.\n\n#### 14.1-4\n\nModify Cut-Rod and Memoized-Cut-Rod-Aux so that their **for** loops go up to only \\(\\lfloor n/2\\rfloor\\), rather than up to \\(n\\). What other changes to the procedures do you need to make? How are their running times affected?\n\n#### 14.1-5\n\nModify Memoized-Cut-Rod to return not only the value but the actual solution.\n\n#### 14.1-6\n\nThe Fibonacci numbers are defined by recurrence (3.31) on page 69. Give an \\(O(n)\\)-time dynamic-programming algorithm to compute the \\(n\\)th Fibonacci number. Draw the subproblem graph. How many vertices and edges does the graph contain?\n\n### Matrix-chain multiplication\n\nOur next example of dynamic programming is an algorithm that solves the problem of matrix-chain multiplication. Given a sequence (chain) \\(\\langle A_{1},\\,A_{2},\\,\\ldots,\\,A_{n}\\rangle\\) of \\(n\\) matrices to be multiplied, where the matrices aren't necessarily square, the goal is to compute the product\n\n\\[A_{1}A_{2}\\cdots A_{n}. \\tag{14.5}\\]\n\nusing the standard algorithm3 for multiplying rectangular matrices, which we'll see in a moment, while minimizing the number of scalar multiplications.\n\nFootnote 3: None of the three methods from Sections 4.1 and Section 4.2 can be used directly, because they apply only to square matrices.\n\nYou can evaluate the expression (14.5) using the algorithm for multiplying pairs of rectangular matrices as a subroutine once you have parenthesized it to resolve all ambiguities in how the matrices are multiplied together. Matrix multiplication is associative, and so all parenthesizations yield the same product. A product of",
        "chapter": "Part IV Advanced Design and Analysis Techniques",
        "section": "14 Dynamic Programming",
        "subsection": "14.1 Rod cutting",
        "subsubsection": "N/A"
    },
    {
        "content": "density. It then continues by applying the greedy strategy to the remaining piece of length \\(n-i\\).\n\n#### 14.1-3\n\nConsider a modification of the rod-cutting problem in which, in addition to a price \\(p_{i}\\) for each rod, each cut incurs a fixed cost of \\(c\\). The revenue associated with a solution is now the sum of the prices of the pieces minus the costs of making the cuts. Give a dynamic-programming algorithm to solve this modified problem.\n\n#### 14.1-4\n\nModify Cut-Rod and Memoized-Cut-Rod-Aux so that their **for** loops go up to only \\(\\lfloor n/2\\rfloor\\), rather than up to \\(n\\). What other changes to the procedures do you need to make? How are their running times affected?\n\n#### 14.1-5\n\nModify Memoized-Cut-Rod to return not only the value but the actual solution.\n\n#### 14.1-6\n\nThe Fibonacci numbers are defined by recurrence (3.31) on page 69. Give an \\(O(n)\\)-time dynamic-programming algorithm to compute the \\(n\\)th Fibonacci number. Draw the subproblem graph. How many vertices and edges does the graph contain?\n\n### Matrix-chain multiplication\n\nOur next example of dynamic programming is an algorithm that solves the problem of matrix-chain multiplication. Given a sequence (chain) \\(\\langle A_{1}\\), \\(A_{2}\\),..., \\(A_{n}\\)) of \\(n\\) matrices to be multiplied, where the matrices aren't necessarily square, the goal is to compute the product\n\n\\[A_{1}A_{2}\\cdots A_{n}. \\tag{14.5}\\]\n\nusing the standard algorithm3 for multiplying rectangular matrices, which we'll see in a moment, while minimizing the number of scalar multiplications.\n\nFootnote 3: None of the three methods from Sections 4.1 and Section 4.2 can be used directly, because they apply only to square matrices.\n\nYou can evaluate the expression (14.5) using the algorithm for multiplying pairs of rectangular matrices as a subroutine once you have parenthesized it to resolve all ambiguities in how the matrices are multiplied together. Matrix multiplication is associative, and so all parenthesizations yield the same product. A product of matrices is _fully parenthesized_ if it is either a single matrix or the product of two fully parenthesized matrix products, surrounded by parentheses. For example, if the chain of matrices is \\(\\langle A_{1}\\), \\(A_{2}\\), \\(A_{3}\\), \\(A_{4}\\rangle\\), then you can fully parenthesize the product \\(A_{1}A_{2}A_{3}A_{4}\\) in five distinct ways:\n\n\\((A_{1}(A_{2}(A_{3}A_{4})))\\),\n\n\\((A_{1}((A_{2}A_{3})A_{4}))\\),\n\n\\(((A_{1}A_{2})(A_{3}A_{4}))\\),\n\n\\(((A_{1}(A_{2}A_{3}))A_{4})\\),\n\n\\((((A_{1}A_{2})A_{3})A_{4})\\).\n\nHow you parenthesize a chain of matrices can have a dramatic impact on the cost of evaluating the product. Consider first the cost of multiplying two rectangular matrices. The standard algorithm is given by the procedure Rectangular-Matrix-Multiply, which generalizes the square-matrix multiplication procedure Matrix-Multiply on page 81. The Rectangular-Matrix-Multiply procedure computes \\(C=C+A\\cdot B\\) for three matrices \\(A=(a_{ij})\\), \\(B=(b_{ij})\\), and \\(C=(c_{ij})\\), where \\(A\\) is \\(p\\times q\\), \\(B\\) is \\(q\\times r\\), and \\(C\\) is \\(p\\times r\\).\n\nRectangular-Matrix-Multiply (\\(A\\), \\(B\\), \\(C\\), \\(p\\), \\(q\\), \\(r\\))\n\n```\n1for\\(i=1\\)to\\(p\\)\n2for\\(j=1\\)to\\(r\\)\n3for\\(k=1\\)to\\(q\\)\n4\\(c_{ij}=c_{ij}+a_{ik}\\cdot b_{kj}\\)\n```\n\nThe running time of Rectangular-Matrix-Multiply is dominated by the number of scalar multiplications in line 4, which is \\(pqr\\). Therefore, we'll consider the cost of multiplying matrices to be the number of scalar multiplications. (The number of scalar multiplications dominates even if we consider initializing \\(C=0\\) to perform just \\(C=A\\cdot B\\).)\n\nTo illustrate the different costs incurred by different parenthesizations of a matrix product, consider the problem of a chain \\(\\langle A_{1}\\), \\(A_{2}\\), \\(A_{3}\\rangle\\) of three matrices. Suppose that the dimensions of the matrices are \\(10\\times 100\\), \\(100\\times 5\\), and \\(5\\times 50\\), respectively. Multiplying according to the parenthesization (\\((A_{1}A_{2})A_{3}\\)) performs \\(10\\cdot 100\\cdot 5=5000\\) scalar multiplications to compute the \\(10\\times 5\\) matrix product \\(A_{1}A_{2}\\), plus another \\(10\\cdot 5\\cdot 50=2500\\) scalar multiplications to multiply this matrix by \\(A_{3}\\), for a total of 7500 scalar multiplications. Multiplying according to the alternative parenthesization (\\(A_{1}(A_{2}A_{3})\\)) performs \\(100\\cdot 5\\cdot 50=25\\),000 scalar multiplications to compute the \\(100\\times 50\\) matrix product \\(A_{2}A_{3}\\), plus another \\(10\\cdot 100\\cdot 50=50\\),000 scalar multiplications to multiply \\(A_{1}\\) by this matrix, for a total of 75,000 scalar multiplications. Thus, computing the product according to the first parenthesization is 10 times faster.\n\nWe state the _matrix-chain multiplication problem_ as follows: given a chain \\(\\left\\langle A_{1},A_{2},\\ldots,A_{n}\\right\\rangle\\) of \\(n\\) matrices, where for \\(i=1,2,\\ldots,n\\), matrix \\(A_{i}\\) has dimension \\(p_{i-1}\\times p_{i}\\), fully parenthesize the product \\(A_{1}A_{2}\\cdots A_{n}\\) in a way that minimizes the number of scalar multiplications. The input is the sequence of dimensions \\(\\left\\langle p_{0},\\,p_{1},\\,p_{2},\\ldots,\\,p_{n}\\right\\rangle\\).\n\nThe matrix-chain multiplication problem does not entail actually multiplying matrices. The goal is only to determine an order for multiplying matrices that has the lowest cost. Typically, the time invested in determining this optimal order is more than paid for by the time saved later on when actually performing the matrix multiplications (such as performing only 7500 scalar multiplications instead of 75,000).\n\n##### Counting the number of parenthesizations\n\nBefore solving the matrix-chain multiplication problem by dynamic programming, let us convince ourselves that exhaustively checking all possible parenthesizations is not an efficient algorithm. Denote the number of alternative parenthesizations of a sequence of \\(n\\) matrices by \\(P(n)\\). When \\(n=1\\), the sequence consists of just one matrix, and therefore there is only one way to fully parenthesize the matrix product. When \\(n\\geq 2\\), a fully parenthesized matrix product is the product of two fully parenthesized matrix subproducts, and the split between the two subproducts may occur between the \\(k\\)th and (\\(k+1\\))st matrices for any \\(k=1,2,\\ldots,n-1\\). Thus, we obtain the recurrence\n\n\\[P(n)=\\left\\{\\begin{array}{ll}1&\\mbox{if $n=1$,}\\\\ \\sum_{k=1}^{n-1}P(k)P(n-k)&\\mbox{if $n\\geq 2$.}\\end{array}\\right. \\tag{14.6}\\]\n\nProblem 12-4 on page 329 asked you to show that the solution to a similar recurrence is the sequence of _Catalan numbers_, which grows as \\(\\Omega(4^{n}/n^{3/2})\\). A simpler exercise (see Exercise 14.2-3) is to show that the solution to the recurrence (14.6) is \\(\\Omega(2^{n})\\). The number of solutions is thus exponential in \\(n\\), and the brute-force method of exhaustive search makes for a poor strategy when determining how to optimally parenthesize a matrix chain.\n\n##### Applying dynamic programming\n\nLet's use the dynamic-programming method to determine how to optimally parenthesize a matrix chain, by following the four-step sequence that we stated at the beginning of this chapter:1. Characterize the structure of an optimal solution.\n2. Recursively define the value of an optimal solution.\n3. Compute the value of an optimal solution.\n4. Construct an optimal solution from computed information.\n\nWe'll go through these steps in order, demonstrating how to apply each step to the problem.\n\n##### Step 1: The structure of an optimal parenthesization\n\nIn the first step of the dynamic-programming method, you find the optimal substructure and then use it to construct an optimal solution to the problem from optimal solutions to subproblems. To perform this step for the matrix-chain multiplication problem, it's convenient to first introduce some notation. Let \\(A_{i:j}\\), where \\(i\\leq j\\), denote the matrix that results from evaluating the product \\(A_{i}A_{i+1}\\cdots A_{j}\\). If the problem is nontrivial, that is, \\(i\\,<\\,j\\), then to parenthesize the product \\(A_{i}A_{i+1}\\cdots A_{j}\\), the product must split between \\(A_{k}\\) and \\(A_{k+1}\\) for some integer \\(k\\) in the range \\(i\\,\\leq k\\,<\\,j\\). That is, for some value of \\(k\\), first compute the matrices \\(A_{i:k}\\) and \\(A_{k+1:j}\\), and then multiply them together to produce the final product \\(A_{i:j}\\). The cost of parenthesizing this way is the cost of computing the matrix \\(A_{i:k}\\), plus the cost of computing \\(A_{k+1:j}\\), plus the cost of multiplying them together.\n\nThe optimal substructure of this problem is as follows. Suppose that to optimally parenthesize \\(A_{i}A_{i+1}\\cdots A_{j}\\), you split the product between \\(A_{k}\\) and \\(A_{k+1}\\). Then the way you parenthesize the \"prefix\" subchain \\(A_{i}A_{i+1}\\cdots A_{k}\\) within this optimal parenthesization of \\(A_{i}A_{i+1}\\cdots A_{j}\\) must be an optimal parenthesization of \\(A_{i}A_{i+1}\\cdots A_{k}\\). Why? If there were a less costly way to parenthesize \\(A_{i}A_{i+1}\\cdots A_{k}\\), then you could substitute that parenthesization in the optimal parenthesization of \\(A_{i}A_{i+1}\\cdots A_{j}\\) to produce another way to parenthesize \\(A_{i}A_{i+1}\\cdots A_{j}\\) whose cost is lower than the optimum: a contradiction. A similar observation holds for how to parenthesize the subchain \\(A_{k+1}A_{k+2}\\cdots A_{j}\\) in the optimal parenthesization of \\(A_{i}A_{i+1}\\cdots A_{j}\\): it must be an optimal parenthesization of \\(A_{k+1}A_{k+2}\\cdots A_{j}\\).\n\nNow let's use the optimal substructure to show how to construct an optimal solution to the problem from optimal solutions to subproblems. Any solution to a nontrivial instance of the matrix-chain multiplication problem requires splitting the product, and any optimal solution contains within it optimal solutions to subproblem instances. Thus, to build an optimal solution to an instance of the matrix-chain multiplication problem, split the problem into two subproblems (optimally parenthesizing \\(A_{i}A_{i+1}\\cdots A_{k}\\) and \\(A_{k+1}A_{k+2}\\cdots A_{j}\\)), find optimal solutions to the two subproblem instances, and then combine these optimal subproblem solutions. To ensure that you've examined the optimal split, you must consider all possible splits.\n\n### Step 2: A recursive solution\n\nThe next step is to define the cost of an optimal solution recursively in terms of the optimal solutions to subproblems. For the matrix-chain multiplication problem, a subproblem is to determine the minimum cost of parenthesizing \\(A_{i}\\,A_{i+1}\\cdots A_{j}\\) for \\(1\\leq i\\leq j\\leq n\\). Given the input dimensions \\(\\langle\\,p_{0},\\,p_{1},\\,p_{2},\\,\\ldots,\\,p_{n}\\,\\rangle\\), an index pair \\(i,\\,j\\) specifies a subproblem. Let \\(m[i,j]\\) be the minimum number of scalar multiplications needed to compute the matrix \\(A_{i:j}\\). For the full problem, the lowest-cost way to compute \\(A_{1:n}\\) is thus \\(m[1,n]\\).\n\nWe can define \\(m[i,j]\\) recursively as follows. If \\(i=j\\), the problem is trivial: the chain consists of just one matrix \\(A_{i:i}=A_{i}\\), so that no scalar multiplications are necessary to compute the product. Thus, \\(m[i,i]=0\\) for \\(i=1,2,\\ldots,n\\). To compute \\(m[i,j]\\) when \\(i<j\\), we take advantage of the structure of an optimal solution from step 1. Suppose that an optimal parenthesization splits the product \\(A_{i}\\,A_{i+1}\\cdots A_{j}\\) between \\(A_{k}\\) and \\(A_{k+1}\\), where \\(i\\leq k<j\\). Then, \\(m[i,j]\\) equals the minimum cost \\(m[i,k]\\) for computing the subproduct \\(A_{i:k}\\), plus the minimum cost \\(m[k+1,j]\\) for computing the subproduct, \\(A_{k+1:j}\\),plus the cost of multiplying these two matrices together. Because each matrix \\(A_{i}\\) is \\(p_{i-1}\\times p_{i}\\), computing the matrix product \\(A_{i:k}\\,A_{k+1:j}\\) takes \\(p_{i-1}p_{k}\\,p_{j}\\) scalar multiplications. Thus, we obtain \\(m[i,j]=m[i,k]+m[k+1,j]+p_{i-1}p_{k}\\,p_{j}\\).\n\nThis recursive equation assumes that you know the value of \\(k\\). But you don't, at least not yet. You have to try all possible values of \\(k\\). How many are there? Just \\(j-i\\), namely \\(k=i,i+1,\\ldots,j-1\\). Since the optimal parenthesization must use one of these values for \\(k\\), you need only check them all to find the best. Thus, the recursive definition for the minimum cost of parenthesizing the product \\(A_{i}\\,A_{i+1}\\cdots A_{j}\\) becomes\n\n\\[m[i,j]=\\cases{0&if $i=j$ \\cr\\min\\,\\{m[i,k]+m[k+1,j]+p_{i-1}p_{k}\\,p_{j}:i \\leq k<j\\}&if $i<j$ \\cr}. \\tag{14.7}\\]\n\nThe \\(m[i,j]\\) values give the costs of optimal solutions to subproblems, but they do not provide all the information you need to construct an optimal solution. To help you do so, let's define \\(s[i,j]\\) to be a value of \\(k\\) at which you split the product \\(A_{i}\\,A_{i+1}\\cdots A_{j}\\) in an optimal parenthesization. That is, \\(s[i,j]\\) equals a value \\(k\\) such that \\(m[i,j]=m[i,k]+m[k+1,j]+p_{i-1}p_{k}\\,p_{j}\\).\n\n### Step 3: Computing the optimal costs\n\nAt this point, you could write a recursive algorithm based on recurrence (14.7) to compute the minimum cost \\(m[1,n]\\) for multiplying \\(A_{1}\\,A_{2}\\cdots A_{n}\\). But as we sawfor the rod-cutting problem, and as we shall see in Section 14.3, this recursive algorithm takes exponential time. That's no better than the brute-force method of checking each way of parenthesizing the product.\n\nFortunately, there aren't all that many distinct subproblems: just one subproblem for each choice of \\(i\\) and \\(j\\) satisfying \\(1\\leq i\\leq j\\leq n\\), or \\(\\binom{n}{2}+n=\\Theta(n^{2})\\) in all.4 A recursive algorithm may encounter each subproblem many times in different branches of its recursion tree. This property of overlapping subproblems is the second hallmark of when dynamic programming applies (the first hallmark being optimal substructure).\n\nFootnote 4: The \\(\\binom{n}{2}\\) term counts all pairs in which \\(i<j\\). Because \\(i\\) and \\(j\\) may be equal, we need to add in the \\(n\\) term.\n\nInstead of computing the solution to recurrence (14.7) recursively, let's compute the optimal cost by using a tabular, bottom-up approach, as in the procedure Matrix-Chain-Order. (The corresponding top-down approach using memoization appears in Section 14.3.) The input is a sequence \\(p=\\langle p_{0},\\,p_{1},\\,\\ldots,\\,p_{n}\\rangle\\) of matrix dimensions, along with \\(n\\), so that for \\(i=1,2,\\ldots,n\\), matrix \\(A_{i}\\) has dimensions \\(p_{i-1}\\times p_{i}\\). The procedure uses an auxiliary table \\(m[1\\!:\\!n,\\,1\\!:\\!n]\\) to store the \\(m[i,j]\\) costs and another auxiliary table \\(s[1\\!:\\!n-1,2\\!:\\!n]\\) that records which index \\(k\\) achieved the optimal cost in computing \\(m[i,j]\\). The table \\(s\\) will help in constructing an optimal solution.\n\nMatrix-Chain-Order (\\(p,n\\))\n\n let \\(m[1\\!:\\!n,\\,1\\!:\\!n]\\) and \\(s[1\\!:\\!n-1,2\\!:\\!n]\\) be new tables\n\n for \\(i=1\\)to\\(n\\) // chain length \\(1\\)\n\n \\(m[i,i]=0\\)\n\n for \\(l=2\\)to\\(n\\) // \\(l\\) is the chain length\n\n for \\(i=1\\)to\\(n-l+1\\) // chain begins at \\(A_{i}\\)\n\n \\(j=i+l-1\\) // chain ends at \\(A_{j}\\)\n\n \\(m[i,j]=\\infty\\)\n\n for \\(k=i\\)to\\(j-1\\) // try \\(A_{i:k}A_{k+1:j}\\)\n\n \\(q=m[i,k]+m[k+1,j]+p_{i-1}p_{k}\\,p_{j}\\)\n\n if \\(q<m[i,j]\\)\n\n \\(m[i,j]=q\\) // remember this cost\n\n \\(s[i,j]=k\\) // remember this index\n\n return\\(m\\) and \\(s\\)\n\nIn what order should the algorithm fill in the table entries? To answer this question, let's see which entries of the table need to be accessed when computing the cost \\(m[i,j]\\). Equation (14.7) tells us that to compute the cost of matrix product \\(A_{i:j}\\), first the costs of the products \\(A_{i:k}\\) and \\(A_{k+1:j}\\) need to have been computed for all \\(k=i,i+1,\\ldots,j-1\\). The chain \\(A_{i}\\,A_{i+1}\\cdots A_{j}\\) consists of \\(j-i+1\\) matrices, and the chains \\(A_{i}\\,A_{i+1}\\ldots A_{k}\\) and \\(A_{k+1}\\,A_{k+2}\\ldots A_{j}\\) consist of \\(k-i+1\\) and \\(j-k\\) matrices, respectively. Since \\(k<j\\), a chain of \\(k-i+1\\) matrices consists of fewer than \\(j-i+1\\) matrices. Likewise, since \\(k\\geq i\\), a chain of \\(j-k\\) matrices consists of fewer than \\(j-i+1\\) matrices. Thus, the algorithm should fill in the table \\(m\\) from shorter matrix chains to longer matrix chains. That is, for the subproblem of optimally parenthesizing the chain \\(A_{i}\\,A_{i+1}\\cdots A_{j}\\), it makes sense to consider the subproblem size as the length \\(j-i+1\\) of the chain.\n\nNow, let's see how the Matrix-Chain-Order procedure fills in the \\(m[i,j]\\) entries in order of increasing chain length. Lines 2-3 initialize \\(m[i,i]=0\\) for \\(i=1,2,\\ldots,n\\), since any matrix chain with just one matrix requires no scalar multiplications. In the **for** loop of lines 4-12, the loop variable \\(l\\) denotes the length of matrix chains whose minimum costs are being computed. Each iteration of this loop uses recurrence (14.7) to compute \\(m[i,i+l-1]\\) for \\(i=1,2,\\ldots,n-l+1\\). In the first iteration, \\(l=2\\), and so the loop computes \\(m[i,i+1]\\) for \\(i=1,2,\\ldots,n-1\\): the minimum costs for chains of length \\(l=2\\). The second time through the loop, it computes \\(m[i,i+2]\\) for \\(i=1,2,\\ldots,n-2\\): the minimum costs for chains of length \\(l=3\\). And so on, ending with a single matrix chain of length \\(l=n\\) and computing \\(m[1,n]\\). When lines 7-12 compute an \\(m[i,j]\\) cost, this cost depends only on table entries \\(m[i,k]\\) and \\(m[k+1,j]\\), which have already been computed.\n\nFigure 14.5 illustrates the \\(m\\) and \\(s\\) tables, as filled in by the Matrix-Chain-Order procedure on a chain of \\(n=6\\) matrices. Since \\(m[i,j]\\) is defined only for \\(i\\leq j\\), only the portion of the table \\(m\\) on or above the main diagonal is used. The figure shows the table rotated to make the main diagonal run horizontally. The matrix chain is listed along the bottom. Using this layout, the minimum cost \\(m[i,j]\\) for multiplying a subchain \\(A_{i}\\,A_{i+1}\\cdots A_{j}\\) of matrices appears at the intersection of lines running northeast from \\(A_{i}\\) and northwest from \\(A_{j}\\). Reading across, each diagonal in the table contains the entries for matrix chains of the same length. Matrix-Chain-Order computes the rows from bottom to top and from left to right within each row. It computes each entry \\(m[i,j]\\) using the products \\(p_{i-1}\\,p_{k}\\,p_{j}\\) for \\(k=i,i+1,\\ldots,j-1\\) and all entries southwest and southeast from \\(m[i,j]\\).\n\nA simple inspection of the nested loop structure of Matrix-Chain-Order yields a running time of \\(O(n^{3})\\) for the algorithm. The loops are nested three deep, and each loop index \\((l,i,\\) and \\(k)\\) takes on at most \\(n-1\\) values. Exercise 14.2-5 asks you to show that the running time of this algorithm is in fact also \\(\\Omega(n^{3})\\). The algorithm requires \\(\\Theta(n^{2})\\) space to store the \\(m\\) and \\(s\\) tables. Thus, Matrix-Chain-Order is much more efficient than the exponential-time method of enumerating all possible parenthesizations and checking each one.\n\n\\[m[2,5] =\\ \\min\\begin{cases}m[2,2]+m[3,5]+\\,p_{1}\\,p_{2}\\,p_{5}&=\\ 0+2500+35\\cdot 1 5\\cdot 20&=\\ 13,000\\,\\\\ m[2,3]+m[4,5]+\\,p_{1}\\,p_{3}\\,p_{5}&=\\ 2625+1000+35\\cdot 5\\cdot 20&=\\ 7125\\,\\\\ m[2,4]+m[5,5]+\\,p_{1}\\,p_{4}\\,p_{5}&=\\ 4375+0+35\\cdot 10\\cdot 20&=\\ 11,375\\end{cases}\\]\n\n### Step 4: Constructing an optimal solution\n\nAlthough Matrix-Chain-Order determines the optimal number of scalar multiplications needed to compute a matrix-chain product, it does not directly show how to multiply the matrices. The table \\(s[1:n-1,2:n]\\) provides the information needed to do so. Each entry \\(s[i,j]\\) records a value of \\(k\\) such that an optimal parenthesization of \\(A_{i}A_{i+1}\\cdots A_{j}\\) splits the product between \\(A_{k}\\) and \\(A_{k+1}\\). The final matrix multiplication in computing \\(A_{1:n}\\) optimally is \\(A_{1:s[1,n]}A_{s[1,n]+1:n}\\). The \\(s\\) table contains the information needed to determine the earlier matrix multiplications as well, using recursion: \\(s[1,s[1,n]]\\) determines the last matrix multiplication when computing \\(A_{1:s[1,n]}\\) and \\(s[s[1,n]+1,n]\\) determines the last matrix multiplication when computing \\(A_{s[1,n]+1:n}\\). The recursive procedure Print-Optimal-Parens on the facing page prints an optimal parenthesization of the matrix chain product \\(A_{i}A_{i+1}\\cdots A_{j}\\), given the \\(s\\) table computed by Matrix-Chain-Order and the in\n\nFigure 14.5: The \\(m\\) and \\(s\\) tables computed by Matrix-Chain-Order for \\(n=6\\) and the following matrix dimensions:\n\ndices \\(i\\) and \\(j\\). The initial call Print-Optimal-Parens\\((s,1,n)\\) prints an optimal parenthesization of the full matrix chain product \\(A_{1}A_{2}\\cdots A_{n}\\). In the example of Figure 14.5, the call Print-Optimal-Parens\\((s,1,6)\\) prints the optimal parenthesization (\\((A_{1}(A_{2}A_{3}))((A_{4}A_{5})A_{6})\\)).\n\nPrint-Optimal-Parens\\((s,i,j)\\)\n\n```\n1if\\(i==j\\)\n2print \"\\(A\\)\"\\({}_{i}\\)\n3else print \"(\" Print-Optimal-Parens\\((s,i,s[i,j])\\)\n4 Print-Optimal-Parens\\((s,s[i,j]+1,j)\\)\n5 print \")\"\n```\n\n**Exercises**\n\n#### 14.2-1\n\nFind an optimal parenthesization of a matrix-chain product whose sequence of dimensions is \\(\\langle 5,10,3,12,5,50,6\\rangle\\).\n\n#### 14.2-2\n\nGive a recursive algorithm Matrix-Chain-Multiply\\((A,s,i,j)\\) that actually performs the optimal matrix-chain multiplication, given the sequence of matrices \\(\\langle A_{1},\\,A_{2},\\ldots,\\,A_{n}\\rangle\\), the \\(s\\) table computed by Matrix-Chain-Order, and the indices \\(i\\) and \\(j\\). (The initial call is Matrix-Chain-Multiply\\((A,s,1,n)\\).) Assume that the call Rectangular-Matrix-Multiply\\((A,\\,B)\\) returns the product of matrices \\(A\\) and \\(B\\).\n\n#### 14.2-3\n\nUse the substitution method to show that the solution to the recurrence (14.6) is \\(\\Omega(2^{n})\\).\n\n#### 14.2-4\n\nDescribe the subproblem graph for matrix-chain multiplication with an input chain of length \\(n\\). How many vertices does it have? How many edges does it have, and which edges are they?\n\n#### 14.2-5\n\nLet \\(R(i,j)\\) be the number of times that table entry \\(m[i,j]\\) is referenced while computing other table entries in a call of Matrix-Chain-Order. Show that the total number of references for the entire table is \\[\\sum_{i=1}^{n}\\sum_{j=i}^{n}R(i,j)=\\frac{n^{\\,3}-n}{3}\\.\\]\n\n_(Hint:_ You may find equation (A.4) on page 1141 useful.)_\n\n_14.2-6_\n\n_Show that a full parenthesization of an \\(n\\)-element expression has exactly \\(n-1\\) pairs of parentheses._\n\n### Elements of dynamic programming\n\nAlthough you have just seen two complete examples of the dynamic-programming method, you might still be wondering just when the method applies. From an engineering perspective, when should you look for a dynamic-programming solution to a problem? In this section, we'll examine the two key ingredients that an optimization problem must have in order for dynamic programming to apply: optimal substructure and overlapping subproblems. We'll also revisit and discuss more fully how memoization might help you take advantage of the overlapping-subproblems property in a top-down recursive approach.\n\n#### Optimal substructure\n\nThe first step in solving an optimization problem by dynamic programming is to characterize the structure of an optimal solution. Recall that a problem exhibits _optimal substructure_ if an optimal solution to the problem contains within it optimal solutions to subproblems. When a problem exhibits optimal substructure, that gives you a good clue that dynamic programming might apply. (As Chapter 15 discusses, it also might mean that a greedy strategy applies, however.) Dynamic programming builds an optimal solution to the problem from optimal solutions to subproblems. Consequently, you must take care to ensure that the range of subproblems you consider includes those used in an optimal solution.\n\nOptimal substructure was key to solving both of the previous problems in this chapter. In Section 14.1, we observed that the optimal way of cutting up a rod of length \\(n\\) (if Serling Enterprises makes any cuts at all) involves optimally cutting up the two pieces resulting from the first cut. In Section 14.2, we noted that an optimal parenthesization of the matrix chain product \\(A_{i}\\,A_{i+1}\\cdots A_{j}\\) that splits the product between \\(A_{k}\\) and \\(A_{k+1}\\) contains within it optimal solutions to the problems of parenthesizing \\(A_{i}\\,A_{i+1}\\cdots A_{k}\\) and \\(A_{k+1}\\,A_{k+2}\\cdots A_{j}\\).",
        "chapter": "Part IV Advanced Design and Analysis Techniques",
        "section": "14 Dynamic Programming",
        "subsection": "14.2 Matrix-chain multiplication",
        "subsubsection": "N/A"
    },
    {
        "content": "\\[\\sum_{i=1}^{n}\\sum_{j=i}^{n}R(i,j)=\\frac{n^{\\,3}-n}{3}\\.\\]\n\n_(Hint:_ You may find equation (A.4) on page 1141 useful.)_\n\n_14.2-6_\n\n_Show that a full parenthesization of an \\(n\\)-element expression has exactly \\(n-1\\) pairs of parentheses._\n\n### Elements of dynamic programming\n\nAlthough you have just seen two complete examples of the dynamic-programming method, you might still be wondering just when the method applies. From an engineering perspective, when should you look for a dynamic-programming solution to a problem? In this section, we'll examine the two key ingredients that an optimization problem must have in order for dynamic programming to apply: optimal substructure and overlapping subproblems. We'll also revisit and discuss more fully how memoization might help you take advantage of the overlapping-subproblems property in a top-down recursive approach.\n\n#### Optimal substructure\n\nThe first step in solving an optimization problem by dynamic programming is to characterize the structure of an optimal solution. Recall that a problem exhibits _optimal substructure_ if an optimal solution to the problem contains within it optimal solutions to subproblems. When a problem exhibits optimal substructure, that gives you a good clue that dynamic programming might apply. (As Chapter 15 discusses, it also might mean that a greedy strategy applies, however.) Dynamic programming builds an optimal solution to the problem from optimal solutions to subproblems. Consequently, you must take care to ensure that the range of subproblems you consider includes those used in an optimal solution.\n\nOptimal substructure was key to solving both of the previous problems in this chapter. In Section 14.1, we observed that the optimal way of cutting up a rod of length \\(n\\) (if Serling Enterprises makes any cuts at all) involves optimally cutting up the two pieces resulting from the first cut. In Section 14.2, we noted that an optimal parenthesization of the matrix chain product \\(A_{i}\\,A_{i+1}\\cdots A_{j}\\) that splits the product between \\(A_{k}\\) and \\(A_{k+1}\\) contains within it optimal solutions to the problems of parenthesizing \\(A_{i}\\,A_{i+1}\\cdots A_{k}\\) and \\(A_{k+1}\\,A_{k+2}\\cdots A_{j}\\).\n\n### Elements of dynamic programming\n\nYou will find yourself following a common pattern in discovering optimal substructure:\n\n1. You show that a solution to the problem consists of making a choice, such as choosing an initial cut in a rod or choosing an index at which to split the matrix chain. Making this choice leaves one or more subproblems to be solved.\n2. You suppose that for a given problem, you are given the choice that leads to an optimal solution. You do not concern yourself yet with how to determine this choice. You just assume that it has been given to you.\n3. Given this choice, you determine which subproblems ensue and how to best characterize the resulting space of subproblems.\n4. You show that the solutions to the subproblems used within an optimal solution to the problem must themselves be optimal by using a \"cut-and-paste\" technique. You do so by supposing that each of the subproblem solutions is not optimal and then deriving a contradiction. In particular, by \"cutting out\" the nonoptimal solution to each subproblem and \"pasting in\" the optimal one, you show that you can get a better solution to the original problem, thus contradicting your supposition that you already had an optimal solution. If an optimal solution gives rise to more than one subproblem, they are typically so similar that you can modify the cut-and-paste argument for one to apply to the others with little effort.\n\nTo characterize the space of subproblems, a good rule of thumb says to try to keep the space as simple as possible and then expand it as necessary. For example, the space of subproblems for the rod-cutting problem contained the problems of optimally cutting up a rod of length \\(i\\) for each size \\(i\\). This subproblem space worked well, and it was not necessary to try a more general space of subproblems.\n\nConversely, suppose that you tried to constrain the subproblem space for matrix-chain multiplication to matrix products of the form \\(A_{1}A_{2}\\cdots A_{j}\\). As before, an optimal parenthesization must split this product between \\(A_{k}\\) and \\(A_{k+1}\\) for some \\(1\\leq k\\,<j\\). Unless you can guarantee that \\(k\\) always equals \\(j-1\\), you will find that you have subproblems of the form \\(A_{1}A_{2}\\cdots A_{k}\\) and \\(A_{k+1}A_{k+2}\\cdots A_{j}\\). Moreover, the latter subproblem does not have the form \\(A_{1}A_{2}\\cdots A_{j}\\). To solve this problem by dynamic programming, you need to allow the subproblems to vary at \"both ends.\" That is, both \\(i\\) and \\(j\\) need to vary in the subproblem of parenthesizing the product \\(A_{i}A_{i+1}\\cdots A_{j}\\).\n\nOptimal substructure varies across problem domains in two ways:\n\n1. how many subproblems an optimal solution to the original problem uses, and\n2. how many choices you have in determining which subproblem(s) to use in an optimal solution.\n\nIn the rod-cutting problem, an optimal solution for cutting up a rod of size \\(n\\) uses just one subproblem (of size \\(n-i\\)), but we have to consider \\(n\\) choices for \\(i\\) in order to determine which one yields an optimal solution. Matrix-chain multiplication for the subchain \\(A_{i}\\,A_{i+1}\\cdots A_{j}\\) serves an example with two subproblems and \\(j-i\\) choices. For a given matrix \\(A_{k}\\) where the product splits, two subproblems arise--parenthesizing \\(A_{i}\\,A_{i+1}\\cdots A_{k}\\) and parenthesizing \\(A_{k+1}\\,A_{k+2}\\cdots A_{j}\\,\\)--and we have to solve _both_ of them optimally. Once we determine the optimal solutions to subproblems, we choose from among \\(j-i\\) candidates for the index \\(k\\).\n\nInformally, the running time of a dynamic-programming algorithm depends on the product of two factors: the number of subproblems overall and how many choices you look at for each subproblem. In rod cutting, we had \\(\\Theta(n)\\) subproblems overall, and at most \\(n\\) choices to examine for each, yielding an \\(O(n^{2})\\) running time. Matrix-chain multiplication had \\(\\Theta(n^{2})\\) subproblems overall, and each had at most \\(n-1\\) choices, giving an \\(O(n^{3})\\) running time (actually, a \\(\\Theta(n^{3})\\) running time, by Exercise 14.2-5).\n\nUsually, the subproblem graph gives an alternative way to perform the same analysis. Each vertex corresponds to a subproblem, and the choices for a subproblem are the edges incident from that subproblem. Recall that in rod cutting, the subproblem graph has \\(n\\) vertices and at most \\(n\\) edges per vertex, yielding an \\(O(n^{2})\\) running time. For matrix-chain multiplication, if you were to draw the subproblem graph, it would have \\(\\Theta(n^{2})\\) vertices and each vertex would have degree at most \\(n-1\\), giving a total of \\(O(n^{3})\\) vertices and edges.\n\nDynamic programming often uses optimal substructure in a bottom-up fashion. That is, you first find optimal solutions to subproblems and, having solved the subproblems, you find an optimal solution to the problem. Finding an optimal solution to the problem entails making a choice among subproblems as to which you will use in solving the problem. The cost of the problem solution is usually the subproblem costs plus a cost that is directly attributable to the choice itself. In rod cutting, for example, first we solved the subproblems of determining optimal ways to cut up rods of length \\(i\\) for \\(i=0,1,\\ldots,n-1\\), and then we determined which of these subproblems yielded an optimal solution for a rod of length \\(n\\), using equation (14.2). The cost attributable to the choice itself is the term \\(p_{i}\\) in equation (14.2). In matrix-chain multiplication, we determined optimal parenthesizations of subchains of \\(A_{i}\\,A_{i+1}\\cdots A_{j}\\), and then we chose the matrix \\(A_{k}\\) at which to split the product. The cost attributable to the choice itself is the term \\(p_{i-1}\\,p_{k}\\,p_{j}\\).\n\nChapter 15 explores \"greedy algorithms,\" which have many similarities to dynamic programming. In particular, problems to which greedy algorithms apply have optimal substructure. One major difference between greedy algorithms and dynamic programming is that instead of first finding optimal solutions to subproblems and then making an informed choice, greedy algorithms first make a \"greedy\" choice -- the choice that looks best at the time--and then solve a resulting subproblem lem, without bothering to solve all possible related smaller subproblems. Surprisingly, in some cases this strategy works!\n\nSubtletiesYou should be careful not to assume that optimal substructure applies when it does not. Consider the following two problems whose input consists of a directed graph \\(G=(V,E)\\) and vertices \\(u,v\\in V\\).\n\nUnweighted shortest path:5Find a path from \\(u\\) to \\(v\\) consisting of the fewest edges. Such a path must be simple, since removing a cycle from a path produces a path with fewer edges.\n\nUnweighted longest simple path:Find a simple path from \\(u\\) to \\(v\\) consisting of the most edges. (Without the requirement that the path must be simple, the problem is undefined, since repeatedly traversing a cycle creates paths with an arbitrarily large number of edges.)\n\nFootnote 5: We use the term \u201cunweighted\u201d to distinguish this problem from that of finding shortest paths with weighted edges, which we shall see in Chapters 22 and 23. You can use the breadth-first search technique of Chapter 20 to solve the unweighted problem.\n\nThe unweighted shortest-path problem exhibits optimal substructure. Here's how. Suppose that \\(u\\neq v\\), so that the problem is nontrivial. Then, any path \\(p\\) from \\(u\\) to \\(v\\) must contain an intermediate vertex, say \\(w\\). (Note that \\(w\\) may be \\(u\\) or \\(v\\).) Then, we can decompose the path \\(u\\stackrel{{ p}}{{\\leadsto}}v\\) into subpaths \\(u\\stackrel{{ p_{1}}}{{\\leadsto}}w\\stackrel{{ p_{2}}}{{\\leadsto}}v\\). The number of edges in \\(p\\) equals the number of edges in \\(p_{1}\\) plus the number of edges in \\(p_{2}\\). We claim that if \\(p\\) is an optimal (i.e., shortest) path from \\(u\\) to \\(v\\), then \\(p_{1}\\) must be a shortest path from \\(u\\) to \\(w\\). Why? As suggested earlier, use a \"cut-and-paste\" argument: if there were another path, say \\(p_{1}^{{}^{\\prime}}\\), from \\(u\\) to \\(w\\) with fewer edges than \\(p_{1}\\), then we could cut out \\(p_{1}\\) and paste in \\(p_{1}^{{}^{\\prime}}\\) to produce a path \\(u\\stackrel{{ p_{1}^{\\prime}}}{{\\leadsto}}w\\stackrel{{ p_{2}}}{{\\leadsto}}v\\) with fewer edges than \\(p\\), thus contradicting \\(p\\)'s optimality. Likewise, \\(p_{2}\\) must be a shortest path from \\(w\\) to \\(v\\). Thus, to find a shortest path from \\(u\\) to \\(v\\), consider all intermediate vertices \\(w\\), find a shortest path from \\(u\\) to \\(w\\) and a shortest path from \\(w\\) to \\(v\\), and choose an intermediate vertex \\(w\\) that yields the overall shortest path. Section 23.2 uses a variant of this observation of optimal substructure to find a shortest path between every pair of vertices on a weighted, directed graph.\n\nYou might be tempted to assume that the problem of finding an unweighted longest simple path exhibits optimal substructure as well. After all, if we decompose a longest simple path \\(u\\stackrel{{ p}}{{\\leadsto}}v\\) into subpaths \\(u\\stackrel{{ p_{1}}}{{\\leadsto}}w\\stackrel{{ p_{2}}}{{\\leadsto}}v\\), then mustn't \\(p_{1}\\) be a longest simple path from \\(u\\) to \\(w\\), and mustn't \\(p_{2}\\) be a longest simple path from \\(w\\) to \\(v\\)? The answer is no! Figure 14.6 supplies an example. Consider the path \\(q\\to r\\to t\\), which is a longest simple path from \\(q\\) to \\(t\\). Is \\(q\\to r\\) a longest simple path from \\(q\\) to \\(r\\)? No, for the path \\(q\\to s\\to t\\to r\\) is a simple path that is longer. Is \\(r\\to t\\) a longest simple path from \\(r\\) to \\(t\\)? No again, for the path \\(r\\to q\\to s\\to t\\) is a simple path that is longer.\n\nThis example shows that for longest simple paths, not only does the problem lack optimal substructure, but you cannot necessarily assemble a \"legal\" solution to the problem from solutions to subproblems. If you combine the longest simple paths \\(q\\to s\\to t\\to r\\) and \\(r\\to q\\to s\\to t\\), you get the path \\(q\\to s\\to t\\to r\\to q\\to s\\to t\\), which is not simple. Indeed, the problem of finding an unweighted longest simple path does not appear to have any sort of optimal substructure. No efficient dynamic-programming algorithm for this problem has ever been found. In fact, this problem is NP-complete, which--as we shall see in Chapter 34--means that we are unlikely to find a way to solve it in polynomial time.\n\nWhy is the substructure of a longest simple path so different from that of a shortest path? Although a solution to a problem for both longest and shortest paths uses two subproblems, the subproblems in finding the longest simple path are not _independent_, whereas for shortest paths they are. What do we mean by subproblems being independent? We mean that the solution to one subproblem does not affect the solution to another subproblem of the same problem. For the example of Figure 14.6, we have the problem of finding a longest simple path from \\(q\\) to \\(t\\) with two subproblems: finding longest simple paths from \\(q\\) to \\(r\\) and from \\(r\\) to \\(t\\). For the first of these subproblems, we chose the path \\(q\\to s\\to t\\to r\\), which used the vertices \\(s\\) and \\(t\\). These vertices cannot appear in a solution to the second subproblem, since the combination of the two solutions to subproblems yields a path that is not simple. If vertex \\(t\\) cannot be in the solution to the second problem, then there is no way to solve it, since \\(t\\) is required to be on the path that forms the solution, and it is not the vertex where the subproblem solutions are \"spliced\" together (that vertex being \\(r\\)). Because vertices \\(s\\) and \\(t\\) appear in one subproblem solution, they cannot appear in the other subproblem solution. One of them must be in the solution to the other subproblem, however, and an optimal solution requires both.\n\nFigure 14.6: A directed graph showing that the problem of finding a longest simple path in an unweighted directed graph does not have optimal substructure. The path \\(q\\to r\\to t\\) is a longest simple path from \\(q\\) to \\(t\\), but the subpath \\(q\\to r\\) is not a longest simple path from \\(q\\) to \\(r\\), nor is the subpath \\(r\\to t\\) a longest simple path from \\(r\\) to \\(t\\).\n\nThus, we say that these subproblems are not independent. Looked at another way, using resources in solving one subproblem (those resources being vertices) renders them unavailable for the other subproblem.\n\nWhy, then, are the subproblems independent for finding a shortest path? The answer is that by nature, the subproblems do not share resources. We claim that if a vertex \\(w\\) is on a shortest path \\(p\\) from \\(u\\) to \\(v\\), then we can splice together _any_ shortest path \\(u\\stackrel{{ p_{1}}}{{\\leadsto}}w\\) and _any_ shortest path \\(w\\stackrel{{ p_{2}}}{{\\leadsto}}v\\) to produce a shortest path from \\(u\\) to \\(v\\). We are assured that, other than \\(w\\), no vertex can appear in both paths \\(p_{1}\\) and \\(p_{2}\\). Why? Suppose that some vertex \\(x\\neq w\\) appears in both \\(p_{1}\\) and \\(p_{2}\\), so that we can decompose \\(p_{1}\\) as \\(u\\stackrel{{ p_{ux}}}{{\\leadsto}}x\\leadsto w\\) and \\(p_{2}\\) as \\(w\\leadsto x\\stackrel{{ p_{xy}}}{{\\leadsto}}v\\). By the optimal substructure of this problem, path \\(p\\) has as many edges as \\(p_{1}\\) and \\(p_{2}\\) together. Let's say that \\(p\\) has \\(e\\) edges. Now let us construct a path \\(p^{\\prime}=u\\stackrel{{ p_{ux}}}{{\\leadsto}}x\\stackrel{{ p_{xy}}}{{\\leadsto}}v\\) from \\(u\\) to \\(v\\). Because we have excised the paths from \\(x\\) to \\(w\\) and from \\(w\\) to \\(x\\), each of which contains at least one edge, path \\(p^{\\prime}\\) contains at most \\(e-2\\) edges, which contradicts the assumption that \\(p\\) is a shortest path. Thus, we are assured that the subproblems for the shortest-path problem are independent.\n\nThe two problems examined in Sections 14.1 and 14.2 have independent subproblems. In matrix-chain multiplication, the subproblems are multiplying subchains \\(A_{i}A_{i+1}\\cdots A_{k}\\) and \\(A_{k+1}A_{k+2}\\cdots A_{j}\\). These subchains are disjoint, so that no matrix could possibly be included in both of them. In rod cutting, to determine the best way to cut up a rod of length \\(n\\), we looked at the best ways of cutting up rods of length \\(i\\) for \\(i=0,1,\\ldots,n-1\\). Because an optimal solution to the length-\\(n\\) problem includes just one of these subproblem solutions (after cutting off the first piece), independence of subproblems is not an issue.\n\n#### Overlapping subproblems\n\nThe second ingredient that an optimization problem must have for dynamic programming to apply is that the space of subproblems must be \"small\" in the sense that a recursive algorithm for the problem solves the same subproblems over and over, rather than always generating new subproblems. Typically, the total number of distinct subproblems is a polynomial in the input size. When a recursive algorithm revisits the same problem repeatedly, we say that the optimization problem has _overlapping subproblems_.6 In contrast, a problem for which a divide-andconquer approach is suitable usually generates brand-new problems at each step of the recursion. Dynamic-programming algorithms typically take advantage of overlapping subproblems by solving each subproblem once and then storing the solution in a table where it can be looked up when needed, using constant time per lookup.\n\nIn Section 14.1, we briefly examined how a recursive solution to rod cutting makes exponentially many calls to find solutions of smaller subproblems. The dynamic-programming solution reduces the running time from the exponential time of the recursive algorithm down to quadratic time.\n\nTo illustrate the overlapping-subproblems property in greater detail, let's revisit the matrix-chain multiplication problem. Referring back to Figure 14.5, observe that Matrix-Chain-Order repeatedly looks up the solution to subproblems in lower rows when solving subproblems in higher rows. For example, it references entry \\(m[3,4]\\) four times: during the computations of \\(m[2,4]\\), \\(m[1,4]\\), \\(m[3,5]\\), and \\(m[3,6]\\). If the algorithm were to recompute \\(m[3,4]\\) each time, rather than just looking it up, the running time would increase dramatically. To see how, consider the inefficient recursive procedure Recursive-Matrix-Chain on the facing page, which determines \\(m[i,j]\\), the minimum number of scalar multiplications needed to compute the matrix-chain product \\(A_{i:j}=A_{i}\\,A_{i+1}\\,\\cdots\\,A_{j}\\). The procedure is based directly on the recurrence (14.7). Figure 14.7 shows the recursion tree produced by the call Recursive-Matrix-Chain\\((p,1,4)\\). Each node is labeled by the values of the parameters \\(i\\) and \\(j\\). Observe that some pairs of values occur many times.\n\nIn fact, the time to compute \\(m[1,n]\\) by this recursive procedure is at least exponential in \\(n\\). To see why, let \\(T(n)\\) denote the time taken by Recursive-Matrix\n\nFigure 14.7: The recursion tree for the computation of Recursive-Matrix-Chain\\((p,1,4)\\). Each node contains the parameters \\(i\\) and \\(j\\). The computations performed in a subtree shaded blue are replaced by a single table lookup in Memoized-Matrix-Chain.\n\n### Elements of dynamic programming\n\nRecursive-Matrix-Chain\\((p,i,j)\\)\n\n```\n1if\\(i==j\\)\n2return\\(0\\)\n3\\(m[i,j]=\\infty\\)\n4for\\(k=i\\)to\\(j-1\\)\n5\\(q=\\)Recursive-Matrix-Chain\\((p,i,k)\\) \\(+\\)Recursive-Matrix-Chain\\((p,k+1,j)\\) \\(+\\)\\(p_{i-1}p_{k}p_{j}\\)\n6if\\(q<m[i,j]\\)\n7\\(m[i,j]=q\\)\n8return\\(m[i,j]\\)\n```\n\nChain to compute an optimal parenthesization of a chain of \\(n\\) matrices. Because the execution of lines 1-2 and of lines 6-7 each take at least unit time, as does the multiplication in line 5, inspection of the procedure yields the recurrence\n\n\\[T(n)\\geq\\left\\{\\begin{array}{ll}1&\\mbox{if $n=1$,}\\\\ 1+\\sum_{k=1}^{n-1}(T(k)+T(n-k)+1)&\\mbox{if $n>1$.}\\end{array}\\right.\\]\n\nNoting that for \\(i=1,2,\\ldots,n-1\\), each term \\(T(i)\\) appears once as \\(T(k)\\) and once as \\(T(n-k)\\), and collecting the \\(n-1\\) 1s in the summation together with the 1 out front, we can rewrite the recurrence as\n\n\\[T(n)\\geq 2\\sum_{i=1}^{n-1}T(i)+n. \\tag{14.8}\\]\n\nLet's prove that \\(T(n)=\\Omega(2^{n})\\) using the substitution method. Specifically, we'll show that \\(T(n)\\geq 2^{n-1}\\) for all \\(n\\geq 1\\). For the base case \\(n=1\\), the summation is empty, and we get \\(T(1)\\geq 1=2^{0}\\). Inductively, for \\(n\\geq 2\\) we have\n\n\\[T(n) \\geq 2\\sum_{i=1}^{n-1}2^{i-1}+n\\] \\[= 2\\sum_{j=0}^{n-2}2^{j}+n\\qquad\\mbox{ (letting $j=i-1$)}\\] \\[= 2(2^{n-1}-1)+n\\quad\\mbox{(by equation (A.6) on page 1142)}\\] \\[= 2^{n}-2+n\\] \\[\\geq 2^{n-1}\\,\\]which completes the proof. Thus, the total amount of work performed by the call Recursive-Matrix-Chain\\((p,1,n)\\) is at least exponential in \\(n\\).\n\nCompare this top-down, recursive algorithm (without memoization) with the bottom-up dynamic-programming algorithm. The latter is more efficient because it takes advantage of the overlapping-subproblems property. Matrix-chain multiplication has only \\(\\Theta(n^{2})\\) distinct subproblems, and the dynamic-programming algorithm solves each exactly once. The recursive algorithm, on the other hand, must solve each subproblem every time it reappears in the recursion tree. Whenever a recursion tree for the natural recursive solution to a problem contains the same subproblem repeatedly, and the total number of distinct subproblems is small, dynamic programming can improve efficiency, sometimes dramatically.\n\n##### Reconstructing an optimal solution\n\nAs a practical matter, you'll often want to store in a separate table which choice you made in each subproblem so that you do not have to reconstruct this information from the table of costs.\n\nFor matrix-chain multiplication, the table \\(s[i,j]\\) saves a significant amount of work when we need to reconstruct an optimal solution. Suppose that the Matrix-Chain-Order procedure on page 378 did not maintain the \\(s[i,j]\\) table, so that it filled in only the table \\(m[i,j]\\) containing optimal subproblem costs. The procedure chooses from among \\(j-i\\) possibilities when determining which subproblems to use in an optimal solution to parenthesizing \\(A_{i}\\,A_{i+1}\\cdots A_{j}\\), and \\(j-i\\) is not a constant. Therefore, it would take \\(\\Theta(j-i)=o(1)\\) time to reconstruct which subproblems it chose for a solution to a given problem. Because Matrix-Chain-Order stores in \\(s[i,j]\\) the index of the matrix at which it split the product \\(A_{i}\\,A_{i+1}\\cdots A_{j}\\), the Print-Optimal-Parens procedure on page 381 can look up each choice in \\(O(1)\\) time.\n\n##### Memoization\n\nAs we saw for the rod-cutting problem, there is an alternative approach to dynamic programming that often offers the efficiency of the bottom-up dynamic-programming approach while maintaining a top-down strategy. The idea is to _memoize_ the natural, but inefficient, recursive algorithm. As in the bottom-up approach, you maintain a table with subproblem solutions, but the control structure for filling in the table is more like the recursive algorithm.\n\nA memoized recursive algorithm maintains an entry in a table for the solution to each subproblem. Each table entry initially contains a special value to indicate that the entry has yet to be filled in. When the subproblem is first encountered as the recursive algorithm unfolds, its solution is computed and then stored in the table.\n\nEach subsequent encounter of this subproblem simply looks up the value stored in the table and returns it.7\n\nFootnote 7: This approach presupposes that you know the set of all possible subproblem parameters and that you have established the relationship between table positions and subproblems. Another, more general, approach is to memoize by using hashing with the subproblem parameters as keys.\n\nThe procedure Memoized-Matrix-Chain is a memoized version of the procedure Recursive-Matrix-Chain on page 389. Note where it resembles the memoized top-down method on page 369 for the rod-cutting problem.\n\nMemoized-Matrix-Chain(\\(p,n\\))\n\n```\n1 let \\(m[1:n,1:n]\\) be a new table\n2for\\(i=1\\)to\\(n\\)\n3for\\(j=i\\)to\\(n\\)\n4\\(m[i,j]=\\infty\\)\n5returnLookup-Chain(\\(m\\), \\(p,1,n\\))\n\nLookup-Chain(\\(m\\), \\(p,i,j\\))\n1if\\(m[i,j]<\\infty\\)return\\(m[i,j]\\)\n2if\\(i=j\\)\n3\\(m[i,j]=0\\)\n4elsefor\\(k=i\\)to\\(j-1\\)\n5\\(q=\\)Lookup-Chain(\\(m\\), \\(p,i,k\\)) \\(+\\)Lookup-Chain(\\(m\\), \\(p,k+1,j\\)) \\(+\\)\\(p_{i-1}p_{k}\\)\\(p_{j}\\)\n6if\\(q<m[i,j]\\)\n7\\(m[i,j]=q\\)\n8return\\(m[i,j]\\)\n```\n\nThe Memoized-Matrix-Chain procedure, like the bottom-up Matrix-Chain-Order procedure on page 378, maintains a table \\(m[1:n,1:n]\\) of computed values of \\(m[i,j]\\), the minimum number of scalar multiplications needed to compute the matrix \\(A_{i;j}\\). Each table entry initially contains the value \\(\\infty\\) to indicate that the entry has yet to be filled in. Upon calling Lookup-Chain(\\(m\\), \\(p,i,j\\)), if line 1 finds that \\(m[i,j]<\\infty\\), then the procedure simply returns the previously computed cost \\(m[i,j]\\) in line 2. Otherwise, the cost is computed as in Recursive-Matrix-Chain, stored in \\(m[i,j]\\), and returned. Thus, Lookup-Chain(\\(m\\), \\(p,i,j\\)) always returns the value of \\(m[i,j]\\), but it computes it only upon the first call of Lookup-Chain with these specific values of \\(i\\) and \\(j\\)Figure 14.7 illustrates how Memoized-Matrix-Chain saves time compared with Recursive-Matrix-Chain. Subtrees shaded blue represent values that are looked up rather than recomputed.\n\nLike the bottom-up procedure Matrix-Chain-Order, the memoized procedure Memoized-Matrix-Chain runs in \\(\\mathcal{O}(n^{3})\\) time. To begin with, line 4 of Memoized-Matrix-Chain executes \\(\\Theta(n^{2})\\) times, which dominates the running time outside of the call to Lookup-Chain in line 5. We can categorize the calls of Lookup-Chain into two types:\n\n1. calls in which \\(m[i,j]=\\infty\\), so that lines 3-9 execute, and\n2. calls in which \\(m[i,j]<\\infty\\), so that Lookup-Chain simply returns in line 2.\n\nThere are \\(\\Theta(n^{2})\\) calls of the first type, one per table entry. All calls of the second type are made as recursive calls by calls of the first type. Whenever a given call of Lookup-Chain makes recursive calls, it makes \\(\\mathcal{O}(n)\\) of them. Therefore, there are \\(\\mathcal{O}(n^{3})\\) calls of the second type in all. Each call of the second type takes \\(\\mathcal{O}(1)\\) time, and each call of the first type takes \\(\\mathcal{O}(n)\\) time plus the time spent in its recursive calls. The total time, therefore, is \\(\\mathcal{O}(n^{3})\\). Memoization thus turns an \\(\\Omega(2^{n})\\)-time algorithm into an \\(\\mathcal{O}(n^{3})\\)-time algorithm.\n\nWe have seen how to solve the matrix-chain multiplication problem by either a top-down, memoized dynamic-programming algorithm or a bottom-up dynamic-programming algorithm in \\(\\mathcal{O}(n^{3})\\) time. Both the bottom-up and memoized methods take advantage of the overlapping-subproblems property. There are only \\(\\Theta(n^{2})\\) distinct subproblems in total, and either of these methods computes the solution to each subproblem only once. Without memoization, the natural recursive algorithm runs in exponential time, since solved subproblems are repeatedly solved.\n\nIn general practice, if all subproblems must be solved at least once, a bottom-up dynamic-programming algorithm usually outperforms the corresponding top-down memoized algorithm by a constant factor, because the bottom-up algorithm has no overhead for recursion and less overhead for maintaining the table. Moreover, for some problems you can exploit the regular pattern of table accesses in the dynamic-programming algorithm to reduce time or space requirements even further. On the other hand, in certain situations, some of the subproblems in the subproblem space might not need to be solved at all. In that case, the memoized solution has the advantage of solving only those subproblems that are definitely required.\n\n## Exercises\n\n### 14.3-1\n\nWhich is a more efficient way to determine the optimal number of multiplications in a matrix-chain multiplication problem: enumerating all the ways of parenthesizing the product and computing the number of multiplications for each, or running Recursive-Matrix-Chain? Justify your answer.\n\n##### 14.3-2\n\nDraw the recursion tree for the Merge-Sort procedure from Section 2.3.1 on an array of 16 elements. Explain why memoization fails to speed up a good divide-and-conquer algorithm such as Merge-Sort.\n\n##### 14.3-3\n\nConsider the antithetical variant of the matrix-chain multiplication problem where the goal is to parenthesize the sequence of matrices so as to maximize, rather than minimize, the number of scalar multiplications. Does this problem exhibit optimal substructure?\n\n##### 14.3-4\n\nAs stated, in dynamic programming, you first solve the subproblems and then choose which of them to use in an optimal solution to the problem. Professor Capulet claims that she does not always need to solve all the subproblems in order to find an optimal solution. She suggests that she can find an optimal solution to the matrix-chain multiplication problem by always choosing the matrix \\(A_{k}\\) at which to split the subproduct \\(A_{i}A_{i+1}\\cdots A_{j}\\) (by selecting \\(k\\) to minimize the quantity \\(p_{i-1}p_{k}p_{j}\\)) before solving the subproblems. Find an instance of the matrix-chain multiplication problem for which this greedy approach yields a suboptimal solution.\n\n##### 14.3-5\n\nSuppose that the rod-cutting problem of Section 14.1 also had a limit \\(l_{i}\\) on the number of pieces of length \\(i\\) allowed to be produced, for \\(i=1,2,\\ldots,n\\). Show that the optimal-substructure property described in Section 14.1 no longer holds.\n\n##### 14.4 Longest common subsequence\n\nBiological applications often need to compare the DNA of two (or more) different organisms. A strand of DNA consists of a string of molecules called _bases_, where the possible bases are adenine, cytosine, guanine, and thymine. Representing each of these bases by its initial letter, we can express a strand of DNA as a string over the 4-element set \\(\\{\\texttt{A},\\texttt{C},\\texttt{G},\\texttt{T}\\}\\). (See Section C.1 for the definition of a string.) For example, the DNA of one organism may be \\(S_{1}=\\texttt{ACCGGTCGAGTGGCGCGGAAGCCGACGA}\\), and the DNA of another organism may be \\(S_{2}=\\texttt{GTCGTTCCGAGATCCGTGTAAA}\\). One reason to com",
        "chapter": "Part IV Advanced Design and Analysis Techniques",
        "section": "14 Dynamic Programming",
        "subsection": "14.3 Elements of dynamic programming",
        "subsubsection": "N/A"
    },
    {
        "content": "ing the product and computing the number of multiplications for each, or running Recursive-Matrix-Chain? Justify your answer.\n\n##### 14.3-2\n\nDraw the recursion tree for the Merge-Sort procedure from Section 2.3.1 on an array of 16 elements. Explain why memoization fails to speed up a good divide-and-conquer algorithm such as Merge-Sort.\n\n##### 14.3-3\n\nConsider the antithetical variant of the matrix-chain multiplication problem where the goal is to parenthesize the sequence of matrices so as to maximize, rather than minimize, the number of scalar multiplications. Does this problem exhibit optimal substructure?\n\n##### 14.3-4\n\nAs stated, in dynamic programming, you first solve the subproblems and then choose which of them to use in an optimal solution to the problem. Professor Capulet claims that she does not always need to solve all the subproblems in order to find an optimal solution. She suggests that she can find an optimal solution to the matrix-chain multiplication problem by always choosing the matrix \\(A_{k}\\) at which to split the subproduct \\(A_{i}A_{i+1}\\cdots A_{j}\\) (by selecting \\(k\\) to minimize the quantity \\(p_{i-1}p_{k}p_{j}\\)) before solving the subproblems. Find an instance of the matrix-chain multiplication problem for which this greedy approach yields a suboptimal solution.\n\n##### 14.3-5\n\nSuppose that the rod-cutting problem of Section 14.1 also had a limit \\(l_{i}\\) on the number of pieces of length \\(i\\) allowed to be produced, for \\(i=1,2,\\ldots,n\\). Show that the optimal-substructure property described in Section 14.1 no longer holds.\n\n##### 14.4 Longest common subsequence\n\nBiological applications often need to compare the DNA of two (or more) different organisms. A strand of DNA consists of a string of molecules called _bases_, where the possible bases are adenine, cytosine, guanine, and thymine. Representing each of these bases by its initial letter, we can express a strand of DNA as a string over the 4-element set \\(\\{\\texttt{A},\\texttt{C},\\texttt{G},\\texttt{T}\\}\\). (See Section C.1 for the definition of a string.) For example, the DNA of one organism may be \\(S_{1}=\\texttt{ACCGGTCGAGTGGCGCGGAAGCCGACGA}\\), and the DNA of another organism may be \\(S_{2}=\\texttt{GTCGTTCCGAGATCCGTGTACGA}\\). One reason to compare two strands of DNA is to determine how \"similar\" the two strands are, as some measure of how closely related the two organisms are. We can, and do, define similarity in many different ways. For example, we can say that two DNA strands are similar if one is a substring of the other. (Chapter 32 explores algorithms to solve this problem.) In our example, neither \\(S_{1}\\) nor \\(S_{2}\\) is a substring of the other. Alternatively, we could say that two strands are similar if the number of changes needed to turn one into the other is small. (Problem 14-5 looks at this notion.) Yet another way to measure the similarity of strands \\(S_{1}\\) and \\(S_{2}\\) is by finding a third strand \\(S_{3}\\) in which the bases in \\(S_{3}\\) appear in each of \\(S_{1}\\) and \\(S_{2}\\). These bases must appear in the same order, but not necessarily consecutively. The longer the strand \\(S_{3}\\) we can find, the more similar \\(S_{1}\\) and \\(S_{2}\\) are. In our example, the longest strand \\(S_{3}\\) is \\(\\tt{GTCGTCCGGAAGCCGGCCGAA}\\).\n\nWe formalize this last notion of similarity as the longest-common-subsequence problem. A subsequence of a given sequence is just the given sequence with \\(0\\) or more elements left out. Formally, given a sequence \\(X=(x_{1},x_{2},\\ldots,x_{m})\\), another sequence \\(Z=\\langle z_{1},\\,z_{2},\\,\\ldots,\\,z_{k}\\rangle\\) is a _subsequence_ of \\(X\\) if there exists a strictly increasing sequence \\(\\langle i_{1},i_{2},\\ldots,i_{k}\\rangle\\) of indices of \\(X\\) such that for all \\(j=1,2,\\ldots,k\\), we have \\(x_{i_{j}}=z_{j}\\). For example, \\(Z=\\langle B,\\,C,\\,D,\\,B\\rangle\\) is a subsequence of \\(X=\\langle A,\\,B,\\,C,\\,B,\\,D,\\,A,\\,B\\rangle\\) with corresponding index sequence \\(\\langle 2,3,5,7\\rangle\\).\n\nGiven two sequences \\(X\\) and \\(Y\\), we say that a sequence \\(Z\\) is a _common subsequence_ of \\(X\\) and \\(Y\\) if \\(Z\\) is a subsequence of both \\(X\\) and \\(Y\\). For example, if \\(X=\\langle A,\\,B,\\,C,\\,B,\\,D,\\,A,\\,B\\rangle\\) and \\(Y=\\langle B,\\,D,\\,C,\\,A,\\,B,\\,A\\rangle\\), the sequence \\(\\langle B,\\,C,\\,A\\rangle\\) is a common subsequence of both \\(X\\) and \\(Y\\). The sequence \\(\\langle B,\\,C,\\,A\\rangle\\) is not a _longest_ common subsequence (\\(\\boldsymbol{LCS}\\)) of \\(X\\) and \\(Y\\), however, since it has length \\(3\\) and the sequence \\(\\langle B,\\,C,\\,B,\\,A\\rangle\\), which is also common to both sequences \\(X\\) and \\(Y\\), has length \\(4\\). The sequence \\(\\langle B,\\,C,\\,B,\\,A\\rangle\\) is an LCS of \\(X\\) and \\(Y\\), as is the sequence \\(\\langle B,\\,D,\\,A,\\,B\\rangle\\), since \\(X\\) and \\(Y\\) have no common subsequence of length \\(5\\) or greater.\n\nIn the _longest-common-subsequence problem_, the input is two sequences \\(X=\\langle x_{1},\\,x_{2},\\,\\ldots,\\,x_{m}\\rangle\\) and \\(Y=\\langle y_{1},\\,y_{2},\\,\\ldots,\\,y_{n}\\rangle\\), and the goal is to find a maximum-length common subsequence of \\(X\\) and \\(Y\\). This section shows how to efficiently solve the LCS problem using dynamic programming.\n\n#### Step 1: Characterizing a longest common subsequence\n\nYou can solve the LCS problem with a brute-force approach: enumerate all subsequences of \\(X\\) and check each subsequence to see whether it is also a subsequence of \\(Y\\), keeping track of the longest subsequence you find. Each subsequence of \\(X\\) corresponds to a subset of the indices \\(\\{1,2,\\ldots,m\\}\\) of \\(X\\). Because \\(X\\) has \\(2^{m}\\) subsequences, this approach requires exponential time, making it impractical for long sequences.\n\nThe LCS problem has an optimal-substructure property, however, as the following theorem shows. As we'll see, the natural classes of subproblems correspond to pairs of \"prefixes\" of the two input sequences. To be precise, given a sequence \\(X=\\langle x_{1},x_{2},\\ldots,x_{m}\\rangle\\), we define the \\(i\\)th _prefix_ of \\(X\\), for \\(i=0,1,\\ldots,m\\), as \\(X_{i}=\\langle x_{1},\\,x_{2},\\,\\ldots,\\,x_{i}\\rangle\\). For example, if \\(X=\\langle A,\\,B,\\,C,\\,B,\\,D,\\,A,\\,B\\rangle\\), then \\(X_{4}=\\langle A,\\,B,\\,C,\\,B\\rangle\\) and \\(X_{0}\\) is the empty sequence.\n\n_Theorem 14.1 (Optimal substructure of an LCS)_\n\nLet \\(X=\\langle x_{1},\\,x_{2},\\,\\ldots,x_{m}\\rangle\\) and \\(Y=\\langle y_{1},\\,y_{2},\\,\\ldots,\\,y_{n}\\rangle\\) be sequences, and let \\(Z=\\langle z_{1},z_{2},\\ldots,z_{k}\\rangle\\) be any LCS of \\(X\\) and \\(Y\\).\n\n1. If \\(x_{m}=y_{n}\\), then \\(z_{k}=x_{m}=y_{n}\\) and \\(Z_{k-1}\\) is an LCS of \\(X_{m-1}\\) and \\(Y_{n-1}\\).\n2. If \\(x_{m}\\neq y_{n}\\) and \\(z_{k}\\neq x_{m}\\), then \\(Z\\) is an LCS of \\(X_{m-1}\\) and \\(Y\\).\n3. If \\(x_{m}\\neq y_{n}\\) and \\(z_{k}\\neq y_{n}\\), then \\(Z\\) is an LCS of \\(X\\) and \\(Y_{n-1}\\).\n\n_Proof_ (1) If \\(z_{k}\\neq x_{m}\\), then we could append \\(x_{m}=y_{n}\\) to \\(Z\\) to obtain a common subsequence of \\(X\\) and \\(Y\\) of length \\(k+1\\), contradicting the supposition that \\(Z\\) is a _longest_ common subsequence of \\(X\\) and \\(Y\\). Thus, we must have \\(z_{k}=x_{m}=y_{n}\\). Now, the prefix \\(Z_{k-1}\\) is a length-\\((k-1)\\) common subsequence of \\(X_{m-1}\\) and \\(Y_{n-1}\\). We wish to show that it is an LCS. Suppose for the purpose of contradiction that there exists a common subsequence \\(W\\) of \\(X_{m-1}\\) and \\(Y_{n-1}\\) with length greater than \\(k-1\\). Then, appending \\(x_{m}=y_{n}\\) to \\(W\\) produces a common subsequence of \\(X\\) and \\(Y\\) whose length is greater than \\(k\\), which is a contradiction.\n\n(2) If \\(z_{k}\\neq x_{m}\\), then \\(Z\\) is a common subsequence of \\(X_{m-1}\\) and \\(Y\\). If there were a common subsequence \\(W\\) of \\(X_{m-1}\\) and \\(Y\\) with length greater than \\(k\\), then \\(W\\) would also be a common subsequence of \\(X_{m}\\) and \\(Y\\), contradicting the assumption that \\(Z\\) is an LCS of \\(X\\) and \\(Y\\).\n\n(3) The proof is symmetric to (2).\n\nThe way that Theorem 14.1 characterizes longest common subsequences says that an LCS of two sequences contains within it an LCS of prefixes of the two sequences. Thus, the LCS problem has an optimal-substructure property. A recursive solution also has the overlapping-subproblems property, as we'll see in a moment.\n\n**Step 2: A recursive solution**\n\nTheorem 14.1 implies that you should examine either one or two subproblems when finding an LCS of \\(X=\\langle x_{1},\\,x_{2},\\,\\ldots,\\,x_{m}\\rangle\\) and \\(Y=\\langle y_{1},\\,y_{2},\\,\\ldots,\\,y_{n}\\rangle\\). If \\(x_{m}=y_{n}\\), you need to find an LCS of \\(X_{m-1}\\) and \\(Y_{n-1}\\). Appending \\(x_{m}=y_{n}\\) to this LCS yields an LCS of \\(X\\) and \\(Y\\). If \\(x_{m}\\neq y_{n}\\), then you have to solve two subproblems: finding an LCS of \\(X_{m-1}\\) and \\(Y\\) and finding an LCS of \\(X\\) and \\(Y_{n-1}\\)When \\(x_{i}=y_{j}\\), you can and should consider the subproblem of finding an LCS of \\(X_{i-1}\\) and \\(Y_{j-1}\\). Otherwise, you instead consider the two subproblems of finding an LCS of \\(X_{i}\\) and \\(Y_{j-1}\\) and of \\(X_{i-1}\\) and \\(Y_{j}\\). In the previous dynamic-programming algorithms we have examined--for rod cutting and matrix-chain multiplication--we didn't rule out any subproblems due to conditions in the problem. Finding an LCS is not the only dynamic-programming algorithm that rules out subproblems based on conditions in the problem. For example, the edit-distance problem (see Problem 14-5) has this characteristic.\n\n##### Step 3: Computing the length of an LCS\n\nBased on equation (14.9), you could write an exponential-time recursive algorithm to compute the length of an LCS of two sequences. Since the LCS problem has only \\(\\Theta(mn)\\) distinct subproblems (computing \\(c[i,j]\\) for \\(0\\leq i\\leq m\\) and \\(0\\leq j\\leq n\\)), dynamic programming can compute the solutions bottom up.\n\nThe procedure LCS-Length on the next page takes two sequences \\(X=\\langle x_{1}\\), \\(x_{2}\\),..., \\(x_{m}\\rangle\\) and \\(Y=\\langle y_{1}\\), \\(y_{2}\\),..., \\(y_{n}\\rangle\\) as inputs, along with their lengths. It stores the \\(c[i,j]\\) values in a table \\(c[0:m,0:n]\\), and it computes the entries in _row-major_ order. That is, the procedure fills in the first row of \\(c\\) from left to right, then the second row, and so on. The procedure also maintains the table \\(b[1:m,1:n]\\) to help in constructing an optimal solution. Intuitively, \\(b[i,j]\\) points to the table entry corresponding to the optimal subproblem solution chosen when computing \\(c[i,j]\\). The procedure returns the \\(b\\) and \\(c\\) tables, where \\(c[m,n]\\) contains the length of an LCS of \\(X\\) and \\(Y\\). Figure 14.8 shows the tables produced by LCS-Length on the sequences \\(X=\\langle A,\\,B,\\,C,\\,B,\\,D,\\,A,\\,B\\rangle\\) and \\(Y=\\langle B,\\,D,\\,C,\\,A,\\,B,\\,A\\rangle\\). The running time of the procedure is \\(\\Theta(mn)\\), since each table entry takes \\(\\Theta(1)\\) time to compute.\n\nLCS-Length(\\(X,Y,m,n\\))\n1 let \\(b[1:m,1:n]\\) and \\(c[0:m,0:n]\\) be new tables\n2for\\(i=1\\)to\\(m\\)\n3\\(c[i,0]=0\\)\n4for\\(j=0\\)to\\(n\\)\n5\\(c[0,j]=0\\)\n6for\\(i=1\\)to\\(m\\)// compute table entries in row-major order\n7for\\(j=1\\)to\\(n\\)\n8if\\(x_{i}==y_{j}\\)\n9\\(c[i,j]=c[i-1,j-1]+1\\)\n10\\(b[i,j]=\\)\"\\(\\times\\)\"\n11elseif\\(c[i-1,j]\\geq c[i,j-1]\\)\n12\\(c[i,j]=c[i-1,j]\\)\n13\\(b[i,j]=\\)\"\\(\\uparrow\\)\"\n14else\\(c[i,j]=c[i,j-1]\\)\n15\\(b[i,j]=\\)\"\\(\\leftarrow\\)\"\n16return\\(c\\) and \\(b\\)\n\nPrint-LCS(\\(b,X,i,j\\))\n1if\\(i==0\\) or \\(j==0\\)\n2return// the LCS has length 0\n3if\\(b[i,j]==\\)\"\\(\\times\\)\"\n4Print-LCS(\\(b,X,i-1,j-1\\)) print \\(x_{i}\\)// same as \\(y_{j}\\)\n5elseif\\(b[i,j]==\\)\"\\(\\uparrow\\)\"\n7Print-LCS(\\(b,X,i-1,j\\))\n8elsePrint-LCS(\\(b,X,i,j-1\\))\n\n### Step 4: Constructing an LCS\n\nWith the \\(b\\) table returned by LCS-Length, you can quickly construct an LCS of \\(X=\\langle x_{1},x_{2},\\ldots,x_{m}\\rangle\\) and \\(Y=\\langle y_{1},y_{2},\\ldots,y_{n}\\rangle\\). Begin at \\(b[m,n]\\) and trace through the table by following the arrows. Each \"\\(\\times\\)\" encountered in an entry \\(b[i,j]\\) implies that \\(x_{i}=y_{j}\\) is an element of the LCS that LCS-Length found. This method gives you the elements of this LCS in reverse order. The recursive procedure Print-LCS prints out an LCS of \\(X\\) and \\(Y\\) in the proper, forward order.\n\nThe initial call is Print-LCS\\((b,X,m,n)\\). For the \\(b\\) table in Figure 14.8, this procedure prints \\(BCBA\\). The procedure takes \\(O(m+n)\\) time, since it decrements at least one of \\(i\\) and \\(j\\) in each recursive call.\n\n##### Improving the code\n\nOnce you have developed an algorithm, you will often find that you can improve on the time or space it uses. Some changes can simplify the code and improve constant factors but otherwise yield no asymptotic improvement in performance. Others can yield substantial asymptotic savings in time and space.\n\nIn the LCS algorithm, for example, you can eliminate the \\(b\\) table altogether. Each \\(c[i,j]\\) entry depends on only three other \\(c\\) table entries: \\(c[i-1,j-1]\\), \\(c[i-1,j]\\), and \\(c[i,j-1]\\). Given the value of \\(c[i,j]\\), you can determine in \\(O(1)\\) time which of these three values was used to compute \\(c[i,j]\\), without inspecting table \\(b\\). Thus, you can reconstruct an LCS in \\(O(m+n)\\) time using a procedure similar to Print-LCS. (Exercise 14.4-2 asks you to give the pseudocode.) Although this method saves \\(\\Theta(mn)\\) space, the auxiliary space requirement for computing\n\nFigure 14.8: The \\(c\\) and \\(b\\) tables computed by LCS-Length on the sequences \\(X=\\langle A,\\,B,\\,C,\\,B,\\,D,\\,A,\\,B\\rangle\\) and \\(Y=\\langle B,\\,D,\\,C,\\,A,\\,B,\\,A\\rangle\\). The square in row \\(i\\) and column \\(j\\) contains the value of \\(c[i,j]\\) and the appropriate arrow for the value of \\(b[i,j]\\). The entry \\(4\\) in \\(c[7,6]\\)\u2014the lower right-hand corner of the table\u2014is the length of an LCS \\(\\langle B,\\,C,\\,B,\\,A\\rangle\\) of \\(X\\) and \\(Y\\). For \\(i\\), \\(j>0\\), entry \\(c[i,j]\\) depends only on whether \\(x_{i}=y_{j}\\) and the values in entries \\(c[i-1,j]\\), \\(c[i,j-1]\\), and \\(c[i-1,j-1]\\), which are computed before \\(c[i,j]\\). To reconstruct the elements of an LCS, follow the \\(b[i,j]\\) arrows from the lower right-hand corner, as shown by the sequence shaded blue. Each \u201c\\(\\times\\)\u201d on the shaded-blue sequence corresponds to an entry (highlighted) for which \\(x_{i}=y_{j}\\) is a member of an LCS.\n\nan LCS does not asymptotically decrease, since the \\(c\\) table takes \\(\\Theta(mn)\\) space anyway.\n\nYou can, however, reduce the asymptotic space requirements for LCS-Length, since it needs only two rows of table \\(c\\) at a time: the row being computed and the previous row. (In fact, as Exercise 14.4-4 asks you to show, you can use only slightly more than the space for one row of \\(c\\) to compute the length of an LCS.) This improvement works if you need only the length of an LCS. If you need to reconstruct the elements of an LCS, the smaller table does not keep enough information to retrace the algorithm's steps in \\(O(m+n)\\) time.\n\n**Exercises**\n\n_14.4-1_\n\nDetermine an LCS of \\(\\langle 1,0,0,1,0,1,0,1\\rangle\\) and \\(\\langle 0,1,0,1,1,0,1,1,0\\rangle\\).\n\n_14.4-2_\n\nGive pseudocode to reconstruct an LCS from the completed \\(c\\) table and the original sequences \\(X=\\langle x_{1},\\,x_{2},\\,\\ldots,\\,x_{m}\\rangle\\) and \\(Y=\\langle y_{1},\\,y_{2},\\,\\ldots,\\,y_{n}\\rangle\\) in \\(O(m+n)\\) time, without using the \\(b\\) table.\n\n_14.4-3_\n\nGive a memoized version of LCS-Length that runs in \\(O(mn)\\) time.\n\n_14.4-4_\n\nShow how to compute the length of an LCS using only \\(2\\cdot\\min\\,\\{m,n\\}\\) entries in the \\(c\\) table plus \\(O(1)\\) additional space. Then show how to do the same thing, but using \\(\\min\\,\\{m,n\\}\\) entries plus \\(O(1)\\) additional space.\n\n_14.4-5_\n\nGive an \\(O(n^{2})\\)-time algorithm to find the longest monotonically increasing subsequence of a sequence of \\(n\\) numbers.\n\n_14.4-6_\n\nGive an \\(O(n\\lg n)\\)-time algorithm to find the longest monotonically increasing subsequence of a sequence of \\(n\\) numbers. (_Hint:_ The last element of a candidate subsequence of length \\(i\\) is at least as large as the last element of a candidate subsequence of length \\(i-1\\). Maintain candidate subsequences by linking them through the input sequence.)\n\n### 14.5 Optimal binary search trees\n\nSuppose that you are designing a program to translate text from English to Latvian. For each occurrence of each English word in the text, you need to look up its Latvian equivalent. You can perform these lookup operations by building a binary search tree with \\(n\\) English words as keys and their Latvian equivalents as satellite data. Because you will search the tree for each individual word in the text, you want the total time spent searching to be as low as possible. You can ensure an \\(\\,O(\\lg n)\\) search time per occurrence by using a red-black tree or any other balanced binary search tree. Words appear with different frequencies, however, and a frequently used word such as _the_ can end up appearing far from the root while a rarely used word such as _naumachia_ appears near the root. Such an organization would slow down the translation, since the number of nodes visited when searching for a key in a binary search tree equals 1 plus the depth of the node containing the key. You want words that occur frequently in the text to be placed nearer the root.8 Moreover, some words in the text might have no Latvian translation,9 and such words would not appear in the binary search tree at all. How can you organize a binary search tree so as to minimize the number of nodes visited in all searches, given that you know how often each word occurs?\n\nFootnote 8: If the subject of the text is ancient Rome, you might want _naumachia_ to appear near the root.\n\nFootnote 9: Yes, _naumachia_ has a Latvian counterpart: _nomacija_.\n\nWhat you need is an _optimal binary search tree_. Formally, given a sequence \\(K=\\langle k_{1},\\,k_{2},\\,\\ldots,\\,k_{n}\\rangle\\) of \\(n\\) distinct keys such that \\(k_{1}<k_{2}<\\cdots<k_{n}\\), build a binary search tree containing them. For each key \\(k_{i}\\), you are given the probability \\(p_{i}\\) that any given search is for key \\(k_{i}\\). Since some searches may be for values not in \\(K\\), you also have \\(n+1\\) \"dummy\" keys \\(d_{0},\\,d_{1},\\,d_{2},\\ldots,\\,d_{n}\\) representing those values. In particular, \\(d_{0}\\) represents all values less than \\(k_{1}\\), \\(d_{n}\\) represents all values greater than \\(k_{n}\\), and for \\(i=1,2,\\ldots,n-1\\), the dummy key \\(d_{i}\\) represents all values between \\(k_{i}\\) and \\(k_{i+1}\\). For each dummy key \\(d_{i}\\), you have the probability \\(q_{i}\\) that a search corresponds to \\(d_{i}\\). Figure 14.9 shows two binary search trees for a set of \\(n=5\\) keys. Each key \\(k_{i}\\) is an internal node, and each dummy key \\(d_{i}\\) is a leaf. Since every search is either successful (finding some key \\(k_{i}\\)) or unsuccessful (finding some dummy key \\(d_{i}\\)), we have\n\n\\[\\sum_{i=1}^{n}p_{i}\\,+\\,\\sum_{i=0}^{n}q_{i}\\,=\\,1. \\tag{14.10}\\]",
        "chapter": "Part IV Advanced Design and Analysis Techniques",
        "section": "14 Dynamic Programming",
        "subsection": "14.4 Longest common subsequence",
        "subsubsection": "N/A"
    },
    {
        "content": "### 14.5 Optimal binary search trees\n\nSuppose that you are designing a program to translate text from English to Latvian. For each occurrence of each English word in the text, you need to look up its Latvian equivalent. You can perform these lookup operations by building a binary search tree with \\(n\\) English words as keys and their Latvian equivalents as satellite data. Because you will search the tree for each individual word in the text, you want the total time spent searching to be as low as possible. You can ensure an \\(\\,O(\\lg n)\\) search time per occurrence by using a red-black tree or any other balanced binary search tree. Words appear with different frequencies, however, and a frequently used word such as _the_ can end up appearing far from the root while a rarely used word such as _naumachia_ appears near the root. Such an organization would slow down the translation, since the number of nodes visited when searching for a key in a binary search tree equals 1 plus the depth of the node containing the key. You want words that occur frequently in the text to be placed nearer the root.8 Moreover, some words in the text might have no Latvian translation,9 and such words would not appear in the binary search tree at all. How can you organize a binary search tree so as to minimize the number of nodes visited in all searches, given that you know how often each word occurs?\n\nFootnote 8: If the subject of the text is ancient Rome, you might want _naumachia_ to appear near the root.\n\nFootnote 9: Yes, _naumachia_ has a Latvian counterpart: _nomacija_.\n\nWhat you need is an _optimal binary search tree_. Formally, given a sequence \\(K=\\langle k_{1},\\,k_{2},\\,\\ldots,\\,k_{n}\\rangle\\) of \\(n\\) distinct keys such that \\(k_{1}<k_{2}<\\cdots<k_{n}\\), build a binary search tree containing them. For each key \\(k_{i}\\), you are given the probability \\(p_{i}\\) that any given search is for key \\(k_{i}\\). Since some searches may be for values not in \\(K\\), you also have \\(n+1\\) \"dummy\" keys \\(d_{0},\\,d_{1},\\,d_{2},\\,\\ldots,\\,d_{n}\\) representing those values. In particular, \\(d_{0}\\) represents all values less than \\(k_{1}\\), \\(d_{n}\\) represents all values greater than \\(k_{n}\\), and for \\(i=1,2,\\ldots,n-1\\), the dummy key \\(d_{i}\\) represents all values between \\(k_{i}\\) and \\(k_{i+1}\\). For each dummy key \\(d_{i}\\), you have the probability \\(q_{i}\\) that a search corresponds to \\(d_{i}\\). Figure 14.9 shows two binary search trees for a set of \\(n=5\\) keys. Each key \\(k_{i}\\) is an internal node, and each dummy key \\(d_{i}\\) is a leaf. Since every search is either successful (finding some key \\(k_{i}\\)) or unsuccessful (finding some dummy key \\(d_{i}\\)), we have\n\n\\[\\sum_{i=1}^{n}p_{i}\\,+\\,\\sum_{i=0}^{n}q_{i}\\,=\\,1. \\tag{14.10}\\]\n\n#### Optimal binary search trees\n\nKnowing the probabilities of searches for each key and each dummy key allows us to determine the expected cost of a search in a given binary search tree \\(T\\). Let us assume that the actual cost of a search equals the number of nodes examined, which is the depth of the node found by the search in \\(T\\), plus 1. Then the expected cost of a search in \\(T\\) is\n\n\\[\\mathrm{E}\\left[\\mathrm{search\\ cost\\ in\\ }T\\right] = \\sum_{i=1}^{n}(\\mathrm{depth}_{T}(k_{i})+1)\\cdot p_{i}\\,+\\,\\sum_{ i=0}^{n}(\\mathrm{depth}_{T}(d_{i})+1)\\cdot q_{i} \\tag{14.11}\\] \\[= 1+\\sum_{i=1}^{n}\\mathrm{depth}_{T}(k_{i})\\cdot p_{i}\\,+\\,\\sum_{ j=0}^{n}\\mathrm{depth}_{T}(d_{i})\\cdot q_{i}\\,\\]\n\nFigure 14.9: Two binary search trees for a set of \\(n=5\\) keys with the following probabilities:\n\n**(a)** A binary search tree with expected search cost 2.80. **(b)** A binary search tree with expected search cost 2.75. This tree is optimal.\n\nwhere \\(\\mbox{depth}_{T}\\) denotes a node's depth in the tree \\(T\\). The last equation follows from equation (14.10). Figure 14.9 shows how to calculate the expected search cost node by node.\n\nFor a given set of probabilities, your goal is to construct a binary search tree whose expected search cost is smallest. We call such a tree an _optimal binary search tree_. Figure 14.9(a) shows one binary search tree, with expected cost \\(2.80\\), for the probabilities given in the figure caption. Part (b) of the figure displays an optimal binary search tree, with expected cost \\(2.75\\). This example demonstrates that an optimal binary search tree is not necessarily a tree whose overall height is smallest. Nor does an optimal binary search tree always have the key with the greatest probability at the root. Here, key \\(k_{5}\\) has the greatest search probability of any key, yet the root of the optimal binary search tree shown is \\(k_{2}\\). (The lowest expected cost of any binary search tree with \\(k_{5}\\) at the root is \\(2.85\\).)\n\nAs with matrix-chain multiplication, exhaustive checking of all possibilities fails to yield an efficient algorithm. You can label the nodes of any \\(n\\)-node binary tree with the keys \\(k_{1},k_{2},\\ldots,k_{n}\\) to construct a binary search tree, and then add in the dummy keys as leaves. In Problem 12-4 on page 329, we saw that the number of binary trees with \\(n\\) nodes is \\(\\Omega(4^{n}/n^{3/2})\\). Thus you would need to examine an exponential number of binary search trees to perform an exhaustive search. We'll see how to solve this problem more efficiently with dynamic programming.\n\n##### Step 1: The structure of an optimal binary search tree\n\nTo characterize the optimal substructure of optimal binary search trees, we start with an observation about subtrees. Consider any subtree of a binary search tree. It must contain keys in a contiguous range \\(k_{i},\\ldots,k_{j}\\), for some \\(1\\leq i\\leq j\\leq n\\). In addition, a subtree that contains keys \\(k_{i},\\ldots,k_{j}\\) must also have as its leaves the dummy keys \\(d_{i-1},\\ldots,d_{j}\\).\n\nNow we can state the optimal substructure: if an optimal binary search tree \\(T\\) has a subtree \\(T^{\\prime}\\) containing keys \\(k_{i},\\ldots,k_{j}\\), then this subtree \\(T^{\\prime}\\) must be optimal as well for the subproblem with keys \\(k_{i},\\ldots,k_{j}\\) and dummy keys \\(d_{i-1},\\ldots,d_{j}\\). The usual cut-and-paste argument applies. If there were a subtree \\(T^{\\prime\\prime}\\) whose expected cost is lower than that of \\(T^{\\prime}\\), then cutting \\(T^{\\prime}\\) out of \\(T\\) and pasting in \\(T^{\\prime\\prime}\\) would result in a binary search tree of lower expected cost than \\(T\\), thus contradicting the optimality of \\(T\\).\n\nWith the optimal substructure in hand, here is how to construct an optimal solution to the problem from optimal solutions to subproblems. Given keys \\(k_{i},\\ldots,k_{j}\\), one of these keys, say \\(k_{r}\\) (\\(i\\leq r\\leq j\\)), is the root of an optimal subtree containing these keys. The left subtree of the root \\(k_{r}\\) contains the keys \\(k_{i},\\ldots,k_{r-1}\\) (and dummy keys \\(d_{i-1},\\ldots,d_{r-1}\\)), and the right subtree contains the keys \\(k_{r+1},\\ldots,k_{j}\\) (and dummy keys \\(d_{r},\\ldots,d_{j}\\)). As long as you examine all candidate roots \\(k_{r}\\)where \\(i\\leq r\\leq j\\), and you determine all optimal binary search trees containing \\(k_{i},\\ldots,k_{r-1}\\) and those containing \\(k_{r+1},\\ldots,k_{j}\\), you are guaranteed to find an optimal binary search tree.\n\nThere is one technical detail worth understanding about \"empty\" subtrees. Suppose that in a subtree with keys \\(k_{i},\\ldots,k_{j}\\), you select \\(k_{i}\\) as the root. By the above argument, \\(k_{i}\\)'s left subtree contains the keys \\(k_{i},\\ldots,k_{i-1}\\): no keys at all. Bear in mind, however, that subtrees also contain dummy keys. We adopt the convention that a subtree containing keys \\(k_{i},\\ldots,k_{i-1}\\) has no actual keys but does contain the single dummy key \\(d_{i-1}\\). Symmetrically, if you select \\(k_{j}\\) as the root, then \\(k_{j}\\)'s right subtree contains the keys \\(k_{j+1},\\ldots,k_{j}\\). This right subtree contains no actual keys, but it does contain the dummy key \\(d_{j}\\).\n\n##### Step 2: A recursive solution\n\nTo define the value of an optimal solution recursively, the subproblem domain is finding an optimal binary search tree containing the keys \\(k_{i},\\ldots,k_{j}\\), where \\(i\\geq 1\\), \\(j\\leq n\\), and \\(j\\geq i-1\\). (When \\(j=i-1\\), there is just the dummy key \\(d_{i-1}\\), but no actual keys.) Let \\(e[i,j]\\) denote the expected cost of searching an optimal binary search tree containing the keys \\(k_{i},\\ldots,k_{j}\\). Your goal is to compute \\(e[1,n]\\), the expected cost of searching an optimal binary search tree for all the actual and dummy keys.\n\nThe easy case occurs when \\(j=i-1\\). Then the subproblem consists of just the dummy key \\(d_{i-1}\\). The expected search cost is \\(e[i,i-1]=q_{i-1}\\).\n\nWhen \\(j\\geq i\\), you need to select a root \\(k_{r}\\) from among \\(k_{i},\\ldots,k_{j}\\) and then make an optimal binary search tree with keys \\(k_{i},\\ldots,k_{r-1}\\) as its left subtree and an optimal binary search tree with keys \\(k_{r+1},\\ldots,k_{j}\\) as its right subtree. What happens to the expected search cost of a subtree when it becomes a subtree of a node? The depth of each node in the subtree increases by 1. By equation (14.11), the expected search cost of this subtree increases by the sum of all the probabilities in the subtree. For a subtree with keys \\(k_{i},\\ldots,k_{j}\\), denote this sum of probabilities as\n\n\\[w(i,j)=\\sum_{l=i}^{j}p_{l}+\\sum_{l=i-1}^{j}q_{l}. \\tag{14.12}\\]\n\nThus, if \\(k_{r}\\) is the root of an optimal subtree containing keys \\(k_{i},\\ldots,k_{j}\\), we have\n\n\\[e[i,j]=p_{r}+(e[i,r-1]+w(i,r-1))+(e[r+1,j]+w(r+1,j))\\.\\]\n\nNoting that\n\n\\[w(i,j)=w(i,r-1)+p_{r}+w(r+1,j)\\,\\]\n\nwe rewrite \\(e[i,j]\\) as \\[e[i,j]=e[i,r-1]+e[r+1,j]+w(i,j). \\tag{14.13}\\]\n\nThe recursive equation (14.13) assumes that you know which node \\(k_{r}\\) to use as the root. Of course, you choose the root that gives the lowest expected search cost, giving the final recursive formulation:\n\n\\[e[i,j]=\\left\\{\\begin{array}{ll}q_{i-1}&\\mbox{if $j\\,=\\,i-1$}\\,\\\\ \\min\\left\\{e[i,r-1]+e[r+1,j]+w(i,j):i\\,\\leq r\\,\\leq j\\right\\}&\\mbox{if $i\\,\\leq j$ }\\.\\end{array}\\right. \\tag{14.14}\\]\n\nThe \\(e[i,j]\\) values give the expected search costs in optimal binary search trees. To help keep track of the structure of optimal binary search trees, define \\(\\mbox{\\it root}[i,j]\\), for \\(1\\leq i\\,\\leq j\\,\\leq n\\), to be the index \\(r\\) for which \\(k_{r}\\) is the root of an optimal binary search tree containing keys \\(k_{i},\\ldots,k_{j}\\). Although we'll see how to compute the values of \\(\\mbox{\\it root}[i,j]\\), the construction of an optimal binary search tree from these values is left as Exercise 14.5-1.\n\n##### Step 3: Computing the expected search cost of an optimal binary search tree\n\nAt this point, you may have noticed some similarities between our characterizations of optimal binary search trees and matrix-chain multiplication. For both problem domains, the subproblems consist of contiguous index subranges. A direct, recursive implementation of equation (14.14) would be just as inefficient as a direct, recursive matrix-chain multiplication algorithm. Instead, you can store the \\(e[i,j]\\) values in a table \\(e[1:n+1,0:n]\\). The first index needs to run to \\(n+1\\) rather than \\(n\\) because in order to have a subtree containing only the dummy key \\(d_{n}\\), you need to compute and store \\(e[n+1,n]\\). The second index needs to start from \\(0\\) because in order to have a subtree containing only the dummy key \\(d_{0}\\), you need to compute and store \\(e[1,0]\\). Only the entries \\(e[i,j]\\) for which \\(j\\,\\geq i-1\\) are filled in. The table \\(\\mbox{\\it root}[i,j]\\) records the root of the subtree containing keys \\(k_{i},\\ldots,k_{j}\\) and uses only the entries for which \\(1\\,\\leq i\\,\\leq j\\,\\leq n\\).\n\nOne other table makes the dynamic-programming algorithm a little faster. Instead of computing the value of \\(w(i,j)\\) from scratch every time you compute \\(e[i,j]\\), which would take \\(\\Theta(j-i)\\) additions, store these values in a table \\(w[1:n+1,0:n]\\). For the base case, compute \\(w[i,i-1]=q_{i-1}\\) for \\(1\\leq i\\,\\leq n+1\\). For \\(j\\,\\geq i\\), compute\n\n\\[w[i,j]=w[i,j-1]+p_{j}+q_{j}. \\tag{14.15}\\]\n\nThus, you can compute the \\(\\Theta(n^{2})\\) values of \\(w[i,j]\\) in \\(\\Theta(1)\\) time each.\n\nThe Optimal-BST procedure on the next page takes as inputs the probabilities \\(p_{1},\\ldots,p_{n}\\) and \\(q_{0},\\ldots,q_{n}\\) and the size \\(n\\), and it returns the tables \\(e\\) and \\(\\mbox{\\it root}\\). From the description above and the similarity to the Matrix-Chain-Order procedure in Section 14.2, you should find the operation of this procedure to be fairly straightforward. The **for** loop of lines 2-4 initializes the values of \\(e[i,i-1]\\) and \\(w[i,i-1]\\). Then the **for** loop of lines 5-14 uses the recurrences (14.14) and (14.15) to compute \\(e[i,j]\\) and \\(w[i,j]\\) for all \\(1\\leq i\\leq j\\leq n\\). In the first iteration, when \\(l=1\\), the loop computes \\(e[i,i]\\) and \\(w[i,i]\\) for \\(i=1,2,\\ldots,n\\). The second iteration, with \\(l=2\\), computes \\(e[i,i+1]\\) and \\(w[i,i+1]\\) for \\(i=1,2,\\ldots,n-1\\), and so on. The innermost **for** loop, in lines 10-14, tries each candidate index \\(r\\) to determine which key \\(k_{r}\\) to use as the root of an optimal binary search tree containing keys \\(k_{i},\\ldots,k_{j}\\). This **for** loop saves the current value of the index \\(r\\) in \\(root[i,j]\\) whenever it finds a better key to use as the root.\n\nOptimal-BST(\\(p,q,n\\))\n\n let \\(e[1:n+1,0:n]\\), \\(w[1:n+1,0:n]\\),\n\n and \\(root[1:n,1:n]\\) be new tables\n\n for \\(i=1\\) to \\(n+1\\)  // base cases\n\n \\(e[i,i-1]=q_{i-1}\\)  // equation (14.14)\n\n \\(w[i,i-1]=q_{i-1}\\)\n\n for \\(l=1\\) to \\(n\\)\n\n for \\(i=1\\) to \\(n-l+1\\)\n\n \\(j=i+l-1\\)\n\n \\(e[i,j]=\\infty\\)\n\n \\(w[i,j]=w[i,j-1]+p_{j}+q_{j}\\)  // equation (14.15)\n\n for \\(r=i\\) to \\(j\\)  // try all possible roots \\(r\\)\n\n \\(t=e[i,r-1]+e[r+1,j]+w[i,j]\\)  // equation (14.14)\n\n if \\(t<e[i,j]\\)  // new minimum?\n\n \\(e[i,j]=t\\)\n\n \\(root[i,j]=r\\)\n\n return \\(e\\) and \\(root\\)\n\nFigure 14.10 shows the tables \\(e[i,j]\\), \\(w[i,j]\\), and \\(root[i,j]\\) computed by the procedure Optimal-BST on the key distribution shown in Figure 14.9. As in the matrix-chain multiplication example of Figure 14.5, the tables are rotated to make the diagonals run horizontally. Optimal-BST computes the rows from bottom to top and from left to right within each row.\n\nThe Optimal-BST procedure takes \\(\\Theta(n^{3})\\) time, just like Matrix-Chain-Order. Its running time is \\(O(n^{3})\\), since its **for** loops are nested three deep and each loop index takes on at most \\(n\\) values. The loop indices in Optimal-BST do not have exactly the same bounds as those in Matrix-Chain-Order, but they are within at most 1 in all directions. Thus, like Matrix-Chain-Order, the Optimal-BST procedure takes \\(\\Omega(n^{3})\\) time.\n\n#### Exercises\n\n##### 14.5-1\n\nWrite pseudocode for the procedure Construct-Optimal-BST\\((root,n)\\) which, given the table \\(root[1:n,1:n]\\), outputs the structure of an optimal binary search tree. For the example in Figure 14.10, your procedure should print out the structure\n\n\\(k_{2}\\) is the root\n\n[MISSING_PAGE_POST]\n\ncorresponding to the optimal binary search tree shown in Figure 14.9(b).\n\nFigure 14.10: The tables \\(e[i,j]\\), \\(w[i,j]\\), and \\(root[i,j]\\) computed by Optimal-BST on the key distribution shown in Figure 14.9. The tables are rotated so that the diagonals run horizontally.\n\n#### 14.5-2\n\nDetermine the cost and structure of an optimal binary search tree for a set of \\(n=7\\) keys with the following probabilities:\n\n\\begin{tabular}{l|c c c c c c c c} \\(i\\) & 0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 \\\\ \\hline \\(p_{i}\\) & & & 0.04 & 0.06 & 0.08 & 0.02 & 0.10 & 0.12 & 0.14 \\\\ \\(q_{i}\\) & 0.06 & 0.06 & 0.06 & 0.06 & 0.05 & 0.05 & 0.05 & 0.05 \\\\ \\end{tabular}\n\n#### 14.5-3\n\nSuppose that instead of maintaining the table \\(w[i,j]\\), you computed the value of \\(w(i,j)\\) directly from equation (14.12) in line 9 of Optimal-BST and used this computed value in line 11. How would this change affect the asymptotic running time of Optimal-BST?\n\n\\(\\bigstar\\) _14.5-4_\n\nKnuth [264] has shown that there are always roots of optimal subtrees such that \\(root[i,j-1]\\leq root[i,j]\\leq root[i+1,j]\\) for all \\(1\\leq i<j\\leq n\\). Use this fact to modify the Optimal-BST procedure to run in \\(\\Theta(n^{2})\\) time.\n\n## Problems\n\n### 14-1 Longest simple path in a directed acyclic graph\n\nYou are given a directed acyclic graph \\(G=(V,E)\\) with real-valued edge weights and two distinguished vertices \\(s\\) and \\(t\\). The _weight_ of a path is the sum of the weights of the edges in the path. Describe a dynamic-programming approach for finding a longest weighted simple path from \\(s\\) to \\(t\\). What is the running time of your algorithm?\n\n### 14-2 Longest palindrome subsequence\n\nA _palindrome_ is a nonempty string over some alphabet that reads the same forward and backward. Examples of palindromes are all strings of length 1, civic, racecar, and aibohphobia (fear of palindromes).\n\nGive an efficient algorithm to find the longest palindrome that is a subsequence of a given input string. For example, given the input character, your algorithm should return carac. What is the running time of your algorithm?\n\n### 14-3 Bitonic euclidean traveling-salesperson problem\n\nIn the _euclidean traveling-salesperson problem_, you are given a set of \\(n\\) points in the plane, and your goal is to find the shortest closed tour that connects all \\(n\\) points.",
        "chapter": "Part IV Advanced Design and Analysis Techniques",
        "section": "14 Dynamic Programming",
        "subsection": "14.5 Optimal binary search trees",
        "subsubsection": "N/A"
    },
    {
        "content": "#### 14.5-2\n\nDetermine the cost and structure of an optimal binary search tree for a set of \\(n=7\\) keys with the following probabilities:\n\n\\begin{tabular}{l|c c c c c c c c} \\(i\\) & 0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 \\\\ \\hline \\(p_{i}\\) & & & 0.04 & 0.06 & 0.08 & 0.02 & 0.10 & 0.12 & 0.14 \\\\ \\(q_{i}\\) & 0.06 & 0.06 & 0.06 & 0.06 & 0.05 & 0.05 & 0.05 & 0.05 \\\\ \\end{tabular}\n\n#### 14.5-3\n\nSuppose that instead of maintaining the table \\(w[i,j]\\), you computed the value of \\(w(i,j)\\) directly from equation (14.12) in line 9 of Optimal-BST and used this computed value in line 11. How would this change affect the asymptotic running time of Optimal-BST?\n\n\\(\\bigstar\\) _14.5-4_\n\nKnuth [264] has shown that there are always roots of optimal subtrees such that \\(root[i,j-1]\\leq root[i,j]\\leq root[i+1,j]\\) for all \\(1\\leq i<j\\leq n\\). Use this fact to modify the Optimal-BST procedure to run in \\(\\Theta(n^{2})\\) time.\n\n## Problems\n\n### 14-1 Longest simple path in a directed acyclic graph\n\nYou are given a directed acyclic graph \\(G=(V,E)\\) with real-valued edge weights and two distinguished vertices \\(s\\) and \\(t\\). The _weight_ of a path is the sum of the weights of the edges in the path. Describe a dynamic-programming approach for finding a longest weighted simple path from \\(s\\) to \\(t\\). What is the running time of your algorithm?\n\n### 14-2 Longest palindrome subsequence\n\nA _palindrome_ is a nonempty string over some alphabet that reads the same forward and backward. Examples of palindromes are all strings of length 1, civic, racecar, and aibohphobia (fear of palindromes).\n\nGive an efficient algorithm to find the longest palindrome that is a subsequence of a given input string. For example, given the input character, your algorithm should return carac. What is the running time of your algorithm?\n\n### 14-3 Bitonic euclidean traveling-salesperson problem\n\nIn the _euclidean traveling-salesperson problem_, you are given a set of \\(n\\) points in the plane, and your goal is to find the shortest closed tour that connects all \\(n\\) points.\n\nFigure 14.11(a) shows the solution to a 7-point problem. The general problem is NP-hard, and its solution is therefore believed to require more than polynomial time (see Chapter 34).\n\nJ. L. Bentley has suggested simplifying the problem by considering only _bitonic tours_, that is, tours that start at the leftmost point, go strictly rightward to the right-most point, and then go strictly leftward back to the starting point. Figure 14.11(b) shows the shortest bitonic tour of the same 7 points. In this case, a polynomial-time algorithm is possible.\n\nDescribe an \\(O(n^{2})\\)-time algorithm for determining an optimal bitonic tour. You may assume that no two points have the same \\(x\\)-coordinate and that all operations on real numbers take unit time. (_Hint:_ Scan left to right, maintaining optimal possibilities for the two parts of the tour.)\n\n#### Printing neatly\n\nConsider the problem of neatly printing a paragraph with a monospaced font (all characters having the same width). The input text is a sequence of \\(n\\) words of lengths \\(l_{1},l_{2},\\ldots,l_{n}\\), measured in characters, which are to be printed neatly on a number of lines that hold a maximum of \\(M\\) characters each. No word exceeds the line length, so that \\(l_{i}\\leq M\\) for \\(i=1,2,\\ldots,n\\). The criterion of \"neatness\" is as follows. If a given line contains words \\(i\\) through \\(j\\), where \\(i\\leq j\\), and exactly one space appears between words, then the number of extra space characters at the end of the line is \\(M-j+i-\\sum_{k=i}^{j}l_{k}\\), which must be nonnegative so that the words fit on the line. The goal is to minimize the sum, over all lines except the last, of the cubes of the numbers of extra space characters at the ends of lines. Give a dynamic-programming algorithm to print a paragraph of \\(n\\) words neatly. Analyze the running time and space requirements of your algorithm.\n\nFigure 14.11: Seven points in the plane, shown on a unit grid. **(a)** The shortest closed tour, with length approximately 24.89. This tour is not bitonic. **(b)** The shortest bitonic tour for the same set of points. Its length is approximately 25.58.\n\n### 14.5 Edit distance\n\nIn order to transform a source string of text \\(x[1:m]\\) to a target string \\(y[1:n]\\), you can perform various transformation operations. The goal is, given \\(x\\) and \\(y\\), to produce a series of transformations that changes \\(x\\) to \\(y\\). An array \\(z-\\)assumed to be large enough to hold all the characters it needs\\(-\\)holds the intermediate results. Initially, \\(z\\) is empty, and at termination, you should have \\(z[j]=y[j]\\) for \\(j=1,2,\\ldots,n\\). The procedure for solving this problem maintains current indices \\(i\\) into \\(x\\) and \\(j\\) into \\(z\\), and the operations are allowed to alter \\(z\\) and these indices. Initially, \\(i=j=1\\). Every character in \\(x\\) must be examined during the transformation, which means that at the end of the sequence of transformation operations, \\(i=m+1\\).\n\nYou may choose from among six transformation operations, each of which has a constant cost that depends on the operation:\n\n**Copy**: a character from \\(x\\) to \\(z\\) by setting \\(z[j]=x[i]\\) and then incrementing both \\(i\\) and \\(j\\). This operation examines \\(x[i]\\) and has cost \\(Q_{C}\\).\n**Replace**: a character from \\(x\\) by another character \\(c\\), by setting \\(z[j]=c\\), and then incrementing both \\(i\\) and \\(j\\). This operation examines \\(x[i]\\) and has cost \\(Q_{R}\\).\n**Delete**: a character from \\(x\\) by incrementing \\(i\\) but leaving \\(j\\) alone. This operation examines \\(x[i]\\) and has cost \\(Q_{D}\\).\n**Insert**: the character \\(c\\) into \\(z\\) by setting \\(z[j]=c\\) and then incrementing \\(j\\), but leaving \\(i\\) alone. This operation examines no characters of \\(x\\) and has cost \\(Q_{I}\\).\n**Twiddle**: (i.e., exchange) the next two characters by copying them from \\(x\\) to \\(z\\) but in the opposite order: setting \\(z[j]=x[i+1]\\) and \\(z[j+1]=x[i]\\), and then setting \\(i=i+2\\) and \\(j=j+2\\). This operation examines \\(x[i]\\) and \\(x[i+1]\\) and has cost \\(Q_{T}\\).\n**Kill**: the remainder of \\(x\\) by setting \\(i=m+1\\). This operation examines all characters in \\(x\\) that have not yet been examined. This operation, if performed, must be the final operation. It has cost \\(Q_{K}\\).\n\nFigure 14.12 gives one way to transform the source string algorithm to the target string altruistic. Several other sequences of transformation operations can transform algorithm to altruistic.\n\nAssume that \\(Q_{C}<Q_{D}+Q_{I}\\) and \\(Q_{R}<Q_{D}+Q_{I}\\), since otherwise, the copy and replace operations would not be used. The cost of a given sequence of transformation operations is the sum of the costs of the individual operations in the sequence. For the sequence above, the cost of transforming algorithm to altruistic is \\(3Q_{C}+Q_{R}+Q_{D}+4Q_{I}+Q_{T}+Q_{K}\\).\n\n**a.**: Given two sequences \\(x[1:m]\\) and \\(y[1:n]\\) and the costs of the transformation operations, the _edit distance_ from \\(x\\) to \\(y\\) is the cost of the least expensive operation sequence that transforms \\(x\\) to \\(y\\). Describe a dynamic-programming algorithm that finds the edit distance from \\(x[1:m]\\) to \\(y[1:n]\\) and prints an optimal operation sequence. Analyze the running time and space requirements of your algorithm.\n\nThe edit-distance problem generalizes the problem of aligning two DNA sequences (see, for example, Setubal and Meidanis [405, Section 3.2]). There are several methods for measuring the similarity of two DNA sequences by aligning them. One such method to align two sequences \\(x\\) and \\(y\\) consists of inserting spaces at arbitrary locations in the two sequences (including at either end) so that the resulting sequences \\(x^{\\prime}\\) and \\(y^{\\prime}\\) have the same length but do not have a space in the same position (i.e., for no position \\(j\\) are both \\(x^{\\prime}[j]\\) and \\(y^{\\prime}[j]\\) a space). Then we assign a \"score\" to each position. Position \\(j\\) receives a score as follows:\n\n* \\(+1\\) if \\(x^{\\prime}[j]=y^{\\prime}[j]\\) and neither is a space,\n* \\(-1\\) if \\(x^{\\prime}[j]\\neq y^{\\prime}[j]\\) and neither is a space,\n* \\(-2\\) if either \\(x^{\\prime}[j]\\) or \\(y^{\\prime}[j]\\) is a space.\n\nThe score for the alignment is the sum of the scores of the individual positions. For example, given the sequences \\(x=\\texttt{GATCGGCAT}\\) and \\(y=\\texttt{CAATGTGAATC}\\), one alignment is\n\n* G ATCG GCAT CAAT GTGAATC -++++++-++\n\nFigure 14.12: A sequence of operations that transforms the source algorithm to the target string altruistic. The underlined characters are \\(x[i]\\) and \\(z[j]\\) after the operation.\n\nA + under a position indicates a score of \\(+1\\) for that position, a - indicates a score of \\(-1\\), and a \\(\\star\\) indicates a score of \\(-2\\), so that this alignment has a total score of \\(6\\cdot 1-2\\cdot 1-4\\cdot 2=-4\\).\n\n_b._: Explain how to cast the problem of finding an optimal alignment as an edit-distance problem using a subset of the transformation operations copy, replace, delete, insert, twiddle, and kill.\n\n#### Planning a company party\n\nProfessor Blutarsky is consulting for the president of a corporation that is planning a company party. The company has a hierarchical structure, that is, the supervisor relation forms a tree rooted at the president. The human resources department has ranked each employee with a conviviality rating, which is a real number. In order to make the party fun for all attendees, the president does not want both an employee and his or her immediate supervisor to attend.\n\nProfessor Blutarsky is given the tree that describes the structure of the corporation, using the left-child, right-sibling representation described in Section 10.3. Each node of the tree holds, in addition to the pointers, the name of an employee and that employee's conviviality ranking. Describe an algorithm to make up a guest list that maximizes the sum of the conviviality ratings of the guests. Analyze the running time of your algorithm.\n\n#### Viterbi algorithm\n\nDynamic programming on a directed graph can play a part in speech recognition. A directed graph \\(G=(V,E)\\) with labeled edges forms a formal model of a person speaking a restricted language. Each edge \\((u,v)\\in E\\) is labeled with a sound \\(\\sigma(u,v)\\) from a finite set \\(\\Sigma\\) of sounds. Each directed path in the graph starting from a distinguished vertex \\(v_{0}\\in V\\) corresponds to a possible sequence of sounds produced by the model, with the label of a path being the concatenation of the labels of the edges on that path.\n\n_a._: Describe an efficient algorithm that, given an edge-labeled directed graph \\(G\\) with distinguished vertex \\(v_{0}\\) and a sequence \\(s=\\langle\\sigma_{1},\\,\\sigma_{2},\\,\\ldots,\\,\\sigma_{k}\\rangle\\) of sounds from \\(\\Sigma\\), returns a path in \\(G\\) that begins at \\(v_{0}\\) and has \\(s\\) as its label, if any such path exists. Otherwise, the algorithm should return no-such-path. Analyze the running time of your algorithm. (_Hint:_ You may find concepts from Chapter 20 useful.)\n\nNow suppose that every edge \\((u,v)\\in E\\) has an associated nonnegative probability \\(p(u,v)\\) of being traversed, so that the corresponding sound is produced. The sum of the probabilities of the edges leaving any vertex equals 1. The probability of a path is defined to be the product of the probabilities of its edges. Think of the probability of a path beginning at vertex \\(v_{0}\\) as the probability that a \"random walk\" beginning at \\(v_{0}\\) follows the specified path, where the edge leaving a vertex \\(u\\) is taken randomly, according to the probabilities of the available edges leaving \\(u\\).\n* Extend your answer to part (a) so that if a path is returned, it is a _most probable path_ starting at vertex \\(v_{0}\\) and having label \\(s\\). Analyze the running time of your algorithm.\n\n#### 14.8 Image compression by seam carving\n\nSuppose that you are given a color picture consisting of an \\(m\\times n\\) array \\(A[1:m,1:n]\\) of pixels, where each pixel specifies a triple of red, green, and blue (RGB) intensities. You want to compress this picture slightly, by removing one pixel from each of the \\(m\\) rows, so that the whole picture becomes one pixel narrower. To avoid incongruous visual effects, however, the pixels removed in two adjacent rows must lie in either the same column or adjacent columns. In this way, the pixels removed form a \"seam\" from the top row to the bottom row, where successive pixels in the seam are adjacent vertically or diagonally.\n\n* Show that the number of such possible seams grows at least exponentially in \\(m\\), assuming that \\(n>1\\).\n* Suppose now that along with each pixel \\(A[i,j]\\), you are given a real-valued disruption measure \\(d[i,j]\\), indicating how disruptive it would be to remove pixel \\(A[i,j]\\). Intuitively, the lower a pixel's disruption measure, the more similar the pixel is to its neighbors. Define the disruption measure of a seam as the sum of the disruption measures of its pixels.\n\nGive an algorithm to find a seam with the lowest disruption measure. How efficient is your algorithm?\n\n#### 14.9 Breaking a string\n\nA certain string-processing programming language allows you to break a string into two pieces. Because this operation copies the string, it costs \\(n\\) time units to break a string of \\(n\\) characters into two pieces. Suppose that you want to break a string into many pieces. The order in which the breaks occur can affect the total amount of time used. For example, suppose that you want to break a 20-character string after characters 2, 8, and 10 (numbering the characters in ascending order from the left-hand end, starting from 1). If you program the breaks to occur in left-to-right order, then the first break costs 20 time units, the second break costs 18 time units (breaking the string from characters 3 to 20 at character 8), and the third break costs 12 time units, totaling 50 time units. If you program the breaks to occur in right-to-left order, however, then the first break costs 20 time units, the second break costs 10 time units, and the third break costs 8 time units, totaling 38 time units. In yet another order, you could break first at 8 (costing 20), then break the left piece at 2 (costing another 8), and finally the right piece at 10 (costing 12), for a total cost of 40.\n\nDesign an algorithm that, given the numbers of characters after which to break, determines a least-cost way to sequence those breaks. More formally, given an array \\(L[1:m]\\) containing the break points for a string of \\(n\\) characters, compute the lowest cost for a sequence of breaks, along with a sequence of breaks that achieves this cost.\n\n#### Planning an investment strategy\n\nYour knowledge of algorithms helps you obtain an exciting job with a hot startup, along with a $10,000 signing bonus. You decide to invest this money with the goal of maximizing your return at the end of 10 years. You decide to use your investment manager, G. I. Luvcache, to manage your signing bonus. The company that Luvcache works with requires you to observe the following rules. It offers \\(n\\) different investments, numbered 1 through \\(n\\). In each year \\(j\\), investment \\(i\\) provides a return rate of \\(r_{ij}\\). In other words, if you invest \\(d\\) dollars in investment \\(i\\) in year \\(j\\), then at the end of year \\(j\\), you have \\(dr_{ij}\\) dollars. The return rates are guaranteed, that is, you are given all the return rates for the next 10 years for each investment. You make investment decisions only once per year. At the end of each year, you can leave the money made in the previous year in the same investments, or you can shift money to other investments, by either shifting money between existing investments or moving money to a new investment. If you do not move your money between two consecutive years, you pay a fee of \\(f_{1}\\) dollars, whereas if you switch your money, you pay a fee of \\(f_{2}\\) dollars, where \\(f_{2}>f_{1}\\). You pay the fee once per year at the end of the year, and it is the same amount, \\(f_{2}\\), whether you move money in and out of only one investment, or in and out of many investments.\n\n_a._: The problem, as stated, allows you to invest your money in multiple investments in each year. Prove that there exists an optimal investment strategy that, in each year, puts all the money into a single investment. (Recall that an optimal investment strategy maximizes the amount of money after 10 years and is not concerned with any other objectives, such as minimizing risk.)\n\n_b._: Prove that the problem of planning your optimal investment strategy exhibits optimal substructure.\n\n_c._: Design an algorithm that plans your optimal investment strategy. What is the running time of your algorithm?\nSuppose that Luvcache's company imposes the additional restriction that, at any point, you can have no more than $15,000 in any one investment. Show that the problem of maximizing your income at the end of 10 years no longer exhibits optimal substructure.\n\n##### 14-11 Inventory planning\n\nThe Rinky Dink Company makes machines that resurface ice rinks. The demand for such products varies from month to month, and so the company needs to develop a strategy to plan its manufacturing given the fluctuating, but predictable, demand. The company wishes to design a plan for the next \\(n\\) months. For each month \\(i\\), the company knows the demand \\(d_{i}\\), that is, the number of machines that it will sell. Let \\(D=\\sum_{i=1}^{n}d_{i}\\) be the total demand over the next \\(n\\) months. The company keeps a full-time staff who provide labor to manufacture up to \\(m\\) machines per month. If the company needs to make more than \\(m\\) machines in a given month, it can hire additional, part-time labor, at a cost that works out to \\(c\\) dollars per machine. Furthermore, if the company is holding any unsold machines at the end of a month, it must pay inventory costs. The company can hold up to \\(D\\) machines, with the cost for holding \\(j\\) machines given as a function \\(h(j)\\) for \\(j=1,2,\\ldots,D\\) that monotonically increases with \\(j\\).\n\nGive an algorithm that calculates a plan for the company that minimizes its costs while fulfilling all the demand. The running time should be polynomial in \\(n\\) and \\(D\\).\n\n##### 14-12 Signing free-agent baseball players\n\nSuppose that you are the general manager for a major-league baseball team. During the off-season, you need to sign some free-agent players for your team. The team owner has given you a budget of \\(\\$X\\) to spend on free agents. You are allowed to spend less than \\(\\$X\\), but the owner will fire you if you spend any more than \\(\\$X\\).\n\nYou are considering \\(N\\) different positions, and for each position, \\(P\\) free-agent players who play that position are available.10 Because you do not want to overload your roster with too many players at any position, for each position you may sign at most one free agent who plays that position. (If you do not sign any players at a particular position, then you plan to stick with the players you already have at that position.)To determine how valuable a player is going to be, you decide to use a sabermetric statistic11 known as \"WAR,\" or \"wins above replacement.\" A player with a higher WAR is more valuable than a player with a lower WAR. It is not necessarily more expensive to sign a player with a higher WAR than a player with a lower WAR, because factors other than a player's value determine how much it costs to sign them.\n\nFootnote 11: _Sabermetrics_ is the application of statistical analysis to baseball records. It provides several ways to compare the relative values of individual players.\n\nFor each available free-agent player \\(p\\), you have three pieces of information:\n\n* the player's position,\n* \\(p.cost\\), the amount of money it costs to sign the player, and\n* \\(p.war\\), the player's WAR.\n\nDevise an algorithm that maximizes the total WAR of the players you sign while spending no more than \\(\\$\\,X\\). You may assume that each player signs for a multiple of \\(\\$100,\\!000\\). Your algorithm should output the total WAR of the players you sign, the total amount of money you spend, and a list of which players you sign. Analyze the running time and space requirement of your algorithm.\n\n## Chapter notes\n\nBellman [44] began the systematic study of dynamic programming in 1955, publishing a book about it in 1957. The word \"programming,\" both here and in linear programming, refers to using a tabular solution method. Although optimization techniques incorporating elements of dynamic programming were known earlier, Bellman provided the area with a solid mathematical basis.\n\nGalil and Park [172] classify dynamic-programming algorithms according to the size of the table and the number of other table entries each entry depends on. They call a dynamic-programming algorithm \\(tD/eD\\) if its table size is \\(O(n^{t})\\) and each entry depends on \\(O(n^{e})\\) other entries. For example, the matrix-chain multiplication algorithm in Section 14.2 is \\(2D/1D\\), and the longest-common-subsequence algorithm in Section 14.4 is \\(2D/0D\\).\n\nThe Matrix-Chain-Order algorithm on page 378 is by Muraoka and Kuck [339]. Hu and Shing [230, 231] give an \\(O(n\\lg n)\\)-time algorithm for the matrix-chain multiplication problem.\n\nThe \\(O(mn)\\)-time algorithm for the longest-common-subsequence problem appears to be a folk algorithm. Knuth [95] posed the question of whether subquadratic",
        "chapter": "Part IV Advanced Design and Analysis Techniques",
        "section": "14 Dynamic Programming",
        "subsection": "Problems",
        "subsubsection": "N/A"
    },
    {
        "content": "To determine how valuable a player is going to be, you decide to use a sabermetric statistic11 known as \"WAR,\" or \"wins above replacement.\" A player with a higher WAR is more valuable than a player with a lower WAR. It is not necessarily more expensive to sign a player with a higher WAR than a player with a lower WAR, because factors other than a player's value determine how much it costs to sign them.\n\nFootnote 11: _Sabermetrics_ is the application of statistical analysis to baseball records. It provides several ways to compare the relative values of individual players.\n\nFor each available free-agent player \\(p\\), you have three pieces of information:\n\n* the player's position,\n* \\(p.cost\\), the amount of money it costs to sign the player, and\n* \\(p.war\\), the player's WAR.\n\nDevise an algorithm that maximizes the total WAR of the players you sign while spending no more than \\(\\$\\,X\\). You may assume that each player signs for a multiple of \\(\\$100,\\!000\\). Your algorithm should output the total WAR of the players you sign, the total amount of money you spend, and a list of which players you sign. Analyze the running time and space requirement of your algorithm.\n\n## Chapter notes\n\nBellman [44] began the systematic study of dynamic programming in 1955, publishing a book about it in 1957. The word \"programming,\" both here and in linear programming, refers to using a tabular solution method. Although optimization techniques incorporating elements of dynamic programming were known earlier, Bellman provided the area with a solid mathematical basis.\n\nGalil and Park [172] classify dynamic-programming algorithms according to the size of the table and the number of other table entries each entry depends on. They call a dynamic-programming algorithm \\(tD/eD\\) if its table size is \\(O(n^{t})\\) and each entry depends on \\(O(n^{e})\\) other entries. For example, the matrix-chain multiplication algorithm in Section 14.2 is \\(2D/1D\\), and the longest-common-subsequence algorithm in Section 14.4 is \\(2D/0D\\).\n\nThe Matrix-Chain-Order algorithm on page 378 is by Muraoka and Kuck [339]. Hu and Shing [230, 231] give an \\(O(n\\lg n)\\)-time algorithm for the matrix-chain multiplication problem.\n\nThe \\(O(mn)\\)-time algorithm for the longest-common-subsequence problem appears to be a folk algorithm. Knuth [95] posed the question of whether subquadraticalgorithms for the LCS problem exist. Masek and Paterson [316] answered this question in the affirmative by giving an algorithm that runs in \\(O(m\\,n/\\lg n)\\) time, where \\(n\\leq m\\) and the sequences are drawn from a set of bounded size. For the special case in which no element appears more than once in an input sequence, Szymanski [425] shows how to solve the problem in \\(O((n+m)\\lg(n+m))\\) time. Many of these results extend to the problem of computing string edit distances (Problem 14-5).\n\nAn early paper on variable-length binary encodings by Gilbert and Moore [181], which had applications to constructing optimal binary search trees for the case in which all probabilities \\(p_{i}\\) are \\(0,\\) contains an \\(O(n^{3})\\)-time algorithm. Aho, Hopcroft, and Ullman [5] present the algorithm from Section 14.5. Splay trees [418], which modify the tree in response to the search queries, come within a constant factor of the optimal bounds without being initialized with the frequencies. Exercise 14.5-4 is due to Knuth [264]. Hu and Tucker [232] devised an algorithm for the case in which all probabilities \\(p_{i}\\) are \\(0\\) that uses \\(O(n^{2})\\) time and \\(O(n)\\) space. Subsequently, Knuth [261] reduced the time to \\(O(n\\lg n)\\).\n\nProblem 14-8 is due to Avidan and Shamir [30], who have posted on the web a wonderful video illustrating this image-compression technique.\n\n## Chapter 15 Greedy Algorithms\n\nAlgorithms for optimization problems typically go through a sequence of steps, with a set of choices at each step. For many optimization problems, using dynamic programming to determine the best choices is overkill, and simpler, more efficient algorithms will do. A _greedy algorithm_ always makes the choice that looks best at the moment. That is, it makes a locally optimal choice in the hope that this choice leads to a globally optimal solution. This chapter explores optimization problems for which greedy algorithms provide optimal solutions. Before reading this chapter, you should read about dynamic programming in Chapter 14, particularly Section 14.3.\n\nGreedy algorithms do not always yield optimal solutions, but for many problems they do. We first examine, in Section 15.1, a simple but nontrivial problem, the activity-selection problem, for which a greedy algorithm efficiently computes an optimal solution. We'll arrive at the greedy algorithm by first considering a dynamic-programming approach and then showing that an optimal solution can result from always making greedy choices. Section 15.2 reviews the basic elements of the greedy approach, giving a direct approach for proving greedy algorithms correct. Section 15.3 presents an important application of greedy techniques: designing data-compression (Huffman) codes. Finally, Section 15.4 shows that in order to decide which blocks to replace when a miss occurs in a cache, the \"furthest-in-future\" strategy is optimal if the sequence of block accesses is known in advance.\n\nThe greedy method is quite powerful and works well for a wide range of problems. Later chapters will present many algorithms that you can view as applications of the greedy method, including minimum-spanning-tree algorithms (Chapter 21), Dijkstra's algorithm for shortest paths from a single source (Section 22.3), and a greedy set-covering heuristic (Section 35.3). Minimum-spanning-tree algorithms furnish a classic example of the greedy method. Although you can read this chapter and Chapter 21 independently of each other, you might find it useful to read them together.",
        "chapter": "Part IV Advanced Design and Analysis Techniques",
        "section": "14 Dynamic Programming",
        "subsection": "Chapter notes",
        "subsubsection": "N/A"
    },
    {
        "content": "### 15.1 An activity-selection problem\n\nOur first example is the problem of scheduling several competing activities that require exclusive use of a common resource, with a goal of selecting a maximum-size set of mutually compatible activities. Imagine that you are in charge of scheduling a conference room. You are presented with a set \\(S=\\{a_{1},a_{2},\\ldots,a_{n}\\}\\) of \\(n\\) proposed _activities_ that wish to reserve the conference room, and the room can serve only one activity at a time. Each activity \\(a_{i}\\) has a _start time_\\(s_{i}\\) and a _finish time_\\(f_{i}\\), where \\(0\\leq s_{i}<f_{i}<\\infty\\). If selected, activity \\(a_{i}\\) takes place during the half-open time interval \\([s_{i},f_{i})\\). Activities \\(a_{i}\\) and \\(a_{j}\\) are _compatible_ if the intervals \\([s_{i},f_{i})\\) and \\([s_{j},f_{j})\\) do not overlap. That is, \\(a_{i}\\) and \\(a_{j}\\) are compatible if \\(s_{i}\\geq f_{j}\\) or \\(s_{j}\\geq f_{i}\\). (Assume that if your staff needs time to change over the room from one activity to the next, the changeover time is built into the intervals.) In the _activity-selection problem_, your goal is to select a maximum-size subset of mutually compatible activities. Assume that the activities are sorted in monotonically increasing order of finish time:\n\n\\[f_{1}\\leq f_{2}\\leq f_{3}\\leq\\cdots\\leq f_{n-1}\\leq f_{n}. \\tag{15.1}\\]\n\n(We'll see later the advantage that this assumption provides.) For example, consider the set of activities in Figure 15.1. The subset \\(\\{a_{3},a_{9},a_{11}\\}\\) consists of mutually compatible activities. It is not a maximum subset, however, since the subset \\(\\{a_{1},a_{4},a_{8},a_{11}\\}\\) is larger. In fact, \\(\\{a_{1},a_{4},a_{8},a_{11}\\}\\) is a largest subset of mutually compatible activities, and another largest subset is \\(\\{a_{2},a_{4},a_{9},a_{11}\\}\\).\n\nWe'll see how to solve this problem, proceeding in several steps. First we'll explore a dynamic-programming solution, in which you consider several choices when determining which subproblems to use in an optimal solution. We'll then observe that you need to consider only one choice--the greedy choice--and that when you make the greedy choice, only one subproblem remains. Based on these observations, we'll develop a recursive greedy algorithm to solve the activity-selection problem. Finally, we'll complete the process of developing a greedy solution by converting the recursive algorithm to an iterative one. Although the steps we go through in this section are slightly more involved than is typical when developing a greedy algorithm, they illustrate the relationship between greedy algorithms and dynamic programming.\n\nFigure 15.1: A set \\(\\{a_{1},a_{2},\\ldots,a_{11}\\}\\) of activities. Activity \\(a_{i}\\) has start time \\(s_{i}\\) and finish time \\(f_{i}\\).\n\n### An activity-selection problem\n\n#### The optimal substructure of the activity-selection problem\n\nLet's verify that the activity-selection problem exhibits optimal substructure. Denote by \\(S_{ij}\\) the set of activities that start after activity \\(a_{i}\\) finishes and that finish before activity \\(a_{j}\\) starts. Suppose that you want to find a maximum set of mutually compatible activities in \\(S_{ij}\\), and suppose further that such a maximum set is \\(A_{ij}\\), which includes some activity \\(a_{k}\\). By including \\(a_{k}\\) in an optimal solution, you are left with two subproblems: finding mutually compatible activities in the set \\(S_{ik}\\) (activities that start after activity \\(a_{i}\\) finishes and that finish before activity \\(a_{k}\\) starts) and finding mutually compatible activities in the set \\(S_{kj}\\) (activities that start after activity \\(a_{k}\\) finishes and that finish before activity \\(a_{j}\\) starts). Let \\(A_{ik}=A_{ij}\\cap S_{ik}\\) and \\(A_{kj}=A_{ij}\\cap S_{kj}\\), so that \\(A_{ik}\\) contains the activities in \\(A_{ij}\\) that finish before \\(a_{k}\\) starts and \\(A_{kj}\\) contains the activities in \\(A_{ij}\\) that start after \\(a_{k}\\) finishes. Thus, we have \\(A_{ij}=A_{ik}\\cup\\{a_{k}\\}\\cup A_{kj}\\), and so the maximum-size set \\(A_{ij}\\) of mutually compatible activities in \\(S_{ij}\\) consists of \\(|A_{ij}|=|A_{ik}|+|A_{kj}|+1\\) activities.\n\nThe usual cut-and-paste argument shows that an optimal solution \\(A_{ij}\\) must also include optimal solutions to the two subproblems for \\(S_{ik}\\) and \\(S_{kj}\\). If you could find a set \\(A^{\\prime}_{kj}\\) of mutually compatible activities in \\(S_{kj}\\) where \\(|A^{\\prime}_{kj}|>|A_{kj}|\\), then you could use \\(A^{\\prime}_{kj}\\), rather than \\(A_{kj}\\), in a solution to the subproblem for \\(S_{ij}\\). You would have constructed a set of \\(|A_{ik}|+|A^{\\prime}_{kj}|+1>|A_{ik}|+|A_{kj}|+1=|A_{ij}|\\) mutually compatible activities, which contradicts the assumption that \\(A_{ij}\\) is an optimal solution. A symmetric argument applies to the activities in \\(S_{ik}\\).\n\nThis way of characterizing optimal substructure suggests that you can solve the activity-selection problem by dynamic programming. Let's denote the size of an optimal solution for the set \\(S_{ij}\\) by \\(c[i,j]\\). Then, the dynamic-programming approach gives the recurrence\n\n\\[c[i,j]=c[i,k]+c[k,j]+1\\.\\]\n\nOf course, if you do not know that an optimal solution for the set \\(S_{ij}\\) includes activity \\(a_{k}\\), you must examine all activities in \\(S_{ij}\\) to find which one to choose, so that\n\n\\[c[i,j]=\\left\\{\\begin{array}{ll}0&\\mbox{if $S_{ij}\\,=\\,\\emptyset$}\\,\\\\ \\max\\,\\{c[i,k]+c[k,j]+1:a_{k}\\in S_{ij}\\}&\\mbox{if $S_{ij}\\,\\neq\\, \\emptyset$}\\.\\end{array}\\right. \\tag{15.2}\\]\n\nYou can then develop a recursive algorithm and memoize it, or you can work bottom-up and fill in table entries as you go along. But you would be overlooking another important characteristic of the activity-selection problem that you can use to great advantage.\n\n### Making the greedy choice\n\nWhat if you could choose an activity to add to an optimal solution without having to first solve all the subproblems? That could save you from having to consider all the choices inherent in recurrence (15.2). In fact, for the activity-selection problem, you need to consider only one choice: the greedy choice.\n\nWhat is the greedy choice for the activity-selection problem? Intuition suggests that you should choose an activity that leaves the resource available for as many other activities as possible. Of the activities you end up choosing, one of them must be the first one to finish. Intuition says, therefore, choose the activity in \\(S\\) with the earliest finish time, since that leaves the resource available for as many of the activities that follow it as possible. (If more than one activity in \\(S\\) has the earliest finish time, then choose any such activity.) In other words, since the activities are sorted in monotonically increasing order by finish time, the greedy choice is activity \\(a_{1}\\). Choosing the first activity to finish is not the only way to think of making a greedy choice for this problem. Exercise 15.1-3 asks you to explore other possibilities.\n\nOnce you make the greedy choice, you have only one remaining subproblem to solve: finding activities that start after \\(a_{1}\\) finishes. Why don't you have to consider activities that finish before \\(a_{1}\\) starts? Because \\(s_{1}<f_{1}\\), and because \\(f_{1}\\) is the earliest finish time of any activity, no activity can have a finish time less than or equal to \\(s_{1}\\). Thus, all activities that are compatible with activity \\(a_{1}\\) must start after \\(a_{1}\\) finishes.\n\nFurthermore, we have already established that the activity-selection problem exhibits optimal substructure. Let \\(S_{k}=\\{a_{i}\\in S:s_{i}\\geq f_{k}\\}\\) be the set of activities that start after activity \\(a_{k}\\) finishes. If you make the greedy choice of activity \\(a_{1}\\), then \\(S_{1}\\) remains as the only subproblem to solve.1 Optimal substructure says that if \\(a_{1}\\) belongs to an optimal solution, then an optimal solution to the original problem consists of activity \\(a_{1}\\) and all the activities in an optimal solution to the subproblem \\(S_{1}\\).\n\nFootnote 1: We sometimes refer to the sets \\(S_{k}\\) as subproblems rather than as just sets of activities. The context will make it clear whether we are referring to \\(S_{k}\\) as a set of activities or as a subproblem whose input is that set.\n\nOne big question remains: Is this intuition correct? Is the greedy choice--in which you choose the first activity to finish--always part of some optimal solution? The following theorem shows that it is.\n\n### An activity-selection problem\n\n**Theorem 15.1**: _Consider any nonempty subproblem \\(S_{k}\\), and let \\(a_{m}\\) be an activity in \\(S_{k}\\) with the earliest finish time. Then \\(a_{m}\\) is included in some maximum-size subset of mutually compatible activities of \\(S_{k}\\)._\n\n_Proof_ Let \\(A_{k}\\) be a maximum-size subset of mutually compatible activities in \\(S_{k}\\), and let \\(a_{j}\\) be the activity in \\(A_{k}\\) with the earliest finish time. If \\(a_{j}=a_{m}\\), we are done, since we have shown that \\(a_{m}\\) belongs to some maximum-size subset of mutually compatible activities of \\(S_{k}\\). If \\(a_{j}\\neq a_{m}\\), let the set \\(A^{\\prime}_{k}=(A_{k}-\\{a_{j}\\})\\cup\\{a_{m}\\}\\) be \\(A_{k}\\) but substituting \\(a_{m}\\) for \\(a_{j}\\). The activities in \\(A^{\\prime}_{k}\\) are compatible, which follows because the activities in \\(A_{k}\\) are compatible, \\(a_{j}\\) is the first activity in \\(A_{k}\\) to finish, and \\(f_{m}\\leq f_{j}\\). Since \\(|A^{\\prime}_{k}|=|A_{k}|\\), we conclude that \\(A^{\\prime}_{k}\\) is a maximum-size subset of mutually compatible activities of \\(S_{k}\\), and it includes \\(a_{m}\\).\n\nAlthough you might be able to solve the activity-selection problem with dynamic programming, Theorem 15.1 says that you don't need to. Instead, you can repeatedly choose the activity that finishes first, keep only the activities compatible with this activity, and repeat until no activities remain. Moreover, because you always choose the activity with the earliest finish time, the finish times of the activities that you choose must strictly increase. You can consider each activity just once overall, in monotonically increasing order of finish times.\n\nAn algorithm to solve the activity-selection problem does not need to work bottom-up, like a table-based dynamic-programming algorithm. Instead, it can work top-down, choosing an activity to put into the optimal solution that it constructs and then solving the subproblem of choosing activities from those that are compatible with those already chosen. Greedy algorithms typically have this top-down design: make a choice and then solve a subproblem, rather than the bottom-up technique of solving subproblems before making a choice.\n\n### A recursive greedy algorithm\n\nNow that you know you can bypass the dynamic-programming approach and instead use a top-down, greedy algorithm, let's see a straightforward, recursive procedure to solve the activity-selection problem. The procedure Recursive-Activity-Selector on the following page takes the start and finish times of the activities, represented as arrays \\(s\\) and \\(f\\),2 the index \\(k\\) that defines the subproblem \\(S_{k}\\) it is to solve, and the size \\(n\\) of the original problem. It returns a maximumsize set of mutually compatible activities in \\(S_{k}\\). The procedure assumes that the \\(n\\) input activities are already ordered by monotonically increasing finish time, according to equation (15.1). If not, you can first sort them into this order in \\(O(n\\lg n)\\) time, breaking ties arbitrarily. In order to start, add the fictitious activity \\(a_{0}\\) with \\(f_{0}=0\\), so that subproblem \\(S_{0}\\) is the entire set of activities \\(S\\). The initial call, which solves the entire problem, is Recursive-Activity-Selector\\((s,f,0,n)\\).\n\nRecursive-Activity-Selector\\((s,f,k,n)\\)\n1\\(m=k+1\\)\n2while\\(m\\leq n\\) and \\(s[m]<f[k]\\) // find the first activity in \\(S_{k}\\) to finish\n3\\(m=m+1\\)\n4if\\(m\\leq n\\)\n5return\\(\\{a_{m}\\}\\cup\\) Recursive-Activity-Selector\\((s,f,m,n)\\)\n6else return\\(\\emptyset\\)\n\nFigure 15.2 shows how the algorithm operates on the activities in Figure 15.1. In a given recursive call Recursive-Activity-Selector\\((s,f,k,n)\\), the **while** loop of lines 2-3 looks for the first activity in \\(S_{k}\\) to finish. The loop examines \\(a_{k+1},a_{k+2},\\ldots,a_{n}\\), until it finds the first activity \\(a_{m}\\) that is compatible with \\(a_{k}\\), which means that \\(s_{m}\\geq f_{k}\\). If the loop terminates because it finds such an activity, line 5 returns the union of \\(\\{a_{m}\\}\\) and the maximum-size subset of \\(S_{m}\\) returned by the recursive call Recursive-Activity-Selector\\((s,f,m,n)\\). Alternatively, the loop may terminate because \\(m>n\\), in which case the procedure has examined all activities in \\(S_{k}\\) without finding one that is compatible with \\(a_{k}\\). In this case, \\(S_{k}=\\emptyset\\), and so line 6 returns \\(\\emptyset\\).\n\nAssuming that the activities have already been sorted by finish times, the running time of the call Recursive-Activity-Selector\\((s,f,0,n)\\) is \\(\\Theta(n)\\). To see why, observe that over all recursive calls, each activity is examined exactly once in the **while** loop test of line 2. In particular, activity \\(a_{i}\\) is examined in the last call made in which \\(k<i\\).\n\n### An iterative greedy algorithm\n\nThe recursive procedure can be converted to an iterative one because the procedure Recursive-Activity-Selector is almost \"tail recursive\" (see Problem 7-5): it ends with a recursive call to itself followed by a union operation. It is usually a straightforward task to transform a tail-recursive procedure to an iterative form. In fact, some compilers for certain programming languages perform this task automatically.\n\n### An activity-selection problem\n\nFigure 15.2: The operation of Recursive-Activity-Selector on the 11 activities from Figure 15.1. Activities considered in each recursive call appear between horizontal lines. The fictitious activity \\(a_{0}\\) finishes at time 0, and the initial call Recursive-Activity-Selector(\\(s\\), \\(f\\), \\(0\\), \\(11\\)), selects activity \\(a_{1}\\). In each recursive call, the activities that have already been selected are blue, and the activity shown in tan is being considered. If the starting time of an activity occurs before the finish time of the most recently added activity (the arrow between them points left), it is rejected. Otherwise (the arrow points directly up or to the right), it is selected. The last recursive call, Recursive-Activity-Selector(\\(s\\), \\(f\\), \\(11\\), \\(11\\)), returns \\(\\emptyset\\). The resulting set of selected activities is \\(\\{a_{1},a_{4},a_{8},a_{11}\\}\\).\n\nThe procedure Greedy-Activity-Selector is an iterative version of the procedure Recursive-Activity-Selector. It, too, assumes that the input activities are ordered by monotonically increasing finish time. It collects selected activities into a set \\(A\\) and returns this set when it is done.\n\n\\[\\begin{array}{ll}\\mbox{\\sc Greedy-Activity-Selector}\\left(s,\\,f,n\\right)\\\\ \\\\ 1&A\\,=\\,\\{a_{1}\\}\\\\ 2&k\\,=\\,1\\\\ \\end{array}\\]\n\n```\n1\\(A\\,=\\,\\{a_{1}\\}\\)\n2\\(k\\,=\\,1\\)\n3for\\(m\\,=\\,2\\)to\\(n\\)\n4if\\(s[m]\\geq\\,f\\,[k]\\) // is \\(a_{m}\\) in \\(S_{k}\\)?\n5\\(A\\,=\\,A\\cup\\{a_{m}\\}\\) // yes, so choose it\n6\\(k\\,=\\,m\\) // and continue from there\n7return\\(A\\)\n```\n\nThe procedure works as follows. The variable \\(k\\) indexes the most recent addition to \\(A\\), corresponding to the activity \\(a_{k}\\) in the recursive version. Since the procedure considers the activities in order of monotonically increasing finish time, \\(f_{k}\\) is always the maximum finish time of any activity in \\(A\\). That is,\n\n\\[f_{k}\\,=\\,\\max\\,\\{f_{i}:a_{i}\\,\\in\\,A\\}\\,\\,. \\tag{15.3}\\]\n\nLines 1-2 select activity \\(a_{1}\\), initialize \\(A\\) to contain just this activity, and initialize \\(k\\) to index this activity. The **for** loop of lines 3-6 finds the earliest activity in \\(S_{k}\\) to finish. The loop considers each activity \\(a_{m}\\) in turn and adds \\(a_{m}\\) to \\(A\\) if it is compatible with all previously selected activities. Such an activity is the earliest in \\(S_{k}\\) to finish. To see whether activity \\(a_{m}\\) is compatible with every activity currently in \\(A\\), it suffices by equation (15.3) to check (in line 4) that its start time \\(s_{m}\\) is not earlier than the finish time \\(f_{k}\\) of the activity most recently added to \\(A\\). If activity \\(a_{m}\\) is compatible, then lines 5-6 add activity \\(a_{m}\\) to \\(A\\) and set \\(k\\) to \\(m\\). The set \\(A\\) returned by the call Greedy-Activity-Selector\\((s,\\,f)\\) is precisely the set returned by the initial call Recursive-Activity-Selector\\((s,\\,f,0,n)\\).\n\nLike the recursive version, Greedy-Activity-Selector schedules a set of \\(n\\) activities in \\(\\Theta(n)\\) time, assuming that the activities were already sorted initially by their finish times.\n\n## 15 Exercises\n\n### 15.1-1\n\nGive a dynamic-programming algorithm for the activity-selection problem, based on recurrence (15.2). Have your algorithm compute the sizes \\(c[i,j]\\) as defined above and also produce the maximum-size subset of mutually compatible activities.\n\n### An activity-selection problem\n\nAssume that the inputs have been sorted as in equation (15.1). Compare the running time of your solution to the running time of Greedy-Activity-Selector.\n\n#### 15.1-2\n\nSuppose that instead of always selecting the first activity to finish, you instead select the last activity to start that is compatible with all previously selected activities. Describe how this approach is a greedy algorithm, and prove that it yields an optimal solution.\n\n#### 15.1-3\n\nNot just any greedy approach to the activity-selection problem produces a maximum-size set of mutually compatible activities. Give an example to show that the approach of selecting the activity of least duration from among those that are compatible with previously selected activities does not work. Do the same for the approaches of always selecting the compatible activity that overlaps the fewest other remaining activities and always selecting the compatible remaining activity with the earliest start time.\n\n#### 15.1-4\n\nYou are given a set of activities to schedule among a large number of lecture halls, where any activity can take place in any lecture hall. You wish to schedule all the activities using as few lecture halls as possible. Give an efficient greedy algorithm to determine which activity should use which lecture hall.\n\n(This problem is also known as the _interval-graph coloring problem_. It is modeled by an interval graph whose vertices are the given activities and whose edges connect incompatible activities. The smallest number of colors required to color every vertex so that no two adjacent vertices have the same color corresponds to finding the fewest lecture halls needed to schedule all of the given activities.)\n\n#### 15.1-5\n\nConsider a modification to the activity-selection problem in which each activity \\(a_{i}\\) has, in addition to a start and finish time, a value \\(v_{i}\\). The objective is no longer to maximize the number of activities scheduled, but instead to maximize the total value of the activities scheduled. That is, the goal is to choose a set \\(A\\) of compatible activities such that \\(\\sum_{a_{k}\\in A}v_{k}\\) is maximized. Give a polynomial-time algorithm for this problem.\n\n### Elements of the greedy strategy\n\nA greedy algorithm obtains an optimal solution to a problem by making a sequence of choices. At each decision point, the algorithm makes the choice that seems best at the moment. This heuristic strategy does not always produce an optimal solution, but as in the activity-selection problem, sometimes it does. This section discusses some of the general properties of greedy methods.\n\nThe process that we followed in Section 15.1 to develop a greedy algorithm was a bit more involved than is typical. It consisted of the following steps:\n\n1. Determine the optimal substructure of the problem.\n2. Develop a recursive solution. (For the activity-selection problem, we formulated recurrence (15.2), but bypassed developing a recursive algorithm based solely on this recurrence.)\n3. Show that if you make the greedy choice, then only one subproblem remains.\n4. Prove that it is always safe to make the greedy choice. (Steps 3 and 4 can occur in either order.)\n5. Develop a recursive algorithm that implements the greedy strategy.\n6. Convert the recursive algorithm to an iterative algorithm.\n\nThese steps highlighted in great detail the dynamic-programming underpinnings of a greedy algorithm. For example, the first cut at the activity-selection problem defined the subproblems \\(S_{ij}\\), where both \\(i\\) and \\(j\\) varied. We then found that if you always make the greedy choice, you can restrict the subproblems to be of the form \\(S_{k}\\).\n\nAn alternative approach is to fashion optimal substructure with a greedy choice in mind, so that the choice leaves just one subproblem to solve. In the activity-selection problem, start by dropping the second subscript and defining subproblems of the form \\(S_{k}\\). Then prove that a greedy choice (the first activity \\(a_{m}\\) to finish in \\(S_{k}\\)), combined with an optimal solution to the remaining set \\(S_{m}\\) of compatible activities, yields an optimal solution to \\(S_{k}\\). More generally, you can design greedy algorithms according to the following sequence of steps:\n\n1. Cast the optimization problem as one in which you make a choice and are left with one subproblem to solve.\n2. Prove that there is always an optimal solution to the original problem that makes the greedy choice, so that the greedy choice is always safe.\n3. Demonstrate optimal substructure by showing that, having made the greedy choice, what remains is a subproblem with the property that if you combine an",
        "chapter": "Part IV Advanced Design and Analysis Techniques",
        "section": "15 Greedy Algorithms",
        "subsection": "15.1 An activity-selection problem",
        "subsubsection": "N/A"
    },
    {
        "content": "### Elements of the greedy strategy\n\nA greedy algorithm obtains an optimal solution to a problem by making a sequence of choices. At each decision point, the algorithm makes the choice that seems best at the moment. This heuristic strategy does not always produce an optimal solution, but as in the activity-selection problem, sometimes it does. This section discusses some of the general properties of greedy methods.\n\nThe process that we followed in Section 15.1 to develop a greedy algorithm was a bit more involved than is typical. It consisted of the following steps:\n\n1. Determine the optimal substructure of the problem.\n2. Develop a recursive solution. (For the activity-selection problem, we formulated recurrence (15.2), but bypassed developing a recursive algorithm based solely on this recurrence.)\n3. Show that if you make the greedy choice, then only one subproblem remains.\n4. Prove that it is always safe to make the greedy choice. (Steps 3 and 4 can occur in either order.)\n5. Develop a recursive algorithm that implements the greedy strategy.\n6. Convert the recursive algorithm to an iterative algorithm.\n\nThese steps highlighted in great detail the dynamic-programming underpinnings of a greedy algorithm. For example, the first cut at the activity-selection problem defined the subproblems \\(S_{ij}\\), where both \\(i\\) and \\(j\\) varied. We then found that if you always make the greedy choice, you can restrict the subproblems to be of the form \\(S_{k}\\).\n\nAn alternative approach is to fashion optimal substructure with a greedy choice in mind, so that the choice leaves just one subproblem to solve. In the activity-selection problem, start by dropping the second subscript and defining subproblems of the form \\(S_{k}\\). Then prove that a greedy choice (the first activity \\(a_{m}\\) to finish in \\(S_{k}\\)), combined with an optimal solution to the remaining set \\(S_{m}\\) of compatible activities, yields an optimal solution to \\(S_{k}\\). More generally, you can design greedy algorithms according to the following sequence of steps:\n\n1. Cast the optimization problem as one in which you make a choice and are left with one subproblem to solve.\n2. Prove that there is always an optimal solution to the original problem that makes the greedy choice, so that the greedy choice is always safe.\n3. Demonstrate optimal substructure by showing that, having made the greedy choice, what remains is a subproblem with the property that if you combine anoptimal solution to the subproblem with the greedy choice you have made, you arrive at an optimal solution to the original problem.\n\nLater sections of this chapter will use this more direct process. Nevertheless, beneath every greedy algorithm, there is almost always a more cumbersome dynamic-programming solution.\n\nHow can you tell whether a greedy algorithm will solve a particular optimization problem? No way works all the time, but the greedy-choice property and optimal substructure are the two key ingredients. If you can demonstrate that the problem has these properties, then you are well on the way to developing a greedy algorithm for it.\n\n##### Greedy-choice property\n\nThe first key ingredient is the _greedy-choice property_: you can assemble a globally optimal solution by making locally optimal (greedy) choices. In other words, when you are considering which choice to make, you make the choice that looks best in the current problem, without considering results from subproblems.\n\nHere is where greedy algorithms differ from dynamic programming. In dynamic programming, you make a choice at each step, but the choice usually depends on the solutions to subproblems. Consequently, you typically solve dynamic-programming problems in a bottom-up manner, progressing from smaller subproblems to larger subproblems. (Alternatively, you can solve them top down, but memoizing. Of course, even though the code works top down, you still must solve the subproblems before making a choice.) In a greedy algorithm, you make whatever choice seems best at the moment and then solve the subproblem that remains. The choice made by a greedy algorithm may depend on choices so far, but it cannot depend on any future choices or on the solutions to subproblems. Thus, unlike dynamic programming, which solves the subproblems before making the first choice, a greedy algorithm makes its first choice before solving any subproblems. A dynamic-programming algorithm proceeds bottom up, whereas a greedy strategy usually progresses top down, making one greedy choice after another, reducing each given problem instance to a smaller one.\n\nOf course, you need to prove that a greedy choice at each step yields a globally optimal solution. Typically, as in the case of Theorem 15.1, the proof examines a globally optimal solution to some subproblem. It then shows how to modify the solution to substitute the greedy choice for some other choice, resulting in one similar, but smaller, subproblem.\n\nYou can usually make the greedy choice more efficiently than when you have to consider a wider set of choices. For example, in the activity-selection problem, assuming that the activities were already sorted in monotonically increasing order by finish times, each activity needed to be examined just once. By preprocessingthe input or by using an appropriate data structure (often a priority queue), you often can make greedy choices quickly, thus yielding an efficient algorithm.\n\n##### Optimal substructure\n\nAs we saw in Chapter 14, a problem exhibits _optimal substructure_ if an optimal solution to the problem contains within it optimal solutions to subproblems. This property is a key ingredient of assessing whether dynamic programming applies, and it's also essential for greedy algorithms. As an example of optimal substructure, recall how Section 15.1 demonstrated that if an optimal solution to subproblem \\(S_{ij}\\) includes an activity \\(a_{k}\\), then it must also contain optimal solutions to the subproblems \\(S_{ik}\\) and \\(S_{kj}\\). Given this optimal substructure, we argued that if you know which activity to use as \\(a_{k}\\), you can construct an optimal solution to \\(S_{ij}\\) by selecting \\(a_{k}\\) along with all activities in optimal solutions to the subproblems \\(S_{ik}\\) and \\(S_{kj}\\). This observation of optimal substructure gave rise to the recurrence (15.2) that describes the value of an optimal solution.\n\nYou will usually use a more direct approach regarding optimal substructure when applying it to greedy algorithms. As mentioned above, you have the luxury of assuming that you arrived at a subproblem by having made the greedy choice in the original problem. All you really need to do is argue that an optimal solution to the subproblem, combined with the greedy choice already made, yields an optimal solution to the original problem. This scheme implicitly uses induction on the subproblems to prove that making the greedy choice at every step produces an optimal solution.\n\n##### Greedy versus dynamic programming\n\nBecause both the greedy and dynamic-programming strategies exploit optimal substructure, you might be tempted to generate a dynamic-programming solution to a problem when a greedy solution suffices or, conversely, you might mistakenly think that a greedy solution works when in fact a dynamic-programming solution is required. To illustrate the subtle differences between the two techniques, let's investigate two variants of a classical optimization problem.\n\nThe _0-1 knapsack problem_ is the following. A thief robbing a store wants to take the most valuable load that can be carried in a knapsack capable of carrying at most \\(W\\) pounds of loot. The thief can choose to take any subset of \\(n\\) items in the store. The \\(i\\)th item is worth \\(v_{i}\\) dollars and weighs \\(w_{i}\\) pounds, where \\(v_{i}\\) and \\(w_{i}\\) are integers. Which items should the thief take? (We call this the 0-1 knapsack problem because for each item, the thief must either take it or leave it behind. The thief cannot take a fractional amount of an item or take an item more than once.)\n\n### Elements of the greedy strategy\n\nIn the _fractional knapsack problem_, the setup is the same, but the thief can take fractions of items, rather than having to make a binary (0-1) choice for each item. You can think of an item in the 0-1 knapsack problem as being like a gold ingot and an item in the fractional knapsack problem as more like gold dust.\n\nBoth knapsack problems exhibit the optimal-substructure property. For the 0-1 problem, if the most valuable load weighing at most \\(W\\) pounds includes item \\(j\\), then the remaining load must be the most valuable load weighing at most \\(W-w_{j}\\) pounds that the thief can take from the \\(n-1\\) original items excluding item \\(j\\). For the comparable fractional problem, if if the most valuable load weighing at most \\(W\\) pounds includes weight \\(w\\) of item \\(j\\), then the remaining load must be the most valuable load weighing at most \\(W-w\\) pounds that the thief can take from the \\(n-1\\) original items plus \\(w_{j}-w\\) pounds of item \\(j\\).\n\nAlthough the problems are similar, a greedy strategy works to solve the fractional knapsack problem, but not the 0-1 problem. To solve the fractional problem, first compute the value per bound \\(v_{i}/w_{i}\\) for each item. Obeying a greedy strategy, the thief begins by taking as much as possible of the item with the greatest value per bound. If the supply of that item is exhausted and the thief can still carry more, then the thief takes as much as possible of the item with the next greatest value per bound, and so forth, until reaching the weight limit \\(W\\). Thus, by sorting the items by value per bound, the greedy algorithm runs in \\(O(n\\lg n)\\) time. You are asked to prove that the fractional knapsack problem has the greedy-choice property in Exercise 15.2-1.\n\nTo see that this greedy strategy does not work for the 0-1 knapsack problem, consider the problem instance illustrated in Figure 15.3(a). This example has three items and a knapsack that can hold 50 pounds. Item 1 weighs 10 pounds and is worth $60. Item 2 weighs 20 pounds and is worth $100. Item 3 weighs 30 pounds and is worth $120. Thus, the value per bound of item 1 is $6 per bound, which is greater than the value per bound of either item 2 ($5 per bound) or item 3 ($4 per bound). The greedy strategy, therefore, would take item 1 first. As you can see from the case analysis in Figure 15.3(b), however, the optimal solution takes items 2 and 3, leaving item 1 behind. The two possible solutions that take item 1 are both suboptimal.\n\nFor the comparable fractional problem, however, the greedy strategy, which takes item 1 first, does yield an optimal solution, as shown in Figure 15.3(c). Taking item 1 doesn't work in the 0-1 problem, because the thief is unable to fill the knapsack to capacity, and the empty space lowers the effective value per bound of the load. In the 0-1 problem, when you consider whether to include an item in the knapsack, you must compare the solution to the subproblem that includes the item with the solution to the subproblem that excludes the item before you can make the choice. The problem formulated in this way gives rise to many overlapping subproblems--a hallmark of dynamic programming, and indeed, as Exercise 15.2-2 asks you to show, you can use dynamic programming to solve the 0-1 problem.\n\n### Exercises\n\n#### 15.2-1\n\nProve that the fractional knapsack problem has the greedy-choice property.\n\n#### 15.2-2\n\nGive a dynamic-programming solution to the 0-1 knapsack problem that runs in \\(O(n\\ W)\\) time, where \\(n\\) is the number of items and \\(W\\) is the maximum weight of items that the thief can put in the knapsack.\n\n#### 15.2-3\n\nSuppose that in a 0-1 knapsack problem, the order of the items when sorted by increasing weight is the same as their order when sorted by decreasing value. Give an efficient algorithm to find an optimal solution to this variant of the knapsack problem, and argue that your algorithm is correct.\n\n#### 15.2-4\n\nProfessor Gekko has always dreamed of inline skating across North Dakota. The professor plans to cross the state on highway U.S. 2, which runs from Grand Forks, on the eastern border with Minnesota, to Williston, near the western border with Montana. The professor can carry two litters of water and can skate \\(m\\) miles before\n\nFigure 15.3: An example showing that the greedy strategy does not work for the 0-1 knapsack problem. **(a)** The thief must select a subset of the three items shown whose weight must not exceed 50 pounds. **(b)** The optimal subset includes items 2 and 3. Any solution with item 1 is suboptimal, even though item 1 has the greatest value per pound. **(c)** For the fractional knapsack problem, taking the items in order of greatest value per pound yields an optimal solution.\n\nrunning out of water. (Because North Dakota is relatively flat, the professor does not have to worry about drinking water at a greater rate on uphill sections than on flat or downhill sections.) The professor will start in Grand Forks with two full liters of water. The professor has an official North Dakota state map, which shows all the places along U.S. 2 to refill water and the distances between these locations.\n\nThe professor's goal is to minimize the number of water stops along the route across the state. Give an efficient method by which the professor can determine which water stops to make. Prove that your strategy yields an optimal solution, and give its running time.\n\n_15.2-5_\n\nDescribe an efficient algorithm that, given a set \\(\\{x_{1},x_{2},\\ldots,x_{n}\\}\\) of points on the real line, determines the smallest set of unit-length closed intervals that contains all of the given points. Argue that your algorithm is correct.\n\n* _15.2-6_\n\nShow how to solve the fractional knapsack problem in \\(O(n)\\) time.\n\n_15.2-7_\n\nYou are given two sets \\(A\\) and \\(B\\), each containing \\(n\\) positive integers. You can choose to reorder each set however you like. After reordering, let \\(a_{i}\\) be the \\(i\\)th element of set \\(A\\), and let \\(b_{i}\\) be the \\(i\\)th element of set \\(B\\). You then receive a payoff of \\(\\prod_{i=1}^{n}{a_{i}}^{b_{i}}\\). Give an algorithm that maximizes your payoff. Prove that your algorithm maximizes the payoff, and state its running time, omitting the time for reordering the sets.\n\n### Huffman codes\n\nHuffman codes compress data well: savings of 20% to 90% are typical, depending on the characteristics of the data being compressed. The data arrive as a sequence of characters. Huffman's greedy algorithm uses a table giving how often each character occurs (its frequency) to build up an optimal way of representing each character as a binary string.\n\nSuppose that you have a 100,000-character data file that you wish to store compactly and you know that the 6 distinct characters in the file occur with the frequencies given by Figure 15.4. The character a occurs 45,000 times, the character b occurs 13,000 times, and so on.\n\nYou have many options for how to represent such a file of information. Here, we consider the problem of designing a _binary character code_ (or _code_ for short)",
        "chapter": "Part IV Advanced Design and Analysis Techniques",
        "section": "15 Greedy Algorithms",
        "subsection": "15.2 Elements of the greedy strategy",
        "subsubsection": "N/A"
    },
    {
        "content": "running out of water. (Because North Dakota is relatively flat, the professor does not have to worry about drinking water at a greater rate on uphill sections than on flat or downhill sections.) The professor will start in Grand Forks with two full liters of water. The professor has an official North Dakota state map, which shows all the places along U.S. 2 to refill water and the distances between these locations.\n\nThe professor's goal is to minimize the number of water stops along the route across the state. Give an efficient method by which the professor can determine which water stops to make. Prove that your strategy yields an optimal solution, and give its running time.\n\n_15.2-5_\n\nDescribe an efficient algorithm that, given a set \\(\\{x_{1},x_{2},\\ldots,x_{n}\\}\\) of points on the real line, determines the smallest set of unit-length closed intervals that contains all of the given points. Argue that your algorithm is correct.\n\n* _15.2-6_\n\nShow how to solve the fractional knapsack problem in \\(O(n)\\) time.\n\n_15.2-7_\n\nYou are given two sets \\(A\\) and \\(B\\), each containing \\(n\\) positive integers. You can choose to reorder each set however you like. After reordering, let \\(a_{i}\\) be the \\(i\\)th element of set \\(A\\), and let \\(b_{i}\\) be the \\(i\\)th element of set \\(B\\). You then receive a payoff of \\(\\prod_{i=1}^{n}{a_{i}}^{b_{i}}\\). Give an algorithm that maximizes your payoff. Prove that your algorithm maximizes the payoff, and state its running time, omitting the time for reordering the sets.\n\n### Huffman codes\n\nHuffman codes compress data well: savings of 20% to 90% are typical, depending on the characteristics of the data being compressed. The data arrive as a sequence of characters. Huffman's greedy algorithm uses a table giving how often each character occurs (its frequency) to build up an optimal way of representing each character as a binary string.\n\nSuppose that you have a 100,000-character data file that you wish to store compactly and you know that the 6 distinct characters in the file occur with the frequencies given by Figure 15.4. The character a occurs 45,000 times, the character b occurs 13,000 times, and so on.\n\nYou have many options for how to represent such a file of information. Here, we consider the problem of designing a _binary character code_ (or _code_ for short)in which each character is represented by a unique binary string, which we call a _codeword_. If you use a _fixed-length code_, you need \\(\\lceil\\lg n\\rceil\\) bits to represent \\(n\\geq 2\\) characters. For 6 characters, therefore, you need 3 bits: \\(\\mathtt{a}=000\\), \\(\\mathtt{b}=001\\), \\(\\mathtt{c}=010\\), \\(\\mathtt{d}=011\\), \\(\\mathtt{e}=100\\), and \\(\\mathtt{f}=101\\). This method requires 300,000 bits to encode the entire file. Can you do better?\n\nA _variable-length code_ can do considerably better than a fixed-length code. The idea is simple: give frequent characters short codewords and infrequent characters long codewords. Figure 15.4 shows such a code. Here, the 1-bit string 0 represents \\(\\mathtt{a}\\), and the 4-bit string 1100 represents \\(\\mathtt{f}\\). This code requires\n\n\\[(45\\cdot 1\\ +\\ 13\\cdot 3\\ +\\ 12\\cdot 3\\ +\\ 16\\cdot 3\\ +\\ 9\\cdot 4\\ +\\ 5 \\cdot 4)\\cdot 1,000=224,000\\ \\text{bits}\\]\n\nto represent the file, a savings of approximately 25%. In fact, this is an optimal character code for this file, as we shall see.\n\n#### Prefix-free codes\n\nWe consider here only codes in which no codeword is also a prefix of some other codeword. Such codes are called _prefix-free codes_. Although we won't prove it here, a prefix-free code can always achieve the optimal data compression among any character code, and so we suffer no loss of generality by restricting our attention to prefix-free codes.\n\nEncoding is always simple for any binary character code: just concatenate the codewords representing each character of the file. For example, with the variable-length prefix-free code of Figure 15.4, the 4-character file \\(\\mathtt{face}\\) has the encoding \\(1100\\cdot 0\\cdot 100\\cdot 1101=110001001101\\), where \"\\(\\cdot\\)\" denotes concatenation.\n\nPrefix-free codes are desirable because they simplify decoding. Since no codeword is a prefix of any other, the codeword that begins an encoded file is unambiguous. You can simply identify the initial codeword, translate it back to the original character, and repeat the decoding process on the remainder of the encoded file. In our example, the string \\(100011001101\\) parses uniquely as \\(100\\cdot 0\\cdot 1100\\cdot 1101\\), which decodes to \\(\\mathtt{cafe}\\).\n\nFigure 15.4: A character-coding problem. A data file of 100,000 characters contains only the characters \\(\\mathtt{a}\\)\u2013\\(\\mathtt{f}\\), with the frequencies indicated. With each character represented by a 3-bit codeword, encoding the file requires 300,000 bits. With the variable-length code shown, the encoding requires only 224,000 bits.\n\nThe decoding process needs a convenient representation for the prefix-free code so that you can easily pick off the initial codeword. A binary tree whose leaves are the given characters provides one such representation. Interpret the binary codeword for a character as the simple path from the root to that character, where 0 means \"go to the left child\" and 1 means \"go to the right child.\" Figure 15.5 shows the trees for the two codes of our example. Note that these are not binary search trees, since the leaves need not appear in sorted order and internal nodes do not contain character keys.\n\nAn optimal code for a file is always represented by a _full_ binary tree, in which every nonleaf node has two children (see Exercise 15.3-2). The fixed-length code in our example is not optimal since its tree, shown in Figure 15.5(a), is not a full binary tree: it contains codewords beginning with 10, but none beginning with 11. Since we can now restrict our attention to full binary trees, we can say that if \\(C\\) is the alphabet from which the characters are drawn and all character frequencies are positive, then the tree for an optimal prefix-free code has exactly \\(|C|\\) leaves, one for each letter of the alphabet, and exactly \\(|C|-1\\) internal nodes (see Exercise B.5-3 on page 1175).\n\nGiven a tree \\(T\\) corresponding to a prefix-free code, we can compute the number of bits required to encode a file. For each character \\(c\\) in the alphabet \\(C\\), let the attribute \\(c\\)_.freq_ denote the frequency of \\(c\\) in the file and let \\(d_{T}(c)\\) denote the depth of \\(c\\)'s leaf in the tree. Note that \\(d_{T}(c)\\) is also the length of the codeword for character \\(c\\). The number of bits required to encode a file is thus\n\nFigure 15.5: Trees corresponding to the coding schemes in Figure 15.4. Each leaf is labeled with a character and its frequency of occurrence. Each internal node is labeled with the sum of the frequencies of the leaves in its subtree. All frequencies are in thousands. **(a)** The tree corresponding to the fixed-length code \\(\\mathtt{a}=000\\), \\(\\mathtt{b}=001\\), \\(\\mathtt{c}=010\\), \\(\\mathtt{d}=011\\), \\(\\mathtt{e}=100\\), \\(\\mathtt{f}=101\\). **(b)** The tree corresponding to the optimal prefix-free code \\(\\mathtt{a}=0\\), \\(\\mathtt{b}=101\\), \\(\\mathtt{c}=100\\), \\(\\mathtt{d}=111\\), \\(\\mathtt{e}=1101\\), \\(\\mathtt{f}=1100\\).\n\n\\[B(T)=\\sum_{c\\in C}c\\,.\\mathit{freq}\\cdot d_{T}(c)\\, \\tag{15.4}\\]\n\nwhich we define as the _cost_ of the tree \\(T\\).\n\n### Constructing a Huffman code\n\nHuffman invented a greedy algorithm that constructs an optimal prefix-free code, called a _Huffman code_ in his honor. In line with our observations in Section 15.2, its proof of correctness relies on the greedy-choice property and optimal substructure. Rather than demonstrating that these properties hold and then developing pseudocode, we present the pseudocode first. Doing so will help clarify how the algorithm makes greedy choices.\n\nThe procedure Huffman assumes that \\(C\\) is a set of \\(n\\) characters and that each character \\(c\\in C\\) is an object with an attribute \\(c\\,.\\mathit{freq}\\) giving its frequency. The algorithm builds the tree \\(T\\) corresponding to an optimal code in a bottom-up manner. It begins with a set of \\(|C\\,|\\) leaves and performs a sequence of \\(|C\\,|-1\\) \"merging\" operations to create the final tree. The algorithm uses a min-priority queue \\(Q\\), keyed on the _freq_ attribute, to identify the two least-frequent objects to merge together. The result of merging two objects is a new object whose frequency is the sum of the frequencies of the two objects that were merged.\n\n```\nHuffman(\\(C\\))\n1\\(n=|C|\\)\n2\\(Q=C\\)\n3for\\(i=1\\)to\\(n-1\\)\n4allocate a new node \\(z\\)\n5\\(x=\\textsc{Extract-Min}(Q)\\)\n6\\(y=\\textsc{Extract-Min}(Q)\\)\n7\\(z.\\mathit{left}=x\\)\n8\\(z.\\mathit{right}=y\\)\n9\\(z.\\mathit{freq}=x.\\mathit{freq}+y.\\mathit{freq}\\)\n10\\(\\textsc{Insert}(Q,z)\\)\n11returnExtract-Min(\\(Q\\)) // the root of the tree is the only node left\n```\n\nFor our example, Huffman's algorithm proceeds as shown in Figure 15.6. Since the alphabet contains 6 letters, the initial queue size is \\(n=6\\), and 5 merge steps build the tree. The final tree represents the optimal prefix-free code. The codeword for a letter is the sequence of edge labels on the simple path from the root to the letter.\n\n### 15.3 Huffman codes\n\nThe Huffman procedure works as follows. Line 2 initializes the min-priority queue \\(Q\\) with the characters in \\(C\\). The **for** loop in lines 3-10 repeatedly extracts the two nodes \\(x\\) and \\(y\\) of lowest frequency from the queue and replaces them in the queue with a new node \\(z\\) representing their merger. The frequency of \\(z\\) is computed as the sum of the frequencies of \\(x\\) and \\(y\\) in line 9. The node \\(z\\) has \\(x\\) as its left child and \\(y\\) as its right child. (This order is arbitrary. Switching the left and right child of any node yields a different code of the same cost.) After \\(n-1\\) mergers, line 11 returns the one node left in the queue, which is the root of the code tree.\n\nFigure 15.6: The steps of Huffman\u2019s algorithm for the frequencies given in Figure 15.4. Each part shows the contents of the queue sorted into increasing order by frequency. Each step merges the two trees with the lowest frequencies. Leaves are shown as rectangles containing a character and its frequency. Internal nodes are shown as circles containing the sum of the frequencies of their children. An edge connecting an internal node with its children is labeled \\(0\\) if it is an edge to a left child and \\(1\\) if it is an edge to a right child. The codeword for a letter is the sequence of labels on the edges connecting the root to the leaf for that letter. **(a)** The initial set of \\(n=6\\) nodes, one for each letter. **(b)\u2013(e)** Intermediate stages. **(f)** The final tree.\n\nThe algorithm produces the same result without the variables \\(x\\) and \\(y\\), assigning the values returned by the Extract-Min calls directly to \\(z\\)._left_ and \\(z\\)._right_ in lines 7 and 8, and changing line 9 to \\(z\\)._freq_\\(=z\\)._left_,_freq_\\(+z\\)._right_,_freq_. We'll use the node names \\(x\\) and \\(y\\) in the proof of correctness, however, so we leave them in.\n\nThe running time of Huffman's algorithm depends on how the min-priority queue \\(Q\\) is implemented. Let's assume that it's implemented as a binary min-heap (see Chapter 6). For a set \\(C\\) of \\(n\\) characters, the Build-Min-Heap procedure discussed in Section 6.3 can initialize \\(Q\\) in line 2 in \\(O(n)\\) time. The **for** loop in lines 3-10 executes exactly \\(n-1\\) times, and since each heap operation runs in \\(O(\\lg n)\\) time, the loop contributes \\(O(n\\lg n)\\) to the running time. Thus, the total running time of Huffman on a set of \\(n\\) characters is \\(O(n\\lg n)\\).\n\n### Correctness of Huffman's algorithm\n\nTo prove that the greedy algorithm Huffman is correct, we'll show that the problem of determining an optimal prefix-free code exhibits the greedy-choice and optimal-substructure properties. The next lemma shows that the greedy-choice property holds.\n\n_Lemma 15.2 (Optimal prefix-free codes have the greedy-choice property)_\n\nLet \\(C\\) be an alphabet in which each character \\(c\\in C\\) has frequency \\(c\\)._freq_. Let \\(x\\) and \\(y\\) be two characters in \\(C\\) having the lowest frequencies. Then there exists an optimal prefix-free code for \\(C\\) in which the codewords for \\(x\\) and \\(y\\) have the same length and differ only in the last bit.\n\n_Proof_ The idea of the proof is to take the tree \\(T\\) representing an arbitrary optimal prefix-free code and modify it to make a tree representing another optimal prefix-free code such that the characters \\(x\\) and \\(y\\) appear as sibling leaves of maximum depth in the new tree. In such a tree, the codewords for \\(x\\) and \\(y\\) have the same length and differ only in the last bit.\n\nLet \\(a\\) and \\(b\\) be any two characters that are sibling leaves of maximum depth in \\(T\\). Without loss of generality, assume that \\(a\\)._freq_\\(\\leq b\\)._freq_ and \\(x\\)._freq_\\(\\leq y\\)._freq_. Since \\(x\\)._freq_ and \\(y\\)._freq_ are the two lowest leaf frequencies, in order, and \\(a\\)._freq_ and \\(b\\)._freq_ are two arbitrary frequencies, in order, we have \\(x\\)._freq_\\(\\leq a\\)._freq_ and \\(y\\)._freq_\\(\\leq b\\)._freq_.\n\nIn the remainder of the proof, it is possible that we could have \\(x\\)._freq_\\(=a\\)._freq_ or \\(y\\)._freq_\\(=b\\)._freq_, but \\(x\\)._freq_\\(=b\\)._freq_ implies that \\(a\\)._freq_\\(=b\\)._freq_\\(=x\\)._freq_\\(=y\\)._freq_ (see Exercise 15.3-1), and the lemma would be trivially true. Therefore, assume that \\(x\\)._freq_\\(\\neq b\\)._freq_, which means that \\(x\\neq b\\).\n\nAs Figure 15.7 shows, imagine exchanging the positions in \\(T\\) of \\(a\\) and \\(x\\) to produce a tree \\(T^{\\prime}\\), and then exchanging the positions in \\(T^{\\prime}\\) of \\(b\\) and \\(y\\) to produce a tree \\(T^{\\prime\\prime}\\) in which \\(x\\) and \\(y\\) are sibling leaves of maximum depth. (Note that if \\(x=b\\) but \\(y\\neq a\\), then tree \\(T^{\\prime\\prime}\\) does not have \\(x\\) and \\(y\\) as sibling leaves of maximum depth. Because we assume that \\(x\\neq b\\), this situation cannot occur.) By equation (15.4), the difference in cost between \\(T\\) and \\(T^{\\prime}\\) is\n\n\\[B(T) -B(T^{\\prime})\\] \\[= \\sum_{c\\in C}c\\,.\\mathit{freq}\\cdot d_{T}(c)-\\sum_{c\\in C}c\\,. \\mathit{freq}\\cdot d_{T^{\\prime}}(c)\\] \\[= x\\,.\\mathit{freq}\\cdot d_{T}(x)+a\\,.\\mathit{freq}\\cdot d_{T}(a )-x\\,.\\mathit{freq}\\cdot d_{T^{\\prime}}(x)-a\\,.\\mathit{freq}\\cdot d_{T^{ \\prime}}(a)\\] \\[= x\\,.\\mathit{freq}\\cdot d_{T}(x)+a\\,.\\mathit{freq}\\cdot d_{T}(a )-x\\,.\\mathit{freq}\\cdot d_{T}(a)-a\\,.\\mathit{freq}\\cdot d_{T}(x)\\] \\[= (a\\,.\\mathit{freq}-x\\,.\\mathit{freq})(d_{T}(a)-d_{T}(x))\\] \\[\\geq 0\\,\\]\n\nbecause both \\(a\\,.\\mathit{freq}-x\\,.\\mathit{freq}\\) and \\(d_{T}(a)-d_{T}(x)\\) are nonnegative. More specifically, \\(a\\,.\\mathit{freq}-x\\,.\\mathit{freq}\\) is nonnegative because \\(x\\) is a minimum-frequency leaf, and \\(d_{T}(a)-d_{T}(x)\\) is nonnegative because \\(a\\) is a leaf of maximum depth in \\(T\\). Similarly, exchanging \\(y\\) and \\(b\\) does not increase the cost, and so \\(B(T^{\\prime})-B(T^{\\prime\\prime})\\) is nonnegative. Therefore, \\(B(T^{\\prime\\prime})\\leq B(T^{\\prime})\\leq B(T)\\), and since \\(T\\) is optimal, we have \\(B(T)\\leq B(T^{\\prime\\prime})\\), which implies \\(B(T^{\\prime\\prime})=B(T)\\). Thus, \\(T^{\\prime\\prime}\\) is an optimal tree in which \\(x\\) and \\(y\\) appear as sibling leaves of maximum depth, from which the lemma follows.\n\nLemma 15.2 implies that the process of building up an optimal tree by mergers can, without loss of generality, begin with the greedy choice of merging together those two characters of lowest frequency. Why is this a greedy choice? We can view the cost of a single merger as being the sum of the frequencies of the two items being merged. Exercise 15.3-4 shows that the total cost of the tree constructed equals the sum of the costs of its mergers. Of all possible mergers at each step, Huffman chooses the one that incurs the least cost.\n\nFigure 15.7: An illustration of the key step in the proof of Lemma 15.2. In the optimal tree \\(T\\), leaves \\(a\\) and \\(b\\) are two siblings of maximum depth. Leaves \\(x\\) and \\(y\\) are the two characters with the lowest frequencies. They appear in arbitrary positions in \\(T\\). Assuming that \\(x\\neq b\\), swapping leaves \\(a\\) and \\(x\\) produces tree \\(T^{\\prime}\\), and then swapping leaves \\(b\\) and \\(y\\) produces tree \\(T^{\\prime\\prime}\\). Since each swap does not increase the cost, the resulting tree \\(T^{\\prime\\prime}\\) is also an optimal tree.\n\nThe next lemma shows that the problem of constructing optimal prefix-free codes has the optimal-substructure property.\n\n**Lemma 15.3** (Optimal prefix-free codes have the optimal-substructure property): _Let \\(C\\) be a given alphabet with frequency \\(c\\).freq defined for each character \\(c\\in C\\). Let \\(x\\) and \\(y\\) be two characters in \\(C\\) with minimum frequency. Let \\(C^{\\prime}\\) be the alphabet \\(C\\) with the characters \\(x\\) and \\(y\\) removed and a new character \\(z\\) added, so that \\(C^{\\prime}=(C-\\{x,\\,y\\})\\cup\\{z\\}\\). Definefreq for all characters in \\(C^{\\prime}\\) with the same values as in \\(C\\), along with \\(z\\).freq\\(=x\\).freq\\(+\\)y.freq. Let \\(T^{\\prime}\\) be any tree representing an optimal prefix-free code for alphabet \\(C^{\\prime}\\). Then the tree \\(T\\), obtained from \\(T^{\\prime}\\) by replacing the leaf node for \\(z\\) with an internal node having \\(x\\) and \\(y\\) as children, represents an optimal prefix-free code for the alphabet \\(C\\)._\n\nProof.: We first show how to express the cost \\(B(T)\\) of tree \\(T\\) in terms of the cost \\(B(T^{\\prime})\\) of tree \\(T^{\\prime}\\), by considering the component costs in equation (15.4). For each character \\(c\\in C-\\{x,\\,y\\}\\), we have that \\(d_{T}(c)=d_{T^{\\prime}}(c)\\), and hence \\(c\\).freq\\(\\cdot\\)\\(d_{T}(c)=c\\).freq\\(\\cdot\\)\\(d_{T^{\\prime}}(c)\\). Since \\(d_{T}(x)=d_{T}(y)=d_{T^{\\prime}}(z)+1\\), we have\n\n\\[x\\).freq\\(\\cdot\\)\\(d_{T}(x)+y\\).freq\\(\\cdot\\)\\(d_{T}(y) = (x\\).freq\\(+\\)y.freq\\()(d_{T^{\\prime}}(z)+1)\\] \\[= z\\).freq\\(\\cdot\\)\\(d_{T^{\\prime}}(z)+(x\\).freq\\(+\\)y.freq\\()\\), from which we conclude that \\(B(T)=B(T^{\\prime})+x\\).freq\\(+\\)y.freq or, equivalently, \\(B(T^{\\prime})=B(T)-x\\).freq\\(-\\)y.freq. We now prove the lemma by contradiction. Suppose that \\(T\\) does not represent an optimal prefix-free code for \\(C\\). Then there exists an optimal tree \\(T^{\\prime\\prime}\\) such that \\(B(T^{\\prime\\prime})<B(T)\\). Without loss of generality (by Lemma 15.2), \\(T^{\\prime\\prime}\\) has \\(x\\) and \\(y\\) as siblings. Let \\(T^{\\prime\\prime\\prime}\\) be the tree \\(T^{\\prime\\prime}\\) with the common parent of \\(x\\) and \\(y\\) replaced by a leaf \\(z\\) with frequency \\(z\\).freq\\(=x\\).freq\\(+\\)y.freq. Then \\(B(T^{\\prime\\prime\\prime})\\)\\(=\\)\\(B(T^{\\prime\\prime})-x\\).freq\\(-\\)y.freq\\(<\\)B(T)\\(-\\)x.freq\\(-\\)y.freq\\(=\\)\\(B(T^{\\prime})\\), yielding a contradiction to the assumption that \\(T^{\\prime}\\) represents an optimal prefix-free code for \\(C^{\\prime}\\). Thus, \\(T\\) must represent an optimal prefix-free code for the alphabet \\(C\\). \n\n**Theorem 15.4**: _Procedure Huffman produces an optimal prefix-free code.__Proof_ Immediate from Lemmas 15.2 and 15.3.\n\n**Exercises**\n\n_15.3-1_\n\nExplain why, in the proof of Lemma 15.2, if \\(x\\,.\\,\\mathit{freq}=b\\,.\\,\\mathit{freq}\\), then we must have \\(a\\,.\\,\\mathit{freq}=b\\,.\\,\\mathit{freq}=x\\,.\\,\\mathit{freq}=y\\,.\\,\\mathit{freq}\\).\n\n_15.3-2_\n\nProve that a non-full binary tree cannot correspond to an optimal prefix-free code.\n\n_15.3-3_\n\nWhat is an optimal Huffman code for the following set of frequencies, based on the first 8 Fibonacci numbers?\n\na:1 b:1 c:2 d:3 e:5 f:8 g:13 h:21\n\nCan you generalize your answer to find the optimal code when the frequencies are the first \\(n\\) Fibonacci numbers?\n\n_15.3-4_\n\nProve that the total cost \\(B(T)\\) of a full binary tree \\(T\\) for a code equals the sum, over all internal nodes, of the combined frequencies of the two children of the node.\n\n_15.3-5_\n\nGiven an optimal prefix-free code on a set \\(C\\) of \\(n\\) characters, you wish to transmit the code itself using as few bits as possible. Show how to represent any optimal prefix-free code on \\(C\\) using only \\(2n-1+n\\,\\lceil\\lg n\\rceil\\) bits. (_Hint:_ Use \\(2n-1\\) bits to specify the structure of the tree, as discovered by a walk of the tree.)\n\n_15.3-6_\n\nGeneralize Huffman's algorithm to ternary codewords (i.e., codewords using the symbols 0, 1, and 2), and prove that it yields optimal ternary codes.\n\n_15.3-7_\n\nA data file contains a sequence of 8-bit characters such that all 256 characters are about equally common: the maximum character frequency is less than twice the minimum character frequency. Prove that Huffman coding in this case is no more efficient than using an ordinary 8-bit fixed-length code.\n\n_15.3-8_\n\nShow that no lossless (invertible) compression scheme can guarantee that for every input file, the corresponding output file is shorter. (_Hint:_ Compare the number of possible files with the number of possible encoded files.)\n\n### 15.4 Offline caching\n\nComputer systems can decrease the time to access data by storing a subset of the main memory in the _cache_: a small but faster memory. A cache organizes data into _cache blocks_ typically comprising 32, 64, or 128 bytes. You can also think of main memory as a cache for disk-resident data in a virtual-memory system. Here, the blocks are called _pages_, and 4096 bytes is a typical size.\n\nAs a computer program executes, it makes a sequence of memory requests. Say that there are \\(n\\) memory requests, to data in blocks \\(b_{1},b_{2},\\ldots,b_{n}\\), in that order. The blocks in the access sequence might not be distinct, and indeed, any given block is usually accessed multiple times. For example, a program that accesses four distinct blocks \\(p,q,r,s\\) might make a sequence of requests to blocks \\(s,q,s,q,q,s\\), \\(p,p,r\\), \\(s,s,q\\), \\(p,r,q\\). The cache can hold up to some fixed number \\(k\\) of cache blocks. It starts out empty before the first request. Each request causes at most one block to enter the cache and at most one block to be evicted from the cache. Upon a request for block \\(b_{i}\\), any one of three scenarios may occur:\n\n1. Block \\(b_{i}\\) is already in the cache, due to a previous request for the same block. The cache remains unchanged. This situation is known as a _cache hit_.\n2. Block \\(b_{i}\\) is not in the cache at that time, but the cache contains fewer than \\(k\\) blocks. In this case, block \\(b_{i}\\) is placed into the cache, so that the cache contains one more block than it did before the request.\n3. Block \\(b_{i}\\) is not in the cache at that time and the cache is full: it contains \\(k\\) blocks. Block \\(b_{i}\\) is placed into the cache, but before that happens, some other block in the cache must be evicted from the cache in order to make room.\n\nThe latter two situations, in which the requested block is not already in the cache, are called _cache misses_. The goal is to minimize the number of cache misses or, equivalently, to maximize the number of cache hits, over the entire sequence of \\(n\\) requests. A cache miss that occurs while the cache holds fewer than \\(k\\) blocks--that is, as the cache is first being filled up--is known as a _compulsory miss_, since no prior decision could have kept the requested block in the cache. When a cache miss occurs and the cache is full, ideally the choice of which block to evict should allow for the smallest possible number of cache misses over the entire sequence of future requests.\n\nTypically, caching is an online problem. That is, the computer has to decide which blocks to keep in the cache without knowing the future requests. Here, however, let's consider the offline version of this problem, in which the computer knows in advance the entire sequence of \\(n\\) requests and the cache size \\(k\\), with a goal of minimizing the total number of cache misses.",
        "chapter": "Part IV Advanced Design and Analysis Techniques",
        "section": "15 Greedy Algorithms",
        "subsection": "15.3 Huffman codes",
        "subsubsection": "N/A"
    },
    {
        "content": "### 15.4 Offline caching\n\nComputer systems can decrease the time to access data by storing a subset of the main memory in the _cache_: a small but faster memory. A cache organizes data into _cache blocks_ typically comprising 32, 64, or 128 bytes. You can also think of main memory as a cache for disk-resident data in a virtual-memory system. Here, the blocks are called _pages_, and 4096 bytes is a typical size.\n\nAs a computer program executes, it makes a sequence of memory requests. Say that there are \\(n\\) memory requests, to data in blocks \\(b_{1},b_{2},\\ldots,b_{n}\\), in that order. The blocks in the access sequence might not be distinct, and indeed, any given block is usually accessed multiple times. For example, a program that accesses four distinct blocks \\(p,q,r,s\\) might make a sequence of requests to blocks \\(s,q,s,q,q,s\\), \\(p,p,r\\), \\(s,s,q\\), \\(p,r,q\\). The cache can hold up to some fixed number \\(k\\) of cache blocks. It starts out empty before the first request. Each request causes at most one block to enter the cache and at most one block to be evicted from the cache. Upon a request for block \\(b_{i}\\), any one of three scenarios may occur:\n\n1. Block \\(b_{i}\\) is already in the cache, due to a previous request for the same block. The cache remains unchanged. This situation is known as a _cache hit_.\n2. Block \\(b_{i}\\) is not in the cache at that time, but the cache contains fewer than \\(k\\) blocks. In this case, block \\(b_{i}\\) is placed into the cache, so that the cache contains one more block than it did before the request.\n3. Block \\(b_{i}\\) is not in the cache at that time and the cache is full: it contains \\(k\\) blocks. Block \\(b_{i}\\) is placed into the cache, but before that happens, some other block in the cache must be evicted from the cache in order to make room.\n\nThe latter two situations, in which the requested block is not already in the cache, are called _cache misses_. The goal is to minimize the number of cache misses or, equivalently, to maximize the number of cache hits, over the entire sequence of \\(n\\) requests. A cache miss that occurs while the cache holds fewer than \\(k\\) blocks--that is, as the cache is first being filled up--is known as a _compulsory miss_, since no prior decision could have kept the requested block in the cache. When a cache miss occurs and the cache is full, ideally the choice of which block to evict should allow for the smallest possible number of cache misses over the entire sequence of future requests.\n\nTypically, caching is an online problem. That is, the computer has to decide which blocks to keep in the cache without knowing the future requests. Here, however, let's consider the offline version of this problem, in which the computer knows in advance the entire sequence of \\(n\\) requests and the cache size \\(k\\), with a goal of minimizing the total number of cache misses.\n\n### Offline caching\n\nTo solve this offline problem, you can use a greedy strategy called _furthest-in-future_, which chooses to evict the block in the cache whose next access in the request sequence comes furthest in the future. Intuitively, this strategy makes sense: if you're not going to need something for a while, why keep it around? We'll show that the furthest-in-future strategy is indeed optimal by showing that the offline caching problem exhibits optimal substructure and that furthest-in-future has the greedy-choice property.\n\nNow, you might be thinking that since the computer usually doesn't know the sequence of requests in advance, there is no point in studying the offline problem. Actually, there is. In some situations, you do know the sequence of requests in advance. For example, if you view the main memory as the cache and the full set of data as residing on disk (or a solid-state drive), there are algorithms that plan out the entire set of reads and writes in advance. Furthermore, we can use the number of cache misses produced by an optimal algorithm as a baseline for comparing how well online algorithms perform. We'll do just that in Section 27.3.\n\nOffline caching can even model real-world problems. For example, consider a scenario where you know in advance a fixed schedule of \\(n\\) events at known locations. Events may occur at a location multiple times, not necessarily consecutively. You are managing a group of \\(k\\) agents, you need to ensure that you have one agent at each location when an event occurs, and you want to minimize the number of times that agents have to move. Here, the agents are like the blocks, the events are like the requests, and moving an agent is akin to a cache miss.\n\n#### Optimal substructure of offline caching\n\nTo show that the offline problem exhibits optimal substructure, let's define the subproblem \\((C,i)\\) as processing requests for blocks \\(b_{i},b_{i+1},\\ldots,b_{n}\\) with cache configuration \\(C\\) at the time that the request for block \\(b_{i}\\) occurs, that is, \\(C\\) is a subset of the set of blocks such that \\(|C\\,|\\leq k\\). A solution to subproblem \\((C,i)\\) is a sequence of decisions that specifies which block to evict (if any) upon each request for blocks \\(b_{i},b_{i+1},\\ldots,b_{n}\\). An optimal solution to subproblem \\((C,i)\\) minimizes the number of cache misses.\n\nConsider an optimal solution \\(S\\) to subproblem \\((C,i)\\), and let \\(C^{\\prime}\\) be the contents of the cache after processing the request for block \\(b_{i}\\) in solution \\(S\\). Let \\(S^{\\prime}\\) be the subsolution of \\(S\\) for the resulting subproblem \\((C^{\\prime},i\\,+1)\\). If the request for \\(b_{i}\\) results in a cache hit, then the cache remains unchanged, so that \\(C^{\\prime}=C\\). If the request for block \\(b_{i}\\) results in a cache miss, then the contents of the cache change, so that \\(C^{\\prime}\\neq C\\). We claim that in either case, \\(S^{\\prime}\\) is an optimal solution to subproblem \\((C^{\\prime},i\\,+1)\\). Why? If \\(S^{\\prime}\\) is not an optimal solution to subproblem \\((C^{\\prime},i\\,+1)\\), then there exists another solution \\(S^{\\prime\\prime}\\) to subproblem \\((C^{\\prime},i\\,+1)\\) that makes fewer cache misses than \\(S^{\\prime}\\). Combining \\(S^{\\prime\\prime}\\) with the decision of \\(S\\) at the request forblock \\(b_{i}\\) yields another solution that makes fewer cache misses than \\(S\\), which contradicts the assumption that \\(S\\) is an optimal solution to subproblem \\((C,i)\\).\n\nTo quantify a recursive solution, we need a little more notation. Let \\(R_{C,i}\\) be the set of all cache configurations that can immediately follow configuration \\(C\\) after processing a request for block \\(b_{i}\\). If the request results in a cache hit, then the cache remains unchanged, so that \\(R_{C,i}=\\{C\\}\\). If the request for \\(b_{i}\\) results in a cache miss, then there are two possibilities. If the cache is not full (\\(|C|<k\\)), then the cache is filling up and the only choice is to insert \\(b_{i}\\) into the cache, so that \\(R_{C,i}=\\{C\\cup\\{b_{i}\\}\\}\\). If the cache is full (\\(|C|=k\\)) upon a cache miss, then \\(R_{C,i}\\) contains \\(k\\) potential configurations: one for each candidate block in \\(C\\) that could be evicted and replaced by block \\(b_{i}\\). In this case, \\(R_{C,i}=\\{(C-\\{x\\})\\cup\\{b_{i}\\}:x\\in C\\}\\). For example, if \\(C=\\{p,q,r\\}\\), \\(k=3\\), and block \\(s\\) is requested, then \\(R_{C,i}=\\{\\{p,q,s\\},\\{p,r,s\\},\\{q,r,s\\}\\}\\).\n\nLet \\(miss(C,i)\\) denote the minimum number of cache misses in a solution for subproblem \\((C,i)\\). Here is a recurrence for \\(miss(C,i)\\):\n\n\\[miss(C,i)=\\left\\{\\begin{array}{ll}0&\\mbox{if $i=n$ and $b_{n}\\in C$,}\\\\ 1&\\mbox{if $i=n$ and $b_{n}\\not\\in C$,}\\\\ \\mbox{\\it miss}(C,i+1)&\\mbox{if $i<n$ and $b_{i}\\in C$,}\\\\ 1+\\min\\{miss(C^{\\prime},i+1):C^{\\prime}\\in R_{C,i}\\}&\\mbox{if $i<n$ and $b_{i}\\not\\in C$.}\\end{array}\\right.\\]\n\n### Greedy-choice property\n\nTo prove that the furthest-in-future strategy yields an optimal solution, we need to show that optimal offline caching exhibits the greedy-choice property. Combined with the optimal-substructure property, the greedy-choice property will prove that furthest-in-future produces the minimum possible number of cache misses.\n\n**Theorem 15.5** (Optimal offline caching has the greedy-choice property): _Consider a subproblem \\((C,i)\\) when the cache \\(C\\) contains \\(k\\) blocks, so that it is full, and a cache miss occurs. When block \\(b_{i}\\) is requested, let \\(z=b_{m}\\) be the block in \\(C\\) whose next access is furthest in the future. (If some block in the cache will never again be referenced, then consider any such block to be block \\(z\\), and add a dummy request for block \\(z=b_{m}=b_{n+1}\\).) Then evicting block \\(z\\) upon a request for block \\(b_{i}\\) is included in some optimal solution for the subproblem \\((C,i)\\)._\n\nProofLet \\(S\\) be an optimal solution to subproblem \\((C,i)\\). If \\(S\\) evicts block \\(z\\) upon the request for block \\(b_{i}\\), then we are done, since we have shown that some optimal solution includes evicting \\(z\\).\n\nSo now suppose that optimal solution \\(S\\) evicts some other block \\(x\\) when block \\(b_{i}\\) is requested. We'll construct another solution \\(S^{\\prime}\\) to subproblem \\((C,i)\\) which, upon the request for \\(b_{i}\\), evicts block \\(z\\) instead of \\(x\\) and induces no more cache misses than \\(S\\) does, so that \\(S^{\\prime}\\) is also optimal. Because different solutions may yield different cache configurations, denote by \\(C_{S,j}\\) the configuration of the cache under solution \\(S\\) just before the request for some block \\(b_{j}\\), and likewise for solution \\(S^{\\prime}\\) and \\(C_{S^{\\prime},j}\\). We'll show how to construct \\(S^{\\prime}\\) with the following properties:\n\n1. For \\(j=i+1,\\ldots,m\\), let \\(D_{j}=C_{S,j}\\cap C_{S^{\\prime},j}\\). Then, \\(|D_{j}|\\geq k-1\\), so that the cache configurations \\(C_{S,j}\\) and \\(C_{S^{\\prime},j}\\) differ by at most one block. If they differ, then \\(C_{S,j}=D_{j}\\cup\\{z\\}\\) and \\(C_{S^{\\prime},j}=D_{j}\\cup\\{y\\}\\) for some block \\(y\\neq z\\).\n2. For each request of blocks \\(b_{i},\\ldots,b_{m-1}\\), if solution \\(S\\) has a cache hit, then solution \\(S^{\\prime}\\) also has a cache hit.\n3. For all \\(j>m\\), the cache configurations \\(C_{S,j}\\) and \\(C_{S^{\\prime},j}\\) are identical.\n4. Over the sequence of requests for blocks \\(b_{i},\\ldots,b_{m}\\), the number of cache misses produced by solution \\(S^{\\prime}\\) is at most the number of cache misses produced by solution \\(S\\).\n\nWe'll prove inductively that these properties hold for each request.\n\n1. We proceed by induction on \\(j\\), for \\(j=i+1,\\ldots,m\\). For the base case, the initial caches \\(C_{S,i}\\) and \\(C_{S^{\\prime},i}\\) are identical. Upon the request for block \\(b_{i}\\), solution \\(S\\) evicts \\(x\\) and solution \\(S^{\\prime}\\) evicts \\(z\\). Thus, cache configurations \\(C_{S,i+1}\\) and \\(C_{S^{\\prime},i+1}\\) differ by just one block, \\(C_{S,i+1}=D_{i+1}\\cup\\{z\\}\\), \\(C_{S^{\\prime},i+1}=D_{i+1}\\cup\\{x\\}\\), and \\(x\\neq z\\). The inductive step defines how solution \\(S^{\\prime}\\) behaves upon a request for block \\(b_{j}\\) for \\(i+1\\leq j\\leq m-1\\). The inductive hypothesis is that property 1 holds when \\(b_{j}\\) is requested. Because \\(z=b_{m}\\) is the block in \\(C_{S,i}\\) whose next reference is furthest in the future, we know that \\(b_{j}\\neq z\\). We consider several scenarios:\n\n* If \\(C_{S,j}=C_{S^{\\prime},j}\\) (so that \\(|D_{j}|=k\\)), then solution \\(S^{\\prime}\\) makes the same decision upon the request for \\(b_{j}\\) as \\(S\\) makes, so that \\(C_{S,j+1}=C_{S^{\\prime},j+1}\\).\n* If \\(|D_{j}|=k-1\\) and \\(b_{j}\\in D_{j}\\), then both caches already contain block \\(b_{j}\\), and both solutions \\(S\\) and \\(S^{\\prime}\\) have cache hits. Therefore, \\(C_{S,j+1}=C_{S,j}\\) and \\(C_{S^{\\prime},j+1}=C_{S^{\\prime},j}\\).\n* If \\(|D_{j}|=k-1\\) and \\(b_{j}\\notin D_{j}\\), then because \\(C_{S,j}=D_{j}\\cup\\{z\\}\\) and \\(b_{j}\\neq z\\), solution \\(S\\) has a cache miss. It evicts either block \\(z\\) or some block \\(w\\in D_{j}\\).\n* If solution \\(S\\) evicts block \\(z\\), then \\(C_{S,j+1}=D_{j}\\cup\\{b_{j}\\}\\). There are two cases, depending on whether \\(b_{j}=y\\):\n* If \\(b_{j}=y\\), then solution \\(S^{\\prime}\\) has a cache hit, so that \\(C_{S^{\\prime},j+1}=C_{S^{\\prime},j}=D_{j}\\cup\\{b_{j}\\}\\). Thus, \\(C_{S,j+1}=C_{S^{\\prime},j+1}\\).\n* If \\(b_{j}\\neq y\\), then solution \\(S^{\\prime}\\) has a cache miss. It evicts block \\(y\\), so that \\(C_{S^{\\prime},j+1}=D_{j}\\cup\\{b_{j}\\}\\), and again \\(C_{S,j+1}=C_{S^{\\prime},j+1}\\).\n* If solution \\(S\\) evicts some block \\(w\\in D_{j}\\), then \\(C_{S,j+1}=(D_{j}-\\{w\\})\\cup\\{b_{j},z\\}\\). Once again, there are two cases, depending on whether \\(b_{j}=y\\):\n* If \\(b_{j}=y\\), then solution \\(S^{\\prime}\\) has a cache hit, so that \\(C_{S^{\\prime},j+1}=C_{S^{\\prime},j}=D_{j}\\cup\\{b_{j}\\}\\). Since \\(w\\in D_{j}\\) and \\(w\\) was not evicted by solution \\(S^{\\prime}\\), we have \\(w\\in C_{S^{\\prime},j+1}\\). Therefore, \\(w\\notin D_{j+1}\\) and \\(b_{j}\\in D_{j+1}\\), so that \\(D_{j+1}=(D_{j}-\\{w\\})\\cup\\{b_{j}\\}\\). Thus, \\(C_{S,j+1}=D_{j+1}\\cup\\{z\\}\\), \\(C_{S^{\\prime},j+1}=D_{j+1}\\cup\\{w\\}\\), and because \\(w\\neq z\\), property 1 holds when block \\(b_{j+1}\\) is requested. (In other words, block \\(w\\) replaces block \\(y\\) in property 1.)\n* If \\(b_{j}\\neq y\\), then solution \\(S^{\\prime}\\) has a cache miss. It evicts block \\(w\\), so that \\(C_{S^{\\prime},j+1}=(D_{j}-\\{w\\})\\cup\\{b_{j},y\\}\\). Therefore, we have that \\(D_{j+1}=(D_{j}-\\{w\\})\\cup\\{b_{j}\\}\\) and so \\(C_{S,j+1}=D_{j+1}\\cup\\{z\\}\\) and \\(C_{S^{\\prime},j+1}=D_{j+1}\\cup\\{y\\}\\).\n2. In the above discussion about maintaining property 1, solution \\(S\\) may have a cache hit in only the first two cases, and solution \\(S^{\\prime}\\) has a cache hit in these cases if and only if \\(S\\) does.\n3. If \\(C_{S,m}=C_{S^{\\prime},m}\\), then solution \\(S^{\\prime}\\) makes the same decision upon the request for block \\(z=b_{m}\\) as \\(S\\) makes, so that \\(C_{S,m+1}=C_{S^{\\prime},m+1}\\). If \\(C_{S,m}\\neq C_{S^{\\prime},m}\\), then by property 1, \\(C_{S,m}=D_{m}\\cup\\{z\\}\\) and \\(C_{S^{\\prime},m}=D_{m}\\cup\\{y\\}\\), where \\(y\\neq z\\). In this case, solution \\(S\\) has a cache hit, so that \\(C_{S,m+1}=C_{S,m}=D_{m}\\cup\\{z\\}\\). Solution \\(S^{\\prime}\\) evicts block \\(y\\) and brings in block \\(z\\), so that \\(C_{S^{\\prime},m+1}=D_{m}\\cup\\{z\\}=C_{S,m+1}\\). Thus, regardless of whether or not \\(C_{S,m}=C_{S^{\\prime},m}\\), we have \\(C_{S,m+1}=C_{S^{\\prime},m+1}\\), and starting with the request for block \\(b_{m+1}\\), solution \\(S^{\\prime}\\) simply makes the same decisions as \\(S\\).\n4. By property 2, upon the requests for blocks \\(b_{i},\\ldots,b_{m-1}\\), whenever solution \\(S\\) has a cache hit, so does \\(S^{\\prime}\\). Only the request for block \\(b_{m}=z\\) remains to be considered. If \\(S\\) has a cache miss upon the request for \\(b_{m}\\), then regardless of whether \\(S^{\\prime}\\) has a cache hit or a cache miss, we are done: \\(S^{\\prime}\\) has at most the same number of cache misses as \\(S\\). So now suppose that \\(S\\) has a cache hit and \\(S^{\\prime}\\) has a cache miss upon the request for \\(b_{m}\\). We'll show that there exists a request for at least one of blocks \\(b_{i+1},\\ldots,b_{m-1}\\) in which the request results in a cache miss for \\(S\\) and a cache hit for \\(S^{\\prime}\\), thereby compensating for what happens upon the request for block \\(b_{m}\\). The proof is by contradiction. Assume that no request for blocks \\(b_{i+1},\\ldots,b_{m-1}\\) results in a cache miss for \\(S\\) and a cache hit for \\(S^{\\prime}\\). We start by observing that once the caches \\(C_{S,j}\\) and \\(C_{S^{\\prime}j}\\) are equal for some \\(j>i\\), they remain equal thereafter. Observe also that if \\(b_{m}\\in C_{S,m}\\) and \\(b_{m}\\notin C_{S^{\\prime},m}\\), then \\(C_{S,m}\\neq C_{S^{\\prime},m}\\). Therefore, solution \\(S\\) cannot have evicted block \\(z\\) upon the requests for blocks \\(b_{i},\\ldots,b_{m-1}\\), for if it had, then these two cache configurations would be equal. The remaining possibility is that upon each of these requests, we had \\(C_{S,j}=D_{j}\\cup\\{z\\}\\), \\(C_{S^{\\prime},j}=D_{j}\\cup\\{y\\}\\) for some block \\(y\\neq z\\), and solution \\(S\\) evicted some block \\(w\\in D_{j}\\). Moreover, since none of these requests resulted in a cache miss for \\(S\\) and a cache hit for \\(S^{\\prime}\\), the case of \\(b_{j}=y\\) never occurred. That is, for every request of blocks \\(b_{i+1},\\ldots,b_{m-1}\\), the requested block \\(b_{j}\\) was never the block \\(y\\in C_{S^{\\prime},j}-C_{S,j}\\). In these cases, after processing the request, we had \\(C_{S^{\\prime},j+1}=D_{j+1}\\cup\\{y\\}\\): the difference between the two caches did not change. Now, let's go back to the request for block \\(b_{i}\\), where afterward, we had \\(C_{S^{\\prime},i+1}=D_{i+1}\\cup\\{x\\}\\). Because every succeeding request until requesting block \\(b_{m}\\) did not change the difference between the caches, we had \\(C_{S^{\\prime},j}=D_{j}\\cup\\{x\\}\\) for \\(j=i+1,\\ldots,m\\). By definition, block \\(z=b_{m}\\) is requested after block \\(x\\). That means at least one of blocks \\(b_{i+1},\\ldots,b_{m-1}\\) is block \\(x\\). But for \\(j=i+1,\\ldots,m\\), we have \\(x\\in C_{S^{\\prime},j}\\) and \\(x\\notin C_{S,j}\\), so that at least one of these requests had a cache hit for \\(S^{\\prime}\\) and a cache miss for \\(S\\), a contradiction. We conclude that if solution \\(S\\) has a cache hit and solution \\(S^{\\prime}\\) has a cache miss upon the request for block \\(b_{m}\\), then some earlier request had the opposite result, and so solution \\(S^{\\prime}\\) produces no more cache misses than solution \\(S\\). Since \\(S\\) is assumed to be optimal, \\(S^{\\prime}\\) is optimal as well.\n\nAlong with the optimal-substructure property, Theorem 15.5 tells us that the furthest-in-future strategy yields the minimum number of cache misses.\n\n#### Exercises\n\n##### 15.4-1\n\nWrite pseudocode for a cache manager that uses the furthest-in-future strategy. It should take as input a set \\(C\\) of blocks in the cache, the number of blocks \\(k\\) that the cache can hold, a sequence \\(b_{1},b_{2},\\ldots,b_{n}\\) of requested blocks, and the index \\(i\\) into the sequence for the block \\(b_{i}\\) being requested. For each request, it should print out whether a cache hit or cache miss occurs, and for each cache miss, it should also print out which block, if any, is evicted.\n\n##### 15.4-2\n\nReal cache managers do not know the future requests, and so they often use the past to decide which block to evict. The _least-recently-used_, or _LRU_, strategy evicts the block that, of all blocks currently in the cache, was the least recently requested. (You can think of LRU as \"furthest-in-past.\") Give an example of a request sequence in which the LRU strategy is not optimal, by showing that it induces more cache misses than the furthest-in-future strategy does on the same request sequence.\n\n#### 15.4-3\n\nProfessor Croesus suggests that in the proof of Theorem 15.5, the last clause in property 1 can change to \\(C_{S^{\\prime},j}=D_{j}\\,\\cup\\,\\{x\\}\\) or, equivalently, require the block \\(y\\) given in property 1 to always be the block \\(x\\) evicted by solution \\(S\\) upon the request for block \\(b_{i}\\). Show where the proof breaks down with this requirement.\n\n#### 15.4-4\n\nThis section has assumed that at most one block is placed into the cache whenever a block is requested. You can imagine, however, a strategy in which multiple blocks may enter the cache upon a single request. Show that for every solution that allows multiple blocks to enter the cache upon each request, there is another solution that brings in only one block upon each request and is at least as good.\n\n## Problems\n\n### 15-1 Coin changing\n\nConsider the problem of making change for \\(n\\) cents using the smallest number of coins. Assume that each coin's value is an integer.\n\n1. Describe a greedy algorithm to make change consisting of quarters, dimes, nickels, and pennies. Prove that your algorithm yields an optimal solution.\n2. Suppose that the available coins are in denominations that are powers of \\(c\\): the denominations are \\(c^{0},c^{1},\\ldots,c^{k}\\) for some integers \\(c>1\\) and \\(k\\geq 1\\). Show that the greedy algorithm always yields an optimal solution.\n3. Give a set of coin denominations for which the greedy algorithm does not yield an optimal solution. Your set should include a penny so that there is a solution for every value of \\(n\\).\n4. Give an \\(O(nk)\\)-time algorithm that makes change for any set of \\(k\\) different coin denominations using the smallest number of coins, assuming that one of the coins is a penny.\n\n### 15-2 Scheduling to minimize average completion time\n\nYou are given a set \\(S=\\{a_{1},a_{2},\\ldots,a_{n}\\}\\) of tasks, where task \\(a_{i}\\) requires \\(p_{i}\\) units of processing time to complete. Let \\(C_{i}\\) be the _completion time_ of task \\(a_{i}\\), that is, the time at which task \\(a_{i}\\) completes processing. Your goal is to minimize the average completion time, that is, to minimize \\((1/n)\\sum_{i=1}^{n}C_{i}\\). For example, suppose that there are two tasks \\(a_{1}\\) and \\(a_{2}\\) with \\(p_{1}=3\\) and \\(p_{2}=5\\), and consider the schedule",
        "chapter": "Part IV Advanced Design and Analysis Techniques",
        "section": "15 Greedy Algorithms",
        "subsection": "15.4 Offline caching",
        "subsubsection": "N/A"
    },
    {
        "content": "#### 15.4-3\n\nProfessor Croesus suggests that in the proof of Theorem 15.5, the last clause in property 1 can change to \\(C_{S^{\\prime},j}=D_{j}\\cup\\{x\\}\\) or, equivalently, require the block \\(y\\) given in property 1 to always be the block \\(x\\) evicted by solution \\(S\\) upon the request for block \\(b_{i}\\). Show where the proof breaks down with this requirement.\n\n#### 15.4-4\n\nThis section has assumed that at most one block is placed into the cache whenever a block is requested. You can imagine, however, a strategy in which multiple blocks may enter the cache upon a single request. Show that for every solution that allows multiple blocks to enter the cache upon each request, there is another solution that brings in only one block upon each request and is at least as good.\n\n## Problems\n\n### 15-1 Coin changing\n\nConsider the problem of making change for \\(n\\) cents using the smallest number of coins. Assume that each coin's value is an integer.\n\n* Describe a greedy algorithm to make change consisting of quarters, dimes, nickels, and pennies. Prove that your algorithm yields an optimal solution.\n* Suppose that the available coins are in denominations that are powers of \\(c\\): the denominations are \\(c^{0},c^{1},\\ldots,c^{k}\\) for some integers \\(c>1\\) and \\(k\\geq 1\\). Show that the greedy algorithm always yields an optimal solution.\n* Give a set of coin denominations for which the greedy algorithm does not yield an optimal solution. Your set should include a penny so that there is a solution for every value of \\(n\\).\n* Give an \\(O(nk)\\)-time algorithm that makes change for any set of \\(k\\) different coin denominations using the smallest number of coins, assuming that one of the coins is a penny.\n\n### 15-2 Scheduling to minimize average completion time\n\nYou are given a set \\(S=\\{a_{1},a_{2},\\ldots,a_{n}\\}\\) of tasks, where task \\(a_{i}\\) requires \\(p_{i}\\) units of processing time to complete. Let \\(C_{i}\\) be the _completion time_ of task \\(a_{i}\\), that is, the time at which task \\(a_{i}\\) completes processing. Your goal is to minimize the average completion time, that is, to minimize \\((1/n)\\sum_{i=1}^{n}C_{i}\\). For example, suppose that there are two tasks \\(a_{1}\\) and \\(a_{2}\\) with \\(p_{1}=3\\) and \\(p_{2}=5\\), and consider the schedulein which \\(a_{2}\\) runs first, followed by \\(a_{1}\\). Then we have \\(C_{2}=5\\), \\(C_{1}=8\\), and the average completion time is \\((5+8)/2=6.5\\). If task \\(a_{1}\\) runs first, however, then we have \\(C_{1}=3\\), \\(C_{2}=8\\), and the average completion time is \\((3+8)/2=5.5\\).\n\n**a.**: Give an algorithm that schedules the tasks so as to minimize the average completion time. Each task must run nonpreemptively, that is, once task \\(a_{i}\\) starts, it must run continuously for \\(p_{i}\\) units of time until it is done. Prove that your algorithm minimizes the average completion time, and analyze the running time of your algorithm.\n**b.**: Suppose now that the tasks are not all available at once. That is, each task cannot start until its _release time_\\(b_{i}\\). Suppose also that tasks may be _preempted_, so that a task can be suspended and restarted at a later time. For example, a task \\(a_{i}\\) with processing time \\(p_{i}=6\\) and release time \\(b_{i}=1\\) might start running at time 1 and be preempted at time 4. It might then resume at time 10 but be preempted at time 11, and it might finally resume at time 13 and complete at time 15. Task \\(a_{i}\\) has run for a total of 6 time units, but its running time has been divided into three pieces. Give an algorithm that schedules the tasks so as to minimize the average completion time in this new scenario. Prove that your algorithm minimizes the average completion time, and analyze the running time of your algorithm.\n\n## Chapter notes\n\nMuch more material on greedy algorithms can be found in Lawler [276] and Papadimitriou and Steiglitz [353]. The greedy algorithm first appeared in the combinatorial optimization literature in a 1971 article by Edmonds [131].\n\nThe proof of correctness of the greedy algorithm for the activity-selection problem is based on that of Gavril [179].\n\nHuffman codes were invented in 1952 [233]. Lelewer and Hirschberg [294] surveys data-compression techniques known as of 1987.\n\nThe furthest-in-future strategy was proposed by Belady [41], who suggested it for virtual-memory systems. Alternative proofs that furthest-in-future is optimal appear in articles by Lee et al. [284] and Van Roy [443].",
        "chapter": "Part IV Advanced Design and Analysis Techniques",
        "section": "15 Greedy Algorithms",
        "subsection": "Problems",
        "subsubsection": "N/A"
    },
    {
        "content": "in which \\(a_{2}\\) runs first, followed by \\(a_{1}\\). Then we have \\(C_{2}=5\\), \\(C_{1}=8\\), and the average completion time is \\((5+8)/2=6.5\\). If task \\(a_{1}\\) runs first, however, then we have \\(C_{1}=3\\), \\(C_{2}=8\\), and the average completion time is \\((3+8)/2=5.5\\).\n\n**a.**: Give an algorithm that schedules the tasks so as to minimize the average completion time. Each task must run nonpreemptively, that is, once task \\(a_{i}\\) starts, it must run continuously for \\(p_{i}\\) units of time until it is done. Prove that your algorithm minimizes the average completion time, and analyze the running time of your algorithm.\n**b.**: Suppose now that the tasks are not all available at once. That is, each task cannot start until its _release time_\\(b_{i}\\). Suppose also that tasks may be _preempted_, so that a task can be suspended and restarted at a later time. For example, a task \\(a_{i}\\) with processing time \\(p_{i}=6\\) and release time \\(b_{i}=1\\) might start running at time 1 and be preempted at time 4. It might then resume at time 10 but be preempted at time 11, and it might finally resume at time 13 and complete at time 15. Task \\(a_{i}\\) has run for a total of 6 time units, but its running time has been divided into three pieces. Give an algorithm that schedules the tasks so as to minimize the average completion time in this new scenario. Prove that your algorithm minimizes the average completion time, and analyze the running time of your algorithm.\n\n## Chapter notes\n\nMuch more material on greedy algorithms can be found in Lawler [276] and Papadimitriou and Steiglitz [353]. The greedy algorithm first appeared in the combinatorial optimization literature in a 1971 article by Edmonds [131].\n\nThe proof of correctness of the greedy algorithm for the activity-selection problem is based on that of Gavril [179].\n\nHuffman codes were invented in 1952 [233]. Lelewer and Hirschberg [294] surveys data-compression techniques known as of 1987.\n\nThe furthest-in-future strategy was proposed by Belady [41], who suggested it for virtual-memory systems. Alternative proofs that furthest-in-future is optimal appear in articles by Lee et al. [284] and Van Roy [443].\n\n## Chapter 16 Amortized Analysis\n\nImagine that you join Buff's Gym. Buff charges a membership fee of $60 per month, plus $3 for every time you use the gym. Because you are disciplined, you visit Buff's Gym every day during the month of November. On top of the $60 monthly charge for November, you pay another \\(3\\times\\$30=\\$90\\) that month. Although you can think of your fees as a flat fee of $60 and another $90 in daily fees, you can think about it in another way. All together, you pay $150 over 30 days, or an average of $5 per day. When you look at your fees in this way, you are _amortizing_ the monthly fee over the 30 days of the month, spreading it out at $2 per day.\n\nYou can do the same thing when you analyze running times. In an _amortized analysis_, you average the time required to perform a sequence of data-structure operations over all the operations performed. With amortized analysis, you show that if you average over a sequence of operations, then the average cost of an operation is small, even though a single operation within the sequence might be expensive. Amortized analysis differs from average-case analysis in that probability is not involved. An amortized analysis guarantees the _average performance of each operation in the worst case_.\n\nThe first three sections of this chapter cover the three most common techniques used in amortized analysis. Section 16.1 starts with aggregate analysis, in which you determine an upper bound \\(T(n)\\) on the total cost of a sequence of \\(n\\) operations. The average cost per operation is then \\(T(n)/n\\). You take the average cost as the amortized cost of each operation, so that all operations have the same amortized cost.\n\nSection 16.2 covers the accounting method, in which you determine an amortized cost of each operation. When there is more than one type of operation, each type of operation may have a different amortized cost. The accounting method overcharges some operations early in the sequence, storing the overcharge as \"pre",
        "chapter": "Part IV Advanced Design and Analysis Techniques",
        "section": "15 Greedy Algorithms",
        "subsection": "Chapter notes",
        "subsubsection": "N/A"
    },
    {
        "content": "### Aggregate analysis\n\nIn _aggregate analysis_, you show that for all \\(n\\), a sequence of \\(n\\) operations takes \\(T(n)\\)_worst-case_ time in total. In the worst case, the average cost, or _amortized cost_, per operation is therefore \\(T(n)/n\\). This amortized cost applies to each operation, even when there are several types of operations in the sequence. The other two methods we shall study in this chapter, the accounting method and the potential method, may assign different amortized costs to different types of operations.\n\n#### Stack operations\n\nAs the first example of aggregate analysis, let's analyze stacks that have been augmented with a new operation. Section 10.1.3 presented the two fundamental stack operations, each of which takes \\(O(1)\\) time:\n\n\\(\\textsc{Push}(S,x)\\) pushes object \\(x\\) onto stack \\(S\\).\n\n\\(\\textsc{Pop}(S)\\) pops the top of stack \\(S\\) and returns the popped object. Calling Pop on an empty stack generates an error.\n\nSince each of these operations runs in \\(O(1)\\) time, let us consider the cost of each to be \\(1\\). The total cost of a sequence of \\(n\\) Push and Pop operations is therefore \\(n\\), and the actual running time for \\(n\\) operations is therefore \\(\\Theta(n)\\).\n\nNow let's add the stack operation Multipop\\((S,k)\\), which removes the \\(k\\) top objects of stack \\(S\\), popping the entire stack if the stack contains fewer than \\(k\\) objects. Of course, the procedure assumes that \\(k\\) is positive, and otherwise, the Multipop operation leaves the stack unchanged. In the pseudocode for Multipop, the operation Stack-Empty returns true if there are no objects currently on the stack, and false otherwise. Figure 16.1 shows an example of Multipop.\n\nWhat is the running time of Multipop\\((S,k)\\) on a stack of \\(s\\) objects? The actual running time is linear in the number of Pop operations actually executed, and thus we can analyze Multipop in terms of the abstract costs of \\(1\\) each for Push and Pop. The number of iterations of the **while** loop is the number \\(\\min\\,\\{s,k\\}\\) of objects popped off the stack. Each iteration of the loop makes one call to Pop in line 2. Thus, the total cost of Multipop is \\(\\min\\,\\{s,k\\}\\), and the actual running time is a linear function of this cost.\n\nNow let's analyze a sequence of \\(n\\) Push, Pop, and Multipop operations on an initially empty stack. The worst-case cost of a Multipop operation in the sequence is \\(O(n)\\), since the stack size is at most \\(n\\). The worst-case time of any stack operation is therefore \\(O(n)\\), and hence a sequence of \\(n\\) operations costs \\(O(n^{2})\\), since the sequence contains at most \\(n\\) Multipop operations costing \\(O(n)\\) each.\n\nFigure 16.1: The action of Multipop on a stack \\(S\\), shown initially in **(a)**. The top \\(4\\) objects are popped by Multipop\\((S,4)\\), whose result is shown in **(b)**. The next operation is Multipop\\((S,7)\\), which empties the stack\\(-\\) shown in **(c)**\\(-\\)since fewer than \\(7\\) objects remained.\n\n### Aggregate analysis\n\nAlthough this analysis is correct, the \\(O(n^{2})\\) result, which came from considering the worst-case cost of each operation individually, is not tight.\n\nYes, a single Multipop might be expensive, but an aggregate analysis shows that any sequence of \\(n\\) Push, Pop, and Multipop operations on an initially empty stack has an upper bound on its cost of \\(O(n)\\). Why? An object cannot be popped from the stack unless it was first pushed. Therefore, the number of times that Pop can be called on a nonempty stack, including calls within Multipop, is at most the number of Push operations, which is at most \\(n\\). For any value of \\(n\\), any sequence of \\(n\\) Push, Pop, and Multipop operations takes a total of \\(O(n)\\) time. Averaging over the \\(n\\) operations gives an average cost per operation of \\(O(n)/n=O(1)\\). Aggregate analysis assigns the amortized cost of each operation to be the average cost. In this example, therefore, all three stack operations have an amortized cost of \\(O(1)\\).\n\nTo recap: although the average cost, and hence the running time, of a stack operation is \\(O(1)\\), the analysis did not rely on probabilistic reasoning. Instead, the analysis yielded a _worst-case_ bound of \\(O(n)\\) on a sequence of \\(n\\) operations. Dividing this total cost by \\(n\\) yielded that the average cost per operation--that is, the amortized cost--is \\(O(1)\\).\n\n#### Incrementing a binary counter\n\nAs another example of aggregate analysis, consider the problem of implementing a \\(k\\)-bit binary counter that counts upward from \\(0\\). An array \\(A[0:k-1]\\) of bits represents the counter. A binary number \\(x\\) that is stored in the counter has its lowest-order bit in \\(A[0]\\) and its highest-order bit in \\(A[k-1]\\), so that \\(x=\\sum_{i=0}^{k-1}A[i]\\cdot 2^{i}\\). Initially, \\(x=0\\), and thus \\(A[i]=0\\) for \\(i=0,1,\\ldots,k-1\\). To add \\(1\\) (modulo \\(2^{k}\\)) to the value in the counter, call the Increment procedure.\n\nFigure 16.2 shows what happens to a binary counter when Increment is called \\(16\\) times, starting with the initial value \\(0\\) and ending with the value \\(16\\). Each iteration of the **while** loop in lines 2-4 adds a \\(1\\) into position \\(i\\). If \\(A[i]=1\\), then adding \\(1\\) flips the bit to \\(0\\) in position \\(i\\) and yields a carry of \\(1\\), to be added intoposition \\(i\\,+\\,1\\) during the next iteration of the loop. Otherwise, the loop ends, and then, if \\(i\\,<\\,k\\,,\\,A[i]\\) must be \\(0\\), so that line 6 adds a \\(1\\) into position \\(i\\,,\\) flipping the \\(0\\) to a \\(1\\). If the loop ends with \\(i\\,=\\,k\\,,\\) then the call of Increment flipped all \\(k\\) bits from \\(1\\) to \\(0\\). The cost of each Increment operation is linear in the number of bits flipped.\n\nAs with the stack example, a cursory analysis yields a bound that is correct but not tight. A single execution of Increment takes \\(\\Theta(k)\\) time in the worst case, in which all the bits in array \\(A\\) are \\(1\\). Thus, a sequence of \\(n\\) Increment operations on an initially zero counter takes \\(O(nk)\\) time in the worst case.\n\nAlthough a single call of Increment might flip all \\(k\\) bits, not all bits flip upon each call. (Note the similarity to Multipop, where a single call might pop many objects, but not every call pops many objects.) As Figure 16.2 shows, \\(A[0]\\) does flip each time Increment is called. The next bit up, \\(A[1]\\), flips only every other time: a sequence of \\(n\\) Increment operations on an initially zero counter causes \\(A[1]\\) to flip \\(\\lfloor n/2\\rfloor\\) times. Similarly, bit \\(A[2]\\) flips only every fourth time, or \\(\\lfloor n/4\\rfloor\\) times in a sequence of \\(n\\) Increment operations. In general, for \\(i\\,=\\,0,1,\\ldots,k-1\\), bit \\(A[i]\\) flips \\(\\lfloor n/2^{i}\\rfloor\\) times in a sequence of \\(n\\) Increment operations on an initially zero counter. For \\(i\\,\\geq\\,k\\,,\\) bit \\(A[i]\\) does not exist, and so it cannot flip. The total number\n\nFigure 16.2: An \\(8\\)-bit binary counter as its value goes from \\(0\\) to \\(16\\) by a sequence of \\(16\\) Increment operations. Bits that flip to achieve the next value are shaded in blue. The running cost for flipping bits is shown at the right. The total cost is always less than twice the total number of Increment operations.\n\nof flips in the sequence is thus\n\n\\[\\sum_{i=0}^{k-1}\\Big{\\lfloor}\\,\\frac{n}{2^{i}}\\Big{\\rfloor} <\\ n\\,\\sum_{i=0}^{\\infty}\\,\\frac{1}{2^{i}}\\] \\[=\\ 2n\\,\\]\n\nby equation (A.7) on page 1142. Thus, a sequence of \\(n\\) Increment operations on an initially zero counter takes \\(\\,O(n)\\) time in the worst case. The average cost of each operation, and therefore the amortized cost per operation, is \\(\\,O(n)/n=O(1)\\).\n\n**Exercises**\n\n_16.1-1_\n\nIf the set of stack operations includes a Multipush operation, which pushes \\(k\\) items onto the stack, does the \\(\\,O(1)\\) bound on the amortized cost of stack operations continue to hold?\n\n_16.1-2_\n\nShow that if a Decrement operation is included in the \\(k\\)-bit counter example, \\(n\\) operations can cost as much as \\(\\,\\Theta(nk)\\) time.\n\n_16.1-3_\n\nUse aggregate analysis to determine the amortized cost per operation for a sequence of \\(n\\) operations on a data structure in which the \\(i\\)th operation costs \\(i\\) if \\(i\\) is an exact power of 2, and 1 otherwise.\n\n### The accounting method\n\nIn the _accounting method_ of amortized analysis, you assign differing charges to different operations, with some operations charged more or less than they actually cost. The amount that you charge an operation is its _amortized cost_. When an operation's amortized cost exceeds its actual cost, you assign the difference to specific objects in the data structure as _credit_. Credit can help pay for later operations whose amortized cost is less than their actual cost. Thus, you can view the amortized cost of an operation as being split between its actual cost and credit that is either deposited or used up. Different operations may have different amortized costs. This method differs from aggregate analysis, in which all operations have the same amortized cost.\n\nYou must choose the amortized costs of operations carefully. If you want to use amortized costs to show that in the worst case the average cost per operation is",
        "chapter": "Part IV Advanced Design and Analysis Techniques",
        "section": "16 Amortized Analysis",
        "subsection": "16.1 Aggregate analysis",
        "subsubsection": "N/A"
    },
    {
        "content": "of flips in the sequence is thus\n\n\\[\\sum_{i=0}^{k-1}\\Big{\\lfloor}\\,\\frac{n}{2^{i}}\\Big{\\rfloor} <\\ n\\,\\sum_{i=0}^{\\infty}\\,\\frac{1}{2^{i}}\\] \\[=\\ 2n\\,\\]\n\nby equation (A.7) on page 1142. Thus, a sequence of \\(n\\) Increment operations on an initially zero counter takes \\(\\,O(n)\\) time in the worst case. The average cost of each operation, and therefore the amortized cost per operation, is \\(\\,O(n)/n=O(1)\\).\n\n**Exercises**\n\n_16.1-1_\n\nIf the set of stack operations includes a Multipush operation, which pushes \\(k\\) items onto the stack, does the \\(\\,O(1)\\) bound on the amortized cost of stack operations continue to hold?\n\n_16.1-2_\n\nShow that if a Decrement operation is included in the \\(k\\)-bit counter example, \\(n\\) operations can cost as much as \\(\\,\\Theta(nk)\\) time.\n\n_16.1-3_\n\nUse aggregate analysis to determine the amortized cost per operation for a sequence of \\(n\\) operations on a data structure in which the \\(i\\)th operation costs \\(i\\) if \\(i\\) is an exact power of 2, and 1 otherwise.\n\n### The accounting method\n\nIn the _accounting method_ of amortized analysis, you assign differing charges to different operations, with some operations charged more or less than they actually cost. The amount that you charge an operation is its _amortized cost_. When an operation's amortized cost exceeds its actual cost, you assign the difference to specific objects in the data structure as _credit_. Credit can help pay for later operations whose amortized cost is less than their actual cost. Thus, you can view the amortized cost of an operation as being split between its actual cost and credit that is either deposited or used up. Different operations may have different amortized costs. This method differs from aggregate analysis, in which all operations have the same amortized cost.\n\nYou must choose the amortized costs of operations carefully. If you want to use amortized costs to show that in the worst case the average cost per operation is small, you must ensure that the total amortized cost of a sequence of operations provides an upper bound on the total actual cost of the sequence. Moreover, as in aggregate analysis, the upper bound must apply to all sequences of operations. Let's denote the actual cost of the \\(i\\)th operation by \\(c_{i}\\) and the amortized cost of the \\(i\\)th operation by \\(\\widehat{c}_{i}\\). Then you need to have\n\n\\[\\sum_{i=1}^{n}\\widehat{c}_{i}\\,\\geq\\,\\sum_{i=1}^{n}c_{i} \\tag{16.1}\\]\n\nfor all sequences of \\(n\\) operations. The total credit stored in the data structure is the difference between the total amortized cost and the total actual cost, or \\(\\sum_{i=1}^{n}\\widehat{c}_{i}-\\sum_{i=1}^{n}c_{i}\\). By inequality (16.1), the total credit associated with the data structure must be nonnegative at all times. If you ever allowed the total credit to become negative (the result of undercharging early operations with the promise of repaying the account later on), then the total amortized costs incurred at that time would be below the total actual costs incurred. In that case, for the sequence of operations up to that time, the total amortized cost would not be an upper bound on the total actual cost. Thus, you must take care that the total credit in the data structure never becomes negative.\n\n##### Stack operations\n\nTo illustrate the accounting method of amortized analysis, we return to the stack example. Recall that the actual costs of the operations were\n\n\\begin{tabular}{l l} Push & 1, \\\\ Pop & 1, \\\\ Multipop & \\(\\min\\left\\{s,k\\right\\}\\), \\\\ \\end{tabular}\n\nwhere \\(k\\) is the argument supplied to Multipop and \\(s\\) is the stack size when it is called. Let us assign the following amortized costs:\n\n\\begin{tabular}{l l} Push & 2, \\\\ Pop & 0, \\\\ Multipop & 0. \\\\ \\end{tabular}\n\nThe amortized cost of Multipop is a constant (0), whereas the actual cost is variable, and thus all three amortized costs are constant. In general, the amortized costs of the operations under consideration may differ from each other, and they may even differ asymptotically.\n\nNow let's see how to pay for any sequence of stack operations by charging the amortized costs. Let \\(\\$1\\) represent each unit of cost. At first, the stack is empty. Recall the analogy of Section 10.1.3 between the stack data structure and a stack of plates in a cafeteria. Upon pushing a plate onto the stack, use \\(\\$1\\) to pay the actual cost of the push, leaving a credit of $1 (out of the $2 charged). Place that $1 of credit on top of the plate. At any point in time, every plate on the stack has $1 of credit on it.\n\nThe $1 stored on the plate serves to prepay the cost of popping the plate from the stack. A Pop operation incurs no charge: pay the actual cost of popping a plate by taking the $1 of credit off the plate. Thus, by charging the Push operation a little bit more, we can view the Pop operation as free.\n\nMoreover, the Multipop operation also incurs no charge, since it's just repeated Pop operations, each of which is free. If a Multipop operation pops \\(k\\) plates, then the actual cost is paid by the \\(k\\) dollars stored on the \\(k\\) plates. Because each plate on the stack has $1 of credit on it, and the stack always has a nonnegative number of plates, the amount of credit is always nonnegative. Thus, for _any_ sequence of \\(n\\) Push, Pop, and Multipop operations, the total amortized cost is an upper bound on the total actual cost. Since the total amortized cost is \\(O(n)\\), so is the total actual cost.\n\n##### Incrementing a binary counter\n\nAs another illustration of the accounting method, let's analyze the Increment operation on a binary counter that starts at 0. Recall that the running time of this operation is proportional to the number of bits flipped, which serves as the cost for this example. Again, we'll use $1 to represent each unit of cost (the flipping of a bit in this example).\n\nFor the amortized analysis, the amortized cost to set a 0-bit to 1 is $2. When a bit is set to 1, $1 of the $2 pays to actually set the bit. The second $1 resides on the bit as credit to be used later if and when the bit is reset to 0. At any point in time, every 1-bit in the counter has $1 of credit on it, and thus resetting a bit to 0 can be viewed as costing nothing, and the $1 on the bit prepays for the reset.\n\nHere is how to determine the amortized cost of Increment. The cost of resetting the bits to 0 within the **while** loop is paid for by the dollars on the bits that are reset. The Increment procedure sets at most one bit to 1, in line 6, and therefore the amortized cost of an Increment operation is at most $2. The number of 1-bits in the counter never becomes negative, and thus the amount of credit stays nonnegative at all times. Thus, for \\(n\\) Increment operations, the total amortized cost is \\(O(n)\\), which bounds the total actual cost.\n\n##### Exercises\n\n##### 16.2-1\n\nYou perform a sequence of Push and Pop operations on a stack whose size never exceeds \\(k\\). After every \\(k\\) operations, a copy of the entire stack is made automat ically, for backup purposes. Show that the cost of \\(n\\) stack operations, including copying the stack, is \\(O(n)\\) by assigning suitable amortized costs to the various stack operations.\n\n_16.2-2_\n\nRedo Exercise 16.1-3 using an accounting method of analysis.\n\n_16.2-3_\n\nYou wish not only to increment a counter but also to reset it to 0 (i.e., make all bits in it 0). Counting the time to examine or modify a bit as \\(\\Theta(1)\\), show how to implement a counter as an array of bits so that any sequence of \\(n\\) Increment and Reset operations takes \\(O(n)\\) time on an initially zero counter. (_Hint:_ Keep a pointer to the high-order 1.)\n\n### The potential method\n\nInstead of representing prepaid work as credit stored with specific objects in the data structure, the _potential method_ of amortized analysis represents the prepaid work as \"potential energy,\" or just \"potential,\" which can be released to pay for future operations. The potential applies to the data structure as a whole rather than to specific objects within the data structure.\n\nThe potential method works as follows. Starting with an initial data structure \\(D_{0}\\), a sequence of \\(n\\) operations occurs. For each \\(i=1,2,\\ldots,n\\), let \\(c_{i}\\) be the actual cost of the \\(i\\)th operation and \\(D_{i}\\) be the data structure that results after applying the \\(i\\)th operation to data structure \\(D_{i-1}\\). A _potential function_\\(\\Phi\\) maps each data structure \\(D_{i}\\) to a real number \\(\\Phi(D_{i})\\), which is the _potential_ associated with \\(D_{i}\\). The _amortized cost_\\(\\widehat{c}_{i}\\) of the \\(i\\)th operation with respect to potential function \\(\\Phi\\) is defined by\n\n\\[\\widehat{c}_{i}\\,=\\,c_{i}\\,+\\,\\Phi(D_{i})-\\Phi(D_{i-1}). \\tag{16.2}\\]\n\nThe amortized cost of each operation is therefore its actual cost plus the change in potential due to the operation. By equation (16.2), the total amortized cost of the \\(n\\) operations is\n\n\\[\\sum_{i=1}^{n}\\widehat{c}_{i} = \\sum_{i=1}^{n}(c_{i}\\,+\\,\\Phi(D_{i})-\\Phi(D_{i-1})) \\tag{16.3}\\] \\[= \\sum_{i=1}^{n}c_{i}\\,+\\,\\Phi(D_{n})-\\Phi(D_{0})\\.\\]",
        "chapter": "Part IV Advanced Design and Analysis Techniques",
        "section": "16 Amortized Analysis",
        "subsection": "16.2 The accounting method",
        "subsubsection": "N/A"
    },
    {
        "content": "ically, for backup purposes. Show that the cost of \\(n\\) stack operations, including copying the stack, is \\(O(n)\\) by assigning suitable amortized costs to the various stack operations.\n\n_16.2-2_\n\nRedo Exercise 16.1-3 using an accounting method of analysis.\n\n_16.2-3_\n\nYou wish not only to increment a counter but also to reset it to 0 (i.e., make all bits in it 0). Counting the time to examine or modify a bit as \\(\\Theta(1)\\), show how to implement a counter as an array of bits so that any sequence of \\(n\\) Increment and Reset operations takes \\(O(n)\\) time on an initially zero counter. (_Hint:_ Keep a pointer to the high-order 1.)\n\n### The potential method\n\nInstead of representing prepaid work as credit stored with specific objects in the data structure, the _potential method_ of amortized analysis represents the prepaid work as \"potential energy,\" or just \"potential,\" which can be released to pay for future operations. The potential applies to the data structure as a whole rather than to specific objects within the data structure.\n\nThe potential method works as follows. Starting with an initial data structure \\(D_{0}\\), a sequence of \\(n\\) operations occurs. For each \\(i=1,2,\\ldots,n\\), let \\(c_{i}\\) be the actual cost of the \\(i\\)th operation and \\(D_{i}\\) be the data structure that results after applying the \\(i\\)th operation to data structure \\(D_{i-1}\\). A _potential function_\\(\\Phi\\) maps each data structure \\(D_{i}\\) to a real number \\(\\Phi(D_{i})\\), which is the _potential_ associated with \\(D_{i}\\). The _amortized cost_\\(\\widehat{c}_{i}\\) of the \\(i\\)th operation with respect to potential function \\(\\Phi\\) is defined by\n\n\\[\\widehat{c}_{i}\\,=\\,c_{i}\\,+\\,\\Phi(D_{i})-\\Phi(D_{i-1}). \\tag{16.2}\\]\n\nThe amortized cost of each operation is therefore its actual cost plus the change in potential due to the operation. By equation (16.2), the total amortized cost of the \\(n\\) operations is\n\n\\[\\sum_{i=1}^{n}\\widehat{c}_{i} = \\sum_{i=1}^{n}(c_{i}\\,+\\,\\Phi(D_{i})-\\Phi(D_{i-1})) \\tag{16.3}\\] \\[= \\sum_{i=1}^{n}c_{i}\\,+\\,\\Phi(D_{n})-\\Phi(D_{0})\\.\\]The second equation follows from equation (A.12) on page 1143 because the \\(\\Phi(D_{i})\\) terms telescope.\n\nIf you can define a potential function \\(\\Phi\\) so that \\(\\Phi(D_{n})\\geq\\Phi(D_{0})\\), then the total amortized cost \\(\\sum_{i=1}^{n}\\widehat{c}_{i}\\) gives an upper bound on the total actual cost \\(\\sum_{i=1}^{n}c_{i}\\). In practice, you don't always know how many operations might be performed. Therefore, if you require that \\(\\Phi(D_{i})\\geq\\Phi(D_{0})\\) for all \\(i\\), then you guarantee, as in the accounting method, that you've paid in advance. It's usually simplest to just define \\(\\Phi(D_{0})\\) to be 0 and then show that \\(\\Phi(D_{i})\\geq 0\\) for all \\(i\\). (See Exercise 16.3-1 for an easy way to handle cases in which \\(\\Phi(D_{0})\\neq 0\\).)\n\nIntuitively, if the potential difference \\(\\Phi(D_{i})-\\Phi(D_{i-1})\\) of the \\(i\\)th operation is positive, then the amortized cost \\(\\widehat{c}_{i}\\) represents an overcharge to the \\(i\\)th operation, and the potential of the data structure increases. If the potential difference is negative, then the amortized cost represents an undercharge to the \\(i\\)th operation, and the decrease in the potential pays for the actual cost of the operation.\n\nThe amortized costs defined by equations (16.2) and (16.3) depend on the choice of the potential function \\(\\Phi\\). Different potential functions may yield different amortized costs, yet still be upper bounds on the actual costs. You will often find trade-offs that you can make in choosing a potential function. The best potential function to use depends on the desired time bounds.\n\n##### Stack operations\n\nTo illustrate the potential method, we return once again to the example of the stack operations Push, Pop, and Multipop. We define the potential function \\(\\Phi\\) on a stack to be the number of objects in the stack. The potential of the empty initial stack \\(D_{0}\\) is \\(\\Phi(D_{0})=0\\). Since the number of objects in the stack is never negative, the stack \\(D_{i}\\) that results after the \\(i\\)th operation has nonnegative potential, and thus\n\n\\[\\Phi(D_{i}) \\geq 0\\] \\[= \\Phi(D_{0})\\.\\]\n\nThe total amortized cost of \\(n\\) operations with respect to \\(\\Phi\\) therefore represents an upper bound on the actual cost.\n\nNow let's compute the amortized costs of the various stack operations. If the \\(i\\)th operation on a stack containing \\(s\\) objects is a Push operation, then the potential difference is\n\n\\[\\Phi(D_{i})-\\Phi(D_{i-1}) = (s+1)-s\\] \\[= 1\\.\\]\n\nBy equation (16.2), the amortized cost of this Push operation is \\[\\widehat{c}_{i} = c_{i}\\,+\\,\\Phi(D_{i})-\\Phi(D_{i-1})\\] \\[= 1\\,+\\,1\\] \\[= 2\\.\\] Suppose that the \\(i\\)th operation on the stack of \\(s\\) objects is Multipop\\((S,k)\\), which causes \\(k^{\\prime}=\\min\\,\\{s,k\\}\\) objects to be popped off the stack. The actual cost of the operation is \\(k^{\\prime}\\), and the potential difference is \\[\\Phi(D_{i})-\\Phi(D_{i-1})=-k^{\\prime}\\.\\] Thus, the amortized cost of the Multipop operation is \\[\\widehat{c}_{i} = c_{i}\\,+\\,\\Phi(D_{i})-\\Phi(D_{i-1})\\] \\[= k^{\\prime}-k^{\\prime}\\] \\[= 0\\.\\] Similarly, the amortized cost of an ordinary Pop operation is \\(0\\). The amortized cost of each of the three operations is \\(O(1)\\), and thus the total amortized cost of a sequence of \\(n\\) operations is \\(O(n)\\). Since \\(\\Phi(D_{i})\\geq\\Phi(D_{0})\\), the total amortized cost of \\(n\\) operations is an upper bound on the total actual cost. The worst-case cost of \\(n\\) operations is therefore \\(O(n)\\).\n\n##### Incrementing a binary counter\n\nAs another example of the potential method, we revisit incrementing a \\(k\\)-bit binary counter. This time, the potential of the counter after the \\(i\\)th Increment operation is defined to be the number of \\(1\\)-bits in the counter after the \\(i\\)th operation, which we'll denote by \\(b_{i}\\).\n\nHere is how to compute the amortized cost of an Increment operation. Suppose that the \\(i\\)th Increment operation resets \\(t_{i}\\) bits to \\(0\\). The actual cost \\(c_{i}\\) of the operation is therefore at most \\(t_{i}\\,+\\,1\\), since in addition to resetting \\(t_{i}\\) bits, it sets at most one bit to \\(1\\). If \\(b_{i}\\,=\\,0\\), then the \\(i\\)th operation had reset all \\(k\\) bits to \\(0\\), and so \\(b_{i-1}\\,=\\,t_{i}\\,=\\,k\\). If \\(b_{i}\\,>\\,0\\), then \\(b_{i}\\,=\\,b_{i-1}-t_{i}\\,+\\,1\\). In either case, \\(b_{i}\\,\\leq\\,b_{i-1}-t_{i}\\,+\\,1\\), and the potential difference is \\[\\Phi(D_{i})-\\Phi(D_{i-1}) \\leq (b_{i-1}-t_{i}\\,+\\,1)-b_{i-1}\\] \\[= 1-t_{i}\\.\\] The amortized cost is therefore \\[\\widehat{c}_{i} = c_{i}\\,+\\,\\Phi(D_{i})-\\Phi(D_{i-1})\\] \\[\\leq (t_{i}\\,+\\,1)\\,+\\,(1-t_{i})\\] \\[= 2\\.\\]\n\n### The potential method\n\nIf the counter starts at 0, then \\(\\Phi(D_{0})=0\\). Since \\(\\Phi(D_{i})\\geq 0\\) for all \\(i\\), the total amortized cost of a sequence of \\(n\\) Increment operations is an upper bound on the total actual cost, and so the worst-case cost of \\(n\\) Increment operations is \\(O(n)\\).\n\nThe potential method provides a simple and clever way to analyze the counter even when it does not start at 0. The counter starts with \\(b_{0}\\) 1-bits, and after \\(n\\) Increment operations it has \\(b_{n}\\) 1-bits, where \\(0\\leq b_{0},b_{n}\\leq k\\). Rewrite equation (16.3) as\n\n\\[\\sum_{i=1}^{n}c_{i}\\,=\\,\\sum_{i=1}^{n}\\widehat{c}_{i}\\,-\\,\\Phi(D_{n})\\,+\\,\\Phi( D_{0})\\.\\]\n\nSince \\(\\Phi(D_{0})=b_{0}\\), \\(\\Phi(D_{n})=b_{n}\\), and \\(\\widehat{c}_{i}\\leq 2\\) for all \\(1\\leq i\\leq n\\), the total actual cost of \\(n\\) Increment operations is\n\n\\[\\sum_{i=1}^{n}c_{i} \\leq \\sum_{i=1}^{n}2-b_{n}\\,+\\,b_{0}\\] \\[= \\,2n-b_{n}\\,+\\,b_{0}\\.\\]\n\nIn particular, \\(b_{0}\\leq k\\) means that as long as \\(k=O(n)\\), the total actual cost is \\(O(n)\\). In other words, if at least \\(n=\\Omega(k)\\) Increment operations occur, the total actual cost is \\(O(n)\\), no matter what initial value the counter contains.\n\nExercises\n\n### 16.3-1\n\nSuppose you have a potential function \\(\\Phi\\) such that \\(\\Phi(D_{i})\\geq\\Phi(D_{0})\\) for all \\(i\\), but \\(\\Phi(D_{0})\\neq 0\\). Show that there exists a potential function \\(\\Phi^{\\prime}\\) such that \\(\\Phi^{\\prime}(D_{0})=0\\), \\(\\Phi^{\\prime}(D_{i})\\geq 0\\) for all \\(i\\geq 1\\), and the amortized costs using \\(\\Phi^{\\prime}\\) are the same as the amortized costs using \\(\\Phi\\).\n\n### 16.3-2\n\nRedo Exercise 16.1-3 using a potential method of analysis.\n\n### 16.3-3\n\nConsider an ordinary binary min-heap data structure supporting the instructions Insert and Extract-Min that, when there are \\(n\\) items in the heap, implements each operation in \\(O(\\lg n)\\) worst-case time. Give a potential function \\(\\Phi\\) such that the amortized cost of Insert is \\(O(\\lg n)\\) and the amortized cost of Extract-Min is \\(O(1)\\), and show that your potential function yields these amortized time bounds. Note that in the analysis, \\(n\\) is the number of items currently in the heap, and you do not know a bound on the maximum number of items that can ever be stored in the heap.\n\n### 16.3-4\n\nWhat is the total cost of executing \\(n\\) of the stack operations Push, Pop, and Multipop, assuming that the stack begins with \\(s_{0}\\) objects and finishes with \\(s_{n}\\) objects?\n\n### 16.3-5\n\nShow how to implement a queue with two ordinary stacks (Exercise 10.1-7) so that the amortized cost of each Enqueue and each Dequeue operation is \\(O(1)\\).\n\n### 16.3-6\n\nDesign a data structure to support the following two operations for a dynamic multiset \\(S\\) of integers, which allows duplicate values:\n\nInsert\\((S,x)\\) inserts \\(x\\) into \\(S\\).\n\nDelete-Larger-Half\\((S)\\) deletes the largest \\(\\lceil|S|\\,/\\,2\\rceil\\) elements from \\(S\\).\n\nExplain how to implement this data structure so that any sequence of \\(m\\) Insert and Delete-Larger-Half operations runs in \\(O(m)\\) time. Your implementation should also include a way to output the elements of \\(S\\) in \\(O(|S|)\\) time.\n\n### 16.4 Dynamic tables\n\nWhen you design an application that uses a table, you do not always know in advance how many items the table will hold. You might allocate space for the table, only to find out later that it is not enough. The program must then reallocate the table with a larger size and copy all items stored in the original table over into the new, larger table. Similarly, if many items have been deleted from the table, it might be worthwhile to reallocate the table with a smaller size. This section studies this problem of dynamically expanding and contracting a table. Amortized analyses will show that the amortized cost of insertion and deletion is only \\(O(1)\\), even though the actual cost of an operation is large when it triggers an expansion or a contraction. Moreover, you'll see how to guarantee that the unused space in a dynamic table never exceeds a constant fraction of the total space.\n\nLet's assume that the dynamic table supports the operations Table-Insert and Table-Delete. Table-Insert inserts into the table an item that occupies a single _slot_, that is, a space for one item. Likewise, Table-Delete removes an item from the table, thereby freeing a slot. The details of the data-structuring method used to organize the table are unimportant: it could be a stack (Section 10.1.3), a heap (Chapter 6), a hash table (Chapter 11), or something else.",
        "chapter": "Part IV Advanced Design and Analysis Techniques",
        "section": "16 Amortized Analysis",
        "subsection": "16.3 The potential method",
        "subsubsection": "N/A"
    },
    {
        "content": "### 16.3-4\n\nWhat is the total cost of executing \\(n\\) of the stack operations Push, Pop, and Multipop, assuming that the stack begins with \\(s_{0}\\) objects and finishes with \\(s_{n}\\) objects?\n\n### 16.3-5\n\nShow how to implement a queue with two ordinary stacks (Exercise 10.1-7) so that the amortized cost of each Enqueue and each Dequeue operation is \\(O(1)\\).\n\n### 16.3-6\n\nDesign a data structure to support the following two operations for a dynamic multiset \\(S\\) of integers, which allows duplicate values:\n\nInsert(\\(S,x\\)) inserts \\(x\\) into \\(S\\).\n\nDelete-Larger-Half(\\(S\\)) deletes the largest \\(\\lceil|S|\\,/\\,2\\rceil\\) elements from \\(S\\).\n\nExplain how to implement this data structure so that any sequence of \\(m\\) Insert and Delete-Larger-Half operations runs in \\(O(m)\\) time. Your implementation should also include a way to output the elements of \\(S\\) in \\(O(|S|)\\) time.\n\n### 16.4 Dynamic tables\n\nWhen you design an application that uses a table, you do not always know in advance how many items the table will hold. You might allocate space for the table, only to find out later that it is not enough. The program must then reallocate the table with a larger size and copy all items stored in the original table over into the new, larger table. Similarly, if many items have been deleted from the table, it might be worthwhile to reallocate the table with a smaller size. This section studies this problem of dynamically expanding and contracting a table. Amortized analyses will show that the amortized cost of insertion and deletion is only \\(O(1)\\), even though the actual cost of an operation is large when it triggers an expansion or a contraction. Moreover, you'll see how to guarantee that the unused space in a dynamic table never exceeds a constant fraction of the total space.\n\nLet's assume that the dynamic table supports the operations Table-Insert and Table-Delete. Table-Insert inserts into the table an item that occupies a single _slot_, that is, a space for one item. Likewise, Table-Delete removes an item from the table, thereby freeing a slot. The details of the data-structuring method used to organize the table are unimportant: it could be a stack (Section 10.1.3), a heap (Chapter 6), a hash table (Chapter 11), or something else.\n\n#### Dynamic tables\n\nIt is convenient to use a concept introduced in Section 11.2, where we analyzed hashing. The _load factor_\\(\\alpha(T)\\) of a nonempty table \\(T\\) is defined as the number of items stored in the table divided by the size (number of slots) of the table. An empty table (one with no slots) has size 0, and its load factor is defined to be 1. If the load factor of a dynamic table is bounded below by a constant, the unused space in the table is never more than a constant fraction of the total amount of space.\n\nWe start by analyzing a dynamic table that allows only insertion and then move on to the more general case that supports both insertion and deletion.\n\n#### Table expansion\n\nLet's assume that storage for a table is allocated as an array of slots. A table fills up when all slots have been used or, equivalently, when its load factor is 1.1 In some software environments, upon an attempt to insert an item into a full table, the only alternative is to abort with an error. The scenario in this section assumes, however, that the software environment, like many modern ones, provides a memory-management system that can allocate and free blocks of storage on request. Thus, upon inserting an item into a full table, the system can _expand_ the table by allocating a new table with more slots than the old table had. Because the table must always reside in contiguous memory, the system must allocate a new array for the larger table and then copy items from the old table into the new table.\n\nFootnote 1: In some situations, such as an open-address hash table, it\u2019s better to consider a table to be full if its load factor equals some constant strictly less than 1. (See Exercise 16.4-2.)\n\nA common heuristic allocates a new table with twice as many slots as the old one. If the only table operations are insertions, then the load factor of the table is always at least \\(1/2\\), and thus the amount of wasted space never exceeds half the total space in the table.\n\nThe Table-Insert procedure on the following page assumes that \\(T\\) is an object representing the table. The attribute \\(T.\\textit{table}\\) contains a pointer to the block of storage representing the table, \\(T.\\textit{num}\\) contains the number of items in the table, and \\(T.\\textit{size}\\) gives the total number of slots in the table. Initially, the table is empty: \\(T.\\textit{num}=T.\\textit{size}=0\\).\n\nThere are two types of insertion here: the Table-Insert procedure itself and the _elementary insertion_ into a table in lines 6 and 10. We can analyze the running time of Table-Insert in terms of the number of elementary insertions by assigning a cost of 1 to each elementary insertion. In most computing environments, the overhead for allocating an initial table in line 2 is constant and the overhead for allocating and freeing storage in lines 5 and 7 is dominated by the cost of transferring items in line 6. Thus, the actual running time of Table-Insert is linear in the number of elementary insertions. An _expansion_ occurs when lines 5-9 execute.\n\nNow, we'll use all three amortized analysis techniques to analyze a sequence of \\(n\\) Table-Insert operations on an initially empty table. First, we need to determine the actual cost \\(c_{i}\\) of the \\(i\\)th operation. If the current table has room for the new item (or if this is the first operation), then \\(c_{i}=1\\), since the only elementary insertion performed is the one in line 10. If the current table is full, however, and an expansion occurs, then \\(c_{i}=i\\): the cost is \\(1\\) for the elementary insertion in line 10 plus \\(i-1\\) for the items copied from the old table to the new table in line 6. For \\(n\\) operations, the worst-case cost of an operation is \\(O(n)\\), which leads to an upper bound of \\(O(n^{2})\\) on the total running time for \\(n\\) operations.\n\nThis bound is not tight, because the table rarely expands in the course of \\(n\\) Table-Insert operations. Specifically, the \\(i\\)th operation causes an expansion only when \\(i-1\\) is an exact power of \\(2\\). The amortized cost of an operation is in fact \\(O(1)\\), as an aggregate analysis shows. The cost of the \\(i\\)th operation is\n\n\\[c_{i}=\\left\\{\\begin{array}{ll}i&\\mbox{if $i-1$ is an exact power of $2$ },\\\\ 1&\\mbox{otherwise }.\\end{array}\\right.\\]\n\nThe total cost of \\(n\\) Table-Insert operations is therefore\n\n\\[\\sum_{i=1}^{n}c_{i} \\leq n\\,+\\sum_{j=0}^{\\lfloor\\lg n\\rfloor}2^{j}\\] \\[< n\\,+\\,2n\\qquad\\quad\\mbox{(by equation (A.6) on page 1142)}\\] \\[= 3n\\,\\]\n\n### Dynamic tables\n\nBecause at most \\(n\\) operations cost 1 each and the costs of the remaining operations form a geometric series. Since the total cost of \\(n\\) Table-Insert operations is bounded by \\(3n\\), the amortized cost of a single operation is at most 3.\n\nThe accounting method can provide some intuition for why the amortized cost of a Table-Insert operation should be 3. You can think of each item paying for three elementary insertions: inserting itself into the current table, moving itself the next time that the table expands, and moving some other item that was already in the table the next time that the table expands. For example, suppose that the size of the table is \\(m\\) immediately after an expansion, as shown in Figure 16.3 for \\(m=8\\). Then the table holds \\(m/2\\) items, and it contains no credit. Each call of Table-Insert charges \\(\\$3\\). The elementary insertion that occurs immediately costs \\(\\$1\\). Another \\(\\$1\\) resides on the item inserted as credit. The third \\(\\$1\\) resides as credit on one of the \\(m/2\\) items already in the table. The table will not fill again until another \\(m/2-1\\) items have been inserted, and thus, by the time the table contains \\(m\\) items and is full, each item has \\(\\$1\\) on it to pay for it to be reinserted it during the expansion.\n\nNow, let's see how to use the potential method. We'll use it again in Section 16.4.2 to design a Table-Delete operation that has an \\(O(1)\\) amortized cost\n\nFigure 16.3: Analysis of table expansion by the accounting method. Each call of Table-Insert charges \\(\\$3\\) as follows: \\(\\$1\\) to pay for the elementary insertion, \\(\\$1\\) on the item inserted as prepayment for it to be reinserted later, and \\(\\$1\\) on an item that was already in the table, also as prepayment for reinsertion. **(a)** The table immediately after an expansion, with 8 slots, 4 items (tan slots), and no stored credit. **(b)\u2013(e)** After each of 4 calls to Table-Insert, the table has one more item, with \\(\\$1\\) stored on the new item and \\(\\$1\\) stored on one of the 4 items that were present immediately after the expansion. Slots with these new items are blue. **(f)** Upon the next call to Table-Insert, the table is full, and so it expands again. Each item had \\(\\$1\\) to pay for it to be reinserted. Now the table looks as it did in part (a), with no stored credit but 16 slots and 8 items.\n\nas well. Just as the accounting method had no stored credit immediately after an expansion--that is, when \\(T.num=T.size/2\\)--let's define the potential to be 0 when \\(T.num=T.size/2\\). As elementary insertions occur, the potential needs to increase enough to pay for all the reinsertions that will happen when the table next expands. The table fills after another \\(T.size/2\\) calls of Table-Insert, when \\(T.num=T.size\\). The next call of Table-Insert after these \\(T.size/2\\) calls triggers an expansion with a cost of \\(T.size\\) to reinsert all the items. Therefore, over the course of \\(T.size/2\\) calls of Table-Insert, the potential must increase from 0 to \\(T.size\\). To achieve this increase, let's design the potential so that each call of Table-Insert increases it by\n\n\\[\\frac{T.size}{T.size/2}=2\\,\\]\n\nuntil the table expands. You can see that the potential function\n\n\\[\\Phi(T)=2(T.num-T.size/2) \\tag{16.4}\\]\n\nequals 0 immediately after the table expands, when \\(T.num=T.size/2\\), and it increases by 2 upon each insertion until the table fills. Once the table fills, that is, when \\(T.num=T.size\\), the potential \\(\\Phi(T)\\) equals \\(T.size\\). The initial value of the potential is 0, and since the table is always at least half full, \\(T.num\\geq T.size/2\\), which implies that \\(\\Phi(T)\\) is always nonnegative. Thus, the sum of the amortized costs of \\(n\\) Table-Insert operations gives an upper bound on the sum of the actual costs.\n\nTo analyze the amortized costs of table operations, it is convenient to think in terms of the change in potential due to each operation. Letting \\(\\Phi_{i}\\) denote the potential after the \\(i\\)th operation, we can rewrite equation (16.2) as\n\n\\[\\widehat{c}_{i} = c_{i}+\\Phi_{i}-\\Phi_{i-1}\\] \\[= c_{i}+\\Delta\\Phi_{i}\\,\\]\n\nwhere \\(\\Delta\\Phi_{i}\\) is the change in potential due to the \\(i\\)th operation. First, consider the case when the \\(i\\)th insertion does not cause the table to expand. In this case, \\(\\Delta\\Phi_{i}\\) is 2. Since the actual cost \\(c_{i}\\) is 1, the amortized cost is\n\n\\[\\widehat{c}_{i} = c_{i}+\\Delta\\Phi_{i}\\] \\[= 1+2\\] \\[= 3\\.\\]\n\nNow, consider the change in potential when the table does expand during the \\(i\\)th insertion because it was full immediately before the insertion. Let \\(num_{i}\\) denote the number of items stored in the table after the \\(i\\)th operation and \\(size_{i}\\) denote the total size of the table after the \\(i\\)th operation, so that \\(size_{i-1}=num_{i-1}=i-1\\)\n\n### 16.4 Dynamic tables\n\nThe first time the _time_ of the system is the time of the system, and the second time the system is the time of the system. The time of the system is the time of the system, and the time of the system is the time of the system. The time of the system is the time of the system, and the time of the system is the time of the system. The time of the system is the time of the system, and the time of the system is the time of the system. The time of the system is the time of the system, and the time of the system is the time of the system. The time of the system is the time of the system, and the time of the system is the time of the system. The time of the system is the time of the system, and the time of the system is the time of the system. The time of the system is the time of the system, and the time of the system is the time of the system. The time of the system is the time of the system, and the time of the system is the time of the system. The time of the system is the time of the system, and the time of the system is the time of the system. The time of the system is the time of the system, and the time of the system is the time of the system. The time of the system is the time of the system, and the time of the system is the time of the system. The time of the system is the time of the system, and the time of the system is the time of the system. The time of the system is the time of the system, and the time of the system is the time of the system. The time of the system is the time of the system, and the time of the system is the time of the system. The time of the system is the time of the system, and the time of the system is the time of the system. The time of the system is the time of the system, and the time of the system is the time of the system. The time of the system is the time of the system, and the time of the system is the time of the system. The time of the system is the time of the system, and the time of the system is the time of the system. The time of the system is the time of the system, and the time of the system is the time of the system. The time of the system is the time of the system, and the time of the system is the time of the system. The time of the system is the time of the system, and the time of the system is the time of the system. The time of the system is the time of the system, and the time of the system is the time of the system. The time of the system is the time of the system, and the time of the system is the time of the system. The time of the system is the time of the system, and the time of the system is the time of the system. The time of the system is the time of the system, and the time of the system is the time of the system. The time of the system is the time of the system, and the time of the system is the time of the system. The time of the system is the time of the system, and the time of the system is the time of the system. The time of the system is the time of the system, and the time of the system is the time of the system. The time of the system is the time of the system, and the time of the system is the time of the system. The time of the system is the time of the system, and the time of the system is the time of the system. The time of the system is the time of the system, and the time of the system is the time of the system. The time of the system is the time of the system, and the time of the system is the time of the system. The time of the system is the time of the system, and the time of the system is the time of the system. The time of the system is the time of the system, and the time of the system is the time of the system. The time of the system is the time of the system, and the time of the system is the time of the system. The time of the system is the time of the system, and the time of the system is the time of the system. The time of the system is the time of the system, and the time of the system is the time of the system. The time of the system is the time of the system, and the time of the system is the time of the system. The time of the system is the time of the system, and the time of the system is the time of the system. The time of the system is the time of the system, and the time of the system is the time of the system. The time of the system is the time of the system, and the time of the system is the time of the system. The time of the system is the time of the system, and the time of the system is the time of the system. The time of the system is the time of the system, and the time of the system is the time of the system. The time of the system is the time of the system, and the time of the system is the time of the system is the time of the system. The time of the system is the time of the system, and the time of the system is the time of the system is the time of the system. The time of the system is the time of the system, and the time of the system is the time of the system. The time of the system is the time of the system, and the time of the system is the time of the system is the time of the system. The time of the system is the time of the system, and the time of the system is the time of the system is the time of the system. The time of the system is the time of the system, and the time of the system is the time of the system is the time of the system. The time of the system is the time of the system, and the time of the system is the time of the system is the time of the system. The time of the system is the time of the system, and the time of the system is the time of the system is the time of the system. The time of the system is the time of the system, and the time of the system is the time of the system is the time of the system. The time of the system is the time of the system, and the time of the system is the time of the system is the time of the system. The time of the system is the time of the system, and the time of the system is the time of the system is the time of the system. The time of the system is the time of the system, and the time of the system is the time of the system is the time of the system. The time of the system is the time of the system, and the time of the system is the time of the system is the time of the system. The time of the system is the time of the system, and the time of the system is the time of the system is the time of the system. The time of the system is the time of the system, and the time of the system is the time of the system is the time of the system. The time of the system is the time of the system, and the time of the system is the time of the system is the time of the system. The time of the system is the time of the system, and the time of the system is the time of the system is the time of the system is the time of the system. The time of the system is the time of the system, and the time of the system is the time of the system is the time of the system is the time of the system. The time of the system is the time of the system, and the time of the system is the time of the system is the time of the system is the time of the system. The time of the system is the time of the system, and the time of the system is the time of the system is the time of the system is the time of the system is the time of the system. The time of the system is the time of the system is the time of the system is the time of the system. The time of the system is the time of the system, and the time of the system is the time of the system is the time of the system is the time of the system. The time of the system is the time of the system system, and the time of the system is the time of the system is the time of the system is the time of the system. The time of the system is the time of the system is the time of the system is the time of the system. The time of the system is the time of the system, and the time of the system is the time of the system is the time of the system is the time of the system. The time of the system is the time of the system system is the time of the system. The time of the system is the time of the system, and the time of the system is the time of the system is the time of the system is the time of the system. The time of the system is the time of the system system is the time of the system system. The time of the system is the time of the system system system, and the time of the system is the time of the system is the time of the system system. The time of the system is the time of the system system is the time of the system system. The time of the system is the time of the system system system, and the time of the system is the time of the system system is the time of the system system. The time of the system system is the time of theble contraction is analogous to table expansion: when the number of items in the table drops too low, allocate a new, smaller table and then copy the items from the old table into the new one. You can then free the storage for the old table by returning it to the memory-management system. In order to not waste space, yet keep the amortized costs low, the insertion and deletion procedures should preserve two properties:\n\n* the load factor of the dynamic table is bounded below by a positive constant, as well as above by 1, and\n* the amortized cost of a table operation is bounded above by a constant.\n\nThe actual cost of each operation equals the number of elementary insertions or deletions.\n\nYou might think that if you double the table size upon inserting an item into a full table, then you should halve the size when deleting an item that would cause the table to become less than half full. This strategy does indeed guarantee that the load factor of the table never drops below \\(1/2\\). Unfortunately, it can also cause the amortized cost of an operation to be quite large. Consider the following scenario. Perform \\(n\\) operations on a table \\(T\\) of size \\(n/2\\), where \\(n\\) is an exact power of 2. The first \\(n/2\\) operations are insertions, which by our previous analysis cost a total of \\(\\Theta(n)\\). At the end of this sequence of insertions, \\(T.num=T.size=n/2\\). For the second \\(n/2\\) operations, perform the following sequence:\n\ninsert, delete, delete, insert, insert, delete, insert, insert,....\n\nThe first insertion causes the table to expand to size \\(n\\). The two deletions that follow cause the table to contract back to size \\(n/2\\). Two further insertions cause another expansion, and so forth. The cost of each expansion and contraction is \\(\\Theta(n)\\), and there are \\(\\Theta(n)\\) of them. Thus, the total cost of the \\(n\\) operations is \\(\\Theta(n^{2})\\), making the amortized cost of an operation \\(\\Theta(n)\\).\n\nThe problem with this strategy is that after the table expands, not enough deletions occur to pay for a contraction. Likewise, after the table contracts, not enough insertions take place to pay for an expansion.\n\nHow can we solve this problem? Allow the load factor of the table to drop below \\(1/2\\). Specifically, continue to double the table size upon inserting an item into a full table, but halve the table size when deleting an item causes the table to become less than \\(1/4\\) full, rather than \\(1/2\\) full as before. The load factor of the table is therefore bounded below by the constant \\(1/4\\), and the load factor is \\(1/2\\) immediately after a contraction.\n\nAn expansion or contraction should exhaust all the built-up potential, so that immediately after expansion or contraction, when the load factor is \\(1/2\\), the table's potential is 0. Figure 16.5 shows the idea. As the load factor deviates from \\(1/2\\), the \n\n### Dynamic tablesto occur, at which time \\(T.num=T.size/4\\). To pay for all the reinsertions, the potential must increase from 0 to \\(T.size/4\\) over these \\(T.size/4\\) deletions. Therefore, for each call of Table-Delete until the table contracts, the potential should increase by\n\n\\[\\frac{T.size/4}{T.size/4}=1\\.\\]\n\nLikewise, when \\(\\alpha<1/2\\), each call of Table-Insert should decrease the potential by 1. When \\(1/4\\leq\\alpha(T)<1/2\\), the potential function\n\n\\[\\Phi(T)=T.size/2-T.num\\]\n\nproduces this desired behavior.\n\nPutting the two cases together, we get the potential function\n\n\\[\\Phi(T)=\\left\\{\\begin{array}{ll}2(T.num-T.size/2)&\\mbox{if $\\alpha(T)\\geq 1/2$,}\\\\ T.size/2-T.num&\\mbox{if $\\alpha(T)<1/2$.}\\end{array}\\right. \\tag{16.5}\\]\n\nThe potential of an empty table is 0 and the potential is never negative. Thus, the total amortized cost of a sequence of operations with respect to \\(\\Phi\\) provides an upper bound on the actual cost of the sequence. Figure 16.6 illustrates how the potential function behaves over a sequence of insertions and deletions.\n\nNow, let's determine the amortized costs of each operation. As before, let \\(num_{i}\\) denote the number of items stored in the table after the \\(i\\)th operation, \\(size_{i}\\) denote the total size of the table after the \\(i\\)th operation, \\(\\alpha_{i}=num_{i}/size_{i}\\) denote the load factor after the \\(i\\)th operation, \\(\\Phi_{i}\\) denote the potential after the \\(i\\)th operation, and \\(\\Delta\\Phi_{i}\\) denote the change in potential due to the \\(i\\)th operation. Initially, \\(num_{0}=0\\), \\(size_{0}=0\\), and \\(\\Phi_{0}=0\\).\n\nThe cases in which the table does not expand or contract and the load factor does not cross \\(\\alpha=1/2\\) are straightforward. As we have seen, if \\(\\alpha_{i-1}\\geq 1/2\\) and the \\(i\\)th operation is an insertion that does not cause the table to expand, then \\(\\Delta\\Phi_{i}=2\\). Likewise, if the \\(i\\)th operation is a deletion and \\(\\alpha_{i}\\geq 1/2\\), then \\(\\Delta\\Phi_{i}=-2\\). Furthermore, if \\(\\alpha_{i-1}<\\!\\!1/2\\) and the \\(i\\)th operation is a deletion that does not trigger a contraction, then \\(\\Delta\\Phi_{i}=1\\), and if the \\(i\\)th operation is an insertion and \\(\\alpha_{i}<\\!\\!1/2\\), then \\(\\Delta\\Phi_{i}=-1\\). In other words, if no expansion or contraction occurs and the load factor does not cross \\(\\alpha=1/2\\), then\n\n* if the load factor stays at or above \\(1/2\\), then the potential increases by 2 for an insertion and decreases by 2 for a deletion, and\n* if the load factor stays below \\(1/2\\), then the potential increases by 1 for a deletion and decreases by 1 for an insertion.\n\nIn each of these cases, the actual cost \\(c_{i}\\) of the \\(i\\)th operation is just 1, and so \n\n#### Dynamic tables\\[\\Phi_{i-1} = size_{i-1}/2-num_{i-1}\\] \\[= size_{i-1}/2-size_{i-1}/4\\] \\[= size_{i-1}/4\\,\\] which also equals the actual cost \\(c_{i}\\) of deleting one item and copying \\(size_{i-1}/4-1\\) items into the new, smaller table. Since \\(num_{i}=size_{i}/2-1\\) after the operation has completed, \\(\\alpha_{i}<1/2\\), and so \\[\\Phi_{i} = size_{i}/2-num_{i}\\] \\[= 1\\,\\] giving \\(\\Delta\\Phi_{i}=1-size_{i-1}/4\\). Therefore, when the \\(i\\)th operation is a deletion that triggers a contraction, its amortized cost is \\[\\widehat{c}_{i} = c_{i}+\\Delta\\Phi_{i}\\] \\[= size_{i-1}/4+(1-size_{i-1}/4)\\] \\[= 1\\.\\] Finally, we handle the cases where the load factor fits one case of equation (16.5) before the operation and the other case afterward. We start with deletion, where we have \\(num_{i-1}=size_{i-1}/2\\), so that \\(\\alpha_{i-1}=1/2\\), beforehand, and \\(num_{i}=size_{i}/2-1\\), so that \\(\\alpha_{i}<1/2\\) afterward. Because \\(\\alpha_{i-1}=1/2\\), we have \\(\\Phi_{i-1}=0\\), and because \\(\\alpha_{i}<1/2\\), we have \\(\\Phi_{i}=size_{i}/2-num_{i}=1\\). Thus we get that \\(\\Delta\\Phi_{i}=1-0=1\\). Since the \\(i\\)th operation is a deletion that does not cause a contraction, the actual cost \\(c_{i}\\) equals \\(1\\), and the amortized cost \\(\\widehat{c}_{i}\\) is \\(c_{i}+\\Delta\\Phi_{i}=1+1=2\\). Conversely, if the \\(i\\)th operation is an insertion that takes the load factor from below \\(1/2\\) to equaling \\(1/2\\), the change in potential \\(\\Delta\\Phi_{i}\\) equals \\(-1\\). Again, the actual cost \\(c_{i}\\) is \\(1\\), and now the amortized cost \\(\\widehat{c}_{i}\\) is \\(c_{i}+\\Delta\\Phi_{i}=1+(-1)=0\\). In summary, since the amortized cost of each operation is bounded above by a constant, the actual time for any sequence of \\(n\\) operations on a dynamic table is \\(O(n)\\).\n\n### Exercises\n\n#### 16.4-1\n\nUsing the potential method, analyze the amortized cost of the first table insertion.\n\n#### 16.4-2\n\nYou wish to implement a dynamic, open-address hash table. Why might you consider the table to be full when its load factor reaches some value \\(\\alpha\\) that is strictly less than 1? Describe briefly how to make insertion into a dynamic, open-address hash table run in such a way that the expected value of the amortized cost per insertion is \\(O(1)\\). Why is the expected value of the actual cost per insertion not necessarily \\(O(1)\\) for all insertions?\n\n_16.4-3_\n\nDiscuss how to use the accounting method to analyze both the insertion and deletion operations, assuming that the table doubles in size when its load factor exceeds \\(1\\) and the table halves in size when its load factor goes below \\(1/4\\).\n\n_16.4-4_\n\nSuppose that instead of contracting a table by halving its size when its load factor drops below \\(1/4\\), you contract the table by multiplying its size by \\(2/3\\) when its load factor drops below \\(1/3\\). Using the potential function\n\n\\(\\Phi(T)=\\left|2(T.num-T.size/2)\\right|\\) ,\n\nshow that the amortized cost of a Table-Delete that uses this strategy is bounded above by a constant.\n\n## Problems\n\n### Binary reflected Gray code\n\nA _binary Gray code_ represents a sequence of nonnegative integers in binary such that to go from one integer to the next, exactly one bit flips every time. The _binary reflected Gray code_ represents a sequence of the integers \\(0\\) to \\(2^{k}-1\\) for some positive integer \\(k\\) according to the following recursive method:\n\n* For \\(k=1\\), the binary reflected Gray code is \\(\\langle 0,1\\rangle\\).\n* For \\(k\\geq 2\\), first form the binary reflected Gray code for \\(k-1\\), giving the \\(2^{k-1}\\) integers \\(0\\) to \\(2^{k-1}-1\\). Then form the reflection of this sequence, which is just the sequence in reverse. (That is, the \\(j\\)th integer in the sequence becomes the \\((2^{k-1}-j-1)\\)st integer in the reflection). Next, add \\(2^{k-1}\\) to each of the \\(2^{k-1}\\) integers in the reflected sequence. Finally, concatenate the two sequences.\n\nFor example, for \\(k=2\\), first form the binary reflected Gray code \\(\\langle 0,1\\rangle\\) for \\(k=1\\). Its reflection is the sequence \\(\\langle 1,0\\rangle\\). Adding \\(2^{k-1}=2\\) to each integer in the reflection gives the sequence \\(\\langle 3,2\\rangle\\). Concatenating the two sequences gives \\(\\langle 0,1,\\)\\(3,2\\rangle\\) or, in binary, \\(\\langle 00,01,11,10\\rangle\\), so that each integer differs from its predecessor by exactly one bit. For \\(k=3\\), the reflection of the binary reflected Gray code for \\(k=2\\) is \\(\\langle 2,3,1,0\\rangle\\) and adding \\(2^{k-1}=4\\) gives \\(\\langle 6,7,5,4\\rangle\\). Concatenating produces the sequence \\(\\langle 0,1,3,2,6,7,5,4\\rangle\\), which in binary is \\(\\langle 000,001,011,010,110,111,\\)\\(101,100\\rangle\\). In the binary reflected Gray code, only one bit flips even when wrapping around from the last integer to the first.",
        "chapter": "Part IV Advanced Design and Analysis Techniques",
        "section": "16 Amortized Analysis",
        "subsection": "16.4 Dynamic tables",
        "subsubsection": "N/A"
    },
    {
        "content": "insertion is \\(O(1)\\). Why is the expected value of the actual cost per insertion not necessarily \\(O(1)\\) for all insertions?\n\n_16.4-3_\n\nDiscuss how to use the accounting method to analyze both the insertion and deletion operations, assuming that the table doubles in size when its load factor exceeds \\(1\\) and the table halves in size when its load factor goes below \\(1/4\\).\n\n_16.4-4_\n\nSuppose that instead of contracting a table by halving its size when its load factor drops below \\(1/4\\), you contract the table by multiplying its size by \\(2/3\\) when its load factor drops below \\(1/3\\). Using the potential function\n\n\\(\\Phi(T)=\\left|2(T.num-T.size/2)\\right|\\) ,\n\nshow that the amortized cost of a Table-Delete that uses this strategy is bounded above by a constant.\n\n## Problems\n\n### Binary reflected Gray code\n\nA _binary Gray code_ represents a sequence of nonnegative integers in binary such that to go from one integer to the next, exactly one bit flips every time. The _binary reflected Gray code_ represents a sequence of the integers \\(0\\) to \\(2^{k}-1\\) for some positive integer \\(k\\) according to the following recursive method:\n\n* For \\(k=1\\), the binary reflected Gray code is \\(\\langle 0,1\\rangle\\).\n* For \\(k\\geq 2\\), first form the binary reflected Gray code for \\(k-1\\), giving the \\(2^{k-1}\\) integers \\(0\\) to \\(2^{k-1}-1\\). Then form the reflection of this sequence, which is just the sequence in reverse. (That is, the \\(j\\)th integer in the sequence becomes the \\((2^{k-1}-j-1)\\)st integer in the reflection). Next, add \\(2^{k-1}\\) to each of the \\(2^{k-1}\\) integers in the reflected sequence. Finally, concatenate the two sequences.\n\nFor example, for \\(k=2\\), first form the binary reflected Gray code \\(\\langle 0,1\\rangle\\) for \\(k=1\\). Its reflection is the sequence \\(\\langle 1,0\\rangle\\). Adding \\(2^{k-1}=2\\) to each integer in the reflection gives the sequence \\(\\langle 3,2\\rangle\\). Concatenating the two sequences gives \\(\\langle 0,1,\\)\\(3,2\\rangle\\) or, in binary, \\(\\langle 00,01,11,10\\rangle\\), so that each integer differs from its predecessor by exactly one bit. For \\(k=3\\), the reflection of the binary reflected Gray code for \\(k=2\\) is \\(\\langle 2,3,1,0\\rangle\\) and adding \\(2^{k-1}=4\\) gives \\(\\langle 6,7,5,4\\rangle\\). Concatenating produces the sequence \\(\\langle 0,1,3,2,6,7,5,4\\rangle\\), which in binary is \\(\\langle 000,001,011,010,110,111,\\)\\(101,100\\rangle\\). In the binary reflected Gray code, only one bit flips even when wrapping around from the last integer to the first.\n\n* Index the integers in a binary reflected Gray code from \\(0\\) to \\(2^{k}-1\\), and consider the \\(i\\)th integer in the binary reflected Gray code. To go from the \\((i-1)\\)st integer to the \\(i\\)th integer in the binary reflected Gray code, exactly one bit flips. Show how to determine which bit flips, given the index \\(i\\).\n* Assuming that given a bit number \\(j\\), you can flip bit \\(j\\) of an integer in constant time, show how to compute the entire binary reflected Gray code sequence of \\(2^{k}\\) numbers in \\(\\Theta(2^{k})\\) time.\n\n#### 16.2 Making binary search dynamic\n\nBinary search of a sorted array takes logarithmic search time, but the time to insert a new element is linear in the size of the array. You can improve the time for insertion by keeping several sorted arrays.\n\nSpecifically, suppose that you wish to support Search and Insert on a set of \\(n\\) elements. Let \\(k=\\lceil\\lg(n+1)\\rceil\\), and let the binary representation of \\(n\\) be \\(\\langle n_{k-1},\\,n_{k-2},\\,\\ldots,\\,n_{0}\\rangle\\). Maintain \\(k\\) sorted arrays \\(A_{0},\\,A_{1},\\ldots,\\,A_{k-1}\\), where for \\(i=0,1,\\ldots,k-1\\), the length of array \\(A_{i}\\) is \\(2^{i}\\). Each array is either full or empty, depending on whether \\(n_{i}=1\\) or \\(n_{i}=0\\), respectively. The total number of elements held in all \\(k\\) arrays is therefore \\(\\sum_{i=0}^{k-1}n_{i}\\)\\(2^{i}=n\\). Although each individual array is sorted, elements in different arrays bear no particular relationship to each other.\n\n* Describe how to perform the Search operation for this data structure. Analyze its worst-case running time.\n* Describe how to perform the Insert operation. Analyze its worst-case and amortized running times, assuming that the only operations are Insert and Search.\n* Describe how to implement Delete. Analyze its worst-case and amortized running times, assuming that there can be Delete, Insert, and Search operations.\n\n#### 16.3 Amortized weight-balanced trees\n\nConsider an ordinary binary search tree augmented by adding to each node \\(x\\) the attribute \\(x\\)._size_, which gives the number of keys stored in the subtree rooted at \\(x\\). Let \\(\\alpha\\) be a constant in the range \\(1/2\\leq\\alpha<1\\). We say that a given node \\(x\\) is _\\(\\alpha\\)-balanced_ if \\(x\\)._left_\\(\\_size\\leq\\alpha\\cdot x\\)._size_ and \\(x\\)._right_._size_\\(\\leq\\alpha\\cdot x\\)._size_. The tree as a whole is _\\(\\alpha\\)-balanced_ if every node in the tree is \\(\\alpha\\)-balanced. The following amortized approach to maintaining weight-balanced trees was suggested by G. Varghese.\n\nA \\(1/2\\)-balanced tree is, in a sense, as balanced as it can be. Given a node \\(x\\) in an arbitrary binary search tree, show how to rebuild the subtree rooted at \\(x\\) so that it becomes \\(1/2\\)-balanced. Your algorithm should run in \\(\\Theta(x.size)\\) time, and it can use \\(O(x.size)\\) auxiliary storage.\n\nShow that performing a search in an \\(n\\)-node \\(\\alpha\\)-balanced binary search tree takes \\(O(\\lg n)\\) worst-case time.\n\nFor the remainder of this problem, assume that the constant \\(\\alpha\\) is strictly greater than \\(1/2\\). Suppose that you implement Insert and Delete as usual for an \\(n\\)-node binary search tree, except that after every such operation, if any node in the tree is no longer \\(\\alpha\\)-balanced, then you \"rebuild\" the subtree rooted at the highest such node in the tree so that it becomes \\(1/2\\)-balanced.\n\nWe'll analyze this rebuilding scheme using the potential method. For a node \\(x\\) in a binary search tree \\(T\\), define\n\n\\[\\Delta(x)=|x.\\mathit{left}.size-x.\\mathit{right}.size|\\enspace.\\]\n\nDefine the potential of \\(T\\) as\n\n\\[\\Phi(T)=\\underset{x\\in T:\\Delta(x)\\geq 2}{c}\\sum_{x\\in T:\\Delta(x)\\geq 2}\\Delta(x)\\]\n\nwhere \\(c\\) is a sufficiently large constant that depends on \\(\\alpha\\).\n\nArgue that any binary search tree has nonnegative potential and also that a \\(1/2\\)-balanced tree has potential \\(0\\).\n\nSuppose that \\(m\\) units of potential can pay for rebuilding an \\(m\\)-node subtree. How large must \\(c\\) be in terms of \\(\\alpha\\) in order for it to take \\(O(1)\\) amortized time to rebuild a subtree that is not \\(\\alpha\\)-balanced?\n\nShow that inserting a node into or deleting a node from an \\(n\\)-node \\(\\alpha\\)-balanced tree costs \\(O(\\lg n)\\) amortized time.\n\nThe cost of restructuring red-black treesThere are four basic operations on red-black trees that perform _structural modifications_: node insertions, node deletions, rotations, and color changes. We have seen that RB-Insert and RB-Delete use only \\(O(1)\\) rotations, node insertions, and node deletions to maintain the red-black properties, but they may make many more color changes.\n\nDescribe a legal red-black tree with \\(n\\) nodes such that calling RB-Insert to add the (\\(n+1\\))st node causes \\(\\Omega(\\lg n)\\) color changes. Then describe a legal red-black tree with \\(n\\) nodes for which calling RB-Delete on a particular node causes \\(\\Omega(\\lg n)\\) color changes.\n\nAlthough the worst-case number of color changes per operation can be logarithmic, you will prove that any sequence of \\(m\\) RB-Insert and RB-Delete operations on an initially empty red-black tree causes \\(O(m)\\) structural modifications in the worst case.\n\n_b._ Some of the cases handled by the main loop of the code of both RB-Insert-Fixup and RB-Delete-Fixup are _terminating_: once encountered, they cause the loop to terminate after a constant number of additional operations. For each of the cases of RB-Insert-Fixup and RB-Delete-Fixup, specify which are terminating and which are not. (_Hint_: Look at Figures 13.5, 13.6, and 13.7 in Sections 13.3 and 13.4.)\n\nYou will first analyze the structural modifications when only insertions are performed. Let \\(T\\) be a red-black tree, and define \\(\\Phi(T)\\) to be the number of red nodes in \\(T\\). Assume that one unit of potential can pay for the structural modifications performed by any of the three cases of RB-Insert-Fixup.\n\n_c._ Let \\(T^{\\prime}\\) be the result of applying Case 1 of RB-Insert-Fixup to \\(T\\). Argue that \\(\\Phi(T^{\\prime})=\\Phi(T)-1\\).\n\n_d._ We can break the operation of the RB-Insert procedure into three parts. List the structural modifications and potential changes resulting from lines 1-16 of RB-Insert, from nonterminating cases of RB-Insert-Fixup, and from terminating cases of RB-Insert-Fixup.\n\n_e._ Using part (d), argue that the amortized number of structural modifications performed by any call of RB-Insert is \\(O(1)\\).\n\nNext you will prove that there are \\(O(m)\\) structural modifications when both insertions and deletions occur. Define, for each node \\(x\\),\n\n\\[w(x)=\\left\\{\\begin{array}{ll}0&\\mbox{if $x$ is red,}\\\\ 1&\\mbox{if $x$ is black and has no red children,}\\\\ 0&\\mbox{if $x$ is black and has one red child,}\\\\ 2&\\mbox{if $x$ is black and has two red children.}\\end{array}\\right.\\]\n\nNow redefine the potential of a red-black tree \\(T\\) as\n\n\\[\\Phi(T)=\\sum_{x\\in T}w(x)\\,\\]and let \\(T^{\\prime}\\) be the tree that results from applying any nonterminating case of RB-Insert-Fixup or RB-Delete-Fixup to \\(T\\).\n* Show that \\(\\Phi(T^{\\prime})\\leq\\Phi(T)-1\\) for all nonterminating cases of RB-Insert-Fixup. Argue that the amortized number of structural modifications performed by any call of RB-Insert-Fixup is \\(O(1)\\).\n* Show that \\(\\Phi(T^{\\prime})\\leq\\Phi(T)-1\\) for all nonterminating cases of RB-Delete-Fixup. Argue that the amortized number of structural modifications performed by any call of RB-Delete-Fixup is \\(O(1)\\).\n* Complete the proof that in the worst case, any sequence of \\(m\\) RB-Insert and RB-Delete operations performs \\(O(m)\\) structural modifications.\n\n## Chapter notes\n\nAho, Hopcroft, and Ullman [5] used aggregate analysis to determine the running time of operations on a disjoint-set forest. We'll analyze this data structure using the potential method in Chapter 19. Tarjan [430] surveys the accounting and potential methods of amortized analysis and presents several applications. He attributes the accounting method to several authors, including M. R. Brown, R. E. Tarjan, S. Huddleston, and K. Mehlhorn. He attributes the potential method to D. D. Sleator. The term \"amortized\" is due to D. D. Sleator and R. E. Tarjan.\n\nPotential functions are also useful for proving lower bounds for certain types of problems. For each configuration of the problem, define a potential function that maps the configuration to a real number. Then determine the potential \\(\\Phi_{\\mathrm{init}}\\) of the initial configuration, the potential \\(\\Phi_{\\mathrm{final}}\\) of the final configuration, and the maximum change in potential \\(\\Delta\\Phi_{\\mathrm{max}}\\) due to any step. The number of steps must therefore be at least \\(\\left|\\Phi_{\\mathrm{final}}-\\Phi_{\\mathrm{init}}\\right|/\\left|\\Delta\\Phi_{ \\mathrm{max}}\\right|\\). Examples of potential functions to prove lower bounds in I/O complexity appear in works by Cormen, Sundquist, and Wisniewski [105], Floyd [146], and Aggarwal and Vitter [3]. Krumme, Cybenko, and Venkataraman [271] applied potential functions to prove lower bounds on _gossiping_: communicating a unique item from each vertex in a graph to every other vertex.",
        "chapter": "Part IV Advanced Design and Analysis Techniques",
        "section": "16 Amortized Analysis",
        "subsection": "Problems",
        "subsubsection": "N/A"
    },
    {
        "content": "and let \\(T^{\\prime}\\) be the tree that results from applying any nonterminating case of RB-Insert-Fixup or RB-Delete-Fixup to \\(T\\).\n* Show that \\(\\Phi(T^{\\prime})\\leq\\Phi(T)-1\\) for all nonterminating cases of RB-Insert-Fixup. Argue that the amortized number of structural modifications performed by any call of RB-Insert-Fixup is \\(O(1)\\).\n* Show that \\(\\Phi(T^{\\prime})\\leq\\Phi(T)-1\\) for all nonterminating cases of RB-Delete-Fixup. Argue that the amortized number of structural modifications performed by any call of RB-Delete-Fixup is \\(O(1)\\).\n* Complete the proof that in the worst case, any sequence of \\(m\\) RB-Insert and RB-Delete operations performs \\(O(m)\\) structural modifications.\n\n## Chapter notes\n\nAho, Hopcroft, and Ullman [5] used aggregate analysis to determine the running time of operations on a disjoint-set forest. We'll analyze this data structure using the potential method in Chapter 19. Tarjan [430] surveys the accounting and potential methods of amortized analysis and presents several applications. He attributes the accounting method to several authors, including M. R. Brown, R. E. Tarjan, S. Huddleston, and K. Mehlhorn. He attributes the potential method to D. D. Sleator. The term \"amortized\" is due to D. D. Sleator and R. E. Tarjan.\n\nPotential functions are also useful for proving lower bounds for certain types of problems. For each configuration of the problem, define a potential function that maps the configuration to a real number. Then determine the potential \\(\\Phi_{\\text{init}}\\) of the initial configuration, the potential \\(\\Phi_{\\text{final}}\\) of the final configuration, and the maximum change in potential \\(\\Delta\\Phi_{\\text{max}}\\) due to any step. The number of steps must therefore be at least \\(\\left|\\Phi_{\\text{final}}-\\Phi_{\\text{init}}\\right|/\\left|\\Delta\\Phi_{\\text{ max}}\\right|\\). Examples of potential functions to prove lower bounds in I/O complexity appear in works by Cormen, Sundquist, and Wisniewski [105], Floyd [146], and Aggarwal and Vitter [3]. Krumme, Cybenko, and Venkataraman [271] applied potential functions to prove lower bounds on _gossiping_: communicating a unique item from each vertex in a graph to every other vertex.",
        "chapter": "Part IV Advanced Design and Analysis Techniques",
        "section": "16 Amortized Analysis",
        "subsection": "Chapter notes",
        "subsubsection": "N/A"
    },
    {
        "content": "## Introduction\n\nThis part returns to studying data structures that support operations on dynamic sets, but at a more advanced level than Part III. One of the chapters, for example, makes extensive use of the amortized analysis techniques from Chapter 16.\n\nChapter 17 shows how to augment red-black trees--adding additional information in each node--to support dynamic-set operations in addition to those covered in Chapters 12 and 13. The first example augments red-black trees to dynamically maintain order statistics for a set of keys. Another example augments them in a different way to maintain intervals of real numbers. Chapter 17 includes a theorem giving sufficient conditions for when a red-black tree can be augmented while maintaining the \\(O(\\lg n)\\) running times for insertion and deletion.\n\nChapter 18 presents B-trees, which are balanced search trees specifically designed to be stored on disks. Since disks operate much more slowly than random-access memory, B-tree performance depends not only on how much computing time the dynamic-set operations consume but also on how many disk accesses they perform. For each B-tree operation, the number of disk accesses increases with the height of the B-tree, but B-tree operations keep the height low.\n\nChapter 19 examines data structures for disjoint sets. Starting with a universe of \\(n\\) elements, each initially in its own singleton set, the operation Union unites two sets. At all times, the \\(n\\) elements are partitioned into disjoint sets, even as calls to the Union operation change the members of a set dynamically. The query Find-Set identifies the unique set that contains a given element at the moment. Representing each set as a simple rooted tree yields surprisingly fast operations: a sequence of \\(m\\) operations runs in \\(O(m\\ \\alpha(n))\\) time, where \\(\\alpha(n)\\) is an incredibly slowly growing function--\\(\\alpha(n)\\) is at most 4 in any conceivable application. The amortized analysis that proves this time bound is as complex as the data structure is simple.\n\nThe topics covered in this part are by no means the only examples of \"advanced\" data structures. Other advanced data structures include the following:\n\n* _Fibonacci heaps_[156] implement mergeable heaps (see Problem 10-2 on page 268) with the operations Insert, Minimum, and Union taking only \\(O(1)\\) actual and amortized time, and the operations Extract-Min and Delete taking \\(O(\\lg n)\\) amortized time. The most significant advantage of these data structures, however, is that Decrease-Key takes only \\(O(1)\\) amortized time. _Strict Fibonacci heaps_[73], developed later, made all of these time bounds actual. Because the Decrease-Key operation takes constant amortized time, (strict) Fibonacci heaps constitute key components of some of the asymptotically fastest algorithms to date for graph problems.\n* _Dynamic trees_[415, 429] maintain a forest of disjoint rooted trees. Each edge in each tree has a real-valued cost. Dynamic trees support queries to find parents, roots, edge costs, and the minimum edge cost on a simple path from a node up to a root. Trees may be manipulated by cutting edges, updating all edge costs on a simple path from a node up to a root, linking a root into another tree, and making a node the root of the tree it appears in. One implementation of dynamic trees gives an \\(O(\\lg n)\\) amortized time bound for each operation, while a more complicated implementation yields \\(O(\\lg n)\\) worst-case time bounds. Dynamic trees are used in some of the asymptotically fastest network-flow algorithms.\n* _Splay trees_[429, 418] are a form of binary search tree on which the standard search-tree operations run in \\(O(\\lg n)\\) amortized time. One application of splay trees simplifies dynamic trees.\n* _Persistent_ data structures allow queries, and sometimes updates as well, on past versions of a data structure. For example, linked data structures can be made persistent with only a small time and space cost [126]. Problem 13-1 gives a simple example of a persistent dynamic set.\n* Several data structures allow a faster implementation of dictionary operations (Insert, Delete, and Search) for a restricted universe of keys. By taking advantage of these restrictions, they are able to achieve better worst-case asymptotic running times than comparison-based data structures. If the keys are unique integers drawn from the set \\(\\{0,1,2,\\ldots,u-1\\}\\), where \\(u\\) is an exact power of 2, then a recursive data structure known as a _van Emde Boas tree_[440, 441] supports each of the operations Search, Insert, Delete, Minimum, Maximum, Successor, and Predecessor in \\(O(\\lg\\lg u)\\) time. _Fusion trees_[157] were the first data structure to allow faster dictionary operations when the universe is restricted to integers, implementing these operations in \\(O(\\lg n/\\lg\\lg n)\\) time. Several subsequent data structures, including _exponential search trees_[17], have also given improved bounds on some or all of the dictionary operations and are mentioned in the chapter notes throughout this book.\n* _Dynamic graph data structures_ support various queries while allowing the structure of a graph to change through operations that insert or delete vertices or edges. Examples of the queries that they support include vertex connectivity [214], edge connectivity, minimum spanning trees [213], biconnectivity, and transitive closure [212].\n\nChapter notes throughout this book mention additional data structures.\n\n## Chapter 17 Augmenting Data Structures\n\nSome solutions require no more than a \"textbook\" data structure -- such as a doubly linked list, a hash table, or a binary search tree -- but many others require a dash of creativity. Rarely will you need to create an entirely new type of data structure, though. More often, you can augment a textbook data structure by storing additional information in it. You can then program new operations for the data structure to support your application. Augmenting a data structure is not always straightforward, however, since the added information must be updated and maintained by the ordinary operations on the data structure.\n\nThis chapter discusses two data structures based on red-black trees that are augmented with additional information. Section 17.1 describes a data structure that supports general order-statistic operations on a dynamic set: quickly finding the \\(i\\)th smallest number or the rank of a given element. Section 17.2 abstracts the process of augmenting a data structure and provides a theorem that you can use when augmenting red-black trees. Section 17.3 uses this theorem to help design a data structure for maintaining a dynamic set of intervals, such as time intervals. You can use this data structure to quickly find an interval that overlaps a given query interval.\n\n### 17.1 Dynamic order statistics\n\nChapter 9 introduced the notion of an order statistic. Specifically, the \\(i\\)th order statistic of a set of \\(n\\) elements, where \\(i\\in\\{1,2,\\ldots,n\\}\\), is simply the element in the set with the \\(i\\)th smallest key. In Chapter 9, you saw how to determine any order statistic in \\(O(n)\\) time from an unordered set. This section shows how to modify red-black trees so that you can determine any order statistic for a dynamic set in \\(O(\\lg n)\\) time and also compute the \\(\\boldsymbol{rank}\\) of an element -- its position in the linear order of the set--in \\(O(\\lg n)\\) time.",
        "chapter": "Part V Advanced Data Structures",
        "section": "Introduction",
        "subsection": "N/A",
        "subsubsection": "N/A"
    },
    {
        "content": "## Chapter 17 Augmenting Data Structures\n\nSome solutions require no more than a \"textbook\" data structure -- such as a doubly linked list, a hash table, or a binary search tree -- but many others require a dash of creativity. Rarely will you need to create an entirely new type of data structure, though. More often, you can augment a textbook data structure by storing additional information in it. You can then program new operations for the data structure to support your application. Augmenting a data structure is not always straightforward, however, since the added information must be updated and maintained by the ordinary operations on the data structure.\n\nThis chapter discusses two data structures based on red-black trees that are augmented with additional information. Section 17.1 describes a data structure that supports general order-statistic operations on a dynamic set: quickly finding the \\(i\\)th smallest number or the rank of a given element. Section 17.2 abstracts the process of augmenting a data structure and provides a theorem that you can use when augmenting red-black trees. Section 17.3 uses this theorem to help design a data structure for maintaining a dynamic set of intervals, such as time intervals. You can use this data structure to quickly find an interval that overlaps a given query interval.\n\n### 17.1 Dynamic order statistics\n\nChapter 9 introduced the notion of an order statistic. Specifically, the \\(i\\)th order statistic of a set of \\(n\\) elements, where \\(i\\in\\{1,2,\\ldots,n\\}\\), is simply the element in the set with the \\(i\\)th smallest key. In Chapter 9, you saw how to determine any order statistic in \\(O(n)\\) time from an unordered set. This section shows how to modify red-black trees so that you can determine any order statistic for a dynamic set in \\(O(\\lg n)\\) time and also compute the \\(\\boldsymbol{rank}\\) of an element--its position in the linear order of the set--in \\(O(\\lg n)\\) time.\n\n### Dynamic order statistics\n\nFigure 17.1 shows a data structure that can support fast order-statistic operations. An _order-statistic tree_\\(T\\) is simply a red-black tree with additional information stored in each node. Each node \\(x\\) contains the usual red-black tree attributes \\(x.\\mathit{key}\\), \\(x.\\mathit{color}\\), \\(x.\\mathit{p}\\), \\(x.\\mathit{left}\\), and \\(x.\\mathit{right}\\), along with a new attribute, \\(x.\\mathit{size}\\). This attribute contains the number of internal nodes in the subtree rooted at \\(x\\) (including \\(x\\) itself, but not including any sentinels), that is, the size of the subtree. If we define the sentinel's size to be \\(0\\)-- that is, we set \\(T.\\mathit{nil}.\\mathit{size}\\) to be \\(0\\)--then we have the identity \\(x.\\mathit{size}=x.\\mathit{left}.\\mathit{size}+x.\\mathit{right}.\\mathit{size }+1\\).\n\nKeys need not be distinct in an order-statistic tree. For example, the tree in Figure 17.1 has two keys with value \\(14\\) and two keys with value \\(21\\). When equal keys are present, the above notion of rank is not well defined. We remove this ambiguity for an order-statistic tree by defining the rank of an element as the position at which it would be printed in an inorder walk of the tree. In Figure 17.1, for example, the key \\(14\\) stored in a black node has rank \\(5\\), and the key \\(14\\) stored in a red node has rank \\(6\\).\n\n#### Retrieving the element with a given rank\n\nBefore we show how to maintain the size information during insertion and deletion, let's see how to implement two order-statistic queries that use this additional information. We begin with an operation that retrieves the element with a given rank. The procedure OS-Select(\\(x,i\\)) on the following page returns a pointer to the node containing the \\(i\\)th smallest key in the subtree rooted at \\(x\\). To find the node with the \\(i\\)th smallest key in an order-statistic tree \\(T\\), call OS-Select(\\(T.\\mathit{root},i\\)).\n\nHere is how OS-Select works. Line 1 computes \\(r\\), the rank of node \\(x\\) within the subtree rooted at \\(x\\). The value of \\(x.\\mathit{left}.\\mathit{size}\\) is the number of nodes that come\n\nFigure 17.1: An order-statistic tree, which is an augmented red-black tree. In addition to its usual attributes, each node \\(x\\) has an attribute \\(x.\\mathit{size}\\), which is the number of nodes, other than the sentinel, in the subtree rooted at \\(x\\).\n\nbefore \\(x\\) in an inorder tree walk of the subtree rooted at \\(x\\). Thus, \\(x.\\mathit{left}.size+1\\) is the rank of \\(x\\) within the subtree rooted at \\(x\\). If \\(i=r\\), then node \\(x\\) is the \\(i\\)th smallest element, and so line 3 returns \\(x\\). If \\(i<r\\), then the \\(i\\)th smallest element resides in \\(x\\)'s left subtree, and therefore, line 5 recurses on \\(x.\\mathit{left}\\). If \\(i>r\\), then the \\(i\\)th smallest element resides in \\(x\\)'s right subtree. Since the subtree rooted at \\(x\\) contains \\(r\\) elements that come before \\(x\\)'s right subtree in an inorder tree walk, the \\(i\\)th smallest element in the subtree rooted at \\(x\\) is the \\((i-r)\\)th smallest element in the subtree rooted at \\(x.\\mathit{right}\\). Line 6 determines this element recursively.\n\nAs an example of how OS-Select operates, consider a search for the 17th smallest element in the order-statistic tree of Figure 17.1. The search starts with \\(x\\) as the root, whose key is 26, and with \\(i=17\\). Since the size of 26's left subtree is 12, its rank is 13. Thus, the node with rank 17 is the \\(17-13=4\\)th smallest element in 26's right subtree. In the recursive call, \\(x\\) is the node with key 41, and \\(i=4\\). Since the size of 41's left subtree is 5, its rank within its subtree is 6. Therefore, the node with rank 4 is the 4th smallest element in 41's left subtree. In the recursive call, \\(x\\) is the node with key 30, and its rank within its subtree is 2. The procedure recurses once again to find the \\(4-2=2\\)nd smallest element in the subtree rooted at the node with key 38. Its left subtree has size 1, which means it is the second smallest element. Thus, the procedure returns a pointer to the node with key 38.\n\nBecause each recursive call goes down one level in the order-statistic tree, the total time for OS-Select is at worst proportional to the height of the tree. Since the tree is a red-black tree, its height is \\(O(\\lg n)\\), where \\(n\\) is the number of nodes. Thus, the running time of OS-Select is \\(O(\\lg n)\\) for a dynamic set of \\(n\\) elements.\n\n#### Determining the rank of an element\n\nGiven a pointer to a node \\(x\\) in an order-statistic tree \\(T\\), the procedure OS-Rank on the facing page returns the position of \\(x\\) in the linear order determined by an inorder tree walk of \\(T\\).\n\n### Dynamic order statistics\n\n\\begin{tabular}{l l l} OS-Rank(\\(T,x\\)) & & \\\\\n1 & \\(r=x.\\mathit{left}.size+1\\) & // rank of \\(x\\) within the subtree rooted at \\(x\\) \\\\\n2 & \\(y=x\\) & // root of subtree being examined \\\\\n3 & **while**\\(y\\neq T.\\mathit{root}\\) & \\\\\n4 & **if**\\(y==y.p.\\mathit{right}\\) & // if root of a right subtree \\(\\ldots\\) \\\\\n5 & \\(r=r+y.p.\\mathit{left}.size+1\\) & // \\(\\ldots\\) add in parent and its left subtree \\\\\n6 & \\(y=y.p\\) & // move \\(y\\) toward the root \\\\\n7 & **return**\\(r\\) & \\\\ \\end{tabular}\n\nThe OS-Rank procedure works as follows. You can think of node \\(x\\)'s rank as the number of nodes preceding \\(x\\) in an inorder tree walk, plus 1 for \\(x\\) itself. OS-Rank maintains the following loop invariant:\n\nAt the start of each iteration of the **while** loop of lines 3-6, \\(r\\) is the rank of \\(x.\\mathit{key}\\) in the subtree rooted at node \\(y\\).\n\nWe use this loop invariant to show that OS-Rank works correctly as follows:\n\n**Initialization:**: Prior to the first iteration, line 1 sets \\(r\\) to be the rank of \\(x.\\mathit{key}\\) within the subtree rooted at \\(x\\). Setting \\(y=x\\) in line 2 makes the invariant true the first time the test in line 3 executes.\n**Maintenance:**: At the end of each iteration of the **while** loop, line 6 sets \\(y=y.p\\). Thus, we must show that if \\(r\\) is the rank of \\(x.\\mathit{key}\\) in the subtree rooted at \\(y\\) at the start of the loop body, then \\(r\\) is the rank of \\(x.\\mathit{key}\\) in the subtree rooted at \\(y.p\\) at the end of the loop body. In each iteration of the **while** loop, consider the subtree rooted at \\(y.p\\). The value of \\(r\\) already includes the number of nodes in the subtree rooted at node \\(y\\) that precede \\(x\\) in an inorder walk, and so the procedure must add the nodes in the subtree rooted at \\(y\\)'s sibling that precede \\(x\\) in an inorder walk, plus 1 for \\(y.p\\) if it, too, precedes \\(x\\). If \\(y\\) is a left child, then neither \\(y.p\\) nor any node in \\(y.p\\)'s right subtree precedes \\(x\\), and so OS-Rank leaves \\(r\\) alone. Otherwise, \\(y\\) is a right child and all the nodes in \\(y.p\\)'s left subtree precede \\(x\\), as does \\(y.p\\) itself. In this case, line 5 adds \\(y.p.\\mathit{left}.size+1\\) to the current value of \\(r\\).\n**Termination:**: Because each iteration of the loop moves \\(y\\) toward the root and the loop terminates when \\(y=T.\\mathit{root}\\), the loop eventually terminates. Moreover, the subtree rooted at \\(y\\) is the entire tree. Thus, the value of \\(r\\) is the rank of \\(x.\\mathit{key}\\) in the entire tree.\n\nAs an example, when OS-Rank runs on the order-statistic tree of Figure 17.1 to find the rank of the node with key 38, the following sequence of values of \\(y.\\mathit{key}\\) and \\(r\\) occurs at the top of the **while** loop:\n\n\\begin{tabular}{c c c} iteration & \\(y\\). _key_ & \\(r\\) \\\\ \\hline\n1 & 38 & 2 \\\\\n2 & 30 & 4 \\\\\n3 & 41 & 4 \\\\\n4 & 26 & 17 \\\\ \\end{tabular} The procedure returns the rank 17.\n\nSince each iteration of the **while** loop takes \\(O(1)\\) time, and \\(y\\) goes up one level in the tree with each iteration, the running time of OS-Rank is at worst proportional to the height of the tree: \\(O(\\lg n)\\) on an \\(n\\)-node order-statistic tree.\n\n#### Maintaining subtree sizes\n\nGiven the _size_ attribute in each node, OS-Select and OS-Rank can quickly compute order-statistic information. But if the basic modifying operations on red-black trees cannot efficiently maintain the _size_ attribute, our work will have been for naught. Let's see how to maintain subtree sizes for both insertion and deletion without affecting the asymptotic running time of either operation.\n\nRecall from Section 13.3 that insertion into a red-black tree consists of two phases. The first phase goes down the tree from the root, inserting the new node as a child of an existing node. The second phase goes up the tree, changing colors and performing rotations to maintain the red-black properties.\n\nTo maintain the subtree sizes in the first phase, simply increment \\(x\\). _size_ for each node \\(x\\) on the simple path traversed from the root down toward the leaves. The new node added gets a _size_ of 1. Since there are \\(O(\\lg n)\\) nodes on the traversed path, the additional cost of maintaining the _size_ attributes is \\(O(\\lg n)\\).\n\nIn the second phase, the only structural changes to the underlying red-black tree are caused by rotations, of which there are at most two. Moreover, a rotation is a local operation: only two nodes have their _size_ attributes invalidated. The link around which the rotation is performed is incident on these two nodes. Referring to the code for Left-Rotate\\((T,x)\\) on page 336, add the following lines:\n\n\\begin{tabular}{c c} iteration & \\(y\\). _size_ & \\(x\\). _size_ \\\\\n14 & \\(x\\). _size_ & \\(x\\). _left_. _size_ + \\(x\\). _right_. _size_ + 1 \\\\ \\end{tabular} Figure 17.2 illustrates how the attributes are updated. The change to Right-Rotate is symmetric.\n\nSince inserting into a red-black tree requires at most two rotations, updating the _size_ attributes in the second phase costs only \\(O(1)\\) additional time. Thus, the total time for insertion into an \\(n\\)-node order-statistic tree is \\(O(\\lg n)\\), which is asymptotically the same as for an ordinary red-black tree.\n\n### Dynamic order statistics\n\nDeletion from a red-black tree also consists of two phases: the first operates on the underlying search tree, and the second causes at most three rotations and otherwise performs no structural changes. (See Section 13.4.) The first phase removes one node \\(z\\) from the tree and could move at most two other nodes within the tree (nodes \\(y\\) and \\(x\\) in Figure 12.4 on page 12.4). To update the subtree sizes, simply traverse a simple path from the lowest node that moves (starting from its original position within the tree) up to the root, decrementing the _size_ attribute of each node on the path. Since this path has length \\(O(\\lg n)\\) in an \\(n\\)-node red-black tree, the additional time spent maintaining _size_ attributes in the first phase is \\(O(\\lg n)\\). For the \\(O(1)\\) rotations in the second phase of deletion, handle them in the same manner as for insertion. Thus, both insertion and deletion, including maintaining the _size_ attributes, take \\(O(\\lg n)\\) time for an \\(n\\)-node order-statistic tree.\n\n##### Exercises\n\n##### 17.1-1\n\nShow how OS-Select(\\(T.root,10\\)) operates on the red-black tree \\(T\\) shown in Figure 17.1.\n\n##### 17.1-2\n\nShow how OS-Rank(\\(T,x\\)) operates on the red-black tree \\(T\\) shown in Figure 17.1 and the node \\(x\\) with \\(x.\\mathit{key}=35\\).\n\n##### 17.1-3\n\nWrite a nonrecursive version of OS-Select.\n\n##### 17.1-4\n\nWrite a procedure OS-Key-Rank(\\(T,k\\)) that takes an order-statistic tree \\(T\\) and a key \\(k\\) and returns the rank of \\(k\\) in the dynamic set represented by \\(T\\). Assume that the keys of \\(T\\) are distinct.\n\nFigure 17.2: Updating subtree sizes during rotations. The updates are local, requiring only the _size_ information stored in \\(x\\), \\(y\\), and the roots of the subtrees shown as triangles.\n\n### 17.1-5\n\nGiven an element \\(x\\) in an \\(n\\)-node order-statistic tree and a natural number \\(i\\), show how to determine the \\(i\\)th successor of \\(x\\) in the linear order of the tree in \\(O(\\lg n)\\) time.\n\n### 17.1-6\n\nThe procedures OS-Select and OS-Rank use the _size_ attribute of a node only to compute a rank. Suppose that you store in each node its rank in the subtree of which it is the root instead of the _size_ attribute. Show how to maintain this information during insertion and deletion. (Remember that these two operations can cause rotations.)\n\n### 17.1-7\n\nShow how to use an order-statistic tree to count the number of inversions (see Problem 2-4 on page 47) in an array of \\(n\\) distinct elements in \\(O(n\\lg n)\\) time.\n\n* _17.1-8_ Consider \\(n\\) chords on a circle, each defined by its endpoints. Describe an \\(O(n\\lg n)\\)-time algorithm to determine the number of pairs of chords that intersect inside the circle. (For example, if the \\(n\\) chords are all diameters that meet at the center, then the answer is \\(\\binom{n}{2}\\).) Assume that no two chords share an endpoint.\n\n### 17.2 How to augment a data structure\n\nThe process of augmenting a basic data structure to support additional functionality occurs quite frequently in algorithm design. We'll use it again in the next section to design a data structure that supports operations on intervals. This section examines the steps involved in such augmentation. It includes a useful theorem that allows you to augment red-black trees easily in many cases.\n\nYou can break the process of augmenting a data structure into four steps:\n\n1. Choose an underlying data structure.\n2. Determine additional information to maintain in the underlying data structure.\n3. Verify that you can maintain the additional information for the basic modifying operations on the underlying data structure.\n4. Develop new operations.\n\nAs with any prescriptive design method, you'll rarely be able to follow the steps precisely in the order given. Most design work contains an element of trial and error, and progress on all steps usually proceeds in parallel. There is no point,",
        "chapter": "Part V Advanced Data Structures",
        "section": "17 Augmenting Data Structures",
        "subsection": "17.1 Dynamic order statistics",
        "subsubsection": "N/A"
    },
    {
        "content": "### 17.1-5\n\nGiven an element \\(x\\) in an \\(n\\)-node order-statistic tree and a natural number \\(i\\), show how to determine the \\(i\\)th successor of \\(x\\) in the linear order of the tree in \\(O(\\lg n)\\) time.\n\n### 17.1-6\n\nThe procedures OS-Select and OS-Rank use the _size_ attribute of a node only to compute a rank. Suppose that you store in each node its rank in the subtree of which it is the root instead of the _size_ attribute. Show how to maintain this information during insertion and deletion. (Remember that these two operations can cause rotations.)\n\n### 17.1-7\n\nShow how to use an order-statistic tree to count the number of inversions (see Problem 2-4 on page 47) in an array of \\(n\\) distinct elements in \\(O(n\\lg n)\\) time.\n\n* _17.1-8_ Consider \\(n\\) chords on a circle, each defined by its endpoints. Describe an \\(O(n\\lg n)\\)-time algorithm to determine the number of pairs of chords that intersect inside the circle. (For example, if the \\(n\\) chords are all diameters that meet at the center, then the answer is \\(\\binom{n}{2}\\).) Assume that no two chords share an endpoint.\n\n### 17.2 How to augment a data structure\n\nThe process of augmenting a basic data structure to support additional functionality occurs quite frequently in algorithm design. We'll use it again in the next section to design a data structure that supports operations on intervals. This section examines the steps involved in such augmentation. It includes a useful theorem that allows you to augment red-black trees easily in many cases.\n\nYou can break the process of augmenting a data structure into four steps:\n\n1. Choose an underlying data structure.\n2. Determine additional information to maintain in the underlying data structure.\n3. Verify that you can maintain the additional information for the basic modifying operations on the underlying data structure.\n4. Develop new operations.\n\nAs with any prescriptive design method, you'll rarely be able to follow the steps precisely in the order given. Most design work contains an element of trial and error, and progress on all steps usually proceeds in parallel. There is no point,for example, in determining additional information and developing new operations (steps 2 and 4) if you cannot maintain the additional information efficiently. Nevertheless, this four-step method provides a good focus for your efforts in augmenting a data structure, and it is also a good framework for documenting an augmented data structure.\n\nWe followed these four steps in Section 17.1 to design order-statistic trees. For step 1, we chose red-black trees as the underlying data structure. Red-black trees seemed like a good starting point because they efficiently support other dynamic-set operations on a total order, such as Minimum, Maximum, Successor, and Predecessor.\n\nIn Step 2, we added the _size_ attribute, so that each node \\(x\\) stores the size of the subtree rooted at \\(x\\). Generally, the additional information makes operations more efficient. For example, it is possible to implement OS-Select and OS-Rank using just the keys stored in the tree, but then they would not run in \\(O(\\lg n)\\) time. Sometimes, the additional information is pointer information rather than data, as in Exercise 17.2-1.\n\nFor step 3, we ensured that insertion and deletion can maintain the _size_ attributes while still running in \\(O(\\lg n)\\) time. Ideally, you would like to update only a few elements of the data structure in order to maintain the additional information. For example, if each node simply stores its rank in the tree, the OS-Select and OS-Rank procedures run quickly, but inserting a new minimum element might cause a change to this information in every node of the tree. Because we chose to store subtree sizes instead, inserting a new element causes information to change in only \\(O(\\lg n)\\) nodes.\n\nIn Step 4, we developed the operations OS-Select and OS-Rank. After all, the need for new operations is why anyone bothers to augment a data structure in the first place. Occasionally, rather than developing new operations, you can use the additional information to expedite existing ones, as in Exercise 17.2-1.\n\n#### Augmenting red-black trees\n\nWhen red-black trees underlie an augmented data structure, we can prove that insertion and deletion can always efficiently maintain certain kinds of additional information, thereby simplifying step 3. The proof of the following theorem is similar to the argument from Section 17.1 that we can maintain the _size_ attribute for order-statistic trees.\n\n_Theorem 17.1 (Augmenting a red-black tree)_\n\nLet \\(f\\) be an attribute that augments a red-black tree \\(T\\) of \\(n\\) nodes, and suppose that the value of \\(f\\) for each node \\(x\\) depends only the information in nodes \\(x\\), \\(x\\)_left_, and \\(x\\)_right_ (possibly including \\(x\\),_left_,\\(f\\) and \\(x\\),_right_,\\(f\\)), and that the value of \\(x\\),\\(f\\) can be computed from this information in \\(O(1)\\) time. Then, the insertion and deletion operations can maintain the values of \\(f\\) in all nodes of \\(T\\) without asymptotically affecting the \\(O(\\lg n)\\) running times of these operations.\n\nProofThe main idea of the proof is that a change to an \\(f\\) attribute in a node \\(x\\) propagates only to ancestors of \\(x\\) in the tree. That is, changing \\(x.f\\) may require \\(x.p.f\\) to be updated, but nothing else; updating \\(x.p.f\\) may require \\(x.p.p.f\\) to be updated, but nothing else; and so on up the tree. After updating \\(T.root.f\\), no other node depends on the new value, and so the process terminates. Since the height of a red-black tree is \\(O(\\lg n)\\), changing an \\(f\\) attribute in a node costs \\(O(\\lg n)\\) time in updating all nodes that depend on the change.\n\nAs we saw in Section 13.3, insertion of a node \\(x\\) into red-black tree \\(T\\) consists of two phases. If the tree \\(T\\) is empty, then the first phase simply makes \\(x\\) be the root of \\(T\\). If \\(T\\) is not empty, then the first phase inserts \\(x\\) as a child of an existing node. Because we assume that the value of \\(x.f\\) depends only on information in the other attributes of \\(x\\) itself and the information in \\(x\\)'s children, and because \\(x\\)'s children are both the sentinel \\(T.nil\\), it takes only \\(O(1)\\) time to compute the value of \\(x.f\\). Having computed \\(x.f\\), the change propagates up the tree. Thus, the total time for the first phase of insertion is \\(O(\\lg n)\\). During the second phase, the only structural changes to the tree come from rotations. Since only two nodes change in a rotation, but a change to an attribute might need to propagate up to the root, the total time for updating the \\(f\\) attributes is \\(O(\\lg n)\\) per rotation. Since the number of rotations during insertion is at most two, the total time for insertion is \\(O(\\lg n)\\).\n\nLike insertion, deletion has two phases, as Section 13.4 discusses. In the first phase, changes to the tree occur when a node is deleted, and at most two other nodes could move within the tree. Propagating the updates to \\(f\\) caused by these changes costs at most \\(O(\\lg n)\\), since the changes modify the tree locally along a simple path from the lowest changed node to the root. Fixing up the red-black tree during the second phase requires at most three rotations, and each rotation requires at most \\(O(\\lg n)\\) time to propagate the updates to \\(f\\). Thus, like insertion, the total time for deletion is \\(O(\\lg n)\\).\n\nIn many cases, such as maintaining the _size_ attributes in order-statistic trees, the cost of updating after a rotation is \\(O(1)\\), rather than the \\(O(\\lg n)\\) derived in the proof of Theorem 17.1. Exercise 17.2-3 gives an example.\n\nOn the other hand, when an update after a rotation requires a traversal all the way up to the root, it is important that insertion into and deletion from a red-black tree require a constant number of rotations. The chapter notes for Chapter 13 list other schemes for balancing search trees that do not bound the number of rotations per insertion or deletion by a constant. If each operation might require \\(\\Theta(\\lg n)\\) rota tions and each rotation traverses a path up to the root, then a single operation could require \\(\\Theta(\\lg^{2}n)\\) time, rather than the \\(O(\\lg n)\\) time bound given by Theorem 17.1.\n\n##### Exercises\n\n##### 17.2-1\n\nShow, by adding pointers to the nodes, how to support each of the dynamic-set queries Minimum, Maximum, Successor, and Predecessor in \\(O(1)\\) worst-case time on an augmented order-statistic tree. The asymptotic performance of other operations on order-statistic trees should not be affected.\n\n##### 17.2-2\n\nCan you maintain the black-heights of nodes in a red-black tree as attributes in the nodes of the tree without affecting the asymptotic performance of any of the red-black tree operations? Show how, or argue why not. How about maintaining the depths of nodes?\n\n##### 17.2-3\n\nLet \\(\\otimes\\) be an associative binary operator, and let \\(a\\) be an attribute maintained in each node of a red-black tree. Suppose that you want to include in each node \\(x\\) an additional attribute \\(f\\) such that \\(x.f=x_{1}.a\\otimes x_{2}.a\\otimes\\cdots\\otimes x_{m}.a\\), where \\(x_{1},x_{2},\\ldots,x_{m}\\) is the inorder listing of nodes in the subtree rooted at \\(x\\). Show how to update the \\(f\\) attributes in \\(O(1)\\) time after a rotation. Modify your argument slightly to apply it to the _size_ attributes in order-statistic trees.\n\n##### Interval trees\n\nThis section shows how to augment red-black trees to support operations on dynamic sets of intervals. In this section, we'll assume that intervals are closed. Extending the results to open and half-open intervals is conceptually straightforward. (See page 1157 for definitions of closed, open, and half-open intervals.)\n\nIntervals are convenient for representing events that each occupy a continuous period of time. For example, you could query a database of time intervals to find out which events occurred during a given interval. The data structure in this section provides an efficient means for maintaining such an interval database.\n\nA simple way to represent an interval \\([t_{1},t_{2}]\\) is as an object \\(i\\) with attributes \\(i.low=t_{1}\\) (the _low endpoint_) and \\(i.high=t_{2}\\) (the _high endpoint_). We say that intervals \\(i\\) and \\(i^{\\prime}\\)_overlap_ if \\(i\\cap i^{\\prime}\\neq\\emptyset\\), that is, if \\(i.low\\leq i^{\\prime}.high\\) and \\(i^{\\prime}.low\\leq i.high\\)",
        "chapter": "Part V Advanced Data Structures",
        "section": "17 Augmenting Data Structures",
        "subsection": "17.2 How to augment a data structure",
        "subsubsection": "N/A"
    },
    {
        "content": "tions and each rotation traverses a path up to the root, then a single operation could require \\(\\Theta(\\lg^{2}n)\\) time, rather than the \\(O(\\lg n)\\) time bound given by Theorem 17.1.\n\n##### Exercises\n\n##### 17.2-1\n\nShow, by adding pointers to the nodes, how to support each of the dynamic-set queries Minimum, Maximum, Successor, and Predecessor in \\(O(1)\\) worst-case time on an augmented order-statistic tree. The asymptotic performance of other operations on order-statistic trees should not be affected.\n\n##### 17.2-2\n\nCan you maintain the black-heights of nodes in a red-black tree as attributes in the nodes of the tree without affecting the asymptotic performance of any of the red-black tree operations? Show how, or argue why not. How about maintaining the depths of nodes?\n\n##### 17.2-3\n\nLet \\(\\otimes\\) be an associative binary operator, and let \\(a\\) be an attribute maintained in each node of a red-black tree. Suppose that you want to include in each node \\(x\\) an additional attribute \\(f\\) such that \\(x.f=x_{1}.a\\otimes x_{2}.a\\otimes\\cdots\\otimes x_{m}.a\\), where \\(x_{1},x_{2},\\ldots,x_{m}\\) is the inorder listing of nodes in the subtree rooted at \\(x\\). Show how to update the \\(f\\) attributes in \\(O(1)\\) time after a rotation. Modify your argument slightly to apply it to the _size_ attributes in order-statistic trees.\n\n##### Interval trees\n\nThis section shows how to augment red-black trees to support operations on dynamic sets of intervals. In this section, we'll assume that intervals are closed. Extending the results to open and half-open intervals is conceptually straightforward. (See page 1157 for definitions of closed, open, and half-open intervals.)\n\nIntervals are convenient for representing events that each occupy a continuous period of time. For example, you could query a database of time intervals to find out which events occurred during a given interval. The data structure in this section provides an efficient means for maintaining such an interval database.\n\nA simple way to represent an interval \\([t_{1},t_{2}]\\) is as an object \\(i\\) with attributes \\(i.low=t_{1}\\) (the _low endpoint_) and \\(i.high=t_{2}\\) (the _high endpoint_). We say that intervals \\(i\\) and \\(i^{\\prime}\\)_overlap_ if \\(i\\cap i^{\\prime}\\neq\\emptyset\\), that is, if \\(i.low\\leq i^{\\prime}.high\\) and \\(i^{\\prime}.low\\leq i.high\\)As Figure 17.3 shows, any two intervals \\(i\\) and \\(i^{\\prime}\\) satisfy the _interval trichotomy_, that is, exactly one of the following three properties holds:\n\n1. \\(i\\) and \\(i^{\\prime}\\) overlap,\n2. \\(i\\) is to the left of \\(i^{\\prime}\\) (i.e., \\(i\\). \\(high<i^{\\prime}\\). \\(low\\)),\n3. \\(i\\) is to the right of \\(i^{\\prime}\\) (i.e., \\(i^{\\prime}\\). \\(high<i\\). \\(low\\)).\n\nAn _interval tree_ is a red-black tree that maintains a dynamic set of elements, with each element \\(x\\) containing an interval \\(x\\). \\(int\\). Interval trees support the following operations:\n\nInterval-Insert(\\(T,x\\)) adds the element \\(x\\), whose \\(int\\) attribute is assumed to contain an interval, to the interval tree \\(T\\).\n\nInterval-Delete(\\(T,x\\)) removes the element \\(x\\) from the interval tree \\(T\\).\n\nInterval-Search(\\(T,i\\)) returns a pointer to an element \\(x\\) in the interval tree \\(T\\) such that \\(x\\). \\(int\\) overlaps interval \\(i\\), or a pointer to the sentinel \\(T\\). \\(nil\\) if no such element belongs to the set.\n\nFigure 17.4 shows how an interval tree represents a set of intervals. The four-step method from Section 17.2 will guide our design of an interval tree and the operations that run on it.\n\n### Step 1: Underlying data structure\n\nA red-black tree serves as the underlying data structure. Each node \\(x\\) contains an interval \\(x\\). \\(int\\). The key of \\(x\\) is the low endpoint, \\(x\\). \\(int\\). \\(low\\), of the interval. Thus, an inorder tree walk of the data structure lists the intervals in sorted order by low endpoint.\n\n### 17.3 Interval trees\n\n#### Step 2: Additional information\n\nIn addition to the intervals themselves, each node \\(x\\) contains a value \\(x.max\\), which is the maximum value of any interval endpoint stored in the subtree rooted at \\(x\\).\n\n#### Step 3: Maintaining the information\n\nWe must verify that insertion and deletion take \\(O(\\lg n)\\) time on an interval tree of \\(n\\) nodes. It is simple enough to determine \\(x.max\\) in \\(O(1)\\) time, given interval \\(x.int\\) and the \\(max\\) values of node \\(x\\)'s children:\n\n\\[x.max=\\max\\left\\{x.int.high,x.left.max,x.right.max\\right\\}\\.\\]\n\nFigure 17.4: An interval tree. **(a)** A set of 10 intervals, shown sorted bottom to top by left endpoint. **(b)** The interval tree that represents them. Each node \\(x\\) contains an interval, shown above the dashed line, and the maximum value of any interval endpoint in the subtree rooted at \\(x\\), shown below the dashed line. An inorder tree walk of the tree lists the nodes in sorted order by left endpoint.\n\nThus, by Theorem 17.1, insertion and deletion run in \\(O(\\lg n)\\) time. In fact, you can use either Exercise 17.2-3 or 17.3-1 to show how to update all the \\(max\\) attributes that change after a rotation in just \\(O(1)\\) time.\n\n### Step 4: Developing new operations\n\nThe only new operation is Interval-Search\\((T,i)\\), which finds a node in tree \\(T\\) whose interval overlaps interval \\(i\\). If there is no interval in the tree that overlaps \\(i\\), the procedure returns a pointer to the sentinel \\(T.nil\\).\n\nInterval-Search\\((T,i)\\)\n\n\\(x=T.root\\)\n\n\\(x\\neq T.nil\\) and \\(i\\) does not overlap \\(x.int\\)\n\n\\(x.left\\neq T.nil\\) and \\(x.left.max\\geq i.low\\)\n\n\\(x=x.left\\) // overlap in left subtree or no overlap in right subtree\n\n\\(x=x.right\\) no overlap in left subtree\n\n\\(x\\)\n\nThe search for an interval that overlaps \\(i\\) starts at the root of the tree and proceeds downward. It terminates when either it finds an overlapping interval or it reaches the sentinel \\(T.nil\\). Since each iteration of the basic loop takes \\(O(1)\\) time, and since the height of an \\(n\\)-node red-black tree is \\(O(\\lg n)\\), the Interval-Search procedure takes \\(O(\\lg n)\\) time.\n\nBefore we see why Interval-Search is correct, let's examine how it works on the interval tree in Figure 17.4. Let's look for an interval that overlaps the interval \\(i=[22,25]\\). Begin with \\(x\\) as the root, which contains \\([16,21]\\) and does not overlap \\(i\\). Since \\(x.left.max=23\\) is greater than \\(i.low=22\\), the loop continues with \\(x\\) as the left child of the root--the node containing \\([8,9]\\), which also does not overlap \\(i\\). This time, \\(x.left.max=10\\) is less than \\(i.low=22\\), and so the loop continues with the right child of \\(x\\) as the new \\(x\\). Because the interval \\([15,23]\\) stored in this node overlaps \\(i\\), the procedure returns this node.\n\nNow let's try an unsuccessful search, for an interval that overlaps \\(i=[11,14]\\) in the interval tree of Figure 17.4. Again, begin with \\(x\\) as the root. Since the root's interval \\([16,21]\\) does not overlap \\(i\\), and since \\(x.left.max=23\\) is greater than \\(i.low=11\\), go left to the node containing \\([8,9]\\). Interval \\([8,9]\\) does not overlap \\(i\\), and \\(x.left.max=10\\) is less than \\(i.low=11\\), and so the search goes right. (No interval in the left subtree overlaps \\(i\\).) Interval \\([15,23]\\) does not overlap \\(i\\), and its left child is \\(T.nil\\), so again the search goes right, the loop terminates, and Interval-Search returns the sentinel \\(T.nil\\).\n\nTo see why Interval-Search is correct, we must understand why it suffices to examine a single path from the root. The basic idea is that at any node \\(x\\), if \\(x.\\mathit{int}\\) does not overlap \\(i\\), the search always proceeds in a safe direction: the search will definitely find an overlapping interval if the tree contains one. The following theorem states this property more precisely.\n\n**Theorem 17.2**: Any execution of Interval-Search\\((T,i)\\) either returns a node whose interval overlaps \\(i\\), or it returns \\(T.\\mathit{nil}\\) and the tree \\(T\\) contains no node whose interval overlaps \\(i\\).\n\nProofThe **while** loop of lines 2-5 terminates when either \\(x=T.\\mathit{nil}\\) or \\(i\\) overlaps \\(x.\\mathit{int}\\). In the latter case, it is certainly correct to return \\(x\\). Therefore, we focus on the former case, in which the **while** loop terminates because \\(x=T.\\mathit{nil}\\), which is the node that Interval-Search returns.\n\nWe'll prove that if the procedure returns \\(T.\\mathit{nil}\\), then it did not miss any intervals in \\(T\\) that overlap \\(i\\). The idea is to show that whether the search goes left in line 4 or right in line 5, it always heads toward a node containing an interval overlapping \\(i\\), if any such interval exists. In particular, we'll prove that\n\n1. If the search goes left in line 4, then the left subtree of node \\(x\\) contains an interval that overlaps \\(i\\) or the right subtree of \\(x\\) contains no interval that overlaps \\(i\\). Therefore, even if \\(x\\)'s left subtree contains no interval that overlaps \\(i\\) but the search goes left, it does not make a mistake, because \\(x\\)'s right subtree does not contain an interval overlapping \\(i\\), either.\n2. If the search goes right in line 5, then the left subtree of \\(x\\) contains no interval that overlaps \\(i\\). Thus, if the search goes right, it does not make a mistake.\n\nFor both cases, we rely on the interval trichotomy. Let's start with the case where the search goes right, whose proof is simpler. By the tests in line 3, we know that \\(x.\\mathit{left}=T.\\mathit{nil}\\) or \\(x.\\mathit{left}.\\mathit{max}<i.\\mathit{low}\\). If \\(x.\\mathit{left}=T.\\mathit{nil}\\), then \\(x\\)'s left subtree contains no interval that overlaps \\(i\\), since it contains no intervals at all. Now suppose that \\(x.\\mathit{left}\\neq T.\\mathit{nil}\\), so that we must have \\(x.\\mathit{left}.\\mathit{max}<i.\\mathit{low}\\). Consider any interval \\(i^{\\prime}\\) in \\(x\\)'s left subtree. Because \\(x.\\mathit{left}.\\mathit{max}\\) is the maximum endpoint in \\(x\\)'s left subtree, we have \\(i^{\\prime}.\\mathit{high}\\leq x.\\mathit{left}.\\mathit{max}\\). Thus, as Figure 17.5(a) shows,\n\n\\[i^{\\prime}.\\mathit{high} \\leq x.\\mathit{left}.\\mathit{max}\\] \\[< i.\\mathit{low}\\.\\]\n\nBy the interval trichotomy, therefore, intervals \\(i\\) and \\(i^{\\prime}\\) do not overlap, and so \\(x\\)'s left subtree contains no interval that overlaps \\(i\\).\n\nNow we examine the case in which the search goes left. If the left subtree of node \\(x\\) contains an interval that overlaps \\(i\\), we're done, so let's assume that no node in \\(x\\)'s left subtree overlaps \\(i\\). We need to show that in this case, no node in \\(x\\)'s right subtree overlaps \\(i\\), so that going left will not miss any overlaps in \\(x\\)'s right subtree. By the tests in line 3, the left subtree of \\(x\\) is not empty and \\(x.\\mathit{left}.\\mathit{max}\\geq i.\\mathit{low}\\). By the definition of the \\(\\mathit{max}\\) attribute, \\(x\\)'s left subtree contains some interval \\(i^{\\prime}\\) such that\n\n\\[i^{\\prime}.\\mathit{high} = x.\\mathit{left}.\\mathit{max}\\] \\[\\geq i.\\mathit{low}\\,\\]\n\nas illustrated in Figure 17.5(b). Since \\(i^{\\prime}\\) is in \\(x\\)'s left subtree, it does not overlap \\(i\\), and since \\(i^{\\prime}.\\mathit{high}\\geq i.\\mathit{low}\\), the interval trichotomy tells us that \\(i.\\mathit{high}<i^{\\prime}.\\mathit{low}\\). Now we bring in the property that interval trees are keyed on the low endpoints of intervals. Because \\(i^{\\prime}\\) is in \\(x\\)'s left subtree, we have \\(i^{\\prime}.\\mathit{low}\\leq x.\\mathit{int}.\\mathit{low}\\). Now consider any interval \\(i^{\\prime\\prime}\\) in \\(x\\)'s right subtree, so that \\(x.\\mathit{int}.\\mathit{low}\\leq i^{\\prime\\prime}.\\mathit{low}\\). Putting inequalities together, we get\n\n\\[i.\\mathit{high} < i^{\\prime}.\\mathit{low}\\] \\[\\leq x.\\mathit{int}.\\mathit{low}\\] \\[\\leq i^{\\prime\\prime}.\\mathit{low}\\.\\]\n\nBecause \\(i.\\mathit{high}<i^{\\prime\\prime}.\\mathit{low}\\), the interval trichotomy tells us that \\(i\\) and \\(i^{\\prime\\prime}\\) do not overlap. Since we chose \\(i^{\\prime\\prime}\\) as any interval in \\(x\\)'s right subtree, no node in \\(x\\)'s right subtree overlaps \\(i\\).\n\nThus, the Interval-Search procedure works correctly.\n\nFigure 17.5: Intervals in the proof of Theorem 17.2. The value of \\(x.\\mathit{left}.\\mathit{max}\\) is shown in each case as a dashed line. **(a)** The search goes right. No interval \\(i^{\\prime}\\) in \\(x\\)\u2019s left subtree can overlap \\(i\\). **(b)** The search goes left. The left subtree of \\(x\\) contains an interval that overlaps \\(i\\) (situation not shown), or \\(x\\)\u2019s left subtree contains an interval \\(i^{\\prime}\\) such that \\(i^{\\prime}.\\mathit{high}=x.\\mathit{left}.\\mathit{max}\\). Since \\(i\\) does not overlap \\(i^{\\prime}\\), neither does it overlap any interval \\(i^{\\prime\\prime}\\) in \\(x\\)\u2019s right subtree, since \\(i^{\\prime}.\\mathit{low}\\leq i^{\\prime\\prime}.\\mathit{low}\\).\n\n### 17.3 Interval trees\n\n**Exercises**\n\n_17.3-1_\n\nWrite pseudocode for Left-Rotate that operates on nodes in an interval tree and updates all the \\(max\\) attributes that change in \\(O(1)\\) time.\n\n_17.3-2_\n\nDescribe an efficient algorithm that, given an interval \\(i\\), returns an interval overlapping \\(i\\) that has the minimum low endpoint, or \\(T.nil\\) if no such interval exists.\n\n_17.3-3_\n\nGiven an interval tree \\(T\\) and an interval \\(i\\), describe how to list all intervals in \\(T\\) that overlap \\(i\\) in \\(O(\\min\\left\\{n,k\\lg n\\right\\})\\) time, where \\(k\\) is the number of intervals in the output list. (_Hint:_ One simple method makes several queries, modifying the tree between queries. A slightly more complicated method does not modify the tree.)\n\n_17.3-4_\n\nSuggest modifications to the interval-tree procedures to support the new operation Interval-Search-Exactly\\((T,i)\\), where \\(T\\) is an interval tree and \\(i\\) is an interval. The operation should return a pointer to a node \\(x\\) in \\(T\\) such that \\(x.int.low=i.low\\) and \\(x.int.high=i.high\\), or \\(T.nil\\) if \\(T\\) contains no such node. All operations, including Interval-Search-Exactly, should run in \\(O(\\lg n)\\) time on an \\(n\\)-node interval tree.\n\n_17.3-5_\n\nShow how to maintain a dynamic set \\(Q\\) of numbers that supports the operation Min-Gap, which gives the absolute value of the difference of the two closest numbers in \\(Q\\). For example, if we have \\(Q=\\left\\{1,5,9,15,18,22\\right\\}\\), then Min-Gap\\((Q)\\) returns 3, since 15 and 18 are the two closest numbers in \\(Q\\). Make the operations Insert, Delete, Search, and Min-Gap as efficient as possible, and analyze their running times.\n\n**7.3-6**\n\nVLSI databases commonly represent an integrated circuit as a list of rectangles. Assume that each rectangle is rectilinearly oriented (sides parallel to the \\(x\\)- and \\(y\\)-axes), so that each rectangle is represented by four values: its minimum and maximum \\(x\\)- and \\(y\\)-coordinates. Give an \\(O(n\\lg n)\\)-time algorithm to decide whether a set of \\(n\\) rectangles so represented contains two rectangles that overlap. Your algorithm need not report all intersecting pairs, but it must report that an overlap exists if one rectangle entirely covers another, even if the boundary lines do not intersect. (_Hint:_ Move a \"sweep\" line across the set of rectangles.)\n\n## Chapter 17 Augmenting Data Structures\n\n### 17-1 Point of maximum overlap\n\nYou wish to keep track of a _point of maximum overlap_ in a set of intervals--a point with the largest number of intervals in the set that overlap it.\n\n* Show that there is always a point of maximum overlap that is an endpoint of one of the intervals.\n* Design a data structure that efficiently supports the operations Interval-Insert, Interval-Delete, and Find-POM, which returns a point of maximum overlap. (_Hint:_ Keep a red-black tree of all the endpoints. Associate a value of \\(+1\\) with each left endpoint, and associate a value of \\(-1\\) with each right endpoint. Augment each node of the tree with some extra information to maintain the point of maximum overlap.)\n\n### 17-2 Josephus permutation\n\nWe define the _Josephus problem_ as follows. A group of \\(n\\) people form a circle, and we are given a positive integer \\(m\\leq n\\). Beginning with a designated first person, proceed around the circle, removing every \\(m\\)th person. After each person is removed, counting continues around the circle that remains. This process continues until nobody remains in the circle. The order in which the people are removed from the circle defines the \\((n,m)\\)**-Josephus permutation** of the integers \\(1,2,\\ldots,n\\). For example, the \\((7,3)\\)-Josephus permutation is \\(\\langle 3,6,2,7,5,1,4\\rangle\\).\n\n* Suppose that \\(m\\) is a constant. Describe an \\(O(n)\\)-time algorithm that, given an integer \\(n\\), outputs the \\((n,m)\\)-Josephus permutation.\n* Suppose that \\(m\\) is not necessarily a constant. Describe an \\(O(n\\lg n)\\)-time algorithm that, given integers \\(n\\) and \\(m\\), outputs the \\((n,m)\\)-Josephus permutation.\n\n### Chapter notes\n\nIn their book, Preparata and Shamos [364] describe several of the interval trees that appear in the literature, citing work by H. Edelsbrunner (1980) and E. M. McCreight (1981). The book details an interval tree that, given a static database of \\(n\\) intervals, allows us to enumerate all \\(k\\) intervals that overlap a given query interval in \\(O(k\\,+\\lg n)\\) time.",
        "chapter": "Part V Advanced Data Structures",
        "section": "17 Augmenting Data Structures",
        "subsection": "17.3 Interval trees",
        "subsubsection": "N/A"
    },
    {
        "content": "## Chapter 17 Augmenting Data Structures\n\n### 17-1 Point of maximum overlap\n\nYou wish to keep track of a _point of maximum overlap_ in a set of intervals--a point with the largest number of intervals in the set that overlap it.\n\n* Show that there is always a point of maximum overlap that is an endpoint of one of the intervals.\n* Design a data structure that efficiently supports the operations Interval-Insert, Interval-Delete, and Find-POM, which returns a point of maximum overlap. (_Hint:_ Keep a red-black tree of all the endpoints. Associate a value of \\(+1\\) with each left endpoint, and associate a value of \\(-1\\) with each right endpoint. Augment each node of the tree with some extra information to maintain the point of maximum overlap.)\n\n### 17-2 Josephus permutation\n\nWe define the _Josephus problem_ as follows. A group of \\(n\\) people form a circle, and we are given a positive integer \\(m\\leq n\\). Beginning with a designated first person, proceed around the circle, removing every \\(m\\)th person. After each person is removed, counting continues around the circle that remains. This process continues until nobody remains in the circle. The order in which the people are removed from the circle defines the \\((n,m)\\)**-Josephus permutation** of the integers \\(1,2,\\ldots,n\\). For example, the \\((7,3)\\)-Josephus permutation is \\(\\langle 3,6,2,7,5,1,4\\rangle\\).\n\n* Suppose that \\(m\\) is a constant. Describe an \\(O(n)\\)-time algorithm that, given an integer \\(n\\), outputs the \\((n,m)\\)-Josephus permutation.\n* Suppose that \\(m\\) is not necessarily a constant. Describe an \\(O(n\\lg n)\\)-time algorithm that, given integers \\(n\\) and \\(m\\), outputs the \\((n,m)\\)-Josephus permutation.\n\n### Chapter notes\n\nIn their book, Preparata and Shamos [364] describe several of the interval trees that appear in the literature, citing work by H. Edelsbrunner (1980) and E. M. McCreight (1981). The book details an interval tree that, given a static database of \\(n\\) intervals, allows us to enumerate all \\(k\\) intervals that overlap a given query interval in \\(O(k\\,+\\lg n)\\) time.",
        "chapter": "Part V Advanced Data Structures",
        "section": "17 Augmenting Data Structures",
        "subsection": "Problems",
        "subsubsection": "N/A"
    },
    {
        "content": "## Chapter 17 Augmenting Data Structures\n\n### 17-1 Point of maximum overlap\n\nYou wish to keep track of a _point of maximum overlap_ in a set of intervals--a point with the largest number of intervals in the set that overlap it.\n\n* Show that there is always a point of maximum overlap that is an endpoint of one of the intervals.\n* Design a data structure that efficiently supports the operations Interval-Insert, Interval-Delete, and Find-POM, which returns a point of maximum overlap. (_Hint:_ Keep a red-black tree of all the endpoints. Associate a value of \\(+1\\) with each left endpoint, and associate a value of \\(-1\\) with each right endpoint. Augment each node of the tree with some extra information to maintain the point of maximum overlap.)\n\n### 17-2 Josephus permutation\n\nWe define the _Josephus problem_ as follows. A group of \\(n\\) people form a circle, and we are given a positive integer \\(m\\leq n\\). Beginning with a designated first person, proceed around the circle, removing every \\(m\\)th person. After each person is removed, counting continues around the circle that remains. This process continues until nobody remains in the circle. The order in which the people are removed from the circle defines the \\((n,m)\\)**-Josephus permutation** of the integers \\(1,2,\\ldots,n\\). For example, the \\((7,3)\\)-Josephus permutation is \\(\\langle 3,6,2,7,5,1,4\\rangle\\).\n\n* Suppose that \\(m\\) is a constant. Describe an \\(O(n)\\)-time algorithm that, given an integer \\(n\\), outputs the \\((n,m)\\)-Josephus permutation.\n* Suppose that \\(m\\) is not necessarily a constant. Describe an \\(O(n\\lg n)\\)-time algorithm that, given integers \\(n\\) and \\(m\\), outputs the \\((n,m)\\)-Josephus permutation.\n\n### Chapter notes\n\nIn their book, Preparata and Shamos [364] describe several of the interval trees that appear in the literature, citing work by H. Edelsbrunner (1980) and E. M. McCreight (1981). The book details an interval tree that, given a static database of \\(n\\) intervals, allows us to enumerate all \\(k\\) intervals that overlap a given query interval in \\(O(k+\\lg n)\\) time.\n\nB-trees are balanced search trees designed to work well on disk drives or other direct-access secondary storage devices. B-trees are similar to red-black trees (Chapter 13), but they are better at minimizing the number of operations that access disks. (We often say just \"disk\" instead of \"disk drive.\") Many database systems use B-trees, or variants of B-trees, to store information.\n\nB-trees differ from red-black trees in that B-tree nodes may have many children, from a few to thousands. That is, the \"branching factor\" of a B-tree can be quite large, although it usually depends on characteristics of the disk drive used. B-trees are similar to red-black trees in that every \\(n\\)-node B-tree has height \\(O(\\lg n)\\), so that B-trees can implement many dynamic-set operations in \\(O(\\lg n)\\) time. But a B-tree has a larger branching factor than a red-black tree, so the base of the logarithm that expresses its height is larger, and hence its height can be considerably lower.\n\nB-trees generalize binary search trees in a natural manner. Figure 18.1 shows a simple B-tree. If an internal B-tree node \\(x\\) contains \\(x\\). \\(n\\) keys, then \\(x\\) has \\(x\\). \\(n\\)\\(+\\)\\(1\\) children. The keys in node \\(x\\) serve as dividing points separating the range of keys handled by \\(x\\) into \\(x\\). \\(n\\)\\(+\\)\\(1\\) subranges, each handled by one child of \\(x\\). A search for a key in a B-tree makes an (\\(x\\). \\(n\\)\\(+\\)\\(1\\))-way decision based on comparisons with the \\(x\\). \\(n\\) keys stored at node \\(x\\). An internal node contains pointers to its children, but a leaf node does not.\n\nSection 18.1 gives a precise definition of B-trees and proves that the height of a B-tree grows only logarithmically with the number of nodes it contains. Section 18.2 describes how to search for a key and insert a key into a B-tree, and Section 18.3 discusses deletion. Before proceeding, however, we need to ask why we evaluate data structures designed to work on a disk drive differently from data structures designed to work in main random-access memory.",
        "chapter": "Part V Advanced Data Structures",
        "section": "17 Augmenting Data Structures",
        "subsection": "Chapter notes",
        "subsubsection": "N/A"
    },
    {
        "content": "typically want each of these operations to read or write as much information as possible. Thus, a B-tree node is usually as large as a whole disk block, and this size limits the number of children a B-tree node can have.\n\nLarge B-trees stored on disk drives often have branching factors between 50 and 2000, depending on the size of a key relative to the size of a block. A large branching factor dramatically reduces both the height of the tree and the number of disk accesses required to find any key. Figure 18.3 shows a B-tree with a branching factor of 1001 and height 2 that can store over one billion keys. Nevertheless, if the root node is kept permanently in main memory, at most two disk accesses suffice to find any key in this tree.\n\n### 18.1 Definition of B-trees\n\nTo keep things simple, let's assume, as we have for binary search trees and red-black trees, that any satellite information associated with a key resides in the same node as the key. In practice, you might actually store with each key just a pointer to another disk block containing the satellite information for that key. The pseudocode in this chapter implicitly assumes that the satellite information associated with a key, or the pointer to such satellite information, travels with the key whenever the key is moved from node to node. A common variant on a B-tree, known as a _B+-tree_, stores all the satellite information in the leaves and stores only keys and child pointers in the internal nodes, thus maximizing the branching factor of the internal nodes.\n\nA _B-tree_\\(T\\) is a rooted tree with root _T.root_ having the following properties:\n\nFigure 18.3: A B-tree of height 2 containing over one billion keys. Shown inside each node \\(x\\) is \\(x\\). \\(n\\), the number of keys in \\(x\\). Each internal node and leaf contains 1000 keys. This B-tree has 1001 nodes at depth 1 and over one million leaves at depth 2.\n\n1. Every node \\(x\\) has the following attributes: 1. \\(x.\\,n\\), the number of keys currently stored in node \\(x\\), 2. the \\(x.\\,n\\) keys themselves, \\(x.\\,key_{1},x.\\,key_{2},\\ldots,x.\\,key_{x.\\,n}\\), stored in monotonically increasing order, so that \\(x.\\,key_{1}\\leq x.\\,key_{2}\\leq\\cdots\\leq x.\\,key_{x.\\,n}\\), 3. \\(x.\\,leaf\\), a boolean value that is true if \\(x\\) is a leaf and false if \\(x\\) is an internal node.\n2. Each internal node \\(x\\) also contains \\(x.\\,n+1\\) pointers \\(x.\\,c_{1},x.\\,c_{2},\\ldots,x.\\,c_{x.\\,n+1}\\) to its children. Leaf nodes have no children, and so their \\(c_{i}\\) attributes are undefined.\n3. The keys \\(x.\\,key_{i}\\) separate the ranges of keys stored in each subtree: if \\(k_{i}\\) is any key stored in the subtree with root \\(x.\\,c_{i}\\), then \\[k_{1}\\leq x.\\,key_{1}\\leq k_{2}\\leq x.\\,key_{2}\\leq\\cdots\\leq x.\\,key_{x.\\,n} \\leq k_{x.\\,n+1}\\.\\]\n4. All leaves have the same depth, which is the tree's height \\(h\\).\n5. Nodes have lower and upper bounds on the number of keys they can contain, expressed in terms of a fixed integer \\(t\\geq 2\\) called the _minimum degree_ of the B-tree: 1. Every node other than the root must have at least \\(t-1\\) keys. Every internal node other than the root thus has at least \\(t\\) children. If the tree is nonempty, the root must have at least one key. 2. Every node may contain at most \\(2t-1\\) keys. Therefore, an internal node may have at most \\(2t\\) children. We say that a node is _full_ if it contains exactly \\(2t-1\\) keys.3 Footnote 3: Another common variant on a B-tree, known as a _B*-tree_, requires each internal node to be at least \\(2/3\\) full, rather than at least half full, as a B-tree requires.\n\nThe simplest B-tree occurs when \\(t=2\\). Every internal node then has either \\(2\\), \\(3\\), or \\(4\\) children, and it is a _2-3-4 tree_. In practice, however, much larger values of \\(t\\) yield B-trees with smaller height.\n\n### The height of a B-tree\n\nThe number of disk accesses required for most operations on a B-tree is proportional to the height of the B-tree. The following theorem bounds the worst-case height of a B-tree.\n\n**Theorem 18.1**: _If \\(n\\geq 1\\), then for any \\(n\\)-key B-tree \\(T\\) of height \\(h\\) and minimum degree \\(t\\geq 2\\),_\n\n\\[h\\leq\\log_{t}\\frac{n+1}{2}\\.\\]\n\n_Proof_ By definition, the root of a nonempty B-tree \\(T\\) contains at least one key, and all other nodes contain at least \\(t-1\\) keys. Let \\(h\\) be the height of \\(T\\). Then \\(T\\) contains at least 2 nodes at depth 1, at least \\(2t\\) nodes at depth 2, at least \\(2t^{2}\\) nodes at depth 3, and so on, until at depth \\(h\\), it has at least \\(2t^{h-1}\\) nodes. Figure 18.4 illustrates such a tree for \\(h=3\\). The number \\(n\\) of keys therefore satisfies the inequality\n\n\\[n \\geq 1+(t-1)\\sum_{i=1}^{h}2t^{i-1}\\] \\[= 1+2(t-1)\\left(\\frac{t^{h}-1}{t-1}\\right)\\quad\\mbox{(by equation (A.6) on page 1142)}\\] \\[= 2t^{h}-1\\,\\]\n\nso that \\(t^{h}\\leq(n+1)/2\\). Taking base-\\(t\\) logarithms of both sides proves the theorem.\n\nYou can see the power of B-trees as compared with red-black trees. Although the height of the tree grows as \\(O(\\log n)\\) in both cases (recall that \\(t\\) is a constant), for B-trees the base of the logarithm can be many times larger. Thus, B-trees save\n\nFigure 18.4: A B-tree of height 3 containing a minimum possible number of keys. Shown inside each node \\(x\\) is \\(x.n\\).\n\na factor of about \\(\\lg t\\) over red-black trees in the number of nodes examined for most tree operations. Because examining an arbitrary node in a tree usually entails accessing the disk, B-trees avoid a substantial number of disk accesses.\n\n**Exercises**\n\n_18.1-1_\n\nWhy isn't a minimum degree of \\(t=1\\) allowed?\n\n_18.1-2_\n\nFor what values of \\(t\\) is the tree of Figure 18.1 a legal B-tree?\n\n_18.1-3_\n\nShow all legal B-trees of minimum degree 2 that store the keys \\(1,2,3,4,5\\).\n\n_18.1-4_\n\nAs a function of the minimum degree \\(t\\), what is the maximum number of keys that can be stored in a B-tree of height \\(h\\)?\n\n_18.1-5_\n\nDescribe the data structure that results if each black node in a red-black tree absorbs its red children, incorporating their children with its own.\n\n### 18.2 Basic operations on B-trees\n\nThis section presents the details of the operations B-Tree-Search, B-Tree-Create, and B-Tree-Insert. These procedures observe two conventions:\n\n* The root of the B-tree is always in main memory, so that no procedure ever needs to perform a Disk-Read on the root. If any changes to the root node occur, however, then Disk-Write must be called on the root.\n* Any nodes that are passed as parameters must already have had a Disk-Read operation performed on them.\n\nThe procedures are all \"one-pass\" algorithms that proceed downward from the root of the tree, without having to back up.\n\n**Searching a B-tree**\n\nSearching a B-tree is much like searching a binary search tree, except that instead of making a binary, or \"two-way,\" branching decision at each node, the search",
        "chapter": "Part V Advanced Data Structures",
        "section": "18 B-Trees",
        "subsection": "18.1 Definition of B-trees",
        "subsubsection": "N/A"
    },
    {
        "content": "a factor of about \\(\\lg t\\) over red-black trees in the number of nodes examined for most tree operations. Because examining an arbitrary node in a tree usually entails accessing the disk, B-trees avoid a substantial number of disk accesses.\n\n**Exercises**\n\n_18.1-1_\n\nWhy isn't a minimum degree of \\(t=1\\) allowed?\n\n_18.1-2_\n\nFor what values of \\(t\\) is the tree of Figure 18.1 a legal B-tree?\n\n_18.1-3_\n\nShow all legal B-trees of minimum degree 2 that store the keys \\(1,2,3,4,5\\).\n\n_18.1-4_\n\nAs a function of the minimum degree \\(t\\), what is the maximum number of keys that can be stored in a B-tree of height \\(h\\)?\n\n_18.1-5_\n\nDescribe the data structure that results if each black node in a red-black tree absorbs its red children, incorporating their children with its own.\n\n### 18.2 Basic operations on B-trees\n\nThis section presents the details of the operations B-Tree-Search, B-Tree-Create, and B-Tree-Insert. These procedures observe two conventions:\n\n* The root of the B-tree is always in main memory, so that no procedure ever needs to perform a Disk-Read on the root. If any changes to the root node occur, however, then Disk-Write must be called on the root.\n* Any nodes that are passed as parameters must already have had a Disk-Read operation performed on them.\n\nThe procedures are all \"one-pass\" algorithms that proceed downward from the root of the tree, without having to back up.\n\n**Searching a B-tree**\n\nSearching a B-tree is much like searching a binary search tree, except that instead of making a binary, or \"two-way,\" branching decision at each node, the search makes a multiway branching decision according to the number of the node's children. More precisely, at each internal node \\(x\\), the search makes an (\\(x.n\\) + 1)-way branching decision.\n\nThe procedure B-Tree-Search generalizes the Tree-Search procedure defined for binary search trees on page 316. It takes as input a pointer to the root node \\(x\\) of a subtree and a key \\(k\\) to be searched for in that subtree. The top-level call is thus of the form B-Tree-Search(\\(T.root,k\\)). If \\(k\\) is in the B-tree, then B-Tree-Search returns the ordered pair \\((y,i)\\) consisting of a node \\(y\\) and an index \\(i\\) such that \\(y.key_{i}=k\\). Otherwise, the procedure returns nil.\n\nB-Tree-Search(\\(x,k\\))\n\n```\n1\\(i\\ =\\ 1\\)while\\(i\\ \\leq x.n\\) and \\(k>x.key_{i}\\)\n3\\(i\\ =\\ i+1\\)if\\(i\\ \\leq x.n\\) and \\(k==x.key_{i}\\)\n4return\\((x,i)\\)\n5elseif\\(x.leaf\\)\n6return nil\n7else Disk-Read(\\(x.c_{i}\\))\n8return B-Tree-Search(\\(x.c_{i},k\\))\n```\n\nUsing a linear-search procedure, lines 1-3 of B-Tree-Search find the smallest index \\(i\\) such that \\(k\\leq x.key_{i}\\), or else they set \\(i\\) to \\(x.n\\) + 1. Lines 4-5 check to see whether the search has discovered the key, returning if it has. Otherwise, if \\(x\\) is a leaf, then line 7 terminates the search unsuccessfully, and if \\(x\\) is an internal node, lines 8-9 recurse to search the appropriate subtree of \\(x\\), after performing the necessary Disk-Read on that child. Figure 18.1 illustrates the operation of B-Tree-Search. The blue nodes are those examined during a search for the key \\(R\\).\n\nAs in the Tree-Search procedure for binary search trees, the nodes encountered during the recursion form a simple path downward from the root of the tree. The B-Tree-Search procedure therefore accesses \\(O(h)=O(\\log_{t}n)\\) disk blocks, where \\(h\\) is the height of the B-tree and \\(n\\) is the number of keys in the B-tree. Since \\(x.n<2t\\), the **while** loop of lines 2-3 takes \\(O(t)\\) time within each node, and the total CPU time is \\(O(th)=O(t\\ \\log_{t}n)\\).\n\n### Creating an empty B-tree\n\nTo build a B-tree \\(T\\), first use the B-Tree-Create procedure on the next page to create an empty root node and then call the B-Tree-Insert procedure on page 508 to add new keys. Both of these procedures use an auxiliary procedure Allocate-Node, whose pseudocode we omit and which allocates one disk block to be used as a new node in \\(\\mathcal{O}(1)\\) time. A node created by Allocate-Node requires no Disk-Read, since there is as yet no useful information stored on the disk for that node. B-Tree-Create requires \\(\\mathcal{O}(1)\\) disk operations and \\(\\mathcal{O}(1)\\) CPU time.\n\n#### Inserting a key into a B-tree\n\nInserting a key into a B-tree is significantly more complicated than inserting a key into a binary search tree. As with binary search trees, you search for the leaf position at which to insert the new key. With a B-tree, however, you cannot simply create a new leaf node and insert it, as the resulting tree would fail to be a valid B-tree. Instead, you insert the new key into an existing leaf node. Since you cannot insert a key into a leaf node that is full, you need an operation that _splits_ a full node \\(y\\) (having \\(2t-1\\) keys) around its _median key_\\(y.key_{t}\\) into two nodes having only \\(t-1\\) keys each. The median key moves up into \\(y\\)'s parent to identify the dividing point between the two new trees. But if \\(y\\)'s parent is also full, you must split it before you can insert the new key, and thus you could end up splitting full nodes all the way up the tree.\n\nTo avoid having to go back up the tree, just split every full node you encounter as you go down the tree. In this way, whenever you need to split a full node, you are assured that its parent is not full. Inserting a key into a B-tree then requires only a single pass down the tree from the root to a leaf.\n\n#### Splitting a node in a B-tree\n\nThe procedure B-Tree-Split-Child on the facing page takes as input a _nonfull_ internal node \\(x\\) (assumed to reside in main memory) and an index \\(i\\) such that \\(x.c_{i}\\) (also assumed to reside in main memory) is a _full_ child of \\(x\\). The procedure splits this child in two and adjusts \\(x\\) so that it has an additional child. To split a full root, you first need to make the root a child of a new empty root node, so that you can use B-Tree-Split-Child. The tree thus grows in height by 1: splitting is the only means by which the tree grows taller.\n\nB-Tree-Split-Child(\\(x,i\\))\n\n```\n1\\(y=x.c_{i}\\)// full node to split\n2\\(z=\\)Allocate-Node()//\\(z\\) will take half of \\(y\\)\n3\\(z.\\mathit{leaf}=y.\\mathit{leaf}\\)\n4\\(z.n=t-1\\)\n5for\\(j=1\\)to\\(t-1\\)//\\(z\\) gets \\(y\\)'s greatest keys...\n6\\(z.\\mathit{key}_{j}=y.\\mathit{key}_{j+t}\\)\n7if not \\(y.\\mathit{leaf}\\)\n8for\\(j=1\\)to\\(t\\)//\\(\\dots\\) and its corresponding children\n9\\(z.c_{j}=y.c_{j+t}\\)\n10\\(y.n=t-1\\)//\\(y\\) keeps \\(t-1\\) keys\n11for\\(j=x.n+1\\) downto\\(i+1\\)// shift \\(x\\)'s children to the right...\n12\\(x.c_{j+1}=x.c_{j}\\)\n13\\(x.c_{i+1}=z\\)//\\(\\dots\\) to make room for \\(z\\) as a child\n14for\\(j=x.n\\) downto\\(i\\)// shift the corresponding keys in \\(x\\)\n15\\(x.\\mathit{key}_{j+1}=x.\\mathit{key}_{j}\\)\n16\\(x.\\mathit{key}_{i}=y.\\mathit{key}_{t}\\)// insert \\(y\\)'s median key\n17\\(x.n=x.n+1\\)//\\(x\\) has gained a child\n18 Disk-Write(\\(y\\))\n19 Disk-Write(\\(z\\))\n20 Disk-Write(\\(x\\))\n```\n\nFigure 18.5 illustrates how a node splits. B-Tree-Split-Child splits the full node \\(y=x.c_{i}\\) about its median key (\\(S\\) in the figure), which moves up into \\(y\\)'s parent node \\(x\\). Those keys in \\(y\\) that are greater than the median key move into a new node \\(z\\), which becomes a new child of \\(x\\).\n\nB-Tree-Split-Child works by straightforward cutting and pasting. Node \\(x\\) is the parent of the node \\(y\\) being split, which is \\(x\\)'s \\(i\\)th child (set in line 1). Node \\(y\\) originally has \\(2t\\) children and \\(2t-1\\) keys, but splitting reduces \\(y\\) to \\(t\\) children and \\(t-1\\) keys. The \\(t\\) largest children and \\(t-1\\) keys of node \\(y\\) move over to node \\(z\\), which becomes a new child of \\(x\\), positioned just after \\(y\\) in \\(x\\)'s table of children. The median key of \\(y\\) moves up to become the key in node \\(x\\) that separates the pointers to nodes \\(y\\) and \\(z\\).\n\nLines 2-9 create node \\(z\\) and give it the largest \\(t-1\\) keys and, if \\(y\\) and \\(z\\) are internal nodes, the corresponding \\(t\\) children of \\(y\\). Line 10 adjusts the key count for \\(y\\). Then, lines 11-17 shift keys and child pointers in \\(x\\) to the right in order to make room for \\(x\\)'s new child, insert \\(z\\) as a new child of \\(x\\), move the median key from \\(y\\) up to \\(x\\) in order to separate \\(y\\) from \\(z\\), and adjust \\(x\\)'s key count. Lines 18-20 write out all modified disk blocks. The CPU time used by B-Tree-Split-Child is \\(\\Theta(t)\\), due to the **for** loops in lines 5-6 and 8-9. (The **for** loops in lines 11-12 and 14-15 also run for \\(O(t)\\) iterations.) The procedure performs \\(O(1)\\) disk operations.\n\n_Inserting a key into a B-tree in a single pass down the tree_\n\nInserting a key \\(k\\) into a B-tree \\(T\\) of height \\(h\\) requires just a single pass down the tree and \\(O(h)\\) disk accesses. The CPU time required is \\(O(th)=O(t\\log_{t}n)\\). The B-Tree-Insert procedure uses B-Tree-Split-Child to guarantee that the recursion never descends to a full node. If the root is full, B-Tree-Insert splits it by calling the procedure B-Tree-Split-Root on the facing page.\n\nB-Tree-Insert(\\(T,k\\))\n\n\\(r=T.root\\)\n\n\\(s=\\) B-Tree-Split-Root(\\(T\\))\n\nB-Tree-Insert-Nonfull(\\(s,k\\))\n\n**else** B-Tree-Insert-Nonfull(\\(r,k\\))\n\nB-Tree-Insert works as follows. If the root is full, then line 3 calls B-Tree-Split-Root in line 3 to split it. A new node \\(s\\) (with two children) becomes the root and is returned by B-Tree-Split-Root. Splitting the root, illustrated in Figure 18.6, is the only way to increase the height of a B-tree. Unlike a binary search tree, a B-tree increases in height at the top instead of at the bottom. Regardless of whether the root split, B-Tree-Insert finishes by calling B-Tree-Insert-Nonfull to insert key \\(k\\) into the tree rooted at the nonfull root node,\n\nFigure 18.5: Splitting a node with \\(t=4\\). Node \\(y=x.\\,c_{i}\\) splits into two nodes, \\(y\\) and \\(z\\), and the median key \\(S\\) of \\(y\\) moves up into \\(y\\)\u2019s parent.\n\nwhich is either the new root (the call in line 4) or the original root (the call in line 5).\n\nB-Tree-Split-Root(\\(T\\))\n\n\\(s=\\)Allocate-Node()\n\n\\(s.\\mathit{leaf}=\\)false\n\n\\(s.\\mathit{n}=0\\)\n\n\\(s.\\mathit{c}_{1}=\\mathit{T.root}\\)\n\n\\(T.\\mathit{root}=s\\)\n\nB-Tree-Split-Child(\\(s,1\\))\n\n**return**\\(s\\)\n\nThe auxiliary procedure B-Tree-Insert-Nonfull on page 51 inserts key \\(k\\) into node \\(x\\), which is assumed to be nonfull when the procedure is called. B-Tree-Insert-Nonfull recurses as necessary down the tree, at all times guaranteeing that the node to which it recurses is not full by calling B-Tree-Split-Child as necessary. The operation of B-Tree-Insert and the recursive operation of B-Tree-Insert-Nonfull guarantee that this assumption is true.\n\nFigure 18.7 illustrates the various cases of how B-Tree-Insert-Nonfull inserts a key into a B-tree. Lines 3-8 handle the case in which \\(x\\) is a leaf node by inserting key \\(k\\) into \\(x\\), shifting to the right all keys in \\(x\\) that are greater than \\(k\\). If \\(x\\) is not a leaf node, then \\(k\\) should go into the appropriate leaf node in the subtree rooted at internal node \\(x\\). Lines 9-11 determine the child \\(x.\\mathit{c}_{i}\\) to which the recursion descends. Line 13 detects whether the recursion would descend to a full child, in which case line 14 calls B-Tree-Split-Child to split that child into two non\n\nFigure 18.6: Splitting the root with \\(t=4\\). Root node \\(r\\) splits in two, and a new root node \\(s\\) is created. The new root contains the median key of \\(r\\) and has the two halves of \\(r\\) as children. The B-tree grows in height by one when the root is split. A B-tree\u2019s height increases only when the root splits.\n\nFigure 18.7: Inserting keys into a B-tree. The minimum degree \\(t\\) for this B-tree is 3, so that a node can hold at most 5 keys. Blue nodes are modified by the insertion process. **(a)** The initial tree for this example. **(b)** The result of inserting \\(B\\) into the initial tree. This case is a simple insertion into a leaf node. **(c)** The result of inserting \\(Q\\) into the previous tree. The node \\(RSTUV\\) splits into two nodes containing \\(RS\\) and \\(UV\\), the key \\(T\\) moves up to the root, and \\(Q\\) is inserted in the leftmost of the two halves (the \\(RS\\) node). **(d)** The result of inserting \\(L\\) into the previous tree. The root splits right away, since it is full, and the B-tree grows in height by one. Then \\(L\\) is inserted into the leaf containing \\(JK\\). **(e)** The result of inserting \\(F\\) into the previous tree. The node \\(ABCDE\\) splits before \\(F\\) is inserted into the rightmost of the two halves (the \\(DE\\) node).\n\n### Basic operations on B-trees\n\nB-Tree-Insert-Nonfull(\\(x,k\\))\n\n\\(i\\ =\\ x.\\ n\\)\n\n\\(x.\\mathit{leaf}\\)\n\n\\(\\mathsf{while}\\ i\\ \\geq 1\\) and \\(k\\ <\\ x.\\mathit{key}_{i}\\)\n\n\\(x.\\mathit{key}_{i+1}\\ =\\ x.\\mathit{key}_{i}\\)\n\n\\(i\\ =\\ i-1\\)\n\n\\(x.\\mathit{key}_{i+1}\\ =\\ k\\)\n\n\\(x.\\mathit{n}\\ =\\ x.\\ n+1\\)\n\n\\(\\mathsf{Disk}\\)-Write(\\(x\\))\n\n\\(\\mathsf{else}\\ \\mathsf{while}\\ i\\ \\geq 1\\) and \\(k\\ <\\ x.\\mathit{key}_{i}\\)\n\n\\(i\\ =\\ i-1\\)\n\n\\(i\\ =\\ i-1\\)\n\n\\(i\\ =\\ i+1\\)\n\n\\(\\mathsf{Disk}\\)-Read(\\(x.\\mathit{c}_{i}\\))\n\n\\(x.\\mathit{c}_{i}.\\ n==2t-1\\)\n\n\\(\\mathsf{B}\\)-Tree-Split-Child(\\(x,i\\))\n\n\\(\\mathsf{if}\\ k\\ >\\ x.\\mathit{key}_{i}\\)\n\n\\(\\mathsf{if}\\ \\text{does}\\ k\\ \\text{go into}\\ x.\\mathit{c}_{i}\\ \\text{or}\\ x.\\mathit{c}_{i+1}?\\)\n\n\\(i\\ =\\ i+1\\)\n\n\\(\\mathsf{B}\\)-Tree-Insert-Nonfull(\\(x.\\mathit{c}_{i},k\\))\n\n\\(\\mathsf{if}\\ \\text{does}\\ k\\ \\text{go into}\\ x.\\mathit{c}_{i}\\ \\text{or}\\ x.\\mathit{c}_{i+1}?\\)\n\n\\(i\\ =\\ i+1\\)\n\n\\(\\mathsf{B}\\)-Tree-Insert-Nonfull(\\(x.\\mathit{c}_{i},k\\))\n\n\\(\\mathsf{if}\\ \\text{does}\\ k\\ \\text{go into}\\ x.\\mathit{c}_{i}\\ \\text{or}\\ x.\\mathit{c}_{i+1}?\\)\n\n\\(i\\ =\\ i+1\\)\n\n\\(\\mathsf{B}\\)-Tree-Insert-Nonfull(\\(x.\\mathit{c}_{i},k\\))\n\n\\(\\mathsf{if}\\ \\text{does}\\ k\\ \\text{go into}\\ x.\\mathit{c}_{i}\\ \\text{or}\\ x.\\mathit{c}_{i+1}?\\)\n\n\\(i\\ =\\ i+1\\)\n\n\\(\\mathsf{B}\\)-Tree-Insert-Nonfull(\\(x.\\mathit{c}_{i},k\\))\n\n\\(\\mathsf{if}\\ \\text{does}\\ k\\ \\text{go into}\\ x.\\mathit{c}_{i}\\ \\text{or}\\ x.\\mathit{c}_{i+1}?\\)\n\n\\(i\\ =\\ i+1\\)\n\n\\(\\mathsf{B}\\)-Tree-Insert-Nonfull(\\(x.\\mathit{c}_{i},k\\))\n\n\\(\\mathsf{if}\\ \\text{does}\\ k\\ \\text{go into}\\ x.\\mathit{c}_{i}\\ \\text{or}\\ x.\\mathit{c}_{i+1}?\\)\n\n\\(\\mathsf{if}\\ \\text{does}\\ k\\ \\text{go into}\\ x.\\mathit{c}_{i}\\ \\text{or}\\ x.\\mathit{c}_{i+1}?\\)\n\n\\(i\\ =\\ i+1\\)\n\n\\(\\mathsf{B}\\)-Tree-Insert-Nonfull(\\(x.\\mathit{c}_{i},k\\))\n\n[MISSING_PAGE_POST]\n\n\\(\\mathsf{if}\\ \\text{does}\\ k\\ \\text{go into}\\ k.\n\nin order into an empty B-tree with minimum degree 2. Draw only the configurations of the tree just before some node must split, and also draw the final configuration.\n\n##### 18.2-2\n\nExplain under what circumstances, if any, redundant Disk-Read or Disk-Write operations occur during the course of executing a call to B-Tree-Insert. (A redundant Disk-Read is a Disk-Read for a block that is already in memory. A redundant Disk-Write writes to disk a block of information that is identical to what is already stored there.)\n\n##### 18.2-3\n\nProfessor Bunyan asserts that the B-Tree-Insert procedure always results in a B-tree with the minimum possible height. Show that the professor is mistaken by proving that with \\(t=2\\) and the set of keys \\(\\{1,2,\\ldots,15\\}\\), there is no insertion sequence that results in a B-tree with the minimum possible height.\n\n* _18.2-4_ If you insert the keys \\(\\{1,2,\\ldots,n\\}\\) into an empty B-tree with minimum degree 2, how many nodes does the final B-tree have?\n\n##### 18.2-5\n\nSince leaf nodes require no pointers to children, they could conceivably use a different (larger) \\(t\\) value than internal nodes for the same disk block size. Show how to modify the procedures for creating and inserting into a B-tree to handle this variation.\n\n##### 18.2-6\n\nSuppose that you implement B-Tree-Search to use binary search rather than linear search within each node. Show that this change makes the required CPU time \\(O(\\lg n)\\), independent of how \\(t\\) might be chosen as a function of \\(n\\).\n\n##### 18.2-7\n\nSuppose that disk hardware allows you to choose the size of a disk block arbitrarily, but that the time it takes to read the disk block is \\(a+bt\\), where \\(a\\) and \\(b\\) are specified constants and \\(t\\) is the minimum degree for a B-tree using blocks of the selected size. Describe how to choose \\(t\\) so as to minimize (approximately) the B-tree search time. Suggest an optimal value of \\(t\\) for the case in which \\(a=5\\) milliseconds and \\(b=10\\) microseconds.\n\n### 18.3 Deleting a key from a B-tree\n\nDeletion from a B-tree is analogous to insertion but a little more complicated, because you can delete a key from any node--not just a leaf--and when you delete a key from an internal node, you must rearrange the node's children. As in insertion, you must guard against deletion producing a tree whose structure violates the B-tree properties. Just as a node should not get too big due to insertion, a node must not get too small during deletion (except that the root is allowed to have fewer than the minimum number \\(t-1\\) of keys). And just as a simple insertion algorithm might have to back up if a node on the path to where the key is to be inserted is full, a simple approach to deletion might have to back up if a node (other than the root) along the path to where the key is to be deleted has the minimum number of keys.\n\nThe procedure B-Tree-Deleteletes the key \\(k\\) from the subtree rooted at \\(x\\). Unlike the procedures Tree-Delete on page 325 and RB-Delete on page 348, which are given the node to delete--presumably as the result of a prior search--B-Tree-Delete combines the search for key \\(k\\) with the deletion process. Why do we combine search and deletion in B-Tree-Delete? Just as B-Tree-Insert prevents any node from becoming overall (having more than \\(2t-1\\) keys) while making a single pass down the tree, B-Tree-Delete prevents any node from becoming underfull (having fewer than \\(t-1\\) keys) while also making a single pass down the tree, searching for and ultimately deleting the key.\n\nTo prevent any node from becoming underfull, the design of B-Tree-Delete guarantees that whenever it calls itself recursively on a node \\(x\\), the number of keys in \\(x\\) is at least the minimum degree \\(t\\) at the time of the call. (Although the root may have fewer than \\(t\\) keys and a recursive call may be made _from_ the root, no recursive call is made _on_ the root.) This condition requires one more key than the minimum required by the usual B-tree conditions, and so a key might have to be moved from \\(x\\) into one of its child nodes (still leaving \\(x\\) with at least the minimum \\(t-1\\) keys) before a recursive call is made on that child, thus allowing deletion to occur in one downward pass without having to traverse back up the tree.\n\nWe describe how the procedure B-Tree-Delete(\\(T,k\\)) deletes a key \\(k\\) from a B-tree \\(T\\) instead of presenting detailed pseudocode. We examine three cases, illustrated in Figure 18.8. The cases are for when the search arrives at a leaf, at an internal node containing key \\(k\\), and at an internal node not containing key \\(k\\). As mentioned above, in all three cases node \\(x\\) has at least \\(t\\) keys (with the possible exception of when \\(x\\) is the root). Cases 2 and 3--when \\(x\\) is an internal node--guarantee this property as the recursion descends through the B-tree.",
        "chapter": "Part V Advanced Data Structures",
        "section": "18 B-Trees",
        "subsection": "18.2 Basic operations on B-trees",
        "subsubsection": "N/A"
    },
    {
        "content": "### 18.3 Deleting a key from a B-tree\n\nDeletion from a B-tree is analogous to insertion but a little more complicated, because you can delete a key from any node--not just a leaf--and when you delete a key from an internal node, you must rearrange the node's children. As in insertion, you must guard against deletion producing a tree whose structure violates the B-tree properties. Just as a node should not get too big due to insertion, a node must not get too small during deletion (except that the root is allowed to have fewer than the minimum number \\(t-1\\) of keys). And just as a simple insertion algorithm might have to back up if a node on the path to where the key is to be inserted is full, a simple approach to deletion might have to back up if a node (other than the root) along the path to where the key is to be deleted has the minimum number of keys.\n\nThe procedure B-Tree-Deleteletes the key \\(k\\) from the subtree rooted at \\(x\\). Unlike the procedures Tree-Delete on page 325 and RB-Delete on page 348, which are given the node to delete--presumably as the result of a prior search--B-Tree-Delete combines the search for key \\(k\\) with the deletion process. Why do we combine search and deletion in B-Tree-Delete? Just as B-Tree-Insert prevents any node from becoming overall (having more than \\(2t-1\\) keys) while making a single pass down the tree, B-Tree-Delete prevents any node from becoming underfull (having fewer than \\(t-1\\) keys) while also making a single pass down the tree, searching for and ultimately deleting the key.\n\nTo prevent any node from becoming underfull, the design of B-Tree-Delete guarantees that whenever it calls itself recursively on a node \\(x\\), the number of keys in \\(x\\) is at least the minimum degree \\(t\\) at the time of the call. (Although the root may have fewer than \\(t\\) keys and a recursive call may be made _from_ the root, no recursive call is made _on_ the root.) This condition requires one more key than the minimum required by the usual B-tree conditions, and so a key might have to be moved from \\(x\\) into one of its child nodes (still leaving \\(x\\) with at least the minimum \\(t-1\\) keys) before a recursive call is made on that child, thus allowing deletion to occur in one downward pass without having to traverse back up the tree.\n\nWe describe how the procedure B-Tree-Delete(\\(T,k\\)) deletes a key \\(k\\) from a B-tree \\(T\\) instead of presenting detailed pseudocode. We examine three cases, illustrated in Figure 18.8. The cases are for when the search arrives at a leaf, at an internal node containing key \\(k\\), and at an internal node not containing key \\(k\\). As mentioned above, in all three cases node \\(x\\) has at least \\(t\\) keys (with the possible exception of when \\(x\\) is the root). Cases 2 and 3--when \\(x\\) is an internal node--guarantee this property as the recursion descends through the B-tree.\n\n_Case 1: The search arrives at a leaf node \\(x\\)_. If \\(x\\) contains key \\(k\\), then delete \\(k\\) from \\(x\\). If \\(x\\) does not contain key \\(k\\), then \\(k\\) was not in the B-tree and nothing else needs to be done. _Case 2: The search arrives at an internal node \\(x\\) that contains key \\(k\\)_. Let \\(k=x.\\mathit{key}_{i}\\). One of the following three cases applies, depending on the number of keys in \\(x.\\mathit{c}_{i}\\) (the child of \\(x\\) that precedes \\(k\\)) and \\(x.\\mathit{c}_{i+1}\\) (the child of \\(x\\) that follows \\(k\\)). _Case 2a: \\(x.\\mathit{c}_{i}\\) has at least \\(t\\) keys_. Find the predecessor \\(k^{\\prime}\\) of \\(k\\) in the subtree rooted at \\(x.\\mathit{c}_{i}\\). Recursively delete \\(k^{\\prime}\\) from \\(x.\\mathit{c}_{i}\\), and replace \\(k\\) by \\(k^{\\prime}\\) in \\(x\\). (Key \\(k^{\\prime}\\) can be found and deleted in a single downward pass.) _Case 2b: \\(x.\\mathit{c}_{i}\\) has \\(t-1\\) keys and \\(x.\\mathit{c}_{i+1}\\) has at least \\(t\\) keys_. This case is symmetric to case 2a. Find the successor \\(k^{\\prime}\\) of \\(k\\) in the subtree rooted at \\(x.\\mathit{c}_{i+1}\\).\n\nFigure 18.8: Deleting keys from a B-tree. The minimum degree for this B-tree is \\(t=3\\), so that, other than the root, every node must have at least 2 keys. Blue nodes are those that are modified by the deletion process. **(a)** The B-tree of Figure 18.7(e). **(b)** Deletion of \\(F\\), which is case 1: simple deletion from a leaf when all nodes visited during the search (other than the root) have at least \\(t=3\\) keys. **(c)** Deletion of \\(M\\), which is case 2a: the predecessor \\(L\\) of \\(M\\) moves up to take \\(M\\)\u2019s position.\n\n### 18.3 Deleting a key from a B-tree\n\nRecursively delete \\(k^{\\prime}\\) from \\(x\\,.\\,c_{i\\,+1}\\), and replace \\(k\\) by \\(k^{\\prime}\\) in \\(x\\). (Again, finding and deleting \\(k^{\\prime}\\) can be done in a single downward pass.)\n\n_Case 2c: Both \\(x\\,.\\,c_{i}\\) and \\(x\\,.\\,c_{i\\,+1}\\) have \\(t-1\\) keys_. Merge \\(k\\) and all of \\(x\\,.\\,c_{i\\,+1}\\) into \\(x\\,.\\,c_{i}\\), so that \\(x\\) loses both \\(k\\) and the pointer to \\(x\\,.\\,c_{i\\,+1}\\), and \\(x\\,.\\,c_{i}\\) now contains \\(2t-1\\) keys. Then free \\(x\\,.\\,c_{i\\,+1}\\) and recursively delete \\(k\\) from \\(x\\,.\\,c_{i\\,}\\).\n\n_Case 3: The search arrives at an internal node \\(x\\) that does not contain key \\(k\\)_. Continue searching down the tree while ensuring that each node visited has at least \\(t\\) keys. To do so, determine the root \\(x\\,.\\,c_{i}\\) of the appropriate subtree that must contain \\(k\\), if \\(k\\) is in the tree at all. If \\(x\\,.\\,c_{i}\\) has only \\(t-1\\) keys, execute\n\nFigure 18.8: **continued** **(d)** Deletion of \\(G\\), which is case 2c: push \\(G\\) down to make node \\(DEGJK\\) and then delete \\(G\\) from this leaf (case 1). **(e)** Deletion of \\(D\\), which is case 3b: since the recursion cannot descend to node \\(CL\\) because it has only 2 keys, push \\(P\\) down and merge it with \\(CL\\) and \\(TX\\) to form \\(CLPTX\\). Then delete \\(D\\) from a leaf (case 1). **(e\\({}^{\\prime}\\))** After (e), delete the empty root. The tree shrinks in height by 1. **(f)** Deletion of \\(B\\), which is case 3a: \\(C\\) moves to fill \\(B\\)\u2019s position and \\(E\\) moves to fill \\(C\\)\u2019s position.\n\ncase 3a or 3b as necessary to guarantee descending to a node containing at least \\(t\\) keys. Then finish by recursing on the appropriate child of \\(x\\).\n\n_Case 3a:_\\(x\\).\\(c_{i}\\) _has only \\(t-1\\) keys but has an immediate sibling with at least \\(t\\) keys_. Give \\(x\\).\\(c_{i}\\) an extra key by moving a key from \\(x\\) down into \\(x\\).\\(c_{i}\\), moving a key from \\(x\\).\\(c_{i}\\)'s immediate left or right sibling up into \\(x\\), and moving the appropriate child pointer from the sibling into \\(x\\).\\(c_{i}\\).\n\n_Case 3b:_\\(x\\).\\(c_{i}\\) _and each of \\(x\\).\\(c_{i}\\)'s immediate siblings have \\(t-1\\) keys_. (It is possible for \\(x\\).\\(c_{i}\\) to have either one or two siblings.) Merge \\(x\\).\\(c_{i}\\) with one sibling, which involves moving a key from \\(x\\) down into the new merged node to become the median key for that node.\n\nIn cases 2c and 3b, if node \\(x\\) is the root, it could end up having no keys. When this situation occurs, then \\(x\\) is deleted, and \\(x\\)'s only child \\(x\\).\\(c_{1}\\) becomes the new root of the tree. This action decreases the height of the tree by one and preserves the property that the root of the tree contains at least one key (unless the tree is empty).\n\nSince most of the keys in a B-tree are in the leaves, deletion operations often end up deleting keys from leaves. The B-Tree-Delete procedure then acts in one downward pass through the tree, without having to back up. When deleting a key in an internal node \\(x\\), however, the procedure might make a downward pass through the tree to find the key's predecessor or successor and then return to node \\(x\\) to replace the key with its predecessor or successor (cases 2a and 2b). Returning to node \\(x\\) does not require a traversal through all the levels between \\(x\\) and the node containing the predecessor or successor, however, since the procedure can just keep a pointer to \\(x\\) and the key position within \\(x\\) and put the predecessor or successor key directly there.\n\nAlthough this procedure seems complicated, it involves only \\(O(h)\\) disk operations for a B-tree of height \\(h\\), since only \\(O(1)\\) calls to Disk-Read and Disk-Write are made between recursive invocations of the procedure. The CPU time required is \\(O(th)=O(t\\,\\log_{t}n)\\).\n\n### Exercises\n\n#### 18.3-1\n\nShow the results of deleting \\(C\\), \\(P\\), and \\(V\\), in order, from the tree of Figure 18.8(f).\n\n#### 18.3-2\n\nWrite pseudocode for B-Tree-Delete.\n\n## Problems\n\n### 18-1 Stacks on secondary storage\n\nConsider implementing a stack in a computer that has a relatively small amount of fast primary memory and a relatively large amount of slower disk storage. The operations Push and Pop work on single-word values. The stack can grow to be much larger than can fit in memory, and thus most of it must be stored on disk.\n\nA simple, but inefficient, stack implementation keeps the entire stack on disk. Maintain in memory a stack pointer, which is the disk address of the top element on the stack. Indexing block numbers and word offsets within blocks from 0, if the pointer has value \\(p\\), the top element is the (\\(p\\) mod \\(m\\))th word on block \\(\\lfloor p/m\\rfloor\\) of the disk, where \\(m\\) is the number of words per block.\n\nTo implement the Push operation, increment the stack pointer, read the appropriate block into memory from disk, copy the element to be pushed to the appropriate word on the block, and write the block back to disk. A Pop operation is similar. Read in the appropriate block from disk, save the top of the stack, decrement the stack pointer, and return the saved value. You need not write back the block, since it was not modified, and the word in the block that contained the popped value is ignored.\n\nAs in the analyses of B-tree operations, two costs matter: the total number of disk accesses and the total CPU time. A disk access also incurs a cost in CPU time. In particular, any disk access to a block of \\(m\\) words incurs charges of one disk access and \\(\\Theta(m)\\) CPU time.\n\n* Asymptotically, what is the worst-case number of disk accesses for \\(n\\) stack operations using this simple implementation? What is the CPU time for \\(n\\) stack operations? Express your answer in terms of \\(m\\) and \\(n\\) for this and subsequent parts.\n\nNow consider a stack implementation in which you keep one block of the stack in memory. (You also maintain a small amount of memory to record which block is currently in memory.) You can perform a stack operation only if the relevant disk block resides in memory. If necessary, you can write the block currently in memory to the disk and read the new block from the disk into memory. If the relevant disk block is already in memory, then no disk accesses are required.\n\n* What is the worst-case number of disk accesses required for \\(n\\) Push operations? What is the CPU time?\n* What is the worst-case number of disk accesses required for \\(n\\) stack operations? What is the CPU time?",
        "chapter": "Part V Advanced Data Structures",
        "section": "18 B-Trees",
        "subsection": "18.3 Deleting a key from a B-tree",
        "subsubsection": "N/A"
    },
    {
        "content": "## Problems\n\n### Stacks on secondary storage\n\nConsider implementing a stack in a computer that has a relatively small amount of fast primary memory and a relatively large amount of slower disk storage. The operations Push and Pop work on single-word values. The stack can grow to be much larger than can fit in memory, and thus most of it must be stored on disk.\n\nA simple, but inefficient, stack implementation keeps the entire stack on disk. Maintain in memory a stack pointer, which is the disk address of the top element on the stack. Indexing block numbers and word offsets within blocks from 0, if the pointer has value \\(p\\), the top element is the (\\(p\\) mod \\(m\\))th word on block \\(\\lfloor p/m\\rfloor\\) of the disk, where \\(m\\) is the number of words per block.\n\nTo implement the Push operation, increment the stack pointer, read the appropriate block into memory from disk, copy the element to be pushed to the appropriate word on the block, and write the block back to disk. A Pop operation is similar. Read in the appropriate block from disk, save the top of the stack, decrement the stack pointer, and return the saved value. You need not write back the block, since it was not modified, and the word in the block that contained the popped value is ignored.\n\nAs in the analyses of B-tree operations, two costs matter: the total number of disk accesses and the total CPU time. A disk access also incurs a cost in CPU time. In particular, any disk access to a block of \\(m\\) words incurs charges of one disk access and \\(\\Theta(m)\\) CPU time.\n\n* Asymptotically, what is the worst-case number of disk accesses for \\(n\\) stack operations using this simple implementation? What is the CPU time for \\(n\\) stack operations? Express your answer in terms of \\(m\\) and \\(n\\) for this and subsequent parts.\n\nNow consider a stack implementation in which you keep one block of the stack in memory. (You also maintain a small amount of memory to record which block is currently in memory.) You can perform a stack operation only if the relevant disk block resides in memory. If necessary, you can write the block currently in memory to the disk and read the new block from the disk into memory. If the relevant disk block is already in memory, then no disk accesses are required.\n\n* What is the worst-case number of disk accesses required for \\(n\\) Push operations? What is the CPU time?\n* What is the worst-case number of disk accesses required for \\(n\\) stack operations? What is the CPU time?Suppose that you now implement the stack by keeping two blocks in memory (in addition to a small number of words for bookkeeping).\n\n_d._: Describe how to manage the stack blocks so that the amortized number of disk accesses for any stack operation is \\(O(1/m)\\) and the amortized CPU time for any stack operation is \\(O(1)\\).\n\n_18-2 Joining and splitting 2-3-4 trees_\n\nThe _join_ operation takes two dynamic sets \\(S^{\\prime}\\) and \\(S^{\\prime\\prime}\\) and an element \\(x\\) such that \\(x^{\\prime}.\\mathit{key}<\\!x\\). \\(\\mathit{key}<x^{\\prime\\prime}.\\mathit{key}\\) for any \\(x^{\\prime}\\in S^{\\prime}\\) and \\(x^{\\prime\\prime}\\in S^{\\prime\\prime}\\). It returns a set \\(S=S^{\\prime}\\cup\\{x\\}\\cup S^{\\prime\\prime}\\). The _split_ operation is like an \"inverse\" join: given a dynamic set \\(S\\) and an element \\(x\\in S\\), it creates a set \\(S^{\\prime}\\) that consists of all elements in \\(S-\\{x\\}\\) whose keys are less than \\(x\\).\\(\\mathit{key}\\) and another set \\(S^{\\prime\\prime}\\) that consists of all elements in \\(S-\\{x\\}\\) whose keys are greater than \\(x\\).\\(\\mathit{key}\\). This problem investigates how to implement these operations on 2-3-4 trees (B-trees with \\(t=2\\)). Assume for convenience that elements consist only of keys and that all key values are distinct.\n\n_a._: Show how to maintain, for every node \\(x\\) of a 2-3-4 tree, the height of the subtree rooted at \\(x\\) as an attribute \\(x\\).\\(\\mathit{height}\\). Make sure that your implementation does not affect the asymptotic running times of searching, insertion, and deletion.\n\n_b._: Show how to implement the join operation. Given two 2-3-4 trees \\(T^{\\prime}\\) and \\(T^{\\prime\\prime}\\) and a key \\(k\\), the join operation should run in \\(O(1+|h^{\\prime}-h^{\\prime\\prime}|)\\) time, where \\(h^{\\prime}\\) and \\(h^{\\prime\\prime}\\) are the heights of \\(T^{\\prime}\\) and \\(T^{\\prime\\prime}\\), respectively.\n\n_c._: Consider the simple path \\(p\\) from the root of a 2-3-4 tree \\(T\\) to a given key \\(k\\), the set \\(S^{\\prime}\\) of keys in \\(T\\) that are less than \\(k\\), and the set \\(S^{\\prime\\prime}\\) of keys in \\(T\\) that are greater than \\(k\\). Show that \\(p\\) breaks \\(S^{\\prime}\\) into a set of trees \\(\\{T^{\\prime}_{0}\\), \\(T^{\\prime}_{1}\\), \\(\\ldots\\), \\(T^{\\prime}_{m}\\}\\) and a set of keys \\(\\{k^{\\prime}_{1},k^{\\prime}_{2},\\ldots,k^{\\prime}_{m}\\}\\) such that \\(y<k^{\\prime}_{i}<z\\) for \\(i=1,2,\\ldots,m\\) and any keys \\(y\\in T^{\\prime}_{i-1}\\) and \\(z\\in T^{\\prime}_{i}\\). What is the relationship between the heights of \\(T^{\\prime}_{i-1}\\) and \\(T^{\\prime}_{i}\\)? Describe how \\(p\\) breaks \\(S^{\\prime\\prime}\\) into sets of trees and keys.\n\n_d._: Show how to implement the split operation on \\(T\\). Use the join operation to assemble the keys in \\(S^{\\prime}\\) into a single 2-3-4 tree \\(T^{\\prime}\\) and the keys in \\(S^{\\prime\\prime}\\) into a single 2-3-4 tree \\(T^{\\prime\\prime}\\). The running time of the split operation should be \\(O(\\lg n)\\), where \\(n\\) is the number of keys in \\(T\\). (_Hint:_ The costs for joining should telescope.)\n\n## Chapter notes\n\nKnuth [261], Aho, Hopcroft, and Ullman [5], and Sedgewick and Wayne [402] give further discussions of balanced-tree schemes and B-trees. Comer [99] provides a comprehensive survey of B-trees. Guibas and Sedgewick [202] discuss the relationships among various kinds of balanced-tree schemes, including red-black trees and 2-3-4 trees.\n\nIn 1970, J. E. Hopcroft invented 2-3 trees, a precursor to B-trees and 2-3-4 trees, in which every internal node has either two or three children. Bayer and McCreight [39] introduced B-trees in 1972 with no explanation of their choice of name.\n\nBender, Demaine, and Farach-Colton [47] studied how to make B-trees perform well in the presence of memory-hierarchy effects. Their _cache-oblivious_ algorithms work efficiently without explicitly knowing the data transfer sizes within the memory hierarchy.",
        "chapter": "Part V Advanced Data Structures",
        "section": "18 B-Trees",
        "subsection": "Problems",
        "subsubsection": "N/A"
    },
    {
        "content": "## Chapter notes\n\nKnuth [261], Aho, Hopcroft, and Ullman [5], and Sedgewick and Wayne [402] give further discussions of balanced-tree schemes and B-trees. Comer [99] provides a comprehensive survey of B-trees. Guibas and Sedgewick [202] discuss the relationships among various kinds of balanced-tree schemes, including red-black trees and 2-3-4 trees.\n\nIn 1970, J. E. Hopcroft invented 2-3 trees, a precursor to B-trees and 2-3-4 trees, in which every internal node has either two or three children. Bayer and McCreight [39] introduced B-trees in 1972 with no explanation of their choice of name.\n\nBender, Demaine, and Farach-Colton [47] studied how to make B-trees perform well in the presence of memory-hierarchy effects. Their _cache-oblivious_ algorithms work efficiently without explicitly knowing the data transfer sizes within the memory hierarchy.\n\n## Chapter Data Structures for Disjoint Sets\n\nSome applications involve grouping \\(n\\) distinct elements into a collection of disjoint sets\\(-\\)sets with no elements in common. These applications often need to perform two operations in particular: finding the unique set that contains a given element and uniting two sets. This chapter explores methods for maintaining a data structure that supports these operations.\n\nSection 19.1 describes the operations supported by a disjoint-set data structure and presents a simple application. Section 19.2 looks at a simple linked-list implementation for disjoint sets. Section 19.3 presents a more efficient representation using rooted trees. The running time using the tree representation is theoretically superlinear, but for all practical purposes it is linear. Section 19.4 defines and discusses a very quickly growing function and its very slowly growing inverse, which appears in the running time of operations on the tree-based implementation, and then, by a complex amortized analysis, proves an upper bound on the running time that is just barely superlinear.\n\n### Disjoint-set operations\n\nA _disjoint-set data structure_ maintains a collection \\(\\delta=\\{S_{1},S_{2},\\ldots,S_{k}\\}\\) of disjoint dynamic sets. To identify each set, choose a _representative_, which is some member of the set. In some applications, it doesn't matter which member is used as the representative; it matters only that if you ask for the representative of a dynamic set twice without modifying the set between the requests, you get the same answer both times. Other applications may require a prespecified rule for choosing the representative, such as choosing the smallest member in the set (for a set whose elements can be ordered).",
        "chapter": "Part V Advanced Data Structures",
        "section": "18 B-Trees",
        "subsection": "Chapter notes",
        "subsubsection": "N/A"
    },
    {
        "content": "## Chapter Data Structures for Disjoint Sets\n\nSome applications involve grouping \\(n\\) distinct elements into a collection of disjoint sets\\(-\\)sets with no elements in common. These applications often need to perform two operations in particular: finding the unique set that contains a given element and uniting two sets. This chapter explores methods for maintaining a data structure that supports these operations.\n\nSection 19.1 describes the operations supported by a disjoint-set data structure and presents a simple application. Section 19.2 looks at a simple linked-list implementation for disjoint sets. Section 19.3 presents a more efficient representation using rooted trees. The running time using the tree representation is theoretically superlinear, but for all practical purposes it is linear. Section 19.4 defines and discusses a very quickly growing function and its very slowly growing inverse, which appears in the running time of operations on the tree-based implementation, and then, by a complex amortized analysis, proves an upper bound on the running time that is just barely superlinear.\n\n### Disjoint-set operations\n\nA _disjoint-set data structure_ maintains a collection \\(\\delta=\\{S_{1},S_{2},\\ldots,S_{k}\\}\\) of disjoint dynamic sets. To identify each set, choose a _representative_, which is some member of the set. In some applications, it doesn't matter which member is used as the representative; it matters only that if you ask for the representative of a dynamic set twice without modifying the set between the requests, you get the same answer both times. Other applications may require a prespecified rule for choosing the representative, such as choosing the smallest member in the set (for a set whose elements can be ordered).\n\n### Disjoint-set operations\n\nAs in the other dynamic-set implementations we have studied, each element of a set is represented by an object. Letting \\(x\\) denote an object, we'll see how to support the following operations:\n\nMake-Set\\((x)\\), where \\(x\\) does not already belong to some other set, creates a new set whose only member (and thus representative) is \\(x\\). Union\\((x,y)\\) unites two disjoint, dynamic sets that contain \\(x\\) and \\(y\\), say \\(S_{x}\\) and \\(S_{y}\\), into a new set that is the union of these two sets. The representative of the resulting set is any member of \\(S_{x}\\cup S_{y}\\), although many implementations of Union specifically choose the representative of either \\(S_{x}\\) or \\(S_{y}\\) as the new representative. Since the sets in the collection must at all times be disjoint, the Union operation destroys sets \\(S_{x}\\) and \\(S_{y}\\), removing them from the collection \\(\\mathcal{S}\\). In practice, implementations often absorb the elements of one of the sets into the other set.\n\nFind-Set\\((x)\\) returns a pointer to the representative of the unique set containing \\(x\\).\n\nThroughout this chapter, we'll analyze the running times of disjoint-set data structures in terms of two parameters: \\(n\\), the number of Make-Set operations, and \\(m\\), the total number of Make-Set, Union, and Find-Set operations. Because the total number of operations \\(m\\) includes the \\(n\\) Make-Set operations, \\(m\\geq n\\). The first \\(n\\) operations are always Make-Set operations, so that after the first \\(n\\) operations, the collection consists of \\(n\\) singleton sets. Since the sets are disjoint at all times, each Union operation reduces the number of sets by \\(1\\). After \\(n-1\\) Union operations, therefore, only one set remains, and so at most \\(n-1\\) Union operations can occur.\n\n### An application of disjoint-set data structures\n\nOne of the many applications of disjoint-set data structures arises in determining the connected components of an undirected graph (see Section B.4). Figure 19.1(a), for example, shows a graph with four connected components.\n\nThe procedure Connected-Components on the following page uses the disjoint-set operations to compute the connected components of a graph. Once the Connected-Components procedure has preprocessed the graph, the procedure Same-Component answers queries about whether two vertices belong to the same connected component. In pseudocode, we denote the set of vertices of a graph \\(G\\) by \\(G.V\\) and the set of edges by \\(G.E\\).\n\nThe procedure Connected-Components initially places each vertex \\(v\\) in its own set. Then, for each edge \\((u,v)\\), it unites the sets containing \\(u\\) and \\(v\\). By Exercise 19.1-2, after all the edges are processed, two vertices belong to the same connected component if and only if the objects corresponding to the vertices belongto the same set. Thus Connected-Components computes sets in such a way that the procedure Same-Component can determine whether two vertices are in the same connected component. Figure 19.1(b) illustrates how Connected-Components computes the disjoint sets.\n\nIn an actual implementation of this connected-components algorithm, the representations of the graph and the disjoint-set data structure would need to reference each other. That is, an object representing a vertex would contain a pointer to the corresponding disjoint-set object, and vice versa. Since these programming details depend on the implementation language, we do not address them further here.\n\nWhen the edges of the graph are static--not changing over time--depth-first search can compute the connected components faster (see Exercise 20.3-12 on\n\nFigure 19.1: **(a)** A graph with four connected components: \\(\\{a,b,c,d\\}\\), \\(\\{e,f,g\\}\\), \\(\\{h,i\\}\\), and \\(\\{j\\}\\). **(b)** The collection of disjoint sets after processing each edge.\n\npage 572). Sometimes, however, the edges are added dynamically, with the connected components updated as each edge is added. In this case, the implementation given here can be more efficient than running a new depth-first search for each new edge.\n\n##### Exercises\n\n##### 19.1-1\n\nThe Connected-Components procedure is run on the undirected graph \\(G=(V,E)\\), where \\(V=\\{a,b,c,d,e,f,g,h,i,j,k\\}\\), and the edges of \\(E\\) are processed in the order \\((d,i),(f,k),(g,i),(b,g),(a,h),(i,j),(d,k),(b,j),(d,f)\\), \\((g,j),(a,e)\\). List the vertices in each connected component after each iteration of lines 3-5.\n\n##### 19.1-2\n\nShow that after all edges are processed by Connected-Components, two vertices belong to the same connected component if and only if they belong to the same set.\n\n##### 19.1-3\n\nDuring the execution of Connected-Components on an undirected graph \\(G=(V,E)\\) with \\(k\\) connected components, how many times is Find-Set called? How many times is Union called? Express your answers in terms of \\(|V|\\), \\(|E|\\), and \\(k\\).\n\n##### Linked-list representation of disjoint sets\n\nFigure 19.2(a) shows a simple way to implement a disjoint-set data structure: each set is represented by its own linked list. The object for each set has attributes _head_, pointing to the first object in the list, and _tail_, pointing to the last object. Each object in the list contains a set member, a pointer to the next object in the list, and a pointer back to the set object. Within each linked list, the objects may appear in any order. The representative is the set member in the first object in the list.\n\nWith this linked-list representation, both Make-Set and Find-Set require only \\(O(1)\\) time. To carry out Make-Set\\((x)\\), create a new linked list whose only object is \\(x\\). For Find-Set\\((x)\\), just follow the pointer from \\(x\\) back to its set object and then return the member in the object that _head_ points to. For example, in Figure 19.2(a), the call Find-Set\\((g)\\) returns \\(f\\).",
        "chapter": "Part V Advanced Data Structures",
        "section": "19 Data Structures for Disjoint Sets",
        "subsection": "19.1 Disjoint-set operations",
        "subsubsection": "N/A"
    },
    {
        "content": "page 572). Sometimes, however, the edges are added dynamically, with the connected components updated as each edge is added. In this case, the implementation given here can be more efficient than running a new depth-first search for each new edge.\n\n##### Exercises\n\n##### 19.1-1\n\nThe Connected-Components procedure is run on the undirected graph \\(G=(V,E)\\), where \\(V=\\{a,b,c,d,e,f,g,h,i,j,k\\}\\), and the edges of \\(E\\) are processed in the order \\((d,i),(f,k),(g,i),(b,g),(a,h),(i,j),(d,k),(b,j),(d,f)\\), \\((g,j),(a,e)\\). List the vertices in each connected component after each iteration of lines 3-5.\n\n##### 19.1-2\n\nShow that after all edges are processed by Connected-Components, two vertices belong to the same connected component if and only if they belong to the same set.\n\n##### 19.1-3\n\nDuring the execution of Connected-Components on an undirected graph \\(G=(V,E)\\) with \\(k\\) connected components, how many times is Find-Set called? How many times is Union called? Express your answers in terms of \\(|V|\\), \\(|E|\\), and \\(k\\).\n\n##### Linked-list representation of disjoint sets\n\nFigure 19.2(a) shows a simple way to implement a disjoint-set data structure: each set is represented by its own linked list. The object for each set has attributes _head_, pointing to the first object in the list, and _tail_, pointing to the last object. Each object in the list contains a set member, a pointer to the next object in the list, and a pointer back to the set object. Within each linked list, the objects may appear in any order. The representative is the set member in the first object in the list.\n\nWith this linked-list representation, both Make-Set and Find-Set require only \\(O(1)\\) time. To carry out Make-Set\\((x)\\), create a new linked list whose only object is \\(x\\). For Find-Set\\((x)\\), just follow the pointer from \\(x\\) back to its set object and then return the member in the object that _head_ points to. For example, in Figure 19.2(a), the call Find-Set\\((g)\\) returns \\(f\\).\n\n### A simple implementation of union\n\nThe simplest implementation of the Union operation using the linked-list set representation takes significantly more time than Make-Set or Find-Set. As Figure 19.2(b) shows, the operation Union(\\(x\\), \\(y\\)) appends \\(y\\)'s list onto the end of \\(x\\)'s list. The representative of \\(x\\)'s list becomes the representative of the resulting set. To quickly find where to append \\(y\\)'s list, use the _tail_ pointer for \\(x\\)'s list. Because all members of \\(y\\)'s list join \\(x\\)'s list, the Union operation destroys the set object for \\(y\\)'s list. The Union operation is where this implementation pays the price for Find-Set taking constant time: Union must also update the pointer to the set object for each object originally on \\(y\\)'s list, which takes time linear in the length of \\(y\\)'s list. In Figure 19.2, for example, the operation Union(\\(g\\), \\(e\\)) causes pointers to be updated in the objects for \\(b\\), \\(c\\), \\(e\\), and \\(h\\).\n\nIn fact, we can construct a sequence of \\(m\\) operations on \\(n\\) objects that requires \\(\\Theta(n^{2})\\) time. Starting with objects \\(x_{1}\\), \\(x_{2}\\), \\(\\ldots\\), \\(x_{n}\\), execute the sequence of \\(n\\) Make-Set operations followed by \\(n-1\\) Union operations shown in Figure 19.3, so that \\(m=2n-1\\). The \\(n\\) Make-Set operations take \\(\\Theta(n)\\) time. Because the \\(i\\)th Union operation updates \\(i\\) objects, the total number of objects updated by all \\(n-1\\) Union operations forms an arithmetic series:\n\nFigure 19.2: **(a)** Linked-list representations of two sets. Set \\(S_{1}\\) contains members \\(d\\), \\(f\\), and \\(g\\), with representative \\(f\\), and set \\(S_{2}\\) contains members \\(b\\), \\(c\\), \\(e\\), and \\(h\\), with representative \\(c\\). Each object in the list contains a set member, a pointer to the next object in the list, and a pointer back to the set object. Each set object has pointers _head_ and _tail_ to the first and last objects, respectively. **(b)** The result of Union(\\(g\\), \\(e\\)), which appends the linked list containing \\(e\\) to the linked list containing \\(g\\). The representative of the resulting set is \\(f\\). The set object for \\(e\\)\u2019s list, \\(S_{2}\\), is destroyed.\n\n\\[\\sum_{i\\,=\\,1}^{n-1}i\\,=\\,\\Theta(n^{2})\\.\\]\n\nThe total number of operations is \\(2n-1\\), and so each operation on average requires \\(\\Theta(n)\\) time. That is, the amortized time of an operation is \\(\\Theta(n)\\).\n\n#### A weighted-union heuristic\n\nIn the worst case, the above implementation of Union requires an average of \\(\\Theta(n)\\) time per call, because it might be appending a longer list onto a shorter list, and the procedure must update the pointer to the set object for each member of the longer list. Suppose instead that each list also includes the length of the list (which can be maintained straightforwardly with constant overhead) and that the Union procedure always appends the shorter list onto the longer, breaking ties arbitrarily. With this simple _weighted-union heuristic_, a single Union operation can still take \\(\\Omega(n)\\) time if both sets have \\(\\Omega(n)\\) members. As the following theorem shows, however, a sequence of \\(m\\) Make-Set, Union, and Find-Set operations, \\(n\\) of which are Make-Set operations, takes \\(\\,O(m+n\\lg n)\\) time.\n\n**Theorem 19.1**: _Using the linked-list representation of disjoint sets and the weighted-union heuristic, a sequence of \\(m\\) Make-Set, Union, and Find-Set operations, \\(n\\) of which are Make-Set operations, takes \\(\\,O(m+n\\lg n)\\) time._\n\nBecause each Union operation unites two disjoint sets, at most \\(n-1\\) Union operations occur over all. We now bound the total time taken by these\n\nFigure 19.3: A sequence of \\(2n-1\\) operations on \\(n\\) objects that takes \\(\\Theta(n^{2})\\) time, or \\(\\Theta(n)\\) time per operation on average, using the linked-list set representation and the simple implementation of Union.\n\nUnion operations. We start by determining, for each object, an upper bound on the number of times the object's pointer back to its set object is updated. Consider a particular object \\(x\\). Each time \\(x\\)'s pointer is updated, \\(x\\) must have started in the smaller set. The first time \\(x\\)'s pointer is updated, therefore, the resulting set must have at least 2 members. Similarly, the next time \\(x\\)'s pointer is updated, the resulting set must have had at least 4 members. Continuing on, for any \\(k\\leq n\\), after \\(x\\)'s pointer has been updated \\(\\lceil\\lg k\\rceil\\) times, the resulting set must have at least \\(k\\) members. Since the largest set has at most \\(n\\) members, each object's pointer is updated at most \\(\\lceil\\lg n\\rceil\\) times over all the Union operations. Thus the total time spent updating object pointers over all Union operations is \\(O(n\\lg n)\\). We must also account for updating the _tail_ pointers and the list lengths, which take only \\(\\Theta(1)\\) time per Union operation. The total time spent in all Union operations is thus \\(O(n\\lg n)\\).\n\nThe time for the entire sequence of \\(m\\) operations follows. Each Make-Set and Find-Set operation takes \\(O(1)\\) time, and there are \\(O(m)\\) of them. The total time for the entire sequence is thus \\(O(m+n\\lg n)\\).\n\n#### Exercises\n\n##### 19.2-1\n\nWrite pseudocode for Make-Set, Find-Set, and Union using the linked-list representation and the weighted-union heuristic. Make sure to specify the attributes that you assume for set objects and list objects.\n\n##### 19.2-2\n\nShow the data structure that results and the answers returned by the Find-Set operations in the following program. Use the linked-list representation with the weighted-union heuristic. Assume that if the sets containing \\(x_{i}\\) and \\(x_{j}\\) have the same size, then the operation Union(\\(x_{i},x_{j}\\)) appends \\(x_{j}\\)'s list onto \\(x_{i}\\)'s list.\n\n```\n1for\\(i=1\\)to\\(16\\)\n2Make-Set(\\(x_{i}\\))\n3for\\(i=1\\)to\\(15\\)by\\(2\\)\n4Union(\\(x_{i},x_{i+1}\\))\n5for\\(i=1\\)to\\(13\\)by\\(4\\)\n6Union(\\(x_{i},x_{i+2}\\))\n7Union(\\(x_{1},x_{5}\\))\n8Union(\\(x_{11},x_{13}\\))\n9Union(\\(x_{1},x_{10}\\))\n10Find-Set(\\(x_{2}\\))\n11Find-Set(\\(x_{9}\\))\n\n### Disjoint-set forests\n\nAdapt the aggregate proof of Theorem 19.1 to obtain amortized time bounds of \\(O(1)\\) for Make-Set and Find-Set and \\(O(\\lg n)\\) for Union using the linked-list representation and the weighted-union heuristic.\n\n### 19.2-4\n\nGive a tight asymptotic bound on the running time of the sequence of operations in Figure 19.3 assuming the linked-list representation and the weighted-union heuristic.\n\n### 19.2-5\n\nProfessor Gompers suspects that it might be possible to keep just one pointer in each set object, rather than two (_head_ and _tail_), while keeping the number of pointers in each list element at two. Show that the professor's suspicion is well founded by describing how to represent each set by a linked list such that each operation has the same running time as the operations described in this section. Describe also how the operations work. Your scheme should allow for the weighted-union heuristic, with the same effect as described in this section. (_Hint:_ Use the tail of a linked list as its set's representative.)\n\n### 19.2-6\n\nSuggest a simple change to the Union procedure for the linked-list representation that removes the need to keep the _tail_ pointer to the last object in each list. Regardless of whether the weighted-union heuristic is used, your change should not change the asymptotic running time of the Union procedure. (_Hint_: Rather than appending one list to another, splice them together.)\n\n### Disjoint-set forests\n\nA faster implementation of disjoint sets represents sets by rooted trees, with each node containing one member and each tree representing one set. In a _disjoint-set forest_, illustrated in Figure 19.4(a), each member points only to its parent. The root of each tree contains the representative and is its own parent. As we'll see, although the straightforward algorithms that use this representation are no faster than ones that use the linked-list representation, two heuristics--\"union by rank\" and \"path compression\"--yield an asymptotically optimal disjoint-set data structure.\n\nThe three disjoint-set operations have simple implementations. A Make-Set operation simply creates a tree with just one node. A Find-Set operation follows parent pointers until it reaches the root of the tree. The nodes visited on this sim",
        "chapter": "Part V Advanced Data Structures",
        "section": "19 Data Structures for Disjoint Sets",
        "subsection": "19.2 Linked-list representation of disjoint sets",
        "subsubsection": "N/A"
    },
    {
        "content": "### Disjoint-set forests\n\nAdapt the aggregate proof of Theorem 19.1 to obtain amortized time bounds of \\(O(1)\\) for Make-Set and Find-Set and \\(O(\\lg n)\\) for Union using the linked-list representation and the weighted-union heuristic.\n\n### 19.2-4\n\nGive a tight asymptotic bound on the running time of the sequence of operations in Figure 19.3 assuming the linked-list representation and the weighted-union heuristic.\n\n### 19.2-5\n\nProfessor Gompers suspects that it might be possible to keep just one pointer in each set object, rather than two (_head_ and _tail_), while keeping the number of pointers in each list element at two. Show that the professor's suspicion is well founded by describing how to represent each set by a linked list such that each operation has the same running time as the operations described in this section. Describe also how the operations work. Your scheme should allow for the weighted-union heuristic, with the same effect as described in this section. (_Hint:_ Use the tail of a linked list as its set's representative.)\n\n### 19.2-6\n\nSuggest a simple change to the Union procedure for the linked-list representation that removes the need to keep the _tail_ pointer to the last object in each list. Regardless of whether the weighted-union heuristic is used, your change should not change the asymptotic running time of the Union procedure. (_Hint_: Rather than appending one list to another, splice them together.)\n\n### Disjoint-set forests\n\nA faster implementation of disjoint sets represents sets by rooted trees, with each node containing one member and each tree representing one set. In a _disjoint-set forest_, illustrated in Figure 19.4(a), each member points only to its parent. The root of each tree contains the representative and is its own parent. As we'll see, although the straightforward algorithms that use this representation are no faster than ones that use the linked-list representation, two heuristics--\"union by rank\" and \"path compression\"--yield an asymptotically optimal disjoint-set data structure.\n\nThe three disjoint-set operations have simple implementations. A Make-Set operation simply creates a tree with just one node. A Find-Set operation follows parent pointers until it reaches the root of the tree. The nodes visited on this simple path toward the root constitute the _find path_. A Union operation, shown in Figure 19.4(b), simply causes the root of one tree to point to the root of the other.\n\n##### Heuristics to improve the running time\n\nSo far, disjoint-set forests have not improved on the linked-list implementation. A sequence of \\(n-1\\) Union operations could create a tree that is just a linear chain of \\(n\\) nodes. By using two heuristics, however, we can achieve a running time that is almost linear in the total number \\(m\\) of operations.\n\nThe first heuristic, _union by rank_, is similar to the weighted-union heuristic we used with the linked-list representation. The common-sense approach is to make the root of the tree with fewer nodes point to the root of the tree with more nodes. Rather than explicitly keeping track of the size of the subtree rooted at each node, however, we'll adopt an approach that eases the analysis. For each node, maintain a _rank_, which is an upper bound on the height of the node. Union by rank makes the root with smaller rank point to the root with larger rank during a Union operation.\n\nThe second heuristic, _path compression_, is also quite simple and highly effective. As shown in Figure 19.5, Find-Set operations use it to make each node on the find path point directly to the root. Path compression does not change any ranks.\n\n##### Pseudocode for disjoint-set forests\n\nThe union-by-rank heuristic requires its implementation to keep track of ranks. With each node \\(x\\), maintain the integer value \\(x.\\textit{rank}\\), which is an upper bound on the height of \\(x\\) (the number of edges in the longest simple path from a descendant leaf to \\(x\\)). When Make-Set creates a singleton set, the single node in the\n\nFigure 19.4: A disjoint-set forest. **(a)** Trees representing the two sets of Figure 19.2. The tree on the left represents the set \\(\\{b,c,e,h\\}\\), with \\(c\\) as the representative, and the tree on the right represents the set \\(\\{d,f,g\\}\\), with \\(f\\) as the representative. **(b)** The result of Union\\((e,g)\\).\n\ncorresponding tree has an initial rank of 0. Each Find-Set operation leaves all ranks unchanged. The Union operation has two cases, depending on whether the roots of the trees have equal rank. If the roots have unequal ranks, make the root with higher rank the parent of the root with lower rank, but don't change the ranks themselves. If the roots have equal ranks, arbitrarily choose one of the roots as the parent and increment its rank.\n\nLet's put this method into pseudocode, appearing on the next page. The parent of node \\(x\\) is denoted by \\(x.p\\). The Link procedure, a subroutine called by Union, takes pointers to two roots as inputs. The Find-Set procedure with path compression, implemented recursively, turns out to be quite simple.\n\nThe Find-Set procedure is a _two-pass method_: as it recurses, it makes one pass up the find path to find the root, and as the recursion unwinds, it makes a second pass back down the find path to update each node to point directly to the root. Each call of Find-Set(\\(x\\)) returns \\(x.p\\) in line 3. If \\(x\\) is the root, then Find-Set skips line 2 and just returns \\(x.p\\), which is \\(x\\). In this case the recursion bottoms out. Otherwise, line 2 executes, and the recursive call with parameter \\(x.p\\) returns\n\nFigure 19.5: Path compression during the operation Find-Set. Arrows and self-loops at roots are omitted. **(a)** A tree representing a set prior to executing Find-Set(\\(a\\)). Triangles represent subtrees whose roots are the nodes shown. Each node has a pointer to its parent. **(b)** The same set after executing Find-Set(\\(a\\)). Each node on the find path now points directly to the root.\n\na pointer to the root. Line 2 updates node \\(x\\) to point directly to the root, and line 3 returns this pointer.\n\n##### Effect of the heuristics on the running time\n\nSeparately, either union by rank or path compression improves the running time of the operations on disjoint-set forests, and combining the two heuristics yields an even greater improvement. Alone, union by rank yields a running time of \\(O(m\\lg n)\\) for a sequence of \\(m\\) operations, \\(n\\) of which are Make-Set (see Exercise 19.4-4), and this bound is tight (see Exercise 19.3-3). Although we won't prove it here, for a sequence of \\(n\\)Make-Set operations (and hence at most \\(n-1\\) Union operations) and \\(f\\)Find-Set operations, the worst-case running time using only the path-compression heuristic is \\(\\Theta(n+f\\cdot(1+\\log_{2+f/n}n))\\).\n\nCombining union by rank and path compression gives a worst-case running time of \\(O(m\\alpha(n))\\), where \\(\\alpha(n)\\) is a _very_ slowly growing function, defined in Section 19.4. In any conceivable application of a disjoint-set data structure, \\(\\alpha(n)\\leq 4\\), and thus, its running time is as good as linear in \\(m\\) for all practical purposes. Mathematically speaking, however, it is superlinear. Section 19.4 proves this \\(O(m\\alpha(n))\\) upper bound.\n\n### 19.4 Analysis of union by rank with path compression\n\nAs noted in Section 19.3, the combined union-by-rank and path-compression heuristic runs in \\(O(m\\;\\alpha(n))\\) time for \\(m\\) disjoint-set operations on \\(n\\) elements. In this section, we'll explore the function \\(\\alpha\\) to see just how slowly it grows. Then we'll analyze the running time using the potential method of amortized analysis.\n\n**A very quickly growing function and its very slowly growing inverse**\n\nFor integers \\(j,k\\geq 0\\), we define the function \\(A_{k}(j)\\) as",
        "chapter": "Part V Advanced Data Structures",
        "section": "19 Data Structures for Disjoint Sets",
        "subsection": "19.3 Disjoint-set forests",
        "subsubsection": "N/A"
    },
    {
        "content": "### 19.4 Analysis of union by rank with path compression\n\nAs noted in Section 19.3, the combined union-by-rank and path-compression heuristic runs in \\(O(m\\;\\alpha(n))\\) time for \\(m\\) disjoint-set operations on \\(n\\) elements. In this section, we'll explore the function \\(\\alpha\\) to see just how slowly it grows. Then we'll analyze the running time using the potential method of amortized analysis.\n\n**A very quickly growing function and its very slowly growing inverse**\n\nFor integers \\(j,k\\geq 0\\), we define the function \\(A_{k}(j)\\) as\\[A_{k}(j)=\\left\\{\\begin{array}{ll}j\\,+\\,1&\\mbox{if $k\\,=0$,}\\\\ A_{k-1}^{(j\\,+\\,1)}(j)&\\mbox{if $k\\,\\geq 1$,}\\end{array}\\right. \\tag{19.1}\\]\n\nwhere the expression \\(A_{k-1}^{(j\\,+\\,1)}(j)\\) uses the functional-iteration notation defined in equation (3.30) on page 68. Specifically, equation (3.30) gives \\(A_{k-1}^{(0)}(j)=j\\) and \\(A_{k-1}^{(i)}(j)=A_{k-1}(A_{k-1}^{(i-1)}(j))\\) for \\(i\\,\\geq 1\\). We call the parameter \\(k\\) the _level_ of the function \\(A\\).\n\nThe function \\(A_{k}(j)\\) strictly increases with both \\(j\\) and \\(k\\). To see just how quickly this function grows, we first obtain closed-form expressions for \\(A_{1}(j)\\) and \\(A_{2}(j)\\).\n\n**Lemma 19.2**: _For any integer \\(j\\,\\geq 1\\), we have \\(A_{1}(j)=2j\\,+\\,1\\)._\n\n_Proof_ We first use induction on \\(i\\) to show that \\(A_{0}^{(i)}(j)=j+i\\). For the base case, \\(A_{0}^{(0)}(j)=j\\,=\\,j\\,+\\,0\\). For the inductive step, assume that \\(A_{0}^{(i-1)}(j)=j+(i-1)\\). Then \\(A_{0}^{(i)}(j)=A_{0}(A_{0}^{(i-1)}(j))=(j+(i-1))+1=j\\,+\\,i\\). Finally, we note that \\(A_{1}(j)=A_{0}^{(j\\,+\\,1)}(j)=j\\,+\\,(j\\,+\\,1)=2j\\,+\\,1\\).\n\n**Lemma 19.3**: _For any integer \\(j\\,\\geq 1\\), we have \\(A_{2}(j)=2^{j\\,+\\,1}(j\\,+\\,1)-1\\)._\n\n_Proof_ We first use induction on \\(i\\) to show that \\(A_{1}^{(i)}(j)=2^{i}(j\\,+\\,1)-1\\). For the base case, we have \\(A_{1}^{(0)}(j)=j\\,=\\,2^{0}(j\\,+\\,1)-1\\). For the inductive step, assume that \\(A_{1}^{(i-1)}(j)=2^{i-1}(j\\,+\\,1)-1\\). Then \\(A_{1}^{(i)}(j)=A_{1}(A_{1}^{(i-1)}(j))=A_{1}(2^{i-1}(j\\,+\\,1)-1)=2^{i}(j\\,+\\, 1)-1\\). Finally, we note that \\(A_{2}(j)=A_{1}^{(j\\,+\\,1)}(j)=2^{j\\,+\\,1}(j\\,+\\,1)-1\\).\n\nNow we can see how quickly \\(A_{k}(j)\\) grows by simply examining \\(A_{k}(1)\\) for levels \\(k=0,1,2,3,4\\). From the definition of \\(A_{0}(j)\\) and the above lemmas, we have \\(A_{0}(1)=1+1=2\\), \\(A_{1}(1)=2\\cdot 1+1=3\\), and \\(A_{2}(1)=2^{1+1}\\cdot(1+1)-1=7\\). We also have\n\n\\[A_{3}(1) = A_{2}^{(2)}(1)\\] \\[= A_{2}(A_{2}(1))\\] \\[= A_{2}(7)\\] \\[= 2^{8}\\cdot 8-1\\] \\[= 2^{11}-1\\] \\[= 2047\\]and\n\n\\[A_{4}(1) = A_{3}^{(2)}(1)\\] \\[= A_{3}(A_{3}(1))\\] \\[= A_{3}(2047)\\] \\[= A_{2}^{(2048)}(2047)\\] \\[\\gg A_{2}(2047)\\] \\[= 2^{2048}\\cdot 2048-1\\] \\[= 2^{2059}-1\\] \\[> 2^{2056}\\] \\[= (2^{4})^{514}\\] \\[= 16^{514}\\] \\[\\gg 10^{80}\\,\\]\n\nwhich is the estimated number of atoms in the observable universe. (The symbol \"\\(\\gg\\)\" denotes the \"much-greater-than\" relation.)\n\nWe define the inverse of the function \\(A_{k}(n)\\), for integer \\(n\\geq 0\\), by\n\n\\[\\alpha(n)=\\min\\left\\{k:A_{k}(1)\\geq n\\right\\}. \\tag{19.2}\\]\n\nIn words, \\(\\alpha(n)\\) is the lowest level \\(k\\) for which \\(A_{k}(1)\\) is at least \\(n\\). From the above values of \\(A_{k}(1)\\), we see that\n\n\\[\\alpha(n)=\\left\\{\\begin{array}{ll}0&\\mbox{for $0\\leq n\\leq 2$}\\,\\\\ 1&\\mbox{for $n=3$}\\,\\\\ 2&\\mbox{for $4\\leq n\\leq 7$}\\,\\\\ 3&\\mbox{for $8\\leq n\\leq 2047$}\\,\\\\ 4&\\mbox{for $2048\\leq n\\leq A_{4}(1)$}\\.\\end{array}\\right.\\]\n\nIt is only for values of \\(n\\) so large that the term \"astronomical\" understates them (greater than \\(A_{4}(1)\\), a huge number) that \\(\\alpha(n)\\!>\\!4\\), and so \\(\\alpha(n)\\leq 4\\) for all practical purposes.\n\n### Properties of ranks\n\nIn the remainder of this section, we prove an \\(O(m\\alpha(n))\\) bound on the running time of the disjoint-set operations with union by rank and path compression. In order to prove this bound, we first prove some simple properties of ranks.\n\n**Lemma 19.4**: For all nodes \\(x\\), we have \\(x\\!\\cdot\\!rank\\leq x\\!\\cdot\\!p\\!\\cdot\\!rank\\), with strict inequality if \\(x\\neq x\\!\\cdot\\!p\\) (\\(x\\) is not a root). The value of \\(x\\!\\cdot\\!rank\\) is initially \\(0\\), increases through time until \\(x\\neq x\\!\\cdot\\!p\\)and from then on, \\(x\\). _rank_ does not change. The value of \\(x\\). _p. rank_ monotonically increases over time.\n\nProofThe proof is a straightforward induction on the number of operations, using the implementations of Make-Set, Union, and Find-Set that appear on page 530, and is left as Exercise 19.4-1.\n\n**Corollary 19.5**: _On the simple path from any node going up toward a root, node ranks strictly increase._\n\n**Lemma 19.6**: _Every node has rank at most \\(n-1\\)._\n\nProofEach node's rank starts at 0, and it increases only upon Link operations. Because there are at most \\(n-1\\) Union operations, there are also at most \\(n-1\\) Link operations. Because each Link operation either leaves all ranks alone or increases some node's rank by 1, all ranks are at most \\(n-1\\).\n\nLemma 19.6 provides a weak bound on ranks. In fact, every node has rank at most \\(\\lfloor\\lg n\\rfloor\\) (see Exercise 19.4-2). The looser bound of Lemma 19.6 suffices for our purposes, however.\n\n### Proving the time bound\n\nIn order to prove the \\(O(m\\ \\alpha(n))\\) time bound, we'll use the potential method of amortized analysis from Section 16.3. In performing the amortized analysis, it will be convenient to assume that we invoke the Link operation rather than the Union operation. That is, since the parameters of the Link procedure are pointers to two roots, we act as though we perform the appropriate Find-Set operations separately. The following lemma shows that even if we count the extra Find-Set operations induced by Union calls, the asymptotic running time remains unchanged.\n\n**Lemma 19.7**: _Suppose that we convert a sequence \\(S^{\\prime}\\) of \\(m^{\\prime}\\) Make-Set, Union, and Find-Set operations into a sequence \\(S\\) of \\(m\\) Make-Set, Link, and Find-Set operations by turning each Union into two Find-Set operations followed by one Link. Then, if sequence \\(S\\) runs in \\(O(m\\,\\alpha(n))\\) time, sequence \\(S^{\\prime}\\) runs in \\(O(m^{\\prime}\\,\\alpha(n))\\) time._\n\nProofSince each Union operation in sequence \\(S^{\\prime}\\) is converted into three operations in \\(S\\), we have \\(m^{\\prime}\\leq m\\leq 3m^{\\prime}\\), so that \\(m=\\Theta(m^{\\prime})\\), Thus, an \\(O(m\\ \\alpha(n))\\)time bound for the converted sequence \\(S\\) implies an \\(O(m^{\\prime}\\;\\alpha(n))\\) time bound for the original sequence \\(S^{\\prime}\\).\n\nFrom now on, we assume that the initial sequence of \\(m^{\\prime}\\) Make-Set, Union, and Find-Set operations has been converted to a sequence of \\(m\\) Make-Set, Link, and Find-Set operations. We now prove an \\(O(m\\,\\alpha(n))\\) time bound for the converted sequence and appeal to Lemma 19.7 to prove the \\(O(m^{\\prime}\\;\\alpha(n))\\) running time of the original sequence of \\(m^{\\prime}\\) operations.\n\n##### Potential function\n\nThe potential function we use assigns a potential \\(\\phi_{q}(x)\\) to each node \\(x\\) in the disjoint-set forest after \\(q\\) operations. For the potential \\(\\Phi_{q}\\) of the entire forest after \\(q\\) operations, sum the individual node potentials: \\(\\Phi_{q}=\\sum_{x}\\phi_{q}(x)\\). Because the forest is empty before the first operation, the sum is taken over an empty set, and so \\(\\Phi_{0}=0\\). No potential \\(\\Phi_{q}\\) is ever negative.\n\nThe value of \\(\\phi_{q}(x)\\) depends on whether \\(x\\) is a tree root after the \\(q\\)th operation. If it is, or if \\(x.\\,rank=0\\), then \\(\\phi_{q}(x)=\\alpha(n)\\cdot x.\\,rank\\).\n\nNow suppose that after the \\(q\\)th operation, \\(x\\) is not a root and that \\(x.\\,rank\\geq 1\\). We need to define two auxiliary functions on \\(x\\) before we can define \\(\\phi_{q}(x)\\). First we define\n\n\\[\\mbox{level}(x)=\\max\\,\\{k:x.\\,p.\\,rank\\geq A_{k}(x.\\,rank)\\}\\,\\,\\,. \\tag{19.3}\\]\n\nThat is, \\(\\mbox{level}(x)\\) is the greatest level \\(k\\) for which \\(A_{k}\\), applied to \\(x\\)'s rank, is no greater than \\(x\\)'s parent's rank.\n\nWe claim that\n\n\\[0\\leq\\mbox{level}(x)<\\alpha(n)\\,\\,, \\tag{19.4}\\]\n\nwhich we see as follows. We have\n\n\\[x.\\,p.\\,rank \\geq x.\\,rank+1\\] (by Lemma 19.4 because \\[x\\] is not a root) \\[= A_{0}(x.\\,rank)\\] (by the definition ( 19.1) of \\[A_{0}(j)\\] ),\n\nwhich implies that \\(\\mbox{level}(x)\\geq 0\\), and\n\n\\[A_{\\alpha(n)}(x.\\,rank) \\geq A_{\\alpha(n)}(1)\\] (because \\[A_{k}(j)\\] is strictly increasing) \\[\\geq n\\] (by the definition ( 19.2) of \\[\\alpha(n)\\] ) \\[> x.\\,\\,\\,p.\\,rank\\] (by Lemma 19.6),\n\nwhich implies that \\(\\mbox{level}(x)<\\alpha(n)\\).\n\nFor a given nonroot node \\(x\\), the value of \\(\\mbox{level}(x)\\) monotonically increases over time. Why? Because \\(x\\) is not a root, its rank does not change. The rank of \\(x.\\,p\\)monotonically increases over time, since if \\(x.p\\) is not a root then its rank does not change, and if \\(x.p\\) is a root then its rank can never decrease. Thus, the difference between \\(x.\\,rank\\) and \\(x.p.\\,rank\\) monotonically increases over time. Therefore, the value of \\(k\\) needed for \\(A_{k}(x.\\,rank)\\) to overtake \\(x.p.\\,rank\\) monotonically increases over time as well.\n\nThe second auxiliary function applies when \\(x.\\,rank\\geq 1\\):\n\n\\[\\mbox{iter}(x)=\\mbox{max}\\,\\left\\{i:x.p.\\,rank\\geq A_{\\mbox{\\scriptsize level $(x)$}}^{(i)}(x.\\,rank)\\right\\}. \\tag{19.5}\\]\n\nThat is, \\(\\mbox{iter}(x)\\) is the largest number of times we can iteratively apply \\(A_{\\mbox{\\scriptsize level$(x)$}}\\), applied initially to \\(x\\)'s rank, before exceeding \\(x\\)'s parent's rank.\n\nWe claim that when \\(x.\\,rank\\geq 1\\), we have\n\n\\[1\\leq\\mbox{iter}(x)\\leq x.\\,rank\\, \\tag{19.6}\\]\n\nwhich we see as follows. We have\n\n\\[\\begin{array}{ll}x.\\,p.\\,rank&\\geq\\ A_{\\mbox{\\scriptsize level$(x)$}}(x.\\, rank)&\\mbox{(by the definition (\\ref{eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq: eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq: eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq: eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq: eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq\\[\\phi_{q}(x) = (\\alpha(n)-\\operatorname{level}(x))\\cdot x\\,.\\,rank-\\operatorname{ iter}(x)\\] \\[\\geq x\\,.\\,rank-x\\,.\\,rank\\] \\[= 0\\.\\]\n\nSimilarly, minimizing \\(\\operatorname{level}(x)\\) and \\(\\operatorname{iter}(x)\\) provides an upper bound on \\(\\phi_{q}(x)\\). By the bound (19.4), \\(\\operatorname{level}(x)\\geq 0\\), and by the bound (19.6), \\(\\operatorname{iter}(x)\\geq 1\\). Thus, we have\n\n\\[\\phi_{q}(x) \\leq (\\alpha(n)-0)\\cdot x\\,.\\,rank-1\\] \\[= \\alpha(n)\\cdot x\\,.\\,rank-1\\] \\[< \\alpha(n) \\cdot x\\,.\\,rank\\.\\]\n\n**Corollary 19.9**: _If node \\(x\\) is not a root and \\(x\\,.\\,rank>0\\), then \\(\\phi_{q}(x)<\\alpha(n)\\cdot x\\,.\\,rank\\)._\n\n**Potential changes and amortized costs of operations**\n\nWe are now ready to examine how the disjoint-set operations affect node potentials. Once we understand how each operation can change the potential, we can determine the amortized costs.\n\n**Lemma 19.10**: _Let \\(x\\) be a node that is not a root, and suppose that the \\(q\\)th operation is either a Link or a Find-Set. Then after the \\(q\\)th operation, \\(\\phi_{q}(x)\\leq\\phi_{q-1}(x)\\). Moreover, if \\(x\\,.\\,rank\\geq 1\\) and either \\(\\operatorname{level}(x)\\) or \\(\\operatorname{iter}(x)\\) changes due to the \\(q\\)th operation, then \\(\\phi_{q}(x)\\leq\\phi_{q-1}(x)-1\\). That is, \\(x\\)'s potential cannot increase, and if it has positive rank and either \\(\\operatorname{level}(x)\\) or \\(\\operatorname{iter}(x)\\) changes, then \\(x\\)'s potential drops by at least \\(1\\)._\n\nBecause \\(x\\) is not a root, the \\(q\\)th operation does not change \\(x\\,.\\,rank\\), and because \\(n\\) does not change after the initial \\(n\\) Make-Set operations, \\(\\alpha(n)\\) remains unchanged as well. Hence, these components of the formula for \\(x\\)'s potential remain the same after the \\(q\\)th operation. If \\(x\\,.\\,rank=0\\), then \\(\\phi_{q}(x)=\\phi_{q-1}(x)=0\\).\n\nNow assume that \\(x\\,.\\,rank\\geq 1\\). Recall that \\(\\operatorname{level}(x)\\) monotonically increases over time. If the \\(q\\)th operation leaves \\(\\operatorname{level}(x)\\) unchanged, then \\(\\operatorname{iter}(x)\\) either increases or remains unchanged. If both \\(\\operatorname{level}(x)\\) and \\(\\operatorname{iter}(x)\\) are unchanged, then \\(\\phi_{q}(x)=\\phi_{q-1}(x)\\). If \\(\\operatorname{level}(x)\\) is unchanged and \\(\\operatorname{iter}(x)\\) increases, then it increases by at least \\(1\\), and so \\(\\phi_{q}(x)\\leq\\phi_{q-1}(x)-1\\).\n\nFinally, if the \\(q\\)th operation increases \\(\\operatorname{level}(x)\\), it increases by at least \\(1\\), so that the value of the term \\((\\alpha(n)-\\operatorname{level}(x))\\cdot x\\,.\\,rank\\) drops by at least \\(x\\,.\\,rank\\). Because \\(\\operatorname{level}(x)\\) increased, the value of \\(\\operatorname{iter}(x)\\) might drop, but according to the bound (19.6), the drop is by at most \\(x\\,.\\,rank-1\\). Thus, the increase in potential due to the change in \\(\\mathrm{iter}(x)\\) is less than the decrease in potential due to the change in \\(\\mathrm{level}(x)\\), yielding \\(\\phi_{q}(x)\\leq\\phi_{q-1}(x)-1\\).\n\nOur final three lemmas show that the amortized cost of each Make-Set, Link, and Find-Set operation is \\(O(\\alpha(n))\\). Recall from equation (16.2) on page 16.2 that the amortized cost of each operation is its actual cost plus the change in potential due to the operation.\n\n**Lemma 19.11**: _The amortized cost of each Make-Set operation is \\(O(1)\\)._\n\n_Proof_ Suppose that the \\(q\\)th operation is Make-Set\\((x)\\). This operation creates node \\(x\\) with rank 0, so that \\(\\phi_{q}(x)=0\\). No other ranks or potentials change, and so \\(\\Phi_{q}=\\Phi_{q-1}\\). Noting that the actual cost of the Make-Set operation is \\(O(1)\\) completes the proof.\n\n**Lemma 19.12**: _The amortized cost of each Link operation is \\(O(\\alpha(n))\\)._\n\n_Proof_ Suppose that the \\(q\\)th operation is Link\\((x,y)\\). The actual cost of the Link operation is \\(O(1)\\). Without loss of generality, suppose that the Link makes \\(y\\) the parent of \\(x\\).\n\nTo determine the change in potential due to the Link, note that the only nodes whose potentials may change are \\(x\\), \\(y\\), and the children of \\(y\\) just prior to the operation. We'll show that the only node whose potential can increase due to the Link is \\(y\\), and that its increase is at most \\(\\alpha(n)\\):\n\n* By Lemma 19.10, any node that is \\(y\\)'s child just before the Link cannot have its potential increase due to the Link.\n* From the definition (19.7) of \\(\\phi_{q}(x)\\), note that, since \\(x\\) was a root just before the \\(q\\)th operation, \\(\\phi_{q-1}(x)=\\alpha(n)\\cdot x\\), \\(rank\\) at that time. If \\(x\\), \\(rank=0\\), then \\(\\phi_{q}(x)=\\phi_{q-1}(x)=0\\). Otherwise, \\[\\phi_{q}(x)\\!<\\!\\!\\alpha(n)\\quad\\cdot x\\,rank\\quad\\mbox{(by Corollary \\ref{eq:Link})}\\] \\[\\quad\\quad=\\;\\phi_{q-1}(x)\\;,\\] and so \\(x\\)'s potential decreases.\n* Because \\(y\\) is a root prior to the Link, \\(\\phi_{q-1}(y)=\\alpha(n)\\cdot y\\), \\(rank\\). After the Link operation, \\(y\\) remains a root, so that \\(y\\)'s potential still equals \\(\\alpha(n)\\) times its rank after the operation. The Link operation either leaves \\(y\\)'s rank alone or increases \\(y\\)'s rank by 1. Therefore, either \\(\\phi_{q}(y)=\\phi_{q-1}(y)\\) or \\(\\phi_{q}(y)=\\phi_{q-1}(y)+\\alpha(n)\\).\n\nThe increase in potential due to the Link operation, therefore, is at most \\(\\alpha(n)\\). The amortized cost of the Link operation is \\(O(1)+\\alpha(n)=O(\\alpha(n))\\).\n\n**Lemma 19.13**: _The amortized cost of each Find-Set operation is \\(O(\\alpha(n))\\)._\n\n_Proof_ Suppose that the \\(q\\)th operation is a Find-Set and that the find path contains \\(s\\) nodes. The actual cost of the Find-Set operation is \\(O(s)\\). We will show that no node's potential increases due to the Find-Set and that at least \\(\\max\\left\\{0,s-(\\alpha(n)+2)\\right\\}\\) nodes on the find path have their potential decrease by at least \\(1\\).\n\nWe first show that no node's potential increases. Lemma 19.10 takes care of all nodes other than the root. If \\(x\\) is the root, then its potential is \\(\\alpha(n)\\cdot x\\cdot rank\\), which does not change due to the Find-Set operation.\n\nNow we show that at least \\(\\max\\left\\{0,s-(\\alpha(n)+2)\\right\\}\\) nodes have their potential decrease by at least \\(1\\). Let \\(x\\) be a node on the find path such that \\(x\\cdot rank>0\\) and \\(x\\) is followed somewhere on the find path by another node \\(y\\) that is not a root, where \\(\\operatorname{level}(y)=\\operatorname{level}(x)\\) just before the Find-Set operation. (Node \\(y\\) need not _immediately_ follow \\(x\\) on the find path.) All but at most \\(\\alpha(n)+2\\) nodes on the find path satisfy these constraints on \\(x\\). Those that do not satisfy them are the first node on the find path (if it has rank \\(0\\)), the last node on the path (i.e., the root), and the last node \\(w\\) on the path for which \\(\\operatorname{level}(w)=k\\), for each \\(k=0,1,2,\\ldots,\\alpha(n)-1\\).\n\nConsider such a node \\(x\\). It has positive rank and is followed somewhere on the find path by nonroot node \\(y\\) such that \\(\\operatorname{level}(y)=\\operatorname{level}(x)\\) before the path compression occurs. We claim that the path compression decreases \\(x\\)'s potential by at least \\(1\\). To prove this claim, let \\(k=\\operatorname{level}(x)=\\operatorname{level}(y)\\) and \\(i=\\operatorname{iter}(x)\\) before the path compression occurs. Just prior to the path compression caused by the Find-Set, we have\n\n\\[x.p.rank \\geq A_{k}^{(i)}(x\\cdot rank)\\quad\\text{(by the definition (\\ref{eq:path compression}) of $\\operatorname{iter}(x)$)}\\,\\] \\[y.p.rank \\geq A_{k}(y\\cdot rank)\\quad\\text{(by the definition (\\ref{eq:path compression}) of $\\operatorname{level}(y)$)}\\,\\] \\[y.rank \\geq x.p.rank \\quad\\text{(by Corollary \\ref{eq:path compression} and because}\\] \\[y\\ \\text{follows $x$ on the find path)}\\.\\]\n\nPutting these inequalities together gives\n\n\\[y.p.rank \\geq A_{k}(y\\cdot rank)\\] \\[\\geq A_{k}(x.p.rank)\\qquad\\text{(because $A_{k}(j)$ is strictly increasing)}\\] \\[\\geq A_{k}(A_{k}^{(i)}(x\\cdot rank))\\] \\[= A_{k}^{(i+1)}(x\\cdot rank)\\qquad\\text{(by the definition (\\ref{eq:path compression}) of functional iteration)}\\.\\]Because path compression makes \\(x\\) and \\(y\\) have the same parent, after path compression we have \\(x.p.rank=y.p.rank\\). The parent of \\(y\\) might change due to the path compression, but if it does, the rank of \\(y\\)'s new parent compared with the rank of \\(y\\)'s parent before path compression is either the same or greater. Since \\(x.rank\\) does not change, \\(x.p.rank=y.p.rank\\geq A_{k}^{(i+1)}(x.rank)\\) after path compression. By the definition (19.5) of the iter function, the value of \\(\\operatorname{iter}(x)\\) increases from \\(i\\) to at least \\(i+1\\). By Lemma 19.10, \\(\\phi_{q}(x)\\leq\\phi_{q-1}(x)-1\\), so that \\(x\\)'s potential decreases by at least \\(1\\).\n\nThe amortized cost of the Find-Set operation is the actual cost plus the change in potential. The actual cost is \\(O(s)\\), and we have shown that the total potential decreases by at least \\(\\max\\{0,s-(\\alpha(n)+2)\\}\\). The amortized cost, therefore, is at most \\(O(s)-(s-(\\alpha(n)+2))=O(s)-s+O(\\alpha(n))=O(\\alpha(n))\\), since we can scale up the units of potential to dominate the constant hidden in \\(O(s)\\). (See Exercise 19.4-6.) \n\nPutting the preceding lemmas together yields the following theorem.\n\n**Theorem 19.14**: _A sequence of \\(m\\) Make-Set, Union, and Find-Set operations, \\(n\\) of which are Make-Set operations, can be performed on a disjoint-set forest with union by rank and path compression in \\(O(m\\,\\alpha(n))\\) time._\n\n_Proof_ Immediate from Lemmas 19.7, 19.11, 19.12, and 19.13. \n\n**Exercises**\n\n_19.4-1_\n\nProve Lemma 19.4.\n\n_19.4-2_\n\nProve that every node has rank at most \\(\\lfloor\\lg n\\rfloor\\).\n\n_19.4-3_\n\nIn light of Exercise 19.4-2, how many bits are necessary to store \\(x.rank\\) for each node \\(x\\)?\n\n_19.4-4_\n\nUsing Exercise 19.4-2, give a simple proof that operations on a disjoint-set forest with union by rank but without path compression run in \\(O(m\\lg n)\\) time.\n\n_19.4-5_\n\nProfessor Dante reasons that because node ranks increase strictly along a simple path to the root, node levels must monotonically increase along the path. In other words, if \\(x\\). _rank_\\(>0\\) and \\(x\\). \\(p\\) is not a root, then \\(\\operatorname{level}(x)\\leq\\operatorname{level}(x\\). _p_). Is the professor correct?\n\n_19.4-6_\n\nThe proof of Lemma 19.13 ends with scaling the units of potential to dominate the constant hidden in the \\(O(s)\\) term. To be more precise in the proof, you need to change the definition (19.7) of the potential function to multiply each of the two cases by a constant, say \\(c\\), that dominates the constant in the \\(O(s)\\) term. How must the rest of the analysis change to accommodate this updated potential function?\n\n_19.4-7_\n\nConsider the function \\(\\alpha^{\\prime}(n)=\\min\\left\\{k:A_{k}(1)\\geq\\lg(n+1)\\right\\}\\). Show that \\(\\alpha^{\\prime}(n)\\leq 3\\) for all practical values of \\(n\\) and, using Exercise 19.4-2, show how to modify the potential-function argument to prove that performing a sequence of \\(m\\) Make-Set, Union, and Find-Set operations, \\(n\\) of which are Make-Set operations, on a disjoint-set forest with union by rank and path compression takes \\(O(m\\alpha^{\\prime}(n))\\) time.\n\n**Problems**\n\n_19-1 Offline minimum_\n\nIn the _offline minimum problem_, you maintain a dynamic set \\(T\\) of elements from the domain \\(\\left\\{1,2,\\ldots,n\\right\\}\\) under the operations Insert and Extract-Min. The input is a sequence \\(S\\) of \\(n\\) Insert and \\(m\\) Extract-Min calls, where each key in \\(\\left\\{1,2,\\ldots,n\\right\\}\\) is inserted exactly once. Your goal is to determine which key is returned by each Extract-Min call. Specifically, you must fill in an array _extracted_\\(\\left[1:m\\right]\\), where for \\(i=1,2,\\ldots,m\\), _extracted_\\(\\left[i\\right]\\) is the key returned by the \\(i\\)th Extract-Min call. The problem is \"offline\" in the sense that you are allowed to process the entire sequence \\(S\\) before determining any of the returned keys.\n\n_a._ Consider the following instance of the offline minimum problem, in which each operation Insert(\\(i\\)) is represented by the value of \\(i\\) and each Extract-Min is represented by the letter E:\n\n\\[4,8,\\text{E},3,\\text{E},9,2,6,\\text{E},\\text{E},\\text{E},1,7,\\text{E},5\\.\\]\n\nFill in the correct values in the _extracted_ array.",
        "chapter": "Part V Advanced Data Structures",
        "section": "19 Data Structures for Disjoint Sets",
        "subsection": "19.4 Analysis of union by rank with path compression",
        "subsubsection": "N/A"
    },
    {
        "content": "_19.4-5_\n\nProfessor Dante reasons that because node ranks increase strictly along a simple path to the root, node levels must monotonically increase along the path. In other words, if \\(x\\). _rank_\\(>0\\) and \\(x\\). \\(p\\) is not a root, then \\(\\operatorname{level}(x)\\leq\\operatorname{level}(x\\). _p_). Is the professor correct?\n\n_19.4-6_\n\nThe proof of Lemma 19.13 ends with scaling the units of potential to dominate the constant hidden in the \\(O(s)\\) term. To be more precise in the proof, you need to change the definition (19.7) of the potential function to multiply each of the two cases by a constant, say \\(c\\), that dominates the constant in the \\(O(s)\\) term. How must the rest of the analysis change to accommodate this updated potential function?\n\n_19.4-7_\n\nConsider the function \\(\\alpha^{\\prime}(n)=\\min\\left\\{k:A_{k}(1)\\geq\\lg(n+1)\\right\\}\\). Show that \\(\\alpha^{\\prime}(n)\\leq 3\\) for all practical values of \\(n\\) and, using Exercise 19.4-2, show how to modify the potential-function argument to prove that performing a sequence of \\(m\\) Make-Set, Union, and Find-Set operations, \\(n\\) of which are Make-Set operations, on a disjoint-set forest with union by rank and path compression takes \\(O(m\\alpha^{\\prime}(n))\\) time.\n\n**Problems**\n\n_19-1 Offline minimum_\n\nIn the _offline minimum problem_, you maintain a dynamic set \\(T\\) of elements from the domain \\(\\left\\{1,2,\\ldots,n\\right\\}\\) under the operations Insert and Extract-Min. The input is a sequence \\(S\\) of \\(n\\) Insert and \\(m\\) Extract-Min calls, where each key in \\(\\left\\{1,2,\\ldots,n\\right\\}\\) is inserted exactly once. Your goal is to determine which key is returned by each Extract-Min call. Specifically, you must fill in an array _extracted_\\(\\left[1:m\\right]\\), where for \\(i=1,2,\\ldots,m\\), _extracted_\\(\\left[i\\right]\\) is the key returned by the \\(i\\)th Extract-Min call. The problem is \"offline\" in the sense that you are allowed to process the entire sequence \\(S\\) before determining any of the returned keys.\n\n_a._ Consider the following instance of the offline minimum problem, in which each operation Insert(\\(i\\)) is represented by the value of \\(i\\) and each Extract-Min is represented by the letter E:\n\n\\[4,8,\\text{E},3,\\text{E},9,2,6,\\text{E},\\text{E},\\text{E},1,7,\\text{E},5\\.\\]\n\nFill in the correct values in the _extracted_ array.\n\nTo develop an algorithm for this problem, break the sequence \\(S\\) into homogeneous subsequences. That is, represent \\(S\\) by\n\n\\[\\mathrm{I}_{1},\\mathrm{E},\\mathrm{I}_{2},\\mathrm{E},\\mathrm{I}_{3},\\ldots, \\mathrm{I}_{m},\\mathrm{E},\\mathrm{I}_{m+1}\\,\\]\n\nwhere each \\(\\mathrm{E}\\) represents a single Extract-Min call and each \\(\\mathrm{I}_{j}\\) represents a (possibly empty) sequence of Insert calls. For each subsequence \\(\\mathrm{I}_{j}\\), initially place the keys inserted by these operations into a set \\(K_{j}\\), which is empty if \\(\\mathrm{I}_{j}\\) is empty. Then execute the Offline-Minimum procedure.\n\n```\nOffline-Minimum(\\(m,n\\))\n1for\\(i=1\\)to\\(n\\)\n2determine\\(j\\)such that \\(i\\in K_{j}\\)\n3if\\(j\\neq m+1\\)\n4extracted\\([j]=i\\)\n5let\\(l\\)be the smallest value greater than \\(j\\)for which set \\(K_{l}\\) exists\n6\\(K_{l}=K_{j}\\cup K_{l}\\), destroying \\(K_{j}\\)\n7returnextracted\n```\n\n_b._Argue that the array _extracted_ returned by Offline-Minimum is correct.\n\n_c._Describe how to implement Offline-Minimum efficiently with a disjoint-set data structure. Give as tight a bound as you can on the worst-case running time of your implementation.\n\n_19-2 Depth determination_\n\nIn the _depth-determination problem_, you maintain a forest \\(\\mathcal{F}=\\{T_{i}\\}\\) of rooted trees under three operations:\n\n``` Make-Tree(\\(v\\))creates a tree whose only node is \\(v\\). Find-Depth(\\(v\\))returns the depth of node \\(v\\)within its tree. Graft(\\(r,v\\))makes node \\(r\\), which is assumed to be the root of a tree, become the child of node \\(v\\), which is assumed to be in a different tree from \\(r\\) but may or may not itself be a root.\n\n_a._Suppose that you use a tree representation similar to a disjoint-set forest: \\(v.p\\) is the parent of node \\(v\\), except that \\(v.p=v\\) if \\(v\\) is a root. Suppose further that you implement Graft(\\(r,v\\)) by setting \\(r.p=v\\) and Find-Depth(\\(v\\)) by following the find path from \\(v\\) up to the root, returning a count of all nodes other than \\(v\\) encountered. Show that the worst-case running time of a sequence of \\(m\\) Make-Tree, Find-Depth, and Graft operations is \\(\\Theta(m^{2})\\).\n\nBy using the union-by-rank and path-compression heuristics, you can reduce the worst-case running time. Use the disjoint-set forest \\(\\mathcal{S}=\\{S_{i}\\}\\), where each set \\(S_{i}\\) (which is itself a tree) corresponds to a tree \\(T_{i}\\) in the forest \\(\\mathcal{F}\\). The tree structure within a set \\(S_{i}\\), however, does not necessarily correspond to that of \\(T_{i}\\). In fact, the implementation of \\(S_{i}\\) does not record the exact parent-child relationships but nevertheless allows you to determine any node's depth in \\(T_{i}\\).\n\nThe key idea is to maintain in each node \\(v\\) a \"pseudodistance\" \\(v.d\\), which is defined so that the sum of the pseudodistances along the simple path from \\(v\\) to the root of its set \\(S_{i}\\) equals the depth of \\(v\\) in \\(T_{i}\\). That is, if the simple path from \\(v\\) to its root in \\(S_{i}\\) is \\(v_{0},v_{1},\\ldots,v_{k}\\), where \\(v_{0}=v\\) and \\(v_{k}\\) is \\(S_{i}\\)'s root, then the depth of \\(v\\) in \\(T_{i}\\) is \\(\\sum_{j=0}^{k}v_{j}.d\\).\n\n_b._: Give an implementation of Make-Tree.\n\n_c._: Show how to modify Find-Set to implement Find-Depth. Your implementation should perform path compression, and its running time should be linear in the length of the find path. Make sure that your implementation updates pseudodistances correctly.\n\n_d._: Show how to implement Graft(\\(r,v\\)), which combines the sets containing \\(r\\) and \\(v\\), by modifying the Union and Link procedures. Make sure that your implementation updates pseudodistances correctly. Note that the root of a set \\(S_{i}\\) is not necessarily the root of the corresponding tree \\(T_{i}\\).\n\n_e._: Give a tight bound on the worst-case running time of a sequence of \\(m\\) Make-Tree, Find-Depth, and Graft operations, \\(n\\) of which are Make-Tree operations.\n\n_19-3 Tarjan's offline lowest-common-ancestors algorithm_\n\nThe _lowest common ancestor_ of two nodes \\(u\\) and \\(v\\) in a rooted tree \\(T\\) is the node \\(w\\) that is an ancestor of both \\(u\\) and \\(v\\) and that has the greatest depth in \\(T\\). In the _offline lowest-common-ancestors problem_, you are given a rooted tree \\(T\\) and an arbitrary set \\(P=\\{\\{u,v\\}\\}\\) of unordered pairs of nodes in \\(T\\), and you wish to determine the lowest common ancestor of each pair in \\(P\\).\n\nTo solve the offline lowest-common-ancestors problem, the LCA procedure on the following page performs a tree walk of \\(T\\) with the initial call LCA(\\(T.root\\)). Assume that each node is colored white prior to the walk.\n\n_a._: Argue that line 10 executes exactly once for each pair \\(\\{u,v\\}\\in P\\).\n\n_b._: Argue that at the time of the call LCA(\\(u\\)), the number of sets in the disjoint-set data structure equals the depth of \\(u\\) in \\(T\\).\n\n#### 1.4.3 Data Structures for Disjoint Sets\n\n#### 1.4.4 Data Structures for Disjoint Sets\n\nThe first two columns of the table are the \"\\(\\operatorname{LCA}(u)\\)\" and \"\\(\\operatorname{LCA}(v)\\)\". The first column of the table is the \"\\(\\operatorname{LCA}(u)\\)\". The second column of the table is the \"\\(\\operatorname{LCA}(v)\\)\". The second column of the table is the \"\\(\\operatorname{LCA}(v)\\)\". The second column of the table is the \"\\(\\operatorname{LCA}(v)\\)\". The third column of the table is the \"\\(\\operatorname{LCA}(v)\\)\".",
        "chapter": "Part V Advanced Data Structures",
        "section": "19 Data Structures for Disjoint Sets",
        "subsection": "Problems",
        "subsubsection": "N/A"
    },
    {
        "content": "[MISSING_PAGE_EMPTY:1]\n\nsame asymptotic running time as union by rank. Gabow and Tarjan [166] show that in certain applications, the disjoint-set operations can be made to run in \\(\\,O(m)\\) time.\n\nTarjan [428] showed that a lower bound of \\(\\Omega(m\\;\\widehat{\\alpha}(m,n))\\) time is required for operations on any disjoint-set data structure satisfying certain technical conditions. This lower bound was later generalized by Fredman and Saks [155], who showed that in the worst case, \\(\\Omega(m\\widehat{\\alpha}(m,n))\\) (\\(\\lg n\\))-bit words of memory must be accessed.",
        "chapter": "Part V Advanced Data Structures",
        "section": "19 Data Structures for Disjoint Sets",
        "subsection": "Chapter notes",
        "subsubsection": "N/A"
    },
    {
        "content": "## Introduction\n\nGraph problems pervade computer science, and algorithms for working with them are fundamental to the field. Hundreds of interesting computational problems are couched in terms of graphs. This part touches on a few of the more significant ones.\n\nChapter 20 shows how to represent a graph in a computer and then discusses algorithms based on searching a graph using either breadth-first search or depth-first search. The chapter gives two applications of depth-first search: topologically sorting a directed acyclic graph and decomposing a directed graph into its strongly connected components.\n\nChapter 21 describes how to compute a minimum-weight spanning tree of a graph: the least-weight way of connecting all of the vertices together when each edge has an associated weight. The algorithms for computing minimum spanning trees serve as good examples of greedy algorithms (see Chapter 15).\n\nChapters 22 and 23 consider how to compute shortest paths between vertices when each edge has an associated length or \"weight.\" Chapter 22 shows how to find shortest paths from a given source vertex to all other vertices, and Chapter 23 examines methods to compute shortest paths between every pair of vertices.\n\nChapter 24 shows how to compute a maximum flow of material in a flow network, which is a directed graph having a specified source vertex of material, a specified sink vertex, and specified capacities for the amount of material that can traverse each directed edge. This general problem arises in many forms, and a good algorithm for computing maximum flows can help solve a variety of related problems efficiently.\n\nFinally, Chapter 25 explores matchings in bipartite graphs: methods for pairing up vertices that are partitioned into two sets by selecting edges that go between the sets. Bipartite-matching problems model several situations that arise in the real world. The chapter examines how to find a matching of maximum cardinality; the\"stable-marriage problem,\" which has the highly practical application of matching medical residents to hospitals; and assignment problems, which maximize the total weight of a bipartite matching.\n\nWhen we characterize the running time of a graph algorithm on a given graph \\(G=(V,E)\\), we usually measure the size of the input in terms of the number of vertices \\(|V|\\) and the number of edges \\(|E|\\) of the graph. That is, we denote the size of the input with two parameters, not just one. We adopt a common notational convention for these parameters. Inside asymptotic notation (such as \\(O\\)-notation or \\(\\Theta\\)-notation), and _only_ inside such notation, the symbol \\(V\\) denotes \\(|V|\\) and the symbol \\(E\\) denotes \\(|E|\\). For example, we might say, \"the algorithm runs in \\(O(VE)\\) time,\" meaning that the algorithm runs in \\(O(|V|\\,|E|)\\) time. This convention makes the running-time formulas easier to read, without risk of ambiguity.\n\nAnother convention we adopt appears in pseudocode. We denote the vertex set of a graph \\(G\\) by \\(G\\). \\(V\\) and its edge set by \\(G\\). \\(E\\). That is, the pseudocode views vertex and edge sets as attributes of a graph.\n\n## Chapter 2 Elementary Graph Algorithms\n\nThis chapter presents methods for representing a graph and for searching a graph. Searching a graph means systematically following the edges of the graph so as to visit the vertices of the graph. A graph-searching algorithm can discover much about the structure of a graph. Many algorithms begin by searching their input graph to obtain this structural information. Several other graph algorithms elaborate on basic graph searching. Techniques for searching a graph lie at the heart of the field of graph algorithms.\n\nSection 20.1 discusses the two most common computational representations of graphs: as adjacency lists and as adjacency matrices. Section 20.2 presents a simple graph-searching algorithm called breadth-first search and shows how to create a breadth-first tree. Section 20.3 presents depth-first search and proves some standard results about the order in which depth-first search visits vertices. Section 20.4 provides our first real application of depth-first search: topologically sorting a directed acyclic graph. A second application of depth-first search, finding the strongly connected components of a directed graph, is the topic of Section 20.5.\n\n### Representations of graphs\n\nYou can choose between two standard ways to represent a graph \\(G=(V,E)\\): as a collection of adjacency lists or as an adjacency matrix. Either way applies to both directed and undirected graphs. Because the adjacency-list representation provides a compact way to represent _sparse_ graphs--those for which \\(\\left|E\\right|\\) is much less than \\(\\left|V\\right|^{2}\\)--it is usually the method of choice. Most of the graph algorithms presented in this book assume that an input graph is represented in adjacency-list form. You might prefer an adjacency-matrix representation, however, when the graph is _dense_--\\(\\left|E\\right|\\) is close to \\(\\left|V\\right|^{2}\\)--or when you need to be able to tell quickly whether there is an edge connecting two given vertices. For example, two of the",
        "chapter": "Part VI Graph Algorithms",
        "section": "Introduction",
        "subsection": "N/A",
        "subsubsection": "N/A"
    },
    {
        "content": "## Chapter 2 Elementary Graph Algorithms\n\nThis chapter presents methods for representing a graph and for searching a graph. Searching a graph means systematically following the edges of the graph so as to visit the vertices of the graph. A graph-searching algorithm can discover much about the structure of a graph. Many algorithms begin by searching their input graph to obtain this structural information. Several other graph algorithms elaborate on basic graph searching. Techniques for searching a graph lie at the heart of the field of graph algorithms.\n\nSection 20.1 discusses the two most common computational representations of graphs: as adjacency lists and as adjacency matrices. Section 20.2 presents a simple graph-searching algorithm called breadth-first search and shows how to create a breadth-first tree. Section 20.3 presents depth-first search and proves some standard results about the order in which depth-first search visits vertices. Section 20.4 provides our first real application of depth-first search: topologically sorting a directed acyclic graph. A second application of depth-first search, finding the strongly connected components of a directed graph, is the topic of Section 20.5.\n\n### Representations of graphs\n\nYou can choose between two standard ways to represent a graph \\(G=(V,E)\\): as a collection of adjacency lists or as an adjacency matrix. Either way applies to both directed and undirected graphs. Because the adjacency-list representation provides a compact way to represent _sparse_ graphs--those for which \\(\\left|E\\right|\\) is much less than \\(\\left|V\\right|^{2}\\)--it is usually the method of choice. Most of the graph algorithms presented in this book assume that an input graph is represented in adjacency-list form. You might prefer an adjacency-matrix representation, however, when the graph is _dense_--\\(\\left|E\\right|\\) is close to \\(\\left|V\\right|^{2}\\)--or when you need to be able to tell quickly whether there is an edge connecting two given vertices. For example, two of theall-pairs shortest-paths algorithms presented in Chapter 23 assume that their input graphs are represented by adjacency matrices.\n\nThe _adjacency-list representation_ of a graph \\(G=(V,E)\\) consists of an array \\(Adj\\) of \\(|V|\\) lists, one for each vertex in \\(V\\). For each \\(u\\in V\\), the adjacency list \\(Adj[u]\\) contains all the vertices \\(v\\) such that there is an edge \\((u,v)\\in E\\). That is, \\(Adj[u]\\) consists of all the vertices adjacent to \\(u\\) in \\(G\\). (Alternatively, it can contain pointers to these vertices.) Since the adjacency lists represent the edges of a graph, our pseudocode treats the array \\(Adj\\) as an attribute of the graph, just like the edge set \\(E\\). In pseudocode, therefore, you will see notation such as \\(G.Adj[u]\\). Figure 20.1(b) is an adjacency-list representation of the undirected graph in Figure 20.1(a). Similarly, Figure 20.2(b) is an adjacency-list representation of the directed graph in Figure 20.2(a).\n\nIf \\(G\\) is a directed graph, the sum of the lengths of all the adjacency lists is \\(|E|\\), since an edge of the form \\((u,v)\\) is represented by having \\(v\\) appear in \\(Adj[u]\\). If \\(G\\) is\n\nFigure 20.2: Two representations of a directed graph. **(a)** A directed graph \\(G\\) with 6 vertices and 8 edges. **(b)** An adjacency-list representation of \\(G\\). **(c)** The adjacency-matrix representation of \\(G\\).\n\nFigure 20.1: Two representations of an undirected graph. **(a)** An undirected graph \\(G\\) with 5 vertices and 7 edges. **(b)** An adjacency-list representation of \\(G\\). **(c)** The adjacency-matrix representation of \\(G\\).\n\nan undirected graph, the sum of the lengths of all the adjacency lists is \\(2\\,|\\,E|\\), since if \\((u,v)\\) is an undirected edge, then \\(u\\) appears in \\(v\\)'s adjacency list and vice versa. For both directed and undirected graphs, the adjacency-list representation has the desirable property that the amount of memory it requires is \\(\\Theta(V+E)\\). Finding each edge in the graph also takes \\(\\Theta(V+E)\\) time, rather than just \\(\\Theta(E)\\), since each of the \\(|V|\\) adjacency lists must be examined. Of course, if \\(|E|=\\Omega(\\mathcal{V})\\) -- such as in a connected, undirected graph or a strongly connected, directed graph--we can say that finding each edge takes \\(\\Theta(E)\\) time.\n\nAdjacency lists can also represent _weighted graphs_, that is, graphs for which each edge has an associated _weight_ given by a _weight function_\\(w:E\\to\\mathbb{R}\\). For example, let \\(G=(V,E)\\) be a weighted graph with weight function \\(w\\). Then you can simply store the weight \\(w(u,v)\\) of the edge \\((u,v)\\in E\\) with vertex \\(v\\) in \\(u\\)'s adjacency list. The adjacency-list representation is quite robust in that you can modify it to support many other graph variants.\n\nA potential disadvantage of the adjacency-list representation is that it provides no quicker way to determine whether a given edge \\((u,v)\\) is present in the graph than to search for \\(v\\) in the adjacency list \\(Adj[u]\\). An adjacency-matrix representation of the graph remedies this disadvantage, but at the cost of using asymptotically more memory. (See Exercise 20.1-8 for suggestions of variations on adjacency lists that permit faster edge lookup.)\n\nThe _adjacency-matrix representation_ of a graph \\(G=(V,E)\\) assumes that the vertices are numbered \\(1,2,\\ldots,|V|\\) in some arbitrary manner. Then the adjacency-matrix representation of a graph \\(G\\) consists of a \\(|V|\\times|V|\\) matrix \\(A=(a_{ij})\\) such that\n\n\\[a_{ij}=\\left\\{\\begin{array}{ll}1&\\mbox{if $(i,j)\\in E$ },\\\\ 0&\\mbox{otherwise }.\\end{array}\\right.\\]\n\nFigures 20.1(c) and 20.2(c) are the adjacency matrices of the undirected and directed graphs in Figures 20.1(a) and 20.2(a), respectively. The adjacency matrix of a graph requires \\(\\Theta(V^{2})\\) memory, independent of the number of edges in the graph. Because finding each edge in the graph requires examining the entire adjacency matrix, doing so takes \\(\\Theta(V^{2})\\) time.\n\nObserve the symmetry along the main diagonal of the adjacency matrix in Figure 20.1(c). Since in an undirected graph, \\((u,v)\\) and \\((v,u)\\) represent the same edge, the adjacency matrix \\(A\\) of an undirected graph is its own transpose: \\(A=A^{\\mathrm{T}}\\). In some applications, it pays to store only the entries on and above the diagonal of the adjacency matrix, thereby cutting the memory needed to store the graph almost in half.\n\nLike the adjacency-list representation of a graph, an adjacency matrix can represent a weighted graph. For example, if \\(G=(V,E)\\) is a weighted graph with edge-weight function \\(w\\), you can store the weight \\(w(u,v)\\) of the edge \\((u,v)\\in E\\)as the entry in row \\(u\\) and column \\(v\\) of the adjacency matrix. If an edge does not exist, you can store a nil value as its corresponding matrix entry, though for many problems it is convenient to use a value such as 0 or \\(\\infty\\).\n\nAlthough the adjacency-list representation is asymptotically at least as space-efficient as the adjacency-matrix representation, adjacency matrices are simpler, and so you might prefer them when graphs are reasonably small. Moreover, adjacency matrices carry a further advantage for unweighted graphs: they require only one bit per entry.\n\n##### Representing attributes\n\nMost algorithms that operate on graphs need to maintain attributes for vertices and/or edges. We indicate these attributes using our usual notation, such as \\(v.d\\) for an attribute \\(d\\) of a vertex \\(v\\). When we indicate edges as pairs of vertices, we use the same style of notation. For example, if edges have an attribute \\(f\\), then we denote this attribute for edge \\((u,v)\\) by \\((u,v).f\\). For the purpose of presenting and understanding algorithms, our attribute notation suffices.\n\nImplementing vertex and edge attributes in real programs can be another story entirely. There is no one best way to store and access vertex and edge attributes. For a given situation, your decision will likely depend on the programming language you are using, the algorithm you are implementing, and how the rest of your program uses the graph. If you represent a graph using adjacency lists, one design choice is to represent vertex attributes in additional arrays, such as an array \\(d\\left[1:|V|\\right]\\) that parallels the _Adj_ array. If the vertices adjacent to \\(u\\) belong to \\(Adj[u]\\), then the attribute \\(u.d\\) can actually be stored in the array entry \\(d\\left[u\\right]\\). Many other ways of implementing attributes are possible. For example, in an object-oriented programming language, vertex attributes might be represented as instance variables within a subclass of a Vertex class.\n\n##### Exercises\n\n##### 20.1-1\n\nGiven an adjacency-list representation of a directed graph, how long does it take to compute the out-degree of every vertex? How long does it take to compute the in-degrees?\n\n##### 20.1-2\n\nGive an adjacency-list representation for a complete binary tree on 7 vertices. Give an equivalent adjacency-matrix representation. Assume that the edges are undirected and that the vertices are numbered from 1 to 7 as in a binary heap.\n\n### 20.1 Representations of graphs\n\nThe _transpose_ of a directed graph \\(G=(V,E)\\) is the graph \\(G^{\\rm T}=(V,E^{\\rm T})\\), where \\(E^{\\rm T}=\\{(v,u)\\in V\\times V:(u,v)\\in E\\}\\). That is, \\(G^{\\rm T}\\) is \\(G\\) with all its edges reversed. Describe efficient algorithms for computing \\(G^{\\rm T}\\) from \\(G\\), for both the adjacency-list and adjacency-matrix representations of \\(G\\). Analyze the running times of your algorithms.\n\n### 20.1-4\n\nGiven an adjacency-list representation of a multigraph \\(G=(V,E)\\), describe an \\(O(V+E)\\)-time algorithm to compute the adjacency-list representation of the \"equivalent\" undirected graph \\(G^{\\prime}=(V,E^{\\prime})\\), where \\(E^{\\prime}\\) consists of the edges in \\(E\\) with all multiple edges between two vertices replaced by a single edge and with all self-loops removed.\n\n### 20.1-5\n\nThe _square_ of a directed graph \\(G=(V,E)\\) is the graph \\(G^{2}=(V,E^{2})\\) such that \\((u,v)\\in E^{2}\\) if and only if \\(G\\) contains a path with at most two edges between \\(u\\) and \\(v\\). Describe efficient algorithms for computing \\(G^{2}\\) from \\(G\\) for both the adjacency-list and adjacency-matrix representations of \\(G\\). Analyze the running times of your algorithms.\n\n### 20.1-6\n\nMost graph algorithms that take an adjacency-matrix representation as input require \\(\\Omega(V^{2})\\) time, but there are some exceptions. Show how to determine whether a directed graph \\(G\\) contains a _universal sink_ -- a vertex with in-degree \\(|V|-1\\) and out-degree \\(0\\)-- in \\(O(V)\\) time, given an adjacency matrix for \\(G\\).\n\n### 20.1-7\n\nThe _incidence matrix_ of a directed graph \\(G=(V,E)\\) with no self-loops is a \\(|V|\\times|E|\\) matrix \\(B=(b_{ij})\\) such that\n\n\\[b_{ij}=\\left\\{\\begin{array}{ll}-1&\\mbox{if edge $j$ leaves vertex $i$ }\\;,\\\\ 1&\\mbox{if edge $j$ enters vertex $i$ }\\;,\\\\ 0&\\mbox{otherwise }.\\end{array}\\right.\\]\n\nDescribe what the entries of the matrix product \\(BB^{\\rm T}\\) represent, where \\(B^{\\rm T}\\) is the transpose of \\(B\\).\n\n### 20.1-8\n\nSuppose that instead of a linked list, each array entry \\(Adj[u]\\) is a hash table containing the vertices \\(v\\) for which \\((u,v)\\in E\\), with collisions resolved by chaining. Under the assumption of uniform independent hashing, if all edge lookups are equally likely, what is the expected time to determine whether an edge is in the graph?What disadvantages does this scheme have? Suggest an alternate data structure for each edge list that solves these problems. Does your alternative have disadvantages compared with the hash table?\n\n### 20.2 Breadth-first search\n\n_Breadth-first search_ is one of the simplest algorithms for searching a graph and the archetype for many important graph algorithms. Prim's minimum-spanning-tree algorithm (Section 21.2) and Dijkstra's single-source shortest-paths algorithm (Section 22.3) use ideas similar to those in breadth-first search.\n\nGiven a graph \\(G=(V,E)\\) and a distinguished _source_ vertex \\(s\\), breadth-first search systematically explores the edges of \\(G\\) to \"discover\" every vertex that is reachable from \\(s\\). It computes the distance from \\(s\\) to each reachable vertex, where the distance to a vertex \\(v\\) equals the smallest number of edges needed to go from \\(s\\) to \\(v\\). Breadth-first search also produces a \"breadth-first tree\" with root \\(s\\) that contains all reachable vertices. For any vertex \\(v\\) reachable from \\(s\\), the simple path in the breadth-first tree from \\(s\\) to \\(v\\) corresponds to a shortest path from \\(s\\) to \\(v\\) in \\(G\\), that is, a path containing the smallest number of edges. The algorithm works on both directed and undirected graphs.\n\nBreadth-first search is so named because it expands the frontier between discovered and undiscovered vertices uniformly across the breadth of the frontier. You can think of it as discovering vertices in waves emanating from the source vertex. That is, starting from \\(s\\), the algorithm first discovers all neighbors of \\(s\\), which have distance 1. Then it discovers all vertices with distance 2, then all vertices with distance 3, and so on, until it has discovered every vertex reachable from \\(s\\).\n\nIn order to keep track of the waves of vertices, breadth-first search could maintain separate arrays or lists of the vertices at each distance from the source vertex. Instead, it uses a single first-in, first-out queue (see Section 10.1.3) containing some vertices at a distance \\(k\\), possibly followed by some vertices at distance \\(k\\)\\(+\\) 1. The queue, therefore, contains portions of two consecutive waves at any time.\n\nTo keep track of progress, breadth-first search colors each vertex white, gray, or black. All vertices start out white, and vertices not reachable from the source vertex \\(s\\) stay white the entire time. A vertex that is reachable from \\(s\\) is _discovered_ the first time it is encountered during the search, at which time it becomes gray, indicating that is now on the frontier of the search: the boundary between discovered and undiscovered vertices. The queue contains all the gray vertices. Eventually, all the edges of a gray vertex will be explored, so that all of its neighbors will be",
        "chapter": "Part VI Graph Algorithms",
        "section": "20 Elementary Graph Algorithms",
        "subsection": "20.1 Representations of graphs",
        "subsubsection": "N/A"
    },
    {
        "content": "What disadvantages does this scheme have? Suggest an alternate data structure for each edge list that solves these problems. Does your alternative have disadvantages compared with the hash table?\n\n### 20.2 Breadth-first search\n\n_Breadth-first search_ is one of the simplest algorithms for searching a graph and the archetype for many important graph algorithms. Prim's minimum-spanning-tree algorithm (Section 21.2) and Dijkstra's single-source shortest-paths algorithm (Section 22.3) use ideas similar to those in breadth-first search.\n\nGiven a graph \\(G=(V,E)\\) and a distinguished _source_ vertex \\(s\\), breadth-first search systematically explores the edges of \\(G\\) to \"discover\" every vertex that is reachable from \\(s\\). It computes the distance from \\(s\\) to each reachable vertex, where the distance to a vertex \\(v\\) equals the smallest number of edges needed to go from \\(s\\) to \\(v\\). Breadth-first search also produces a \"breadth-first tree\" with root \\(s\\) that contains all reachable vertices. For any vertex \\(v\\) reachable from \\(s\\), the simple path in the breadth-first tree from \\(s\\) to \\(v\\) corresponds to a shortest path from \\(s\\) to \\(v\\) in \\(G\\), that is, a path containing the smallest number of edges. The algorithm works on both directed and undirected graphs.\n\nBreadth-first search is so named because it expands the frontier between discovered and undiscovered vertices uniformly across the breadth of the frontier. You can think of it as discovering vertices in waves emanating from the source vertex. That is, starting from \\(s\\), the algorithm first discovers all neighbors of \\(s\\), which have distance 1. Then it discovers all vertices with distance 2, then all vertices with distance 3, and so on, until it has discovered every vertex reachable from \\(s\\).\n\nIn order to keep track of the waves of vertices, breadth-first search could maintain separate arrays or lists of the vertices at each distance from the source vertex. Instead, it uses a single first-in, first-out queue (see Section 10.1.3) containing some vertices at a distance \\(k\\), possibly followed by some vertices at distance \\(k\\)\\(+\\) 1. The queue, therefore, contains portions of two consecutive waves at any time.\n\nTo keep track of progress, breadth-first search colors each vertex white, gray, or black. All vertices start out white, and vertices not reachable from the source vertex \\(s\\) stay white the entire time. A vertex that is reachable from \\(s\\) is _discovered_ the first time it is encountered during the search, at which time it becomes gray, indicating that is now on the frontier of the search: the boundary between discovered and undiscovered vertices. The queue contains all the gray vertices. Eventually, all the edges of a gray vertex will be explored, so that all of its neighbors will be discovered. Once all of a vertex's edges have been explored, the vertex is behind the frontier of the search, and it goes from gray to black.1\n\nFootnote 1: We distinguish between gray and black vertices to help us understand how breadth-first search operates. In fact, as Exercise 20.2-3 shows, we get the same result even if we do not distinguish between gray and black vertices.\n\nBreadth-first search constructs a breadth-first tree, initially containing only its root, which is the source vertex \\(s\\). Whenever the search discovers a white vertex \\(v\\) in the course of scanning the adjacency list of a gray vertex \\(u\\), the vertex \\(v\\) and the edge \\((u,v)\\) are added to the tree. We say that \\(u\\) is the _predecessor_ or _parent_ of \\(v\\) in the breadth-first tree. Since every vertex reachable from \\(s\\) is discovered at most once, each vertex reachable from \\(s\\) has exactly one parent. (There is one exception: because \\(s\\) is the root of the breadth-first tree, it has no parent.) Ancestor and descendant relationships in the breadth-first tree are defined relative to the root \\(s\\) as usual: if \\(u\\) is on the simple path in the tree from the root \\(s\\) to vertex \\(v\\), then \\(u\\) is an ancestor of \\(v\\) and \\(v\\) is a descendant of \\(u\\).\n\nThe breadth-first-search procedure BFS on the following page assumes that the graph \\(G=(V,E)\\) is represented using adjacency lists. It denotes the queue by \\(Q\\), and it attaches three additional attributes to each vertex \\(v\\) in the graph:\n\n* \\(v.\\mathit{color}\\) is the color of \\(v\\): white, gray, or black.\n* \\(v.\\mathit{d}\\) holds the distance from the source vertex \\(s\\) to \\(v\\), as computed by the algorithm.\n* \\(v.\\mathit{\\pi}\\) is \\(v\\)'s predecessor in the breadth-first tree. If \\(v\\) has no predecessor because it is the source vertex or is undiscovered, then \\(v.\\mathit{\\pi}=\\textsc{nil}\\).\n\nFigure 20.3 illustrates the progress of BFS on an undirected graph.\n\nThe procedure BFS works as follows. With the exception of the source vertex \\(s\\), lines 1-4 paint every vertex white, set \\(u.\\mathit{d}=\\infty\\) for each vertex \\(u\\), and set the parent of every vertex to be nil. Because the source vertex \\(s\\) is always the first vertex discovered, lines 5-7 paint \\(s\\) gray, set \\(s.\\mathit{d}\\) to \\(0\\), and set the predecessor of \\(s\\) to nil. Lines 8-9 create the queue \\(Q\\), initially containing just the source vertex.\n\nThe **while** loop of lines 10-18 iterates as long as there remain gray vertices, which are on the frontier: discovered vertices that have not yet had their adjacency lists fully examined. This **while** loop maintains the following invariant:\n\nAt the test in line 10, the queue \\(Q\\) consists of the set of gray vertices.\n\nAlthough we won't use this loop invariant to prove correctness, it is easy to see that it holds prior to the first iteration and that each iteration of the loop maintains the invariant. Prior to the first iteration, the only gray vertex, and the only vertex in \\(Q\\), is the source vertex \\(s\\). Line 11 determines the gray vertex \\(u\\) at the head of the queue \\(Q\\) and removes it from \\(Q\\). The **for** loop of lines 12-17 considers each vertex \\(v\\) in the adjacency list of \\(u\\). If \\(v\\) is white, then it has not yet been discovered, and the procedure discovers it by executing lines 14-17. These lines paint vertex \\(v\\) gray, set \\(v\\)'s distance \\(v.d\\) to \\(u.d+1\\), record \\(u\\) as \\(v\\)'s parent \\(v.\\pi\\), and place \\(v\\) at the tail of the queue \\(Q\\). Once the procedure has examined all the vertices on \\(u\\)'s adjacency list, it blackens \\(u\\) in line 18, indicating that \\(u\\) is now behind the frontier. The loop invariant is maintained because whenever a vertex is painted gray (in line 14) it is also enqueued (in line 17), and whenever a vertex is dequeued (in line 11) it is also painted black (in line 18).\n\nThe results of breadth-first search may depend upon the order in which the neighbors of a given vertex are visited in line 12: the breadth-first tree may vary, but the distances \\(d\\) computed by the algorithm do not. (See Exercise 20.2-5.)\n\nA simple change allows the BFS procedure to terminate in many cases before the queue \\(Q\\) becomes empty. Because each vertex is discovered at most once and receives a finite \\(d\\) value only when it is discovered, the algorithm can terminate once every vertex has a finite \\(d\\) value. If BFS keeps count of how many vertices have been discovered, it can terminate once either the queue \\(Q\\) is empty or all \\(|V|\\) vertices are discovered.\n\n### 2.2 Breadth-first search\n\nFigure 20.3: The operation of BFS on an undirected graph. Each part shows the graph and the queue \\(Q\\) at the beginning of each iteration of the **while** loop of lines 10\u201318. Vertex distances appear within each vertex and below vertices in the queue. The tan region surrounds the frontier of the search, consisting of the vertices in the queue. The light blue region surrounds the vertices behind the frontier, which have been dequeued. Each part highlights in orange the vertex dequeued and the breadth-first tree edges added, if any, in the previous iteration. Blue edges belong to the breadth-first tree constructed so far.\n\n### Analysis\n\nBefore proving the various properties of breadth-first search, let's take on the easier job of analyzing its running time on an input graph \\(G=(V,E)\\). We use aggregate analysis, as we saw in Section 16.1. After initialization, breadth-first search never whitens a vertex, and thus the test in line 13 ensures that each vertex is enqueued at most once, and hence dequeued at most once. The operations of enqueuing and dequeuing take \\(O(1)\\) time, and so the total time devoted to queue operations is \\(O(V)\\). Because the procedure scans the adjacency list of each vertex only when the vertex is dequeued, it scans each adjacency list at most once. Since the sum of the lengths of all \\(|V|\\) adjacency lists is \\(\\Theta(E)\\), the total time spent in scanning adjacency lists is \\(O(V+E)\\). The overhead for initialization is \\(O(V)\\), and thus the total running time of the BFS procedure is \\(O(V+E)\\). Thus, breadth-first search runs in time linear in the size of the adjacency-list representation of \\(G\\).\n\n### Shortest paths\n\nNow, let's see why breadth-first search finds the shortest distance from a given source vertex \\(s\\) to each vertex in a graph. Define the _shortest-path distance_\\(\\delta(s,v)\\) from \\(s\\) to \\(v\\) as the minimum number of edges in any path from vertex \\(s\\) to vertex \\(v\\). If there is no path from \\(s\\) to \\(v\\), then \\(\\delta(s,v)=\\infty\\). We call a path of length \\(\\delta(s,v)\\) from \\(s\\) to \\(v\\) a _shortest path_2 from \\(s\\) to \\(v\\). Before showing that breadth-first search correctly computes shortest-path distances, we investigate an important property of shortest-path distances.\n\nFootnote 2: Chapters 22 and 23 generalize shortest paths to weighted graphs, in which every edge has a real-valued weight and the weight of a path is the sum of the weights of its constituent edges. The graphs considered in the present chapter are unweighted or, equivalently, all edges have unit weight.\n\n**Lemma 20.1**: _Let \\(G=(V,E)\\) be a directed or undirected graph, and let \\(s\\in V\\) be an arbitrary vertex. Then, for any edge \\((u,v)\\in E\\),_\n\n\\[\\delta(s,v)\\leq\\delta(s,u)+1\\.\\]\n\n_Proof_If \\(u\\) is reachable from \\(s\\), then so is \\(v\\). In this case, the shortest path from \\(s\\) to \\(v\\) cannot be longer than the shortest path from \\(s\\) to \\(u\\) followed by the edge \\((u,v)\\), and thus the inequality holds. If \\(u\\) is not reachable from \\(s\\), then \\(\\delta(s,u)=\\infty\\), and again, the inequality holds.\n\nOur goal is to show that the BFS procedure properly computes \\(v.d=\\delta(s,v)\\) for each vertex \\(v\\in V\\). We first show that \\(v.d\\) bounds \\(\\delta(s,v)\\) from above.\n\n**Lemma 20.2**: _Let \\(G=(V,E)\\) be a directed or undirected graph, and suppose that BFS is run on \\(G\\) from a given source vertex \\(s\\in V\\). Then, for each vertex \\(v\\in V\\), the value \\(v.d\\) computed by BFS satisfies \\(v.d\\geq\\delta(s,v)\\) at all times, including at termination._\n\n_Proof_ The lemma is true intuitively, because any finite value assigned to \\(v.d\\) equals the number of edges on some path from \\(s\\) to \\(v\\). The formal proof is by induction on the number of Enqueue operations. The inductive hypothesis is that \\(v.d\\geq\\delta(s,v)\\) for all \\(v\\in V\\).\n\nThe base case of the induction is the situation immediately after enqueuing \\(s\\) in line 9 of BFS. The inductive hypothesis holds here, because \\(s.d=0=\\delta(s,s)\\) and \\(v.d=\\infty\\geq\\delta(s,v)\\) for all \\(v\\in V-\\{s\\}\\).\n\nFor the inductive step, consider a white vertex \\(v\\) that is discovered during the search from a vertex \\(u\\). The inductive hypothesis implies that \\(u.d\\geq\\delta(s,u)\\). The assignment performed by line 15 and Lemma 20.1 give\n\n\\[v.d = u.d+1\\] \\[\\geq \\delta(s,u)+1\\] \\[\\geq \\delta(s,v)~{}.\\]\n\nVertex \\(v\\) is then enqueued, and it is never enqueued again because it is also grayed and lines 14-17 execute only for white vertices. Thus, the value of \\(v.d\\) never changes again, and the inductive hypothesis is maintained.\n\nTo prove that \\(v.d=\\delta(s,v)\\), we first show more precisely how the queue \\(Q\\) operates during the course of BFS. The next lemma shows that at all times, the \\(d\\) values of vertices in the queue either are all the same or form a sequence \\((k,k,\\ldots,k,k+1,k+1,\\ldots,k+1)\\) for some integer \\(k\\geq 0\\).\n\n**Lemma 20.3**: _Suppose that during the execution of BFS on a graph \\(G=(V,E)\\), the queue \\(Q\\) contains the vertices \\(\\langle v_{1}\\), \\(v_{2},\\ldots,v_{r}\\rangle\\), where \\(v_{1}\\) is the head of \\(Q\\) and \\(v_{r}\\) is the tail. Then, \\(v_{r}.d\\leq v_{1}.d+1\\) and \\(v_{i}.d\\leq v_{i+1}.d\\) for \\(i=1,2,\\ldots,r-1\\)._\n\n_Proof_ The proof is by induction on the number of queue operations. Initially, when the queue contains only \\(s\\), the lemma trivially holds.\n\nFor the inductive step, we must prove that the lemma holds after both dequeuing and enqueuing a vertex. First, we examine dequeuing. When the head \\(v_{1}\\) of the queue is dequeued, \\(v_{2}\\) becomes the new head. (If the queue becomes empty, then the lemma holds vacuously.) By the inductive hypothesis, \\(v_{1}.d\\leq v_{2}.d\\). But then we have \\(v_{r}.d\\leq v_{1}.d+1\\leq v_{2}.d+1\\), and the remaining inequalities are unaffected. Thus, the lemma follows with \\(v_{2}\\) as the new head.\n\nNow, we examine enqueuing. When line 17 of BFS enqueues a vertex \\(v\\) onto a queue containing vertices \\(\\langle v_{1},\\,v_{2},\\,\\ldots,\\,v_{r}\\rangle\\), the enqueued vertex becomes \\(v_{r+1}\\). If the queue was empty before \\(v\\) was enqueued, then after enqueuing \\(v\\), we have \\(r=1\\) and the lemma trivially holds. Now suppose that the queue was nonempty when \\(v\\) was enqueued. At that time, the procedure has most recently removed vertex \\(u\\), whose adjacency list is currently being scanned, from the queue \\(Q\\). Just before \\(u\\) was removed, we had \\(u=v_{1}\\) and the inductive hypothesis held, so that \\(u.d\\leq v_{2}.\\,d\\) and \\(v_{r}.\\,d\\leq u.d+1\\). After \\(u\\) is removed from the queue, the vertex that had been \\(v_{2}\\) becomes the new head \\(v_{1}\\) of the queue, so that now \\(u.d\\leq v_{1}.\\,d\\). Thus, \\(v_{r+1}.\\,d=v.\\,d=u.\\,d+1\\leq v_{1}.\\,d+1\\). Since \\(v_{r}.\\,d\\leq u.\\,d+1\\), we have \\(v_{r}.\\,d\\leq u.\\,d+1=v.\\,d=v_{r+1}.\\,d\\), and the remaining inequalities are unaffected. Thus, the lemma follows when \\(v\\) is enqueued.\n\nThe following corollary shows that the \\(d\\) values at the time that vertices are enqueued monotonically increase over time.\n\n**Corollary 20.4**: _Suppose that vertices \\(v_{i}\\) and \\(v_{j}\\) are enqueued during the execution of BFS, and that \\(v_{i}\\) is enqueued before \\(v_{j}\\). Then \\(v_{i}.\\,d\\leq v_{j}.\\,d\\) at the time that \\(v_{j}\\) is enqueued._\n\n_Proof_ Immediate from Lemma 20.3 and the property that each vertex receives a finite \\(d\\) value at most once during the course of BFS.\n\nWe can now prove that breadth-first search correctly finds shortest-path distances.\n\n**Theorem 20.5** (Correctness of breadth-first search): _Let \\(G=(V,E)\\) be a directed or undirected graph, and suppose that BFS is run on \\(G\\) from a given source vertex \\(s\\in V\\). Then, during its execution, BFS discovers every vertex \\(v\\in V\\) that is reachable from the source \\(s\\), and upon termination, \\(v.\\,d=\\delta(s,v)\\) for all \\(v\\in V\\). Moreover, for any vertex \\(v\\neq s\\) that is reachable from \\(s\\), one of the shortest paths from \\(s\\) to \\(v\\) is a shortest path from \\(s\\) to \\(v.\\,\\pi\\) followed by the edge \\((v.\\,\\pi,v)\\)._\n\n_Proof_ Assume for the purpose of contradiction that some vertex receives a \\(d\\) value not equal to its shortest-path distance. Of all such vertices, let \\(v\\) be a vertex that has the minimum \\(\\delta(s,v)\\). By Lemma 20.2, we have \\(v.\\,d\\geq\\delta(s,v)\\), and thus \\(v.\\,d>\\delta(s,v)\\). We cannot have \\(v=s\\), because \\(s.\\,d=0\\) and \\(\\delta(s,s)=0\\). Vertex \\(v\\) must be reachable from \\(s\\), for otherwise we would have \\(\\delta(s,v)=\\infty\\geq v.\\,d\\). Let \\(u\\) be the vertex immediately preceding \\(v\\) on some shortest path from \\(s\\) to \\(v\\) (since \\(v\\neq s\\), vertex \\(u\\) must exist), so that \\(\\delta(s,v)=\\delta(s,u)+1\\). Because \\(\\delta(s,u)<\\delta(s,v)\\)and because of how we chose \\(v\\), we have \\(u.d=\\delta(s,u)\\). Putting these properties together gives\n\n\\[v.d>\\delta(s,v)=\\delta(s,u)+1=u.d+1. \\tag{20.1}\\]\n\nNow consider the time when BFS chooses to dequeue vertex \\(u\\) from \\(Q\\) in line 11. At this time, vertex \\(v\\) is either white, gray, or black. We shall show that each of these cases leads to a contradiction of inequality (20.1). If \\(v\\) is white, then line 15 sets \\(v.d=u.d+1\\), contradicting inequality (20.1). If \\(v\\) is black, then it was already removed from the queue and, by Corollary 20.4, we have \\(v.d\\leq u.d\\), again contradicting inequality (20.1). If \\(v\\) is gray, then it was painted gray upon dequeuing some vertex \\(w\\), which was removed from \\(Q\\) earlier than \\(u\\) and for which \\(v.d=w.d+1\\). By Corollary 20.4, however, \\(w.d\\leq u.d\\), and so \\(v.d=w.d+1\\leq u.d+1\\), once again contradicting inequality (20.1).\n\nThus we conclude that \\(v.d=\\delta(s,v)\\) for all \\(v\\in V\\). All vertices \\(v\\) reachable from \\(s\\) must be discovered, for otherwise they would have \\(\\infty=v.d>\\delta(s,v)\\). To conclude the proof of the theorem, observe from lines 15-16 that if \\(v.\\pi=u\\), then \\(v.d=u.d+1\\). Thus, to form a shortest path from \\(s\\) to \\(v\\), take a shortest path from \\(s\\) to \\(v.\\pi\\) and then traverse the edge \\((v.\\pi,v)\\).\n\n##### Breadth-first trees\n\nThe blue edges in Figure 20.3 show the breadth-first tree built by the BFS procedure as it searches the graph. The tree corresponds to the \\(\\pi\\) attributes. More formally, for a graph \\(G=(V,E)\\) with source \\(s\\), we define the _predecessor subgraph_ of \\(G\\) as \\(G_{\\pi}=(V_{\\pi},E_{\\pi})\\), where\n\n\\[V_{\\pi}=\\{v\\in V:v.\\pi\\not=\\textsc{nil}\\}\\cup\\{s\\} \\tag{20.2}\\]\n\nand\n\n\\[E_{\\pi}=\\{(v.\\pi,v):v\\in V_{\\pi}-\\{s\\}\\}. \\tag{20.3}\\]\n\nThe predecessor subgraph \\(G_{\\pi}\\) is a _breadth-first tree_ if \\(V_{\\pi}\\) consists of the vertices reachable from \\(s\\) and, for all \\(v\\in V_{\\pi}\\), the subgraph \\(G_{\\pi}\\) contains a unique simple path from \\(s\\) to \\(v\\) that is also a shortest path from \\(s\\) to \\(v\\) in \\(G\\). A breadth-first tree is in fact a tree, since it is connected and \\(|E_{\\pi}|=|V_{\\pi}|-1\\) (see Theorem B.2 on page 1169). We call the edges in \\(E_{\\pi}\\)_tree edges_.\n\nThe following lemma shows that the predecessor subgraph produced by the BFS procedure is a breadth-first tree.\n\n**Lemma 20.6**: _When applied to a directed or undirected graph \\(G=(V,E)\\), procedure BFS constructs \\(\\pi\\) so that the predecessor subgraph \\(G_{\\pi}=(V_{\\pi},E_{\\pi})\\) is a breadth-first tree.__Proof_Line 16 of BFS sets \\(v.\\,\\pi\\,=u\\) if and only if \\((u,v)\\in E\\) and \\(\\delta(s,v)<\\infty\\)-- that is, if \\(v\\) is reachable from \\(s\\)-- and thus \\(V_{\\pi}\\) consists of the vertices in \\(V\\) reachable from \\(s\\). Since the predecessor subgraph \\(G_{\\pi}\\) forms a tree, by Theorem B.2, it contains a unique simple path from \\(s\\) to each vertex in \\(V_{\\pi}\\). Applying Theorem 20.5 inductively yields that every such path is a shortest path in \\(G\\).\n\nThe Print-Path procedure prints out the vertices on a shortest path from \\(s\\) to \\(v\\), assuming that BFS has already computed a breadth-first tree. This procedure runs in time linear in the number of vertices in the path printed, since each recursive call is for a path one vertex shorter.\n\n\\begin{tabular}{l} Print-Path(\\(G,s,v\\)) \\\\\n1 **if**\\(v==s\\) \\\\\n2 **print**\\(s\\) \\\\\n3 **elseif**\\(v.\\,\\pi\\,==\\,\\textsc{nil}\\) \\\\\n4 **print** \"no path from\" \\(s\\) \"to\" \\(v\\) \"exists\" \\\\\n5 **else**Print-Path(\\(G,s,v.\\pi\\)) \\\\\n6 **print**\\(v\\) \\\\ \\end{tabular}\n\n### Exercises\n\n_20.2-1_\n\nShow the \\(d\\) and \\(\\pi\\) values that result from running breadth-first search on the directed graph of Figure 20.2(a), using vertex 3 as the source.\n\n_20.2-2_\n\nShow the \\(d\\) and \\(\\pi\\) values that result from running breadth-first search on the undirected graph of Figure 20.3, using vertex \\(u\\) as the source. Assume that neighbors of a vertex are visited in alphabetical order.\n\n_20.2-3_\n\nShow that using a single bit to store each vertex color suffices by arguing that the BFS procedure produces the same result if line 18 is removed. Then show how to obviate the need for vertex colors altogether.\n\n_20.2-4_\n\nWhat is the running time of BFS if we represent its input graph by an adjacency matrix and modify the algorithm to handle this form of input?\n\n### Depth-first search\n\nArgue that in a breadth-first search, the value \\(u.d\\) assigned to a vertex \\(u\\) is independent of the order in which the vertices appear in each adjacency list. Using Figure 20.3 as an example, show that the breadth-first tree computed by BFS can depend on the ordering within adjacency lists.\n\n### 20.2-6\n\nGive an example of a directed graph \\(G=(V,E)\\), a source vertex \\(s\\in V\\), and a set of tree edges \\(E_{\\pi}\\subseteq E\\) such that for each vertex \\(v\\in V\\), the unique simple path in the graph \\((V,E_{\\pi})\\) from \\(s\\) to \\(v\\) is a shortest path in \\(G\\), yet the set of edges \\(E_{\\pi}\\) cannot be produced by running BFS on \\(G\\), no matter how the vertices are ordered in each adjacency list.\n\n### 20.2-7\n\nThere are two types of professional wrestlers: \"faces\" (short for \"babyfaces,\" i.e., \"good guys\") and \"heels\" (\"bad guys\"). Between any pair of professional wrestlers, there may or may not be a rivalry. You are given the names of \\(n\\) professional wrestlers and a list of \\(r\\) pairs of wrestlers for which there are rivalries. Give an \\(O(n+r)\\)-time algorithm that determines whether it is possible to designate some of the wrestlers as faces and the remainder as heels such that each rivalry is between a face and a heel. If it is possible to perform such a designation, your algorithm should produce it.\n\n### 20.2-8\n\nThe _diameter_ of a tree \\(T=(V,E)\\) is defined as \\(\\max\\left\\{\\delta(u,v):u,v\\in V\\right\\}\\), that is, the largest of all shortest-path distances in the tree. Give an efficient algorithm to compute the diameter of a tree, and analyze the running time of your algorithm.\n\n### Depth-first search\n\nAs its name implies, depth-first search searches \"deeper\" in the graph whenever possible. Depth-first search explores edges out of the most recently discovered vertex \\(v\\) that still has unexplored edges leaving it. Once all of \\(v\\)'s edges have been explored, the search \"backtracks\" to explore edges leaving the vertex from which \\(v\\) was discovered. This process continues until all vertices that are reachable from the original source vertex have been discovered. If any undiscovered vertices remain, then depth-first search selects one of them as a new source, repeating the search",
        "chapter": "Part VI Graph Algorithms",
        "section": "20 Elementary Graph Algorithms",
        "subsection": "20.2 Breadth-first search",
        "subsubsection": "N/A"
    },
    {
        "content": "### Depth-first search\n\nArgue that in a breadth-first search, the value \\(u.d\\) assigned to a vertex \\(u\\) is independent of the order in which the vertices appear in each adjacency list. Using Figure 20.3 as an example, show that the breadth-first tree computed by BFS can depend on the ordering within adjacency lists.\n\n### 20.2-6\n\nGive an example of a directed graph \\(G=(V,E)\\), a source vertex \\(s\\in V\\), and a set of tree edges \\(E_{\\pi}\\subseteq E\\) such that for each vertex \\(v\\in V\\), the unique simple path in the graph \\((V,E_{\\pi})\\) from \\(s\\) to \\(v\\) is a shortest path in \\(G\\), yet the set of edges \\(E_{\\pi}\\) cannot be produced by running BFS on \\(G\\), no matter how the vertices are ordered in each adjacency list.\n\n### 20.2-7\n\nThere are two types of professional wrestlers: \"faces\" (short for \"babyfaces,\" i.e., \"good guys\") and \"heels\" (\"bad guys\"). Between any pair of professional wrestlers, there may or may not be a rivalry. You are given the names of \\(n\\) professional wrestlers and a list of \\(r\\) pairs of wrestlers for which there are rivalries. Give an \\(O(n+r)\\)-time algorithm that determines whether it is possible to designate some of the wrestlers as faces and the remainder as heels such that each rivalry is between a face and a heel. If it is possible to perform such a designation, your algorithm should produce it.\n\n### 20.2-8\n\nThe _diameter_ of a tree \\(T=(V,E)\\) is defined as \\(\\max\\left\\{\\delta(u,v):u,v\\in V\\right\\}\\), that is, the largest of all shortest-path distances in the tree. Give an efficient algorithm to compute the diameter of a tree, and analyze the running time of your algorithm.\n\n### Depth-first search\n\nAs its name implies, depth-first search searches \"deeper\" in the graph whenever possible. Depth-first search explores edges out of the most recently discovered vertex \\(v\\) that still has unexplored edges leaving it. Once all of \\(v\\)'s edges have been explored, the search \"backtracks\" to explore edges leaving the vertex from which \\(v\\) was discovered. This process continues until all vertices that are reachable from the original source vertex have been discovered. If any undiscovered vertices remain, then depth-first search selects one of them as a new source, repeating the searchfrom that source. The algorithm repeats this entire process until it has discovered every vertex.3\n\nFootnote 3: It may seem arbitrary that breadth-first search is limited to only one source whereas depth-first search may search from multiple sources. Although conceptually, breadth-first search could proceed from multiple sources and depth-first search could be limited to one source, our approach reflects how the results of these searches are typically used. Breadth-first search usually serves to find shortest-path distances and the associated predecessor subgraph from a given source. Depth-first search is often a subroutine in another algorithm, as we\u2019ll see later in this chapter.\n\nAs in breadth-first search, whenever depth-first search discovers a vertex \\(v\\) during a scan of the adjacency list of an already discovered vertex \\(u\\), it records this event by setting \\(v\\)'s predecessor attribute \\(v.\\pi\\) to \\(u\\). Unlike breadth-first search, whose predecessor subgraph forms a tree, depth-first search produces a predecessor subgraph that might contain several trees, because the search may repeat from multiple sources. Therefore, we define the _predecessor subgraph_ of a depth-first search slightly differently from that of a breadth-first search: it always includes all vertices, and it accounts for multiple sources. Specifically, for a depth-first search the predecessor subgraph is \\(G_{\\pi}=(V,E_{\\pi})\\), where\n\n\\[E_{\\pi}=\\left\\{(v.\\pi,v):v\\in V\\text{ and }v.\\pi\\neq\\textsc{nil}\\right\\}\\.\\]\n\nThe predecessor subgraph of a depth-first search forms a _depth-first forest_ comprising several _depth-first trees_. The edges in \\(E_{\\pi}\\) are _tree edges_.\n\nLike breadth-first search, depth-first search colors vertices during the search to indicate their state. Each vertex is initially white, is grayed when it is _discovered_ in the search, and is blackened when it is _finished_, that is, when its adjacency list has been examined completely. This technique guarantees that each vertex ends up in exactly one depth-first tree, so that these trees are disjoint.\n\nBesides creating a depth-first forest, depth-first search also _timestamps_ each vertex. Each vertex \\(v\\) has two timestamps: the first timestamp \\(v.d\\) records when \\(v\\) is first discovered (and grayed), and the second timestamp \\(v.f\\) records when the search finishes examining \\(v\\)'s adjacency list (and blackens \\(v\\)). These timestamps provide important information about the structure of the graph and are generally helpful in reasoning about the behavior of depth-first search.\n\nThe procedure DFS on the facing page records when it discovers vertex \\(u\\) in the attribute \\(u.d\\) and when it finishes vertex \\(u\\) in the attribute \\(u.f\\). These timestamps are integers between 1 and 2 \\(|V|\\), since there is one discovery event and one finishing event for each of the \\(|V|\\) vertices. For every vertex \\(u\\),\n\n\\[u.d<u.f. \\tag{20.4}\\]\n\nVertex \\(u\\) is white before time \\(u.d\\), gray between time \\(u.d\\) and time \\(u.f\\), and black thereafter. In the DFS procedure, the input graph \\(G\\) may be undirected or directed. The variable _time_ is a global variable used for timestamping. Figure 20.4 illustrates the progress of DFS on the graph shown in Figure 20.2 (but with vertices labeled by letters rather than numbers).\n\n\\[\\begin{array}{l}\\mbox{\\sc DFS}(G)\\\\ \\mbox{\\sc for each vertex $u\\in G.V$}\\\\ \\mbox{\\sc }u.\\mathit{color}=\\mbox{\\sc white}\\\\ \\mbox{\\sc }u.\\pi=\\mbox{\\sc nil}\\\\ \\mbox{\\sc }time=0\\\\ \\mbox{\\sc for each vertex $u\\in G.V$}\\\\ \\mbox{\\sc if $u.\\mathit{color}==\\mbox{\\sc white}$}\\\\ \\mbox{\\sc DFS-Visit}(G,u)\\end{array}\\]\n\n\\[\\begin{array}{l}\\mbox{\\sc DFS-Visit}(G,u)\\\\ \\mbox{\\sc }\n\nproblems in practice, because many applications of depth-first search can use the result from any depth-first search.\n\nWhat is the running time of DFS? The loops on lines 1-3 and lines 5-7 of DFS take \\(\\Theta(V)\\) time, exclusive of the time to execute the calls to DFS-Visit. As we did for breadth-first search, we use aggregate analysis. The procedure DFS-Visit is called exactly once for each vertex \\(v\\in V\\), since the vertex \\(u\\) on which DFS-Visit is invoked must be white and the first thing DFS-Visit does is paint vertex \\(u\\) gray. During an execution of DFS-Visit\\((G,v)\\), the loop in lines 4-7 executes \\(|Adj[v]|\\) times. Since \\(\\sum_{v\\in V}|Adj[v]|=\\Theta(E)\\) and DFS-Visit is called once per vertex, the\n\nFigure 20: The progress of the depth-first-search algorithm DFS on a directed graph. Edges are classified as they are explored: tree edges are labeled T, back edges B, forward edges F, and cross edges C. Timestamps within vertices indicate discovery time/finish times. Tree edges are highlighted in blue. Orange highlights indicate vertices whose discovery or finish times change and edges that are explored in each step.\n\ntotal cost of executing lines 4-7 of DFS-Visit is \\(\\Theta(V+E)\\). The running time of DFS is therefore \\(\\Theta(V+E)\\).\n\n##### Properties of depth-first search\n\nDepth-first search yields valuable information about the structure of a graph. Perhaps the most basic property of depth-first search is that the predecessor subgraph \\(G_{\\pi}\\) does indeed form a forest of trees, since the structure of the depth-first trees exactly mirrors the structure of recursive calls of DFS-Visit. That is, \\(u=v.\\pi\\) if and only if DFS-Visit\\((G,v)\\) was called during a search of \\(u\\)'s adjacency list. Additionally, vertex \\(v\\) is a descendant of vertex \\(u\\) in the depth-first forest if and only if \\(v\\) is discovered during the time in which \\(u\\) is gray.\n\nAnother important property of depth-first search is that discovery and finish times have _parenthesis structure_. If the DFS-Visit procedure were to print a left parenthesis \"\\((u\\)\" when it discovers vertex \\(u\\) and to print a right parenthesis \"\\(u\\)\" when it finishes \\(u\\), then the printed expression would be well formed in the sense that the parentheses are properly nested. For example, the depth-first search of Figure 20.5(a) corresponds to the parenthesization shown in Figure 20.5(b). The following theorem provides another way to characterize the parenthesis structure.\n\n**Theorem 20.7** (Parenthesis theorem): _In any depth-first search of a (directed or undirected) graph \\(G=(V,E)\\), for any two vertices \\(u\\) and \\(v\\), exactly one of the following three conditions holds:_\n\n* _the intervals_ \\([u.d,u.f]\\) _and_ \\([v.d,v.f]\\) _are entirely disjoint, and neither_ \\(u\\) _nor_ \\(v\\) _is a descendant of the other in the depth-first forest,_\n* _the interval_ \\([u.d,u.f]\\) _is contained entirely within the interval_ \\([v.d,v.f]\\)_, and_ \\(u\\) _is a descendant of_ \\(v\\) _in a depth-first tree, or_\n* _the interval_ \\([v.d,v.f]\\) _is contained entirely within the interval_ \\([u.d,u.f]\\)_, and_ \\(v\\) _is a descendant of_ \\(u\\) _in a depth-first tree._\n\n_Proof_We begin with the case in which \\(u.d<v.d\\). We consider two subcases, according to whether \\(v.d<u.f\\). The first subcase occurs when \\(v.d<u.f\\), so that \\(v\\) was discovered while \\(u\\) was still gray, which implies that \\(v\\) is a descendant of \\(u\\). Moreover, since \\(v\\) was discovered after \\(u\\), all of its outgoing edges are explored, and \\(v\\) is finished, before the search returns to and finishes \\(u\\). In this case, therefore, the interval \\([v.d,v.f]\\) is entirely contained within the interval \\([u.d,u.f]\\). In the other subcase, \\(u.f<v\\). \\(d\\), and by inequality (20.4), \\(u.d<\\!\\!u\\). \\(f<\\!\\!v\\). \\(d<\\!\\!v\\). \\(f\\), and thus the intervals \\([u.d,u.f]\\) and \\([v.d,v.f]\\) are disjoint. Because the intervals are disjoint, neither vertex was discovered while the other was gray, and so neither vertex is a descendant of the other.\n\nThe case in which \\(v.d<u.d\\) is similar, with the roles of \\(u\\) and \\(v\\) reversed in the above argument. \n\n_Corollary 20.8_ (Nesting of descendants' intervals): Vertex \\(v\\) is a proper descendant of vertex \\(u\\) in the depth-first forest for a (directed or undirected) graph \\(G\\) if and only if \\(u.d<v.d<v.f<u.f\\).\n\n_Proof_ Immediate from Theorem 20.7. \n\nThe next theorem gives another important characterization of when one vertex is a descendant of another in the depth-first forest.\n\nFigure 20.5: Properties of depth-first search. **(a)** The result of a depth-first search of a directed graph. Vertices are timestamped and edge types are indicated as in Figure 20.4. **(b)** Intervals for the discovery time and finish time of each vertex correspond to the parenthesized shown. Each rectangle spans the interval given by the discovery and finish times of the corresponding vertex. Only tree edges are shown. If two intervals overlap, then one is nested within the other, and the vertex corresponding to the smaller interval is a descendant of the vertex corresponding to the larger. **(c)** The graph of part (a) redrawn with all tree and forward edges going down within a depth-first tree and all back edges going up from a descendant to an ancestor.\n\n_Theorem 20.9 (White-path theorem)_\n\nIn a depth-first forest of a (directed or undirected) graph \\(G=(V,E)\\), vertex \\(v\\) is a descendant of vertex \\(u\\) if and only if at the time \\(u.d\\) that the search discovers \\(u\\), there is a path from \\(u\\) to \\(v\\) consisting entirely of white vertices.\n\n_Proof_\\(\\Rightarrow\\): If \\(v=u\\), then the path from \\(u\\) to \\(v\\) contains just vertex \\(u\\), which is still white when \\(u.d\\) receives a value. Now, suppose that \\(v\\) is a proper descendant of \\(u\\) in the depth-first forest. By Corollary 20.8, \\(u.d<v.d\\), and so \\(v\\) is white at time \\(u.d\\). Since \\(v\\) can be any descendant of \\(u\\), all vertices on the unique simple path from \\(u\\) to \\(v\\) in the depth-first forest are white at time \\(u.d\\).\n\n\\(\\Leftarrow\\): Suppose that there is a path of white vertices from \\(u\\) to \\(v\\) at time \\(u.d\\), but \\(v\\) does not become a descendant of \\(u\\) in the depth-first tree. Without loss of generality, assume that every vertex other than \\(v\\) along the path becomes a descendant of \\(u\\). (Otherwise, let \\(v\\) be the closest vertex to \\(u\\) along the path that doesn't become a descendant of \\(u\\).) Let \\(w\\) be the predecessor of \\(v\\) in the path, so that \\(w\\) is a descendant of \\(u\\) (\\(w\\) and \\(u\\) may in fact be the same vertex). By Corollary 20.8, \\(w.f\\leq u.f\\). Because \\(v\\) must be discovered after \\(u\\) is discovered, but before \\(w\\) is finished, \\(u.d<v.\\ d<w.\\ f\\leq u.f\\). Theorem 20.7 then implies that the interval \\([v.d,v.f]\\) is contained entirely within the interval \\([u.d,u.f]\\). By Corollary 20.8, \\(v\\) must after all be a descendant of \\(u\\).\n\n**Classification of edges**\n\nYou can obtain important information about a graph by classifying its edges during a depth-first search. For example, Section 20.4 will show that a directed graph is acyclic if and only if a depth-first search yields no \"back\" edges (Lemma 20.11).\n\nThe depth-first forest \\(G_{\\pi}\\) produced by a depth-first search on graph \\(G\\) can contain four types of edges:\n\n1. _Tree edges_ are edges in the depth-first forest \\(G_{\\pi}\\). Edge \\((u,v)\\) is a tree edge if \\(v\\) was first discovered by exploring edge \\((u,v)\\).\n2. _Back edges_ are those edges \\((u,v)\\) connecting a vertex \\(u\\) to an ancestor \\(v\\) in a depth-first tree. We consider self-loops, which may occur in directed graphs, to be back edges.\n3. _Forward edges_ are those nontree edges \\((u,v)\\) connecting a vertex \\(u\\) to a proper descendant \\(v\\) in a depth-first tree.\n4. _Cross edges_ are all other edges. They can go between vertices in the same depth-first tree, as long as one vertex is not an ancestor of the other, or they can go between vertices in different depth-first trees.\n\nIn Figures 20.4 and 20.5, edge labels indicate edge types. Figure 20.5(c) also shows how to redraw the graph of Figure 20.5(a) so that all tree and forward edges head downward in a depth-first tree and all back edges go up. You can redraw any graph in this fashion.\n\nThe DFS algorithm has enough information to classify some edges as it encounters them. The key idea is that when an edge \\((u,v)\\) is first explored, the color of vertex \\(v\\) says something about the edge:\n\n1. white indicates a tree edge,\n2. gray indicates a back edge, and\n3. black indicates a forward or cross edge.\n\nThe first case is immediate from the specification of the algorithm. For the second case, observe that the gray vertices always form a linear chain of descendants corresponding to the stack of active DFS-Visit invocations. The number of gray vertices is 1 more than the depth in the depth-first forest of the vertex most recently discovered. Depth-first search always explores from the deepest gray vertex, so that an edge that reaches another gray vertex has reached an ancestor. The third case handles the remaining possibility. Exercise 20.3-5 asks you to show that such an edge \\((u,v)\\) is a forward edge if \\(u.d<v.d\\) and a cross edge if \\(u.d>v.d\\).\n\nAccording to the following theorem, forward and cross edges never occur in a depth-first search of an undirected graph.\n\n**Theorem 20.10**: _In a depth-first search of an undirected graph \\(G\\), every edge of \\(G\\) is either a tree edge or a back edge._\n\nLet \\((u,v)\\) be an arbitrary edge of \\(G\\), and suppose without loss of generality that \\(u.d<v.d\\). Then, while \\(u\\) is gray, the search must discover and finish \\(v\\) before it finishes \\(u\\), since \\(v\\) is on \\(u\\)'s adjacency list. If the first time that the search explores edge \\((u,v)\\), it is in the direction from \\(u\\) to \\(v\\), then \\(v\\) is undiscovered (white) until that time, for otherwise the search would have explored this edge already in the direction from \\(v\\) to \\(u\\). Thus, \\((u,v)\\) becomes a tree edge. If the search explores \\((u,v)\\) first in the direction from \\(v\\) to \\(u\\), then \\((u,v)\\) is a back edge, since there must be a path of tree edges from \\(u\\) to \\(v\\).\n\nSince \\((u,v)\\) and \\((v,u)\\) are really the same edge in an undirected graph, the proof of Theorem 20.10 says how to classify the edge. When searching from a vertex, which must be gray, if the adjacent vertex is white, then the edge is a tree edge. Otherwise, the edge is a back edge.\n\nThe next two sections apply the above theorems about depth-first search.\n\n### 20.3 Depth-first search\n\n#### Exercises\n\nMake a 3-by-3 chart with row and column labels white, gray, and black. In each cell \\((i,j)\\), indicate whether, at any point during a depth-first search of a directed graph, there can be an edge from a vertex of color \\(i\\) to a vertex of color \\(j\\). For each possible edge, indicate what edge types it can be. Make a second such chart for depth-first search of an undirected graph.\n\n#### 20.3-2\n\nShow how depth-first search works on the graph of Figure 20.6. Assume that the **for** loop of lines 5-7 of the DFS procedure considers the vertices in alphabetical order, and assume that each adjacency list is ordered alphabetically. Show the discovery and finish times for each vertex, and show the classification of each edge.\n\n#### 20.3-3\n\nShow the parenthesis structure of the depth-first search of Figure 20.4.\n\n#### 20.3-4\n\nShow that using a single bit to store each vertex color suffices by arguing that the DFS procedure produces the same result if line 10 of DFS-Visit is removed.\n\n#### 20.3-5\n\nShow that in a directed graph, edge \\((u,v)\\) is\n\n_a._ a tree edge or forward edge if and only if \\(u.d<v.d<v.f<u.f\\),\n\n_b._ a back edge if and only if \\(v.d\\leq u.d<u.f\\leq v.f\\), and\n\n_c._ a cross edge if and only if \\(v.d<v.f<u.d<u.f\\).\n\nFigure 20.6: A directed graph for use in Exercises 20.3-2 and 20.5-2.\n\n### 20.3-6\n\nRewrite the procedure DFS, using a stack to eliminate recursion.\n\n### 20.3-7\n\nGive a counterexample to the conjecture that if a directed graph \\(G\\) contains a path from \\(u\\) to \\(v\\), and if \\(u.d<v.d\\) in a depth-first search of \\(G\\), then \\(v\\) is a descendant of \\(u\\) in the depth-first forest produced.\n\n### 20.3-8\n\nGive a counterexample to the conjecture that if a directed graph \\(G\\) contains a path from \\(u\\) to \\(v\\), then any depth-first search must result in \\(v.d\\leq u.f\\).\n\n### 20.3-9\n\nModify the pseudocode for depth-first search so that it prints out every edge in the directed graph \\(G\\), together with its type. Show what modifications, if any, you need to make if \\(G\\) is undirected.\n\n### 20.3-10\n\nExplain how a vertex \\(u\\) of a directed graph can end up in a depth-first tree containing only \\(u\\), even though \\(u\\) has both incoming and outgoing edges in \\(G\\).\n\n### 20.3-11\n\nLet \\(G=(V,E)\\) be a connected, undirected graph. Give an \\(O(V+E)\\)-time algorithm to compute a path in \\(G\\) that traverses each edge in \\(E\\) exactly once in each direction. Describe how you can find your way out of a maze if you are given a large supply of pennies.\n\n### 20.3-12\n\nShow how to use a depth-first search of an undirected graph \\(G\\) to identify the connected components of \\(G\\), so that the depth-first forest contains as many trees as \\(G\\) has connected components. More precisely, show how to modify depth-first search so that it assigns to each vertex \\(v\\) an integer label \\(v.cc\\) between 1 and \\(k\\), where \\(k\\) is the number of connected components of \\(G\\), such that \\(u.cc=v.cc\\) if and only if \\(u\\) and \\(v\\) belong to the same connected component.\n\n### 20.3-13\n\nA directed graph \\(G=(V,E)\\) is _singly connected_ if \\(u\\leadsto v\\) implies that \\(G\\) contains at most one simple path from \\(u\\) to \\(v\\) for all vertices \\(u,v\\in V\\). Give an efficient algorithm to determine whether a directed graph is singly connected.\n\n### 20.4 Topological sort\n\nThis section shows how to use depth-first search to perform a topological sort of a directed acyclic graph, or a \"dag\" as it is sometimes called. A _topological sort_ of a dag \\(G=(V,E)\\) is a linear ordering of all its vertices such that if \\(G\\) contains an edge \\((u,v)\\), then \\(u\\) appears before \\(v\\) in the ordering. Topological sorting is defined only on directed graphs that are acyclic; no linear ordering is possible when a directed graph contains a cycle. Think of a topological sort of a graph as an ordering of its vertices along a horizontal line so that all directed edges go from left to right. Topological sorting is thus different from the usual kind of \"sorting\" studied in Part II.\n\nMany applications use directed acyclic graphs to indicate precedences among events. Figure 20.7 gives an example that arises when Professor Bumstead gets dressed in the morning. The professor must don certain garments before others (e.g., socks before shoes). Other items may be put on in any order (e.g., socks and pants). A directed edge \\((u,v)\\) in the dag of Figure 20.7(a) indicates that garment \\(u\\) must be donned before garment \\(v\\). A topological sort of this dag therefore gives a possible order for getting dressed. Figure 20.7(b) shows the topologically sorted dag as an ordering of vertices along a horizontal line such that all directed edges go from left to right.\n\nThe procedure Topological-Sort topologically sorts a dag. Figure 20.7(b) shows how the topologically sorted vertices appear in reverse order of their finish times.\n\nTopological-Sort(\\(G\\))\n\n call DFS(\\(G\\)) to compute finish times \\(v.f\\) for each vertex \\(v\\)\n\n as each vertex is finished, insert it onto the front of a linked list\n\n**return** the linked list of vertices\n\nThe Topological-Sort procedure runs in \\(\\Theta(V+E)\\) time, since depth-first search takes \\(\\Theta(V+E)\\) time and it takes \\(O(1)\\) time to insert each of the \\(|V|\\) vertices onto the front of the linked list.\n\nTo prove the correctness of this remarkably simple and efficient algorithm, we start with the following key lemma characterizing directed acyclic graphs.\n\n**Lemma 20.11**: _A directed graph \\(G\\) is acyclic if and only if a depth-first search of \\(G\\) yields no back edges._",
        "chapter": "Part VI Graph Algorithms",
        "section": "20 Elementary Graph Algorithms",
        "subsection": "20.3 Depth-first search",
        "subsubsection": "N/A"
    },
    {
        "content": "### 20.4 Topological sort\n\nThis section shows how to use depth-first search to perform a topological sort of a directed acyclic graph, or a \"dag\" as it is sometimes called. A _topological sort_ of a dag \\(G=(V,E)\\) is a linear ordering of all its vertices such that if \\(G\\) contains an edge \\((u,v)\\), then \\(u\\) appears before \\(v\\) in the ordering. Topological sorting is defined only on directed graphs that are acyclic; no linear ordering is possible when a directed graph contains a cycle. Think of a topological sort of a graph as an ordering of its vertices along a horizontal line so that all directed edges go from left to right. Topological sorting is thus different from the usual kind of \"sorting\" studied in Part II.\n\nMany applications use directed acyclic graphs to indicate precedences among events. Figure 20.7 gives an example that arises when Professor Bumstead gets dressed in the morning. The professor must don certain garments before others (e.g., socks before shoes). Other items may be put on in any order (e.g., socks and pants). A directed edge \\((u,v)\\) in the dag of Figure 20.7(a) indicates that garment \\(u\\) must be donned before garment \\(v\\). A topological sort of this dag therefore gives a possible order for getting dressed. Figure 20.7(b) shows the topologically sorted dag as an ordering of vertices along a horizontal line such that all directed edges go from left to right.\n\nThe procedure Topological-Sort topologically sorts a dag. Figure 20.7(b) shows how the topologically sorted vertices appear in reverse order of their finish times.\n\nTopological-Sort(\\(G\\))\n\n call DFS(\\(G\\)) to compute finish times \\(v.f\\) for each vertex \\(v\\)\n\n as each vertex is finished, insert it onto the front of a linked list\n\n**return** the linked list of vertices\n\nThe Topological-Sort procedure runs in \\(\\Theta(V+E)\\) time, since depth-first search takes \\(\\Theta(V+E)\\) time and it takes \\(O(1)\\) time to insert each of the \\(|V|\\) vertices onto the front of the linked list.\n\nTo prove the correctness of this remarkably simple and efficient algorithm, we start with the following key lemma characterizing directed acyclic graphs.\n\n**Lemma 20.11**: _A directed graph \\(G\\) is acyclic if and only if a depth-first search of \\(G\\) yields no back edges.__Proof_ \\(\\Rightarrow\\): Suppose that a depth-first search produces a back edge \\((u,v)\\). Then vertex \\(v\\) is an ancestor of vertex \\(u\\) in the depth-first forest. Thus, \\(G\\) contains a path from \\(v\\) to \\(u\\), and the back edge \\((u,v)\\) completes a cycle.\n\n\\(\\Leftarrow\\): Suppose that \\(G\\) contains a cycle \\(c\\). We show that a depth-first search of \\(G\\) yields a back edge. Let \\(v\\) be the first vertex to be discovered in \\(c\\), and let \\((u,v)\\) be the preceding edge in \\(c\\). At time \\(v.d\\), the vertices of \\(c\\) form a path of white vertices from \\(v\\) to \\(u\\). By the white-path theorem, vertex \\(u\\) becomes a descendant of \\(v\\) in the depth-first forest. Therefore, \\((u,v)\\) is a back edge.\n\n_Theorem 20.12_\n\nTopological-Sort produces a topological sort of the directed acyclic graph provided as its input.\n\n_Proof_ Suppose that DFS is run on a given \\(\\text{\\rm{dag}}\\ G=(V,E)\\) to determine finish times for its vertices. It suffices to show that for any pair of distinct vertices \\(u,v\\in V\\), if \\(G\\) contains an edge from \\(u\\) to \\(v\\), then \\(v.f<\\!\\!u\\). \\(f\\). Consider any edge \\((u,v)\\) explored by \\(\\text{\\rm{DFS}}(G)\\). When this edge is explored, \\(v\\) cannot be gray, since then \\(v\\) would be an ancestor of \\(u\\) and \\((u,v)\\) would be a back edge, contradicting Lemma 20.11. Therefore, \\(v\\) must be either white or black. If \\(v\\) is\n\nFigure 20.7: **(a)** Professor Bumstead topologically sorts his clothing when getting dressed. Each directed edge \\((u,v)\\) means that garment \\(u\\) must be put on before garment \\(v\\). The discovery and finish times from a depth-first search are shown next to each vertex. **(b)** The same graph shown topologically sorted, with its vertices arranged from left to right in order of decreasing finish time. All directed edges go from left to right.\n\n#### 20.4.1 Topological sort\n\nThe _topological sort_ of a topological sort is a topological sort, and the _topological sort_ of a topological sort. The _topological sort_ of a topological sort is a topological sort, and the _topological sort_ of a topological sort. The _topological sort_ of a topological sort is a topological sort, and the _topological sort_ of a topological sort is a topological sort. The _topological sort_ of a topological sort is a topological sort, and the _topological sort_ of a topological sort is a topological sort. The _topological sort_ of a topological sort is a topological sort, and the _topological sort_ of a topological sort is a topological sort. The _topological sort_ of a topological sort is a topological sort, and the _topological sort_ of a topological sort is a topological sort. The _topological sort_ of a topological sort is a topological sort, and the _topological sort_ of a topological sort is a topological sort. The _topological sort_ of a topological sort is a topological sort, and the _topological sort_ of a topological sort is a topological sort. The _topological sort_ of a topological sort is a topological sort, and the _topological sort_ of a topological sort is a topological sort. The _topological sort_ of a topological sort is a topological sort, and the _topological sort_ of a topological sort is a topological sort. The _topological sort_ of a topological sort is a topological sort, and the _topological sort_ of a topological sort is a topological sort. The _topological sort_ of a topological sort is a topological sort, and the _topological sort_ of a topological sort is a topological sort. The _topological sort_ of a topological sort is a topological sort, and the _topological sort_ of a topological sort is a topological sort. The _topological sort_ of a topological sort is a topological sort, and the _topological sort_ of a topological sort is a topological sort. The _topological sort_ of a topological sort is a topological sort, and the _topological sort_ of a topological sort is a topological sort. The _topological sort_ of a topological sort is a topological sort, and the _topological sort_ of a topological sort is a topological sort. The _topological sort_ of a topological sort is a topological sort, and the _topological sort_ of a topological sort is a topological sort. The _topological sort_ of a topological sort is a topological sort, and the _topological sort_ of a topological sort is a topological sort. The _topological sort_ of a topological sort is a topological sort, and the _topological sort_ of a topological sort is a topological sort. The _topological sort_ of a topological sort is a topological sort, and the _topological sort_ of a topological sort is a topological sort. The _topological sort_ of a topological sort is a topological sort, and the _topological sort_ of a topological sort is a topological sort. The _topological sort_ of a topological sort is a topological sort, and the _topological sort_ of a topological sort is a topological sort. The _topological sort_ of a topological sort is a topological sort, and the _topological sort_ of a topological sort is a topological sort. The _topological sort_ of a topological sort is a topological sort, and the _topological sort_ of a topological sort is a topological sort. The _topological sort_ of a topological sort is a topological sort, and the _topological sort_ of a topological sort is a topological sort. The _topological sort_ of a topological sort is a topological sort, and the _topological sort_ of a topological sort is a topological sort. The _topological sort_ of a topological sort is a topological sort, and the _topological sort_ of a topological sort is a topological sort. The _topological sort_ of a topological sort is a topological sort, and the _topological sort_ of a topological sort is a topological sort. The _topological sort_ of a topological sort is a topological sort, and the _topological sort_ of a topological sort is a topological sort. The _topological sort_ of a topological sort is a topological sort, and the _topological sort_ of a topological sort is a topological sort. The _topological sort_ of a topological sort is a topological sort, and the _topological sort_ of a topological sort is a topological sort. The _topological sort_ of a topological sort is a topological sort, and the _topological sort_ of a topological sort is a topological sort. The _topological sort_ of a topological sort is a topological sort, and the _topological sort_ of a topological sort is a topological sort. The _topological sort_ of a topological sort is a topological sort, and the _topological sort_ of a topological sort is a topological sort. The _topological sort_ of a topological sort is a topological sort, and the _topological sort_ of a topological sort is a topological sort. The _topological sort_ of a topological sort is a topological sort, and the _topological sort_ of a topological sort is a topological sort. The _topological sort_ of a topological sort is a topological sort, and the _topological sort_ of a topological sort is a topological sort. The _topological sort_ of a topological sort is a topological sort, and the _topological sort_ of a topological sort is a topological sort. The _topological sort_ of a topological sort is a topological sort, and the _topological sort_ of a topological sort is a topological sort. The _topological sort_ of a topological sort is a topological sort, and the _topological sort_ of a topological sort is a topological sort. The _topological sort_ of a topological sort is a topological sort, and the _topological sort_ of a topological sort is a topological sort. The _topological sort_ of a topological sort is a topological sort, and the _topological sort_ of a topological sort is a topological sort. The _topological sort_ of a topological sort is a topological sort, and the _topological sort_ of a topological sort is a topological sort. The _topological sort_ of a topological sort is a topological sort, and the _topological sort_ of a topological sort is a topological sort. The _topological sort_ of a topological sort is a topological sort, and the _topological sort_ of a topological sort is a topological sort. The _topological sort_ of a topological sort is a topological sort, and the _topological sort_ of a topological sort is a topological sort. The _topological sort_ of a topological sort is a topological sort, and the _topological sort_ of a topological sort is a topological sort. The _topological sort_ of a topological sort is a topological sort, and the _topological sort_ of a topological sort is a topological sort. The _topological sort_ of a topological sort is a topological sort, and the _topological sort_ of a topological sort is a topological sort. The _topological sort_ of a topological sort is a topological sort, and the _topological sort_ of a topological sort is a topological sort. The _topological sort_ of a topological sort is a topological sort, and the _topological sort_ of a topological sort is a topological sort. The _topological sort_ of a topological sort is a topological sort, and the _topological sort_ of a topological sort is a topological sort. The _topological sort_ of a topological sort is a topological sort, and the _topological sort_ of a topological sort is a topological sort. The _topological sort_ of a topological sort is a topological sort, and the _topological sort_ of a topological sort is a topological sort. The _topological sort_ of a topological sort is a topological sort, and the _topological sort_ of a topological sort is a topological sort. The _topological sort_ of a topological sort is a topological sort, and the _topological sort_ of a topological sort is a topological sort. The _topological sort_ of a topological sort is a topological sort, and the _topological sort_ of a topological sort is a topological sort. The _topological sort_ of a topological sort is a topological sort, and the _topological sort_ of a topological sort is a topological sort. The _topological sort_ of a topological sort is a topological sort, and the _topological sort_ of a topological sort is a topological sort. The _topological sort_ of a topological sort is a topological sort, and the _topological sort_ of a topological sort is a topological sort. The _topological sort_ of a topological sort is a topological sort, and the _topological sort_ of a topological sort is a topological sort. The _topological sort_ of a topological sort is a topological sort, and the _topological sort_ of a topological sort is a topological sort. The _topological sort_ of a topological sort is a topological sort, and the _topological sort_ of a topological sort is a topological sort. The _topological sort_ of a topological sort is a topological sort, and the _topological sort_ of a topological sort is a topological sort. The _topological sort_ of a topological sort is a topological sort, and the _topological sort_ of a topological sort is a topological sort. The _topological sort_ of a topological sort is a topological sort, and the _topological sort_ of a topological sort is a topological sort. The _topological sort_ of a topological sort is a topological sort, and the _topological sort_ of a topological sort is a topological sort. The _topological sort_ of a topological sort is a topological sort, and the _topological sort_ of a topological sort is a topological sort. The _topological sort_ of a topological sort is a topological sort, and the _topological sort_ of a topological sort is a topological sort. The _topological sort_ of a topological sort is a topological sort, and the _topological sort_ of a topological sort is a topological sort. The _topological sort_ of a topological sort is a topological sort, and the _topological sort_ of a topological sort is a topological sort. The _topological sort_ of a topological sort is a topological sort, and the _topological sort_ of a topological sort is a topological sort. The _topological sort_ of a topological sort is a topological sort, and the _topological sort_ of a topological sort is a topological sort. The _topological sort_ of a topological sort is a topological sort, and the _topological sort_ of a topological sort is a topological sort. The _topological sort_ of a topological sort is a topological sort, and the _topological sort_ of a topological sort is a topological sort. The _topological sort_ of a topological sort is a topological sort, and the _topological sort_ of a topological sort is a topological sort. The _topological sort_ of a topological sort is a topological sort, and the _topological sort_ of a topological sort is a topological sort. The _topological sort_ of a topological sort is a topological sort, and the _topological sort_ of a topological sort is a topological sort. The _topological sort_ of a topological sort is a topological sort, and the _topological sort_ of a topological sort is a topological sort. The _topological sort_ of a topological sort is a topological sort, and the _topological sort_ of a topological sort is a topological sort. The _topological sort_ of a topological sort is a topological sort, and the _topological sort_ of a topological sort is a topological sort. The _topological sort_ of a topological sort is a topological sort, and the _topological sort_ of a topological sort is a topological sort. The _topological sort_ of a topological sort is a topological sort, and the _topological sort_ of a topological sort is a sort, and the _topological sort_ of a topological sort is a sort. The _topological sort_ of a topological sort is a topological sort, and the _topological sort_ of a topological sort is a sort. The _topological sort_ of a topological sort is a sort, and the _topological sort_ of a topological sort is a sort. The _topological sort_ of a sort is a topological sort, and the _topological sort_ of a sort is a topological sort. The _topological sort_ of a sort is a topological sort, and the _topological sort_ of a topological sort is a sort. The _topological sort_ of a sort is a topological sort, and the _topological sort_ of a sort is a topological sort.\n\n#### 20.4-5\n\nAnother way to topologically sort a directed acyclic graph \\(G=(V,E)\\) is to repeatedly find a vertex of in-degree 0, output it, and remove it and all of its outgoing edges from the graph. Explain how to implement this idea so that it runs in time \\(O(V+E)\\). What happens to this algorithm if \\(G\\) has cycles?\n\n### 20.5 Strongly connected components\n\nWe now consider a classic application of depth-first search: decomposing a directed graph into its strongly connected components. This section shows how to do so using two depth-first searches. Many algorithms that work with directed graphs begin with such a decomposition. After decomposing the graph into strongly connected components, such algorithms run separately on each one and then combine the solutions according to the structure of connections among components.\n\nRecall from Appendix B that a strongly connected component of a directed graph \\(G=(V,E)\\) is a maximal set of vertices \\(C\\subseteq V\\) such that for every pair of vertices \\(u,v\\in C\\), both \\(u\\leadsto v\\) and \\(v\\leadsto u\\), that is, vertices \\(u\\) and \\(v\\) are reachable from each other. Figure 20.9 shows an example.\n\nThe algorithm for finding the strongly connected components of a directed graph \\(G=(V,E)\\) uses the transpose of \\(G\\), which we defined in Exercise 20.1-3 to be the graph \\(G^{\\mathrm{T}}=(V,E^{\\mathrm{T}})\\), where \\(E^{\\mathrm{T}}=\\{(u,v):(v,u)\\in E\\}\\). That is, \\(E^{\\mathrm{T}}\\) consists of the edges of \\(G\\) with their directions reversed. Given an adjacency-list representation of \\(G\\), the time to create \\(G^{\\mathrm{T}}\\) is \\(\\Theta(V+E)\\). The graphs \\(G\\) and \\(G^{\\mathrm{T}}\\) have exactly the same strongly connected components: \\(u\\) and \\(v\\) are reachable from each other in \\(G\\) if and only if they are reachable from each other in \\(G^{\\mathrm{T}}\\). Figure 20.9(b) shows the transpose of the graph in Figure 20.9(a), with the strongly connected components shaded blue in both parts.\n\nThe linear-time (i.e., \\(\\Theta(V+E)\\)-time) procedure Strongly-Connected-Components on the next page computes the strongly connected components of a directed graph \\(G=(V,E)\\) using two depth-first searches, one on \\(G\\) and one on \\(G^{\\mathrm{T}}\\).\n\nThe idea behind this algorithm comes from a key property of the _component graph_\\(G^{\\mathrm{SCC}}=(V^{\\mathrm{SCC}},E^{\\mathrm{SCC}})\\), defined as follows. Suppose that \\(G\\) has strongly connected components \\(C_{1},C_{2},\\ldots,C_{k}\\). The vertex set \\(V^{\\mathrm{SCC}}\\) is \\(\\{v_{1},v_{2},\\ldots,v_{k}\\}\\), and it contains one vertex \\(v_{i}\\) for each strongly connected component \\(C_{i}\\) of \\(G\\). There is an edge \\((v_{i},v_{j})\\in E^{\\mathrm{SCC}}\\) if \\(G\\) contains a directed edge \\((x,y)\\) for some \\(x\\in C_{i}\\) and some \\(y\\in C_{j}\\). Looked at another way, if we contract all edges whose incident vertices are within the same strongly connected component of \\(G\\) so that",
        "chapter": "Part VI Graph Algorithms",
        "section": "20 Elementary Graph Algorithms",
        "subsection": "20.4 Topological sort",
        "subsubsection": "N/A"
    },
    {
        "content": "#### 20.4-5\n\nAnother way to topologically sort a directed acyclic graph \\(G=(V,E)\\) is to repeatedly find a vertex of in-degree 0, output it, and remove it and all of its outgoing edges from the graph. Explain how to implement this idea so that it runs in time \\(O(V+E)\\). What happens to this algorithm if \\(G\\) has cycles?\n\n### 20.5 Strongly connected components\n\nWe now consider a classic application of depth-first search: decomposing a directed graph into its strongly connected components. This section shows how to do so using two depth-first searches. Many algorithms that work with directed graphs begin with such a decomposition. After decomposing the graph into strongly connected components, such algorithms run separately on each one and then combine the solutions according to the structure of connections among components.\n\nRecall from Appendix B that a strongly connected component of a directed graph \\(G=(V,E)\\) is a maximal set of vertices \\(C\\subseteq V\\) such that for every pair of vertices \\(u,v\\in C\\), both \\(u\\leadsto v\\) and \\(v\\leadsto u\\), that is, vertices \\(u\\) and \\(v\\) are reachable from each other. Figure 20.9 shows an example.\n\nThe algorithm for finding the strongly connected components of a directed graph \\(G=(V,E)\\) uses the transpose of \\(G\\), which we defined in Exercise 20.1-3 to be the graph \\(G^{\\mathrm{T}}=(V,E^{\\mathrm{T}})\\), where \\(E^{\\mathrm{T}}=\\{(u,v):(v,u)\\in E\\}\\). That is, \\(E^{\\mathrm{T}}\\) consists of the edges of \\(G\\) with their directions reversed. Given an adjacency-list representation of \\(G\\), the time to create \\(G^{\\mathrm{T}}\\) is \\(\\Theta(V+E)\\). The graphs \\(G\\) and \\(G^{\\mathrm{T}}\\) have exactly the same strongly connected components: \\(u\\) and \\(v\\) are reachable from each other in \\(G\\) if and only if they are reachable from each other in \\(G^{\\mathrm{T}}\\). Figure 20.9(b) shows the transpose of the graph in Figure 20.9(a), with the strongly connected components shaded blue in both parts.\n\nThe linear-time (i.e., \\(\\Theta(V+E)\\)-time) procedure Strongly-Connected-Components on the next page computes the strongly connected components of a directed graph \\(G=(V,E)\\) using two depth-first searches, one on \\(G\\) and one on \\(G^{\\mathrm{T}}\\).\n\nThe idea behind this algorithm comes from a key property of the _component graph_\\(G^{\\mathrm{SCC}}=(V^{\\mathrm{SCC}},E^{\\mathrm{SCC}})\\), defined as follows. Suppose that \\(G\\) has strongly connected components \\(C_{1},C_{2},\\ldots,C_{k}\\). The vertex set \\(V^{\\mathrm{SCC}}\\) is \\(\\{v_{1},v_{2},\\ldots,v_{k}\\}\\), and it contains one vertex \\(v_{i}\\) for each strongly connected component \\(C_{i}\\) of \\(G\\). There is an edge \\((v_{i},v_{j})\\in E^{\\mathrm{SCC}}\\) if \\(G\\) contains a directed edge \\((x,y)\\) for some \\(x\\in C_{i}\\) and some \\(y\\in C_{j}\\). Looked at another way, if we contract all edges whose incident vertices are within the same strongly connected component of \\(G\\) so thatonly a single vertex remains, the resulting graph is \\(G^{\\mathrm{SCC}}\\). Figure 20.9(c) shows the component graph of the graph in Figure 20.9(a).\n\nThe following lemma gives the key property that the component graph is acyclic. We'll see that the algorithm uses this property to visit the vertices of the component graph in topologically sorted order, by considering vertices in the second depth-first search in decreasing order of the finish times that were computed in the first depth-first search.\n\nFigure 20.9: **(a)** A directed graph \\(G\\). Each region shaded light blue is a strongly connected component of \\(G\\). Each vertex is labeled with its discovery and finish times in a depth-first search, and tree edges are dark blue. **(b)** The graph \\(G^{\\mathrm{T}}\\), the transpose of \\(G\\), with the depth-first forest computed in line 3 of Strongly-Connected-Components shown and tree edges shaded dark blue. Each strongly connected component corresponds to one depth-first tree. Orange vertices \\(b,c,g,\\) and \\(h\\) are the roots of the depth-first trees produced by the depth-first search of \\(G^{\\mathrm{T}}\\). **(c)** The acyclic component graph \\(G^{\\mathrm{SCC}}\\) obtained by contracting all edges within each strongly connected component of \\(G\\) so that only a single vertex remains in each component.\n\n**Lemma 20.13**: _Let \\(C\\) and \\(C^{\\prime}\\) be distinct strongly connected components in directed graph \\(G=(V,E)\\), let \\(u,v\\in C\\), let \\(u^{\\prime},v^{\\prime}\\in C^{\\prime}\\), and suppose that \\(G\\) contains a path \\(u\\leadsto u^{\\prime}\\). Then \\(G\\) cannot also contain a path \\(v^{\\prime}\\leadsto v\\)._\n\n_Proof_ If \\(G\\) contains a path \\(v^{\\prime}\\leadsto v\\), then it contains paths \\(u\\leadsto u^{\\prime}\\leadsto v^{\\prime}\\) and \\(v^{\\prime}\\leadsto v\\leadsto u\\). Thus, \\(u\\) and \\(v^{\\prime}\\) are reachable from each other, thereby contradicting the assumption that \\(C\\) and \\(C^{\\prime}\\) are distinct strongly connected components.\n\nBecause the Strongly-Connected-Components procedure performs two depth-first searches, there are two distinct sets of discovery and finish times. In this section, discovery and finish times always refer to those computed by the _first_ call of DFS, in line 1.\n\nThe notation for discovery and finish times extends to sets of vertices. For a subset \\(U\\) of vertices, \\(d(U)\\) and \\(f(U)\\) are the earliest discovery time and latest finish time, respectively, of any vertex in \\(U\\): \\(d(U)=\\min\\left\\{u.d:u\\in U\\right\\}\\) and \\(f(U)=\\max\\left\\{u.f:u\\in U\\right\\}\\).\n\nThe following lemma and its corollary give a key property relating strongly connected components and finish times in the first depth-first search.\n\n**Lemma 20.14**: _Let \\(C\\) and \\(C^{\\prime}\\) be distinct strongly connected components in directed graph \\(G=(V,E)\\). Suppose that there is an edge \\((u,v)\\in E\\), where \\(u\\in C^{\\prime}\\) and \\(v\\in C\\). Then \\(f(C^{\\prime})>f(C)\\)._\n\n_Proof_ We consider two cases, depending on which strongly connected component, \\(C\\) or \\(C^{\\prime}\\), had the first discovered vertex during the first depth-first search.\n\nIf \\(d(C^{\\prime})<d(C)\\), let \\(x\\) be the first vertex discovered in \\(C^{\\prime}\\). At time \\(x.d\\), all vertices in \\(C\\) and \\(C^{\\prime}\\) are white. At that time, \\(G\\) contains a path from \\(x\\) to each vertex in \\(C^{\\prime}\\) consisting only of white vertices. Because \\((u,v)\\in E\\), for any vertex \\(w\\in C\\), there is also a path in \\(G\\) at time \\(x.d\\) from \\(x\\) to \\(w\\) consisting only of white vertices: \\(x\\leadsto u\\to v\\leadsto w\\). By the white-path theorem, all vertices in \\(C\\) and \\(C^{\\prime}\\) become descendants of \\(x\\) in the depth-first tree. By Corollary 20.8, \\(x\\) has the latest finish time of any of its descendants, and so \\(x.f=f(C^{\\prime})>f(C)\\).\n\nOtherwise, \\(d(C^{\\prime})>d(C)\\). Let \\(y\\) be the first vertex discovered in \\(C\\), so that \\(y.d=d(C)\\). At time \\(y.d\\), all vertices in \\(C\\) are white and \\(G\\) contains a path from \\(y\\) to each vertex in \\(C\\) consisting only of white vertices. By the white-path theorem, all vertices in \\(C\\) become descendants of \\(y\\) in the depth-first tree, and by Corollary 20.8, \\(y.f=f(C)\\). Because \\(d(C^{\\prime})>d(C)=y.d\\), all vertices in \\(C^{\\prime}\\) are white at time \\(y.d\\). Since there is an edge \\((u,v)\\) from \\(C^{\\prime}\\) to \\(C\\), Lemma 20.13 implies that there cannot be a path from \\(C\\) to \\(C^{\\prime}\\). Hence, no vertex in \\(C^{\\prime}\\) is reachablefrom \\(y\\). At time \\(y.f\\), therefore, all vertices in \\(C^{\\prime}\\) are still white. Thus, for any vertex \\(w\\in C^{\\prime}\\), we have \\(w.f>y.f\\), which implies that \\(f(C^{\\prime})>f(C)\\).\n\n_Corollary 20.15_: Let \\(C\\) and \\(C^{\\prime}\\) be distinct strongly connected components in directed graph \\(G=(V,E)\\), and suppose that \\(f(C)>f(C^{\\prime})\\). Then \\(E^{\\mathrm{T}}\\) contains no edge \\((v,u)\\) such that \\(u\\in C^{\\prime}\\) and \\(v\\in C\\).\n\n_Proof_ The contrapositive of Lemma 20.14 says that if \\(f(C^{\\prime})<f(C)\\), then there is no edge \\((u,v)\\in E\\) such that \\(u\\in C^{\\prime}\\) and \\(v\\in C\\). Because the strongly connected components of \\(G\\) and \\(G^{\\mathrm{T}}\\) are the same, if there is no such edge \\((u,v)\\in E\\), then there is no edge \\((v,u)\\in E^{\\mathrm{T}}\\) such that \\(u\\in C^{\\prime}\\) and \\(v\\in C\\).\n\nCorollary 20.15 provides the key to understanding why the strongly connected components algorithm works. Let's examine what happens during the second depth-first search, which is on \\(G^{\\mathrm{T}}\\). The search starts from the vertex \\(x\\) whose finish time from the first depth-first search is maximum. This vertex belongs to some strongly connected component \\(C\\), and since \\(x.f\\) is maximum, \\(f(C)\\) is maximum over all strongly connected components. When the search starts from \\(x\\), it visits all vertices in \\(C\\). By Corollary 20.15, \\(G^{\\mathrm{T}}\\) contains no edges from \\(C\\) to any other strongly connected component, and so the search from \\(x\\) never visits vertices in any other component. Thus, the tree rooted at \\(x\\) contains exactly the vertices of \\(C\\). Having completed visiting all vertices in \\(C\\), the second depth-first search selects as a new root a vertex from some other strongly connected component \\(C^{\\prime}\\) whose finish time \\(f(C^{\\prime})\\) is maximum over all components other than \\(C\\). Again, the search visits all vertices in \\(C^{\\prime}\\). But by Corollary 20.15, if any edges in \\(G^{\\mathrm{T}}\\) go from \\(C^{\\prime}\\) to any other component, they must go to \\(C\\), which the second depth-first search has already visited. In general, when the depth-first search of \\(G^{\\mathrm{T}}\\) in line 3 visits any strongly connected component, any edges out of that component must be to components that the search has already visited. Each depth-first tree, therefore, corresponds to exactly one strongly connected component. The following theorem formalizes this argument.\n\n_Theorem 20.16_: The Strongly-Connected-Components procedure correctly computes the strongly connected components of the directed graph \\(G\\) provided as its input.\n\n_Proof_ We argue by induction on the number of depth-first trees found in the depth-first search of \\(G^{\\mathrm{T}}\\) in line 3 that the vertices of each tree form a strongly connected component. The inductive hypothesis is that the first \\(k\\) trees produced in line 3 are strongly connected components. The basis for the induction, when \\(k=0\\), is trivial.\n\nIn the inductive step, we assume that each of the first \\(k\\) depth-first trees produced in line 3 is a strongly connected component, and we consider the (\\(k+1\\))st tree produced. Let the root of this tree be vertex \\(u\\), and let \\(u\\) be in strongly connected component \\(C\\). Because of how the depth-first search chooses roots in line 3, \\(u.f=f(C)>f(C^{\\prime})\\) for any strongly connected component \\(C^{\\prime}\\) other than \\(C\\) that has yet to be visited. By the inductive hypothesis, at the time that the search visits \\(u\\), all other vertices of \\(C\\) are white. By the white-path theorem, therefore, all other vertices of \\(C\\) are descendants of \\(u\\) in its depth-first tree. Moreover, by the inductive hypothesis and by Corollary 20.15, any edges in \\(G^{\\mathrm{T}}\\) that leave \\(C\\) must be to strongly connected components that have already been visited. Thus, no vertex in any strongly connected component other than \\(C\\) is a descendant of \\(u\\) during the depth-first search of \\(G^{\\mathrm{T}}\\). The vertices of the depth-first tree in \\(G^{\\mathrm{T}}\\) that is rooted at \\(u\\) form exactly one strongly connected component, which completes the inductive step and the proof.\n\nHere is another way to look at how the second depth-first search operates. Consider the component graph \\((G^{\\mathrm{T}})^{\\mathrm{SCC}}\\) of \\(G^{\\mathrm{T}}\\). If you map each strongly connected component visited in the second depth-first search to a vertex of \\((G^{\\mathrm{T}})^{\\mathrm{SCC}}\\), the second depth-first search visits vertices of \\((G^{\\mathrm{T}})^{\\mathrm{SCC}}\\) in the reverse of a topologically sorted order. If you reverse the edges of \\((G^{\\mathrm{T}})^{\\mathrm{SCC}}\\), you get the graph \\(((G^{\\mathrm{T}})^{\\mathrm{SCC}})^{\\mathrm{T}}\\). Because \\(((G^{\\mathrm{T}})^{\\mathrm{SCC}})^{\\mathrm{T}}=G^{\\mathrm{SCC}}\\) (see Exercise 20.5-4), the second depth-first search visits the vertices of \\(G^{\\mathrm{SCC}}\\) in topologically sorted order.\n\n##### Exercises\n\n##### 20.5-1\n\nHow can the number of strongly connected components of a graph change if a new edge is added?\n\n##### 20.5-2\n\nShow how the procedure Strongly-Connected-Components works on the graph of Figure 20.6. Specifically, show the finish times computed in line 1 and the forest produced in line 3. Assume that the loop of lines 5-7 of DFS considers vertices in alphabetical order and that the adjacency lists are in alphabetical order.\n\n##### 20.5-3\n\nProfessor Bacon rewrites the algorithm for strongly connected components to use the original (instead of the transpose) graph in the second depth-first search and scan the vertices in order of _increasing_ finish times. Does this modified algorithm always produce correct results?\n\n#### 20.5-4\n\nProve that for any directed graph \\(G\\), the transpose of the component graph of \\(G^{\\mathrm{T}}\\) is the same as the component graph of \\(G\\). That is, \\(((G^{\\mathrm{T}})^{\\mathrm{SCC}})^{\\mathrm{T}}=G^{\\mathrm{SCC}}\\).\n\n#### 20.5-5\n\nGive an \\(O(V+E)\\)-time algorithm to compute the component graph of a directed graph \\(G=(V,E)\\). Make sure that there is at most one edge between two vertices in the component graph your algorithm produces.\n\n#### 20.5-6\n\nGive an \\(O(V+E)\\)-time algorithm that, given a directed graph \\(G=(V,E)\\), constructs another graph \\(G^{\\prime}=(V,E^{\\prime})\\) such that \\(G\\) and \\(G^{\\prime}\\) have the same strongly connected components, \\(G^{\\prime}\\) has the same component graph as \\(G\\), and \\(|E^{\\prime}|\\) is as small as possible.\n\n#### 20.5-7\n\nA directed graph \\(G=(V,E)\\) is _semiconnected_ if, for all pairs of vertices \\(u\\), \\(v\\in V\\), we have \\(u\\leadsto v\\) or \\(v\\leadsto u\\). Give an efficient algorithm to determine whether \\(G\\) is semiconnected. Prove that your algorithm is correct, and analyze its running time.\n\n#### 20.5-8\n\nLet \\(G=(V,E)\\) be a directed graph, and let \\(l:V\\to\\mathbb{R}\\) be a function that assigns a real-valued label \\(l\\) to each vertex. For vertices \\(s,t\\in V\\), define\n\n\\[\\Delta l(s,t)=\\left\\{\\begin{array}{ll}l(t)-l(s)&\\mbox{if there is a path from $s$ to $t$ in $G$ },\\\\ -\\infty&\\mbox{otherwise }.\\end{array}\\right.\\]\n\nGive an \\(O(V+E)\\)-time algorithm to find vertices \\(s\\) and \\(t\\) such that \\(\\Delta l(s,t)\\) is maximum over all pairs of vertices. (_Hint:_ Use Exercise 20.5-5.)\n\n## Problems\n\n### 20-1 Classifying edges by breadth-first search\n\nA depth-first forest classifies the edges of a graph into tree, back, forward, and cross edges. A breadth-first tree can also be used to classify the edges reachable from the source of the search into the same four categories.",
        "chapter": "Part VI Graph Algorithms",
        "section": "20 Elementary Graph Algorithms",
        "subsection": "20.5 Strongly connected components",
        "subsubsection": "N/A"
    },
    {
        "content": "scan the vertices in order of _increasing_ finish times. Does this modified algorithm always produce correct results?\n\n#### 20.5-4\n\nProve that for any directed graph \\(G\\), the transpose of the component graph of \\(G^{\\mathrm{T}}\\) is the same as the component graph of \\(G\\). That is, \\(((G^{\\mathrm{T}})^{\\mathrm{SCC}})^{\\mathrm{T}}=G^{\\mathrm{SCC}}\\).\n\n#### 20.5-5\n\nGive an \\(O(V+E)\\)-time algorithm to compute the component graph of a directed graph \\(G=(V,E)\\). Make sure that there is at most one edge between two vertices in the component graph your algorithm produces.\n\n#### 20.5-6\n\nGive an \\(O(V+E)\\)-time algorithm that, given a directed graph \\(G=(V,E)\\), constructs another graph \\(G^{\\prime}=(V,E^{\\prime})\\) such that \\(G\\) and \\(G^{\\prime}\\) have the same strongly connected components, \\(G^{\\prime}\\) has the same component graph as \\(G\\), and \\(|E^{\\prime}|\\) is as small as possible.\n\n#### 20.5-7\n\nA directed graph \\(G=(V,E)\\) is _semiconnected_ if, for all pairs of vertices \\(u,v\\in V\\), we have \\(u\\leadsto v\\) or \\(v\\leadsto u\\). Give an efficient algorithm to determine whether \\(G\\) is semiconnected. Prove that your algorithm is correct, and analyze its running time.\n\n#### 20.5-8\n\nLet \\(G=(V,E)\\) be a directed graph, and let \\(l:V\\to\\mathbb{R}\\) be a function that assigns a real-valued label \\(l\\) to each vertex. For vertices \\(s,t\\in V\\), define\n\n\\[\\Delta l(s,t)=\\left\\{\\begin{array}{ll}l(t)-l(s)&\\mbox{if there is a path from $s$ to $t$ in $G$ },\\\\ -\\infty&\\mbox{otherwise }.\\end{array}\\right.\\]\n\nGive an \\(O(V+E)\\)-time algorithm to find vertices \\(s\\) and \\(t\\) such that \\(\\Delta l(s,t)\\) is maximum over all pairs of vertices. (_Hint:_ Use Exercise 20.5-5.)\n\n## Problems\n\n### 20-1 Classifying edges by breadth-first search\n\nA depth-first forest classifies the edges of a graph into tree, back, forward, and cross edges. A breadth-first tree can also be used to classify the edges reachable from the source of the search into the same four categories.\n\n* Prove that in a breadth-first search of an undirected graph, the following properties hold: 1. There are no back edges and no forward edges. 2. If \\((u,v)\\) is a tree edge, then \\(v.d=u.d+1\\). 3. If \\((u,v)\\) is a cross edge, then \\(v.d=u.d\\) or \\(v.d=u.d+1\\).\n* Prove that in a breadth-first search of a directed graph, the following properties hold: 1. There are no forward edges. 2. If \\((u,v)\\) is a tree edge, then \\(v.d=u.d+1\\). 3. If \\((u,v)\\) is a cross edge, then \\(v.d\\leq u.d+1\\). 4. If \\((u,v)\\) is a back edge, then \\(0\\leq v.d\\leq u.d\\).\n\n#### 20.2 **Articulation points**, bridges, and biconnected components\n\nLet \\(G=(V,E)\\) be a connected, undirected graph. An _articulation point_ of \\(G\\) is a vertex whose removal disconnects \\(G\\). A _bridge_ of \\(G\\) is an edge whose removal disconnects \\(G\\). A _biconnected component_ of \\(G\\) is a maximal set of edges such that any two edges in the set lie on a common simple cycle. Figure 20.10 illustrates these definitions. You can determine articulation points, bridges, and biconnected components using depth-first search. Let \\(G_{\\pi}=(V,E_{\\pi})\\) be a depth-first tree of \\(G\\).\n\n* Prove that the root of \\(G_{\\pi}\\) is an articulation point of \\(G\\) if and only if it has at least two children in \\(G_{\\pi}\\).\n\nFigure 20.10: The articulation points, bridges, and biconnected components of a connected, undirected graph for use in Problem 20.2. The articulation points are the orange vertices, the bridges are the dark blue edges, and the biconnected components are the edges in the light blue regions, with a _bcc_ numbering shown.\n\n_b._ Let \\(v\\) be a nonroot vertex of \\(G_{\\pi}\\). Prove that \\(v\\) is an articulation point of \\(G\\) if and only if \\(v\\) has a child \\(s\\) such that there is no back edge from \\(s\\) or any descendant of \\(s\\) to a proper ancestor of \\(v\\). _c._ Let\n\n\\[v.\\mathit{low}=\\min\\left\\{\\begin{array}{l}v.d\\;,\\\\ w.d:(u,w)\\mbox{ is a back edge for some descendant $u$ of $v$}\\;.\\end{array}\\right.\\]\n\nShow how to compute \\(v.\\mathit{low}\\) for all vertices \\(v\\in V\\) in \\(O(E)\\) time. _d._ Show how to compute all articulation points in \\(O(E)\\) time. _e._ Prove that an edge of \\(G\\) is a bridge if and only if it does not lie on any simple cycle of \\(G\\). _f._ Show how to compute all the bridges of \\(G\\) in \\(O(E)\\) time. _g._ Prove that the biconnected components of \\(G\\) partition the nonbridge edges of \\(G\\). _h._ Give an \\(O(E)\\)-time algorithm to label each edge \\(e\\) of \\(G\\) with a positive integer \\(e.\\mathit{bcc}\\) such that \\(e.\\mathit{bcc}=e^{\\prime}.\\mathit{bcc}\\) if and only if \\(e\\) and \\(e^{\\prime}\\) belong to the same biconnected component.\n\n_20-3 Euler tour_\n\nAn \\(\\boldsymbol{Euler}\\) of a strongly connected, directed graph \\(G=(V,E)\\) is a cycle that traverses each edge of \\(G\\) exactly once, although it may visit a vertex more than once.\n\n_a._ Show that \\(G\\) has an Euler tour if and only if in-degree\\((v)=\\mbox{out-degree}(v)\\) for each vertex \\(v\\in V\\). _b._ Describe an \\(O(E)\\)-time algorithm to find an Euler tour of \\(G\\) if one exists. (_Hint:_ Merge edge-disjoint cycles.)\n\n_20-4 Reachability_\n\nLet \\(G=(V,E)\\) be a directed graph in which each vertex \\(u\\in V\\) is labeled with a unique integer \\(L(u)\\) from the set \\(\\{1,2,\\ldots,|V|\\}\\). For each vertex \\(u\\in V\\), let \\(R(u)=\\{v\\in V:u\\leadsto v\\}\\) be the set of vertices that are reachable from \\(u\\). Define \\(\\min(u)\\) to be the vertex in \\(R(u)\\) whose label is minimum, that is, \\(\\min(u)\\) is the vertex \\(v\\) such that \\(L(v)=\\min\\left\\{L(w):w\\in R(u)\\right\\}\\). Give an \\(O(V+E)\\)-time algorithm that computes \\(\\min(u)\\) for all vertices \\(u\\in V\\).\n\n#### 20.5 Inserting and querying vertices in planar graphs\n\nA _planar_ graph is an undirected graph that can be drawn in the plane with no edges crossing. Euler proved that every planar graph has \\(|E|<3\\,|V|\\).\n\nConsider the following two operations on a planar graph \\(G\\):\n\n* Insert(\\(G,v,\\mathit{neighbors}\\)) inserts a new vertex \\(v\\) into \\(G\\), where _neighbors_ is an array (possibly empty) of vertices that have already been inserted into \\(G\\) and will become all the neighbors of \\(v\\) in \\(G\\) when \\(v\\) is inserted.\n* Newest-Neighbor(\\(G,v\\)) returns the neighbor of vertex \\(v\\) that was most recently inserted into \\(G\\), or nil if \\(v\\) has no neighbors.\n\nDesign a data structure that supports these two operations such that Newest-Neighbor takes \\(O(1)\\) worst-case time and Insert takes \\(O(1)\\) amortized time. Note that the length of the array _neighbors_ given to Insert may vary. (_Hint:_ Use a potential function for the amortized analysis.)\n\n## Chapter notes\n\nEven [137] and Tarjan [429] are excellent references for graph algorithms.\n\nBreadth-first search was discovered by Moore [334] in the context of finding paths through mazes. Lee [280] independently discovered the same algorithm in the context of routing wires on circuit boards.\n\nHopcroft and Tarjan [226] advocated the use of the adjacency-list representation over the adjacency-matrix representation for sparse graphs and were the first to recognize the algorithmic importance of depth-first search. Depth-first search has been widely used since the late 1950s, especially in artificial intelligence programs.\n\nTarjan [426] gave a linear-time algorithm for finding strongly connected components. The algorithm for strongly connected components in Section 20.5 is adapted from Aho, Hopcroft, and Ullman [6], who credit it to S. R. Kosaraju (unpublished) and Sharir [408]. Dijkstra [117, Chapter 25] also developed an algorithm for strongly connected components that is based on contracting cycles. Subsequently, Gabow [163] rediscovered this algorithm. Knuth [259] was the first to give a linear-time algorithm for topological sorting.",
        "chapter": "Part VI Graph Algorithms",
        "section": "20 Elementary Graph Algorithms",
        "subsection": "Problems",
        "subsubsection": "N/A"
    },
    {
        "content": "#### 20.5 Inserting and querying vertices in planar graphs\n\nA _planar_ graph is an undirected graph that can be drawn in the plane with no edges crossing. Euler proved that every planar graph has \\(|E|<3\\,|V|\\).\n\nConsider the following two operations on a planar graph \\(G\\):\n\n* Insert(\\(G,v,\\mathit{neighbors}\\)) inserts a new vertex \\(v\\) into \\(G\\), where _neighbors_ is an array (possibly empty) of vertices that have already been inserted into \\(G\\) and will become all the neighbors of \\(v\\) in \\(G\\) when \\(v\\) is inserted.\n* Newest-Neighbor(\\(G,v\\)) returns the neighbor of vertex \\(v\\) that was most recently inserted into \\(G\\), or nil if \\(v\\) has no neighbors.\n\nDesign a data structure that supports these two operations such that Newest-Neighbor takes \\(O(1)\\) worst-case time and Insert takes \\(O(1)\\) amortized time. Note that the length of the array _neighbors_ given to Insert may vary. (_Hint:_ Use a potential function for the amortized analysis.)\n\n## Chapter notes\n\nEven [137] and Tarjan [429] are excellent references for graph algorithms.\n\nBreadth-first search was discovered by Moore [334] in the context of finding paths through mazes. Lee [280] independently discovered the same algorithm in the context of routing wires on circuit boards.\n\nHopcroft and Tarjan [226] advocated the use of the adjacency-list representation over the adjacency-matrix representation for sparse graphs and were the first to recognize the algorithmic importance of depth-first search. Depth-first search has been widely used since the late 1950s, especially in artificial intelligence programs.\n\nTarjan [426] gave a linear-time algorithm for finding strongly connected components. The algorithm for strongly connected components in Section 20.5 is adapted from Aho, Hopcroft, and Ullman [6], who credit it to S. R. Kosaraju (unpublished) and Sharir [408]. Dijkstra [117, Chapter 25] also developed an algorithm for strongly connected components that is based on contracting cycles. Subsequently, Gabow [163] rediscovered this algorithm. Knuth [259] was the first to give a linear-time algorithm for topological sorting.\n\n## Chapter 2 Minimum Spanning Trees\n\n### 2.1 Introduction\n\nThe _minimum spanning tree_ is a _minimum spanning tree_, which is a _minimum spanning tree_. The minimum spanning tree is a _minimum spanning tree_.",
        "chapter": "Part VI Graph Algorithms",
        "section": "20 Elementary Graph Algorithms",
        "subsection": "Chapter notes",
        "subsubsection": "N/A"
    },
    {
        "content": "The two algorithms are greedy algorithms, as described in Chapter 15. Each step of a greedy algorithm must make one of several possible choices. The greedy strategy advocates making the choice that is the best at the moment. Such a strategy does not generally guarantee that it always finds globally optimal solutions to problems. For the minimum-spanning-tree problem, however, we can prove that certain greedy strategies do yield a spanning tree with minimum weight. Although you can read this chapter independently of Chapter 15, the greedy methods presented here are a classic application of the theoretical notions introduced there.\n\nSection 21.1 introduces a \"generic\" minimum-spanning-tree method that grows a spanning tree by adding one edge at a time. Section 21.2 gives two algorithms that implement the generic method. The first algorithm, due to Kruskal, is similar to the connected-components algorithm from Section 19.1. The second, due to Prim, resembles Dijkstra's shortest-paths algorithm (Section 22.3).\n\nBecause a tree is a type of graph, in order to be precise we must define a tree in terms of not just its edges, but its vertices as well. Because this chapter focuses on trees in terms of their edges, we'll implicitly understand that the vertices of a tree \\(T\\) are those that some edge of \\(T\\) is incident on.\n\n### Growing a minimum spanning tree\n\nThe input to the minimum-spanning-tree problem is a connected, undirected graph \\(G=(V,E)\\) with a weight function \\(w:E\\to\\mathbb{R}\\). The goal is to find a minimum spanning tree for \\(G\\). The two algorithms considered in this chapter use a greedy approach to the problem, although they differ in how they apply this approach.\n\nThis greedy strategy is captured by the procedure Generic-MST on the facing page, which grows the minimum spanning tree one edge at a time. The generic method manages a set \\(A\\) of edges, maintaining the following loop invariant:\n\nPrior to each iteration, \\(A\\) is a subset of some minimum spanning tree.\n\nFigure 21: A minimum spanning tree for a connected graph. The weights on edges are shown, and the blue edges form a minimum spanning tree. The total weight of the tree shown is 37. This minimum spanning tree is not unique: removing the edge \\((b,c)\\) and replacing it with the edge \\((a,h)\\) yields another spanning tree with weight 37.\n\n### Growing a minimum spanning tree\n\nGeneric-MST(\\(G,w\\))\n\n```\n1\\(A=\\emptyset\\)\n2while\\(A\\) does not form a spanning tree\n3 find an edge \\((u,v)\\) that is safe for \\(A\\)\n4\\(A=A\\cup\\{(u,v)\\}\\)\n5return\\(A\\)\n```\n\nEach step determines an edge \\((u,v)\\) that the procedure can add to \\(A\\) without violating this invariant, in the sense that \\(A\\cup\\{(u,v)\\}\\) is also a subset of a minimum spanning tree. We call such an edge a _safe edge_ for \\(A\\), since it can be added safely to \\(A\\) while maintaining the invariant.\n\nThis generic algorithm uses the loop invariant as follows:\n\n**Initialization:**: After line 1, the set \\(A\\) trivially satisfies the loop invariant.\n**Maintenance:**: The loop in lines 2-4 maintains the invariant by adding only safe edges.\n**Termination:**: All edges added to \\(A\\) belong to a minimum spanning tree, and the loop must terminate by the time it has considered all edges. Therefore, the set \\(A\\) returned in line 5 must be a minimum spanning tree.\n\nThe tricky part is, of course, finding a safe edge in line 3. One must exist, since when line 3 is executed, the invariant dictates that there is a spanning tree \\(T\\) such that \\(A\\subseteq T\\). Within the **while** loop body, \\(A\\) must be a proper subset of \\(T\\), and therefore there must be an edge \\((u,v)\\in T\\) such that \\((u,v)\\notin A\\) and \\((u,v)\\) is safe for \\(A\\).\n\nThe remainder of this section provides a rule (Theorem 21.1) for recognizing safe edges. The next section describes two algorithms that use this rule to find safe edges efficiently.\n\nWe first need some definitions. A _cut_ (\\(S,V-S\\)) of an undirected graph \\(G=(V,E)\\) is a partition of \\(V\\). Figure 21 illustrates this notion. We say that an edge \\((u,v)\\in E\\)_crosses_ the cut (\\(S,V-S\\)) if one of its endpoints belongs to \\(S\\) and the other belongs to \\(V-S\\). A cut _respects_ a set \\(A\\) of edges if no edge in \\(A\\) crosses the cut. An edge is a _light edge_ crossing a cut if its weight is the minimum of any edge crossing the cut. There can be more than one light edge crossing a cut in the case of ties. More generally, we say that an edge is a _light edge_ satisfying a given property if its weight is the minimum of any edge satisfying the property.\n\nThe following theorem gives the rule for recognizing safe edges.\n\n**Theorem 21.1**: Let \\(G=(V,E)\\) be a connected, undirected graph with a real-valued weight function \\(w\\) defined on \\(E\\). Let \\(A\\) be a subset of \\(E\\) that is included in some minimumspanning tree for \\(G\\), let \\((S,V-S)\\) be any cut of \\(G\\) that respects \\(A\\), and let \\((u,v)\\) be a light edge crossing \\((S,V-S)\\). Then, edge \\((u,v)\\) is safe for \\(A\\).\n\n_Proof_ Let \\(T\\) be a minimum spanning tree that includes \\(A\\), and assume that \\(T\\) does not contain the light edge \\((u,v)\\), since if it does, we are done. We'll construct another minimum spanning tree \\(T^{\\prime}\\) that includes \\(A\\cup\\{(u,v)\\}\\) by using a cut-and-paste technique, thereby showing that \\((u,v)\\) is a safe edge for \\(A\\).\n\nThe edge \\((u,v)\\) forms a cycle with the edges on the simple path \\(p\\) from \\(u\\) to \\(v\\) in \\(T\\), as Figure 21 illustrates. Since \\(u\\) and \\(v\\) are on opposite sides of the cut \\((S,V-S)\\), at least one edge in \\(T\\) lies on the simple path \\(p\\) and also crosses the cut. Let \\((x,y)\\) be any such edge. The edge \\((x,y)\\) is not in \\(A\\), because the cut respects \\(A\\). Since \\((x,y)\\) is on the unique simple path from \\(u\\) to \\(v\\) in \\(T\\), removing \\((x,y)\\) breaks \\(T\\) into two components. Adding \\((u,v)\\) reconnects them to form a new spanning tree \\(T^{\\prime}=(T-\\{(x,y)\\})\\cup\\{(u,v)\\}\\).\n\nWe next show that \\(T^{\\prime}\\) is a minimum spanning tree. Since \\((u,v)\\) is a light edge crossing \\((S,V-S)\\) and \\((x,y)\\) also crosses this cut, \\(w(u,v)\\leq w(x,y)\\). Therefore,\n\n\\[w(T^{\\prime}) = w(T)-w(x,y)+w(u,v)\\] \\[\\leq w(T)\\.\\]\n\nBut \\(T\\) is a minimum spanning tree, so that \\(w(T)\\leq w(T^{\\prime})\\), and thus, \\(T^{\\prime}\\) must be a minimum spanning tree as well.\n\nIt remains to show that \\((u,v)\\) is actually a safe edge for \\(A\\). We have \\(A\\subseteq T^{\\prime}\\), since \\(A\\subseteq T\\) and \\((x,y)\\notin A\\), and thus, \\(A\\cup\\{(u,v)\\}\\subseteq T^{\\prime}\\). Consequently, since \\(T^{\\prime}\\) is a minimum spanning tree, \\((u,v)\\) is safe for \\(A\\).\n\nTheorem 21 provides insight into how the Generic-MST method works on a connected graph \\(G=(V,E)\\). As the method proceeds, the set \\(A\\) is always acyclic, since it is a subset of a minimum spanning tree and a tree may not contain a cycle.\n\nFigure 21: A cut \\((S,V-S)\\) of the graph from Figure 21. Orange vertices belong to the set \\(S\\), and tan vertices belong to \\(V-S\\). The edges crossing the cut are those connecting tan vertices with orange vertices. The edge \\((d,c)\\) is the unique light edge crossing the cut. Blue edges form a subset \\(A\\) of the edges. The cut \\((S,V-S)\\) respects \\(A\\), since no edge of \\(A\\) crosses the cut.\n\n### Growing a minimum spanning tree\n\nAt any point in the execution, the graph \\(G_{A}=(V,A)\\) is a forest, and each of the connected components of \\(G_{A}\\) is a tree. (Some of the trees may contain just one vertex, as is the case, for example, when the method begins: \\(A\\) is empty and the forest contains \\(|V|\\) trees, one for each vertex.) Moreover, any safe edge \\((u,v)\\) for \\(A\\) connects distinct components of \\(G_{A}\\), since \\(A\\cup\\{(u,v)\\}\\) must be acyclic.\n\nThe **while** loop in lines 2-4 of Generic-MST executes \\(|V|-1\\) times because it finds one of the \\(|V|-1\\) edges of a minimum spanning tree in each iteration. Initially, when \\(A=\\emptyset\\), there are \\(|V|\\) trees in \\(G_{A}\\), and each iteration reduces that number by 1. When the forest contains only a single tree, the method terminates.\n\nThe two algorithms in Section 21.2 use the following corollary to Theorem 21.1.\n\n**Corollary 21.2**: Let \\(G=(V,E)\\) be a connected, undirected graph with a real-valued weight function \\(w\\) defined on \\(E\\). Let \\(A\\) be a subset of \\(E\\) that is included in some minimum spanning tree for \\(G\\), and let \\(C=(V_{C},E_{C})\\) be a connected component (tree) in the forest \\(G_{A}=(V,A)\\). If \\((u,v)\\) is a light edge connecting \\(C\\) to some other component in \\(G_{A}\\), then \\((u,v)\\) is safe for \\(A\\).\n\nThe cut \\((V_{C},V-V_{C})\\) respects \\(A\\), and \\((u,v)\\) is a light edge for this cut. Therefore, \\((u,v)\\) is safe for \\(A\\).\n\nFigure 21.3: The proof of Theorem 21.1. Orange vertices belong to \\(S\\), and tan vertices belong to \\(V-S\\). Only edges in the minimum spanning tree \\(T\\) are shown, along with edge \\((u,v)\\), which does not lie in \\(T\\). The edges in \\(A\\) are blue, and \\((u,v)\\) is a light edge crossing the cut \\((S,V-S)\\). The edge \\((x,y)\\) is an edge on the unique simple path \\(p\\) from \\(u\\) to \\(v\\) in \\(T\\). To form a minimum spanning tree \\(T^{\\prime}\\) that contains \\((u,v)\\), remove the edge \\((x,y)\\) from \\(T\\) and add the edge \\((u,v)\\).\n\n### Exercises\n\n#### 21.1-1\n\nLet \\((u,v)\\) be a minimum-weight edge in a connected graph \\(G\\). Show that \\((u,v)\\) belongs to some minimum spanning tree of \\(G\\).\n\n#### 21.1-2\n\nProfessor Sabatier conjectures the following converse of Theorem 21.1. Let \\(G=(V,E)\\) be a connected, undirected graph with a real-valued weight function \\(w\\) defined on \\(E\\). Let \\(A\\) be a subset of \\(E\\) that is included in some minimum spanning tree for \\(G\\), let \\((S,V-S)\\) be any cut of \\(G\\) that respects \\(A\\), and let \\((u,v)\\) be a safe edge for \\(A\\) crossing \\((S,V-S)\\). Then, \\((u,v)\\) is a light edge for the cut. Show that the professor's conjecture is incorrect by giving a counterexample.\n\n#### 21.1-3\n\nShow that if an edge \\((u,v)\\) is contained in some minimum spanning tree, then it is a light edge crossing some cut of the graph.\n\n#### 21.1-4\n\nGive a simple example of a connected graph such that the set of edges \\(\\{(u,v):\\) there exists a cut \\((S,V-S)\\) such that \\((u,v)\\) is a light edge crossing \\((S,V-S)\\}\\) does not form a minimum spanning tree.\n\n#### 21.1-5\n\nLet \\(e\\) be a maximum-weight edge on some cycle of connected graph \\(G=(V,E)\\). Prove that there is a minimum spanning tree of \\(G^{\\prime}=(V,E-\\{e\\})\\) that is also a minimum spanning tree of \\(G\\). That is, there is a minimum spanning tree of \\(G\\) that does not include \\(e\\).\n\n#### 21.1-6\n\nShow that a graph has a unique minimum spanning tree if, for every cut of the graph, there is a unique light edge crossing the cut. Show that the converse is not true by giving a counterexample.\n\n#### 21.1-7\n\nArgue that if all edge weights of a graph are positive, then any subset of edges that connects all vertices and has minimum total weight must be a tree. Give an example to show that the same conclusion does not follow if we allow some weights to be nonpositive.\n\n#### 21.1-8\n\nLet \\(T\\) be a minimum spanning tree of a graph \\(G\\), and let \\(L\\) be the sorted list of the edge weights of \\(T\\). Show that for any other minimum spanning tree \\(T^{\\prime}\\) of \\(G\\), the list \\(L\\) is also the sorted list of edge weights of \\(T^{\\prime}\\).\n\n#### 21.1-9\n\nLet \\(T\\) be a minimum spanning tree of a graph \\(G=(V,E)\\), and let \\(V^{\\prime}\\) be a subset of \\(V\\). Let \\(T^{\\prime}\\) be the subgraph of \\(T\\) induced by \\(V^{\\prime}\\), and let \\(G^{\\prime}\\) be the subgraph of \\(G\\) induced by \\(V^{\\prime}\\). Show that if \\(T^{\\prime}\\) is connected, then \\(T^{\\prime}\\) is a minimum spanning tree of \\(G^{\\prime}\\).\n\n#### 21.1-10\n\nGiven a graph \\(G\\) and a minimum spanning tree \\(T\\), suppose that the weight of one of the edges in \\(T\\) decreases. Show that \\(T\\) is still a minimum spanning tree for \\(G\\). More formally, let \\(T\\) be a minimum spanning tree for \\(G\\) with edge weights given by weight function \\(w\\). Choose one edge \\((x,y)\\in T\\) and a positive number \\(k\\), and define the weight function \\(w^{\\prime}\\) by\n\n\\[w^{\\prime}(u,v)=\\left\\{\\begin{array}{ll}w(u,v)&\\mbox{if }(u,v)\\neq(x,y) \\;,\\\\ w(x,y)-k&\\mbox{if }(u,v)=(x,y)\\;.\\end{array}\\right.\\]\n\nShow that \\(T\\) is a minimum spanning tree for \\(G\\) with edge weights given by \\(w^{\\prime}\\).\n\n* _21.1-11_ Given a graph \\(G\\) and a minimum spanning tree \\(T\\), suppose that the weight of one of the edges _not_ in \\(T\\) decreases. Give an algorithm for finding the minimum spanning tree in the modified graph.\n\n### The algorithms of Kruskal and Prim\n\nThe two minimum-spanning-tree algorithms described in this section elaborate on the generic method. They each use a specific rule to determine a safe edge in line 3 of Generic-MST. In Kruskal's algorithm, the set \\(A\\) is a forest whose vertices are all those of the given graph. The safe edge added to \\(A\\) is always a lowest-weight edge in the graph that connects two distinct components. In Prim's algorithm, the set \\(A\\) forms a single tree. The safe edge added to \\(A\\) is always a lowest-weight edge connecting the tree to a vertex not in the tree. Both algorithms assume that the input graph is connected and represented by adjacency lists.",
        "chapter": "Part VI Graph Algorithms",
        "section": "21 Minimum Spanning Trees",
        "subsection": "21.1 Growing a minimum spanning tree",
        "subsubsection": "N/A"
    },
    {
        "content": "#### 21.1-8\n\nLet \\(T\\) be a minimum spanning tree of a graph \\(G\\), and let \\(L\\) be the sorted list of the edge weights of \\(T\\). Show that for any other minimum spanning tree \\(T^{\\prime}\\) of \\(G\\), the list \\(L\\) is also the sorted list of edge weights of \\(T^{\\prime}\\).\n\n#### 21.1-9\n\nLet \\(T\\) be a minimum spanning tree of a graph \\(G=(V,E)\\), and let \\(V^{\\prime}\\) be a subset of \\(V\\). Let \\(T^{\\prime}\\) be the subgraph of \\(T\\) induced by \\(V^{\\prime}\\), and let \\(G^{\\prime}\\) be the subgraph of \\(G\\) induced by \\(V^{\\prime}\\). Show that if \\(T^{\\prime}\\) is connected, then \\(T^{\\prime}\\) is a minimum spanning tree of \\(G^{\\prime}\\).\n\n#### 21.1-10\n\nGiven a graph \\(G\\) and a minimum spanning tree \\(T\\), suppose that the weight of one of the edges in \\(T\\) decreases. Show that \\(T\\) is still a minimum spanning tree for \\(G\\). More formally, let \\(T\\) be a minimum spanning tree for \\(G\\) with edge weights given by weight function \\(w\\). Choose one edge \\((x,y)\\in T\\) and a positive number \\(k\\), and define the weight function \\(w^{\\prime}\\) by\n\n\\[w^{\\prime}(u,v)=\\left\\{\\begin{array}{ll}w(u,v)&\\mbox{if }(u,v)\\neq(x,y) \\;,\\\\ w(x,y)-k&\\mbox{if }(u,v)=(x,y)\\;.\\end{array}\\right.\\]\n\nShow that \\(T\\) is a minimum spanning tree for \\(G\\) with edge weights given by \\(w^{\\prime}\\).\n\n* _21.1-11_ Given a graph \\(G\\) and a minimum spanning tree \\(T\\), suppose that the weight of one of the edges _not_ in \\(T\\) decreases. Give an algorithm for finding the minimum spanning tree in the modified graph.\n\n### The algorithms of Kruskal and Prim\n\nThe two minimum-spanning-tree algorithms described in this section elaborate on the generic method. They each use a specific rule to determine a safe edge in line 3 of Generic-MST. In Kruskal's algorithm, the set \\(A\\) is a forest whose vertices are all those of the given graph. The safe edge added to \\(A\\) is always a lowest-weight edge in the graph that connects two distinct components. In Prim's algorithm, the set \\(A\\) forms a single tree. The safe edge added to \\(A\\) is always a lowest-weight edge connecting the tree to a vertex not in the tree. Both algorithms assume that the input graph is connected and represented by adjacency lists.\n\n### Kruskal's algorithm\n\nKruskal's algorithm finds a safe edge to add to the growing forest by finding, of all the edges that connect any two trees in the forest, an edge \\((u,v)\\) with the lowest weight. Let \\(C_{1}\\) and \\(C_{2}\\) denote the two trees that are connected by \\((u,v)\\). Since \\((u,v)\\) must be a light edge connecting \\(C_{1}\\) to some other tree, Corollary 21.2 implies\n\nFigure 21: The execution of Kruskal\u2019s algorithm on the graph from Figure 21.1. Blue edges belong to the forest \\(A\\) being grown. The algorithm considers each edge in sorted order by weight. A red arrow points to the edge under consideration at each step of the algorithm. If the edge joins two distinct trees in the forest, it is added to the forest, thereby merging the two trees.\n\nthat \\((u,v)\\) is a safe edge for \\(C_{1}\\). Kruskal's algorithm qualifies as a greedy algorithm because at each step it adds to the forest an edge with the lowest possible weight.\n\nLike the algorithm to compute connected components from Section 19.1, the procedure MST-Kruskal on the following page uses a disjoint-set data structure to maintain several disjoint sets of elements. Each set contains the vertices in one tree of the current forest. The operation Find-Set\\((u)\\) returns a representative element from the set that contains \\(u\\). Thus, to determine whether two vertices \\(u\\) and \\(v\\) belong to the same tree, just test whether Find-Set\\((u)\\) equals Find-Set\\((v)\\). To combine trees, Kruskal's algorithm calls the Union procedure.\n\nFigure 21.4 shows how Kruskal's algorithm works. Lines 1-3 initialize the set \\(A\\) to the empty set and create \\(|V|\\) trees, one containing each vertex. The **for** loop in lines 6-9 examines edges in order of weight, from lowest to highest. The loop checks, for each edge \\((u,v)\\), whether the endpoints \\(u\\) and \\(v\\) belong to the same tree. If they do, then the edge \\((u,v)\\) cannot be added to the forest without creating a cycle, and the edge is ignored. Otherwise, the two vertices belong to different\n\nFigure 21.4: **continued** Further steps in the execution of Kruskal\u2019s algorithm.\n\ntrees. In this case, line 8 adds the edge \\((u,v)\\) to \\(A\\), and line 9 merges the vertices in the two trees.\n\nThe running time of Kruskal's algorithm for a graph \\(G=(V,E)\\) depends on the specific implementation of the disjoint-set data structure. Let's assume that it uses the disjoint-set-forest implementation of Section 19.3 with the union-by-rank and path-compression heuristics, since that is the asymptotically fastest implementation known. Initializing the set \\(A\\) in line 1 takes \\(O(1)\\) time, creating a single list of edges in line 4 takes \\(O(V+E)\\) time (which is \\(O(E)\\) because \\(G\\) is connected), and the time to sort the edges in line 5 is \\(O(E\\lg E)\\). (We'll account for the cost of the \\(|V|\\) Make-Set operations in the **for** loop of lines 2-3 in a moment.) The **for** loop of lines 6-9 performs \\(O(E)\\) Find-Set and Union operations on the disjoint-set forest. Along with the \\(|V|\\) Make-Set operations, these disjoint-set operations take a total of \\(O((V+E)\\,\\alpha(V))\\) time, where \\(\\alpha\\) is the very slowly growing function defined in Section 19.4. Because we assume that \\(G\\) is connected, we have \\(|E|\\geq|V|-1\\), and so the disjoint-set operations take \\(O(E\\,\\alpha(V))\\) time. Moreover, since \\(\\alpha(|V|)=O(\\lg V)=O(\\lg E)\\), the total running time of Kruskal's algorithm is \\(O(E\\lg E)\\). Observing that \\(|E|<|V|^{2}\\), we have \\(\\lg|E|=O(\\lg V)\\), and so we can restate the running time of Kruskal's algorithm as \\(O(E\\lg V)\\).\n\n#### Prim's algorithm\n\nLike Kruskal's algorithm, Prim's algorithm is a special case of the generic minimum-spanning-tree method from Section 21.1. Prim's algorithm operates much like Dijkstra's algorithm for finding shortest paths in a graph, which we'll see in Section 22.3. Prim's algorithm has the property that the edges in the set \\(A\\) always form a single tree. As Figure 21.5 shows, the tree starts from an arbitrary root vertex \\(r\\) and grows until it spans all the vertices in \\(V\\). Each step adds to the tree \n\n#### 2.1.2 The algorithms of Kruskal and Prim\n\nThe algorithm is a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree with a _tree_ algorithm that runs in a tree witha light edge that connects \\(A\\) to an isolated vertex --one on which no edge of \\(A\\) is incident. By Corollary 21.2, this rule adds only edges that are safe for \\(A\\). Therefore, when the algorithm terminates, the edges in \\(A\\) form a minimum spanning tree. This strategy qualifies as greedy since at each step it adds to the tree an edge that contributes the minimum amount possible to the tree's weight.\n\nIn the procedure MST-Prim below, the connected graph \\(G\\) and the root \\(r\\) of the minimum spanning tree to be grown are inputs to the algorithm. In order to efficiently select a new edge to add into tree \\(A\\), the algorithm maintains a min-priority queue \\(Q\\) of all vertices that are _not_ in the tree, based on a _key_ attribute. For each vertex \\(v\\), the attribute \\(v.\\emph{key}\\) is the minimum weight of any edge connecting \\(v\\) to a vertex in the tree, where by convention, \\(v.\\emph{key}=\\infty\\) if there is no such edge. The attribute \\(v.\\pi\\) names the parent of \\(v\\) in the tree. The algorithm implicitly maintains the set \\(A\\) from Generic-MST as\n\n\\[A=\\left\\{(v,v.\\pi):v\\in V-\\left\\{r\\right\\}-Q\\right\\}\\,\\]\n\nwhere we interpret the vertices in \\(Q\\) as forming a set. When the algorithm terminates, the min-priority queue \\(Q\\) is empty, and thus the minimum spanning tree \\(A\\) for \\(G\\) is\n\n\\[A=\\left\\{(v,v.\\pi):v\\in V-\\left\\{r\\right\\}\\right\\}\\.\\]\n\nFigure 21.5 shows how Prim's algorithm works. Lines 1-7 set the key of each vertex to \\(\\infty\\) (except for the root \\(r\\), whose key is set to 0 to make it the first vertex processed), set the parent of each vertex to nil, and insert each vertex into the min-priority queue \\(Q\\). The algorithm maintains the following three-part loop invariant:\n\n### The algorithms of Kruskal and Prim\n\nPrior to each iteration of the **while** loop of lines 8-14,\n\n1. \\(A=\\{(v,v.\\pi):v\\in V-\\{r\\}-Q\\}\\).\n2. The vertices already placed into the minimum spanning tree are those in \\(V-Q\\).\n3. For all vertices \\(v\\in Q\\), if \\(v.\\pi\\neq\\textsc{nil}\\), then \\(v.\\mathit{key}<\\infty\\) and \\(v.\\mathit{key}\\) is the weight of a light edge \\((v,v.\\pi)\\) connecting \\(v\\) to some vertex already placed into the minimum spanning tree.\n\nLine 9 identifies a vertex \\(u\\in Q\\) incident on a light edge that crosses the cut \\((V-Q,Q)\\) (with the exception of the first iteration, in which \\(u=r\\) due to lines 4-7). Removing \\(u\\) from the set \\(Q\\) adds it to the set \\(V-Q\\) of vertices in the tree, thus adding the edge \\((u,u.\\pi)\\) to \\(A\\). The **for** loop of lines 10-14 updates the _key_ and \\(\\pi\\) attributes of every vertex \\(v\\) adjacent to \\(u\\) but not in the tree, thereby maintaining the third part of the loop invariant. Whenever line 13 updates \\(v.\\mathit{key}\\), line 14 calls Decrease-Key to inform the min-priority queue that \\(v\\)'s key has changed.\n\nThe running time of Prim's algorithm depends on the specific implementation of the min-priority queue \\(Q\\). You can implement \\(Q\\) with a binary min-heap (see Chapter 6), including a way to map between vertices and their corresponding heap elements. The Build-Min-Heap procedure can perform lines 5-7 in \\(O(V)\\) time. In fact, there is no need to call Build-Min-Heap. You can just put the key of \\(r\\) at the root of the min-heap, and because all other keys are \\(\\infty\\), they can go anywhere else in the min-heap. The body of the **while** loop executes \\(|V|\\) times, and since each Extract-Min operation takes \\(O(\\lg V)\\) time, the total time for all calls to Extract-Min is \\(O(V\\lg V)\\). The **for** loop in lines 10-14 executes \\(O(E)\\) times altogether, since the sum of the lengths of all adjacency lists is \\(2\\,|E|\\). Within the **for** loop, the test for membership in \\(Q\\) in line 11 can take constant time if you keep a bit for each vertex that indicates whether it belongs to \\(Q\\) and update the bit when the vertex is removed from \\(Q\\). Each call to Decrease-Key in line 14 takes \\(O(\\lg V)\\) time. Thus, the total time for Prim's algorithm is \\(O(V\\lg V+E\\lg V)=O(E\\lg V)\\), which is asymptotically the same as for our implementation of Kruskal's algorithm.\n\nYou can further improve the asymptotic running time of Prim's algorithm by implementing the min-priority queue with a Fibonacci heap (see page 478). If a Fibonacci heap holds \\(|V|\\) elements, an Extract-Min operation takes \\(O(\\lg V)\\) amortized time and each Insert and Decrease-Key operation takes only \\(O(1)\\) amortized time. Therefore, by using a Fibonacci heap to implement the min-priority queue \\(Q\\), the running time of Prim's algorithm improves to \\(O(E+V\\lg V)\\)\n\n### Exercises\n\n#### 21.2-1\n\nKruskal's algorithm can return different spanning trees for the same input graph \\(G\\), depending on how it breaks ties when the edges are sorted. Show that for each minimum spanning tree \\(T\\) of \\(G\\), there is a way to sort the edges of \\(G\\) in Kruskal's algorithm so that the algorithm returns \\(T\\).\n\n#### 21.2-2\n\nGive a simple implementation of Prim's algorithm that runs in \\(O(V^{2})\\) time when the graph \\(G=(V,E)\\) is represented as an adjacency matrix.\n\n#### 21.2-3\n\nFor a sparse graph \\(G=(V,E)\\), where \\(|E|=\\Theta(V)\\), is the implementation of Prim's algorithm with a Fibonacci heap asymptotically faster than the binary-heap implementation? What about for a dense graph, where \\(|E|=\\Theta(V^{2})\\)? How must the sizes \\(|E|\\) and \\(|V|\\) be related for the Fibonacci-heap implementation to be asymptotically faster than the binary-heap implementation?\n\n#### 21.2-4\n\nSuppose that all edge weights in a graph are integers in the range from \\(1\\) to \\(|V|\\). How fast can you make Kruskal's algorithm run? What if the edge weights are integers in the range from \\(1\\) to \\(W\\) for some constant \\(W\\)?\n\n#### 21.2-5\n\nSuppose that all edge weights in a graph are integers in the range from \\(1\\) to \\(|V|\\). How fast can you make Prim's algorithm run? What if the edge weights are integers in the range from \\(1\\) to \\(W\\) for some constant \\(W\\)?\n\n#### 21.2-6\n\nProfessor Borden proposes a new divide-and-conquer algorithm for computing minimum spanning trees, which goes as follows. Given a graph \\(G=(V,E)\\), partition the set \\(V\\) of vertices into two sets \\(V_{1}\\) and \\(V_{2}\\) such that \\(|V_{1}|\\) and \\(|V_{2}|\\) differ by at most \\(1\\). Let \\(E_{1}\\) be the set of edges that are incident only on vertices in \\(V_{1}\\), and let \\(E_{2}\\) be the set of edges that are incident only on vertices in \\(V_{2}\\). Recursively solve a minimum-spanning-tree problem on each of the two subgraphs \\(G_{1}=(V_{1},E_{1})\\) and \\(G_{2}=(V_{2},E_{2})\\). Finally, select the minimum-weight edge in \\(E\\) that crosses the cut \\((V_{1},V_{2})\\), and use this edge to unite the resulting two minimum spanning trees into a single spanning tree.\n\nEither argue that the algorithm correctly computes a minimum spanning tree of \\(G\\), or provide an example for which the algorithm fails.\n\n* _21.2-7_ Suppose that the edge weights in a graph are uniformly distributed over the half-open interval \\([0,1)\\). Which algorithm, Kruskal's or Prim's, can you make run faster?\n* _21.2-8_ Suppose that a graph \\(G\\) has a minimum spanning tree already computed. How quickly can you update the minimum spanning tree upon adding a new vertex and incident edges to \\(G\\)?\n\n## Problems\n\n### 21.1 Second-best minimum spanning tree\n\nLet \\(G=(V,E)\\) be an undirected, connected graph whose weight function is \\(w:E\\rightarrow\\mathbb{R}\\), and suppose that \\(|E|\\geq|V|\\) and all edge weights are distinct.\n\nWe define a second-best minimum spanning tree as follows. Let \\(\\mathcal{T}\\) be the set of all spanning trees of \\(G\\), and let \\(T\\) be a minimum spanning tree of \\(G\\). Then a _second-best minimum spanning tree_ is a spanning tree \\(T^{\\prime}\\) such that \\(w(T^{\\prime})=\\min\\left\\{w(T^{\\prime\\prime}):T^{\\prime\\prime}\\in\\mathcal{T}- \\{T\\}\\right\\}\\).\n\n* Show that the minimum spanning tree is unique, but that the second-best minimum spanning tree need not be unique.\n* Let \\(T\\) be the minimum spanning tree of \\(G\\). Prove that \\(G\\) contains some edge \\((u,v)\\in T\\) and some edge \\((x,y)\\notin T\\) such that \\((T-\\{(u,v)\\})\\cup\\{(x,y)\\}\\) is a second-best minimum spanning tree of \\(G\\).\n* Now let \\(T\\) be any spanning tree of \\(G\\) and, for any two vertices \\(u,v\\in V\\), let \\(max[u,v]\\) denote an edge of maximum weight on the unique simple path between \\(u\\) and \\(v\\) in \\(T\\). Describe an \\(O(V^{2})\\)-time algorithm that, given \\(T\\), computes \\(max[u,v]\\) for all \\(u,v\\in V\\).\n* Give an efficient algorithm to compute the second-best minimum spanning tree of \\(G\\).\n\n### 21.2 Minimum spanning tree in sparse graphs\n\nFor a very sparse connected graph \\(G=(V,E)\\), it is possible to further improve upon the \\(O(E+V\\lg V)\\) running time of Prim's algorithm with a Fibonacci heap by preprocessing \\(G\\) to decrease the number of vertices before running Prim's algorithm. In particular, for each vertex \\(u\\), choose the minimum-weight edge \\((u,v)\\)",
        "chapter": "Part VI Graph Algorithms",
        "section": "21 Minimum Spanning Trees",
        "subsection": "21.2 The algorithms of Kruskal and Prim",
        "subsubsection": "N/A"
    },
    {
        "content": "* _21.2-7_ Suppose that the edge weights in a graph are uniformly distributed over the half-open interval \\([0,1)\\). Which algorithm, Kruskal's or Prim's, can you make run faster?\n* _21.2-8_ Suppose that a graph \\(G\\) has a minimum spanning tree already computed. How quickly can you update the minimum spanning tree upon adding a new vertex and incident edges to \\(G\\)?\n\n## Problems\n\n### 21.1 Second-best minimum spanning tree\n\nLet \\(G=(V,E)\\) be an undirected, connected graph whose weight function is \\(w:E\\rightarrow\\mathbb{R}\\), and suppose that \\(|E|\\geq|V|\\) and all edge weights are distinct.\n\nWe define a second-best minimum spanning tree as follows. Let \\(\\mathcal{T}\\) be the set of all spanning trees of \\(G\\), and let \\(T\\) be a minimum spanning tree of \\(G\\). Then a _second-best minimum spanning tree_ is a spanning tree \\(T^{\\prime}\\) such that \\(w(T^{\\prime})=\\min\\left\\{w(T^{\\prime\\prime}):T^{\\prime\\prime}\\in\\mathcal{T}- \\{T\\}\\right\\}\\).\n\n* Show that the minimum spanning tree is unique, but that the second-best minimum spanning tree need not be unique.\n* Let \\(T\\) be the minimum spanning tree of \\(G\\). Prove that \\(G\\) contains some edge \\((u,v)\\in T\\) and some edge \\((x,y)\\notin T\\) such that \\((T-\\{(u,v)\\})\\cup\\{(x,y)\\}\\) is a second-best minimum spanning tree of \\(G\\).\n* Now let \\(T\\) be any spanning tree of \\(G\\) and, for any two vertices \\(u,v\\in V\\), let \\(max[u,v]\\) denote an edge of maximum weight on the unique simple path between \\(u\\) and \\(v\\) in \\(T\\). Describe an \\(O(V^{2})\\)-time algorithm that, given \\(T\\), computes \\(max[u,v]\\) for all \\(u,v\\in V\\).\n* Give an efficient algorithm to compute the second-best minimum spanning tree of \\(G\\).\n\n### 21.2 Minimum spanning tree in sparse graphs\n\nFor a very sparse connected graph \\(G=(V,E)\\), it is possible to further improve upon the \\(O(E+V\\lg V)\\) running time of Prim's algorithm with a Fibonacci heap by preprocessing \\(G\\) to decrease the number of vertices before running Prim's algorithm. In particular, for each vertex \\(u\\), choose the minimum-weight edge \\((u,v)\\)incident on \\(u\\), and put \\((u,v)\\) into the minimum spanning tree under construction. Then, contract all chosen edges (see Section B.4). Rather than contracting these edges one at a time, first identify sets of vertices that are united into the same new vertex. Then create the graph that would have resulted from contracting these edges one at a time, but do so by \"renaming\" edges according to the sets into which their endpoints were placed. Several edges from the original graph might be renamed the same as each other. In such a case, only one edge results, and its weight is the minimum of the weights of the corresponding original edges.\n\nInitially, set the minimum spanning tree \\(T\\) being constructed to be empty, and for each edge \\((u,v)\\in E\\), initialize the two attributes \\((u,v).\\mathit{orig}=(u,v)\\) and \\((u,v).\\mathit{c}=w(u,v)\\). Use the \\(\\mathit{orig}\\) attribute to reference the edge from the initial graph that is associated with an edge in the contracted graph. The \\(\\mathit{c}\\) attribute holds the weight of an edge, and as edges are contracted, it is updated according to the above scheme for choosing edge weights. The procedure MST-Reduce on the facing page takes inputs \\(G\\) and \\(T\\), and it returns a contracted graph \\(G^{\\prime}\\) with updated attributes \\(\\mathit{orig}^{\\prime}\\) and \\(c^{\\prime}\\). The procedure also accumulates edges of \\(G\\) into the minimum spanning tree \\(T\\).\n\n* Let \\(T\\) be the set of edges returned by MST-Reduce, and let \\(A\\) be the minimum spanning tree of the graph \\(G^{\\prime}\\) formed by the call MST-Prim\\((G^{\\prime},c^{\\prime},r)\\), where \\(c^{\\prime}\\) is the weight attribute on the edges of \\(G^{\\prime}.E\\) and \\(r\\) is any vertex in \\(G^{\\prime}.\\mathit{V}\\). Prove that \\(T\\cup\\{(x,y).\\mathit{orig}^{\\prime}:(x,y)\\in A\\}\\) is a minimum spanning tree of \\(G\\).\n* Argue that \\(\\left|G^{\\prime}.\\mathit{V}\\right|\\leq\\left|V\\right|/2\\).\n* Show how to implement MST-Reduce so that it runs in \\(O(E)\\) time. (_Hint:_ Use simple data structures.)\n* Suppose that you run \\(k\\) phases of MST-Reduce, using the output \\(G^{\\prime}\\) produced by one phase as the input \\(G\\) to the next phase and accumulating edges in \\(T\\). Argue that the overall running time of the \\(k\\) phases is \\(O(kE)\\).\n* Suppose that after running \\(k\\) phases of MST-Reduce, as in part (d), you run Prim's algorithm by calling MST-Prim\\((G^{\\prime},c^{\\prime},r)\\), where \\(G^{\\prime}\\), with weight attribute \\(c^{\\prime}\\), is returned by the last phase and \\(r\\) is any vertex in \\(G^{\\prime}.\\mathit{V}\\). Show how to pick \\(k\\) so that the overall running time is \\(O(E\\lg\\lg V)\\). Argue that your choice of \\(k\\) minimizes the overall asymptotic running time.\n* For what values of \\(\\left|E\\right|\\) (in terms of \\(\\left|V\\right|\\)) does Prim's algorithm with preprocessing asymptotically beat Prim's algorithm without preprocessing?\n#### 21.3 Alternative minimum-spanning-tree algorithms\n\nConsider the three algorithms Maybe-MST-A, Maybe-MST-B, and Maybe-MST-C on the next page. Each one takes a connected graph and a weight function as input and returns a set of edges \\(T\\). For each algorithm, either prove that \\(T\\) is a minimum spanning tree or prove that \\(T\\) is not necessarily a minimum spanning tree. Also describe the most efficient implementation of each algorithm, regardless of whether it computes a minimum spanning tree.\n\n#### 21.4 Bottleneck spanning tree\n\nA _bottleneck spanning tree_\\(T\\) of an undirected graph \\(G\\) is a spanning tree of \\(G\\) whose largest edge weight is minimum over all spanning trees of \\(G\\). The value of the bottleneck spanning tree is the weight of the maximum-weight edge in \\(T\\).\n\nMaybe-MST-A(\\(G,w\\))\n\n1 sort the edges into monotonically decreasing order of edge weights \\(w\\)\n2\\(T\\,=\\,E\\)\n3 for each edge \\(e\\), taken in monotonically decreasing order by weight\n4if\\(T-\\{e\\}\\) is a connected graph\n5\\(T\\,=\\,T-\\{e\\}\\)\n6 return\\(T\\)Maybe-MST-B(\\(G,w\\))\n\n1\\(T\\,=\\,\\emptyset\\)\n2for each edge \\(e\\), taken in arbitrary order\n3if\\(T\\,\\cup\\{e\\}\\) has no cycles\n4\\(T\\,=\\,T\\,\\cup\\{e\\}\\)\n5 return\\(T\\)Maybe-MST-C(\\(G,w\\))\n\n1\\(T\\,=\\,\\emptyset\\)\n2for each edge \\(e\\), taken in arbitrary order\n3\\(T\\,=\\,T\\,\\cup\\{e\\}\\)\n4if\\(T\\) has a cycle \\(c\\)\n5 let \\(e^{\\prime}\\) be a maximum-weight edge on \\(c\\)\n6\\(T\\,=\\,T-\\{e^{\\prime}\\}\\)\n7return\\(T\\)\n\n_a._ Argue that a minimum spanning tree is a bottleneck spanning tree.\n\nPart (a) shows that finding a bottleneck spanning tree is no harder than finding a minimum spanning tree. In the remaining parts, you will show how to find a bottleneck spanning tree in linear time.\n\n_b._ Give a linear-time algorithm that, given a graph \\(G\\) and an integer \\(b\\), determines whether the value of the bottleneck spanning tree is at most \\(b\\).\n\n_c._ Use your algorithm for part (b) as a subroutine in a linear-time algorithm for the bottleneck-spanning-tree problem. (_Hint_: You might want to use a subroutine that contracts sets of edges, as in the MST-Reduce procedure described in Problem 21-2.)\n\n## Chapter notes\n\nTarjan [429] surveys the minimum-spanning-tree problem and provides excellent advanced material. Graham and Hell [198] compiled a history of the minimum-spanning-tree problem.\n\nTarjan attributes the first minimum-spanning-tree algorithm to a 1926 paper by O. Boruvka. Boruvka's algorithm consists of running \\(O(\\lg V)\\) iterations of the procedure MST-Reduce described in Problem 21-2. Kruskal's algorithm was reported by Kruskal [272] in 1956. The algorithm commonly known as Prim's algorithm was indeed invented by Prim [367], but it was also invented earlier by V. Jarnik in 1930.\n\nWhen \\(|E|=\\Omega(V\\lg V)\\), Prim's algorithm, implemented with a Fibonacci heap, runs in \\(O(E)\\) time. For sparser graphs, using a combination of the ideas from Prim's algorithm, Kruskal's algorithm, and Boruvka's algorithm, together with advanced data structures, Fredman and Tarjan [156] give an algorithm that runs in \\(O(E\\lg^{*}V)\\) time. Gabow, Galil, Spencer, and Tarjan [165] improved this algorithm to run in \\(O(E\\lg\\lg^{*}V)\\) time. Chazelle [83] gives an algorithm that runs in \\(O(E\\ \\widehat{\\alpha}(E,V))\\) time, where \\(\\widehat{\\alpha}(E,V)\\) is the functional inverse of Ackermann's function. (See the chapter notes for Chapter 19 for a brief discussion of Ackermann's function and its inverse.) Unlike previous minimum-spanning-tree algorithms, Chazelle's algorithm does not follow the greedy method. Pettie and Ramachandran [356] give an algorithm based on precomputed \"MST decision trees\" that also runs in \\(O(E\\ \\widehat{\\alpha}(E,V))\\) time.\n\nA related problem is _spanning-tree verification_: given a graph \\(G=(V,E)\\) and a tree \\(T\\subseteq E\\), determine whether \\(T\\) is a minimum spanning tree of \\(G\\). King [254] gives a linear-time algorithm to verify a spanning tree, building on earlier work of Komlos [269] and Dixon, Rauch, and Tarjan [120].\n\nThe above algorithms are all deterministic and fall into the comparison-based model described in Chapter 8. Karger, Klein, and Tarjan [243] give a randomized minimum-spanning-tree algorithm that runs in \\(O(V+E)\\) expected time. This algorithm uses recursion in a manner similar to the linear-time selection algorithm in Section 9.3: a recursive call on an auxiliary problem identifies a subset of the edges \\(E^{\\prime}\\) that cannot be in any minimum spanning tree. Another recursive call on \\(E-E^{\\prime}\\) then finds the minimum spanning tree. The algorithm also uses ideas from Boruvka's algorithm and King's algorithm for spanning-tree verification.\n\nFredman and Willard [158] showed how to find a minimum spanning tree in \\(O(V+E)\\) time using a deterministic algorithm that is not comparison based. Their algorithm assumes that the data are \\(b\\)-bit integers and that the computer memory consists of addressable \\(b\\)-bit words.",
        "chapter": "Part VI Graph Algorithms",
        "section": "21 Minimum Spanning Trees",
        "subsection": "Problems",
        "subsubsection": "N/A"
    },
    {
        "content": "## Chapter notes\n\nTarjan [429] surveys the minimum-spanning-tree problem and provides excellent advanced material. Graham and Hell [198] compiled a history of the minimum-spanning-tree problem.\n\nTarjan attributes the first minimum-spanning-tree algorithm to a 1926 paper by O. Boruvka. Boruvka's algorithm consists of running \\(O(\\lg V)\\) iterations of the procedure MST-Reduce described in Problem 21-2. Kruskal's algorithm was reported by Kruskal [272] in 1956. The algorithm commonly known as Prim's algorithm was indeed invented by Prim [367], but it was also invented earlier by V. Jarnik in 1930.\n\nWhen \\(|E|=\\Omega(V\\lg V)\\), Prim's algorithm, implemented with a Fibonacci heap, runs in \\(O(E)\\) time. For sparser graphs, using a combination of the ideas from Prim's algorithm, Kruskal's algorithm, and Boruvka's algorithm, together with advanced data structures, Fredman and Tarjan [156] give an algorithm that runs in \\(O(E\\lg^{*}V)\\) time. Gabow, Galil, Spencer, and Tarjan [165] improved this algorithm to run in \\(O(E\\lg\\lg^{*}V)\\) time. Chazelle [83] gives an algorithm that runs in \\(O(E\\;\\widehat{\\alpha}(E,V))\\) time, where \\(\\widehat{\\alpha}(E,V)\\) is the functional inverse of Ackermann's function. (See the chapter notes for Chapter 19 for a brief discussion of Ackermann's function and its inverse.) Unlike previous minimum-spanning-tree algorithms, Chazelle's algorithm does not follow the greedy method. Pettie and Ramachandran [356] give an algorithm based on precomputed \"MST decision trees\" that also runs in \\(O(E\\;\\widehat{\\alpha}(E,V))\\) time.\n\nA related problem is _spanning-tree verification_: given a graph \\(G=(V,E)\\) and a tree \\(T\\subseteq E\\), determine whether \\(T\\) is a minimum spanning tree of \\(G\\). King [254] gives a linear-time algorithm to verify a spanning tree, building on earlier work of Komlos [269] and Dixon, Rauch, and Tarjan [120].\n\nThe above algorithms are all deterministic and fall into the comparison-based model described in Chapter 8. Karger, Klein, and Tarjan [243] give a randomized minimum-spanning-tree algorithm that runs in \\(O(V+E)\\) expected time. This algorithm uses recursion in a manner similar to the linear-time selection algorithm in Section 9.3: a recursive call on an auxiliary problem identifies a subset of the edges \\(E^{\\prime}\\) that cannot be in any minimum spanning tree. Another recursive call on \\(E-E^{\\prime}\\) then finds the minimum spanning tree. The algorithm also uses ideas from Boruvka's algorithm and King's algorithm for spanning-tree verification.\n\nFredman and Willard [158] showed how to find a minimum spanning tree in \\(O(V+E)\\) time using a deterministic algorithm that is not comparison based. Their algorithm assumes that the data are \\(b\\)-bit integers and that the computer memory consists of addressable \\(b\\)-bit words.\n\n## Chapter Single-Source Shortest Paths\n\nSuppose that you need to drive from Oceanside, New York, to Oceanside, California, by the shortest possible route. Your GPS contains information about the entire road network of the United States, including the road distance between each pair of adjacent intersections. How can your GPS determine this shortest route?\n\nOne possible way is to enumerate all the routes from Oceanside, New York, to Oceanside, California, add up the distances on each route, and select the shortest. But even disallowing routes that contain cycles, your GPS would need to examine an enormous number of possibilities, most of which are simply not worth considering. For example, a route that passes through Miami, Florida, is a poor choice, because Miami is several hundred miles out of the way.\n\nThis chapter and Chapter 23 show how to solve such problems efficiently. The input to a _shortest-paths problem_ is a weighted, directed graph \\(G=(V,E)\\), with a weight function \\(w:E\\rightarrow\\mathbb{R}\\) mapping edges to real-valued weights. The _weight_\\(w(p)\\) of path \\(p=\\langle v_{0},\\,v_{1},\\,\\ldots,\\,v_{k}\\rangle\\) is the sum of the weights of its constituent edges:\n\n\\[w(p)=\\sum_{i=1}^{k}w(v_{i-1},v_{i})\\.\\]\n\nWe define the _shortest-path weight_\\(\\delta(u,v)\\) from \\(u\\) to \\(v\\) by\n\n\\[\\delta(u,v)=\\left\\{\\begin{array}{ll}\\min\\{w(p):u\\stackrel{{ p}}{{\\leadsto}}v\\}&\\text{if there is a path from $u$ to $v$ }\\,,\\\\ \\infty&\\text{otherwise }.\\end{array}\\right.\\]\n\nA _shortest path_ from vertex \\(u\\) to vertex \\(v\\) is then defined as any path \\(p\\) with weight \\(w(p)=\\delta(u,v)\\).\n\nIn the example of going from Oceanside, New York, to Oceanside, California, your GPS models the road network as a graph: vertices represent intersections, edges represent road segments between intersections, and edge weights represent road distances. The goal is to find a shortest path from a given intersection in",
        "chapter": "Part VI Graph Algorithms",
        "section": "21 Minimum Spanning Trees",
        "subsection": "Chapter notes",
        "subsubsection": "N/A"
    },
    {
        "content": "All algorithms in this chapter assume that the directed graph \\(G\\) is stored in the adjacency-list representation. Additionally, stored with each edge is its weight, so that as each algorithm traverses an adjacency list, it can find edge weights in \\(O(1)\\) time per edge.\n\n### The Bellman-Ford algorithm\n\nThe _Bellman-Ford algorithm_ solves the single-source shortest-paths problem in the general case in which edge weights may be negative. Given a weighted, directed graph \\(G=(V,E)\\) with source vertex \\(s\\) and weight function \\(w:E\\rightarrow\\mathbb{R}\\), the Bellman-Ford algorithm returns a boolean value indicating whether there is a negative-weight cycle that is reachable from the source. If there is such a cycle, the algorithm indicates that no solution exists. If there is no such cycle, the algorithm produces the shortest paths and their weights.\n\nThe procedure Bellman-Ford relaxes edges, progressively decreasing an estimate \\(v.d\\) on the weight of a shortest path from the source \\(s\\) to each vertex \\(v\\in V\\) until it achieves the actual shortest-path weight \\(\\delta(s,v)\\). The algorithm returns true if and only if the graph contains no negative-weight cycles that are reachable from the source.\n\n```\nBellman-Ford(\\(G,w,s\\))\n1Initialize-Single-Source(\\(G,s\\))\n2for\\(i=1\\)to\\(|G.V|-1\\)\n3for each edge \\((u,v)\\in G.E\\)\n4Relax(\\(u,v,w\\))\n5for each edge \\((u,v)\\in G.E\\)\n6if\\(v.d>u.d+w(u,v)\\)\n7returnfalse\n8returntrue\n```\n\nFigure 22.4 shows the execution of the Bellman-Ford algorithm on a graph with 5 vertices. After initializing the \\(d\\) and \\(\\pi\\) values of all vertices in line 1, the algorithm makes \\(|V|-1\\) passes over the edges of the graph. Each pass is one iteration of the **for** loop of lines 2-4 and consists of relaxing each edge of the graph once. Figures 22.4(b)-(e) show the state of the algorithm after each of the four passes over the edges. After making \\(|V|-1\\) passes, lines 5-8 check for a negative-weight cycle and return the appropriate boolean value. (We'll see a little later why this check works.)\n\nThe Bellman-Ford algorithm runs in \\(O(V^{2}+VE)\\) time when the graph is represented by adjacency lists, since the initialization in line 1 takes \\(\\Theta(V)\\) time, each of the \\(|V|-1\\) passes over the edges in lines 2-4 takes \\(\\Theta(V+E)\\) time (examining \\(|V|\\) adjacency lists to find the \\(|E|\\) edges), and the **for** loop of lines 5-7 takes \\(O(V+E)\\) time. Fewer than \\(|V|-1\\) passes over the edges sometimes suffice (see Exercise 22.1-3), which is why we say \\(O(V^{2}+VE)\\) time, rather than \\(\\Theta(V^{2}+VE)\\) time. In the frequent case where \\(|E|=\\Omega(\\vec{V})\\), we can express this running time as \\(O(VE)\\). Exercise 22.1-5 asks you to make the Bellman-Ford algorithm run in \\(O(VE)\\) time even when \\(|E|=o(V)\\).\n\nTo prove the correctness of the Bellman-Ford algorithm, we start by showing that if there are no negative-weight cycles, the algorithm computes correct shortest-path weights for all vertices reachable from the source.\n\nFigure 22.4: The execution of the Bellman-Ford algorithm. The source is vertex \\(s\\). The \\(d\\) values appear within the vertices, and blue edges indicate predecessor values: if edge \\((u,v)\\) is blue, then \\(v.\\pi=u\\). In this particular example, each pass relaxes the edges in the order \\((t,x),(t,y),(t,z),(x,t),(y,x),(y,z),(z,x),(z,s),(s,t),(s,y)\\). **(a)** The situation just before the first pass over the edges. **(b)\u2013(e)** The situation after each successive pass over the edges. Vertices whose shortest-path estimates and predecessors have changed due to a pass are highlighted in orange. The \\(d\\) and \\(\\pi\\) values in part (e) are the final values. The Bellman-Ford algorithm returns true in this example.\n\n**Lemma 22.2**: _Let \\(G=(V,E)\\) be a weighted, directed graph with source vertex \\(s\\) and weight function \\(w:E\\to\\mathbb{R}\\), and assume that \\(G\\) contains no negative-weight cycles that are reachable from \\(s\\). Then, after the \\(|V|-1\\) iterations of the **for** loop of lines 2-4 of Bellman-Ford, \\(v.d=\\delta(s,v)\\) for all vertices \\(v\\) that are reachable from \\(s\\)._\n\n_Proof_ We prove the lemma by appealing to the path-relaxation property. Consider any vertex \\(v\\) that is reachable from \\(s\\), and let \\(p=\\langle v_{0},\\,v_{1},\\,\\ldots,\\,v_{k}\\rangle\\), where \\(v_{0}=s\\) and \\(v_{k}=v\\), be any shortest path from \\(s\\) to \\(v\\). Because shortest paths are simple, \\(p\\) has at most \\(|V|-1\\) edges, and so \\(k\\leq|V|-1\\). Each of the \\(|V|-1\\) iterations of the **for** loop of lines 2-4 relaxes all \\(|E|\\) edges. Among the edges relaxed in the \\(i\\)th iteration, for \\(i=1,2,\\ldots,k\\), is \\((v_{i-1},v_{i})\\). By the path-relaxation property, therefore, \\(v.d=v_{k}.d=\\delta(s,v_{k})=\\delta(s,v)\\).\n\n_Corollary 22.3_: Let \\(G=(V,E)\\) be a weighted, directed graph with source vertex \\(s\\) and weight function \\(w:E\\to\\mathbb{R}\\). Then, for each vertex \\(v\\in V\\), there is a path from \\(s\\) to \\(v\\) if and only if Bellman-Ford terminates with \\(v.d<\\infty\\) when it is run on \\(G\\).\n\n_Proof_ The proof is left as Exercise 22.1-2.\n\n_Theorem 22.4_ (Correctness of the Bellman-Ford algorithm): Let Bellman-Ford be run on a weighted, directed graph \\(G=(V,E)\\) with source vertex \\(s\\) and weight function \\(w:E\\to\\mathbb{R}\\). If \\(G\\) contains no negative-weight cycles that are reachable from \\(s\\), then the algorithm returns true, \\(v.d=\\delta(s,v)\\) for all vertices \\(v\\in V\\), and the predecessor subgraph \\(G_{\\pi}\\) is a shortest-paths tree rooted at \\(s\\). If \\(G\\) does contain a negative-weight cycle reachable from \\(s\\), then the algorithm returns false.\n\n_Proof_ Suppose that graph \\(G\\) contains no negative-weight cycles that are reachable from the source \\(s\\). We first prove the claim that at termination, \\(v.d=\\delta(s,v)\\) for all vertices \\(v\\in V\\). If vertex \\(v\\) is reachable from \\(s\\), then Lemma 22.2 proves this claim. If \\(v\\) is not reachable from \\(s\\), then the claim follows from the no-path property. Thus, the claim is proven. The predecessor-subgraph property, along with the claim, implies that \\(G_{\\pi}\\) is a shortest-paths tree. Now we use the claim to show that Bellman-Ford returns true. At termination, for all edges \\((u,v)\\in E\\) we have\n\n\\[v.d = \\delta(s,v)\\] \\[\\leq \\delta(s,u)\\,+w(u,v)\\quad\\mbox{(by the triangle inequality)}\\] \\[= u.d\\,+w(u,v)\\,\\]and so none of the tests in line 6 causes Bellman-Ford to return false. Therefore, it returns true.\n\nNow, suppose that graph \\(G\\) contains a negative-weight cycle reachable from the source \\(s\\). Let this cycle be \\(c\\,=\\,\\langle v_{0},\\,v_{1},\\ldots,v_{k}\\rangle\\), where \\(v_{0}\\,=\\,v_{k}\\), in which case we have\n\n\\[\\sum_{i\\,=\\,1}^{k}w(v_{i\\,-\\,1},v_{i})\\,<\\,0. \\tag{22.1}\\]\n\nAssume for the purpose of contradiction that the Bellman-Ford algorithm returns true. Thus, \\(v_{i\\,}.\\,d\\,\\leq\\,v_{i\\,-\\,1}.\\,d\\,+\\,w(v_{i\\,-\\,1},v_{i})\\) for \\(i\\,=\\,1,2,\\ldots,k\\). Summing the inequalities around cycle \\(c\\) gives\n\n\\[\\sum_{i\\,=\\,1}^{k}v_{i\\,}.\\,d \\,\\leq\\,\\sum_{i\\,=\\,1}^{k}(v_{i\\,-\\,1}.\\,d\\,+\\,w(v_{i\\,-\\,1},v_{i }))\\] \\[\\,=\\,\\sum_{i\\,=\\,1}^{k}v_{i\\,-\\,1}.\\,d\\,+\\,\\sum_{i\\,=\\,1}^{k}w(v_{ i\\,-\\,1},v_{i})\\.\\]\n\nSince \\(v_{0}\\,=\\,v_{k}\\), each vertex in \\(c\\) appears exactly once in each of the summations \\(\\sum_{i\\,=\\,1}^{k}v_{i\\,}.\\,d\\) and \\(\\sum_{i\\,=\\,1}^{k}v_{i\\,-\\,1}.\\,d\\), and so\n\n\\[\\sum_{i\\,=\\,1}^{k}v_{i\\,}.\\,d\\,=\\,\\sum_{i\\,=\\,1}^{k}v_{i\\,-\\,1}.\\,d\\.\\]\n\nMoreover, by Corollary 22.3, \\(v_{i\\,}.\\,d\\) is finite for \\(i\\,=\\,1,2,\\ldots,k\\). Thus,\n\n\\[0\\,\\leq\\,\\sum_{i\\,=\\,1}^{k}w(v_{i\\,-\\,1},v_{i})\\,\\]\n\nwhich contradicts inequality (22.1). We conclude that the Bellman-Ford algorithm returns true if graph \\(G\\) contains no negative-weight cycles reachable from the source, and false otherwise.\n\n### Exercises\n\n#### 22.1-1\n\nRun the Bellman-Ford algorithm on the directed graph of Figure 22.4, using vertex \\(z\\) as the source. In each pass, relax edges in the same order as in the figure, and show the \\(d\\) and \\(\\pi\\) values after each pass. Now, change the weight of edge \\((z,x)\\) to 4 and run the algorithm again, using \\(s\\) as the source.\n\n#### 22.1-2\n\nProve Corollary 22.3.\n\n#### 22.1-3\n\nGiven a weighted, directed graph \\(G=(V,E)\\) with no negative-weight cycles, let \\(m\\) be the maximum over all vertices \\(v\\in V\\) of the minimum number of edges in a shortest path from the source \\(s\\) to \\(v\\). (Here, the shortest path is by weight, not the number of edges.) Suggest a simple change to the Bellman-Ford algorithm that allows it to terminate in \\(m+1\\) passes, even if \\(m\\) is not known in advance.\n\n#### 22.1-4\n\nModify the Bellman-Ford algorithm so that it sets \\(v.d\\) to \\(-\\infty\\) for all vertices \\(v\\) for which there is a negative-weight cycle on some path from the source to \\(v\\).\n\n#### 22.1-5\n\nSuppose that the graph given as input to the Bellman-Ford algorithm is represented with a list of \\(|E|\\) edges, where each edge indicates the vertices it leaves and enters, along with its weight. Argue that the Bellman-Ford algorithm runs in \\(O(VE)\\) time without the constraint that \\(|E|=\\Omega(\\mathcal{V})\\). Modify the Bellman-Ford algorithm so that it runs in \\(O(VE)\\) time in all cases when the input graph is represented with adjacency lists.\n\n#### 22.1-6\n\nLet \\(G=(V,E)\\) be a weighted, directed graph with weight function \\(w:E\\to\\mathbb{R}\\). Give an \\(O(VE)\\)-time algorithm to find, for all vertices \\(v\\in V\\), the value \\(\\delta^{*}(v)=\\min\\left\\{\\delta(u,v):u\\in V\\right\\}\\).\n\n#### 22.1-7\n\nSuppose that a weighted, directed graph \\(G=(V,E)\\) contains a negative-weight cycle. Give an efficient algorithm to list the vertices of one such cycle. Prove that your algorithm is correct.\n\n### Single-source shortest paths in directed acyclic graphs\n\nIn this section, we introduce one further restriction on weighted, directed graphs: they are acyclic. That is, we are concerned with weighted dags. Shortest paths are always well defined in a dag, since even if there are negative-weight edges, no negative-weight cycles can exist. We'll see that if the edges of a weighted dag \\(G=(V,E)\\) are relaxed according to a topological sort of its vertices, it takes only \\(\\Theta(V+E)\\) time to compute shortest paths from a single source.\n\nThe algorithm starts by topologically sorting the dag (see Section 20.4) to impose a linear ordering on the vertices. If the dag contains a path from vertex \\(u\\) to vertex \\(v\\), then \\(u\\) precedes \\(v\\) in the topological sort. The Dag-Shortest-Path",
        "chapter": "Part VI Graph Algorithms",
        "section": "22 Single-Source Shortest Paths",
        "subsection": "22.1 The Bellman-Ford algorithm",
        "subsubsection": "N/A"
    },
    {
        "content": "#### 22.1-3\n\nGiven a weighted, directed graph \\(G=(V,E)\\) with no negative-weight cycles, let \\(m\\) be the maximum over all vertices \\(v\\in V\\) of the minimum number of edges in a shortest path from the source \\(s\\) to \\(v\\). (Here, the shortest path is by weight, not the number of edges.) Suggest a simple change to the Bellman-Ford algorithm that allows it to terminate in \\(m+1\\) passes, even if \\(m\\) is not known in advance.\n\n#### 22.1-4\n\nModify the Bellman-Ford algorithm so that it sets \\(v.d\\) to \\(-\\infty\\) for all vertices \\(v\\) for which there is a negative-weight cycle on some path from the source to \\(v\\).\n\n#### 22.1-5\n\nSuppose that the graph given as input to the Bellman-Ford algorithm is represented with a list of \\(|E|\\) edges, where each edge indicates the vertices it leaves and enters, along with its weight. Argue that the Bellman-Ford algorithm runs in \\(O(VE)\\) time without the constraint that \\(|E|=\\Omega(\\mathcal{V})\\). Modify the Bellman-Ford algorithm so that it runs in \\(O(VE)\\) time in all cases when the input graph is represented with adjacency lists.\n\n#### 22.1-6\n\nLet \\(G=(V,E)\\) be a weighted, directed graph with weight function \\(w:E\\to\\mathbb{R}\\). Give an \\(O(VE)\\)-time algorithm to find, for all vertices \\(v\\in V\\), the value \\(\\delta^{*}(v)=\\min\\left\\{\\delta(u,v):u\\in V\\right\\}\\).\n\n#### 22.1-7\n\nSuppose that a weighted, directed graph \\(G=(V,E)\\) contains a negative-weight cycle. Give an efficient algorithm to list the vertices of one such cycle. Prove that your algorithm is correct.\n\n### Single-source shortest paths in directed acyclic graphs\n\nIn this section, we introduce one further restriction on weighted, directed graphs: they are acyclic. That is, we are concerned with weighted dags. Shortest paths are always well defined in a dag, since even if there are negative-weight edges, no negative-weight cycles can exist. We'll see that if the edges of a weighted dag \\(G=(V,E)\\) are relaxed according to a topological sort of its vertices, it takes only \\(\\Theta(V+E)\\) time to compute shortest paths from a single source.\n\nThe algorithm starts by topologically sorting the dag (see Section 20.4) to impose a linear ordering on the vertices. If the dag contains a path from vertex \\(u\\) to vertex \\(v\\), then \\(u\\) precedes \\(v\\) in the topological sort. The Dag-Shortest-Pathprocedure makes just one pass over the vertices in the topologically sorted order. As it processes each vertex, it relaxes each edge that leaves the vertex. Figure 22.5 shows the execution of this algorithm.\n\n```\nDag-Shortest-Paths(\\(G,w,s\\))\n1 topologically sort the vertices of \\(G\\)\n2Initialize-Single-Source(\\(G,s\\))\n3foreach vertex \\(u\\in G.V,\\) taken in topologically sorted order\n4for each vertex \\(v\\) in \\(G.Adj[u]\\)\n5Relax(\\(u,v,w\\))\n```\n\nLet's analyze the running time of this algorithm. As shown in Section 20.4, the topological sort of line 1 takes \\(\\Theta(V\\,+\\,E)\\) time. The call of Initialize-Single-Source in line 2 takes \\(\\Theta(V)\\) time. The **for** loop of lines 3-5 makes one iteration per vertex. Altogether, the **for** loop of lines 4-5 relaxes each edge exactly once. (We have used an aggregate analysis here.) Because each iteration of the inner **for** loop takes \\(\\Theta(1)\\) time, the total running time is \\(\\Theta(V\\,+\\,E)\\), which is linear in the size of an adjacency-list representation of the graph.\n\nThe following theorem shows that the Dag-Shortest-Paths procedure correctly computes the shortest paths.\n\n**Theorem 22.5**: _If a weighted, directed graph \\(G=(V,E)\\) has source vertex \\(s\\) and no cycles, then at the termination of the Dag-Shortest-Paths procedure, \\(v.d=\\delta(s,v)\\) for all vertices \\(v\\in V\\), and the predecessor subgraph \\(G_{\\pi}\\) is a shortest-paths tree._\n\n_Proof_ We first show that \\(v.d=\\delta(s,v)\\) for all vertices \\(v\\in V\\) at termination. If \\(v\\) is not reachable from \\(s\\), then \\(v.d=\\delta(s,v)=\\infty\\) by the no-path property. Now, suppose that \\(v\\) is reachable from \\(s\\), so that there is a shortest path \\(p=(v_{0},v_{1},\\ldots,v_{k})\\), where \\(v_{0}=s\\) and \\(v_{k}=v\\). Because Dag-Shortest-Paths processes the vertices in topologically sorted order, it relaxes the edges on \\(p\\) in the order \\((v_{0},v_{1}),(v_{1},v_{2}),\\ldots,(v_{k-1},v_{k})\\). The path-relaxation property implies that \\(v_{i}.d=\\delta(s,v_{i})\\) at termination for \\(i=0,1,\\ldots,k\\). Finally, by the predecessor-subgraph property, \\(G_{\\pi}\\) is a shortest-paths tree.\n\nA useful application of this algorithm arises in determining critical paths in _PERT chart_2 analysis. A job consists of several tasks. Each task takes a certain amount of time, and some tasks must be completed before others can be started. For example, if the job is to build a house, then the foundation must be completed before starting to frame the exterior walls, which must be completed before starting on the roof. Some tasks require more than one other task to be completed before they can be started: before the drywall can be installed over the wall framing, both the electrical system and plumbing must be installed. A dag models the tasks and dependencies. Edges represent tasks, with the weight of an edge indicating the time required to perform the task. Vertices represent \"milestones,\" which are\n\nFigure 22.5: The execution of the algorithm for shortest paths in a directed acyclic graph. The vertices are topologically sorted from left to right. The source vertex is \\(s\\). The \\(d\\) values appear within the vertices, and blue edges indicate the \\(\\pi\\) values. **(a)** The situation before the first iteration of the **for** loop of lines 3\u20135. **(b)\u2013(g)** The situation after each iteration of the **for** loop of lines 3\u20135. Blue vertices have had their outgoing edges relaxed. The vertex highlighted in orange was used as \\(u\\) in that iteration. Each edge highlighted in orange caused a \\(d\\) value to change when it was relaxed in that iteration. The values shown in part (g) are the final values.\n\nachieved when all the tasks represented by the edges entering the vertex have been completed. If edge \\((u,v)\\) enters vertex \\(v\\) and edge \\((v,x)\\) leaves \\(v\\), then task \\((u,v)\\) must be completed before task \\((v,x)\\) is started. A path through this dag represents a sequence of tasks that must be performed in a particular order. A _critical path_ is a _longest_ path through the dag, corresponding to the longest time to perform any sequence of tasks. Thus, the weight of a critical path provides a lower bound on the total time to perform all the tasks, even if as many tasks as possible are performed simultaneously. You can find a critical path by either\n\n* negating the edge weights and running Dag-Shortest-Paths, or\n* running Dag-Shortest-Paths, but replacing \"\\(\\infty\\)\" by \"\\(-\\infty\\)\" in line 2 of Initialize-Single-Source and \"\\(>\\)\" by \"\\(<\\)\" in the Relax procedure.\n\n##### Exercises\n\n##### 22.2-1\n\nShow the result of running Dag-Shortest-Paths on the directed acyclic graph of Figure 22.5, using vertex \\(r\\) as the source.\n\n##### 22.2-2\n\nSuppose that you change line 3 of Dag-Shortest-Paths to read\n\n* for the first \\(|V|-1\\) vertices, taken in topologically sorted order\n\nShow that the procedure remains correct.\n\n##### 22.2-3\n\nAn alternative way to represent a PERT chart looks more like the dag of Figure 20.7 on page 574. Vertices represent tasks and edges represent sequencing constraints, that is, edge \\((u,v)\\) indicates that task \\(u\\) must be performed before task \\(v\\). Vertices, not edges, have weights. Modify the Dag-Shortest-Paths procedure so that it finds a longest path in a directed acyclic graph with weighted vertices in linear time.\n\n##### 22.2-4\n\nGive an efficient algorithm to count the total number of paths in a directed acyclic graph. The count should include all paths between all pairs of vertices and all paths with 0 edges. Analyze your algorithm.\n\n### Dijkstra's algorithm\n\nDijkstra's algorithm solves the single-source shortest-paths problem on a weighted, directed graph \\(G=(V,E)\\), but it requires nonnegative weights on all edges: \\(w(u,v)\\geq 0\\) for each edge \\((u,v)\\in E\\). As we shall see, with a good implementation, the running time of Dijkstra's algorithm is lower than that of the Bellman-Ford algorithm.\n\nYou can think of Dijkstra's algorithm as generalizing breadth-first search to weighted graphs. A wave emanates from the source, and the first time that a wave arrives at a vertex, a new wave emanates from that vertex. Whereas breadth-first search operates as if each wave takes unit time to traverse an edge, in a weighted graph, the time for a wave to traverse an edge is given by the edge's weight. Because a shortest path in a weighted graph might not have the fewest edges, a simple, first-in, first-out queue won't suffice for choosing the next vertex from which to send out a wave.\n\nInstead, Dijkstra's algorithm maintains a set \\(S\\) of vertices whose final shortest-path weights from the source \\(s\\) have already been determined. The algorithm repeatedly selects the vertex \\(u\\in V-S\\) with the minimum shortest-path estimate, adds \\(u\\) into \\(S\\), and relaxes all edges leaving \\(u\\). The procedure Dijkstra replaces the first-in, first-out queue of breadth-first search by a min-priority queue \\(Q\\) of vertices, keyed by their \\(d\\) values.\n\nDijkstra's algorithm relaxes edges as shown in Figure 22.6. Line 1 initializes the \\(d\\) and \\(\\pi\\) values in the usual way, and line 2 initializes the set \\(S\\) to the empty set. The algorithm maintains the invariant that \\(Q=V-S\\) at the start of each iteration",
        "chapter": "Part VI Graph Algorithms",
        "section": "22 Single-Source Shortest Paths",
        "subsection": "22.2 Single-source shortest paths in directed acyclic graphs",
        "subsubsection": "N/A"
    },
    {
        "content": "### Dijkstra's algorithm\n\nDijkstra's algorithm solves the single-source shortest-paths problem on a weighted, directed graph \\(G=(V,E)\\), but it requires nonnegative weights on all edges: \\(w(u,v)\\geq 0\\) for each edge \\((u,v)\\in E\\). As we shall see, with a good implementation, the running time of Dijkstra's algorithm is lower than that of the Bellman-Ford algorithm.\n\nYou can think of Dijkstra's algorithm as generalizing breadth-first search to weighted graphs. A wave emanates from the source, and the first time that a wave arrives at a vertex, a new wave emanates from that vertex. Whereas breadth-first search operates as if each wave takes unit time to traverse an edge, in a weighted graph, the time for a wave to traverse an edge is given by the edge's weight. Because a shortest path in a weighted graph might not have the fewest edges, a simple, first-in, first-out queue won't suffice for choosing the next vertex from which to send out a wave.\n\nInstead, Dijkstra's algorithm maintains a set \\(S\\) of vertices whose final shortest-path weights from the source \\(s\\) have already been determined. The algorithm repeatedly selects the vertex \\(u\\in V-S\\) with the minimum shortest-path estimate, adds \\(u\\) into \\(S\\), and relaxes all edges leaving \\(u\\). The procedure Dijkstra replaces the first-in, first-out queue of breadth-first search by a min-priority queue \\(Q\\) of vertices, keyed by their \\(d\\) values.\n\nDijkstra's algorithm relaxes edges as shown in Figure 22.6. Line 1 initializes the \\(d\\) and \\(\\pi\\) values in the usual way, and line 2 initializes the set \\(S\\) to the empty set. The algorithm maintains the invariant that \\(Q=V-S\\) at the start of each iterationof the **while** loop of lines 6-12. Lines 3-5 initialize the min-priority queue \\(Q\\) to contain all the vertices in \\(V\\). Since \\(S=\\emptyset\\) at that time, the invariant is true upon first reaching line 6. Each time through the **while** loop of lines 6-12, line 7 extracts a vertex \\(u\\) from \\(Q=V-S\\) and line 8 adds it to set \\(S\\), thereby maintaining the invariant. (The first time through this loop, \\(u=s\\).) Vertex \\(u\\), therefore, has the smallest shortest-path estimate of any vertex in \\(V-S\\). Then, lines 9-12 relax each edge \\((u,v)\\) leaving \\(u\\), thus updating the estimate \\(v.d\\) and the predecessor \\(v.\\pi\\) if the shortest path to \\(v\\) found so far improves by going through \\(u\\). Whenever a relaxation step changes the \\(d\\) and \\(\\pi\\) values, the call to Decrease-Key in line 12 updates the min-priority queue. The algorithm never inserts vertices into \\(Q\\) after the **for** loop of lines 4-5, and each vertex is extracted from \\(Q\\) and added to \\(S\\) exactly once, so that the **while** loop of lines 6-12 iterates exactly \\(|V|\\) times.\n\nBecause Dijkstra's algorithm always chooses the \"lightest\" or \"closest\" vertex in \\(V-S\\) to add to set \\(S\\), you can think of it as using a greedy strategy. Chapter 15 explains greedy strategies in detail, but you need not have read that chapter to understand Dijkstra's algorithm. Greedy strategies do not always yield optimal\n\nFigure 22.6: The execution of Dijkstra\u2019s algorithm. The source \\(s\\) is the leftmost vertex. The shortest-path estimates appear within the vertices, and blue edges indicate predecessor values. Blue vertices belong to the set \\(S\\), and tan vertices are in the min-priority queue \\(Q=V-S\\). **(a)** The situation just before the first iteration of the **while** loop of lines 6\u201312. **(b)\u2013(f)** The situation after each successive iteration of the **while** loop. In each part, the vertex highlighted in orange was chosen as vertex \\(u\\) in line 7, and each edge highlighted in orange caused a \\(d\\) value and a predecessor to change when the edge was relaxed. The \\(d\\) values and predecessors shown in part (f) are the final values.\n\nresults in general, but as the following theorem and its corollary show, Dijkstra's algorithm does indeed compute shortest paths. The key is to show that \\(u.d=\\delta(s,u)\\) each time it adds a vertex \\(u\\) to set \\(S\\).\n\n**Theorem 22.6** (Correctness of Dijkstra's algorithm): _Dijkstra's algorithm, run on a weighted, directed graph \\(G=(V,E)\\) with nonnegative weight function \\(w\\) and source vertex \\(s\\), terminates with \\(u.d=\\delta(s,u)\\) for all vertices \\(u\\in V\\)._\n\nWe will show that at the start of each iteration of the **while** loop of lines 6-12, we have \\(v.d=\\delta(s,v)\\) for all \\(v\\in S\\). The algorithm terminates when \\(S=V\\), so that \\(v.d=\\delta(s,v)\\) for all \\(v\\in V\\).\n\nThe proof is by induction on the number of iterations of the **while** loop, which equals \\(|S|\\) at the start of each iteration. There are two bases: for \\(|S|=0\\), so that \\(S=\\emptyset\\) and the claim is trivially true, and for \\(|S|=1\\), so that \\(S=\\{s\\}\\) and \\(s.d=\\delta(s,s)=0\\).\n\nFor the inductive step, the inductive hypothesis is that \\(v.d=\\delta(s,v)\\) for all \\(v\\in S\\). The algorithm extracts vertex \\(u\\) from \\(V-S\\). Because the algorithm adds \\(u\\) into \\(S\\), we need to show that \\(u.d=\\delta(s,u)\\) at that time. If there is no path from \\(s\\) to \\(u\\), then we are done, by the no-path property. If there is a path from \\(s\\) to \\(u\\), then, as Figure 22.7 shows, let \\(y\\) be the first vertex on a shortest path from \\(s\\) to \\(u\\) that is not in \\(S\\), and let \\(x\\in S\\) be the predecessor of \\(y\\) on that shortest path. (We could have \\(y=u\\) or \\(x=s\\).) Because \\(y\\) appears no later than \\(u\\) on the shortest path and all edge weights are nonnegative, we have \\(\\delta(s,y)\\leq\\delta(s,u)\\). Because the call of Extract-Min in line 7 returned \\(u\\) as having the minimum \\(d\\) value in \\(V-S\\), we also have \\(u.d\\leq y.d\\), and the upper-bound property gives \\(\\delta(s,u)\\leq u.d\\).\n\nSince \\(x\\in S\\), the inductive hypothesis implies that \\(x.d=\\delta(s,x)\\). During the iteration of the **while** loop that added \\(x\\) into \\(S\\), edge \\((x,y)\\) was relaxed. By the convergence property, \\(y.d\\) received the value of \\(\\delta(s,y)\\) at that time. Thus, we have\n\nFigure 22.7: The proof of Theorem 22.6. Vertex \\(u\\) is selected to be added into set \\(S\\) in line 7 of Dijkstra. Vertex \\(y\\) is the first vertex on a shortest path from the source \\(s\\) to vertex \\(u\\) that is not in set \\(S\\), and \\(x\\in S\\) is \\(y\\)\u2019s predecessor on that shortest path. The subpath from \\(y\\) to \\(u\\) may or may not re-enter set \\(S\\).\n\n\\(\\delta(s,y)\\leq\\delta(s,u)\\leq u.d\\leq y.d\\) and \\(y.d=\\delta(s,y)\\), so that\n\n\\(\\delta(s,y)=\\delta(s,u)=u.d=y.d\\).\n\nHence, \\(u.d=\\delta(s,u)\\), and by the upper-bound property, this value never changes again.\n\n**Corollary 22.7**: _After Dijkstra's algorithm is run on a weighted, directed graph \\(G=(V,E)\\) with nonnegative weight function \\(w\\) and source vertex \\(s\\), the predecessor subgraph \\(G_{\\pi}\\) is a shortest-paths tree rooted at \\(s\\)._\n\n_Proof_ Immediate from Theorem 22.6 and the predecessor-subgraph property.\n\n**Analysis**\n\nHow fast is Dijkstra's algorithm? It maintains the min-priority queue \\(Q\\) by calling three priority-queue operations: Insert (in line 5), Extract-Min (in line 7), and Decrease-Key (in line 12). The algorithm calls both Insert and Extract-Min once per vertex. Because each vertex \\(u\\in V\\) is added to set \\(S\\) exactly once, each edge in the adjacency list \\(Adj[u]\\) is examined in the **for** loop of lines 9-12 exactly once during the course of the algorithm. Since the total number of edges in all the adjacency lists is \\(|E|\\), this **for** loop iterates a total of \\(|E|\\) times, and thus the algorithm calls Decrease-Key at most \\(|E|\\) times overall. (Observe once again that we are using aggregate analysis.)\n\nJust as in Prim's algorithm, the running time of Dijkstra's algorithm depends on the specific implementation of the min-priority queue \\(Q\\). A simple implementation takes advantage of the vertices being numbered 1 to \\(|V|\\): simply store \\(v.d\\) in the \\(v\\)th entry of an array. Each Insert and Decrease-Key operation takes \\(O(1)\\) time, and each Extract-Min operation takes \\(O(V)\\) time (since it has to search through the entire array), for a total time of \\(O(V^{2}+E)=O(V^{2})\\).\n\nIf the graph is sufficiently sparse--in particular, \\(E=o(V^{2}/\\lg V)\\)--you can improve the running time by implementing the min-priority queue with a binary min-heap that includes a way to map between vertices and their corresponding heap elements. Each Extract-Min operation then takes \\(O(\\lg V)\\) time. As before, there are \\(|V|\\) such operations. The time to build the binary min-heap is \\(O(V)\\). (As noted in Section 21.2, you don't even need to call Build-Min-Heap.) Each Decrease-Key operation takes \\(O(\\lg V)\\) time, and there are still at most \\(|E|\\) such operations. The total running time is therefore \\(O((V+E)\\lg V)\\), which is \\(O(E\\lg V)\\) in the typical case that \\(|E|=\\Omega(\\mathcal{V})\\). This running time improves upon the straightforward \\(O(V^{2})\\)-time implementation if \\(E=o(V^{2}/\\lg V)\\).\n\nBy implementing the min-priority queue with a Fibonacci heap (see page 478), you can improve the running time to \\(\\mathit{O}(V\\lg V+E)\\). The amortized cost of each of the \\(|V|\\)Extract-Min operations is \\(\\mathit{O}(\\lg V)\\), and each Decrease-Key call, of which there are at most \\(|E|\\), takes only \\(\\mathit{O}(1)\\) amortized time. Historically, the development of Fibonacci heaps was motivated by the observation that Dijkstra's algorithm typically makes many more Decrease-Key calls than Extract-Min calls, so that any method of reducing the amortized time of each Decrease-Key operation to \\(o(\\lg V)\\) without increasing the amortized time of Extract-Min would yield an asymptotically faster implementation than with binary heaps.\n\nDijkstra's algorithm resembles both breadth-first search (see Section 20.2) and Prim's algorithm for computing minimum spanning trees (see Section 21.2). It is like breadth-first search in that set \\(S\\) corresponds to the set of black vertices in a breadth-first search. Just as vertices in \\(S\\) have their final shortest-path weights, so do black vertices in a breadth-first search have their correct breadth-first distances. Dijkstra's algorithm is like Prim's algorithm in that both algorithms use a min-priority queue to find the \"lightest\" vertex outside a given set (the set \\(S\\) in Dijkstra's algorithm and the tree being grown in Prim's algorithm), add this vertex into the set, and adjust the weights of the remaining vertices outside the set accordingly.\n\n### Exercises\n\n#### 22.3-1\n\nRun Dijkstra's algorithm on the directed graph of Figure 22.2, first using vertex \\(s\\) as the source and then using vertex \\(z\\) as the source. In the style of Figure 22.6, show the \\(d\\) and \\(\\pi\\) values and the vertices in set \\(S\\) after each iteration of the **while** loop.\n\n#### 22.3-2\n\nGive a simple example of a directed graph with negative-weight edges for which Dijkstra's algorithm produces an incorrect answer. Why doesn't the proof of Theorem 22.6 go through when negative-weight edges are allowed?\n\n#### 22.3-3\n\nSuppose that you change line 6 of Dijkstra's algorithm to read\n\n## 6 while \\(|\\mathit{Q}|>1\\)\n\nThis change causes the **while** loop to execute \\(|V|-1\\) times instead of \\(|V|\\) times. Is this proposed algorithm correct?\nModify the Dijkstra procedure so that the priority queue \\(Q\\) is more like the queue in the BFS procedure in that it contains only vertices that have been reached from source \\(s\\) so far: \\(Q\\subseteq V-S\\) and \\(v\\in Q\\) implies \\(v.d\\neq\\infty\\).\n\nProfessor Gaedel has written a program that he claims implements Dijkstra's algorithm. The program produces \\(v.d\\) and \\(v.\\pi\\) for each vertex \\(v\\in V\\). Give an \\(O(V+E)\\)-time algorithm to check the output of the professor's program. It should determine whether the \\(d\\) and \\(\\pi\\) attributes match those of some shortest-paths tree. You may assume that all edge weights are nonnegative.\n\nProfessor Newman thinks that he has worked out a simpler proof of correctness for Dijkstra's algorithm. He claims that Dijkstra's algorithm relaxes the edges of every shortest path in the graph in the order in which they appear on the path, and therefore the path-relaxation property applies to every vertex reachable from the source. Show that the professor is mistaken by constructing a directed graph for which Dijkstra's algorithm relaxes the edges of a shortest path out of order.\n\nConsider a directed graph \\(G=(V,E)\\) on which each edge \\((u,v)\\in E\\) has an associated value \\(r(u,v)\\), which is a real number in the range \\(0\\leq r(u,v)\\leq 1\\) that represents the reliability of a communication channel from vertex \\(u\\) to vertex \\(v\\). Interpret \\(r(u,v)\\) as the probability that the channel from \\(u\\) to \\(v\\) will not fail, and assume that these probabilities are independent. Give an efficient algorithm to find the most reliable path between two given vertices.\n\nLet \\(G=(V,E)\\) be a weighted, directed graph with positive weight function \\(w:E\\to\\{1,2,\\ldots,W\\}\\) for some positive integer \\(W\\), and assume that no two vertices have the same shortest-path weights from source vertex \\(s\\). Now define an unweighted, directed graph \\(G^{\\prime}=(V\\cup V^{\\prime},E^{\\prime})\\) by replacing each edge \\((u,v)\\in E\\) with \\(w(u,v)\\) unit-weight edges in series. How many vertices does \\(G^{\\prime}\\) have? Now suppose that you run a breadth-first search on \\(G^{\\prime}\\). Show that the order in which the breadth-first search of \\(G^{\\prime}\\) colors vertices in \\(V\\) black is the same as the order in which Dijkstra's algorithm extracts the vertices of \\(V\\) from the priority queue when it runs on \\(G\\).\n\nLet \\(G=(V,E)\\) be a weighted, directed graph with nonnegative weight function \\(w:E\\to\\{0,1,\\ldots,W\\}\\) for some nonnegative integer \\(W\\). Modify Dijkstra's algorithm to compute the shortest paths from a given source vertex \\(s\\) in \\(O(W\\,V\\,+\\,E)\\) time.\n\n_22.3-10_\n\nModify your algorithm from Exercise 22.3-9 to run in \\(O((V\\,+\\,E)\\,\\lg\\,W)\\) time. (_Hint:_ How many distinct shortest-path estimates can \\(V\\,-\\,S\\) contain at any point in time?)\n\n_22.3-11_\n\nSuppose that you are given a weighted, directed graph \\(G\\,=\\,(V,\\,E)\\) in which edges that leave the source vertex \\(s\\) may have negative weights, all other edge weights are nonnegative, and there are no negative-weight cycles. Argue that Dijkstra's algorithm correctly finds shortest paths from \\(s\\) in this graph.\n\n_22.3-12_\n\nSuppose that you have a weighted directed graph \\(G\\,=\\,(V,\\,E)\\) in which all edge weights are positive real values in the range \\([C,2C]\\) for some positive constant \\(C\\). Modify Dijkstra's algorithm so that it runs in \\(O(V\\,+\\,E)\\) time.\n\n### 22.4 Difference constraints and shortest paths\n\nChapter 29 studies the general linear-programming problem, showing how to optimize a linear function subject to a set of linear inequalities. This section investigates a special case of linear programming that reduces to finding shortest paths from a single source. The Bellman-Ford algorithm then solves the resulting single-source shortest-paths problem, thereby also solving the linear-programming problem.\n\n#### Linear programming\n\nIn the general _linear-programming problem_, the input is an \\(m\\times n\\) matrix \\(A\\), an \\(m\\)-vector \\(b\\), and an \\(n\\)-vector \\(c\\). The goal is to find a vector \\(x\\) of \\(n\\) elements that maximizes the _objective function_\\(\\sum_{i\\,=\\,1}^{n}c_{i}x_{i}\\) subject to the \\(m\\) constraints given by \\(Ax\\leq b\\).\n\nThe most popular method for solving linear programs is the _simplex algorithm_, which Section 29.1 discusses. Although the simplex algorithm does not always run in time polynomial in the size of its input, there are other linear-programming algorithms that do run in polynomial time. We offer here two reasons to understand the setup of linear-programming problems. First, if you know that you can cast a given problem as a polynomial-sized linear-programming problem, then you im",
        "chapter": "Part VI Graph Algorithms",
        "section": "22 Single-Source Shortest Paths",
        "subsection": "22.3 Dijkstra\u2019s algorithm",
        "subsubsection": "N/A"
    },
    {
        "content": "rithm to compute the shortest paths from a given source vertex \\(s\\) in \\(O(W\\,V\\,+\\,E)\\) time.\n\n_22.3-10_\n\nModify your algorithm from Exercise 22.3-9 to run in \\(O((V\\,+\\,E)\\,\\lg\\,W)\\) time. (_Hint:_ How many distinct shortest-path estimates can \\(V\\,-\\,S\\) contain at any point in time?)\n\n_22.3-11_\n\nSuppose that you are given a weighted, directed graph \\(G\\,=\\,(V,\\,E)\\) in which edges that leave the source vertex \\(s\\) may have negative weights, all other edge weights are nonnegative, and there are no negative-weight cycles. Argue that Dijkstra's algorithm correctly finds shortest paths from \\(s\\) in this graph.\n\n_22.3-12_\n\nSuppose that you have a weighted directed graph \\(G\\,=\\,(V,\\,E)\\) in which all edge weights are positive real values in the range \\([C,2C]\\) for some positive constant \\(C\\). Modify Dijkstra's algorithm so that it runs in \\(O(V\\,+\\,E)\\) time.\n\n### 22.4 Difference constraints and shortest paths\n\nChapter 29 studies the general linear-programming problem, showing how to optimize a linear function subject to a set of linear inequalities. This section investigates a special case of linear programming that reduces to finding shortest paths from a single source. The Bellman-Ford algorithm then solves the resulting single-source shortest-paths problem, thereby also solving the linear-programming problem.\n\n#### Linear programming\n\nIn the general _linear-programming problem_, the input is an \\(m\\times n\\) matrix \\(A\\), an \\(m\\)-vector \\(b\\), and an \\(n\\)-vector \\(c\\). The goal is to find a vector \\(x\\) of \\(n\\) elements that maximizes the _objective function_\\(\\sum_{i\\,=\\,1}^{n}c_{i}x_{i}\\) subject to the \\(m\\) constraints given by \\(Ax\\leq b\\).\n\nThe most popular method for solving linear programs is the _simplex algorithm_, which Section 29.1 discusses. Although the simplex algorithm does not always run in time polynomial in the size of its input, there are other linear-programming algorithms that do run in polynomial time. We offer here two reasons to understand the setup of linear-programming problems. First, if you know that you can cast a given problem as a polynomial-sized linear-programming problem, then you immediately have a polynomial-time algorithm to solve the problem. Second, faster algorithms exist for many special cases of linear programming. For example, the single-pair shortest-path problem (Exercise 22.4-4) and the maximum-flow problem (Exercise 24.1-5) are special cases of linear programming.\n\nSometimes the objective function does not matter: it's enough just to find any _feasible solution_, that is, any vector \\(x\\) that satisfies \\(Ax\\leq b\\), or to determine that no feasible solution exists. This section focuses on one such _feasibility problem_.\n\n#### Systems of difference constraints\n\nIn a _system of difference constraints_, each row of the linear-programming matrix \\(A\\) contains one \\(1\\) and one \\(-1\\), and all other entries of \\(A\\) are \\(0\\). Thus, the constraints given by \\(Ax\\leq b\\) are a set of \\(m\\)_difference constraints_ involving \\(n\\) unknowns, in which each constraint is a simple linear inequality of the form\n\n\\[x_{j}-x_{i}\\leq b_{k}\\,\\]\n\nwhere \\(1\\leq i\\), \\(j\\leq n\\), \\(i\\neq j\\), and \\(1\\leq k\\leq m\\).\n\nFor example, consider the problem of finding a 5-vector \\(x=(x_{i})\\) that satisfies\n\n\\[\\left(\\begin{array}{cccc}1&-1&0&0&0\\\\ 1&0&0&0&-1\\\\ 0&1&0&0&-1\\\\ -1&0&1&0&0\\\\ -1&0&0&1&0\\\\ 0&0&-1&1&0\\\\ 0&0&-1&0&1\\\\ 0&0&0&-1&1\\end{array}\\right)\\,\\left(\\begin{array}{c}x_{1}\\\\ x_{2}\\\\ x_{3}\\\\ x_{4}\\\\ x_{5}\\end{array}\\right)\\ \\leq\\ \\left(\\begin{array}{c}0\\\\ -1\\\\ 1\\\\ 5\\\\ -1\\\\ -3\\\\ -3\\end{array}\\right)\\.\\]\n\nThis problem is equivalent to finding values for the unknowns \\(x_{1},x_{2},x_{3},x_{4},x_{5}\\), satisfying the following 8 difference constraints:\n\n\\[x_{1}-x_{2} \\leq \\ 0\\, \\tag{22.2}\\] \\[x_{1}-x_{5} \\leq \\ -1\\,\\] (22.3) \\[x_{2}-x_{5} \\leq \\ 1\\,\\] (22.4) \\[x_{3}-x_{1} \\leq \\ 5\\,\\] (22.5) \\[x_{4}-x_{1} \\leq \\ 4\\,\\] (22.6) \\[x_{4}-x_{3} \\leq \\ -1\\,\\] (22.7) \\[x_{5}-x_{3} \\leq \\ -3\\,\\] (22.8) \\[x_{5}-x_{4} \\leq \\ -3. \\tag{22.9}\\]\n\nOne solution to this problem is \\(x=(-5,-3,0,-1,-4)\\), which you can verify directly by checking each inequality. In fact, this problem has more than one solution.\n\nAnother is \\(x^{\\prime}=(0,2,5,4,1)\\). These two solutions are related: each component of \\(x^{\\prime}\\) is 5 larger than the corresponding component of \\(x\\). This fact is not mere coincidence.\n\n**Lemma 22.8**: \\(\\,\\)\n\nLet \\(x=(x_{1},x_{2},\\ldots,x_{n})\\) be a solution to a system \\(Ax\\leq b\\) of difference constraints, and let \\(d\\) be any constant. Then \\(x+d=(x_{1}+d,x_{2}+d,\\ldots,x_{n}+d)\\) is a solution to \\(Ax\\leq b\\) as well.\n\n_Proof_ For each \\(x_{i}\\) and \\(x_{j}\\), we have \\((x_{j}+d)-(x_{i}+d)=x_{j}-x_{i}\\). Thus, if \\(x\\) satisfies \\(Ax\\leq b\\), so does \\(x+d\\).\n\nSystems of difference constraints occur in various applications. For example, the unknowns \\(x_{i}\\) might be times at which events are to occur. Each constraint states that at least a certain amount of time, or at most a certain amount of time, must elapse between two events. Perhaps the events are jobs to be performed during the assembly of a product. If the manufacturer applies an adhesive that takes 2 hours to set at time \\(x_{1}\\) and has to wait until it sets to install a part at time \\(x_{2}\\), then there is a constraint that \\(x_{2}\\geq x_{1}+2\\) or, equivalently, that \\(x_{1}-x_{2}\\leq-2\\). Alternatively, the manufacturer might require the part to be installed after the adhesive has been applied but no later than the time that the adhesive has set halfway. In this case, there is a pair of constraints \\(x_{2}\\geq x_{1}\\) and \\(x_{2}\\leq x_{1}+1\\) or, equivalently, \\(x_{1}-x_{2}\\leq 0\\) and \\(x_{2}-x_{1}\\leq 1\\).\n\nIf all the constraints have nonnegative numbers on the right-hand side-- that is, if \\(b_{i}\\geq 0\\) for \\(i=1,2,\\ldots,m\\)--then finding a feasible solution is trivial: just set all the unknowns \\(x_{i}\\) equal to each other. Then all the differences are 0, and every constraint is satisfied. The problem of finding a feasible solution to a system of difference constraints is interesting only if at least one constraint has \\(b_{i}<0\\).\n\n### Constraint graphs\n\nWe can interpret systems of difference constraints from a graph-theoretic point of view. For a system \\(Ax\\leq b\\) of difference constraints, let's view the \\(m\\times n\\) linear-programming matrix \\(A\\) as the transpose of an incidence matrix (see Exercise 20.1-7) for a graph with \\(n\\) vertices and \\(m\\) edges. Each vertex \\(v_{i}\\) in the graph, for \\(i=1,2,\\ldots,n\\), corresponds to one of the \\(n\\) unknown variables \\(x_{i}\\). Each directed edge in the graph corresponds to one of the \\(m\\) inequalities involving two unknowns.\n\nMore formally, given a system \\(Ax\\leq b\\) of difference constraints, the corresponding _constraint graph_ is a weighted, directed graph \\(G=(V,E)\\), where \\(V=\\{v_{0},v_{1},\\ldots,v_{n}\\}\\)\n\nand\n\n\\(E=\\{(v_{i},v_{j}):x_{j}-x_{i}\\leq b_{k}\\text{ is a constraint}\\}\\)\n\n\\[\\cup\\left\\{(v_{0},v_{1}),(v_{0},v_{2}),(v_{0},v_{3}),\\ldots,(v_{0},v_{n})\\right\\} \\enspace.\\]\n\nThe constraint graph includes the additional vertex \\(v_{0}\\), as we shall see shortly, to guarantee that the graph has some vertex that can reach all other vertices. Thus, the vertex set \\(V\\) consists of a vertex \\(v_{i}\\) for each unknown \\(x_{i}\\), plus an additional vertex \\(v_{0}\\). The edge set \\(E\\) contains an edge for each difference constraint, plus an edge \\((v_{0},v_{i})\\) for each unknown \\(x_{i}\\). If \\(x_{j}-x_{i}\\leq b_{k}\\) is a difference constraint, then the weight of edge \\((v_{i},v_{j})\\) is \\(w(v_{i},v_{j})=b_{k}\\). The weight of each edge leaving \\(v_{0}\\) is 0. Figure 22.8 shows the constraint graph for the system (22.2)-(22.9) of difference constraints.\n\nThe following theorem shows how to solve a system of difference constraints by finding shortest-path weights in the corresponding constraint graph.\n\n**Theorem 22.9**: _Given a system \\(Ax\\leq b\\) of difference constraints, let \\(G=(V,E)\\) be the corresponding constraint graph. If \\(G\\) contains no negative-weight cycles, then_\n\n\\[x=(\\delta(v_{0},v_{1}),\\delta(v_{0},v_{2}),\\delta(v_{0},v_{3}),\\ldots,\\delta( v_{0},v_{n})) \\tag{22.10}\\]\n\n_is a feasible solution for the system. If \\(G\\) contains a negative-weight cycle, then there is no feasible solution for the system._\n\nFigure 22.8: The constraint graph corresponding to the system (22.2)\u2013(22.9) of difference constraints. The value of \\(\\delta(v_{0},v_{i})\\) appears in each vertex \\(v_{i}\\). One feasible solution to the system is \\(x=(-5,-3,0,-1,-4)\\).\n\nProofWe first show that if the constraint graph contains no negative-weight cycles, then equation (22.10) gives a feasible solution. Consider any edge \\((v_{i},v_{j})\\in E\\). The triangle inequality implies that \\(\\delta(v_{0},v_{j})\\leq\\delta(v_{0},v_{i})+w(v_{i},v_{j})\\), which is equivalent to \\(\\delta(v_{0},v_{j})-\\delta(v_{0},v_{i})\\leq w(v_{i},v_{j})\\). Thus, letting \\(x_{i}=\\delta(v_{0},v_{i})\\) and \\(x_{j}=\\delta(v_{0},v_{j})\\) satisfies the difference constraint \\(x_{j}-x_{i}\\leq w(v_{i},v_{j})\\) that corresponds to edge \\((v_{i},v_{j})\\).\n\nNow we show that if the constraint graph contains a negative-weight cycle, then the system of difference constraints has no feasible solution. Without loss of generality, let the negative-weight cycle be \\(c=\\{v_{1},\\,v_{2},\\,\\ldots,\\,v_{k}\\}\\), where \\(v_{1}=v_{k}\\). (The vertex \\(v_{0}\\) cannot be on cycle \\(c\\), because it has no entering edges.) Cycle \\(c\\) corresponds to the following difference constraints:\n\n\\[x_{2}-x_{1} \\leq w(v_{1},v_{2})\\,\\] \\[x_{3}-x_{2} \\leq w(v_{2},v_{3})\\,\\] \\[\\vdots\\] \\[x_{k-1}-x_{k-2} \\leq w(v_{k-2},v_{k-1})\\,\\] \\[x_{k}-x_{k-1} \\leq w(v_{k-1},v_{k})\\.\\]\n\nWe'll assume that \\(x\\) has a solution satisfying each of these \\(k\\) inequalities and then derive a contradiction. The solution must also satisfy the inequality that results from summing the \\(k\\) inequalities together. In summing the left-hand sides, each unknown \\(x_{i}\\) is added in once and subtracted out once (remember that \\(v_{1}=v_{k}\\) implies \\(x_{1}=x_{k}\\)), so that the left-hand side sums to \\(0\\). The right-hand side sums to the weight \\(w(c)\\) of the cycle, giving \\(0\\leq w(c)\\). But since \\(c\\) is a negative-weight cycle, \\(w(c)<0\\), and we obtain the contradiction that \\(0\\leq w(c)<0\\). \n\n### Solving systems of difference constraints\n\nTheorem 22.9 suggests how to use the Bellman-Ford algorithm to solve a system of difference constraints. Because the constraint graph contains edges from the source vertex \\(v_{0}\\) to all other vertices, any negative-weight cycle in the constraint graph is reachable from \\(v_{0}\\). If the Bellman-Ford algorithm returns true, then the shortest-path weights give a feasible solution to the system. In Figure 22.8, for example, the shortest-path weights provide the feasible solution \\(x=(-5,-3,0,-1,-4)\\), and by Lemma 22.8, \\(x=(d-5,d-3,d,d-1,d-4)\\) is also a feasible solution for any constant \\(d\\). If the Bellman-Ford algorithm returns false, there is no feasible solution to the system of difference constraints.\n\nA system of difference constraints with \\(m\\) constraints on \\(n\\) unknowns produces a graph with \\(n+1\\) vertices and \\(n+m\\) edges. Thus, the Bellman-Ford algorithm provides a way to solve the system in \\(O((n+1)(n+m))=O(n^{2}+nm)\\) time.\n\nExercise 22.4-5 asks you to modify the algorithm to run in \\(O(nm)\\) time, even if \\(m\\) is much less than \\(n\\).\n\n##### Exercises\n\n##### 22.4-1\n\nFind a feasible solution or determine that no feasible solution exists for the following system of difference constraints:\n\n\\[\\begin{array}{lcl}x_{1}-x_{2}&\\leq&1\\,\\\\ x_{1}-x_{4}&\\leq&-4\\,\\\\ x_{2}-x_{3}&\\leq&2\\,\\\\ x_{2}-x_{5}&\\leq&7\\,\\\\ x_{2}-x_{6}&\\leq&5\\,\\\\ x_{3}-x_{6}&\\leq&10\\,\\\\ x_{4}-x_{2}&\\leq&2\\,\\\\ x_{5}-x_{1}&\\leq&-1\\,\\\\ x_{5}-x_{4}&\\leq&3\\,\\\\ x_{6}-x_{3}&\\leq&-8\\.\\end{array}\\]\n\n##### 22.4-2\n\nFind a feasible solution or determine that no feasible solution exists for the following system of difference constraints:\n\n\\[\\begin{array}{lcl}x_{1}-x_{2}&\\leq&4\\,\\\\ x_{1}-x_{5}&\\leq&5\\,\\\\ x_{2}-x_{4}&\\leq&-6\\,\\\\ x_{3}-x_{2}&\\leq&1\\,\\\\ x_{4}-x_{1}&\\leq&3\\,\\\\ x_{4}-x_{3}&\\leq&5\\,\\\\ x_{4}-x_{5}&\\leq&10\\,\\\\ x_{5}-x_{3}&\\leq&-4\\,\\\\ x_{5}-x_{4}&\\leq&-8\\.\\end{array}\\]\n\n##### 22.4-3\n\nCan any shortest-path weight from the new vertex \\(v_{0}\\) in a constraint graph be positive? Explain.\n\n##### 22.4-4\n\nExpress the single-pair shortest-path problem as a linear program.\n\n#### 22.4-5\n\nShow how to modify the Bellman-Ford algorithm slightly so that when using it to solve a system of difference constraints with \\(m\\) inequalities on \\(n\\) unknowns, the running time is \\(O(nm)\\).\n\n#### 22.4-6\n\nConsider adding _equality constraints_ of the form \\(x_{i}=x_{j}+b_{k}\\) to a system of difference constraints. Show how to solve this variety of constraint system.\n\n#### 22.4-7\n\nShow how to solve a system of difference constraints by a Bellman-Ford-like algorithm that runs on a constraint graph without the extra vertex \\(v_{0}\\).\n\n* _22.4-8_ Let \\(Ax\\leq b\\) be a system of \\(m\\) difference constraints in \\(n\\) unknowns. Show that the Bellman-Ford algorithm, when run on the corresponding constraint graph, maximizes \\(\\sum_{i=1}^{n}x_{i}\\) subject to \\(Ax\\leq b\\) and \\(x_{i}\\leq 0\\) for all \\(x_{i}\\).\n* _22.4-9_ Show that the Bellman-Ford algorithm, when run on the constraint graph for a system \\(Ax\\leq b\\) of difference constraints, minimizes the quantity (max \\(\\{x_{i}\\}-\\)min \\(\\{x_{i}\\}\\)) subject to \\(Ax\\leq b\\). Explain how this fact might come in handy if the algorithm is used to schedule construction jobs.\n\n#### 22.4-10\n\nSuppose that every row in the matrix \\(A\\) of a linear program \\(Ax\\leq b\\) corresponds to a difference constraint, a single-variable constraint of the form \\(x_{i}\\leq b_{k}\\), or a single-variable constraint of the form \\(-x_{i}\\leq b_{k}\\). Show how to adapt the Bellman-Ford algorithm to solve this variety of constraint system.\n\n* _22.4-11_ Give an efficient algorithm to solve a system \\(Ax\\leq b\\) of difference constraints when all of the elements of \\(b\\) are real-valued and all of the unknowns \\(x_{i}\\) must be integers.\n* _22.4-12_ Give an efficient algorithm to solve a system \\(Ax\\leq b\\) of difference constraints when all of the elements of \\(b\\) are real-valued and a specified subset of some, but not necessarily all, of the unknowns \\(x_{i}\\) must be integers.\n\n### Proofs of shortest-paths properties\n\nThroughout this chapter, our correctness arguments have relied on the triangle inequality, upper-bound property, no-path property, convergence property, path-relaxation property, and predecessor-subgraph property. We stated these properties without proof on page 611. In this section, we prove them.\n\n### The triangle inequality\n\nIn studying breadth-first search (Section 20.2), we proved as Lemma 20.1 a simple property of shortest distances in unweighted graphs. The triangle inequality generalizes the property to weighted graphs.\n\n**Lemma 22.10** (Triangle inequality): _Let \\(G=(V,E)\\) be a weighted, directed graph with weight function \\(w:E\\to\\mathbb{R}\\) and source vertex \\(s\\). Then, for all edges \\((u,v)\\in E\\),_\n\n\\[\\delta(s,v)\\leq\\delta(s,u)+w(u,v)\\.\\]\n\n_Proof_ Suppose that \\(p\\) is a shortest path from source \\(s\\) to vertex \\(v\\). Then \\(p\\) has no more weight than any other path from \\(s\\) to \\(v\\). Specifically, path \\(p\\) has no more weight than the particular path that takes a shortest path from source \\(s\\) to vertex \\(u\\) and then takes edge \\((u,v)\\).\n\nExercise 22.5-3 asks you to handle the case in which there is no shortest path from \\(s\\) to \\(v\\).\n\n### Effects of relaxation on shortest-path estimates\n\nThe next group of lemmas describes how shortest-path estimates are affected by executing a sequence of relaxation steps on the edges of a weighted, directed graph that has been initialized by Initialize-Single-Source.\n\n**Lemma 22.11** (Upper-bound property): _Let \\(G=(V,E)\\) be a weighted, directed graph with weight function \\(w:E\\to\\mathbb{R}\\). Let \\(s\\in V\\) be the source vertex, and let the graph be initialized by Initialize-Single-Source\\((G,s)\\). Then, \\(v.d\\geq\\delta(s,v)\\) for all \\(v\\in V\\), and this invariant is maintained over any sequence of relaxation steps on the edges of \\(G\\). Moreover, once \\(v.d\\) achieves its lower bound \\(\\delta(s,v)\\), it never changes._\n\n_Proof_ We prove the invariant \\(v.d\\geq\\delta(s,v)\\) for all vertices \\(v\\in V\\) by induction over the number of relaxation steps.",
        "chapter": "Part VI Graph Algorithms",
        "section": "22 Single-Source Shortest Paths",
        "subsection": "22.4 Difference constraints and shortest paths",
        "subsubsection": "N/A"
    },
    {
        "content": "### Proofs of shortest-paths properties\n\nThroughout this chapter, our correctness arguments have relied on the triangle inequality, upper-bound property, no-path property, convergence property, path-relaxation property, and predecessor-subgraph property. We stated these properties without proof on page 611. In this section, we prove them.\n\n### The triangle inequality\n\nIn studying breadth-first search (Section 20.2), we proved as Lemma 20.1 a simple property of shortest distances in unweighted graphs. The triangle inequality generalizes the property to weighted graphs.\n\n**Lemma 22.10** (Triangle inequality): _Let \\(G=(V,E)\\) be a weighted, directed graph with weight function \\(w:E\\to\\mathbb{R}\\) and source vertex \\(s\\). Then, for all edges \\((u,v)\\in E\\),_\n\n\\[\\delta(s,v)\\leq\\delta(s,u)+w(u,v)\\.\\]\n\n_Proof_ Suppose that \\(p\\) is a shortest path from source \\(s\\) to vertex \\(v\\). Then \\(p\\) has no more weight than any other path from \\(s\\) to \\(v\\). Specifically, path \\(p\\) has no more weight than the particular path that takes a shortest path from source \\(s\\) to vertex \\(u\\) and then takes edge \\((u,v)\\).\n\nExercise 22.5-3 asks you to handle the case in which there is no shortest path from \\(s\\) to \\(v\\).\n\n### Effects of relaxation on shortest-path estimates\n\nThe next group of lemmas describes how shortest-path estimates are affected by executing a sequence of relaxation steps on the edges of a weighted, directed graph that has been initialized by Initialize-Single-Source.\n\n**Lemma 22.11** (Upper-bound property): _Let \\(G=(V,E)\\) be a weighted, directed graph with weight function \\(w:E\\to\\mathbb{R}\\). Let \\(s\\in V\\) be the source vertex, and let the graph be initialized by Initialize-Single-Source\\((G,s)\\). Then, \\(v.d\\geq\\delta(s,v)\\) for all \\(v\\in V\\), and this invariant is maintained over any sequence of relaxation steps on the edges of \\(G\\). Moreover, once \\(v.d\\) achieves its lower bound \\(\\delta(s,v)\\), it never changes._\n\n_Proof_ We prove the invariant \\(v.d\\geq\\delta(s,v)\\) for all vertices \\(v\\in V\\) by induction over the number of relaxation steps.\n\nFor the base case, \\(v.d\\geq\\delta(s,v)\\) holds after initialization, since if \\(v.d=\\infty\\), then \\(v.d\\geq\\delta(s,v)\\) for all \\(v\\in V-\\{s\\}\\), and since \\(s.d=0\\geq\\delta(s,s)\\). (Note that \\(\\delta(s,s)=-\\infty\\) if \\(s\\) is on a negative-weight cycle and that \\(\\delta(s,s)=0\\) otherwise.)\n\nFor the inductive step, consider the relaxation of an edge \\((u,v)\\). By the inductive hypothesis, \\(x.d\\geq\\delta(s,x)\\) for all \\(x\\in V\\) prior to the relaxation. The only \\(d\\) value that may change is \\(v.d\\). If it changes, we have\n\n\\[v.d = u.d+w(u,v)\\] \\[\\geq \\delta(s,u)+w(u,v)\\] (by the inductive hypothesis) \\[\\geq \\delta(s,v)\\] (by the triangle inequality),\n\nand so the invariant is maintained.\n\nThe value of \\(v.d\\) never changes once \\(v.d=\\delta(s,v)\\) because, having achieved its lower bound, \\(v.d\\) cannot decrease since we have just shown that \\(v.d\\geq\\delta(s,v)\\), and it cannot increase because relaxation steps do not increase \\(d\\) values.\n\n**Corollary 22.12** (No-path property): _Suppose that in a weighted, directed graph \\(G=(V,E)\\) with weight function \\(w:E\\to\\mathbb{R}\\), no path connects a source vertex \\(s\\in V\\) to a given vertex \\(v\\in V\\). Then, after the graph is initialized by Initialize-Single-Source\\((G,s)\\), we have \\(v.d=\\delta(s,v)=\\infty\\), and this equation is maintained as an invariant over any sequence of relaxation steps on the edges of \\(G\\)._\n\n_Proof_ By the upper-bound property, we always have \\(\\infty=\\delta(s,v)\\leq v.d\\), and thus \\(v.d=\\infty=\\delta(s,v)\\).\n\n**Lemma 22.13**: _Let \\(G=(V,E)\\) be a weighted, directed graph with weight function \\(w:E\\to\\mathbb{R}\\), and let \\((u,v)\\in E\\). Then, immediately after edge \\((u,v)\\) is relaxed by a call of Relax\\((u,v,w)\\), we have \\(v.d\\leq u.d+w(u,v)\\)._\n\n_Proof_ If, just prior to relaxing edge \\((u,v)\\), we have \\(v.d>\\!\\!u\\). \\(d+w(u,v)\\), then \\(v.d=u.d+w(u,v)\\) afterward. If, instead, \\(v.d\\leq u.d+w(u,v)\\) just before the relaxation, then neither \\(u.d\\) nor \\(v.d\\) changes, and so \\(v.d\\leq u.d+w(u,v)\\) afterward.\n\n**Lemma 22.14** (Convergence property): _Let \\(G=(V,E)\\) be a weighted, directed graph with weight function \\(w:E\\to\\mathbb{R}\\), let \\(s\\in V\\) be a source vertex, and let \\(s\\leadsto u\\to v\\) be a shortest path in \\(G\\) for some vertices \\(u,v\\in V\\). Suppose that \\(G\\) is initialized by Initialize-Single-Source\\((G,s)\\) and then a sequence of relaxation steps that includes the call \\(\\textsc{Relax}(u,v,w)\\) is executed on the edges of \\(G\\). If \\(u.d=\\delta(s,u)\\) at any time prior to the call, then \\(v.d=\\delta(s,v)\\) at all times after the call.\n\nProofBy the upper-bound property, if \\(u.d=\\delta(s,u)\\) at some point prior to relaxing edge \\((u,v)\\), then this equation holds thereafter. In particular, after edge \\((u,v)\\) is relaxed, we have\n\n\\[v.d \\leq u.d+w(u,v)\\qquad\\text{(by Lemma \\ref{eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq: eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eqeq:eq:eq:eq:eq:eq:eq:eq:eqeq:eq:eq:eq:eqeq:eq:eq:eqeq:eq:eq:eqeq:eqeq:eq:eqeq:eqeq:eqeq:eq:eqeq:eqeq:eq:eq:eqeq:eq:eqeq:eq:eqeq:eq:eqeq:eq:eqeq:eqeq:eqeq:eq:eqeq:eqeq:eqeq:eqeq:eqeq:eqeq:eqeq:eqeq:eqeq:eqeq:eq:eqeqeq:eq:eqeq:eqeq:eq:eqeq:eqeq:eqeqeq:eqeq:eqeq:eqeqeq:eqeq:eqeqeq:eqeq:eqeq:eqeqeq:eqeq:eqeq:eqeq:eqeq:eqeq:eqeqeq:eqeq:eqeq:eqeqeq:eqeq:eqeq:eqeq:eqeq:eqeq:eqeq:eqeq:eqeq:eqeqeq:eqeqeq:eqeq:eqeqeq:eqeqeq:eqeqeq:eqeqeq:eqeqeq:eqeqeq:eqeqeq:eqeqeq:eqeqeqeq:eqeqeq:eqeqeq:eqeqeqeq:eqeqeqeq:eqeqeq:eqeqeqeq:eqeqeqeq:eqeqeq:eqeqeqeq:eqeqeqeq:eqeqeqeqeqeq:eqeqeqeqeq:eqeqeqeqeq:eqeqeqeq:eqeqeqeqeq:eqeqeqeqeq:eqeqeqeqeqeq:eqeqeqeqeqeq:cycles that are reachable from \\(s\\). Then, after the graph is initialized by Initialize-Single-Source\\((G,s)\\), the predecessor subgraph \\(G_{\\pi}\\) forms a rooted tree with root \\(s\\), and any sequence of relaxation steps on edges of \\(G\\) maintains this property as an invariant.\n\nProof.: Initially, the only vertex in \\(G_{\\pi}\\) is the source vertex, and the lemma is trivially true. Consider a predecessor subgraph \\(G_{\\pi}\\) that arises after a sequence of relaxation steps. We first prove that \\(G_{\\pi}\\) is acyclic. Suppose for the sake of contradiction that some relaxation step creates a cycle in the graph \\(G_{\\pi}\\). Let the cycle be \\(c=\\langle v_{0},v_{1},\\ldots,v_{k}\\rangle\\), where \\(v_{k}=v_{0}\\). Then, \\(v_{i}\\,.\\,\\pi=v_{i-1}\\) for \\(i=1,2,\\ldots,k\\) and, without loss of generality, assume that relaxing edge \\((v_{k-1},v_{k})\\) created the cycle in \\(G_{\\pi}\\).\n\nWe claim that all vertices on cycle \\(c\\) are reachable from the source vertex \\(s\\). Why? Each vertex on \\(c\\) has a non-nil predecessor, and so each vertex on \\(c\\) was assigned a finite shortest-path estimate when it was assigned its non-nil\\(\\pi\\) value. By the upper-bound property, each vertex on cycle \\(c\\) has a finite shortest-path weight, which means that it is reachable from \\(s\\).\n\nWe'll examine the shortest-path estimates on cycle \\(c\\) immediately before the call Relax\\((v_{k-1},v_{k},w)\\) and show that \\(c\\) is a negative-weight cycle, thereby contradicting the assumption that \\(G\\) contains no negative-weight cycles that are reachable from the source. Just before the call, we have \\(v_{i}\\,.\\,\\pi=v_{i-1}\\) for \\(i=1,2,\\ldots,k-1\\). Thus, for \\(i=1,2,\\ldots,k-1\\), the last update to \\(v_{i}\\,.\\,d\\) was by the assignment \\(v_{i}\\,.\\,d=v_{i-1}\\,.\\,d+w(v_{i-1},v_{i})\\). If \\(v_{i-1}\\,.\\,d\\) changed since then, it decreased. Therefore, just before the call Relax\\((v_{k-1},v_{k},w)\\), we have\n\n\\[v_{i}\\,.\\,d\\geq v_{i-1}\\,.\\,d+w(v_{i-1},v_{i})\\qquad\\mbox{for all $i=1,2,\\ldots,k-1$ }. \\tag{22.11}\\]\n\nBecause \\(v_{k}\\,.\\,\\pi\\) is changed by the call Relax\\((v_{k-1},v_{k},w)\\), immediately beforehand we also have the strict inequality\n\n\\[v_{k}\\,.\\,d>v_{k-1}\\,.\\,d+w(v_{k-1},v_{k})\\.\\]\n\nSumming this strict inequality with the \\(k-1\\) inequalities (22.11), we obtain the sum of the shortest-path estimates around cycle \\(c\\):\n\n\\[\\sum_{i=1}^{k}v_{i}\\,.\\,d > \\sum_{i=1}^{k}(v_{i-1}\\,.\\,d+w(v_{i-1},v_{i}))\\] \\[= \\sum_{i=1}^{k}v_{i-1}\\,.\\,d+\\sum_{i=1}^{k}w(v_{i-1},v_{i})\\.\\]\n\nBut\n\n\\[\\sum_{i=1}^{k}v_{i}\\,.\\,d=\\sum_{i=1}^{k}v_{i-1}\\,.\\,d\\,\\]since each vertex in the cycle \\(c\\) appears exactly once in each summation. This equation implies\n\n\\[0>\\sum_{i=1}^{k}w(v_{i-1},v_{i})\\.\\]\n\nThus, the sum of weights around the cycle \\(c\\) is negative, which provides the desired contradiction.\n\nWe have now proven that \\(G_{\\pi}\\) is a directed, acyclic graph. To show that it forms a rooted tree with root \\(s\\), it suffices (see Exercise B.5-2 on page 1175) to prove that for each vertex \\(v\\in V_{\\pi}\\), there is a unique simple path from \\(s\\) to \\(v\\) in \\(G_{\\pi}\\).\n\nThe vertices in \\(V_{\\pi}\\) are those with non-nil\\(\\pi\\) values, plus \\(s\\). Exercise 22.5-6 asks you to prove that a path from \\(s\\) exists to each vertex in \\(V_{\\pi}\\).\n\nTo complete the proof of the lemma, we now show that for any vertex \\(v\\in V_{\\pi}\\), the graph \\(G_{\\pi}\\) contains at most one simple path from \\(s\\) to \\(v\\). Suppose otherwise. That is, suppose that, as Figure 22.9 illustrates, \\(G_{\\pi}\\) contains two simple paths from \\(s\\) to some vertex \\(v\\): \\(p_{1}\\), which we decompose into \\(s\\leadsto u\\leadsto x\\to z\\leadsto v\\), and \\(p_{2}\\), which we decompose into \\(s\\leadsto u\\leadsto y\\to z\\leadsto v\\), where \\(x\\neq y\\) (though \\(u\\) could be \\(s\\) and \\(z\\) could be \\(v\\)). But then, \\(z.\\pi=x\\) and \\(z.\\pi=y\\), which implies the contradiction that \\(x=y\\). We conclude that \\(G_{\\pi}\\) contains a unique simple path from \\(s\\) to \\(v\\), and thus \\(G_{\\pi}\\) forms a rooted tree with root \\(s\\).\n\nWe can now show that if all vertices have been assigned their true shortest-path weights after a sequence of relaxation steps, then the predecessor subgraph \\(G_{\\pi}\\) is a shortest-paths tree.\n\n**Lemma 22.17** (Predecessor-subgraph property): _Let \\(G=(V,E)\\) be a weighted, directed graph with weight function \\(w:E\\to\\mathbb{R}\\), let \\(s\\in V\\) be a source vertex, and assume that \\(G\\) contains no negative-weight cycles that are reachable from \\(s\\). Then, after a call to Initialize-Single-Source\\((G,s)\\) followed by any sequence of relaxation steps on edges of \\(G\\) that produces \\(v.d=\\delta(s,v)\\) for all \\(v\\in V\\), the predecessor subgraph \\(G_{\\pi}\\) is a shortest-paths tree rooted at \\(s\\)._ProofWe must prove that the three properties of shortest-paths trees given on page 608 hold for \\(G_{\\pi}\\). To show the first property, we must show that \\(V_{\\pi}\\) is the set of vertices reachable from \\(s\\). By definition, a shortest-path weight \\(\\delta(s,v)\\) is finite if and only if \\(v\\) is reachable from \\(s\\), and thus the vertices that are reachable from \\(s\\) are exactly those with finite \\(d\\) values. But a vertex \\(v\\in V-\\{s\\}\\) has been assigned a finite value for \\(v.\\,d\\) if and only if \\(v.\\,\\pi\\neq\\textsc{nil}\\), since both assignments occur in Relax. Thus, the vertices in \\(V_{\\pi}\\) are exactly those reachable from \\(s\\).\n\nThe second property, that \\(G_{\\pi}\\) forms a rooted tree with root \\(s\\), follows directly from Lemma 22.16.\n\nIt remains, therefore, to prove the last property of shortest-paths trees: for each vertex \\(v\\in V_{\\pi}\\), the unique simple path \\(s\\stackrel{{ p}}{{\\leadsto}}v\\) in \\(G_{\\pi}\\) is a shortest path from \\(s\\) to \\(v\\) in \\(G\\). Let \\(p=\\langle v_{0},\\,v_{1},\\,\\dots,\\,v_{k}\\rangle\\), where \\(v_{0}=s\\) and \\(v_{k}=v\\). Consider an edge \\((v_{i-1},v_{i})\\) in path \\(p\\). Because this edge belongs to \\(G_{\\pi}\\), the last relaxation that changed \\(v_{i}.\\,d\\) must have been of this edge. After that relaxation, we had \\(v_{i}.\\,d=v_{i-1}.\\,d+(v_{i-1},v_{i})\\). Subsequently, an edge entering \\(v_{i-1}\\) could have been relaxed, causing \\(v_{i-1}.\\,d\\) to decrease further, but without changing \\(v_{i}.\\,d\\). Therefore, we have \\(v_{i}.\\,d\\geq v_{i-1}.\\,d+w(v_{i-1},v_{i})\\). Thus, for \\(i=1,2,\\dots,k\\), we have both \\(v_{i}.\\,d=\\delta(s,v_{i})\\) and \\(v_{i}.\\,d\\geq v_{i-1}.\\,d+w(v_{i-1},v_{i})\\), which together imply \\(w(v_{i-1},v_{i})\\leq\\delta(s,v_{i})-\\delta(s,v_{i-1})\\). Summing the weights along path \\(p\\) yields\n\n\\[w(p) = \\sum_{i=1}^{k}w(v_{i-1},v_{i})\\] \\[\\leq \\sum_{i=1}^{k}(\\delta(s,v_{i})-\\delta(s,v_{i-1}))\\] \\[= \\delta(s,v_{k})-\\delta(s,v_{0})\\qquad\\text{(because the sum telescopes)}\\] \\[= \\delta(s,v_{k})\\qquad\\qquad\\qquad\\qquad\\text{(because $\\delta(s,v_{0})=\\delta(s,s)=0$)}\\.\\]\n\nThus, we have \\(w(p)\\leq\\delta(s,v_{k})\\). Since \\(\\delta(s,v_{k})\\) is a lower bound on the weight of any path from \\(s\\) to \\(v_{k}\\), we conclude that \\(w(p)=\\delta(s,v_{k})\\), and \\(p\\) is a shortest path from \\(s\\) to \\(v=v_{k}\\).\n\n## Exercises\n\n### 22.5-1\n\nGive two shortest-paths trees for the directed graph of Figure 22.2 on page 609 other than the two shown.\n\n### 22.5-2\n\nGive an example of a weighted, directed graph \\(G=(V,E)\\) with weight function \\(w:E\\to\\mathbb{R}\\) and source vertex \\(s\\) such that \\(G\\) satisfies the following property: For every edge \\((u,v)\\in E\\), there is a shortest-paths tree rooted at \\(s\\) that contains \\((u,v)\\) and another shortest-paths tree rooted at \\(s\\) that does not contain \\((u,v)\\).\n\n#### 22.5-3\n\nModify the proof of Lemma 22.10 to handle cases in which shortest-path weights are \\(\\infty\\) or \\(-\\infty\\).\n\n#### 22.5-4\n\nLet \\(G=(V,E)\\) be a weighted, directed graph with source vertex \\(s\\), and let \\(G\\) be initialized by Initialize-Single-Source\\((G,s)\\). Prove that if a sequence of relaxation steps sets \\(s.\\pi\\) to a non-nil value, then \\(G\\) contains a negative-weight cycle.\n\n#### 22.5-5\n\nLet \\(G=(V,E)\\) be a weighted, directed graph with no negative-weight edges. Let \\(s\\in V\\) be the source vertex, and suppose that \\(v.\\pi\\) is allowed to be the predecessor of \\(v\\) on _any_ shortest path to \\(v\\) from source \\(s\\) if \\(v\\in V-\\{s\\}\\) is reachable from \\(s\\), and nil otherwise. Give an example of such a graph \\(G\\) and an assignment of \\(\\pi\\) values that produces a cycle in \\(G_{\\pi}\\). (By Lemma 22.16, such an assignment cannot be produced by a sequence of relaxation steps.)\n\n#### 22.5-6\n\nLet \\(G=(V,E)\\) be a weighted, directed graph with weight function \\(w:E\\to\\mathbb{R}\\) and no negative-weight cycles. Let \\(s\\in V\\) be the source vertex, and let \\(G\\) be initialized by Initialize-Single-Source\\((G,s)\\). Use induction to prove that for every vertex \\(v\\in V_{\\pi}\\), there exists a path from \\(s\\) to \\(v\\) in \\(G_{\\pi}\\) and that this property is maintained as an invariant over any sequence of relaxations.\n\n#### 22.5-7\n\nLet \\(G=(V,E)\\) be a weighted, directed graph that contains no negative-weight cycles. Let \\(s\\in V\\) be the source vertex, and let \\(G\\) be initialized by Initialize-Single-Source\\((G,s)\\). Prove that there exists a sequence of \\(|V|-1\\) relaxation steps that produces \\(v.d=\\delta(s,v)\\) for all \\(v\\in V\\).\n\n#### 22.5-8\n\nLet \\(G\\) be an arbitrary weighted, directed graph with a negative-weight cycle reachable from the source vertex \\(s\\). Show how to construct an infinite sequence of relaxations of the edges of \\(G\\) such that every relaxation causes a shortest-path estimate to change.\n\n## Problems\n\n### 22-1 Yen's improvement to Bellman-Ford\n\nThe Bellman-Ford algorithm does not specify the order in which to relax edges in each pass. Consider the following method for deciding upon the order. Before the first pass, assign an arbitrary linear order \\(v_{1},v_{2},\\ldots,v_{|V|}\\) to the vertices of the input graph \\(G=(V,E)\\). Then partition the edge set \\(E\\) into \\(E_{f}\\cup E_{b}\\), where \\(E_{f}=\\{(v_{i},v_{j})\\in E:i<j\\}\\) and \\(E_{b}=\\{(v_{i},v_{j})\\in E:i>j\\}\\). (Assume that \\(G\\) contains no self-loops, so that every edge belongs to either \\(E_{f}\\) or \\(E_{b}\\).) Define \\(G_{f}=(V,E_{f})\\) and \\(G_{b}=(V,E_{b})\\).\n\n* Prove that \\(G_{f}\\) is acyclic with topological sort \\(\\langle v_{1},v_{2},\\ldots,v_{|V|}\\rangle\\) and that \\(G_{b}\\) is acyclic with topological sort \\(\\langle v_{|V|},v_{|V|-1},\\ldots,v_{1}\\rangle\\).\n\nSuppose that each pass of the Bellman-Ford algorithm relaxes edges in the following way. First, visit each vertex in the order \\(v_{1},v_{2},\\ldots,v_{|V|}\\), relaxing edges of \\(E_{f}\\) that leave the vertex. Then visit each vertex in the order \\(v_{|V|},v_{|V|-1},\\ldots,v_{1}\\), relaxing edges of \\(E_{b}\\) that leave the vertex.\n\n* Prove that with this scheme, if \\(G\\) contains no negative-weight cycles that are reachable from the source vertex \\(s\\), then after only \\(\\lceil|V|\\rceil/2\\rceil\\) passes over the edges, \\(v.d=\\delta(s,v)\\) for all vertices \\(v\\in V\\).\n* Does this scheme improve the asymptotic running time of the Bellman-Ford algorithm?\n\n### 22-2 Nesting boxes\n\nA \\(d\\)-dimensional box with dimensions \\((x_{1},x_{2},\\ldots,x_{d})\\)_nests_ within another box with dimensions \\((y_{1},y_{2},\\ldots,y_{d})\\) if there exists a permutation \\(\\pi\\) on \\(\\{1,2,\\ldots,d\\}\\) such that \\(x_{\\pi(1)}<y_{1},x_{\\pi(2)}<y_{2},\\ldots,x_{\\pi(d)}<y_{d}\\).\n\n* Argue that the nesting relation is transitive.\n* Describe an efficient method to determine whether one \\(d\\)-dimensional box nests inside another.\n* You are given a set of \\(n\\)\\(d\\)-dimensional boxes \\(\\{B_{1},\\,B_{2},\\ldots,\\,B_{n}\\}\\). Give an efficient algorithm to find the longest sequence \\(\\langle B_{i_{1}},\\,B_{i_{2}},\\ldots,B_{i_{k}}\\rangle\\) of boxes such that \\(B_{i_{j}}\\) nests within \\(B_{i_{j}+1}\\) for \\(j=1,2,\\ldots,k-1\\). Express the running time of your algorithm in terms of \\(n\\) and \\(d\\).",
        "chapter": "Part VI Graph Algorithms",
        "section": "22 Single-Source Shortest Paths",
        "subsection": "22.5 Proofs of shortest-paths properties",
        "subsubsection": "N/A"
    },
    {
        "content": "## Problems\n\n### 22-1 Yen's improvement to Bellman-Ford\n\nThe Bellman-Ford algorithm does not specify the order in which to relax edges in each pass. Consider the following method for deciding upon the order. Before the first pass, assign an arbitrary linear order \\(v_{1},v_{2},\\ldots,v_{|V|}\\) to the vertices of the input graph \\(G=(V,E)\\). Then partition the edge set \\(E\\) into \\(E_{f}\\cup E_{b}\\), where \\(E_{f}=\\{(v_{i},v_{j})\\in E:i<j\\}\\) and \\(E_{b}=\\{(v_{i},v_{j})\\in E:i>j\\}\\). (Assume that \\(G\\) contains no self-loops, so that every edge belongs to either \\(E_{f}\\) or \\(E_{b}\\).) Define \\(G_{f}=(V,E_{f})\\) and \\(G_{b}=(V,E_{b})\\).\n\n* Prove that \\(G_{f}\\) is acyclic with topological sort \\(\\langle v_{1},v_{2},\\ldots,v_{|V|}\\rangle\\) and that \\(G_{b}\\) is acyclic with topological sort \\(\\langle v_{|V|},v_{|V|-1},\\ldots,v_{1}\\rangle\\).\n\nSuppose that each pass of the Bellman-Ford algorithm relaxes edges in the following way. First, visit each vertex in the order \\(v_{1},v_{2},\\ldots,v_{|V|}\\), relaxing edges of \\(E_{f}\\) that leave the vertex. Then visit each vertex in the order \\(v_{|V|},v_{|V|-1},\\ldots,v_{1}\\), relaxing edges of \\(E_{b}\\) that leave the vertex.\n\n* Prove that with this scheme, if \\(G\\) contains no negative-weight cycles that are reachable from the source vertex \\(s\\), then after only \\(\\lceil|V|\\rceil/2\\rceil\\) passes over the edges, \\(v.d=\\delta(s,v)\\) for all vertices \\(v\\in V\\).\n* Does this scheme improve the asymptotic running time of the Bellman-Ford algorithm?\n\n### 22-2 Nesting boxes\n\nA \\(d\\)-dimensional box with dimensions \\((x_{1},x_{2},\\ldots,x_{d})\\)_nests_ within another box with dimensions \\((y_{1},y_{2},\\ldots,y_{d})\\) if there exists a permutation \\(\\pi\\) on \\(\\{1,2,\\ldots,d\\}\\) such that \\(x_{\\pi(1)}<y_{1},x_{\\pi(2)}<y_{2},\\ldots,x_{\\pi(d)}<y_{d}\\).\n\n* Argue that the nesting relation is transitive.\n* Describe an efficient method to determine whether one \\(d\\)-dimensional box nests inside another.\n* You are given a set of \\(n\\)\\(d\\)-dimensional boxes \\(\\{B_{1},\\,B_{2},\\ldots,\\,B_{n}\\}\\). Give an efficient algorithm to find the longest sequence \\(\\langle B_{i_{1}},\\,B_{i_{2}},\\ldots,B_{i_{k}}\\rangle\\) of boxes such that \\(B_{i_{j}}\\) nests within \\(B_{i_{j}+1}\\) for \\(j=1,2,\\ldots,k-1\\). Express the running time of your algorithm in terms of \\(n\\) and \\(d\\).\n\n#### 22.3 Arbitrage\n\n_Arbitrage_ is the use of discrepancies in currency exchange rates to transform one unit of a currency into more than one unit of the same currency. For example, suppose that one U.S. dollar buys 64 Indian rupees, one Indian rupee buys 1.8 Japanese yen, and one Japanese yen buys 0.009 U.S. dollars. Then, by converting currencies, a trader can start with 1 U.S. dollar and buy \\(64\\times 1.8\\times 0.009=1.0368\\) U.S. dollars, thus turning a profit of 3.68%.\n\nSuppose that you are given \\(n\\) currencies \\(c_{1},c_{2},\\ldots,c_{n}\\) and an \\(n\\times n\\) table \\(R\\) of exchange rates, such that 1 unit of currency \\(c_{i}\\) buys \\(R[i,j]\\) units of currency \\(c_{j}\\).\n\n_a._: Give an efficient algorithm to determine whether there exists a sequence of currencies \\(\\langle c_{i_{1}},c_{i_{2}},\\ldots,c_{i_{k}}\\rangle\\) such that\n\n\\[R[i_{1},i_{2}]\\cdot R[i_{2},i_{3}]\\cdots R[i_{k-1},i_{k}]\\cdot R[i_{k},i_{1}]> 1\\.\\]\n\nAnalyze the running time of your algorithm.\n\n_b._: Give an efficient algorithm to print out such a sequence if one exists. Analyze the running time of your algorithm.\n\n#### 22.4 Gabow's scaling algorithm for single-source shortest paths\n\nA _scaling_ algorithm solves a problem by initially considering only the highest-order bit of each relevant input value, such as an edge weight, assuming that these values are nonnegative integers. The algorithm then refines the initial solution by looking at the two highest-order bits. It progressively looks at more and more high-order bits, refining the solution each time, until it has examined all bits and computed the correct solution.\n\nThis problem examines an algorithm for computing the shortest paths from a single source by scaling edge weights. The input is a directed graph \\(G=(V,E)\\) with nonnegative integer edge weights \\(w\\). Let \\(W=\\max\\left\\{w(u,v):(u,v)\\in E\\right\\}\\) be the maximum weight of any edge. In this problem, you will develop an algorithm that runs in \\(O(E\\lg W)\\) time. Assume that all vertices are reachable from the source.\n\nThe scaling algorithm uncovers the bits in the binary representation of the edge weights one at a time, from the most significant bit to the least significant bit. Specifically, let \\(k=\\lceil\\lg(W+1)\\rceil\\) be the number of bits in the binary representation of \\(W\\), and for \\(i=1,2,\\ldots,k\\), let \\(w_{i}(u,v)=\\left\\lfloor w(u,v)/2^{k-i}\\right\\rfloor\\). That is, \\(w_{i}(u,v)\\) is the \"scaled-down\" version of \\(w(u,v)\\) given by the \\(i\\) most significant bits of \\(w(u,v)\\). (Thus, \\(w_{k}(u,v)=w(u,v)\\) for all \\((u,v)\\in E\\).) For example, if \\(k=5\\) and \\(w(u,v)=25\\), which has the binary representation \\(\\langle 11001\\rangle\\), then \\(w_{3}(u,v)=\\langle 110\\rangle=6\\). Also with \\(k=5\\), if \\(w(u,v)=\\langle 00100\\rangle=4\\), then \\(w_{4}(u,v)=\\langle 0010\\rangle=2\\). Define \\(\\delta_{i}(u,v)\\) as the shortest-path weight from vertexto vertex \\(v\\) using weight function \\(w_{i}\\), so that \\(\\delta_{k}(u,v)=\\delta(u,v)\\) for all \\(u,v\\in V\\). For a given source vertex \\(s\\), the scaling algorithm first computes the shortest-path weights \\(\\delta_{1}(s,v)\\) for all \\(v\\in V\\), then computes \\(\\delta_{2}(s,v)\\) for all \\(v\\in V\\), and so on, until it computes \\(\\delta_{k}(s,v)\\) for all \\(v\\in V\\). Assume throughout that \\(|E|\\geq|V|-1\\). You will show how to compute \\(\\delta_{i}\\) from \\(\\delta_{i-1}\\) in \\(O(E)\\) time, so that the entire algorithm takes \\(O(kE)=O(E\\lg W)\\) time. _a._ Suppose that for all vertices \\(v\\in V\\), we have \\(\\delta(s,v)\\leq|E|\\). Show how to compute \\(\\delta(s,v)\\) for all \\(v\\in V\\) in \\(O(E)\\) time. _b._ Show how to compute \\(\\delta_{1}(s,v)\\) for all \\(v\\in V\\) in \\(O(E)\\) time. Now focus on computing \\(\\delta_{i}\\) from \\(\\delta_{i-1}\\). _c._ Prove that for \\(i=2,3,\\ldots,k\\), either \\(w_{i}(u,v)=2w_{i-1}(u,v)\\) or \\(w_{i}(u,v)=2w_{i-1}(u,v)+1\\). Then prove that \\(2\\delta_{i-1}(s,v)\\leq\\delta_{i}(s,v)\\leq 2\\delta_{i-1}(s,v)+|V|-1\\) for all \\(v\\in V\\). _d._ Define, for \\(i=2,3,\\ldots,k\\) and all \\((u,v)\\in E\\), \\(\\widehat{w}_{i}(u,v)=w_{i}(u,v)+2\\delta_{i-1}(s,u)-2\\delta_{i-1}(s,v)\\). Prove that for \\(i=2,3,\\ldots,k\\) and all \\(u,v\\in V\\), the \"reweighted\" value \\(\\widehat{w}_{i}(u,v)\\) of edge \\((u,v)\\) is a nonnegative integer. _e._ Now define \\(\\widehat{\\delta}_{i}(s,v)\\) as the shortest-path weight from \\(s\\) to \\(v\\) using the weight function \\(\\widehat{w}_{i}\\). Prove that for \\(i=2,3,\\ldots,k\\) and all \\(v\\in V\\), \\(\\delta_{i}(s,v)=\\widehat{\\delta}_{i}(s,v)+2\\delta_{i-1}(s,v)\\) and that \\(\\widehat{\\delta}_{i}(s,v)\\leq|E|\\). _f._ Show how to compute \\(\\delta_{i}(s,v)\\) from \\(\\delta_{i-1}(s,v)\\) for all \\(v\\in V\\) in \\(O(E)\\) time. Conclude that you can compute \\(\\delta(s,v)\\) for all \\(v\\in V\\) in \\(O(E\\lg W)\\) time.\n\n_22-5 Karp's minimum mean-weight cycle algorithm_\n\nLet \\(G=(V,E)\\) be a directed graph with weight function \\(w:E\\to\\mathbb{R}\\), and let \\(n=|V|\\). We define the _mean weight_ of a cycle \\(c=\\langle e_{1},e_{2},\\ldots,e_{k}\\rangle\\) of edges in \\(E\\) to be \\[\\mu(c)=\\frac{1}{k}\\sum_{i=1}^{k}w(e_{i})\\.\\]\n\nLet \\(\\mu^{*}\\,=\\,\\min\\,\\{\\mu(c):c\\) is a directed cycle in \\(G\\}\\). We call a cycle \\(c\\) for which \\(\\mu(c)\\,=\\,\\mu^{*}\\) a _minimum mean-weight cycle_. This problem investigates an efficient algorithm for computing \\(\\mu^{*}\\).\n\nAssume without loss of generality that every vertex \\(v\\in V\\) is reachable from a source vertex \\(s\\in V\\). Let \\(\\delta(s,v)\\) be the weight of a shortest path from \\(s\\) to \\(v\\), and let \\(\\delta_{k}(s,v)\\) be the weight of a shortest path from \\(s\\) to \\(v\\) consisting of _exactly_\\(k\\) edges. If there is no path from \\(s\\) to \\(v\\) with exactly \\(k\\) edges, then \\(\\delta_{k}(s,v)\\,=\\,\\infty\\).\n\n_a._ Show that if \\(\\mu^{*}=0\\), then \\(G\\) contains no negative-weight cycles and \\(\\delta(s,v)\\,=\\,\\min\\,\\{\\delta_{k}(s,v):0\\leq k\\,\\leq n-1\\}\\) for all vertices \\(v\\in V\\).\n\n_b._ Show that if \\(\\mu^{*}=0\\), then\n\n\\[\\max\\,\\left\\{\\frac{\\delta_{n}(s,v)-\\delta_{k}(s,v)}{n-k}:0\\leq k\\,\\leq n-1 \\right\\}\\geq 0\\]\n\nfor all vertices \\(v\\in V\\). (_Hint:_ Use both properties from part (a).)\n\n_c._ Let \\(c\\) be a \\(0\\)-weight cycle, and let \\(u\\) and \\(v\\) be any two vertices on \\(c\\). Suppose that \\(\\mu^{*}=0\\) and that the weight of the simple path from \\(u\\) to \\(v\\) along the cycle is \\(x\\). Prove that \\(\\delta(s,v)\\,=\\,\\delta(s,u)\\,+\\,x\\). (_Hint:_ The weight of the simple path from \\(v\\) to \\(u\\) along the cycle is \\(-x\\).)\n\n_d._ Show that if \\(\\mu^{*}=0\\), then on each minimum mean-weight cycle there exists a vertex \\(v\\) such that\n\n\\[\\max\\,\\left\\{\\frac{\\delta_{n}(s,v)-\\delta_{k}(s,v)}{n-k}:0\\leq k\\,\\leq n-1 \\right\\}=0\\.\\]\n\n(_Hint:_ Show how to extend a shortest path to any vertex on a minimum mean-weight cycle along the cycle to make a shortest path to the next vertex on the cycle.)\n\n_e._ Show that if \\(\\mu^{*}=0\\), then the minimum value of\n\n\\[\\max\\,\\left\\{\\frac{\\delta_{n}(s,v)-\\delta_{k}(s,v)}{n-k}:0\\leq k\\,\\leq n-1 \\right\\}\\,\\]\n\ntaken over all vertices \\(v\\in V\\), equals \\(0\\).\n\nShow that if you add a constant \\(t\\) to the weight of each edge of \\(G\\), then \\(\\mu^{*}\\) increases by \\(t\\). Use this fact to show that \\(\\mu^{*}\\) equals the minimum value of\n\n\\[\\max\\left\\{\\frac{\\delta_{n}(s,v)-\\delta_{k}(s,v)}{n-k}:0\\leq k\\leq n-1\\right\\}\\,\\]\n\ntaken over all vertices \\(v\\in V\\).\n\nGive an \\(O(VE)\\)-time algorithm to compute \\(\\mu^{*}\\).\n\n#### 22.6 Bitonic shortest paths\n\nA sequence is _bitonic_ if it monotonically increases and then monotonically decreases, or if by a circular shift it monotonically increases and then monotonically decreases. For example the sequences \\(\\langle 1,\\,4,\\,6,\\,8,\\,3,\\,-2\\rangle\\), \\(\\langle 9,\\,2,\\,-4,-10,\\,-5\\rangle\\), and \\(\\langle 1,\\,2,\\,3,\\,4\\rangle\\) are bitonic, but \\(\\langle 1,\\,3,\\,12,\\,4,\\,2,\\,10\\rangle\\) is not bitonic. (See Problem 14-3 on page 407 for the bitonic euclidean traveling-salesperson problem.)\n\nSuppose that you are given a directed graph \\(G=(V,E)\\) with weight function \\(w:E\\to\\mathbb{R}\\), where all edge weights are unique, and you wish to find single-source shortest paths from a source vertex \\(s\\). You are given one additional piece of information: for each vertex \\(v\\in V\\), the weights of the edges along any shortest path from \\(s\\) to \\(v\\) form a bitonic sequence.\n\nGive the most efficient algorithm you can to solve this problem, and analyze its running time.\n\n#### Chapter notes\n\nThe shortest-path problem has a long history that is nicely desribed in an article by Schrijver [400]. He credits the general idea of repeatedly executing edge relaxations to Ford [148]. Dijkstra's algorithm [116] appeared in 1959, but it contained no mention of a priority queue. The Bellman-Ford algorithm is based on separate algorithms by Bellman [45] and Ford [149]. The same algorithm is also attributed to Moore [334]. Bellman describes the relation of shortest paths to difference constraints. Lawler [276] describes the linear-time algorithm for shortest paths in a dag, which he considers part of the folklore.\n\nWhen edge weights are relatively small nonnegative integers, more efficient algorithms result from using min-priority queues that require integer keys and rely on the sequence of values returned by the Extract-Min calls in Dijkstra's algorithm monotonically increasing over time. Ahuja, Mehlhorn, Orlin, and Tarjan [8] give an algorithm that runs in \\(O(E+V\\sqrt{\\lg W})\\) time on graphs with nonnegative edge weights, where \\(W\\) is the largest weight of any edge in the",
        "chapter": "Part VI Graph Algorithms",
        "section": "22 Single-Source Shortest Paths",
        "subsection": "Problems",
        "subsubsection": "N/A"
    },
    {
        "content": "**.**: Show that if you add a constant \\(t\\) to the weight of each edge of \\(G\\), then \\(\\mu^{*}\\) increases by \\(t\\). Use this fact to show that \\(\\mu^{*}\\) equals the minimum value of\n\n\\[\\max\\left\\{\\frac{\\delta_{n}(s,v)-\\delta_{k}(s,v)}{n-k}:0\\leq k\\leq n-1\\right\\}\\,\\]\n\ntaken over all vertices \\(v\\in V\\).\n**.**: Give an \\(O(VE)\\)-time algorithm to compute \\(\\mu^{*}\\).\n\n_22-6 Bitonic shortest paths_\n\nA sequence is _bitonic_ if it monotonically increases and then monotonically decreases, or if by a circular shift it monotonically increases and then monotonically decreases. For example the sequences \\(\\langle 1,\\,4,\\,6,\\,8,\\,3,\\,-2\\rangle\\), \\(\\langle 9,\\,2,-4,-10,-5\\rangle\\), and \\(\\langle 1,\\,2,\\,3,\\,4\\rangle\\) are bitonic, but \\(\\langle 1,\\,3,\\,12,\\,4,\\,2,\\,10\\rangle\\) is not bitonic. (See Problem 14-3 on page 407 for the bitonic euclidean traveling-salesperson problem.)\n\nSuppose that you are given a directed graph \\(G=(V,E)\\) with weight function \\(w:E\\to\\mathbb{R}\\), where all edge weights are unique, and you wish to find single-source shortest paths from a source vertex \\(s\\). You are given one additional piece of information: for each vertex \\(v\\in V\\), the weights of the edges along any shortest path from \\(s\\) to \\(v\\) form a bitonic sequence.\n\nGive the most efficient algorithm you can to solve this problem, and analyze its running time.\n\n## Chapter notes\n\nThe shortest-path problem has a long history that is nicely desribed in an article by Schrijver [400]. He credits the general idea of repeatedly executing edge relaxations to Ford [148]. Dijkstra's algorithm [116] appeared in 1959, but it contained no mention of a priority queue. The Bellman-Ford algorithm is based on separate algorithms by Bellman [45] and Ford [149]. The same algorithm is also attributed to Moore [334]. Bellman describes the relation of shortest paths to difference constraints. Lawler [276] describes the linear-time algorithm for shortest paths in a dag, which he considers part of the folklore.\n\nWhen edge weights are relatively small nonnegative integers, more efficient algorithms result from using min-priority queues that require integer keys and rely on the sequence of values returned by the Extract-Min calls in Dijkstra's algorithm monotonically increasing over time. Ahuja, Mehlhorn, Orlin, and Tarjan [8] give an algorithm that runs in \\(O(E+V\\sqrt{\\lg W})\\) time on graphs with nonnegative edge weights, where \\(W\\) is the largest weight of any edge in thegraph. The best bounds are by Thorup [436], who gives an algorithm that runs in \\(O(E\\lg\\lg V)\\) time, and by Raman [375], who gives an algorithm that runs in \\(O\\left(E+V\\min\\left\\{(\\lg V)^{1/3+\\epsilon},(\\lg W)^{1/4+\\epsilon}\\right\\}\\right)\\) time. These two algorithms use an amount of space that depends on the word size of the underlying machine. Although the amount of space used can be unbounded in the size of the input, it can be reduced to be linear in the size of the input using randomized hashing.\n\nFor undirected graphs with integer weights, Thorup [435] gives an algorithm that runs in \\(O(V+E)\\) time for single-source shortest paths. In contrast to the algorithms mentioned in the previous paragraph, the sequence of values returned by Extract-Min calls does not monotonically increase over time, and so this algorithm is not an implementation of Dijkstra's algorithm. Pettie and Ramachandran [357] remove the restriction of integer weights on undirected graphs. Their algorithm entails a preprocessing phase, followed by queries for specific source vertices. Preprocessing takes \\(O(\\mathit{MST}(V,E)+\\min\\left\\{V\\lg V,V\\lg\\lg r\\right\\})\\) time, where \\(\\mathit{MST}(V,E)\\) is the time to compute a minimum spanning tree and \\(r\\) is the ratio of the maximum edge weight to the minimum edge weight. After preprocessing, each query takes \\(O(E\\lg\\widehat{\\alpha}(E,V))\\) time, where \\(\\widehat{\\alpha}(E,V)\\) is the inverse of Ackermann's function. (See the chapter notes for Chapter 19 for a brief discussion of Ackermann's function and its inverse.)\n\nFor graphs with negative edge weights, an algorithm due to Gabow and Tarjan [167] runs in \\(O(\\sqrt{V}\\,E\\lg(VW))\\) time, and one by Goldberg [186] runs in \\(O(\\sqrt{V}\\,E\\lg W)\\) time, where \\(W=\\max\\left\\{|w(u,v)|:(u,v)\\in E\\right\\}\\). There has also been some progress based on methods that use continuous optimization and electrical flows. Cohen et al. [98] give such an algorithm, which is randomized and runs in \\(\\widetilde{O}(E^{10/7}\\lg W)\\) expected time (see Problem 3-6 on page 73 for the definition of \\(\\widetilde{O}\\)-notation). There is also a pseudopolynomial-time algorithm based on fast matrix multiplication. Sankowski [394] and Yuster and Zwick [465] designed an algorithm for shortest paths that runs in \\(\\widetilde{O}(W\\,V^{\\omega})\\) time, where two \\(n\\times n\\) matrices can be multiplied in \\(O(n^{\\omega})\\) time, giving a faster algorithm than the previously mentioned algorithms for small values of \\(W\\) on dense graphs.\n\nCherkassky, Goldberg, and Radzik [89] conducted extensive experiments comparing various shortest-path algorithms. Shortest-path algorithms are widely used in real-time navigation and route-planning applications. Typically based on Dijkstra's algorithm, these algorithms use many clever ideas to be able to compute shortest paths on networks with many millions of vertices and edges in fractions of a second. Bast et al. [36] survey many of these developments.\n\n## Chapter 23 All-Pairs Shortest Paths\n\nIn this chapter, we turn to the problem of finding shortest paths between all pairs of vertices in a graph. A classic application of this problem occurs in computing a table of distances between all pairs of cities for a road atlas. Classic perhaps, but not a true application of finding shortest paths between _all_ pairs of vertices. After all, a road map modeled as a graph has one vertex for _every_ road intersection and one edge wherever a road connects intersections. A table of intercity distances in an atlas might include distances for 100 cities, but the United States has approximately 300,000 signal-controlled intersections1 and many more uncontrolled intersections.\n\nFootnote 1: According to a report cited by U.S. Department of Transportation Federal Highway Administration, \u201ca reasonable \u2018rule of thumb\u2019 is one signalized intersection per 1,000 population.\u201d\n\nA legitimate application of all-pairs shortest paths is to determine the _diameter_ of a network: the longest of all shortest paths. If a directed graph models a communication network, with the weight of an edge indicating the time required for a message to traverse a communication link, then the diameter gives the longest possible transit time for a message in the network.\n\nAs in Chapter 22, the input is a weighted, directed graph \\(G=(V,E)\\) with a weight function \\(w:E\\rightarrow\\mathbb{R}\\) that maps edges to real-valued weights. Now the goal is to find, for every pair of vertices \\(u,v\\in V\\), a shortest (least-weight) path from \\(u\\) to \\(v\\), where the weight of a path is the sum of the weights of its constituent edges. For the all-pairs problem, the output typically takes a tabular form in which the entry in \\(u\\)'s row and \\(v\\)'s column is the weight of a shortest path from \\(u\\) to \\(v\\).\n\nYou can solve an all-pairs shortest-paths problem by running a single-source shortest-paths algorithm \\(|V|\\) times, once with each vertex as the source. If all edge weights are nonnegative, you can use Dijkstra's algorithm. If you implement the min-priority queue with a linear array, the running time is \\(O(V^{\\,3}+VE)\\) which is \\(O(V^{\\,3})\\). The binary min-heap implementation of the min-priority queue",
        "chapter": "Part VI Graph Algorithms",
        "section": "22 Single-Source Shortest Paths",
        "subsection": "Chapter notes",
        "subsubsection": "N/A"
    },
    {
        "content": "### Chapter outline\n\nSection 23.1 presents a dynamic-programming algorithm based on matrix multiplication to solve the all-pairs shortest-paths problem. The technique of \"repeated squaring\" yields a running time of \\(\\Theta(V^{3}\\lg V)\\). Section 23.2 gives another dynamic-programming algorithm, the Floyd-Warshall algorithm, which runs in \\(\\Theta(V^{3})\\) time. Section 23.2 also covers the problem of finding the transitive closure of a directed graph, which is related to the all-pairs shortest-paths problem. Finally, Section 23.3 presents Johnson's algorithm, which solves the all-pairs shortest-paths problem in \\(\\mathcal{O}(V^{2}\\lg V+VE)\\) time and is a good choice for large, sparse graphs.\n\nBefore proceeding, we need to establish some conventions for adjacency-matrix representations. First, we generally assume that the input graph \\(G=(V,E)\\) has \\(n\\) vertices, so that \\(n=|V|\\). Second, we use the convention of denoting matrices by uppercase letters, such as \\(W\\), \\(L\\), or \\(D\\), and their individual elements by subscripted lowercase letters, such as \\(w_{ij}\\), \\(l_{ij}\\), or \\(d_{ij}\\). Finally, some matrices have parenthesized superscripts, as in \\(L^{(r)}=\\left(l_{ij}^{(r)}\\right)\\) or \\(D^{(r)}=\\left(d_{ij}^{(r)}\\right)\\), to indicate iterates.\n\n### Shortest paths and matrix multiplication\n\nThis section presents a dynamic-programming algorithm for the all-pairs shortest-paths problem on a directed graph \\(G=(V,E)\\). Each major loop of the dynamic program invokes an operation similar to matrix multiplication, so that the algorithm looks like repeated matrix multiplication. We'll start by developing a \\(\\Theta(V^{4})\\)-time algorithm for the all-pairs shortest-paths problem, and then we'll improve its running time to \\(\\Theta(V^{3}\\lg V)\\).\n\nBefore proceeding, let's briefly recap the steps given in Chapter 14 for developing a dynamic-programming algorithm:\n\n1. Characterize the structure of an optimal solution.\n2. Recursively define the value of an optimal solution.\n3. Compute the value of an optimal solution in a bottom-up fashion.\n\n### Shortest paths and matrix multiplication\n\nWe reserve the fourth step--constructing an optimal solution from computed information--for the exercises.\n\n#### The structure of a shortest path\n\nLet's start by characterizing the structure of an optimal solution. Lemma 22.1 tells us that all subpaths of a shortest path are shortest paths. Consider a shortest path \\(p\\) from vertex \\(i\\) to vertex \\(j\\), and suppose that \\(p\\) contains at most \\(r\\) edges. Assuming that there are no negative-weight cycles, \\(r\\) is finite. If \\(i\\,=\\,j\\), then \\(p\\) has weight \\(0\\) and no edges. If vertices \\(i\\) and \\(j\\) are distinct, then decompose path \\(p\\) into \\(i\\stackrel{{ p^{\\prime}}}{{\\leadsto}}k\\,\\to\\,j\\), where path \\(p^{\\prime}\\) now contains at most \\(r-1\\) edges. Lemma 22.1 says that \\(p^{\\prime}\\) is a shortest path from \\(i\\) to \\(k\\), and so \\(\\delta(i,j)=\\delta(i,k)\\,+\\,w_{kj}\\).\n\n#### A recursive solution to the all-pairs shortest-paths problem\n\nNow, let \\(l_{ij}^{(r)}\\) be the minimum weight of any path from vertex \\(i\\) to vertex \\(j\\) that contains at most \\(r\\) edges. When \\(r\\,=\\,0\\), there is a shortest path from \\(i\\) to \\(j\\) with no edges if and only if \\(i\\,=\\,j\\), yielding\n\n\\[l_{ij}^{(0)}\\,=\\,\\cases{0&if $i\\,=\\,j$ \\cr\\infty&if $i\\,\\neq\\,j$ \\cr}. \\tag{23.2}\\]\n\nFor \\(r\\,\\geq\\,1\\), one way to achieve a minimum-weight path from \\(i\\) to \\(j\\) with at most \\(r\\) edges is by taking a path containing at most \\(r-1\\) edges, so that \\(l_{ij}^{(r)}\\,=\\,l_{ij}^{(r-1)}\\). Another way is by taking a path of at most \\(r-1\\) edges from \\(i\\) to some vertex \\(k\\) and then taking the edge \\((k,\\,j)\\), so that \\(l_{ij}^{(r)}\\,=\\,l_{ik}^{(r-1)}\\,+\\,w(k,\\,j)\\). Therefore, to examine paths from \\(i\\) to \\(j\\) consisting of at most \\(r\\) edges, try all possible predecessors \\(k\\) of \\(j\\), giving the recursive definition\n\n\\[l_{ij}^{(r)}\\,=\\,\\min\\,\\left\\{l_{ij}^{(r-1)},\\,\\min\\,\\left\\{l_{ ik}^{(r-1)}\\,+\\,w_{kj}\\,:\\,1\\leq k\\,\\leq n\\right\\}\\right\\}\\] \\[\\,=\\,\\min\\,\\left\\{l_{ik}^{(r-1)}\\,+\\,w_{kj}\\,:\\,1\\leq k\\,\\leq n \\right\\}\\,. \\tag{23.3}\\]\n\nThe last equality follows from the observation that \\(w_{jj}\\,=\\,0\\) for all \\(j\\).\n\nWhat are the actual shortest-path weights \\(\\delta(i,j)\\)? If the graph contains no negative-weight cycles, then whenever \\(\\delta(i,j)\\,<\\,\\infty\\), there is a shortest path from vertex \\(i\\) to vertex \\(j\\) that is simple. (A path \\(p\\) from \\(i\\) to \\(j\\) that is not simple contains a cycle. Since each cycle's weight is nonnegative, removing all cycles from the path leaves a simple path with weight no greater than \\(p\\)'s weight.) Because any simple path contains at most \\(n-1\\) edges, a path from vertex \\(i\\) to vertex \\(j\\) with more than \\(n-1\\) edges cannot have lower weight than a shortest path from \\(i\\) to \\(j\\). The actual shortest-path weights are therefore given by\\[\\delta(i,j)=l^{(n-1)}_{ij}=l^{(n)}_{ij}=l^{(n+1)}_{ij}=\\cdots. \\tag{23.4}\\]\n\n##### Computing the shortest-path weights bottom up\n\nTaking as input the matrix \\(W=(w_{ij})\\), let's see how to compute a series of matrices \\(L^{(0)},L^{(1)},\\ldots,L^{(n-1)}\\), where \\(L^{(r)}=\\left(l^{(r)}_{ij}\\right)\\) for \\(r=0,1,\\ldots,n-1\\). The initial matrix is \\(L^{(0)}\\) given by equation (23.2). The final matrix \\(L^{(n-1)}\\) contains the actual shortest-path weights.\n\nThe heart of the algorithm is the procedure Extend-Shortest-Paths, which implements equation (23.3) for all \\(i\\) and \\(j\\). The four inputs are the matrix \\(L^{(r-1)}\\) computed so far; the edge-weight matrix \\(W\\); the output matrix \\(L^{(r)}\\), which will hold the computed result and whose elements are all initialized to \\(\\infty\\) before invoking the procedure; and the number \\(n\\) of vertices. The superscripts \\(r\\) and \\(r-1\\) help to make the correspondence of the pseudocode with equation (23.3) plain, but they play no actual role in the pseudocode. The procedure extends the shortest paths computed so far by one more edge, producing the matrix \\(L^{(r)}\\) of shortest-path weights from the matrix \\(L^{(r-1)}\\) computed so far. Its running time is \\(\\Theta(n^{3})\\) due to the three nested **for** loops.\n\n\\[\\begin{array}{l}\\mbox{Extend-Shortest-Paths}\\left(L^{(r-1)},W,L^{(r)},n\\right) \\\\ \\mbox{ 1 \\\\(l^{(r-1)}\\)\\(\\to\\)\\(a\\),\n\n\\(w\\)\\(\\to\\)\\(b\\),\n\n\\(l^{(r)}\\)\\(\\to\\)\\(c\\),\n\n\\(\\min\\)\\(\\to\\)\\(+\\),\n\n\\(+\\)\\(\\to\\)\\(\\cdot\\)\n\nin equation (23.3). You get equation (23.5)! Making these changes to Extend-Shortest-Paths, and also replacing \\(\\infty\\) (the identity for \\(\\min\\)) by \\(0\\) (the identity for \\(+\\)), yields the procedure Matrix-Multiply. We can see that the procedure Extend-Shortest-Paths\\((L^{(r-1)},W,L^{(r)},n)\\) computes the matrix \"product\" \\(L^{(r)}=L^{(r-1)}\\cdot W\\) using this unusual definition of matrix multiplication.2\n\nFootnote 2: An algebraic _semiring_ contains operations \\(\\oplus\\), which is commutative with identity \\(I_{\\bigoplus}\\), and \\(\\otimes\\), with identity \\(I_{\\bigotimes}\\), where \\(\\otimes\\) distributes over \\(\\oplus\\) on both the left and right, and where \\(I_{\\bigoplus}\\otimes x=x\\otimes I_{\\bigoplus}=I_{\\bigoplus}\\) for all \\(x\\). Standard matrix multiplication, as in Matrix-Multiply,uses the semiring with \\(+\\) for \\(\\oplus\\), \\(\\cdot\\) for \\(\\otimes\\), \\(0\\) for \\(I_{\\bigoplus}\\), and \\(1\\) for \\(I_{\\bigotimes}\\). The procedure Extend-Shortest-Paths uses another semiring, known as the _tropical semiring_, with \\(\\min\\) for \\(\\oplus\\), \\(+\\) for \\(\\otimes\\), \\(\\infty\\) for \\(I_{\\bigoplus}\\), and \\(0\\) for \\(I_{\\bigotimes}\\).\n\nThus, we can solve the all-pairs shortest-paths problem by repeatedly multiplying matrices. Each step extends the shortest-path weights computed so far by one more edge using Extend-Shortest-Paths\\((L^{(r-1)},W,L^{(r)},n)\\) to perform the matrix multiplication. Starting with the matrix \\(L^{(0)}\\), we produce the following sequence of \\(n-1\\) matrices corresponding to powers of \\(W\\):\n\n\\(L^{(1)}\\)\\(=\\)\\(L^{(0)}\\cdot W\\)\\(=\\)\\(W^{1}\\),\n\n\\(L^{(2)}\\)\\(=\\)\\(L^{(1)}\\cdot W\\)\\(=\\)\\(W^{2}\\),\n\n\\(L^{(3)}\\)\\(=\\)\\(L^{(2)}\\cdot W\\)\\(=\\)\\(W^{3}\\),\n\n\\(\\vdots\\)\n\n\\(L^{(n-1)}\\)\\(=\\)\\(L^{(n-2)}\\cdot W\\)\\(=\\)\\(W^{n-1}\\).\n\nAt the end, the matrix \\(L^{(n-1)}=W^{n-1}\\) contains the shortest-path weights.\n\nThe procedure Slow-APSP on the next page computes this sequence in \\(\\Theta(n^{4})\\) time. The procedure takes the \\(n\\times n\\) matrices \\(W\\) and \\(L^{(0)}\\) as inputs, along with \\(n\\). Figure 23 illustrates its operation. The pseudocode uses two \\(n\\times n\\) matrices \\(L\\) and \\(M\\) to store powers of \\(W\\), computing \\(M=L\\cdot W\\) on each iteration. Line 2 initializes \\(L=L^{(0)}\\). For each iteration \\(r\\), line 4 initializes \\(M=\\infty\\), where \\(\\infty\\) in this context is a matrix of scalar \\(\\infty\\) values. The \\(r\\)th iteration starts with the invariant \\(L=L^{(r-1)}=W^{r-1}\\). Line 6 computes \\(M=L\\cdot W=L^{(r-1)}\\cdot W=W^{r-1}\\cdot W=W^{r}=L^{(r)}\\) so that the invariant can be restored for the next iteration by line 7, which sets \\(L=M\\). At the end, the matrix \\(L=L^{(n-1)}=W^{n-1}\\) of shortest-path weights is returned. The assignments to \\(n\\times n\\) matrices in lines \\(2,4\\), and 7 implicitly run doubly nested loops that take \\(\\Theta(n^{2})\\) time for each assignment.\n\nThe \\(n-1\\) invocations of Extend-Shortest-Paths, each of which takes \\(\\Theta(n^{3})\\) time, dominate the computation, yielding a total running time of \\(\\Theta(n^{4})\\).\n\n\\begin{tabular}{l} \\hline Slow-APSP\\((W,L^{(0)},n)\\) \\\\\n1 let \\(L=(l_{ij})\\) and \\(M=(m_{ij})\\) be new \\(n\\times n\\) matrices \\\\\n2 \\(L\\,=\\,L^{(0)}\\) \\\\\n3 for\\(r\\,=\\,1\\) to \\(n-1\\) \\\\\n4 \\(M\\,=\\,\\infty\\) \\(\\quad\\) // initialize \\(M\\) \\\\\n5 // Compute the matrix \"product\" \\(M\\,=\\,L\\cdot W\\). \\\\\n6 Extend-Shortest-Paths\\((L,W,M,n)\\) \\\\\n7 \\(L\\,=\\,M\\) \\\\\n8 return\\(L\\) \\\\ \\end{tabular}\n\n#### Improving the running time\n\nBear in mind that the goal is not to compute _all_ the \\(L^{(r)}\\) matrices: only the matrix \\(L^{(n-1)}\\) matters. Recall that in the absence of negative-weight cycles, equation (23.4) implies \\(L^{(r)}\\,=\\,L^{(n-1)}\\) for all integers \\(r\\,\\geq\\,n-1\\). Just as traditional matrix multiplication is associative, so is matrix multiplication defined by the Extend-Shortest-Paths procedure (see Exercise 23.1-4). In fact, we can compute \\(L^{(n-1)}\\) with only \\(\\lceil\\lg(n-1)\\rceil\\) matrix products by using the technique of _repeated squaring_:\n\n### Shortest paths and matrix multiplication\n\n\\[\\begin{array}{ccccccccc}L^{(1)}&=&W\\,&&&&\\\\ L^{(2)}&=&W^{2}&=&W\\cdot W\\,\\\\ L^{(4)}&=&W^{4}&=&W^{2}\\cdot W^{2}\\\\ L^{(8)}&=&W^{8}&=&W^{4}\\cdot W^{4}\\,\\\\ &&\\vdots&&&&\\\\ L^{(2^{\\lceil\\lg(n-1)\\rceil})}&=&W^{2^{\\lceil\\lg(n-1)\\rceil}}&=&W^{2^{\\lceil \\lg(n-1)\\rceil-1}}\\cdot W^{2^{\\lceil\\lg(n-1)\\rceil-1}}\\.\\end{array}\\]\n\nSince \\(2^{\\lceil\\lg(n-1)\\rceil}\\geq n-1\\), the final product is \\(L^{(2^{\\lceil\\lg(n-1)\\rceil})}=L^{(n-1)}\\).\n\nThe procedure Faster-APSP implements this idea. It takes just the \\(n\\times n\\) matrix \\(W\\) and the size \\(n\\) as inputs. Each iteration of the **while** loop of lines 4-8 starts with the invariant \\(L=W^{r}\\), which it squares using Extend-Shortest-Paths to obtain the matrix \\(M=L^{2}=(W^{r})^{2}=W^{2r}\\). At the end of each iteration, the value of \\(r\\) doubles, and \\(L\\) for the next iteration becomes \\(M\\), restoring the invariant. Upon exiting the loop when \\(r\\geq n-1\\), the procedure returns \\(L=W^{r}=L^{(r)}=L^{(n-1)}\\) by equation (23.4). As in Slow-APSP, the assignments to \\(n\\times n\\) matrices in lines 2, 5, and 8 implicitly run doubly nested loops, taking \\(\\Theta(n^{2})\\) time for each assignment.\n\n```\nFaster-APSP(\\(W,n\\))\n1 let \\(L\\) and \\(M\\) be new \\(n\\times n\\) matrices\n2\\(L\\,=\\,W\\)\n3\\(r\\,=\\,1\\)\n4while\\(r<n-1\\)\n5\\(M\\,=\\infty\\) // initialize \\(M\\)\n6Extend-Shortest-Paths(\\(L,L,M,n\\)) // compute \\(M\\,=L^{2}\\)\n7\\(r\\,=\\,2r\\)\n8\\(L\\,=\\,M\\) // ready for the next iteration\n9return\\(L\\)\n```\n\nBecause each of the \\(\\lceil\\lg(n-1)\\rceil\\) matrix products takes \\(\\Theta(n^{3})\\) time, Faster-APSP runs in \\(\\Theta(n^{3}\\lg n)\\) time. The code is tight, containing no elaborate data structures, and the constant hidden in the \\(\\Theta\\)-notation is therefore small.\n\n## Exercises\n\n### 23.1-1\n\nRun Slow-APSP on the weighted, directed graph of Figure 23.2, showing the matrices that result for each iteration of the loop. Then do the same for Faster-APSP.\n\n#### 23.1-2\n\nWhy is it convenient for both Slow-APSP and Faster-APSP that \\(w_{i}=0\\) for \\(i=1,2,\\ldots,n\\)?\n\n#### 23.1-3\n\nWhat does the matrix\n\n\\[L^{(0)}=\\left(\\begin{array}{cccc}0&\\infty\\,\\infty&\\cdots\\,\\infty\\\\ \\infty&0&\\infty&\\cdots\\,\\infty\\\\ \\infty&\\infty&0&\\cdots\\,\\infty\\\\ \\vdots&\\vdots&\\vdots&\\ddots&\\vdots\\\\ \\infty\\,\\infty\\,\\infty&\\cdots&0\\end{array}\\right)\\]\n\nused in the shortest-paths algorithms correspond to in regular matrix multiplication?\n\n#### 23.1-4\n\nShow that matrix multiplication defined by Extend-Shortest-Paths is associative.\n\n#### 23.1-5\n\nShow how to express the single-source shortest-paths problem as a product of matrices and a vector. Describe how evaluating this product corresponds to a Bellman-Ford-like algorithm (see Section 22.1).\n\n#### 23.1-6\n\nArgue that we don't need the matrix \\(M\\) in Slow-APSP because by substituting \\(L\\) for \\(M\\) and leaving out the initialization of \\(M\\), the code still works correctly. (_Hint:_ Relate line 5 of Extend-Shortest-Paths to Relax on page 610.) Do we need the matrix \\(M\\) in Faster-APSP?\n\nFigure 23.2: A weighted, directed graph for use in Exercises 23.1-1, 23.2-1, and 23.3-1.\n\n#### 23.1-7\n\nSuppose that you also want to compute the vertices on shortest paths in the algorithms of this section. Show how to compute the predecessor matrix \\(\\Pi\\) from the completed matrix \\(L\\) of shortest-path weights in \\(O(n^{3})\\) time.\n\n#### 23.1-8\n\nYou can also compute the vertices on shortest paths along with computing the shortest-path weights. Define \\(\\pi_{ij}^{(r)}\\) as the predecessor of vertex \\(j\\) on any minimum-weight path from vertex \\(i\\) to vertex \\(j\\) that contains at most \\(r\\) edges. Modify the Extend-Shortest-Paths and Slow-APSP procedures to compute the matrices \\(\\Pi^{(1)}\\), \\(\\Pi^{(2)},\\ldots,\\Pi^{(n-1)}\\) as they compute the matrices \\(L^{(1)}\\), \\(L^{(2)},\\ldots,L^{(n-1)}\\).\n\n#### 23.1-9\n\nModify Faster-APSP so that it can determine whether the graph contains a negative-weight cycle.\n\n#### 23.1-10\n\nGive an efficient algorithm to find the length (number of edges) of a minimum-length negative-weight cycle in a graph.\n\n#### The Floyd-Warshall algorithm\n\nHaving already seen one dynamic-programming solution to the all-pairs shortest-paths problem, in this section we'll see another: the _Floyd-Warshall algorithm_, which runs in \\(\\Theta(V^{3})\\) time. As before, negative-weight edges may be present, but not negative-weight cycles. As in Section 23.1, we develop the algorithm by following the dynamic-programming process. After studying the resulting algorithm, we present a similar method for finding the transitive closure of a directed graph.\n\n#### The structure of a shortest path\n\nIn the Floyd-Warshall algorithm, we characterize the structure of a shortest path differently from how we characterized it in Section 23.1. The Floyd-Warshall algorithm considers the intermediate vertices of a shortest path, where an _intermediate_ vertex of a simple path \\(p=\\{v_{1},v_{2},\\ldots,v_{l}\\}\\) is any vertex of \\(p\\) other than \\(v_{1}\\) or \\(v_{l}\\), that is, any vertex in the set \\(\\{v_{2},v_{3},\\ldots,v_{l-1}\\}\\).\n\nThe Floyd-Warshall algorithm relies on the following observation. Numbering the vertices of \\(G\\) by \\(V=\\{1,2,\\ldots,n\\}\\), take a subset \\(\\{1,2,\\ldots,k\\}\\) of vertices for some \\(1\\leq k\\leq n\\). For any pair of vertices \\(i,j\\in V\\), consider all paths from \\(i\\) to \\(j\\) whose intermediate vertices are all drawn from \\(\\{1,2,\\ldots,k\\}\\), and let \\(p\\) be a",
        "chapter": "Part VI Graph Algorithms",
        "section": "23 All-Pairs Shortest Paths",
        "subsection": "23.1 Shortest paths and matrix multiplication",
        "subsubsection": "N/A"
    },
    {
        "content": "#### 23.1-7\n\nSuppose that you also want to compute the vertices on shortest paths in the algorithms of this section. Show how to compute the predecessor matrix \\(\\Pi\\) from the completed matrix \\(L\\) of shortest-path weights in \\(O(n^{3})\\) time.\n\n#### 23.1-8\n\nYou can also compute the vertices on shortest paths along with computing the shortest-path weights. Define \\(\\pi_{ij}^{(r)}\\) as the predecessor of vertex \\(j\\) on any minimum-weight path from vertex \\(i\\) to vertex \\(j\\) that contains at most \\(r\\) edges. Modify the Extend-Shortest-Paths and Slow-APSP procedures to compute the matrices \\(\\Pi^{(1)}\\), \\(\\Pi^{(2)},\\ldots,\\Pi^{(n-1)}\\) as they compute the matrices \\(L^{(1)}\\), \\(L^{(2)},\\ldots,L^{(n-1)}\\).\n\n#### 23.1-9\n\nModify Faster-APSP so that it can determine whether the graph contains a negative-weight cycle.\n\n#### 23.1-10\n\nGive an efficient algorithm to find the length (number of edges) of a minimum-length negative-weight cycle in a graph.\n\n#### The Floyd-Warshall algorithm\n\nHaving already seen one dynamic-programming solution to the all-pairs shortest-paths problem, in this section we'll see another: the _Floyd-Warshall algorithm_, which runs in \\(\\Theta(V^{3})\\) time. As before, negative-weight edges may be present, but not negative-weight cycles. As in Section 23.1, we develop the algorithm by following the dynamic-programming process. After studying the resulting algorithm, we present a similar method for finding the transitive closure of a directed graph.\n\n#### The structure of a shortest path\n\nIn the Floyd-Warshall algorithm, we characterize the structure of a shortest path differently from how we characterized it in Section 23.1. The Floyd-Warshall algorithm considers the intermediate vertices of a shortest path, where an _intermediate_ vertex of a simple path \\(p=\\{v_{1},v_{2},\\ldots,v_{l}\\}\\) is any vertex of \\(p\\) other than \\(v_{1}\\) or \\(v_{l}\\), that is, any vertex in the set \\(\\{v_{2},v_{3},\\ldots,v_{l-1}\\}\\).\n\nThe Floyd-Warshall algorithm relies on the following observation. Numbering the vertices of \\(G\\) by \\(V=\\{1,2,\\ldots,n\\}\\), take a subset \\(\\{1,2,\\ldots,k\\}\\) of vertices for some \\(1\\leq k\\leq n\\). For any pair of vertices \\(i,j\\in V\\), consider all paths from \\(i\\) to \\(j\\) whose intermediate vertices are all drawn from \\(\\{1,2,\\ldots,k\\}\\), and let \\(p\\) be aminimum-weight path from among them. (Path \\(p\\) is simple.) The Floyd-Warshall algorithm exploits a relationship between path \\(p\\) and shortest paths from \\(i\\) to \\(j\\) with all intermediate vertices in the set \\(\\{1,2,\\ldots,k-1\\}\\). The details of the relationship depend on whether \\(k\\) is an intermediate vertex of path \\(p\\) or not.\n* If \\(k\\) is not an intermediate vertex of path \\(p\\), then all intermediate vertices of path \\(p\\) belong to the set \\(\\{1,2,\\ldots,k-1\\}\\). Thus a shortest path from vertex \\(i\\) to vertex \\(j\\) with all intermediate vertices in the set \\(\\{1,2,\\ldots,k-1\\}\\) is also a shortest path from \\(i\\) to \\(j\\) with all intermediate vertices in the set \\(\\{1,2,\\ldots,k\\}\\).\n* If \\(k\\) is an intermediate vertex of path \\(p\\), then decompose \\(p\\) into \\(i\\stackrel{{ P_{1}}}{{\\leadsto}}k\\stackrel{{ P_{2}}}{{\\leadsto}}j\\), as Figure 23 illustrates. By Lemma 22.1, \\(p_{1}\\) is a shortest path from \\(i\\) to \\(k\\) with all intermediate vertices in the set \\(\\{1,2,\\ldots,k\\}\\). In fact, we can make a slightly stronger statement. Because vertex \\(k\\) is not an _intermediate_ vertex of path \\(p_{1}\\), all intermediate vertices of \\(p_{1}\\) belong to the set \\(\\{1,2,\\ldots,k-1\\}\\). Therefore \\(p_{1}\\) is a shortest path from \\(i\\) to \\(k\\) with all intermediate vertices in the set \\(\\{1,2,\\ldots,k-1\\}\\). Likewise, \\(p_{2}\\) is a shortest path from vertex \\(k\\) to vertex \\(j\\) with all intermediate vertices in the set \\(\\{1,2,\\ldots,k-1\\}\\).\n\n#### A recursive solution to the all-pairs shortest-paths problem\n\nThe above observations suggest a recursive formulation of shortest-path estimates that differs from the one in Section 23.1. Let \\(d_{ij}^{(k)}\\) be the weight of a shortest path from vertex \\(i\\) to vertex \\(j\\) for which all intermediate vertices belong to the set \\(\\{1,2,\\ldots,k\\}\\). When \\(k=0\\), a path from vertex \\(i\\) to vertex \\(j\\) with no intermediate vertex numbered higher than \\(0\\) has no intermediate vertices at all. Such a path has at most one edge, and hence \\(d_{ij}^{(0)}=w_{ij}\\). Following the above discussion, define \\(d_{ij}^{(k)}\\) recursively by\n\nFigure 23: Optimal substructure used by the Floyd-Warshall algorithm. Path \\(p\\) is a shortest path from vertex \\(i\\) to vertex \\(j\\), and \\(k\\) is the highest-numbered intermediate vertex of \\(p\\). Path \\(p_{1}\\), the portion of path \\(p\\) from vertex \\(i\\) to vertex \\(k\\), has all intermediate vertices in the set \\(\\{1,2,\\ldots,k-1\\}\\). The same holds for path \\(p_{2}\\) from vertex \\(k\\) to vertex \\(j\\).\n\n#### 23.2 The Floyd-Warshall algorithm\n\n\\[d_{ij}^{(k)}=\\left\\{\\begin{array}{ll}w_{ij}&\\mbox{if $k\\,=0$,}\\\\ \\min\\left\\{d_{ij}^{(k-1)},d_{ik}^{(k-1)}+d_{kj}^{(k-1)}\\right\\}&\\mbox{if $k\\,\\geq 1$.}\\end{array}\\right. \\tag{23.6}\\]\n\nBecause for any path, all intermediate vertices belong to the set \\(\\{1,2,\\ldots,n\\}\\), the matrix \\(D^{(n)}=\\left(d_{ij}^{(n)}\\right)\\) gives the final answer: \\(d_{ij}^{(n)}=\\delta(i,j)\\) for all \\(i,j\\,\\in\\,V\\).\n\n#### Computing the shortest-path weights bottom up\n\nBased on recurrence (23.6), the bottom-up procedure Floyd-Warshall computes the values \\(d_{ij}^{(k)}\\) in order of increasing values of \\(k\\). Its input is an \\(n\\times n\\) matrix \\(W\\) defined as in equation (23.1). The procedure returns the matrix \\(D^{(n)}\\) of shortest-path weights. Figure 23.4 shows the matrices \\(D^{(k)}\\) computed by the Floyd-Warshall algorithm for the graph in Figure 23.1.\n\nThe running time of the Floyd-Warshall algorithm is determined by the triply nested **for** loops of lines 2-6. Because each execution of line 6 takes \\(O(1)\\) time, the algorithm runs in \\(\\Theta(n^{3})\\) time. As in the final algorithm in Section 23.1, the code is tight, with no elaborate data structures, and so the constant hidden in the \\(\\Theta\\)-notation is small. Thus, the Floyd-Warshall algorithm is quite practical for even moderate-sized input graphs.\n\n#### Constructing a shortest path\n\nThere are a variety of different methods for constructing shortest paths in the Floyd-Warshall algorithm. One way is to compute the matrix \\(D\\) of shortest-path weights and then construct the predecessor matrix \\(\\Pi\\) from the \\(D\\) matrix. Exercise 23.1-7 asks you to implement this method so that it runs in \\(O(n^{3})\\) time. Given the predecessor matrix \\(\\Pi\\), the Print-All-Pairs-Shortest-Path procedure prints the vertices on a given shortest path.\n\nAlternatively, the predecessor matrix \\(\\Pi\\) can be computed while the algorithm computes the matrices \\(D^{(0)},D^{(1)},\\ldots,D^{(n)}\\). Specifically, compute a sequence of\\[D^{(0)}=\\left(\\begin{array}{cccccc}0&3&8&\\infty&-4\\\\ \\infty&0&\\infty&1&7\\\\ \\infty&4&0&\\infty&\\infty\\\\ 2&\\infty&-5&0&\\infty\\\\ \\infty&\\infty&\\infty&6&0\\end{array}\\right)\\quad\\Pi^{(0)}=\\left(\\begin{array}{ ccccc}\\text{nil}&1&1&\\text{nil}&1\\\\ \\text{nil}&\\text{nil}&\\text{nil}&2&2\\\\ \\text{nil}&3&\\text{nil}&\\text{nil}&\\text{nil}\\\\ 4&\\text{nil}&4&\\text{nil}&\\text{nil}\\\\ \\text{nil}&\\text{nil}&\\text{nil}&5&\\text{nil}\\end{array}\\right)\\]\n\n\\[D^{(1)}=\\left(\\begin{array}{cccccc}0&3&8&\\infty&-4\\\\ \\infty&0&\\infty&1&7\\\\ \\infty&4&0&5&11\\\\ 2&5&-5&0&-2\\\\ \\infty&\\infty&\\infty&6&0\\end{array}\\right)\\quad\\Pi^{(1)}=\\left(\\begin{array}[] {cccccc}\\text{nil}&1&1&\\text{nil}&1\\\\ \\text{nil}&\\text{nil}&\\text{nil}&2&2\\\\ \\text{nil}&3&\\text{nil}&\\text{nil}&\\text{nil}\\\\ 4&1&4&\\text{nil}&1\\\\ \\text{nil}&\\text{nil}&\\text{nil}&5&\\text{nil}\\end{array}\\right)\\]\n\n\\[D^{(2)}=\\left(\\begin{array}{cccccc}0&3&8&4&-4\\\\ \\infty&0&\\infty&1&7\\\\ \\infty&4&0&5&11\\\\ 2&-1&-5&0&-2\\\\ \\infty&\\infty&\\infty&6&0\\end{array}\\right)\\quad\\Pi^{(2)}=\\left(\\begin{array}[] {cccccc}\\text{nil}&1&1&2&1\\\\ \\text{nil}&\\text{nil}&\\text{nil}&2&2\\\\ \\text{nil}&3&\\text{nil}&2&2\\\\ 4&1&4&\\text{nil}&1\\\\ \\text{nil}&\\text{nil}&\\text{nil}&5&\\text{nil}\\end{array}\\right)\\]\n\n\\[D^{(3)}=\\left(\\begin{array}{cccccc}0&3&8&4&-4\\\\ \\infty&0&\\infty&1&7\\\\ \\infty&4&0&5&11\\\\ 2&-1&-5&0&-2\\\\ \\infty&\\infty&\\infty&6&0\\end{array}\\right)\\quad\\Pi^{(3)}=\\left(\\begin{array}[] {cccccc}\\text{nil}&1&1&2&1\\\\ \\text{nil}&\\text{nil}&\\text{nil}&2&2\\\\ \\text{nil}&3&\\text{nil}&2&2\\\\ 4&3&4&\\text{nil}&1\\\\ \\text{nil}&\\text{nil}&\\text{nil}&5&\\text{nil}\\end{array}\\right)\\]\n\n\\[D^{(4)}=\\left(\\begin{array}{cccccc}0&3&-1&4&-4\\\\ 3&0&-4&1&-1\\\\ 7&4&0&5&3\\\\ 2&-1&-5&0&-2\\\\ 8&5&1&6&0\\end{array}\\right)\\quad\\quad\\Pi^{(4)}=\\left(\\begin{array}{cccccc} \\text{nil}&1&4&2&1\\\\ 4&\\text{nil}&4&2&1\\\\ 4&3&\\text{nil}&2&1\\\\ 4&3&4&\\text{nil}&1\\\\ 4&3&4&5&\\text{nil}\\end{array}\\right)\\]\n\n\\[D^{(5)}=\\left(\\begin{array}{cccccc}0&1&-3&2&-4\\\\ 3&0&-4&1&-1\\\\ 7&4&0&5&3\\\\ 2&-1&-5&0&-2\\\\ 8&5&1&6&0\\end{array}\\right)\\quad\\quad\\Pi^{(5)}=\\left(\\begin{array}{cccccc} \\text{nil}&3&4&5&1\\\\ 4&\\text{nil}&4&2&1\\\\ 4&3&\\text{nil}&2&1\\\\ 4&3&4&\\text{nil}&1\\\\ 4&3&4&5&\\text{nil}\\end{array}\\right)\\]\n\n\\[D^{(5)}=\\left(\\begin{array}{cccccc}0&1&-3&2&-4\\\\ 3&0&-4&1&-1\\\\ 7&4&0&5&3\\\\ 2&-1&-5&0&-2\\\\ 8&5&1&6&0\\end{array}\\right)\\quad\\quad\\Pi^{(5)}=\\left(\\begin{array}{cccccc} \\text{nil}&3&4&5&1\\\\ 4&\\text{nil}&4&2&1\\\\ 4&3&\\text{nil}&2&1\\\\ 4&3&4&\\text{nil}&1\\\\ 4&3&4&5&\\text{nil}\\end{array}\\right)\\]\n\nmatrices \\(\\Pi^{(0)},\\Pi^{(1)},\\ldots,\\Pi^{(n)}\\), where \\(\\Pi=\\Pi^{(n)}\\) and \\(\\pi^{(k)}_{ij}\\) is the predecessor of vertex \\(j\\) on a shortest path from vertex \\(i\\) with all intermediate vertices in the set \\(\\{1,2,\\ldots,k\\}\\).\n\nHere's a recursive formulation of \\(\\pi^{(k)}_{ij}\\). When \\(k=0\\), a shortest path from \\(i\\) to \\(j\\) has no intermediate vertices at all, and so\n\nFigure 23: The sequence of matrices \\(D^{(k)}\\) and \\(\\Pi^{(k)}\\) computed by the Floyd-Warshall algorithm for the graph in Figure 23.1.\n\n\\[\\pi^{(0)}_{ij}=\\left\\{\\begin{array}{ll}\\mbox{\\sc nil}&\\mbox{if $i\\,=\\,j$ or $w_{ij}=\\infty$,}\\\\ i&\\mbox{if $i\\,\\neq\\,j$ and $w_{ij}<\\infty$.}\\end{array}\\right. \\tag{23.7}\\]\n\nFor \\(k\\,\\geq\\,1\\), if the path has \\(k\\) as an intermediate vertex, so that it is \\(i\\leadsto k\\leadsto j\\) where \\(k\\,\\neq\\,j\\), then choose as the predecessor of \\(j\\) on this path the same vertex as the predecessor of \\(j\\) chosen on a shortest path from \\(k\\) with all intermediate vertices in the set \\(\\{1,2,\\ldots,k\\,-1\\}\\). Otherwise, when the path from \\(i\\) to \\(j\\) does not have \\(k\\) as an intermediate vertex, choose the same predecessor of \\(j\\) as on a shortest path from \\(i\\) with all intermediate vertices in the set \\(\\{1,2,\\ldots,k\\,-1\\}\\). Formally, for \\(k\\,\\geq\\,1\\),\n\n\\[\\pi^{(k)}_{ij}=\\left\\{\\begin{array}{ll}\\pi^{(k-1)}_{kj}&\\mbox{if $d^{(k-1)}_{ij}>d^{(k-1)}_{ jk}+d^{(k-1)}_{kj}$ ($k$ is an intermediate vertex),}\\\\ \\pi^{(k-1)}_{ij}&\\mbox{if $d^{(k-1)}_{ij}\\leq d^{(k-1)}_{ik}+d^{(k-1)}_{kj}$ ($k$ is not an intermediate vertex).}\\end{array}\\right. \\tag{23.8}\\]\n\nExercise 23.2-3 asks you to show how to incorporate the \\(\\Pi^{(k)}\\) matrix computations into the Floyd-Warshall procedure. Figure 23.4 shows the sequence of \\(\\Pi^{(k)}\\) matrices that the resulting algorithm computes for the graph of Figure 23.1. The exercise also asks for the more difficult task of proving that the predecessor subgraph \\(G_{\\pi,i}\\) is a shortest-paths tree with root \\(i\\). Exercise 23.2-7 asks for yet another way to reconstruct shortest paths.\n\n#### Transitive closure of a directed graph\n\nGiven a directed graph \\(G=(V,E)\\) with vertex set \\(V=\\{1,2,\\ldots,n\\}\\), you might wish to determine simply whether \\(G\\) contains a path from \\(i\\) to \\(j\\) for all vertex pairs \\(i,\\,j\\,\\in\\,V\\), without regard to edge weights. We define the _transitive closure_ of \\(G\\) as the graph \\(G^{*}=(V,E^{*})\\), where\n\n\\[E^{*}=\\{(i,\\,j):\\mbox{there is a path from vertex $i$ to vertex $j$ in $G$}\\}\\enspace.\\]\n\nOne way to compute the transitive closure of a graph in \\(\\Theta(n^{3})\\) time is to assign a weight of \\(1\\) to each edge of \\(E\\) and run the Floyd-Warshall algorithm. If there is a path from vertex \\(i\\) to vertex \\(j\\), you get \\(d_{ij}\\,<\\,n\\). Otherwise, you get \\(d_{ij}\\,=\\,\\infty\\).\n\nThere is another, similar way to compute the transitive closure of \\(G\\) in \\(\\Theta(n^{3})\\) time, which can save time and space in practice. This method substitutes the logical operations \\(\\vee\\) (logical OR) and \\(\\wedge\\) (logical AND) for the arithmetic operations min and \\(+\\) in the Floyd-Warshall algorithm. For \\(i,\\,j,k\\,=\\,1,2,\\ldots,n\\), define \\(t^{(k)}_{ij}\\) to be \\(1\\) if there exists a path in graph \\(G\\) from vertex \\(i\\) to vertex \\(j\\) with all intermediate vertices in the set \\(\\{1,2,\\ldots,k\\}\\), and \\(0\\) otherwise. To construct the transitive closure \\(G^{*}=(V,E^{*})\\), put edge \\((i,\\,j)\\) into \\(E^{*}\\) if and only if \\(t^{(n)}_{ij}=1\\). A recursive definition of \\(t^{(k)}_{ij}\\), analogous to recurrence (23.6), is \\[T^{(0)}=\\left(\\begin{array}{cccc}1&0&0&0\\\\ 0&1&1&1\\\\ 0&1&1&0\\\\ 1&0&1&1\\end{array}\\right)\\quad T^{(1)}=\\left(\\begin{array}{cccc}1&0&0&0\\\\ 0&1&1&1\\\\ 0&1&1&0\\\\ 1&0&1&1\\end{array}\\right)\\quad T^{(2)}=\\left(\\begin{array}{cccc}1&0&0&0\\\\ 0&1&1&1\\\\ 0&1&1&1\\\\ 1&0&1&1\\end{array}\\right)\\quad\\]\n\n\\[T^{(3)}=\\left(\\begin{array}{cccc}1&0&0&0\\\\ 0&1&1&1\\\\ 0&1&1&1\\\\ 1&1&1&1\\end{array}\\right)\\quad T^{(4)}=\\left(\\begin{array}{cccc}1&0&0&0\\\\ 1&1&1&1\\\\ 1&1&1&1\\\\ 1&1&1&1\\end{array}\\right)\\quad\\]\n\n\\[t_{ij}^{(0)}=\\left\\{\\begin{array}{cccc}0&\\mbox{if $i\\,\\neq j$ and $(i,j)\\notin E$,}\\\\ 1&\\mbox{if $i\\,=j$ or $(i,j)\\in E$,}\\end{array}\\right.\\]\n\nand for \\(k\\,\\geq\\,1\\),\n\n\\[t_{ij}^{(k)}=t_{ij}^{(k-1)}\\vee\\left(t_{ik}^{(k-1)}\\wedge t_{kj}^{(k-1)} \\right). \\tag{23.9}\\]\n\nAs in the Floyd-Warshall algorithm, the Transitive-Closure procedure computes the matrices \\(T^{(k)}=\\left(t_{ij}^{(k)}\\right)\\) in order of increasing \\(k\\).\n\nFigure 23.5 shows the matrices \\(T^{(k)}\\) computed by the Transitive-Closure procedure on a sample graph. The Transitive-Closure procedure, like the Floyd-Warshall algorithm, runs in \\(\\Theta(n^{3})\\) time. On some computers, though, logical operations on single-bit values execute faster than arithmetic operations on integer words of data. Moreover, because the direct trans\n\nFigure 23.5: A directed graph and the matrices \\(T^{(k)}\\) computed by the transitive-closure algorithm.\n\nuses only boolean values rather than integer values, its space requirement is less than the Floyd-Warshall algorithm's by a factor corresponding to the size of a word of computer storage.\n\n##### Exercises\n\n##### 23.2-1\n\nRun the Floyd-Warshall algorithm on the weighted, directed graph of Figure 23.2. Show the matrix \\(D^{(k)}\\) that results for each iteration of the outer loop.\n\n##### 23.2-2\n\nShow how to compute the transitive closure using the technique of Section 23.1.\n\n##### 23.2-3\n\nModify the Floyd-Warshall procedure to compute the \\(\\Pi^{(k)}\\) matrices according to equations (23.7) and (23.8). Prove rigorously that for all \\(i\\in V\\), the predecessor subgraph \\(G_{\\pi,i}\\) is a shortest-paths tree with root \\(i\\). (_Hint:_ To show that \\(G_{\\pi,i}\\) is acyclic, first show that \\(\\pi_{ij}^{(k)}=l\\) implies \\(d_{ij}^{(k)}\\geq d_{il}^{(k)}+w_{lj}\\), according to the definition of \\(\\pi_{ij}^{(k)}\\). Then adapt the proof of Lemma 22.16.)\n\n##### 23.2-4\n\nAs it appears on page 657, the Floyd-Warshall algorithm requires \\(\\Theta(n^{3})\\) space, since it creates \\(d_{ij}^{(k)}\\) for \\(i,j,k=1,2,\\ldots,n\\). Show that the procedure Floyd-Warshall\\({}^{\\prime}\\), which simply drops all the superscripts, is correct, and thus only \\(\\Theta(n^{2})\\) space is required.\n\n```\nFloyd-Warshall\\({}^{\\prime}(W,n)\\)\n1\\(D=W\\)\n2for\\(k=1\\)to\\(n\\)\n3for\\(i=1\\)to\\(n\\)\n4for\\(j=1\\)to\\(n\\)\n5\\(d_{ij}=\\min\\left\\{d_{ij},d_{ik}+d_{kj}\\right\\}\\)\n6return\\(D\\)\n```\n\n#### 23.2-5\n\nConsider the following change to how equation (23.8) handles equality:\n\n\\[\\pi_{ij}^{(k)}=\\left\\{\\begin{array}{ll}\\pi_{kj}^{(k-1)}&\\mbox{if $d_{ij}^{(k-1)} \\geq d_{ik}^{(k-1)}+d_{kj}^{(k-1)}$ ($k$ is an intermediate vertex),}\\\\ \\pi_{ij}^{(k-1)}&\\mbox{if $d_{ij}^{(k-1)}<d_{ik}^{(k-1)}+d_{kj}^{(k-1)}$ ($k$ is not an intermediate vertex).}\\end{array}\\right.\\]\n\nIs this alternative definition of the predecessor matrix \\(\\Pi\\) correct?\n\n#### 23.2-6\n\nShow how to use the output of the Floyd-Warshall algorithm to detect the presence of a negative-weight cycle.\n\n#### 23.2-7\n\nAnother way to reconstruct shortest paths in the Floyd-Warshall algorithm uses values \\(\\phi_{ij}^{(k)}\\) for \\(i,j,k=1,2,\\ldots,n\\), where \\(\\phi_{ij}^{(k)}\\) is the highest-numbered intermediate vertex of a shortest path from \\(i\\) to \\(j\\) in which all intermediate vertices lie in the set \\(\\{1,2,\\ldots,k\\}\\). Give a recursive formulation for \\(\\phi_{ij}^{(k)}\\), modify the Floyd-Warshall procedure to compute the \\(\\phi_{ij}^{(k)}\\) values, and rewrite the Print-All-Pairs-Shortest-Path procedure to take the matrix \\(\\Phi=\\left(\\phi_{ij}^{(n)}\\right)\\) as an input. How is the matrix \\(\\Phi\\) like the \\(s\\) table in the matrix-chain multiplication problem of Section 14.2?\n\n#### 23.2-8\n\nGive an \\(O(VE)\\)-time algorithm for computing the transitive closure of a directed graph \\(G=(V,E)\\). Assume that \\(|V|=O(E)\\) and that the graph is represented with adjacency lists.\n\n#### 23.2-9\n\nSuppose that it takes \\(f(|V|\\,,|E|)\\) time to compute the transitive closure of a directed acyclic graph, where \\(f\\) is a monotonically increasing function of both \\(|V|\\) and \\(|E|\\). Show that the time to compute the transitive closure \\(G^{*}=(V,E^{*})\\) of a general directed graph \\(G=(V,E)\\) is then \\(f(|V|\\,,|E|)+O(V+E^{*})\\).\n\n### Johnson's algorithm for sparse graphs\n\nJohnson's algorithm finds shortest paths between all pairs in \\(O(V^{2}\\lg V+VE)\\) time. For sparse graphs, it is asymptotically faster than either repeated squaring of matrices or the Floyd-Warshall algorithm. The algorithm either returns a matrix of shortest-path weights for all pairs of vertices or reports that the input graph contains a negative-weight cycle. Johnson's algorithm uses as subroutines both Dijkstra's algorithm and the Bellman-Ford algorithm, which Chapter 22 describes.\n\nJohnson's algorithm uses the technique of _reweighting_, which works as follows. If all edge weights \\(w\\) in a graph \\(G=(V,E)\\) are nonnegative, Dijkstra's algorithm can find shortest paths between all pairs of vertices by running it once from each vertex. With the Fibonacci-heap min-priority queue, the running time of this all-pairs algorithm is \\(O(V^{2}\\lg V+VE)\\). If \\(G\\) has negative-weight edges but no negative-weight cycles, first compute a new set of nonnegative edge weights so",
        "chapter": "Part VI Graph Algorithms",
        "section": "23 All-Pairs Shortest Paths",
        "subsection": "23.2 The Floyd-Warshall algorithm",
        "subsubsection": "N/A"
    },
    {
        "content": "#### 23.2-6\n\nShow how to use the output of the Floyd-Warshall algorithm to detect the presence of a negative-weight cycle.\n\n#### 23.2-7\n\nAnother way to reconstruct shortest paths in the Floyd-Warshall algorithm uses values \\(\\phi_{ij}^{(k)}\\) for \\(i,j,k=1,2,\\ldots,n\\), where \\(\\phi_{ij}^{(k)}\\) is the highest-numbered intermediate vertex of a shortest path from \\(i\\) to \\(j\\) in which all intermediate vertices lie in the set \\(\\{1,2,\\ldots,k\\}\\). Give a recursive formulation for \\(\\phi_{ij}^{(k)}\\), modify the Floyd-Warshall procedure to compute the \\(\\phi_{ij}^{(k)}\\) values, and rewrite the Print-All-Pairs-Shortest-Path procedure to take the matrix \\(\\Phi=\\left(\\phi_{ij}^{(n)}\\right)\\) as an input. How is the matrix \\(\\Phi\\) like the \\(s\\) table in the matrix-chain multiplication problem of Section 14.2?\n\n#### 23.2-8\n\nGive an \\(O(VE)\\)-time algorithm for computing the transitive closure of a directed graph \\(G=(V,E)\\). Assume that \\(|V|=O(E)\\) and that the graph is represented with adjacency lists.\n\n#### 23.2-9\n\nSuppose that it takes \\(f(|V|\\,,|E|)\\) time to compute the transitive closure of a directed acyclic graph, where \\(f\\) is a monotonically increasing function of both \\(|V|\\) and \\(|E|\\). Show that the time to compute the transitive closure \\(G^{*}=(V,E^{*})\\) of a general directed graph \\(G=(V,E)\\) is then \\(f(|V|\\,,|E|)+O(V+E^{*})\\).\n\n### Johnson's algorithm for sparse graphs\n\nJohnson's algorithm finds shortest paths between all pairs in \\(O(V^{2}\\lg V+VE)\\) time. For sparse graphs, it is asymptotically faster than either repeated squaring of matrices or the Floyd-Warshall algorithm. The algorithm either returns a matrix of shortest-path weights for all pairs of vertices or reports that the input graph contains a negative-weight cycle. Johnson's algorithm uses as subroutines both Dijkstra's algorithm and the Bellman-Ford algorithm, which Chapter 22 describes.\n\nJohnson's algorithm uses the technique of _reweighting_, which works as follows. If all edge weights \\(w\\) in a graph \\(G=(V,E)\\) are nonnegative, Dijkstra's algorithm can find shortest paths between all pairs of vertices by running it once from each vertex. With the Fibonacci-heap min-priority queue, the running time of this all-pairs algorithm is \\(O(V^{2}\\lg V+VE)\\). If \\(G\\) has negative-weight edges but no negative-weight cycles, first compute a new set of nonnegative edge weights sothat Dijkstra's algorithm applies. The new set of edge weights \\(\\widehat{w}\\) must satisfy two important properties:\n\n1. For all pairs of vertices \\(u,v\\in V\\), a path \\(p\\) is a shortest path from \\(u\\) to \\(v\\) using weight function \\(w\\) if and only if \\(p\\) is also a shortest path from \\(u\\) to \\(v\\) using weight function \\(\\widehat{w}\\).\n2. For all edges \\((u,v)\\), the new weight \\(\\widehat{w}(u,v)\\) is nonnegative.\n\nAs we'll see in a moment, preprocessing \\(G\\) to determine the new weight function \\(\\widehat{w}\\) takes \\(O(VE)\\) time.\n\n##### Preserving shortest paths by reweighting\n\nThe following lemma shows how to reweight the edges to satisfy the first property above. We use \\(\\delta\\) to denote shortest-path weights derived from weight function \\(w\\) and \\(\\widehat{\\delta}\\) to denote shortest-path weights derived from weight function \\(\\widehat{w}\\).\n\n**Lemma 23.1** (Reweighting does not change shortest paths): _Given a weighted, directed graph \\(G=(V,E)\\) with weight function \\(w:E\\to\\mathbb{R}\\), let \\(h:V\\to\\mathbb{R}\\) be any function mapping vertices to real numbers. For each edge \\((u,v)\\in E\\), define_\n\n\\[\\widehat{w}(u,v)=w(u,v)+h(u)-h(v). \\tag{23.10}\\]\n\n_Let \\(p=\\langle v_{0},\\,v_{1},\\,\\ldots,\\,v_{k}\\rangle\\) be any path from vertex \\(v_{0}\\) to vertex \\(v_{k}\\). Then \\(p\\) is a shortest path from \\(v_{0}\\) to \\(v_{k}\\) with weight function \\(w\\) if and only if it is a shortest path with weight function \\(\\widehat{w}\\). That is, \\(w(p)=\\delta(v_{0},v_{k})\\) if and only if \\(\\widehat{w}(p)=\\widehat{\\delta}(v_{0},v_{k})\\). Furthermore, \\(G\\) has a negative-weight cycle using weight function \\(w\\) if and only if \\(G\\) has a negative-weight cycle using weight function \\(\\widehat{w}\\)._\n\n_Proof_ We start by showing that\n\n\\[\\widehat{w}(p)=w(p)+h(v_{0})-h(v_{k}). \\tag{23.11}\\]\n\nWe have\n\n\\[\\widehat{w}(p) = \\sum_{i=1}^{k}\\widehat{w}(v_{i-1},v_{i})\\] \\[= \\sum_{i=1}^{k}(w(v_{i-1},v_{i})+h(v_{i-1})-h(v_{i}))\\] \\[= \\sum_{i=1}^{k}w(v_{i-1},v_{i})+h(v_{0})-h(v_{k})\\qquad\\text{ (because the sum telescopes)}\\] \\[= w(p)+h(v_{0})-h(v_{k})\\.\\]Therefore, any path \\(p\\) from \\(v_{0}\\) to \\(v_{k}\\) has \\(\\widehat{w}(p)=w(p)+h(v_{0})-h(v_{k})\\). Because \\(h(v_{0})\\) and \\(h(v_{k})\\) do not depend on the path, if one path from \\(v_{0}\\) to \\(v_{k}\\) is shorter than another using weight function \\(w\\), then it is also shorter using \\(\\widehat{w}\\). Thus, \\(w(p)=\\delta(v_{0},v_{k})\\) if and only if \\(\\widehat{w}(p)=\\widehat{\\delta}(v_{0},v_{k})\\).\n\nFinally, we show that \\(G\\) has a negative-weight cycle using weight function \\(w\\) if and only if \\(G\\) has a negative-weight cycle using weight function \\(\\widehat{w}\\). Consider any cycle \\(c=\\langle v_{0},v_{1},\\ldots,v_{k}\\rangle\\), where \\(v_{0}=v_{k}\\). By equation (23.11),\n\n\\[\\widehat{w}(c) = w(c)+h(v_{0})-h(v_{k})\\] \\[= w(c)\\,\\]\n\nand thus \\(c\\) has negative weight using \\(w\\) if and only if it has negative weight using \\(\\widehat{w}\\).\n\n##### Producing nonnegative weights by reweighting\n\nOur next goal is to ensure that the second property holds: \\(\\widehat{w}(u,v)\\) must be nonnegative for all edges \\((u,v)\\in E\\). Given a weighted, directed graph \\(G=(V,E)\\) with weight function \\(w:E\\to\\mathbb{R}\\), we'll see how to make a new graph \\(G^{\\prime}=(V^{\\prime},E^{\\prime})\\), where \\(V^{\\prime}=V\\cup\\{s\\}\\) for some new vertex \\(s\\notin V\\) and \\(E^{\\prime}=E\\cup\\{(s,v):v\\in V\\}\\). To incorporate the new vertex \\(s\\), extend the weight function \\(w\\) so that \\(w(s,v)=0\\) for all \\(v\\in V\\). Since no edges enter \\(s\\), no shortest paths in \\(G^{\\prime}\\), other than those with source \\(s\\), contain \\(s\\). Moreover, \\(G^{\\prime}\\) has no negative-weight cycles if and only if \\(G\\) has no negative-weight cycles. Figure 23.6(a) shows the graph \\(G^{\\prime}\\) corresponding to the graph \\(G\\) of Figure 23.1.\n\nNow suppose that \\(G\\) and \\(G^{\\prime}\\) have no negative-weight cycles. Define the function \\(h(v)=\\delta(s,v)\\) for all \\(v\\in V^{\\prime}\\). By the triangle inequality (Lemma 22.10 on page 63), we have \\(h(v)\\leq h(u)+w(u,v)\\) for all edges \\((u,v)\\in E^{\\prime}\\). Thus, by defining reweighted edge weights \\(\\widehat{w}\\) according to equation (23.10), we have \\(\\widehat{w}(u,v)=w(u,v)+h(u)-h(v)\\geq 0\\), thereby satisfying the second property. Figure 23.6(b) shows the graph \\(G^{\\prime}\\) from Figure 23.6(a) with reweighted edges.\n\n##### Computing all-pairs shortest paths\n\nJohnson's algorithm to compute all-pairs shortest paths uses the Bellman-Ford algorithm (Section 22.1) and Dijkstra's algorithm (Section 22.3) as subroutines. The pseudocode appears in the procedure Johnson on page 66. It assumes implicitly that the edges are stored in adjacency lists. The algorithm returns the usual \\(|V|\\times|V|\\) matrix \\(D=(d_{ij})\\), where \\(d_{ij}=\\delta(i,j)\\), or it reports that the input graph contains a negative-weight cycle. As is typical for an all-pairs shortest-paths algorithm, it assumes that the vertices are numbered from \\(1\\) to \\(|V|\\).\n\n#### 23.3 Johnson's algorithm for sparse graphs\n\nFigure 23.6: Johnson\u2019s all-pairs shortest-paths algorithm run on the graph of Figure 23.1. Vertex numbers appear outside the vertices. **(a)** The graph \\(G^{\\prime}\\) with the original weight function \\(w\\). The new vertex \\(s\\) is blue. Within each vertex \\(v\\) is \\(h(v)=\\delta(s,v)\\). **(b)** After reweighting each edge \\((u,v)\\) with weight function \\(\\widehat{w}(u,v)=w(u,v)+h(u)-h(v)\\). **(c)\u2013(g)** The result of running Dijkstra\u2019s algorithm on each vertex of \\(G\\) using weight function \\(\\widehat{w}\\). In each part, the source vertex \\(u\\) is blue, and blue edges belong to the shortest-paths tree computed by the algorithm. Within each vertex \\(v\\) are the values \\(\\widehat{\\delta}(u,v)\\) and \\(\\delta(u,v)\\), separated by a slash. The value \\(d_{uv}=\\delta(u,v)\\) is equal to \\(\\widehat{\\delta}(u,v)+h(v)-h(u)\\).\n\nThe Johnson procedure simply performs the actions specified earlier. Line 1 produces \\(G^{\\prime}\\). Line 2 runs the Bellman-Ford algorithm on \\(G^{\\prime}\\) with weight function \\(w\\) and source vertex \\(s\\). If \\(G^{\\prime}\\), and hence \\(G\\), contains a negative-weight cycle, line 3 reports the problem. Lines 4-12 assume that \\(G^{\\prime}\\) contains no negative-weight cycles. Lines 4-5 set \\(h(v)\\) to the shortest-path weight \\(\\delta(s,v)\\) computed by the Bellman-Ford algorithm for all \\(v\\in V^{\\prime}\\). Lines 6-7 compute the new weights \\(\\widehat{w}\\). For each pair of vertices \\(u,v\\in V\\), the **for** loop of lines 9-12 computes the shortest-path weight \\(\\widehat{\\delta}(u,v)\\) by calling Dijkstra's algorithm once from each vertex in \\(V\\). Line 12 stores in matrix entry \\(d_{uv}\\) the correct shortest-path weight \\(\\delta(u,v)\\), calculated using equation (23.11). Finally, line 13 returns the completed \\(D\\) matrix. Figure 23.6 depicts the execution of Johnson's algorithm.\n\nIf the min-priority queue in Dijkstra's algorithm is implemented by a Fibonacci heap, Johnson's algorithm runs in \\(O(V^{2}\\lg V+VE)\\) time. The simpler binary min-heap implementation yields a running time of \\(O(VE\\lg V)\\), which is still asymptotically faster than the Floyd-Warshall algorithm if the graph is sparse.\n\n#### Exercises\n\n#### 23.3-1\n\nUse Johnson's algorithm to find the shortest paths between all pairs of vertices in the graph of Figure 23.2. Show the values of \\(h\\) and \\(\\widehat{w}\\) computed by the algorithm.\n\n_23.3-2_\n\nWhat is the purpose of adding the new vertex \\(s\\) to \\(V\\), yielding \\(V^{\\prime}\\)?\n\n_23.3-3_\n\nSuppose that \\(w(u,v)\\geq 0\\) for all edges \\((u,v)\\in E\\). What is the relationship between the weight functions \\(w\\) and \\(\\widehat{w}\\)?\n\n_23.3-4_\n\nProfessor Greenstreet claims that there is a simpler way to reweight edges than the method used in Johnson's algorithm. Letting \\(w^{\\star}=\\min\\left\\{w(u,v):(u,v)\\in E\\right\\}\\), just define \\(\\widehat{w}(u,v)=w(u,v)-w^{\\star}\\) for all edges \\((u,v)\\in E\\). What is wrong with the professor's method of reweighting?\n\n_23.3-5_\n\nShow that if \\(G\\) contains a 0-weight cycle \\(c\\), then \\(\\widehat{w}(u,v)=0\\) for every edge \\((u,v)\\) in \\(c\\).\n\n_23.3-6_\n\nProfessor Michener claims that there is no need to create a new source vertex in line 1 of Johnson. He suggests using \\(G^{\\prime}=G\\) instead and letting \\(s\\) be any vertex. Give an example of a weighted, directed graph \\(G\\) for which incorporating the professor's idea into Johnson causes incorrect answers. Assume that \\(\\infty-\\infty\\) is undefined, and in particular, it is not 0. Then show that if \\(G\\) is strongly connected (every vertex is reachable from every other vertex), the results returned by Johnson with the professor's modification are correct.\n\n## Problems\n\n### Transitive closure of a dynamic graph\n\nYou wish to maintain the transitive closure of a directed graph \\(G=(V,E)\\) as you insert edges into \\(E\\). That is, after inserting an edge, you update the transitive closure of the edges inserted so far. Start with \\(G\\) having no edges initially, and represent the transitive closure by a boolean matrix.\n\n_a._\n\nShow how to update the transitive closure \\(G^{\\star}=(V,E^{\\star})\\) of a graph \\(G=(V,E)\\) in \\(O(V^{2})\\) time when a new edge is added to \\(G\\).\n\n_b._\n\nGive an example of a graph \\(G\\) and an edge \\(e\\) such that \\(\\Omega(V^{2})\\) time is required to update the transitive closure after inserting \\(e\\) into \\(G\\), no matter what algorithm is used.",
        "chapter": "Part VI Graph Algorithms",
        "section": "23 All-Pairs Shortest Paths",
        "subsection": "23.3 Johnson\u2019s algorithm for sparse graphs",
        "subsubsection": "N/A"
    },
    {
        "content": "_23.3-2_\n\nWhat is the purpose of adding the new vertex \\(s\\) to \\(V\\), yielding \\(V^{\\prime}\\)?\n\n_23.3-3_\n\nSuppose that \\(w(u,v)\\geq 0\\) for all edges \\((u,v)\\in E\\). What is the relationship between the weight functions \\(w\\) and \\(\\widehat{w}\\)?\n\n_23.3-4_\n\nProfessor Greenstreet claims that there is a simpler way to reweight edges than the method used in Johnson's algorithm. Letting \\(w^{\\star}=\\min\\left\\{w(u,v):(u,v)\\in E\\right\\}\\), just define \\(\\widehat{w}(u,v)=w(u,v)-w^{\\star}\\) for all edges \\((u,v)\\in E\\). What is wrong with the professor's method of reweighting?\n\n_23.3-5_\n\nShow that if \\(G\\) contains a 0-weight cycle \\(c\\), then \\(\\widehat{w}(u,v)=0\\) for every edge \\((u,v)\\) in \\(c\\).\n\n_23.3-6_\n\nProfessor Michener claims that there is no need to create a new source vertex in line 1 of Johnson. He suggests using \\(G^{\\prime}=G\\) instead and letting \\(s\\) be any vertex. Give an example of a weighted, directed graph \\(G\\) for which incorporating the professor's idea into Johnson causes incorrect answers. Assume that \\(\\infty-\\infty\\) is undefined, and in particular, it is not 0. Then show that if \\(G\\) is strongly connected (every vertex is reachable from every other vertex), the results returned by Johnson with the professor's modification are correct.\n\n## Problems\n\n### Transitive closure of a dynamic graph\n\nYou wish to maintain the transitive closure of a directed graph \\(G=(V,E)\\) as you insert edges into \\(E\\). That is, after inserting an edge, you update the transitive closure of the edges inserted so far. Start with \\(G\\) having no edges initially, and represent the transitive closure by a boolean matrix.\n\n_a._\n\nShow how to update the transitive closure \\(G^{\\star}=(V,E^{\\star})\\) of a graph \\(G=(V,E)\\) in \\(O(V^{2})\\) time when a new edge is added to \\(G\\).\n\n_b._\n\nGive an example of a graph \\(G\\) and an edge \\(e\\) such that \\(\\Omega(V^{2})\\) time is required to update the transitive closure after inserting \\(e\\) into \\(G\\), no matter what algorithm is used.\n\n_c._: Give an algorithm for updating the transitive closure as edges are inserted into the graph. For any sequence of \\(r\\) insertions, your algorithm should run in time \\(\\sum_{i=1}^{r}t_{i}\\ =\\ O(V^{3})\\), where \\(t_{i}\\) is the time to update the transitive closure upon inserting the \\(i\\)th edge. Prove that your algorithm attains this time bound.\n\n#### 23.2 Shortest paths in \\(\\epsilon\\)-dense graphs\n\nA graph \\(G=(V,E)\\) is \\(\\epsilon\\)_-dense_ if \\(|E|=\\Theta(V^{1+\\epsilon})\\) for some constant \\(\\epsilon\\) in the range \\(0<\\epsilon\\leq 1\\). \\(d\\)-ary min-heaps (see Problem 6-2 on page 179) provide a way to match the running times of Fibonacci-heap-based shortest-path algorithms on \\(\\epsilon\\)-dense graphs without using as complicated a data structure.\n\n_a._: What are the asymptotic running times for the operations Insert, Extract-Min, and Decrease-Key, as a function of \\(d\\) and the number \\(n\\) of elements in a \\(d\\)-ary min-heap? What are these running times if you choose \\(d=\\Theta(n^{\\alpha})\\) for some constant \\(0<\\alpha\\leq 1\\)? Compare these running times to the amortized costs of these operations for a Fibonacci heap.\n\n_b._: Show how to compute shortest paths from a single source on an \\(\\epsilon\\)-dense directed graph \\(G=(V,E)\\) with no negative-weight edges in \\(O(E)\\) time. (_Hint_: Pick \\(d\\) as a function of \\(\\epsilon\\).)\n\n_c._: Show how to solve the all-pairs shortest-paths problem on an \\(\\epsilon\\)-dense directed graph \\(G=(V,E)\\) with no negative-weight edges in \\(O(VE)\\) time.\n\n_d._: Show how to solve the all-pairs shortest-paths problem in \\(O(VE)\\) time on an \\(\\epsilon\\)-dense directed graph \\(G=(V,E)\\) that may have negative-weight edges but has no negative-weight cycles.\n\n## Chapter notes\n\nLawler [276] has a good discussion of the all-pairs shortest-paths problem. He attributes the matrix-multiplication algorithm to the folklore. The Floyd-Warshall algorithm is due to Floyd [144], who based it on a theorem of Warshall [450] that describes how to compute the transitive closure of boolean matrices. Johnson's algorithm is taken from [238].\n\nSeveral researchers have given improved algorithms for computing shortest paths via matrix multiplication. Fredman [153] shows how to solve the all-pairs shortest paths problem using \\(O(V^{5/2})\\) comparisons between sums of edge weights and obtains an algorithm that runs in \\(O(V^{3}(\\lg\\lg V/\\lg V)^{1/3})\\) time, which is slightly better than the running time of the Floyd-Warshall algorithm. This bound",
        "chapter": "Part VI Graph Algorithms",
        "section": "23 All-Pairs Shortest Paths",
        "subsection": "Problems",
        "subsubsection": "N/A"
    },
    {
        "content": "_c._: Give an algorithm for updating the transitive closure as edges are inserted into the graph. For any sequence of \\(r\\) insertions, your algorithm should run in time \\(\\sum_{i=1}^{r}t_{i}\\ =\\ O(V^{3})\\), where \\(t_{i}\\) is the time to update the transitive closure upon inserting the \\(i\\)th edge. Prove that your algorithm attains this time bound.\n\n#### 23.2 Shortest paths in \\(\\epsilon\\)-dense graphs\n\nA graph \\(G=(V,E)\\) is \\(\\epsilon\\)_-dense_ if \\(|E|=\\Theta(V^{1+\\epsilon})\\) for some constant \\(\\epsilon\\) in the range \\(0<\\epsilon\\leq 1\\). \\(d\\)-ary min-heaps (see Problem 6-2 on page 179) provide a way to match the running times of Fibonacci-heap-based shortest-path algorithms on \\(\\epsilon\\)-dense graphs without using as complicated a data structure.\n\n_a._: What are the asymptotic running times for the operations Insert, Extract-Min, and Decrease-Key, as a function of \\(d\\) and the number \\(n\\) of elements in a \\(d\\)-ary min-heap? What are these running times if you choose \\(d=\\Theta(n^{\\alpha})\\) for some constant \\(0<\\alpha\\leq 1\\)? Compare these running times to the amortized costs of these operations for a Fibonacci heap.\n\n_b._: Show how to compute shortest paths from a single source on an \\(\\epsilon\\)-dense directed graph \\(G=(V,E)\\) with no negative-weight edges in \\(O(E)\\) time. (_Hint_: Pick \\(d\\) as a function of \\(\\epsilon\\).)\n\n_c._: Show how to solve the all-pairs shortest-paths problem on an \\(\\epsilon\\)-dense directed graph \\(G=(V,E)\\) with no negative-weight edges in \\(O(VE)\\) time.\n\n_d._: Show how to solve the all-pairs shortest-paths problem in \\(O(VE)\\) time on an \\(\\epsilon\\)-dense directed graph \\(G=(V,E)\\) that may have negative-weight edges but has no negative-weight cycles.\n\n## Chapter notes\n\nLawler [276] has a good discussion of the all-pairs shortest-paths problem. He attributes the matrix-multiplication algorithm to the folklore. The Floyd-Warshall algorithm is due to Floyd [144], who based it on a theorem of Warshall [450] that describes how to compute the transitive closure of boolean matrices. Johnson's algorithm is taken from [238].\n\nSeveral researchers have given improved algorithms for computing shortest paths via matrix multiplication. Fredman [153] shows how to solve the all-pairs shortest paths problem using \\(O(V^{5/2})\\) comparisons between sums of edge weights and obtains an algorithm that runs in \\(O(V^{3}(\\lg\\lg V/\\lg V)^{1/3})\\) time, which is slightly better than the running time of the Floyd-Warshall algorithm. This bound has been improved several times, and the fastest algorithm is now by Williams [457], with a running time of \\(O(V^{\\,3}/2^{\\Omega(\\lg^{1/2}V)})\\).\n\nAnother line of research demonstrates how to apply algorithms for fast matrix multiplication (see the chapter notes for Chapter 4) to the all-pairs shortest paths problem. Let \\(O(n^{\\omega})\\) be the running time of the fastest algorithm for multiplying two \\(n\\times n\\) matrices. Galil and Margalit [170, 171] and Seidel [403] designed algorithms that solve the all-pairs shortest paths problem in undirected, unweighted graphs in \\((V^{\\omega}\\,p(V))\\) time, where \\(p(n)\\) denotes a particular function that is poly-logarithmically bounded in \\(n\\). In dense graphs, these algorithms are faster than the \\(O(VE)\\) time needed to perform \\(|V|\\) breadth-first searches. Several researchers have extended these results to give algorithms for solving the all-pairs shortest paths problem in undirected graphs in which the edge weights are integers in the range \\(\\{1,2,\\ldots,W\\}\\). The asymptotically fastest such algorithm, by Shoshan and Zwick [410], runs in \\(O(W\\,V^{\\omega}\\,p(V\\,W))\\) time. In directed graphs, the best algorithm to date is due to Zwick [467] and runs in \\(\\widetilde{O}(W^{1/(4-\\omega)}\\,V^{2+1/(4-\\omega)})\\) time.\n\nKarger, Koller, and Phillips [244] and independently McGeoch [320] have given a time bound that depends on \\(E^{*}\\), the set of edges in \\(E\\) that participate in some shortest path. Given a graph with nonnegative edge weights, their algorithms run in \\(O(VE^{*}+V^{2}\\lg V)\\) time and improve upon running Dijkstra's algorithm \\(|V|\\) times when \\(|E^{*}|=o(E)\\). Pettie [355] uses an approach based on component hierarchies to achieve a running time of \\(O(VE+V^{2}\\lg\\lg V)\\), and the same running time is also achieved by Hagerup [205].\n\nBaswana, Hariharan, and Sen [37] examined decremental algorithms, which allow a sequence of intermixed edge deletions and queries, for maintaining all-pairs shortest paths and transitive-closure information. When a path exists, their randomized transitive-closure algorithm can fail to report it with probability \\(1/n^{c}\\) for an arbitrary \\(c>0\\). The query times are \\(O(1)\\) with high probability. For transitive closure, the amortized time for each update is \\(O(V^{\\,4/3}\\lg^{1/3}V)\\). By comparison, Problem 23-1, in which edges are inserted, asks for an incremental algorithm. For all-pairs shortest paths, the update times depend on the queries. For queries just giving the shortest-path weights, the amortized time per update is \\(O(V^{\\,3}/E\\lg^{2}V)\\). To report the actual shortest path, the amortized update time is \\(\\min\\big{\\{}O(V^{\\,3/2}\\,\\sqrt{\\lg V}),\\,O(V^{\\,3}/E\\lg^{2}V)\\big{\\}}\\). Demetrescu and Italiano [111] showed how to handle update and query operations when edges are both inserted and deleted, as long as the range of edge weights is bounded.\n\nAho, Hopcroft, and Ullman [5] defined an algebraic structure known as a \"closed semiring,\" which serves as a general framework for solving path problems in directed graphs. Both the Floyd-Warshall algorithm and the transitive-closure algorithm from Section 23.2 are instantiations of an all-pairs algorithm based on closed semirings. Maggs and Plotkin [309] showed how to find minimum spanning trees using a closed semiring.\n\nJust as you can model a road map as a directed graph in order to find the shortest path from one point to another, you can also interpret a directed graph as a \"flow network\" and use it to answer questions about material flows. Imagine a material coursing through a system from a source, where the material is produced, to a sink, where it is consumed. The source produces the material at some steady rate, and the sink consumes the material at the same rate. The \"flow\" of the material at any point in the system is intuitively the rate at which the material moves. Flow networks can model many problems, including liquids flowing through pipes, parts through assembly lines, current through electrical networks, and information through communication networks.\n\nYou can think of each directed edge in a flow network as a conduit for the material. Each conduit has a stated capacity, given as a maximum rate at which the material can flow through the conduit, such as 200 gallons of liquid per hour through a pipe or 20 amperes of electrical current through a wire. Vertices are conduit junctions, and other than the source and sink, material flows through the vertices without collecting in them. In other words, the rate at which material enters a vertex must equal the rate at which it leaves the vertex. We call this property \"flow conservation,\" and it is equivalent to Kirchhoff's current law when the material is electrical current.\n\nThe goal of the maximum-flow problem is to compute the greatest rate for shipping material from the source to the sink without violating any capacity constraints. It is one of the simplest problems concerning flow networks and, as we shall see in this chapter, this problem can be solved by efficient algorithms. Moreover, other network-flow problems are solvable by adapting the basic techniques used in maximum-flow algorithms.\n\nThis chapter presents two general methods for solving the maximum-flow problem. Section 24.1 formalizes the notions of flow networks and flows, formally defining the maximum-flow problem. Section 24.2 describes the classical method",
        "chapter": "Part VI Graph Algorithms",
        "section": "23 All-Pairs Shortest Paths",
        "subsection": "Chapter notes",
        "subsubsection": "N/A"
    },
    {
        "content": "of Ford and Fulkerson for finding maximum flows. We finish up with a simple application of this method, finding a maximum matching in an undirected bipartite graph, in Section 24.3. (Section 25.1 will give a more efficient algorithm that is specifically designed to find a maximum matching in a bipartite graph.)\n\n#### Flow networks\n\nThis section gives a graph-theoretic definition of flow networks, discusses their properties, and defines the maximum-flow problem precisely. It also introduces some helpful notation.\n\n##### Flow networks and flows\n\nA _flow network_\\(G=(V,E)\\) is a directed graph in which each edge \\((u,v)\\in E\\) has a nonnegative _capacity_\\(c(u,v)\\geq 0\\). We further require that if \\(E\\) contains an edge \\((u,v)\\), then there is no edge \\((v,u)\\) in the reverse direction. (We'll see shortly how to work around this restriction.) If \\((u,v)\\notin E\\), then for convenience we define \\(c(u,v)=0\\), and we disallow self-loops. Each flow network contains two distinguished vertices: a _source_\\(s\\) and a _sink_\\(t\\). For convenience, we assume that each vertex lies on some path from the source to the sink. That is, for each vertex \\(v\\in V\\), the flow network contains a path \\(s\\leadsto v\\leadsto t\\). Because each vertex other than \\(s\\) has at least one entering edge, we have \\(|E|\\geq|V|-1\\). Figure 24.1 shows an example of a flow network.\n\nFigure 24.1: **(a)** A flow network \\(G=(V,E)\\) for the Lucky Puck Company\u2019s trucking problem. The Vancouver factory is the source \\(s\\), and the Winnipeg warehouse is the sink \\(t\\). The company ships pucks through intermediate cities, but only \\(c(u,v)\\) crates per day can go from city \\(u\\) to city \\(v\\). Each edge is labeled with its capacity. **(b)** A flow \\(f\\) in \\(G\\) with value \\(|f|=19\\). Each edge \\((u,v)\\) is labeled by \\(f(u,v)/c(u,v)\\). The slash notation merely separates the flow and capacity and does not indicate division.\n\nWe are now ready to define flows more formally. Let \\(G=(V,E)\\) be a flow network with a capacity function \\(c\\). Let \\(s\\) be the source of the network, and let \\(t\\) be the sink. A _flow_ in \\(G\\) is a real-valued function \\(f:V\\times V\\to\\mathbb{R}\\) that satisfies the following two properties:\n\n**Capacity constraint:**: For all \\(u,v\\in V\\), we require\n\n\\[0\\leq f(u,v)\\leq c(u,v)\\.\\]\n\nThe flow from one vertex to another must be nonnegative and must not exceed the given capacity.\n**Flow conservation:**: For all \\(u\\in V-\\{s,t\\}\\), we require\n\n\\[\\sum_{v\\in V}f(v,u)=\\sum_{v\\in V}f(u,v)\\.\\]\n\nThe total flow into a vertex other than the source or sink must equal the total flow out of that vertex\\(-\\)informally, \"flow in equals flow out.\"\n\nWhen \\((u,v)\\notin E\\), there can be no flow from \\(u\\) to \\(v\\), and \\(f(u,v)=0\\).\n\nWe call the nonnegative quantity \\(f(u,v)\\) the flow from vertex \\(u\\) to vertex \\(v\\). The _value_\\(|f|\\) of a flow \\(f\\) is defined as\n\n\\[|f|=\\sum_{v\\in V}f(s,v)-\\sum_{v\\in V}f(v,s)\\, \\tag{24.1}\\]\n\nthat is, the total flow out of the source minus the flow into the source. (Here, the \\(|\\cdot|\\) notation denotes flow value, not absolute value or cardinality.) Typically, a flow network does not have any edges into the source, and the flow into the source, given by the summation \\(\\sum_{v\\in V}f(v,s)\\), is \\(0\\). We include it, however, because when we introduce residual networks later in this chapter, the flow into the source can be positive. In the _maximum-flow problem_, the input is a flow network \\(G\\) with source \\(s\\) and sink \\(t\\), and the goal is to find a flow of maximum value.\n\n### An example of flow\n\nA flow network can model the trucking problem shown in Figure 24.1(a). The Lucky Puck Company has a factory (source \\(s\\)) in Vancouver that manufactures hockey pucks, and it has a warehouse (sink \\(t\\)) in Winnipeg that stocks them. Lucky Puck leases space on trucks from another firm to ship the pucks from the factory to the warehouse. Because the trucks travel over specified routes (edges) between cities (vertices) and have a limited capacity, Lucky Puck can ship at most \\(c(u,v)\\) crates per day between each pair of cities \\(u\\) and \\(v\\) in Figure 24.1(a). Lucky Puck\n\n#### Flow networks\n\nIn this section we will discuss the flow network for the network. In this section we will discuss the flow network for the network. In Section 2.2 we will discuss the flow network for the network. In Section 2.3 we will discuss the flow network for the network. In Section 2.4 we will discuss the flow network for the network. In Section 2.5 we will discuss the flow network for the network. In Section 2.6 we will discuss the flow network for the network. In Section 2.7 we will discuss the flow network for the network. In Section 2.8 we will discuss the flow network for the network. In Section 2.9 we will discuss the flow network for the network. In Section 2.10 we will discuss the flow network for the network. In Section 2.11 we will discuss the flow network for the network. In Section 2.12 we will discuss the flow network for the network. In Section 2.13 we will discuss the flow network for the network. In Section 2.14 we will discuss the flow network for the network. In Section 2.15 we will discuss the flow network for the network. In Section 2.16 we will discuss the flow network for the network. In Section 2.17 we will discuss the flow network for the network. In Section 2.18 we will discuss the flow network for the network. In Section 2.19 we will discuss the flow network for the network. In Section 2.11 we will discuss the flow network for the network. In Section 2.12 we will discuss the flow network for the network. In Section 2.13 we will discuss the flow network for the network. In Section 2.14 we will discuss the flow network for the network. In Section 2.15 we will discuss the flow network for the network. In Section 2.16 we will discuss the flow network for the network. In Section 2.17 we will discuss the flow network for the network. In Section 2.18 we will discuss the flow network for the network. In Section 2.19 we will discuss the flow network for the network. In Section 2.11 we will discuss the flow network for the network. In Section 2.12 we will discuss the flow network for the network. In Section 2.13 we will discuss the flow network for the network. In Section 2.14 we will discuss the flow network for the network. In Section 2.15 we will discuss the flow network for the network. In Section 2.16 we will discuss the flow network for the network. In Section 2.17 we will discuss the flow network for the network. In Section 2.18 we will discuss the flow network for the network. In Section 2.19 we will discuss the flow network for the network. In Section 2.11 we will discuss the flow network for the network. In Section 2.11 we will discuss the flow network for the network. In Section 2.12 we will discuss the flow network for the network. In Section 2.13 we will discuss the flow network for the network. In Section 2.14 we will discuss the flow network for the network. In Section 2.15 we will discuss the flow network for the network. In Section 2.16 we will discuss the flow network for the network. In Section 2.17 we will discuss the flow network for the network. In Section 2.18 we will discuss the flow network for the network. In Section 2.19 we will discuss the flow network for the network. In Section 2.11 we will discuss the flow network for the network. In Section 2.11 we will discuss the flow network for the network. In Section 2.12 we will discuss the flow network for the network. In Section 2.13 we will discuss the flow network for the network. In Section 2.14 we will discuss the flow network for the network. In Section 2.15 we will discuss the flow network for the network. In Section 2.16 we will discuss the flow network for the network. In Section 2.17 we will discuss the flow network for the network. In Section 2.18 we will discuss the flow network for the network. In Section 2.19 we will discuss the flow network for the network. In Section 2.11 we will discuss the flow network for the network. In Section 2.11 we will discuss the flow network for the network. In Section 2.12 we will discuss the flow network for the network. In Section 2.13 we will discuss the flow network for the network. In Section 2.14 we will discuss the flow network for the network. In Section 2.15 we will discuss the flow network for the network. In Section 2.16 we will discuss the flow network for the network. In Section 2.17 we will discuss the flow network for the network. In Section 2.18 we will discuss the flow network for the network. In Section 2.19 we will discuss the flow network for the network. In Section 2.11 we will discuss the flow network for the network. In Section 2.12 we will discuss the flow network for the network. In Section 2.12 we will discuss the flow network for the network. In Section 2.13 we will discuss the flow network for the network. In Section 2.14 we will discuss the flow network for the network. In Section 2.15 we will discuss the flow network for the network. In Section 2.16 we will discuss the flow network for the network. In Section 2.17 we will discuss the flow network for the network. In Section 2.18 we will discuss the flow network for the network. In Section 2.19 we will discuss the flow network for the network. In Section 2.19 we will discuss the flow network for the network. In Section 2.11 we will discuss the flow network for the network. In Section 2.11 we will discuss the flow network for the network. In Section 2.12 we will discuss the flow network for the network. In Section 2.12 we will discuss the flow network for the network. In Section 2.13 we will discuss the flow network for the network. In Section 2.14 we will discuss the flow network for the network. In Section 2.15 we will discuss the flow network for the network. In Section 2.16 we will discuss the flow network for the network. In Section 2.17 we will discuss the flow network for the network. In Section 2.18 we will discuss the flow network for the network. In Section 2.19 we will discuss the flow network for the network. In Section 2.19 we will discuss the flow network for the network. In Section 2.11 we will discuss the flow network for the network. In Section 2.12 we will discuss the flow network for the network. In Section 2.12 we will discuss the flow network for the network. In Section 2.13 we will discuss the flow network for the network. In Section 2.14 we will discuss the flow network for the network. In Section 2.15 we will discuss the flow network for the network. In Section 2.16 we will discuss the flow network for the network. In Section 2.17 we will discuss the flow network for the network. In Section 2.18 we will discuss the flow network for the network. In Section 2.19 we will discuss the flow network for the network. In Section 2.\n\nthe network, the reverse edge does not. As Exercise 24.1-1 asks you to prove, the resulting network is equivalent to the original one.\n\n##### Networks with multiple sources and sinks\n\nA maximum-flow problem may have several sources and sinks, rather than just one of each. The Lucky Puck Company, for example, might actually have a set of \\(m\\) factories \\(\\{s_{1},s_{2},\\ldots,s_{m}\\}\\) and a set of \\(n\\) warehouses \\(\\{t_{1},t_{2},\\ldots,t_{n}\\}\\), as shown in Figure 24.3(a). Fortunately, this problem is no harder than ordinary maximum flow.\n\nThe problem of determining a maximum flow in a network with multiple sources and multiple sinks reduces to an ordinary maximum-flow problem. Figure 24.3(b) shows how to convert the network from (a) to an ordinary flow network with only a single source and a single sink. Add a _supersource_\\(s\\) and add a directed edge \\((s,s_{i})\\) with capacity \\(c(s,s_{i})=\\infty\\) for each \\(i=1,2,\\ldots,m\\). Similarly, create a new _supersink_\\(t\\) and add a directed edge \\((t_{i},t)\\) with capacity \\(c(t_{i},t)=\\infty\\) for each \\(i=1,2,\\ldots,n\\). Intuitively, any flow in the network in (a) corresponds to a flow in the network in (b), and vice versa. The single supersource \\(s\\) provides as much flow as desired for the multiple sources \\(s_{i}\\), and the single supersink \\(t\\) likewise consumes as much flow as desired for the multiple sinks \\(t_{i}\\). Exercise 24.1-2 asks you to prove formally that the two problems are equivalent.\n\nFigure 24.3: Converting a multiple-source, multiple-sink maximum-flow problem into a problem with a single source and a single sink. **(a)** A flow network with three sources \\(S=\\{s_{1},s_{2},s_{3}\\}\\) and two sinks \\(T=\\{t_{1},t_{2}\\}\\). **(b)** An equivalent single-source, single-sink flow network. Add a supersource \\(s\\) and an edge with infinite capacity from \\(s\\) to each of the multiple sources. Also add a supersink \\(t\\) and an edge with infinite capacity from each of the multiple sinks to \\(t\\).\n\n#### Exercises\n\n##### 24.1-1\n\nShow that splitting an edge in a flow network yields an equivalent network. More formally, suppose that flow network \\(G\\) contains edge \\((u,v)\\), and define a new flow network \\(G^{\\prime}\\) by creating a new vertex \\(x\\) and replacing \\((u,v)\\) by new edges \\((u,x)\\) and \\((x,v)\\) with \\(c(u,x)=c(x,v)=c(u,v)\\). Show that a maximum flow in \\(G^{\\prime}\\) has the same value as a maximum flow in \\(G\\).\n\n##### 24.1-2\n\nExtend the flow properties and definitions to the multiple-source, multiple-sink problem. Show that any flow in a multiple-source, multiple-sink flow network corresponds to a flow of identical value in the single-source, single-sink network obtained by adding a supersource and a supersink, and vice versa.\n\n##### 24.1-3\n\nSuppose that a flow network \\(G=(V,E)\\) violates the assumption that the network contains a path \\(s\\leadsto v\\leadsto t\\) for all vertices \\(v\\in V\\). Let \\(u\\) be a vertex for which there is no path \\(s\\leadsto u\\leadsto t\\). Show that there must exist a maximum flow \\(f\\) in \\(G\\) such that \\(f(u,v)=f(v,u)=0\\) for all vertices \\(v\\in V\\).\n\n##### 24.1-4\n\nLet \\(f\\) be a flow in a network, and let \\(\\alpha\\) be a real number. The _scalar flow product_, denoted \\(\\alpha f\\), is a function from \\(V\\times V\\) to \\(\\mathbb{R}\\) defined by\n\n\\[(\\alpha f)(u,v)=\\alpha\\cdot f(u,v)\\.\\]\n\nProve that the flows in a network form a _convex set_. That is, show that if \\(f_{1}\\) and \\(f_{2}\\) are flows, then so is \\(\\alpha f_{1}+(1-\\alpha)f_{2}\\) for all \\(\\alpha\\) in the range \\(0\\leq\\alpha\\leq 1\\).\n\n##### 24.1-5\n\nState the maximum-flow problem as a linear-programming problem.\n\n##### 24.1-6\n\nProfessor Adam has two children who, unfortunately, dislike each other. The problem is so severe that not only do they refuse to walk to school together, but in fact each one refuses to walk on any block that the other child has stepped on that day. The children have no problem with their paths crossing at a corner. Fortunately both the professor's house and the school are on corners, but beyond that he is not sure if it is going to be possible to send both of his children to the same school. The professor has a map of his town. Show how to formulate the problem of determining whether both his children can go to the same school as a maximum-flow problem.\n\n#### 24.1-7\n\nSuppose that, in addition to edge capacities, a flow network has _vertex capacities_. That is each vertex \\(v\\) has a limit \\(l(v)\\) on how much flow can pass through \\(v\\). Show how to transform a flow network \\(G=(V,E)\\) with vertex capacities into an equivalent flow network \\(G^{\\prime}=(V^{\\prime},E^{\\prime})\\) without vertex capacities, such that a maximum flow in \\(G^{\\prime}\\) has the same value as a maximum flow in \\(G\\). How many vertices and edges does \\(G^{\\prime}\\) have?\n\n### 24.2 The Ford-Fulkerson method\n\nThis section presents the Ford-Fulkerson method for solving the maximum-flow problem. We call it a \"method\" rather than an \"algorithm\" because it encompasses several implementations with differing running times. The Ford-Fulkerson method depends on three important ideas that transcend the method and are relevant to many flow algorithms and problems: residual networks, augmenting paths, and cuts. These ideas are essential to the important max-flow min-cut theorem (Theorem 24.6), which characterizes the value of a maximum flow in terms of cuts of the flow network. We end this section by presenting one specific implementation of the Ford-Fulkerson method and analyzing its running time.\n\nThe Ford-Fulkerson method iteratively increases the value of the flow. It starts with \\(f(u,v)=0\\) for all \\(u,v\\in V\\), giving an initial flow of value \\(0\\). Each iteration increases the flow value in \\(G\\) by finding an \"augmenting path\" in an associated \"residual network\" \\(G_{f}\\). The edges of the augmenting path in \\(G_{f}\\) indicate on which edges in \\(G\\) to update the flow in order to increase the flow value. Although each iteration of the Ford-Fulkerson method increases the value of the flow, we'll see that the flow on any particular edge of \\(G\\) may increase or decrease. Although it might seem counterintuitive to decrease the flow on an edge, doing so may enable flow to increase on other edges, allowing more flow to travel from the source to the sink. The Ford-Fulkerson method, given in the procedure Ford-Fulkerson-Method, repeatedly augments the flow until the residual network has no more augmenting paths. The max-flow min-cut theorem shows that upon termination, this process yields a maximum flow.",
        "chapter": "Part VI Graph Algorithms",
        "section": "24 Maximum Flow",
        "subsection": "24.1 Flow networks",
        "subsubsection": "N/A"
    },
    {
        "content": "#### 24.1-7\n\nSuppose that, in addition to edge capacities, a flow network has _vertex capacities_. That is each vertex \\(v\\) has a limit \\(l(v)\\) on how much flow can pass through \\(v\\). Show how to transform a flow network \\(G=(V,E)\\) with vertex capacities into an equivalent flow network \\(G^{\\prime}=(V^{\\prime},E^{\\prime})\\) without vertex capacities, such that a maximum flow in \\(G^{\\prime}\\) has the same value as a maximum flow in \\(G\\). How many vertices and edges does \\(G^{\\prime}\\) have?\n\n### 24.2 The Ford-Fulkerson method\n\nThis section presents the Ford-Fulkerson method for solving the maximum-flow problem. We call it a \"method\" rather than an \"algorithm\" because it encompasses several implementations with differing running times. The Ford-Fulkerson method depends on three important ideas that transcend the method and are relevant to many flow algorithms and problems: residual networks, augmenting paths, and cuts. These ideas are essential to the important max-flow min-cut theorem (Theorem 24.6), which characterizes the value of a maximum flow in terms of cuts of the flow network. We end this section by presenting one specific implementation of the Ford-Fulkerson method and analyzing its running time.\n\nThe Ford-Fulkerson method iteratively increases the value of the flow. It starts with \\(f(u,v)=0\\) for all \\(u,v\\in V\\), giving an initial flow of value \\(0\\). Each iteration increases the flow value in \\(G\\) by finding an \"augmenting path\" in an associated \"residual network\" \\(G_{f}\\). The edges of the augmenting path in \\(G_{f}\\) indicate on which edges in \\(G\\) to update the flow in order to increase the flow value. Although each iteration of the Ford-Fulkerson method increases the value of the flow, we'll see that the flow on any particular edge of \\(G\\) may increase or decrease. Although it might seem counterintuitive to decrease the flow on an edge, doing so may enable flow to increase on other edges, allowing more flow to travel from the source to the sink. The Ford-Fulkerson method, given in the procedure Ford-Fulkerson-Method, repeatedly augments the flow until the residual network has no more augmenting paths. The max-flow min-cut theorem shows that upon termination, this process yields a maximum flow.\n\nIn order to implement and analyze the Ford-Fulkerson method, we need to introduce several additional concepts.\n\n##### Residual networks\n\nIntuitively, given a flow network \\(G\\) and a flow \\(f\\), the residual network \\(G_{f}\\) consists of edges whose capacities represent how the flow can change on edges of \\(G\\). An edge of the flow network can admit an amount of additional flow equal to the edge's capacity minus the flow on that edge. If that value is positive, that edge goes into \\(G_{f}\\) with a \"residual capacity\" of \\(c_{f}(u,v)=c(u,v)-f(u,v)\\). The only edges of \\(G\\) that belong to \\(G_{f}\\) are those that can admit more flow. Those edges \\((u,v)\\) whose flow equals their capacity have \\(c_{f}(u,v)=0\\), and they do not belong to \\(G_{f}\\).\n\nYou might be surprised that the residual network \\(G_{f}\\) can also contain edges that are not in \\(G\\). As an algorithm manipulates the flow, with the goal of increasing the total flow, it might need to decrease the flow on a particular edge in order to increase the flow elsewhere. In order to represent a possible decrease in the positive flow \\(f(u,v)\\) on an edge in \\(G\\), the residual network \\(G_{f}\\) contains an edge \\((v,u)\\) with residual capacity \\(c_{f}(v,u)=f(u,v)-\\)that is, an edge that can admit flow in the opposite direction to \\((u,v)\\), at most canceling out the flow on \\((u,v)\\). These reverse edges in the residual network allow an algorithm to send back flow it has already sent along an edge. Sending flow back along an edge is equivalent to _decreasing_ the flow on the edge, which is a necessary operation in many algorithms.\n\nMore formally, for a flow network \\(G=(V,E)\\) with source \\(s\\), sink \\(t\\), and a flow \\(f\\), consider a pair of vertices \\(u,v\\in V\\). We define the _residual capacity_\\(c_{f}(u,v)\\) by\n\n\\[c_{f}(u,v)=\\left\\{\\begin{array}{ll}c(u,v)-f(u,v)&\\mbox{if $(u,v)\\in E$,}\\\\ f(v,u)&\\mbox{if $(v,u)\\in E$,}\\\\ 0&\\mbox{otherwise.}\\end{array}\\right. \\tag{24.2}\\]\n\nIn a flow network, \\((u,v)\\in E\\) implies \\((v,u)\\notin E\\), and so exactly one case in equation (24.2) applies to each ordered pair of vertices.\n\nAs an example of equation (24.2), if \\(c(u,v)=16\\) and \\(f(u,v)=11\\), then \\(f(u,v)\\) can increase by up to \\(c_{f}(u,v)=5\\) units before exceeding the capacity constraint on edge \\((u,v)\\). Alternatively, up to 11 units of flow can return from \\(v\\) to \\(u\\), so that \\(c_{f}(v,u)=11\\).\n\nGiven a flow network \\(G=(V,E)\\) and a flow \\(f\\), the _residual network_ of \\(G\\) induced by \\(f\\) is \\(G_{f}=(V,E_{f})\\), where\n\n\\[E_{f}=\\left\\{(u,v)\\in V\\times V:c_{f}(u,v)>0\\right\\}. \\tag{24.3}\\]That is, as promised above, each edge of the residual network, or _residual edge_, can admit a flow that is greater than 0. Figure 24.4(a) repeats the flow network \\(G\\) and flow \\(f\\) of Figure 24.1(b), and Figure 24.4(b) shows the corresponding residual network \\(G_{f}\\). The edges in \\(E_{f}\\) are either edges in \\(E\\) or their reversals, and thus\n\n\\[|E_{f}|\\leq 2\\ |\\ E|\\enspace.\\]\n\nObserve that the residual network \\(G_{f}\\) is similar to a flow network with capacities given by \\(c_{f}\\). It does not satisfy the definition of a flow network, however, because it could contain antiparallel edges. Other than this difference, a residual network has the same properties as a flow network, and we can define a flow in the residual network as one that satisfies the definition of a flow, but with respect to capacities \\(c_{f}\\) in the residual network \\(G_{f}\\).\n\nA flow in a residual network provides a roadmap for adding flow to the original flow network. If \\(f\\) is a flow in \\(G\\) and \\(f^{\\prime}\\) is a flow in the corresponding residual network \\(G_{f}\\), we define \\(f\\uparrow f^{\\prime}\\), the _augmentation_ of flow \\(f\\) by \\(f^{\\prime}\\), to be a function from \\(V\\times V\\) to \\(\\mathbb{R}\\), defined by\n\nFigure 24.4: **(a)** The flow network \\(G\\) and flow \\(f\\) of Figure 24.1(b). **(b)** The residual network \\(G_{f}\\) with augmenting path \\(p\\), having residual capacity \\(c_{f}(p)=c_{f}(v_{2},v_{3})=4\\), in blue. Edges with residual capacity equal to 0, such as \\((v_{1},v_{3})\\), are not shown, a convention we follow in the remainder of this section. **(c)** The flow in \\(G\\) that results from augmenting along path \\(p\\) by its residual capacity 4. Edges carrying no flow, such as \\((v_{3},v_{2})\\), are labeled only by their capacity, another convention we follow throughout. **(d)** The residual network induced by the flow in (c).\n\n#### The Ford-Fulkerson method\n\nThe intuition behind this definition follows the definition of the residual network. The flow on \\((u,v)\\) increases by \\(f^{\\prime}(u,v)\\), but decreases by \\(f^{\\prime}(v,u)\\) because pushing flow on the reverse edge in the residual network signifies decreasing the flow in the original network. Pushing flow on the reverse edge in the residual network is also known as _cancellation_. For example, suppose that 5 crates of hockey pucks go from \\(u\\) to \\(v\\) and 2 crates go from \\(v\\) to \\(u\\). That is equivalent (from the perspective of the final result) to sending 3 crates from \\(u\\) to \\(v\\) and none from \\(v\\) to \\(u\\). Cancellation of this type is crucial for any maximum-flow algorithm.\n\nThe following lemma shows that augmenting a flow in \\(G\\) by a flow in \\(G_{f}\\) yields a new flow in \\(G\\) with a greater flow value.\n\n**Lemma 24.1**: _Let \\(G=(V,E)\\) be a flow network with source \\(s\\) and sink \\(t\\), and let \\(f\\) be a flow in \\(G\\). Let \\(G_{f}\\) be the residual network of \\(G\\) induced by \\(f\\), and let \\(f^{\\prime}\\) be a flow in \\(G_{f}\\). Then the function \\(f\\uparrow f^{\\prime}\\) defined in equation (24.4) is a flow in \\(G\\) with value \\(|f\\uparrow f^{\\prime}|=|f|+|f^{\\prime}|\\)._\n\n_Proof_ We first verify that \\(f\\uparrow f^{\\prime}\\) obeys the capacity constraint for each edge in \\(E\\) and flow conservation at each vertex in \\(V-\\{s,t\\}\\).\n\nFor the capacity constraint, first observe that if \\((u,v)\\in E\\), then \\(c_{f}(v,u)=f(u,v)\\). Because \\(f^{\\prime}\\) is a flow in \\(G_{f}\\), we have \\(f^{\\prime}(v,u)\\leq c_{f}(v,u)\\), which gives \\(f^{\\prime}(v,u)\\leq f(u,v)\\). Therefore,\n\n\\[(f\\uparrow f^{\\prime})(u,v) = f(u,v)+f^{\\prime}(u,v)-f^{\\prime}(v,u)\\quad\\mbox{(by equation (\\ref{eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq: eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq: eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq: eq:\\[\\sum_{v\\in V}(f\\uparrow f^{\\,\\prime})(u,v)-\\sum_{v\\in V}(f\\uparrow f ^{\\,\\prime})(v,u)\\] \\[=\\,\\sum_{v\\in V}f(u,v)-\\sum_{v\\in V}f(v,u)+\\sum_{v\\in V}f^{\\,\\prime} (u,v)-\\sum_{v\\in V}f^{\\,\\prime}(v,u). \\tag{24.5}\\]\n\nBecause we disallow antiparallel edges in \\(G\\) (but not in \\(G_{f}\\)), we know that for each vertex \\(u\\), there can be an edge \\((u,v)\\) or \\((v,u)\\) in \\(G\\), but never both. For a fixed vertex \\(u\\), define \\(V_{l}(u)=\\{v:(u,v)\\in E\\}\\) to be the set of vertices with edges in \\(G\\) leaving \\(u\\), and define \\(V_{e}(u)=\\{v:(v,u)\\in E\\}\\) to be the set of vertices with edges in \\(G\\) entering \\(u\\). We have \\(V_{l}(u)\\cup V_{e}(u)\\subseteq V\\) and, because \\(G\\) contains no antiparallel edges, \\(V_{l}(u)\\cap V_{e}(u)=\\emptyset\\). By the definition of flow augmentation in equation (24.4), only vertices \\(v\\) in \\(V_{l}(u)\\) can have positive \\((f\\uparrow f^{\\,\\prime})(u,v)\\), and only vertices \\(v\\) in \\(V_{e}(u)\\) can have positive \\((f\\uparrow f^{\\,\\prime})(v,u)\\). Starting from the left-hand side of equation (24.5), we use this fact and then reorder and group terms, giving\n\n\\[\\sum_{v\\in V} (f\\uparrow f^{\\,\\prime})\\left(u,v\\right)-\\sum_{v\\in V}\\left(f \\uparrow f^{\\,\\prime}\\right)\\left(v,u\\right)\\] \\[=\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\! \\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\! \\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\! \\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\! \\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\! \\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\! \\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\! \\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\! \\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\! \\!\\!\n\n### The Ford-Fulkerson method\n\n\\[|f\\uparrow f^{\\,\\prime}| = \\sum_{v\\in V}(f\\uparrow f^{\\,\\prime})(s,v)-\\sum_{v\\in V}(f\\uparrow f ^{\\,\\prime})(v,s)\\] \\[= \\sum_{v\\in V}f(s,v)-\\sum_{v\\in V}f(v,s)+\\sum_{v\\in V}f^{\\,\\prime}( s,v)-\\sum_{v\\in V}f^{\\,\\prime}(v,s)\\] \\[= \\,|f|+|f^{\\,\\prime}|\\,\\,.\\]\n\nFor flow conservation, observe that for any vertex \\(u\\) that is neither \\(s\\) nor \\(t\\), flow conservation for \\(f\\) and \\(f^{\\,\\prime}\\) means that the right-hand side of equation (24.5) is \\(0\\), and thus \\(\\sum_{v\\in V}(f\\uparrow f^{\\,\\prime})(u,v)=\\sum_{v\\in V}(f\\uparrow f^{\\,\\prime })(v,u)\\).\n\n#### Augmenting paths\n\nGiven a flow network \\(G=(V,E)\\) and a flow \\(f\\), an _augmenting path_\\(p\\) is a simple path from \\(s\\) to \\(t\\) in the residual network \\(G_{f}\\). By the definition of the residual network, the flow on an edge \\((u,v)\\) of an augmenting path may increase by up to \\(c_{f}(u,v)\\) without violating the capacity constraint on whichever of \\((u,v)\\) and \\((v,u)\\) belongs to the original flow network \\(G\\).\n\nThe blue path in Figure 24.4(b) is an augmenting path. Treating the residual network \\(G_{f}\\) in the figure as a flow network, the flow through each edge of this path can increase by up to \\(4\\) units without violating a capacity constraint, since the smallest residual capacity on this path is \\(c_{f}(v_{2},v_{3})=4\\). We call the maximum amount by which we can increase the flow on each edge in an augmenting path \\(p\\) the _residual capacity_ of \\(p\\), given by\n\n\\[c_{f}(p)=\\min\\left\\{c_{f}(u,v):(u,v)\\text{ is in }p\\right\\}\\,\\,.\\]\n\nThe following lemma, which Exercise 24.2-7 asks you to prove, makes the above argument more precise.\n\n**Lemma 24.2**: _Let \\(G=(V,E)\\) be a flow network, let \\(f\\) be a flow in \\(G\\), and let \\(p\\) be an augmenting path in \\(G_{f}\\). Define a function \\(f_{p}:V\\times V\\to\\mathbb{R}\\) by_\n\n\\[f_{p}(u,v)=\\left\\{\\begin{array}{ll}c_{f}(p)&\\text{if }(u,v)\\text{ is on }p\\,\\,,\\\\ 0&\\text{otherwise }.\\end{array}\\right. \\tag{24.7}\\]\n\n_Then, \\(f_{p}\\) is a flow in \\(G_{f}\\) with value \\(|f_{p}|=c_{f}(p)>0\\)._\n\nThe following corollary shows that augmenting \\(f\\) by \\(f_{p}\\) produces another flow in \\(G\\) whose value is closer to the maximum. Figure 24.4(c) shows the result of augmenting the flow \\(f\\) from Figure 24.4(a) by the flow \\(f_{p}\\) in Figure 24.4(b), and Figure 24.4(d) shows the ensuing residual network.\n\n**Corollary 24.3**: _Let \\(G=(V,E)\\) be a flow network, let \\(f\\) be a flow in \\(G\\), and let \\(p\\) be an augmenting path in \\(G_{f}\\). Let \\(f_{p}\\) be defined as in equation (24.7), and suppose that \\(f\\) is augmented by \\(f_{p}\\). Then the function \\(f\\uparrow f_{p}\\) is a flow in \\(G\\) with value \\(|f\\uparrow f_{p}|=|f|+|f_{p}|>|f|\\)._\n\n_Proof_ Immediate from Lemmas 24.1 and 24.2.\n\n### Cuts of flow networks\n\nThe Ford-Fulkerson method repeatedly augments the flow along augmenting paths until it has found a maximum flow. How do we know that when the algorithm terminates, it has actually found a maximum flow? The max-flow min-cut theorem, which we will prove shortly, tells us that a flow is maximum if and only if its residual network contains no augmenting path. To prove this theorem, though, we must first explore the notion of a cut of a flow network.\n\nA _cut_ (\\(S,T\\)) of flow network \\(G=(V,E)\\) is a partition of \\(V\\) into \\(S\\) and \\(T=V-S\\) such that \\(s\\in S\\) and \\(t\\in T\\). (This definition is similar to the definition of \"cut\" that we used for minimum spanning trees in Chapter 21, except that here we are cutting a directed graph rather than an undirected graph, and we insist that \\(s\\in S\\) and \\(t\\in T\\).) If \\(f\\) is a flow, then the _net flow_\\(f(S,T)\\) across the cut (\\(S,T\\)) is defined to be\n\n\\[f(S,T)=\\sum_{u\\in S}\\sum_{v\\in T}f(u,v)-\\sum_{u\\in S}\\sum_{v\\in T}f(v,u). \\tag{24.8}\\]\n\nThe _capacity_ of the cut (\\(S,T\\)) is\n\n\\[c(S,T)=\\sum_{u\\in S}\\sum_{v\\in T}c(u,v). \\tag{24.9}\\]\n\nA _minimum cut_ of a network is a cut whose capacity is minimum over all cuts of the network.\n\nYou probably noticed that the definitions of flow across a cut and capacity of a cut differ in that flow counts edges going in both directions across the cut, but capacity counts only edges going from the source side of the cut toward the sink side. This asymmetry is intentional and important. The reason for this difference will become apparent later in this section.\n\nFigure 24.5 shows the cut (\\(\\{s,v_{1},v_{2}\\},\\{v_{3},v_{4},t\\}\\)) in the flow network of Figure 24.1(b). The net flow across this cut is\n\n\\[f(v_{1},v_{3})+f(v_{2},v_{4})-f(v_{3},v_{2}) = 12+11-4\\] \\[= 19\\,\\]\n\nand the capacity of this cut is\n\n### The Ford-Fulkerson method\n\nThe following lemma shows that, for a given flow \\(f\\), the net flow across any cut is the same, and it equals \\(|f\\,|\\), the value of the flow.\n\n**Lemma 24.4**: \\(\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\! \\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\! \\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\! \\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\! \\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\! \\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\! \\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\! \\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\! \\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\! \\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\! \\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\! \\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\! \\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\! \\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\! \\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\! \\!\\!Because \\(V=S\\cup T\\) and \\(S\\cap T=\\emptyset\\), splitting each summation over \\(V\\) into summations over \\(S\\) and \\(T\\) gives\n\n\\[|f| = \\sum_{v\\in S}\\sum_{u\\in S}f(u,v)+\\sum_{v\\in T}\\sum_{u\\in S}f(u,v)- \\sum_{v\\in S}\\sum_{u\\in S}f(v,u)-\\sum_{v\\in T}\\sum_{u\\in S}f(v,u)\\] \\[= \\sum_{v\\in T}\\sum_{u\\in S}f(u,v)-\\sum_{v\\in T}\\sum_{u\\in S}f(v,u)\\] \\[\\qquad\\qquad+\\left(\\sum_{v\\in S}\\sum_{u\\in S}f(u,v)-\\sum_{v\\in S }\\sum_{u\\in S}f(v,u)\\right)\\.\\]\n\nThe two summations within the parentheses are actually the same, since for all vertices \\(x\\), \\(y\\in S\\), the term \\(f(x,y)\\) appears once in each summation. Hence, these summations cancel, yielding\n\n\\[|f| = \\sum_{u\\in S}\\sum_{v\\in T}f(u,v)-\\sum_{u\\in S}\\sum_{v\\in T}f(v,u)\\] \\[= f(S,T)\\.\\]\n\nA corollary to Lemma 24.4 shows how cut capacities bound the value of a flow.\n\n**Corollary 24.5**: _The value of any flow \\(f\\) in a flow network \\(G\\) is bounded from above by the capacity of any cut of \\(G\\)._\n\nProofLet \\((S,T)\\) be any cut of \\(G\\) and let \\(f\\) be any flow. By Lemma 24.4 and the capacity constraint,\n\n\\[|f| = f(S,T)\\] \\[= \\sum_{u\\in S}\\sum_{v\\in T}f(u,v)-\\sum_{u\\in S}\\sum_{v\\in T}f(v,u)\\] \\[\\leq \\sum_{u\\in S}\\sum_{v\\in T}f(u,v)\\] \\[\\leq \\sum_{u\\in S}\\sum_{v\\in T}c(u,v)\\] \\[= c(S,T)\\.\\]\n\nCorollary 24.5 yields the immediate consequence that the value of a maximum flow in a network is bounded from above by the capacity of a minimum cut of the network. The important max-flow min-cut theorem, which we now state and prove, says that the value of a maximum flow is in fact equal to the capacity of a minimum cut.\n\n_Theorem 24.6_ (_Max-flow min-cut theorem_):\n\nIf \\(f\\) is a flow in a flow network \\(G=(V,E)\\) with source \\(s\\) and sink \\(t\\), then the following conditions are equivalent:\n\n1. \\(f\\) is a maximum flow in \\(G\\).\n2. The residual network \\(G_{f}\\) contains no augmenting paths.\n3. \\(|f|=c(S,T)\\) for some cut \\((S,T)\\) of \\(G\\).\n\n_Proof_ (1) \\(\\Rightarrow\\) (2): Suppose for the sake of contradiction that \\(f\\) is a maximum flow in \\(G\\) but that \\(G_{f}\\) has an augmenting path \\(p\\). Then, by Corollary 24.3, the flow found by augmenting \\(f\\) by \\(f_{p}\\), where \\(f_{p}\\) is given by equation (24.7), is a flow in \\(G\\) with value strictly greater than \\(|f|\\), contradicting the assumption that \\(f\\) is a maximum flow.\n\n(2) \\(\\Rightarrow\\) (3): Suppose that \\(G_{f}\\) has no augmenting path, that is, that \\(G_{f}\\) contains no path from \\(s\\) to \\(t\\). Define\n\n\\(S=\\{v\\in V:\\) there exists a path from \\(s\\) to \\(v\\) in \\(G_{f}\\}\\)\n\nand \\(T=V-S\\). The partition \\((S,T)\\) is a cut: we have \\(s\\in S\\) trivially and \\(t\\notin S\\) because there is no path from \\(s\\) to \\(t\\) in \\(G_{f}\\). Now consider a pair of vertices \\(u\\in S\\) and \\(v\\in T\\). If \\((u,v)\\in E\\), we must have \\(f(u,v)=c(u,v)\\), since otherwise \\((u,v)\\in E_{f}\\), which would place \\(v\\) in set \\(S\\). If \\((v,u)\\in E\\), we must have \\(f(v,u)=0\\), because otherwise \\(c_{f}(u,v)=f(v,u)\\) would be positive and we would have \\((u,v)\\in E_{f}\\), which again would place \\(v\\) in \\(S\\). Of course, if neither \\((u,v)\\) nor \\((v,u)\\) belongs to \\(E\\), then \\(f(u,v)=f(v,u)=0\\). We thus have\n\n\\[f(S,T) = \\sum_{u\\in S}\\sum_{v\\in T}f(u,v)-\\sum_{v\\in T}\\sum_{u\\in S}f(v,u)\\] \\[= \\sum_{u\\in S}\\sum_{v\\in T}c(u,v)-\\sum_{v\\in T}\\sum_{u\\in S}0\\] \\[= c(S,T)\\.\\]\n\nBy Lemma 24.4, therefore, \\(|f|=f(S,T)=c(S,T)\\).\n\n(3) \\(\\Rightarrow\\) (1): By Corollary 24.5, \\(|f|\\leq c(S,T)\\) for all cuts \\((S,T)\\). The condition \\(|f|=c(S,T)\\) thus implies that \\(f\\) is a maximum flow.\n\n### The basic Ford-Fulkerson algorithm\n\nEach iteration of the Ford-Fulkerson method finds _some_ augmenting path \\(p\\) and uses \\(p\\) to modify the flow \\(f\\). As Lemma 24.2 and Corollary 24.3 suggest, replacing \\(f\\) by \\(f\\uparrow f_{p}\\) produces a new flow whose value is \\(|f|+|f_{p}|\\). The procedure Ford-Fulkerson on the next page implements the method by updating the flow attribute \\((u,v).f\\) for each edge \\((u,v)\\in E\\).1 It assumes implicitly that \\((u,v).f=0\\) if \\((u,v)\\notin E\\). The procedure also assumes that the capacities \\(c(u,v)\\) come with the flow network, and that \\(c(u,v)=0\\) if \\((u,v)\\notin E\\). The procedure computes the residual capacity \\(c_{f}(u,v)\\) in accordance with the formula (24.2). The expression \\(c_{f}(p)\\) in the code is just a temporary variable that stores the residual capacity of the path \\(p\\).\n\nFootnote 1: Recall from Section 20.1 that we represent an attribute \\(f\\) for edge \\((u,v)\\) with the same style of notation\\(-\\)\\((u,v).f-\\)that we use for an attribute of any other object.\n\n\\[\\textsc{Ford-Fulkerson}(G,s,t)\\] \\[\\textsc{for each edge }(u,v)\\in G.E\\] \\[\\textsc{ }(u,v).f = 0\\] \\[\\\n\n### 24.2 The Ford-Fulkerson method\n\nFigure 24.6: The execution of the basic Ford-Fulkerson algorithm. **(a)\u2013(e)** Successive iterations of the **while** loop. The left side of each part shows the residual network \\(G_{f}\\) from line 3 with a blue augmenting path \\(p\\). The right side of each part shows the new flow \\(f\\) that results from augmenting \\(f\\) by \\(f_{p}\\). The residual network in (a) is the input flow network \\(G\\). **(f)** The residual network at the last **while** loop test. It has no augmenting paths, and the flow \\(f\\) shown in (e) is therefore a maximum flow. The value of the maximum flow found is 23.\n\npolynomial time. Before proving this result, we obtain a simple bound for the case in which all capacities are integers and the algorithm finds any augmenting path.\n\nIn practice, the maximum-flow problem often arises with integer capacities. If the capacities are rational numbers, an appropriate scaling transformation can make them all integers. If \\(f^{*}\\) denotes a maximum flow in the transformed network, then a straightforward implementation of Ford-Fulkerson executes the **while** loop of lines 3-8 at most \\(|f^{*}|\\) times, since the flow value increases by at least 1 unit in each iteration.\n\nA good implementation should perform the work done within the **while** loop efficiently. It should represent the flow network \\(G=(V,E)\\) with the right data structure and find an augmenting path by a linear-time algorithm. Let's assume that the implementation keeps a data structure corresponding to a directed graph \\(G^{\\prime}=(V,E^{\\prime})\\), where \\(E^{\\prime}=\\{(u,v):(u,v)\\in E\\text{ or }(v,u)\\in E\\}\\). Edges in the network \\(G\\) are also edges in \\(G^{\\prime}\\), making it straightforward to maintain capacities and flows in this data structure. Given a flow \\(f\\) on \\(G\\), the edges in the residual network \\(G_{f}\\) consist of all edges \\((u,v)\\) of \\(G^{\\prime}\\) such that \\(c_{f}(u,v)>0\\), where \\(c_{f}\\) conforms to equation (24.2). The time to find a path in a residual network is therefore \\(O(V+E^{\\prime})=O(E)\\) using either depth-first search or breadth-first search. Each iteration of the **while** loop thus takes \\(O(E)\\) time, as does the initialization in lines 1-2, making the total running time of the Ford-Fulkerson algorithm \\(O(E\\mid\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\! \\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\! \\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\! \\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\! \\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\! \\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\! \\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\! \\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\! \\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\! \\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\! \\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\! \\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\! \\!\\!in Figure 24.7(a), the flow has value 1 after the first iteration. The resulting residual network appears in Figure 24.7(b). If the second iteration finds the augmenting path, as shown in Figure 24.7(b), the flow then has value 2. Figure 24.7(c) shows the resulting residual network. If the algorithm continues alternately choosing the augmenting paths \\(s\\to u\\to v\\to t\\) and \\(s\\to v\\to u\\to t\\), it performs a total of 2,000,000 augmentations, increasing the flow value by only 1 unit in each.\n\n### The Edmonds-Karp algorithm\n\nIn the example of Figure 24.7, the algorithm never chooses the augmenting path with the fewest edges. It should have. By using breadth-first search to find an augmenting path in the residual network, the algorithm runs in polynomial time, independent of the maximum flow value. We call the Ford-Fulkerson method so implemented the _Edmonds-Karp algorithm_.\n\nLet's now prove that the Edmonds-Karp algorithm runs in \\(O(VE^{2})\\) time. The analysis depends on the distances to vertices in the residual network \\(G_{f}\\). The notation \\(\\delta_{f}(u,v)\\) denotes the shortest-path distance from \\(u\\) to \\(v\\) in \\(G_{f}\\), where each edge has unit distance.\n\n_Lemma 24.7_: If the Edmonds-Karp algorithm is run on a flow network \\(G=(V,E)\\) with source \\(s\\) and sink \\(t\\), then for all vertices \\(v\\in V-\\{s,t\\}\\), the shortest-path distance \\(\\delta_{f}(s,v)\\) in the residual network \\(G_{f}\\) increases monotonically with each flow augmentation.\n\nProofWe'll suppose that a flow augmentation occurs that causes the shortest-path distance from \\(s\\) to some vertex \\(v\\in V-\\{s,t\\}\\) to decrease and then derive a contradiction. Let \\(f\\) be the flow just before an augmentation that decreases some shortest-path distance, and let \\(f^{\\prime}\\) be the flow just afterward. Let \\(v\\) be a vertex with the minimum \\(\\delta_{f^{\\prime}}(s,v)\\) whose distance was decreased by the augmentation, so that \\(\\delta_{f^{\\prime}}(s,v)<\\delta_{f}(s,v)\\). Let \\(p=s\\leadsto u\\to v\\) be a shortest path from \\(s\\) to \\(v\\) in \\(G_{f^{\\prime}}\\), so that \\((u,v)\\in E_{f^{\\prime}}\\) and\n\n\\[\\delta_{f^{\\prime}}(s,u)=\\delta_{f^{\\prime}}(s,v)-1. \\tag{24.11}\\]\n\nBecause of how we chose \\(v\\), we know that the distance of vertex \\(u\\) from the source \\(s\\) did not decrease, that is,\n\n\\[\\delta_{f^{\\prime}}(s,u)\\geq\\delta_{f}(s,u). \\tag{24.12}\\]\n\nWe claim that \\((u,v)\\not\\in E_{f}\\). Why? If we have \\((u,v)\\in E_{f}\\), then we also have \\[\\delta_{f}(s,v) \\leq\\ \\delta_{f}(s,u)\\ +\\ 1\\quad\\text{ (by Lemma \\ref{lem:ff}, the triangle inequality)}\\] \\[\\leq\\ \\delta_{f^{\\prime}}(s,u)\\ +\\ 1\\quad\\text{ (by inequality \\eqref{eq:ff})}\\] \\[=\\ \\delta_{f^{\\prime}}(s,v)\\qquad\\quad\\text{(by equation \\eqref{eq:ff})}\\,\\]\n\nwhich contradicts our assumption that \\(\\delta_{f^{\\prime}}(s,v)<\\delta_{f}(s,v)\\).\n\nHow can we have \\((u,v)\\notin E_{f}\\) and \\((u,v)\\in E_{f^{\\prime}}\\)? The augmentation must have increased the flow from \\(v\\) to \\(u\\), so that edge \\((v,u)\\) was in the augmenting path. The augmenting path was a shortest path from \\(s\\) to \\(t\\) in \\(G_{f}\\), and since any subpath of a shortest path is itself a shortest path, this augmenting path includes a shortest path from \\(s\\) to \\(u\\) in \\(G_{f}\\) that has \\((v,u)\\) as its last edge. Therefore,\n\n\\[\\delta_{f}(s,v) =\\ \\delta_{f}(s,u)-1\\] \\[\\leq\\ \\delta_{f^{\\prime}}(s,u)-1\\quad\\text{(by inequality \\eqref{eq:ff})}\\] \\[=\\ \\delta_{f^{\\prime}}(s,v)-2\\quad\\text{(by equation \\eqref{eq:ff})}\\,\\]\n\nso that \\(\\delta_{f^{\\prime}}(s,v)>\\delta_{f}(s,v)\\), contradicting our assumption that \\(\\delta_{f^{\\prime}}(s,v)<\\delta_{f}(s,v)\\). We conclude that our assumption that such a vertex \\(v\\) exists is incorrect. \n\nThe next theorem bounds the number of iterations of the Edmonds-Karp algorithm.\n\n**Theorem 24.8**: If the Edmonds-Karp algorithm is run on a flow network \\(G=(V,E)\\) with source \\(s\\) and sink \\(t\\), then the total number of flow augmentations performed by the algorithm is \\(O(VE)\\).\n\nProof.: We say that an edge \\((u,v)\\) in a residual network \\(G_{f}\\) is _critical_ on an augmenting path \\(p\\) if the residual capacity of \\(p\\) is the residual capacity of \\((u,v)\\), that is, if \\(c_{f}(p)=c_{f}(u,v)\\). After flow is augmented along an augmenting path, any critical edge on the path disappears from the residual network. Moreover, at least one edge on any augmenting path must be critical. We'll show that each of the \\(\\left|E\\right|\\) edges can become critical at most \\(\\left|V\\right|/2\\) times.\n\nLet \\(u\\) and \\(v\\) be vertices in \\(V\\) that are connected by an edge in \\(E\\). Since augmenting paths are shortest paths, when \\((u,v)\\) is critical for the first time, we have\n\n\\[\\delta_{f}(s,v)\\ =\\ \\delta_{f}(s,u)\\ +\\ 1\\.\\]\n\nOnce the flow is augmented, the edge \\((u,v)\\) disappears from the residual network. It cannot reappear later on another augmenting path until after the flow from \\(u\\) to \\(v\\) is decreased, which occurs only if \\((v,u)\\) appears on an augmenting path. If \\(f^{\\prime}\\) is the flow in \\(G\\) when this event occurs, then we have\n\n\\[\\delta_{f^{\\prime}}(s,u)\\ =\\ \\delta_{f^{\\prime}}(s,v)\\ +\\ 1\\.\\]\n\n### The Ford-Fulkerson method\n\nSince \\(\\delta_{f}(s,v)\\leq\\delta_{f^{\\prime}}(s,v)\\) by Lemma 24.7, we have\n\n\\[\\delta_{f^{\\prime}}(s,u) = \\delta_{f^{\\prime}}(s,v)\\ +\\ 1\\] \\[\\geq \\delta_{f}(s,v)\\ +\\ 1\\] \\[= \\delta_{f}(s,u)\\ +\\ 2\\.\\]\n\nConsequently, from the time \\((u,v)\\) becomes critical to the time when it next becomes critical, the distance of \\(u\\) from the source increases by at least 2. The distance of \\(u\\) from the source is initially at least 0. Because edge \\((u,v)\\) is on an augmenting path, and augmenting paths end at \\(t\\), we know that \\(u\\) cannot be \\(t\\), so that in any residual network that has a path from \\(s\\) to \\(u\\), the shortest such path has at most \\(\\left|V\\right|-2\\) edges. Thus, after the first time that \\((u,v)\\) becomes critical, it can become critical at most \\((\\left|V\\right|-2)/2=\\left|V\\right|/2-1\\) times more, for a total of at most \\(\\left|V\\right|/2\\) times. Since there are \\(O(E)\\) pairs of vertices that can have an edge between them in a residual network, the total number of critical edges during the entire execution of the Edmonds-Karp algorithm is \\(O(VE)\\). Each augmenting path has at least one critical edge, and hence the theorem follows.\n\nBecause each iteration of Ford-Fulkerson takes \\(O(E)\\) time when it uses breadth-first search to find the augmenting path, the total running time of the Edmonds-Karp algorithm is \\(O(VE^{2})\\).\n\n##### Exercises\n\n##### 24.2-1\n\nProve that the summations in equation (24.6) equal the summations on the right-hand side of equation (24.5).\n\n##### 24.2-2\n\nIn Figure 24.1(b), what is the net flow across the cut \\((\\left\\{s,v_{2},v_{4}\\right\\},\\left\\{v_{1},v_{3},t\\right\\})\\)? What is the capacity of this cut?\n\n##### 24.2-3\n\nShow the execution of the Edmonds-Karp algorithm on the flow network of Figure 24.1(a).\n\n##### 24.2-4\n\nIn the example of Figure 24.6, what is the minimum cut corresponding to the maximum flow shown? Of the augmenting paths appearing in the example, which one cancels flow?\n\n#### 24.2-5\n\nThe construction in Section 24.1 to convert a flow network with multiple sources and sinks into a single-source, single-sink network adds edges with infinite capacity. Prove that any flow in the resulting network has a finite value if the edges of the original network with multiple sources and sinks have finite capacity.\n\n#### 24.2-6\n\nSuppose that each source \\(s_{i}\\) in a flow network with multiple sources and sinks produces exactly \\(p_{i}\\) units of flow, so that \\(\\sum_{v\\in V}f(s_{i},v)=p_{i}\\). Suppose also that each sink \\(t_{j}\\) consumes exactly \\(q_{j}\\) units, so that \\(\\sum_{v\\in V}f(v,t_{j})=q_{j}\\), where \\(\\sum_{i}p_{i}=\\sum_{j}q_{j}\\). Show how to convert the problem of finding a flow \\(f\\) that obeys these additional constraints into the problem of finding a maximum flow in a single-source, single-sink flow network.\n\n#### 24.2-7\n\nProve Lemma 24.2.\n\n#### 24.2-8\n\nSuppose that we redefine the residual network to disallow edges into \\(s\\). Argue that the procedure Ford-Fulkerson still correctly computes a maximum flow.\n\n#### 24.2-9\n\nSuppose that both \\(f\\) and \\(f^{\\prime}\\) are flows in a flow network. Does the augmented flow \\(f\\uparrow f^{\\prime}\\) satisfy the flow conservation property? Does it satisfy the capacity constraint?\n\n#### 24.2-10\n\nShow how to find a maximum flow in a flow network \\(G=(V,E)\\) by a sequence of at most \\(|E|\\) augmenting paths. (_Hint:_ Determine the paths _after_ finding the maximum flow.)\n\n#### 24.2-11\n\nThe _edge connectivity_ of an undirected graph is the minimum number \\(k\\) of edges that must be removed to disconnect the graph. For example, the edge connectivity of a tree is 1, and the edge connectivity of a cyclic chain of vertices is 2. Show how to determine the edge connectivity of an undirected graph \\(G=(V,E)\\) by running a maximum-flow algorithm on at most \\(|V|\\) flow networks, each having \\(O(V+E)\\) vertices and \\(O(E)\\) edges.\n\n#### 24.2-12\n\nYou are given a flow network \\(G\\), where \\(G\\) contains edges entering the source \\(s\\). Let \\(f\\) be a flow in \\(G\\) with \\(|f|\\geq 0\\) in which one of the edges \\((v,s)\\) enteringthe source has \\(f(v,s)=1\\). Prove that there must exist another flow \\(f^{\\prime}\\) with \\(f^{\\prime}(v,s)=0\\) such that \\(|f|=|f^{\\prime}|\\). Give an \\(O(E)\\)-time algorithm to compute \\(f^{\\prime}\\), given \\(f\\) and assuming that all edge capacities are integers.\n\n_24.2-13_\n\nSuppose that you wish to find, among all minimum cuts in a flow network \\(G\\) with integer capacities, one that contains the smallest number of edges. Show how to modify the capacities of \\(G\\) to create a new flow network \\(G^{\\prime}\\) in which any minimum cut in \\(G^{\\prime}\\) is a minimum cut with the smallest number of edges in \\(G\\).\n\n### Maximum bipartite matching\n\nSome combinatorial problems can be cast as maximum-flow problems, such as the multiple-source, multiple-sink maximum-flow problem from Section 24.1. Other combinatorial problems seem on the surface to have little to do with flow networks, but they can in fact be reduced to maximum-flow problems. This section presents one such problem: finding a maximum matching in a bipartite graph. In order to solve this problem, we'll take advantage of an integrality property provided by the Ford-Fulkerson method. We'll also see how to use the Ford-Fulkerson method to solve the maximum-bipartite-matching problem on a graph \\(G=(V,E)\\) in \\(O(VE)\\) time. Section 25.1 will present an algorithm specifically designed to solve this problem.\n\n#### The maximum-bipartite-matching problem\n\nGiven an undirected graph \\(G=(V,E)\\), a _matching_ is a subset of edges \\(M\\subseteq E\\) such that for all vertices \\(v\\in V\\), at most one edge of \\(M\\) is incident on \\(v\\). We say that a vertex \\(v\\in V\\) is _matched_ by the matching \\(M\\) if some edge in \\(M\\) is incident on \\(v\\), and otherwise, \\(v\\) is _unmatched_. A _maximum matching_ is a matching of maximum cardinality, that is, a matching \\(M\\) such that for any matching \\(M^{\\prime}\\), we have \\(|M|\\geq|M^{\\prime}|\\). In this section, we restrict our attention to finding maximum matchings in bipartite graphs: graphs in which the vertex set can be partitioned into \\(V=L\\cup R\\), where \\(L\\) and \\(R\\) are disjoint and all edges in \\(E\\) go between \\(L\\) and \\(R\\). We further assume that every vertex in \\(V\\) has at least one incident edge. Figure 24.8 illustrates the notion of a matching in a bipartite graph.\n\nThe problem of finding a maximum matching in a bipartite graph has many practical applications. As an example, consider matching a set \\(L\\) of machines with a set \\(R\\) of tasks to be performed simultaneously. An edge \\((u,v)\\) in \\(E\\) signifies that",
        "chapter": "Part VI Graph Algorithms",
        "section": "24 Maximum Flow",
        "subsection": "24.2 The Ford-Fulkerson method",
        "subsubsection": "N/A"
    },
    {
        "content": "the source has \\(f(v,s)=1\\). Prove that there must exist another flow \\(f^{\\prime}\\) with \\(f^{\\prime}(v,s)=0\\) such that \\(|f|=|f^{\\prime}|\\). Give an \\(O(E)\\)-time algorithm to compute \\(f^{\\prime}\\), given \\(f\\) and assuming that all edge capacities are integers.\n\n_24.2-13_\n\nSuppose that you wish to find, among all minimum cuts in a flow network \\(G\\) with integer capacities, one that contains the smallest number of edges. Show how to modify the capacities of \\(G\\) to create a new flow network \\(G^{\\prime}\\) in which any minimum cut in \\(G^{\\prime}\\) is a minimum cut with the smallest number of edges in \\(G\\).\n\n### Maximum bipartite matching\n\nSome combinatorial problems can be cast as maximum-flow problems, such as the multiple-source, multiple-sink maximum-flow problem from Section 24.1. Other combinatorial problems seem on the surface to have little to do with flow networks, but they can in fact be reduced to maximum-flow problems. This section presents one such problem: finding a maximum matching in a bipartite graph. In order to solve this problem, we'll take advantage of an integrality property provided by the Ford-Fulkerson method. We'll also see how to use the Ford-Fulkerson method to solve the maximum-bipartite-matching problem on a graph \\(G=(V,E)\\) in \\(O(VE)\\) time. Section 25.1 will present an algorithm specifically designed to solve this problem.\n\n#### The maximum-bipartite-matching problem\n\nGiven an undirected graph \\(G=(V,E)\\), a _matching_ is a subset of edges \\(M\\subseteq E\\) such that for all vertices \\(v\\in V\\), at most one edge of \\(M\\) is incident on \\(v\\). We say that a vertex \\(v\\in V\\) is _matched_ by the matching \\(M\\) if some edge in \\(M\\) is incident on \\(v\\), and otherwise, \\(v\\) is _unmatched_. A _maximum matching_ is a matching of maximum cardinality, that is, a matching \\(M\\) such that for any matching \\(M^{\\prime}\\), we have \\(|M|\\geq|M^{\\prime}|\\). In this section, we restrict our attention to finding maximum matchings in bipartite graphs: graphs in which the vertex set can be partitioned into \\(V=L\\cup R\\), where \\(L\\) and \\(R\\) are disjoint and all edges in \\(E\\) go between \\(L\\) and \\(R\\). We further assume that every vertex in \\(V\\) has at least one incident edge. Figure 24.8 illustrates the notion of a matching in a bipartite graph.\n\nThe problem of finding a maximum matching in a bipartite graph has many practical applications. As an example, consider matching a set \\(L\\) of machines with a set \\(R\\) of tasks to be performed simultaneously. An edge \\((u,v)\\) in \\(E\\) signifies that a particular machine \\(u\\in L\\) is capable of performing a particular task \\(v\\in R\\). A maximum matching provides work for as many machines as possible.\n\n##### Finding a maximum bipartite matching\n\nThe Ford-Fulkerson method provides a basis for finding a maximum matching in an undirected bipartite graph \\(G=(V,E)\\) in time polynomial in \\(|V|\\) and \\(|E|\\). The trick is to construct a flow network in which flows correspond to matchings, as shown in Figure 24.8(c). We define the _corresponding flow network_\\(G^{\\prime}=(V^{\\prime},E^{\\prime})\\) for the bipartite graph \\(G\\) as follows. Let the source \\(s\\) and sink \\(t\\) be new vertices not in \\(V\\), and let \\(V^{\\prime}=V\\cup\\{s,t\\}\\). If the vertex partition of \\(G\\) is \\(V=L\\cup R\\), the directed edges of \\(G^{\\prime}\\) are the edges of \\(E\\), directed from \\(L\\) to \\(R\\), along with \\(|V|\\) new directed edges:\n\n\\[E^{\\prime}\\;= \\{(s,u):u\\in L\\}\\] \\[\\cup\\left\\{(u,v):u\\in L,v\\in R\\right,\\text{ and }(u,v)\\in E\\}\\] \\[\\cup\\left\\{(v,t):v\\in R\\right\\}\\;.\\]\n\nTo complete the construction, assign unit capacity to each edge in \\(E^{\\prime}\\). Since each vertex in \\(V\\) has at least one incident edge, \\(|E|\\geq|V|\\,/2\\). Thus, \\(|E|\\leq|E^{\\prime}|=|E|+|V|\\leq 3\\,|E|\\), and so \\(|E^{\\prime}|=\\Theta(E)\\).\n\nFigure 24.8: A bipartite graph \\(G=(V,E)\\) with vertex partition \\(V=L\\cup R\\). **(a)** A matching with cardinality 2, indicated by blue edges. **(b)** A maximum matching with cardinality 3. **(c)** The corresponding flow network \\(G^{\\prime}\\) with a maximum flow shown. Each edge has unit capacity. Blue edges have a flow of 1, and all other edges carry no flow. The blue edges from \\(L\\) to \\(R\\) correspond to those in the maximum matching from (b).\n\nThe following lemma shows that a matching in \\(G\\) corresponds directly to a flow in \\(G\\)'s corresponding flow network \\(G^{\\prime}\\). We say that a flow \\(f\\) on a flow network \\(G=(V,E)\\) is _integer-valued_ if \\(f(u,v)\\) is an integer for all \\((u,v)\\in V\\times V\\).\n\n**Lemma 24.9**: _Let \\(G=(V,E)\\) be a bipartite graph with vertex partition \\(V=L\\cup R\\), and let \\(G^{\\prime}=(V^{\\prime},E^{\\prime})\\) be its corresponding flow network. If \\(M\\) is a matching in \\(G\\), then there is an integer-valued flow \\(f\\) in \\(G^{\\prime}\\) with value \\(|f|=|M|\\). Conversely, if \\(f\\) is an integer-valued flow in \\(G^{\\prime}\\), then there is a matching \\(M\\) in \\(G\\) with cardinality \\(|M|=|f|\\) consisting of edges \\((u,v)\\in E\\) such that \\(f(u,v)>0\\)._\n\n_Proof_ We first show that a matching \\(M\\) in \\(G\\) corresponds to an integer-valued flow \\(f\\) in \\(G^{\\prime}\\). Define \\(f\\) as follows. If \\((u,v)\\in M\\), then \\(f(s,u)=f(u,v)=f(v,t)=1\\). For all other edges \\((u,v)\\in E^{\\prime}\\), define \\(f(u,v)=0\\). It is simple to verify that \\(f\\) satisfies the capacity constraint and flow conservation.\n\nIntuitively, each edge \\((u,v)\\in M\\) corresponds to 1 unit of flow in \\(G^{\\prime}\\) that traverses the path \\(s\\to u\\to v\\to t\\). Moreover, the paths induced by edges in \\(M\\) are vertex-disjoint, except for \\(s\\) and \\(t\\). The net flow across cut \\((L\\cup\\{s\\}\\,,R\\cup\\{t\\})\\) is equal to \\(|M|\\), and thus, by Lemma 24.4, the value of the flow is \\(|f|=|M|\\).\n\nTo prove the converse, let \\(f\\) be an integer-valued flow in \\(G^{\\prime}\\) and, as in the statement of the lemma, let\n\n\\[M=\\{(u,v):u\\in L\\,,\\,v\\in R\\,,\\,\\,\\text{and}\\,\\,f(u,v)>0\\}\\enspace.\\]\n\nEach vertex \\(u\\in L\\) has only one entering edge, namely \\((s,u)\\), and its capacity is 1. Thus, each \\(u\\in L\\) has at most 1 unit of flow entering it, and if 1 unit of flow does enter, by flow conservation, 1 unit of flow must leave. Furthermore, since the flow \\(f\\) is integer-valued, for each \\(u\\in L\\), the 1 unit of flow can enter on at most one edge and can leave on at most one edge. Thus, 1 unit of flow enters \\(u\\) if and only if there is exactly one vertex \\(v\\in R\\) such that \\(f(u,v)=1\\), and at most one edge leaving each \\(u\\in L\\) carries positive flow. A symmetric argument applies to each \\(v\\in R\\). The set \\(M\\) is therefore a matching.\n\nTo see that \\(|M|=|f|\\), observe that of the edges \\((u,v)\\in E^{\\prime}\\) such that \\(u\\in L\\) and \\(v\\in R\\),\n\n\\[f(u,v)=\\left\\{\\begin{array}{ll}1&\\text{if $(u,v)\\in M$}\\enspace,\\\\ 0&\\text{if $(u,v)\\notin M$}\\enspace.\\end{array}\\right.\\]\n\nConsequently, \\(f(L\\cup\\{s\\}\\,,R\\cup\\{t\\})\\), the net flow across cut \\((L\\cup\\{s\\}\\,,R\\cup\\{t\\})\\), is equal to \\(|M|\\). Lemma 24.4 gives that \\(|f|=f(L\\cup\\{s\\}\\,,R\\cup\\{t\\})=|M|\\).\n\nBased on Lemma 24.9, we would like to conclude that a maximum matching in a bipartite graph \\(G\\) corresponds to a maximum flow in its corresponding flow network \\(G^{\\prime}\\), and therefore running a maximum-flow algorithm on \\(G^{\\prime}\\) provides a maximum matching in \\(G\\). The only hitch in this reasoning is that the maximum-flow algorithm might return a flow in \\(G^{\\prime}\\) for which some \\(f(u,v)\\) is not an integer, even though the flow value \\(|f|\\) must be an integer. The following theorem shows that the Ford-Fulkerson method cannot produce a solution with this problem.\n\n**Theorem 24.10** (Integrality theorem): _If the capacity function \\(c\\) takes on only integer values, then the maximum flow \\(f\\) produced by the Ford-Fulkerson method has the property that \\(|f|\\) is an integer. Moreover, for all vertices \\(u\\) and \\(v\\), the value of \\(f(u,v)\\) is an integer._\n\n_Proof_ Exercise 24.3-2 asks you to provide the proof by induction on the number of iterations.\n\nWe can now prove the following corollary to Lemma 24.9.\n\n**Corollary 24.11**: _The cardinality of a maximum matching \\(M\\) in a bipartite graph \\(G\\) equals the value of a maximum flow \\(f\\) in its corresponding flow network \\(G^{\\prime}\\)._\n\n_Proof_ We use the nomenclature from Lemma 24.9. Suppose that \\(M\\) is a maximum matching in \\(G\\) and that the corresponding flow \\(f\\) in \\(G^{\\prime}\\) is not maximum. Then there is a maximum flow \\(f^{\\prime}\\) in \\(G^{\\prime}\\) such that \\(|f^{\\prime}|>|f|\\). Since the capacities in \\(G^{\\prime}\\) are integer-valued, by Theorem 24.10, we can assume that \\(f^{\\prime}\\) is integer-valued. Thus, \\(f^{\\prime}\\) corresponds to a matching \\(M^{\\prime}\\) in \\(G\\) with cardinality \\(|M^{\\prime}|=|f^{\\prime}|>|f|=|M|\\), contradicting our assumption that \\(M\\) is a maximum matching. In a similar manner, we can show that if \\(f\\) is a maximum flow in \\(G^{\\prime}\\), its corresponding matching is a maximum matching on \\(G\\).\n\nThus, to find a maximum matching in a bipartite undirected graph \\(G\\), create the flow network \\(G^{\\prime}\\), run the Ford-Fulkerson method on \\(G^{\\prime}\\), and convert the integer-valued maximum flow found into a maximum matching for \\(G\\). Since any matching in a bipartite graph has cardinality at most \\(\\min\\left\\{|L|\\,,|R|\\right\\}=O(V)\\), the value of the maximum flow in \\(G^{\\prime}\\) is \\(O(V)\\). Therefore, finding a maximum matching in a bipartite graph takes \\(O(VE^{\\prime})=O(VE)\\) time, since \\(|E^{\\prime}|=\\Theta(E)\\).\n\n**Exercises**\n\n_24.3-1_ Run the Ford-Fulkerson algorithm on the flow network in Figure 24.8(c) and show the residual network after each flow augmentation. Number the vertices in \\(L\\) top to bottom from 1 to 5 and in \\(R\\) top to bottom from 6 to 9. For each iteration, pick the augmenting path that is lexicographically smallest.\n\n_24.3-2_\n\nProve Theorem 24.10. Use induction on the number of iterations of the Ford-Fulkerson method.\n\n_24.3-3_\n\nLet \\(G=(V,E)\\) be a bipartite graph with vertex partition \\(V=L\\cup R\\), and let \\(G^{\\prime}\\) be its corresponding flow network. Give a good upper bound on the length of any augmenting path found in \\(G^{\\prime}\\) during the execution of Ford-Fulkerson.\n\n## Problems\n\n### Escape problem\n\nAn \\(n\\times n\\)_grid_ is an undirected graph consisting of \\(n\\) rows and \\(n\\) columns of vertices, as shown in Figure 24.9. We denote the vertex in the \\(i\\)th row and the \\(j\\)th column by \\((i,j)\\). All vertices in a grid have exactly four neighbors, except for the boundary vertices, which are the points \\((i,j)\\) for which \\(i=1,i=n\\), \\(j=1\\), or \\(j=n\\).\n\nGiven \\(m\\leq n^{2}\\) starting points \\((x_{1},y_{1}),(x_{2},y_{2}),\\ldots,(x_{m},y_{m})\\) in the grid, the _escape problem_ is to determine whether there are \\(m\\) vertex-disjoint paths from the starting points to any \\(m\\) different points on the boundary. For example, the grid in Figure 24.9(a) has an escape, but the grid in Figure 24.9(b) does not.\n\nFigure 24.9: Grids for the escape problem. Starting points are blue, and other grid vertices are tan. **(a)** A grid with an escape, shown by blue paths. **(b)** A grid with no escape.",
        "chapter": "Part VI Graph Algorithms",
        "section": "24 Maximum Flow",
        "subsection": "24.3 Maximum bipartite matching",
        "subsubsection": "N/A"
    },
    {
        "content": "to bottom from 1 to 5 and in \\(R\\) top to bottom from 6 to 9. For each iteration, pick the augmenting path that is lexicographically smallest.\n\n_24.3-2_\n\nProve Theorem 24.10. Use induction on the number of iterations of the Ford-Fulkerson method.\n\n_24.3-3_\n\nLet \\(G=(V,E)\\) be a bipartite graph with vertex partition \\(V=L\\cup R\\), and let \\(G^{\\prime}\\) be its corresponding flow network. Give a good upper bound on the length of any augmenting path found in \\(G^{\\prime}\\) during the execution of Ford-Fulkerson.\n\n## Problems\n\n### Escape problem\n\nAn \\(n\\times n\\)_grid_ is an undirected graph consisting of \\(n\\) rows and \\(n\\) columns of vertices, as shown in Figure 24.9. We denote the vertex in the \\(i\\)th row and the \\(j\\)th column by \\((i,j)\\). All vertices in a grid have exactly four neighbors, except for the boundary vertices, which are the points \\((i,j)\\) for which \\(i=1,i=n\\), \\(j=1\\), or \\(j=n\\).\n\nGiven \\(m\\leq n^{2}\\) starting points \\((x_{1},y_{1}),(x_{2},y_{2}),\\ldots,(x_{m},y_{m})\\) in the grid, the _escape problem_ is to determine whether there are \\(m\\) vertex-disjoint paths from the starting points to any \\(m\\) different points on the boundary. For example, the grid in Figure 24.9(a) has an escape, but the grid in Figure 24.9(b) does not.\n\nFigure 24.9: Grids for the escape problem. Starting points are blue, and other grid vertices are tan. **(a)** A grid with an escape, shown by blue paths. **(b)** A grid with no escape.\n\n* Consider a flow network in which vertices, as well as edges, have capacities. That is, the total positive flow entering any given vertex is subject to a capacity constraint. Show how to reduce the problem of determining the maximum flow in a network with edge and vertex capacities to an ordinary maximum-flow problem on a flow network of comparable size.\n* Describe an efficient algorithm to solve the escape problem, and analyze its running time.\n\n#### 24.2 Minimum path cover\n\nA _path cover_ of a directed graph \\(G=(V,E)\\) is a set \\(P\\) of vertex-disjoint paths such that every vertex in \\(V\\) is included in exactly one path in \\(P\\). Paths may start and end anywhere, and they may be of any length, including \\(0\\). A _minimum path cover_ of \\(G\\) is a path cover containing the fewest possible paths.\n\n* Give an efficient algorithm to find a minimum path cover of a directed acyclic graph \\(G=(V,E)\\). (_Hint:_ Assuming that \\(V=\\{1,2,\\ldots,n\\}\\), construct a flow network based on the graph \\(G^{\\prime}=(V^{\\prime},E^{\\prime})\\), where \\[V^{\\prime} = \\{x_{0},x_{1},\\ldots,x_{n}\\}\\cup\\{y_{0},y_{1},\\ldots,y_{n}\\}\\enspace,\\] \\[E^{\\prime} = \\{(x_{0},x_{i}):i\\in V\\}\\cup\\{(y_{i},y_{0}):i\\in V\\}\\cup\\{(x_{i},y_{j}):(i,j)\\in E\\}\\enspace,\\] and run a maximum-flow algorithm.)\n* Does your algorithm work for directed graphs that contain cycles? Explain.\n\n#### 24.3 Hiring consulting experts\n\nProfessor Fieri wants to open a consulting company for the food industry. He has identified \\(n\\) important food categories, which he represents by the set \\(C=\\{C_{1},C_{2},\\ldots,C_{n}\\}\\). In each category \\(C_{k}\\), he can hire an expert in that category for \\(e_{k}>0\\) dollars. The consulting company has lined up a set \\(J=\\{J_{1},J_{2},\\ldots,J_{m}\\}\\) of potential jobs. In order to perform job \\(J_{i}\\), the company needs to have hired experts in a subset \\(R_{i}\\subseteq C\\) of categories. Each expert can work on multiple jobs simultaneously. If the company chooses to accept job \\(J_{i}\\), it must have hired experts in all categories in \\(R_{i}\\), and it takes in revenue of \\(p_{i}>0\\) dollars.\n\nProfessor Fieri's job is to determine which categories to hire experts in and which jobs to accept in order to maximize the net revenue, which is the total income from jobs accepted minus the total cost of employing the experts.\n\nConsider the following flow network \\(G\\). It contains a source vertex \\(s\\), vertices \\(C_{1},C_{2},\\ldots,C_{n}\\), vertices \\(J_{1},J_{2},\\ldots,J_{m}\\), and a sink vertex \\(t\\). For \\(k=1,2\\ldots,n\\), the flow network contains an edge \\((s,C_{k})\\) with capacity \\(c(s,C_{k})=e_{k}\\), and for \\(i=1,2,\\ldots,m\\), the flow network contains an edge \\((J_{i},t)\\) with capacity \\(c(J_{i},t)=p_{i}\\). For \\(k=1,2,\\ldots,n\\) and \\(i=1,2,\\ldots,m\\), if \\(C_{k}\\in R_{i}\\), then \\(G\\) contains an edge \\((C_{k},J_{i})\\) with capacity \\(c(C_{k},J_{i})=\\infty\\).\n\n_a._ Show that if \\(J_{i}\\in T\\) for a finite-capacity cut \\((S,T)\\) of \\(G\\), then \\(C_{k}\\in T\\) for each \\(C_{k}\\in R_{i}\\).\n\n_b._ Show how to determine the maximum net revenue from the capacity of a minimum cut of \\(G\\) and the given \\(p_{i}\\) values.\n\n_c._ Give an efficient algorithm to determine which jobs to accept and which experts to hire. Analyze the running time of your algorithm in terms of \\(m\\), \\(n\\), and \\(r=\\sum_{i=1}^{m}|R_{i}|\\).\n\n### Updating maximum flow\n\nLet \\(G=(V,E)\\) be a flow network with source \\(s\\), sink \\(t\\), and integer capacities. Suppose that you are given a maximum flow in \\(G\\).\n\n_a._ Suppose that the capacity of a single edge \\((u,v)\\in E\\) increases by 1. Give an \\(O(V+E)\\)-time algorithm to update the maximum flow.\n\n_b._ Suppose that the capacity of a single edge \\((u,v)\\in E\\) decreases by 1. Give an \\(O(V+E)\\)-time algorithm to update the maximum flow.\n\n### Maximum flow by scaling\n\nLet \\(G=(V,E)\\) be a flow network with source \\(s\\), sink \\(t\\), and an integer capacity \\(c(u,v)\\) on each edge \\((u,v)\\in E\\). Let \\(C=\\max\\left\\{c(u,v):(u,v)\\in E\\right\\}\\).\n\n_a._ Argue that a minimum cut of \\(G\\) has capacity at most \\(C\\left|E\\right|\\).\n\n_b._ For a given number \\(K\\), show how to find an augmenting path of capacity at least \\(K\\) in \\(O(E)\\) time, if such a path exists.\n\nThe procedure Max-Flow-By-Scaling appearing on the following page modifies the basic Ford-Fulkerson-Method procedure to compute a maximum flow in \\(G\\).\n\n_c._ Argue that Max-Flow-By-Scaling returns a maximum flow.\n\n_d._ Show that the capacity of a minimum cut of the residual network \\(G_{f}\\) is less than \\(2K\\left|E\\right|\\) each time line 4 executes.\n\n_e._ Argue that the inner **while** loop of lines 5-6 executes \\(O(E)\\) times for each value of \\(K\\).\n\n#### 24.6.1 Wideset augmenting path\n\nThe Edmonds-Karp algorithm implements the Ford-Fulkerson algorithm by always choosing a shortest augmenting path in the residual network. Suppose instead that the Ford-Fulkerson algorithm chooses a _widest augmenting path_: an augmenting path with the greatest residual capacity. Assume that \\(G=(V,E)\\) is a flow network with source \\(s\\) and sink \\(t\\), that all capacities are integer, and that the largest capacity is \\(C\\). In this problem, you will show that choosing a widest augmenting path results in at most \\(|E|\\ln|f^{*}|\\) augmentations to find a maximum flow \\(f^{*}\\).\n\n* Show how to adjust Dijkstra's algorithm to find the widest augmenting path in the residual network.\n* Show that a maximum flow in \\(G\\) can be formed by successive flow augmentations along at most \\(|E|\\) paths from \\(s\\) to \\(t\\).\n* Given a flow \\(f\\), argue that the residual network \\(G_{f}\\) has an augmenting path \\(p\\) with residual capacity \\(c_{f}(p)\\geq(|f^{*}|-|f|)/\\,|E|\\).\n* Assuming that each augmenting path is a widest augmenting path, let \\(f_{i}\\) be the flow after augmenting the flow by the \\(i\\)th augmenting path, where \\(f_{0}\\) has \\(f(u,v)=0\\) for all edges \\((u,v)\\). Show that \\(|f^{*}|-|f_{i}|\\leq|f^{*}|\\,(1-1/\\,|E|)^{i}\\).\n* Show that \\(|f^{*}|-|f_{i}|<|f^{*}|\\,e^{-i/|E|}\\).\n* Conclude that after the flow is augmented at most \\(|E|\\ln|f^{*}|\\) times, the flow is a maximum flow,\n\n#### 24.7 Global minimum cut\n\nA _global cut_ in an undirected graph \\(G=(V,E)\\) is a partition (see page 1156) of \\(V\\) into two nonempty sets \\(V_{1}\\) and \\(V_{2}\\). This definition is like the definition of cut that we have used in this chapter, except that we no longer have distinguished vertices \\(s\\) and \\(t\\). Any edge \\((u,v)\\) with \\(u\\in V_{1}\\) and \\(v\\in V_{2}\\) is said to _cross_ the cut.\n\nWe can extend this definition of a cut to a multigraph \\(G=(V,E)\\) (see page 1167), and we denote by \\(c(u,v)\\) the number of edges in the multigraph with endpoints \\(u\\) and \\(v\\). A global cut in a multigraph is still a partition of the vertices, and the value of a global cut \\((V_{1},V_{2})\\) is \\(c(V_{1},V_{2})=\\sum_{u\\in V_{1},v\\in V_{2}}c(u,v)\\). A solution to the _global-minimum-cut problem_ is a cut \\((V_{1},V_{2})\\) such that \\(c(V_{1},V_{2})\\) is minimum. Let \\(\\mu(G)\\) denote the value of a global minimum cut in a graph or multigraph \\(G\\).\n\n_a._: Show how to find a global minimum cut of a graph \\(G=(V,E)\\) by solving \\({|V|\\choose 2}\\) maximum-flow problems, each with a different pair of vertices as the source and sink, and taking the minimum value of the cuts found.\n\n_b._: Give an algorithm to find a global minimum cut by solving only \\(\\Theta(V)\\) maximum-flow problems. What is the running time of your algorithm?\n\nThe remainder of this problem develops an algorithm for the global-minimum-cut problem that does not use any maximum-flow computations. It uses the notion of an edge contraction, defined on page 1168, with one crucial difference. The algorithm maintains a multigraph, so that upon contracting an edge \\((u,v)\\), it creates a new vertex \\(x\\), and for any other vertex \\(y\\in V\\), the number of edges between \\(x\\) and \\(y\\) is \\(c(u,y)+c(v,y)\\). The algorithm does not maintain self-loops, and so it sets \\(c(x,x)\\) to \\(0\\). Denote by \\(G/(u,v)\\) the multigraph that results from contracting edge \\((u,v)\\) in multigraph \\(G\\).\n\nConsider what can happen to the minimum cut when an edge is contracted. Assume that, at all points, the minimum cut in a multigraph \\(G\\) is unique. We'll remove this assumption later.\n\n_c._: Show that for any edge \\((u,v)\\), we have \\(\\mu(G/(uv))\\leq\\mu(G)\\). Under what conditions is \\(\\mu(G/(uv))\\!\\!<\\mu(G)\\)?\n\nNext, you will show that if you pick an edge uniformly at random, the probability that it belongs to the minimum cut is small.\n\n_d._: Show that for any multigraph \\(G=(V,E)\\), the value of the global minimum cut is at most the average degree of a vertex: that \\(\\mu(G)\\leq 2\\,|E|\\,/\\,|V|\\), where \\(|E|\\) denotes the total number of edges in the multigraph.\n\n* Using the results from parts (c) and (d), show that, if we pick an edge \\((u,v)\\) uniformly at random, then the probability that \\((u,v)\\) belongs to the minimum cut is at most \\(2/\\,V\\).\n\nConsider the algorithm that repeatedly chooses an edge at random and contracts it until the multigraph has exactly two vertices, say \\(u\\) and \\(v\\). At that point, the multigraph corresponds to a cut in the original graph, with vertex \\(u\\) representing all the nodes in one side of the original graph, and \\(v\\) representing all the vertices on the other side. The number of edges given by \\(c(u,v)\\) corresponds exactly to the number of edges crossing the corresponding cut in the original graph. We call this algorithm the _contraction algorithm_.\n* Suppose that the contraction algorithm terminates with a multigraph whose only vertices are \\(u\\) and \\(v\\). Show that \\(\\Pr\\left\\{c(u,v)=\\mu(G)\\right\\}=\\Omega\\left(1/\\binom{|V|}{2}\\right)\\).\n* Prove that if the contraction algorithm repeats \\(\\binom{|V|}{2}\\ln|V|\\) times, then the probability that at least one of the runs returns the minimum cut is at least \\(1-1/\\,|V|\\).\n* Give a detailed implementation of the contraction algorithm that runs in \\(O(V^{2})\\) time.\n* Combine the previous parts and remove the assumption that the minimum cut must be unique, to conclude that running the contraction algorithm \\(\\binom{|V|}{2}\\ln|V|\\) times yields an algorithm that runs in \\(O(V^{4}\\lg V)\\) time and returns a minimum cut with probability at least \\(1-1/\\,V\\).\n\n## Chapter notes\n\nAhuja, Magnanti, and Orlin [7], Even [137], Lawler [276], Papadimitriou and Steiglitz [353], Tarjan [429], and Williamson [458] are good references for network flows and related algorithms. Schrijver [399] has written an interesting review of historical developments in the field of network flows.\n\nThe Ford-Fulkerson method is due to Ford and Fulkerson [149], who originated the formal study of many of the problems in the area of network flow, including the maximum-flow and bipartite-matching problems. Many early implementations of the Ford-Fulkerson method found augmenting paths using breadth-first search. Edmonds and Karp [132], and independently Dinic [119], proved that this strategy yields a polynomial-time algorithm. A related idea, that of using \"blocking flows,\" was also first developed by Dinic [119].\n\nA class of algorithms known as _push-relabel algorithms_, due to Goldberg [185] and Goldberg and Tarjan [188], takes a different approach from the Ford-Fulkerson",
        "chapter": "Part VI Graph Algorithms",
        "section": "24 Maximum Flow",
        "subsection": "Problems",
        "subsubsection": "N/A"
    },
    {
        "content": "* Using the results from parts (c) and (d), show that, if we pick an edge \\((u,v)\\) uniformly at random, then the probability that \\((u,v)\\) belongs to the minimum cut is at most \\(2/\\,V\\).\n\nConsider the algorithm that repeatedly chooses an edge at random and contracts it until the multigraph has exactly two vertices, say \\(u\\) and \\(v\\). At that point, the multigraph corresponds to a cut in the original graph, with vertex \\(u\\) representing all the nodes in one side of the original graph, and \\(v\\) representing all the vertices on the other side. The number of edges given by \\(c(u,v)\\) corresponds exactly to the number of edges crossing the corresponding cut in the original graph. We call this algorithm the _contraction algorithm_.\n* Suppose that the contraction algorithm terminates with a multigraph whose only vertices are \\(u\\) and \\(v\\). Show that \\(\\Pr\\left\\{c(u,v)=\\mu(G)\\right\\}=\\Omega\\left(1/\\binom{|V|}{2}\\right)\\).\n* Prove that if the contraction algorithm repeats \\(\\binom{|V|}{2}\\ln|V|\\) times, then the probability that at least one of the runs returns the minimum cut is at least \\(1-1/\\,|V|\\).\n* Give a detailed implementation of the contraction algorithm that runs in \\(O(V^{2})\\) time.\n* Combine the previous parts and remove the assumption that the minimum cut must be unique, to conclude that running the contraction algorithm \\(\\binom{|V|}{2}\\ln|V|\\) times yields an algorithm that runs in \\(O(V^{4}\\lg V)\\) time and returns a minimum cut with probability at least \\(1-1/\\,V\\).\n\n## Chapter notes\n\nAhuja, Magnanti, and Orlin [7], Even [137], Lawler [276], Papadimitriou and Steiglitz [353], Tarjan [429], and Williamson [458] are good references for network flows and related algorithms. Schrijver [399] has written an interesting review of historical developments in the field of network flows.\n\nThe Ford-Fulkerson method is due to Ford and Fulkerson [149], who originated the formal study of many of the problems in the area of network flow, including the maximum-flow and bipartite-matching problems. Many early implementations of the Ford-Fulkerson method found augmenting paths using breadth-first search. Edmonds and Karp [132], and independently Dinic [119], proved that this strategy yields a polynomial-time algorithm. A related idea, that of using \"blocking flows,\" was also first developed by Dinic [119].\n\nA class of algorithms known as _push-relabel algorithms_, due to Goldberg [185] and Goldberg and Tarjan [188], takes a different approach from the Ford-Fulkersonmethod. Push-relabel algorithms allow flow conservation to be violated at vertices other than the source and sink as they execute. Using an idea first developed by Karzonov [251], they allow a _preflow_ in which the flow into a vertex may exceed the flow out of the vertex. Such a vertex is said to be _overflowing_. Initially, every edge leaving the source is filled to capacity, so that all neighbors of the source are overflowing. In a push-relabel algorithm, each vertex is assigned an integer height. An overflowing vertex may push flow to a neighboring vertex to which it has a residual edge provided that it is higher than the neighbor. If all residual edges from an overflowing vertex go to neighbors with equal or greater heights, then the vertex may increase its height. Once all vertices other than the sink are no longer overflowing, the preflow is not only a legal flow, but also a maximum flow.\n\nGoldberg and Tarjan [188] gave an \\(O(V^{3})\\)-time algorithm that uses a queue to maintain the set of overflowing vertices, as well as an algorithm that uses dynamic trees to achieve a running time of \\(O(VE\\lg(V^{2}/E+2))\\). Several other researchers developed improved variants and implementations [9, 10, 15, 86, 87, 255, 358], the fastest of which, by King, Rao, and Tarjan [255], runs in \\(O(VE\\log_{E/(V\\lg V)}V)\\) time.\n\nAnother efficient algorithm for maximum flow, by Goldberg and Rao [187], runs in \\(O\\left(\\min\\left\\{V^{2/3},\\,E^{\\,1/2}\\right\\}\\,E\\lg(V^{2}/E\\,+\\,2)\\lg C\\right)\\) time, where \\(C\\) is the maximum capacity of any edge. Orlin [350] gave an algorithm in the same spirit as this algorithm that runs in \\(O(VE\\,+\\,E^{\\,31/16}\\lg^{2}V)\\) time. Combining it with the algorithm of King, Rao, and Tarjan results in an \\(O(VE)\\)-time algorithm.\n\nA different approach to maximum flows and related problems is to use techniques from continuous optimization including electrical flows and interior-point methods. The first breakthrough in this line of work is due to Madry [308], who gave an \\(\\widetilde{O}(E^{\\,10/7})\\)-time algorithm for unit-capacity maximum flow and bipartite maximum matching. (See Problem 3-6 on page 73 for a definition of \\(\\widetilde{O}\\).) There has been a series of papers in this area for matchings, maximum flows, and minimum-cost flows. The fastest algorithm to date in this line of work for maximum flow is due to Lee and Sidford [285], taking \\(\\widetilde{O}(\\sqrt{V}\\,E\\lg^{O(1)}C)\\) time. If the capacities are not too large, this algorithm is faster than the \\(O(VE)\\)-time algorithm mentioned above. Another algorithm, due to Liu and Sidford [303] runs in \\(\\widetilde{O}(E^{\\,11/8}C^{\\,1/4})\\) time, where \\(C\\) is the maximum capacity of any edge. This algorithm does not run in polynomial time, but for small enough capacities, it is faster than the previous ones.\n\nIn practice, push-relabel algorithms currently dominate algorithms based on augmenting paths, continuous-optimization, and linear programming for the maximum-flow problem [88].\n\nMany real-world problems can be modeled as finding matchings in an undirected graph. For an undirected graph \\(G=(V,E)\\), a _matching_ is a subset of edges \\(M\\subseteq E\\) such that every vertex in \\(V\\) has at most one incident edge in \\(M\\).\n\nFor example, consider the following scenario. You have one or more positions to fill and several candidates to interview. According to your schedule, you are able to interview candidates at certain time slots. You ask the candidates to indicate the subsets of time slots at which they are available. How can you schedule the interviews so that each time slot has at most one candidate scheduled, while maximizing the number of candidates that you can interview? You can model this scenario as a matching problem on a bipartite graph in which each vertex represents either a candidate or a time slot, with an edge between a candidate and a time slot if the candidate is available then. If an edge is included in the matching, that means you are scheduling a particular candidate for a particular time slot. Your goal is to find a _maximum matching_: a matching of maximum cardinality. One of the authors of this book was faced with exactly this situation when hiring teaching assistants for a large class. He used the Hopcroft-Karp algorithm in Section 25.1 to schedule the interviews.\n\nAnother application of matching is the U.S. National Resident Matching Program, in which medical students are matched to hospitals where they will be stationed as medical residents. Each student ranks the hospitals by preference, and each hospital ranks the students. The goal is to assign students to hospitals so that there is never a student and a hospital that both have regrets because the student was not assigned to the hospital, yet each ranked the other higher than who or where they were assigned. This scenario is perhaps the best-known real-world example of the \"stable-marriage problem,\" which Section 25.2 examines.\n\nYet another instance where matching comes into play occurs when workers must be assigned to tasks in order to maximize the overall effectiveness of the assignment. For each worker and each task, the worker has some quantified effectiveness",
        "chapter": "Part VI Graph Algorithms",
        "section": "24 Maximum Flow",
        "subsection": "Chapter notes",
        "subsubsection": "N/A"
    },
    {
        "content": "for that task. Assuming that there are equal numbers of workers and tasks, the goal is to find a matching with the maximum total effectiveness. Such a situation is an example of an assignment problem, which Section 25.3 shows how to solve.\n\nThe algorithms in this chapter find matchings in _bipartite_ graphs. As in Section 24.3, the input is an undirected graph \\(G=(V,E)\\), where \\(V=L\\cup R\\), the vertex sets \\(L\\) and \\(R\\) are disjoint, and every edge in \\(E\\) is incident on one vertex in \\(L\\) and one vertex in \\(R\\). A matching, therefore, matches vertices in \\(L\\) with vertices in \\(R\\). In some applications, the sets \\(L\\) and \\(R\\) have equal cardinality, and in other applications they need not be the same size.\n\nAn undirected graph need not be bipartite for the concept of matching to apply. Matching in general undirected graphs has applications in areas such as scheduling and computational chemistry. It models problems in which you want to pair up entities, represented by vertices. Two vertices are adjacent if they represent compatible entities, and you need to find a large set of compatible pairs. Maximum-matching and maximum-weight matching problems on general graphs can be solved by polynomial-time algorithms whose running times are similar to those for bipartite matching, but the algorithms are significantly more complicated. Exercise 25.2-5 discusses the general version of the stable-marriage problem, known as the \"stable-roommates problem.\" Although matching applies to general undirected graphs, this chapter deals only with bipartite graphs.\n\n### Maximum bipartite matching (revisited)\n\nSection 24.3 demonstrated one way to find a maximum matching in a bipartite graph, by finding a maximum flow. This section provides a more efficient method, the Hopcroft-Karp algorithm, which runs in \\(O(\\sqrt{V}E)\\) time. Figure 25.1(a) shows a matching in an undirected bipartite graph. A vertex that has an incident edge in matching \\(M\\) is _matched_ under \\(M\\), and otherwise, it is _unmatched_. A _maximal matching_ is a matching \\(M\\) to which no other edges can be added, that is, for every edge \\(e\\in E-M\\), the edge set \\(M\\cup\\{e\\}\\) fails to be a matching. A maximum matching is always maximal, but the reverse does not always hold.\n\nMany algorithms to find maximum matchings, the Hopcroft-Karp algorithm included, work by incrementally increasing the size of a matching. Given a matching \\(M\\) in an undirected graph \\(G=(V,E)\\), an \\(M\\)**-alternating path** is a simple path whose edges alternate between being in \\(M\\) and being in \\(E-M\\). Figure 25.1(b) depicts an \\(M\\)**-augmenting path** (sometimes called an augmenting path with respect to \\(M\\)): an \\(M\\)-alternating path whose first and last edges belong to \\(E-M\\). Since an \\(M\\)-augmenting path contains one more edge in \\(E-M\\) than in \\(M\\), it must consist of an odd number of edges.\n\nFigure 25.1(c) demonstrates the following lemma, which shows that by removing from matching \\(M\\) the edges in an \\(M\\)-augmenting path that belong to \\(M\\) and adding to \\(M\\) the edges in the \\(M\\)-augmenting path that are not in \\(M\\), the result is a new matching with one more edge than \\(M\\). Since a matching is a set of edges, the lemma relies on the notion of the _symmetric difference_ of two sets: \\(X\\oplus Y=(X-Y)\\cup(Y-X)\\), that is, the elements that belong to \\(X\\) or \\(Y\\), but not both. Alternatively, you can think of \\(X\\oplus Y\\) as \\((X\\cup Y)-(X\\cap Y)\\). The operator \\(\\oplus\\) is commutative and associative. Furthermore, \\(X\\oplus X=\\emptyset\\) and \\(X\\oplus\\emptyset=\\emptyset\\oplus X=X\\) for any set \\(X\\), so that the empty set is the identity for \\(\\oplus\\).\n\n**Lemma 25.1**: _Let \\(M\\) be a matching in any undirected graph \\(G=(V,E)\\), and let \\(P\\) be an \\(M\\)-augmenting path. Then the set of edges \\(M^{\\prime}=M\\oplus P\\) is also a matching in \\(G\\) with \\(|M^{\\prime}|=|M|+1\\)._\n\nFigure 25.1: A bipartite graph, where \\(V=L\\cup R\\), \\(L=\\{l_{1},l_{2},\\ldots,l_{7}\\}\\), and \\(R=\\{r_{1},r_{2},\\ldots,r_{8}\\}\\). **(a)** A matching \\(M\\) with cardinality \\(4\\), highlighted in blue. Matched vertices are blue, and unmatched vertices are tan. **(b)** The five edges highlighted in orange form an \\(M\\)-augmenting path \\(P\\) going between vertices \\(l_{6}\\) and \\(r_{8}\\). **(c)** The set of edges \\(M^{\\prime}=M\\oplus P\\) highlighted in blue is a matching containing one more edge than \\(M\\) and adding \\(l_{6}\\) and \\(r_{8}\\) to the matched vertices. This matching is not a maximum matching (see Exercise 25.1-1).\n\n_Proof_ Let \\(P\\) contain \\(q\\) edges, so that \\(\\lceil q/2\\rceil\\) edges belong to \\(E-M\\) and \\(\\lfloor q/2\\rfloor\\) edges belong to \\(M\\), and let these \\(q\\) edges be \\((v_{1},v_{2}),(v_{2},v_{3}),\\ldots,(v_{q},v_{q+1})\\). Because \\(P\\) is an \\(M\\)-augmenting path, vertices \\(v_{1}\\) and \\(v_{q+1}\\) are unmatched under \\(M\\) and all other vertices in \\(P\\) are matched. Edges \\((v_{1},v_{2}),(v_{3},v_{4}),\\ldots,(v_{q},v_{q+1})\\) belong to \\(E-M\\), and edges \\((v_{2},v_{3}),(v_{4},v_{5}),\\ldots,(v_{q-1},v_{q})\\) belong to \\(M\\). The symmetric difference \\(M^{\\prime}=M\\oplus P\\) reverses these roles, so that edges \\((v_{1},v_{2}),(v_{3},v_{4}),\\ldots,(v_{q},v_{q+1})\\) belong to \\(M^{\\prime}\\) and \\((v_{2},v_{3}),(v_{4},v_{5}),\\ldots,(v_{q-1},v_{q})\\) belong to \\(E-M^{\\prime}\\). Each vertex \\(v_{1},v_{2},\\ldots,v_{q},v_{q+1}\\) is matched under \\(M^{\\prime}\\), which gains one additional edge relative to \\(M\\), and no other vertices or edges in \\(G\\) are affected by the change from \\(M\\) to \\(M^{\\prime}\\). Hence, \\(M^{\\prime}\\) is a matching in \\(G\\), and \\(|M^{\\prime}|=|M|+1\\).\n\nSince taking the symmetric difference of a matching \\(M\\) with an \\(M\\)-augmenting path increases the size of the matching by \\(1\\), the following corollary shows that taking the symmetric difference of \\(M\\) with \\(k\\) vertex-disjoint \\(M\\)-augmenting paths increases the size of the matching by \\(k\\).\n\n_Corollary 25.2_ Let \\(M\\) be a matching in any undirected graph \\(G=(V,E)\\) and \\(P_{1},P_{2},\\ldots,P_{k}\\) be vertex-disjoint \\(M\\)-augmenting paths. Then the set of edges \\(M^{\\prime}=M\\oplus(P_{1}\\cup P_{2}\\cup\\cdots\\cup P_{k})\\) is a matching in \\(G\\) with \\(|M^{\\prime}|=|M|+k\\).\n\n_Proof_ Since the \\(M\\)-augmenting paths \\(P_{1},P_{2},\\ldots,P_{k}\\) are vertex-disjoint, we have that \\(P_{1}\\cup P_{2}\\cup\\cdots\\cup P_{k}=P_{1}\\oplus P_{2}\\oplus\\cdots\\oplus P_{k}\\). Because the operator \\(\\oplus\\) is associative, we have\n\n\\[M\\oplus(P_{1}\\cup P_{2}\\cup\\cdots\\cup P_{k}) = M\\oplus(P_{1}\\oplus P_{2}\\oplus\\cdots\\oplus P_{k})\\] \\[= (\\cdots((M\\oplus P_{1})\\oplus P_{2})\\oplus\\cdots\\oplus P_{k-1}) \\oplus P_{k}\\.\\]\n\nA simple induction on \\(i\\) using Lemma 25.1 shows that \\(M\\oplus(P_{1}\\cup P_{2}\\cup\\cdots\\cup P_{i-1})\\) is a matching in \\(G\\) containing \\(|M|+i-1\\) edges and that path \\(P_{i}\\) is an augmenting path with respect to \\(M\\oplus(P_{1}\\cup P_{2}\\cup\\cdots\\cup P_{i-1})\\). Each of these augmenting paths increases the size of the matching by \\(1\\), and so \\(|M^{\\prime}|=|M|+k\\).\n\nAs the Hopcroft-Karp algorithm goes from matching to matching, it will be useful to consider the symmetric difference between two matchings.\n\n_Lemma 25.3_ Let \\(M\\) and \\(M^{*}\\) be matchings in graph \\(G=(V,E)\\), and consider the graph \\(G^{\\prime}=(V,E^{\\prime})\\), where \\(E^{\\prime}=M\\oplus M^{*}\\). Then, \\(G^{\\prime}\\) is a disjoint union of simple paths, simple cycles, and/or isolated vertices. The edges in each such simple path or simple cycle alternate between \\(M\\) and \\(M^{*}\\). If \\(|M^{*}|>|M|\\), then \\(G^{\\prime}\\) contains at least \\(|M^{*}|-|M|\\) vertex-disjoint \\(M\\)-augmenting paths.\n\n_Proof_ Each vertex in \\(G^{\\prime}\\) has degree 0, 1, or 2, since at most two edges of \\(E^{\\prime}\\) can be incident on a vertex: at most one edge from \\(M\\) and at most one edge from \\(M^{*}\\). Therefore, each connected component of \\(G^{\\prime}\\) is either a singleton vertex, an even-length simple cycle with edges alternately in \\(M\\) and \\(M^{*}\\), or a simple path with edges alternately in \\(M\\) and \\(M^{*}\\). Since\n\n\\[E^{\\prime} = M\\,\\oplus\\,M^{*}\\] \\[= (M\\,\\cup\\,M^{*})-(M\\,\\cap\\,M^{*})\\]\n\nand \\(|M^{*}|>|M|\\), the edge set \\(E^{\\prime}\\) must contain \\(|M^{*}|-|M|\\) more edges from \\(M^{*}\\) than from \\(M\\). Because each cycle in \\(G^{\\prime}\\) has an even number of edges drawn alternately from \\(M\\) and \\(M^{*}\\), each cycle has an equal number of edges from \\(M\\) and \\(M^{*}\\). Therefore, the simple paths in \\(G^{\\prime}\\) account for there being \\(|M^{*}|-|M|\\) more edges from \\(M^{*}\\) than \\(M\\). Each path containing a different number of edges from \\(M\\) and \\(M^{*}\\) either starts and ends with edges from \\(M\\), containing one more edge from \\(M\\) than from \\(M^{*}\\), or starts and ends with edges from \\(M^{*}\\), containing one more edge from \\(M^{*}\\) than from \\(M\\). Because \\(E^{\\prime}\\) contains \\(|M^{*}|-|M|\\) more edges from \\(M^{*}\\) than from \\(M\\), there are at least \\(|M^{*}|-|M|\\) paths of the latter type, and each one is an \\(M\\)-augmenting path. Because each vertex has at most two incident edges from \\(E^{\\prime}\\), these paths must be vertex-disjoint.\n\nIf an algorithm finds a maximum matching by incrementally increasing the size of the matching, how does it determine when to stop? The following corollary gives the answer: when there are no augmenting paths.\n\n_Corollary 25.4_\n\nMatching \\(M\\) in graph \\(G=(V,E)\\) is a maximum matching if and only if \\(G\\) contains no \\(M\\)-augmenting path.\n\n_Proof_ We prove the contrapositive of both directions of the lemma statement. The contrapositive of the forward direction is straightforward. If there is an \\(M\\)-augmenting path \\(P\\) in \\(G\\), then by Lemma 25.1, the matching \\(M\\,\\oplus\\,P\\) contains one more edge than \\(M\\), meaning that \\(M\\) could not be a maximum matching.\n\nTo show the contrapositive of the backward direction--if \\(M\\) is not a maximum matching, then \\(G\\) contains an \\(M\\)-augmenting path--let \\(M^{*}\\) be a maximum matching in Lemma 25.3, so that \\(|M^{*}|>|M|\\). Then \\(G\\) contains at least \\(|M^{*}|-|M|>0\\) vertex-disjoint \\(M\\)-augmenting paths.\n\n### 25.1 Maximum bipartite matching (revisited)\n\nWe already have learned enough to create a maximum-matching algorithm that runs in \\(O(VE)\\) time. Start with the matching \\(M\\) empty. Then repeatedly run a variant of either breadth-first search or depth-first search from an unmatched vertex that takes alternating paths until you find another unmatched vertex. Use the resulting \\(M\\)-augmenting path to increase the size of \\(M\\) by 1.\n\n#### The Hopcroft-Karp algorithm\n\nThe Hopcroft-Karp algorithm improves the running time to \\(O(\\sqrt{V}E)\\). The procedure Hopcroft-Karp is given an undirected bipartite graph, and it uses Corollary 25.2 to repeatedly increase the size of the matching \\(M\\) it finds. Corollary 25.4 proves that the algorithm is correct, since it terminates once there are no \\(M\\)-augmenting paths. It remains to show that the algorithm does run in \\(O(\\sqrt{V}E)\\) time. We'll see that the **repeat** loop of lines 2-5 iterates \\(O(\\sqrt{V})\\) times and how to implement line 3 so that it runs in \\(O(E)\\) time in each iteration.\n\n#### Hopcroft-Karp(\\(G\\))\n\n```\n1\\(M=\\emptyset\\)\n2repeat\n3 let \\(\\mathcal{P}=\\{P_{1},P_{2},\\ldots,P_{k}\\}\\) be a maximal set of vertex-disjoint shortest \\(M\\)-augmenting paths\n4\\(M=M\\oplus(P_{1}\\cup P_{2}\\cup\\cdots\\cup P_{k})\\)\n5until\\(\\mathcal{P}==\\emptyset\\)\n6return\\(M\\)\n```\n\nLet's first see how to find a maximal set of vertex-disjoint shortest \\(M\\)-augmenting paths in \\(O(E)\\) time. There are three phases. The first phase forms a directed version \\(G_{M}\\) of the undirected bipartite graph \\(G\\). The second phase creates a directed acyclic graph \\(H\\) from \\(G_{M}\\) via a variant of breadth-first search. The third phase finds a maximal set of vertex-disjoint shortest \\(M\\)-augmenting paths by running a variant of depth-first search on the transpose \\(H^{\\mathrm{T}}\\) of \\(H\\). (Recall that the transpose of a directed graph reverses the direction of each edge. Since \\(H\\) is acyclic, so is \\(H^{\\mathrm{T}}\\).)\n\nGiven a matching \\(M\\), you can think of an \\(M\\)-augmenting path \\(P\\) as starting at an unmatched vertex in \\(L\\), traversing an odd number of edges, and ending at an unmatched vertex in \\(R\\). The edges in \\(P\\) traversed from \\(L\\) to \\(R\\) must belong to \\(E-M\\), and the edges in \\(P\\) traversed from \\(R\\) to \\(L\\) must belong to \\(M\\). The first phase, therefore, creates the directed graph \\(G_{M}\\) by directing the edges accordingly:\n\n\\(G_{M}=(V,E_{M})\\), where\\(E_{M}=\\{(l,r):l\\in L,r\\in R\\), and \\((l,r)\\in E-M\\}\\) (edges from \\(L\\) to \\(R\\)) \\(\\cup\\{(r,l):r\\in R,l\\in L,\\text{ and }(l,r)\\in M\\}\\) (edges from \\(R\\) to \\(L\\)).\n\nFigure 25.2(a) shows the graph \\(G_{M}\\) for the graph \\(G\\) and matching \\(M\\) in Figure 25.1(a).\n\nThe \\(\\operatorname{\\text{\\rm{deg}}}H=(V_{H},\\,E_{H})\\) created by the second phase has layers of vertices. Figure 25.2(b) shows the \\(\\operatorname{\\text{\\rm{deg}}}H\\) corresponding to the directed graph \\(G_{M}\\) in part (a) of the figure. Each layer contains only vertices from \\(L\\) or only vertices from \\(R\\), alternating from layer to layer. The layer that a vertex resides in is given by that vertex's minimum breadth-first distance in \\(G_{M}\\) from any unmatched vertex in \\(L\\). Vertices in \\(L\\) appear in even-numbered layers, and vertices in \\(R\\) appear in odd-numbered layers. Let \\(q\\) denote the smallest distance in \\(G_{M}\\) of any unmatched vertex in \\(R\\). Then, the last layer in \\(H\\) contains the vertices in \\(R\\) with distance \\(q\\). Vertices whose distance exceeds \\(q\\) do not appear in \\(V_{H}\\). (The graph \\(H\\) in Figure 25.2(b) omits vertices \\(l_{7}\\) and \\(r_{8}\\) because their distances from any unmatched vertex in \\(L\\) exceed \\(q=3\\).) The edges in \\(E_{H}\\) form a subset of \\(E_{M}\\):\n\nFigure 25.2: **(a)** The directed graph \\(G_{M}\\) created in the first phase for the undirected bipartite graph \\(G\\) and matching \\(M\\) in Figure 25.1(a). Breadth-first distances from any unmatched vertex in \\(L\\) appear next to each vertex. **(b)** The \\(\\operatorname{\\text{\\rm{deg}}}H\\) created from \\(G_{M}\\) in the second phase. Because the smallest distance to an unmatched vertex in \\(R\\) is \\(3\\), vertices \\(l_{7}\\) and \\(r_{8}\\), with distances greater than \\(3\\), are not in \\(H\\).\n\n\\(E_{H}=\\{(l,r)\\in E_{M}:r.d\\leq q\\text{ and }r.d=l.d+1\\}\\cup\\{(r,l)\\in E_{M}:l.d\\leq q\\}\\), where the attribute \\(d\\) of a vertex gives the vertex's breadth-first distance in \\(G_{M}\\) from any unmatched vertex in \\(L\\). Edges that do not go between two consecutive layers are omitted from \\(E_{H}\\).\n\nTo determine the breadth-first distances of vertices, run breadth-first search on the graph \\(G_{M}\\), but starting from all the unmatched vertices in \\(L\\). (In the BFS procedure on page 556, replace the root vertex \\(s\\) by the set of unmatched vertices in \\(L\\).) The predecessor attributes \\(\\pi\\) computed by the BFS procedure are not needed here, since \\(H\\) is a dag and not necessarily a tree.\n\nEvery path in \\(H\\) from a vertex in layer \\(0\\) to an unmatched vertex in layer \\(q\\) corresponds to a shortest \\(M\\)-augmenting path in the original bipartite graph \\(G\\). Just use the undirected versions of the directed edges in \\(H\\). Moreover, every shortest \\(M\\)-augmenting path in \\(G\\) is present in \\(H\\).\n\nThe third phase identifies a maximal set of vertex-disjoint shortest \\(M\\)-augmenting paths. As Figure 25.3 shows, it starts by creating the transpose \\(H^{\\mathrm{T}}\\) of \\(H\\). Then, for each unmatched vertex \\(r\\) in layer \\(q\\), it performs a depth-first search starting from \\(r\\) until it either reaches a vertex in layer \\(0\\) or has exhausted all possible paths without reaching a vertex in layer \\(0\\). Instead of maintaining discovery and finish times, the depth-first search just needs to keep track of the predecessor attributes \\(\\pi\\) in the depth-first tree of each search. Upon reaching a vertex in layer \\(0\\), tracing back along the predecessors identifies an \\(M\\)-augmenting path. Each vertex is searched from only when it is first discovered in any search. If the search from a vertex \\(r\\) in layer \\(q\\) cannot find a path of undiscovered vertices to an undiscovered vertex in layer \\(0\\), then no \\(M\\)-augmenting path including \\(r\\) goes into the maximal set.\n\nFigure 25.3 shows the result of the third phase. The first depth-first search starts from vertex \\(r_{1}\\). It identifies the \\(M\\)-augmenting path \\(\\langle(r_{1},\\,l_{3}),\\,(l_{3},\\,r_{3}),\\,(r_{3},\\,l_{1})\\rangle\\), which is highlighted in orange, and discovers vertices \\(r_{1},\\,l_{3},\\,r_{3}\\), and \\(l_{1}\\). The next depth-first search starts from vertex \\(r_{4}\\). This search first examines the edge \\((r_{4},l_{3})\\), but because \\(l_{3}\\) was already discovered, it backtracks and examines edge \\((r_{4},l_{5})\\). From there, it continues and identifies the \\(M\\)-augmenting path \\(\\langle(r_{4},\\,l_{5}),\\,(l_{5},\\,r_{7}),\\,(r_{7},\\,l_{6})\\rangle\\), which is highlighted in yellow, and discovers vertices \\(r_{4}\\), \\(l_{5}\\), \\(r_{7}\\), and \\(l_{6}\\). The depth-first search from vertex \\(r_{6}\\) gets stuck at vertices \\(l_{3}\\) and \\(l_{5}\\), which have already been discovered, and so this search fails to find a path of undiscovered vertices to a vertex in layer \\(0\\). There is no depth-first search from vertex \\(r_{5}\\) because it is matched, and depth-first searches start from unmatched vertices. Therefore, the maximal set of vertex-disjoint shortest \\(M\\)-augmenting paths found contains just the two \\(M\\)-augmenting paths \\((\\langle r_{1},l_{3}),(l_{3},r_{3}),\\,(r_{3},l_{1})\\rangle\\) and \\(\\langle(r_{4},l_{5}),(l_{5},r_{7}),(r_{7},l_{6})\\rangle\\).\n\nYou might have noticed that in this example, this maximal set of two vertex-disjoint shortest \\(M\\)-augmenting paths is not a maximum set. The graph contains three vertex-disjoint shortest \\(M\\)-augmenting paths: \\(\\langle(r_{1},l_{2}),\\,(l_{2},\\,r_{2}),\\,(r_{2},l_{1})\\rangle\\), \\(\\langle(r_{4},l_{3}),\\,(l_{3},r_{3}),\\,(r_{3},l_{4})\\rangle\\), and \\(\\langle(r_{6},l_{5}),(l_{5},r_{7}),(r_{7},l_{6})\\rangle\\). No matter: the algorithm requires the set of vertex-disjoint shortest \\(M\\)-augmenting paths found in line 3 of Hopcroft-Karp to be only maximal, not necessarily maximum.\n\nIt remains to show that all three phases of line 3 take \\(O(E)\\) time. We assume that in the original bipartite graph \\(G\\), each vertex has at least one incident edge so that \\(|V|=O(E)\\), which in turn implies that \\(|V|+|E|=O(E)\\). The first phase creates the directed graph \\(G_{M}\\) by simply directing each edge of \\(G\\), so that \\(|V_{M}|=|V|\\) and \\(|E_{M}|=|E|\\). The second phase performs a breadth-first search on \\(G_{M}\\), taking \\(O(V_{M}+E_{M})=O(E_{M})=O(E)\\) time. In fact, it can stop once the first distance in the queue within the breadth-first search exceeds the shortest distance \\(q\\) to an unmatched vertex in \\(R\\). The dag \\(H\\) has \\(|V_{H}|\\leq|V_{M}|\\) and \\(|E_{H}|\\leq|E_{M}|\\), so that it takes \\(O(V_{H}+E_{H})=O(E)\\) time to construct. Finally, the third phase performs depth-first searches from the unmatched vertices in layer \\(q\\). Once a vertex is discovered, it is not searched from again, and so the analysis of depth-first search from Section 20.3 applies here: \\(O(V_{H}+E_{H})=O(E)\\). Hence, all three phases take just \\(O(E)\\) time.\n\nOnce the maximal set of vertex-disjoint shortest \\(M\\)-augmenting paths have been found in line 3, updating the matching in line 4 takes \\(O(E)\\) time, as it is just a matter of going through the edges of the \\(M\\)-augmenting paths and adding edges to and removing edges from the matching \\(M\\). Thus, each iteration of the **repeat** loop of lines 2-5 can run in \\(O(E)\\) time.\n\nFigure 25.3: The transpose \\(H^{\\mathrm{T}}\\) of the dag \\(H\\) created in the third phase. The first depth-first search, starting from vertex \\(r_{1}\\), identifies the \\(M\\)-augmenting path \\(\\langle(r_{1},l_{3})\\), \\((l_{3},r_{3})\\), \\((r_{3},l_{1})\\rangle\\) highlighted in orange, and it discovers vertices \\(r_{1},l_{3},r_{3},l_{1}\\). The second depth-first search, starting from vertex \\(r_{4}\\), identifies the \\(M\\)-augmenting path \\(\\langle(r_{4},l_{5})\\),\\((l\\ 5,\\ r_{7})\\),\\((r\\ 7,\\ l_{6})\\rangle\\) highlighted in yellow, discovering vertices \\(r_{4},l_{5},r_{7},l_{6}\\).\n\nIt remains to show that the **repeat** loop iterates \\(O(\\sqrt{V})\\) times. We start with the following lemma, which shows that after each iteration of the **repeat** loop, the length of an augmenting path increases.\n\n**Lemma 25.5**: _Let \\(G=(V,E)\\) be an undirected bipartite graph with matching \\(M\\), and let \\(q\\) be the length of a shortest \\(M\\)-augmenting path. Let \\(\\mathcal{P}=\\{P_{1},P_{2},\\ldots,P_{k}\\}\\) be a maximal set of vertex-disjoint \\(M\\)-augmenting paths of length \\(q\\). Let \\(M^{\\prime}=M\\oplus(P_{1}\\cup P_{2}\\cup\\cdots\\cup P_{k})\\), and suppose that \\(P\\) is a shortest \\(M^{\\prime}\\)-augmenting path. Then \\(P\\) has more than \\(q\\) edges._\n\n_Proof_ We consider separately the cases in which \\(P\\) is vertex-disjoint from the augmenting paths in \\(\\mathcal{P}\\) and in which it is not vertex-disjoint.\n\nFirst, assume that \\(P\\) is vertex-disjoint from the augmenting paths in \\(\\mathcal{P}\\). Then, \\(P\\) contains edges that are in \\(M\\) but are not in any of \\(P_{1},P_{2},\\ldots,P_{k}\\), so that \\(P\\) is also an \\(M\\)-augmenting path. Since \\(P\\) is disjoint from \\(P_{1},P_{2},\\ldots,P_{k}\\) but is also an \\(M\\)-augmenting path, and since \\(\\mathcal{P}\\) is a maximal set of shortest \\(M\\)-augmenting paths, \\(P\\) must be longer than any of the augmenting paths in \\(\\mathcal{P}\\), each of which has length \\(q\\). Therefore, \\(P\\) has more than \\(q\\) edges.\n\nNow, assume that \\(P\\) visits at least one vertex from the \\(M\\)-augmenting paths in \\(\\mathcal{P}\\). By Corollary 25.2, \\(M^{\\prime}\\) is a matching in \\(G\\) with \\(|M^{\\prime}|=|M|+k\\). Since \\(P\\) is an \\(M^{\\prime}\\)-augmenting path, by Lemma 25.1, \\(M^{\\prime}\\oplus P\\) is a matching with \\(|M^{\\prime}\\oplus P|=|M^{\\prime}|+1=|M|+k+1\\). Now let \\(A=M\\oplus M^{\\prime}\\oplus P\\). We claim that \\(A=(P_{1}\\cup P_{2}\\cup\\cdots\\cup P_{k})\\oplus P\\):\n\n\\[A = M\\oplus M^{\\prime}\\oplus P\\] \\[= M\\oplus(M\\oplus(P_{1}\\cup P_{2}\\cup\\cdots\\cup P_{k}))\\oplus P\\] \\[= (M\\oplus M)\\oplus(P_{1}\\cup P_{2}\\cup\\cdots\\cup P_{k})\\oplus P\\] (associativity of \\[\\oplus\\] ) \\[= \\emptyset\\oplus(P_{1}\\cup P_{2}\\cup\\cdots\\cup P_{k})\\oplus P\\] ( \\[X\\oplus X=\\emptyset\\] for all \\[X\\] ) \\[= (P_{1}\\cup P_{2}\\cup\\cdots\\cup P_{k})\\oplus P\\] ( \\[\\emptyset\\oplus X=X\\] for all \\[X\\] ).\n\nLemma 25.3 with \\(M^{*}=M^{\\prime}\\oplus P\\) gives that \\(A\\) contains at least \\(|M^{\\prime}\\oplus P|-|M|=k+1\\) vertex-disjoint \\(M\\)-augmenting paths. Since each such \\(M\\)-augmenting path has at least \\(q\\) edges, we have \\(|A|\\geq(k+1)q=kq+q\\).\n\nNow we claim that \\(P\\) shares at least one edge with some \\(M\\)-augmenting path in \\(\\mathcal{P}\\). Under the matching \\(M^{\\prime}\\), every vertex in each \\(M\\)-augmenting path in \\(\\mathcal{P}\\) is matched. (Only the first and last vertex in each \\(M\\)-augmenting path \\(P_{i}\\) is unmatched under \\(M\\), and under \\(M\\oplus P_{i}\\), all vertices in \\(P_{i}\\) are matched. Because the \\(M\\)-augmenting paths in \\(\\mathcal{P}\\) are vertex-disjoint, no other path in \\(\\mathcal{P}\\) can affect whether the vertices in \\(P_{i}\\) are matched. That is, the vertices in \\(P_{i}\\) are matched under \\((M\\oplus P_{i})\\oplus P_{j}\\) if and only if they are matched under \\(M\\oplus P_{i}\\), for any other path \\(P_{j}\\in\\mathcal{P}\\).) Suppose that \\(P\\) shares a vertex \\(v\\) with some path \\(P_{i}\\in\\mathcal{P}\\). Vertex \\(v\\) cannot be an endpoint of \\(P\\), because the endpoints of \\(P\\) are unmatched under \\(M^{\\prime}\\). Therefore, \\(v\\) has an incident edge in \\(P\\) that belongs to \\(M^{\\prime}\\). Since any vertex has at most one incident edge in a matching, this edge must also belong to \\(P_{i}\\), thus proving the claim.\n\nBecause \\(A=(P_{1}\\cup P_{2}\\cup\\cdots\\cup P_{k})\\oplus P\\) and \\(P\\) shares at least one edge with some \\(P_{i}\\in\\mathcal{P}\\), we have that \\(|A|<|P_{1}\\cup P_{2}\\cup\\cdots\\cup P_{k}|+|P|\\). Thus, we have\n\n\\[kq+q \\leq |A|\\] \\[< |P_{1}\\cup P_{2}\\cup\\cdots\\cup P_{k}|+|P|\\] \\[= kq+|P|\\enspace,\\]\n\nso that \\(q<|P|\\). We conclude that \\(P\\) contains more than \\(q\\) edges.\n\nThe next lemma bounds the size of a maximum matching, based on the length of a shortest augmenting path.\n\n**Lemma 25.6**: _Let \\(M\\) be a matching in graph \\(G=(V,E)\\), and let a shortest \\(M\\)-augmenting path in \\(G\\) contain \\(q\\) edges. Then the size of a maximum matching in \\(G\\) is at most \\(|M|+|V|\\), \\((q+1)\\)._\n\n_Proof_ Let \\(M^{*}\\) be a maximum matching in \\(G\\). By Lemma 25.3, \\(G\\) contains at least \\(|M^{*}|-|M|\\) vertex-disjoint \\(M\\)-augmenting paths. Each of these paths contains at least \\(q\\) edges, and hence at least \\(q+1\\) vertices. Because these paths are vertex-disjoint, we have \\((|M^{*}|-|M|)(q+1)\\leq|V|\\), so that \\(|M^{*}|\\leq|M|+|V|\\), \\((q+1)\\).\n\nThe final lemma bounds the number of iterations of the **repeat** loop of lines 2-5.\n\n**Lemma 25.7**: _When the Hopcroft-Karp procedure runs on an undirected bipartite graph \\(G=(V,E)\\), the **repeat** loop of lines 2-5 iterates \\(O(\\sqrt{V})\\) times._\n\n_Proof_ By Lemma 25.5, the length \\(q\\) of the shortest \\(M\\)-augmenting paths found in line 3 increases from iteration to iteration. After \\(\\left\\lceil\\sqrt{|V|}\\enspace\\right\\rceil\\) iterations, therefore, we must have \\(q\\geq\\left\\lceil\\sqrt{|V|}\\enspace\\right\\rceil\\). Consider the situation after the first time line 4 executes with \\(M\\)-augmenting paths whose length is at least \\(\\left\\lceil\\sqrt{|V|}\\enspace\\right\\rceil\\). Since the size of a matching increases by at least one edge per iteration, Lemma 25.6 implies that the number of additional iterations before achieving a maximum matching is at most\n\n\\[\\frac{|V|}{\\left\\lceil\\sqrt{|V|}\\enspace\\right\\rceil+1}<\\frac{|V|}{\\sqrt{|V|} }=\\sqrt{|V|}\\enspace.\\]Hence, the total number of loop iterations is less than \\(2\\sqrt{|V|}\\).\n\nThus, we have the following bound on the running time of the Hopcroft-Karp procedure.\n\n_Theorem 25.8_\n\nThe procedure Hopcroft-Karp runs in \\(O(\\sqrt{V}E)\\) time on an undirected bipartite graph \\(G=(V,E)\\).\n\n_Proof_ By Lemma 25.7 the **repeat** loop iterates \\(O(\\sqrt{V})\\) times, and we have seen how to implement each iteration in \\(O(E)\\) time.\n\n**Exercises**\n\n_25.1-1_\n\nUse the Hopcroft-Karp algorithm to find a maximum matching for the graph in Figure 25.1.\n\n_25.1-2_\n\nHow are \\(M\\)-augmenting paths and augmenting paths in flow networks similar? How do they differ?\n\n_25.1-3_\n\nWhat is the advantage of searching in the transpose \\(H^{\\mathrm{T}}\\) from unmatched vertices in layer \\(q\\) (the first layer that contains an unmatched vertex in \\(R\\)) to layer 0 versus searching in the \\(\\mathrm{dag}\\)\\(H\\) from layer 0 to layer \\(q\\)?\n\n_25.1-4_\n\nShow how to bound the number of iterations of the the **repeat** loop of lines 2-5 of Hopcroft-Karp by \\(\\left\\lceil 3\\sqrt{|V|}/2\\right\\rceil\\).\n\n\\(\\bigstar\\) _25.1-5_\n\nA **perfect matching** is a matching under which every vertex is matched. Let \\(G=(V,E)\\) be an undirected bipartite graph with vertex partition \\(V=L\\cup R\\), where \\(|L|=|R|\\). For any \\(X\\subseteq V\\), define the **neighborhood** of \\(X\\) as\n\n\\(N(X)=\\left\\{y\\in V:(x,y)\\in E\\text{ for some }x\\in X\\right\\}\\),\n\nthat is, the set of vertices adjacent to some member of \\(X\\). Prove **Hall's theorem**: there exists a perfect matching in \\(G\\) if and only if \\(|A|\\leq|N(A)|\\) for every subset \\(A\\subseteq L\\).\n\n### 25.1-6\n\nIn a _d-regular_ graph, every vertex has degree \\(d\\). If \\(G=(V,E)\\) is bipartite with vertex partition \\(V=L\\cup R\\) and also \\(d\\)-regular, then \\(|L|=|R|\\). Use Hall's theorem (see Exercise 25.1-5) to prove that every \\(d\\)-regular bipartite graph contains a perfect matching. Then use that result to prove that every \\(d\\)-regular bipartite graph contains \\(d\\) disjoint perfect matchings.\n\n### 25.2 The stable-marriage problem\n\nIn Section 25.1, the goal was to find a maximum matching in an undirected bipartite graph. If you know that the graph \\(G=(V,E)\\) with vertex partition \\(V=L\\cup R\\) is a _complete bipartite graph1--_containing an edge from every vertex in \\(L\\) to every vertex in \\(R\\) -- then you can find a maximum matching by a simple greedy algorithm.\n\nFootnote 1: The definition of a complete bipartite graph differs from the definition of complete graph given on page 1167 because in a bipartite graph, there are no edges between vertices in \\(L\\) and no edges between vertices in \\(R\\).\n\nWhen a graph can have several matchings, you might want to decide which matchings are most desirable. In Section 25.3, we'll add weights to the edges and find a matching of maximum weight. In this section, we will instead add some information to each vertex in a complete bipartite graph: a ranking of the vertices in the other side. That is, each vertex in \\(L\\) has an ordered list of all the vertices in \\(R\\), and vice-versa. To keep things simple, let's assume that \\(L\\) and \\(R\\) each contain \\(n\\) vertices. The goal here is to match each vertex in \\(L\\) with a vertex in \\(R\\) in a \"stable\" way.\n\nThis problem derives its name, the _stable-marriage problem_, from the notion of heterosexual marriage, viewing \\(L\\) as a set of women and \\(R\\) as a set of men.2 Each woman ranks all the men in terms of desirability, and each man does the same with all the women. The goal is to pair up women and men (a matching) so that if a woman and a man are not matched to each other, then at least one of them prefers their assigned partner.\n\nFootnote 2: Although marriage norms are changing, it\u2019s traditional to view the stable-marriage problem through the lens of heterosexual marriage.\n\nIf a woman and a man are not matched to each other but each prefers the other over their assigned partner, they form a _blocking pair_. A blocking pair has incentive to opt out of the assigned pairing and get together on their own. If that were to occur, then this pair would block the matching from being \"stable.\" A _stable",
        "chapter": "Part VI Graph Algorithms",
        "section": "25 Matchings in Bipartite Graphs",
        "subsection": "25.1 Maximum bipartite matching (revisited)",
        "subsubsection": "N/A"
    },
    {
        "content": "### 25.1-6\n\nIn a _d-regular_ graph, every vertex has degree \\(d\\). If \\(G=(V,E)\\) is bipartite with vertex partition \\(V=L\\cup R\\) and also \\(d\\)-regular, then \\(|L|=|R|\\). Use Hall's theorem (see Exercise 25.1-5) to prove that every \\(d\\)-regular bipartite graph contains a perfect matching. Then use that result to prove that every \\(d\\)-regular bipartite graph contains \\(d\\) disjoint perfect matchings.\n\n### 25.2 The stable-marriage problem\n\nIn Section 25.1, the goal was to find a maximum matching in an undirected bipartite graph. If you know that the graph \\(G=(V,E)\\) with vertex partition \\(V=L\\cup R\\) is a _complete bipartite graph1--_containing an edge from every vertex in \\(L\\) to every vertex in \\(R\\) -- then you can find a maximum matching by a simple greedy algorithm.\n\nFootnote 1: The definition of a complete bipartite graph differs from the definition of complete graph given on page 1167 because in a bipartite graph, there are no edges between vertices in \\(L\\) and no edges between vertices in \\(R\\).\n\nWhen a graph can have several matchings, you might want to decide which matchings are most desirable. In Section 25.3, we'll add weights to the edges and find a matching of maximum weight. In this section, we will instead add some information to each vertex in a complete bipartite graph: a ranking of the vertices in the other side. That is, each vertex in \\(L\\) has an ordered list of all the vertices in \\(R\\), and vice-versa. To keep things simple, let's assume that \\(L\\) and \\(R\\) each contain \\(n\\) vertices. The goal here is to match each vertex in \\(L\\) with a vertex in \\(R\\) in a \"stable\" way.\n\nThis problem derives its name, the _stable-marriage problem_, from the notion of heterosexual marriage, viewing \\(L\\) as a set of women and \\(R\\) as a set of men.2 Each woman ranks all the men in terms of desirability, and each man does the same with all the women. The goal is to pair up women and men (a matching) so that if a woman and a man are not matched to each other, then at least one of them prefers their assigned partner.\n\nFootnote 2: Although marriage norms are changing, it\u2019s traditional to view the stable-marriage problem through the lens of heterosexual marriage.\n\nIf a woman and a man are not matched to each other but each prefers the other over their assigned partner, they form a _blocking pair_. A blocking pair has incentive to opt out of the assigned pairing and get together on their own. If that were to occur, then this pair would block the matching from being \"stable.\" A _stablematching_, therefore, is a matching that has no blocking pair. If there is a blocking pair, then the matching is _unstable_.\n\nLet's look at an example with four women--Wanda, Emma, Lacey, and Karen--and four men--Oscar, Davis, Brent, and Hank--having the following preferences:\n\nWanda: Brent, Hank, Oscar, Davis\n\nEmma: Davis, Hank, Oscar\n\nLacey: Brent, Davis, Hank, Oscar\n\nKaren: Brent, Hank, Davis, Oscar\n\nOscar: Wanda, Karen, Lacey, Emma\n\nDavis: Wanda, Lacey, Karen, Emma\n\nBrent: Lacey, Karen, Wanda, Emma\n\nHank: Lacey, Wanda, Emma, Karen\n\nA stable matching comprises the following pairs:\n\nLacey and Brent\n\nWanda and Hank\n\nKaren and Davis\n\nEmma and Oscar\n\nYou can verify that this matching has no blocking pair. For example, even though Karen prefers Brent and Hank to her partner Davis, Brent prefers his partner Lacey to Karen, and Hank prefers his partner Wanda to Karen, so that neither Karen and Brent nor Karen and Hank form a blocking pair. In fact, this stable matching is unique. Suppose instead that the last two pairs were\n\nEmma and Davis\n\nKaren and Oscar\n\nThen Karen and Davis would be a blocking pair, because they were not paired together, Karen prefers Davis to Oscar, and Davis prefers Karen to Emma. Therefore, this matching is not stable.\n\nStable matchings need not be unique. For example, suppose that there are three women--Monica, Phoebe, and Rachel--and three men--Chandler, Joey, and Ross--with these preferences:\n\nMonica: Chandler, Joey, Ross, Chandler\n\nRachel: Ross, Chandler, Joey\n\nChandler: Phoebe, Rachel, Monica\n\nJoey: Rachel, Monica, Phoebe\n\nRoss: Monica, Phoebe, Rachel In this case, there are three stable matchings:\n\n\\begin{tabular}{l l l} Matching 1 & Matching 2 & Matching 3 \\\\ \\hline Monica and Chandler & Phoebe and Chandler & Rachel and Joey \\\\ \\end{tabular}\n\n\\begin{tabular}{l l} Rachel and Ross & Monica and Ross & Maching 3 \\\\ \\end{tabular}\n\nIn matching 1, all women get their first choice and all men get their last choice. Matching 2 is the opposite, with all men getting their first choice and all women getting their last choice. When all the women or all the men get their first choice, there plainly cannot be a blocking pair. In matching 3, everyone gets their second choice. You can verify that there are no blocking pairs.\n\nYou might wonder whether it is always possible to come up with a stable matching no matter what rankings each participant provides. The answer is yes. (Exercise 25.2-3 asks you to show that even in the scenario of the National Resident Matching Program, where each hospital takes on multiple students, it is always possible to devise a stable assignment.) A simple algorithm known as the Gale-Shapley algorithm always finds a stable matching. The algorithm has two variants, which mirror each other: \"woman-oriented\" and \"man-oriented.\" Let's examine the woman-oriented version. Each participant is either \"free\" or \"engaged.\" Everyone starts out free. Engagements occur when a free woman proposes to a man. When a man is first proposed to, he goes from free to engaged, and he always stays engaged, though not necessarily to the same woman. If an engaged man receives a proposal from a woman whom he prefers to the woman he's currently engaged to, that engagement is broken, the woman to whom he had been engaged becomes free, and the man and the woman whom he prefers become engaged. Each woman proposes to the men in her preference list, in order, until the last time she becomes engaged. When a woman is engaged, she temporarily stops proposing, but if she becomes free again, she continues down her list. Once everyone is engaged, the algorithm terminates. The procedure Gale-Shapley on the next page makes this process more concrete. The procedure allows for some choice: any free woman may be selected in line 2. We'll see that the procedure produces a stable matching regardless of the order in which line 2 chooses free women. For the man-oriented version, just reverse the roles of men and women in the procedure.\n\nLet's see how the Gale-Shapley procedure executes on the example with Wanda, Emma, Lacey, Karen, Oscar, Davis, Brent, and Hank. After everyone is initialized to free, here is one possible version of what can occur in successive iterations of the **while** loop of lines 2-9:\n\n1. Wanda proposes to Brent. Brent is free, so that Wanda and Brent become engaged and no longer free.\n\n2. Emma proposes to Davis. Davis is free, so that Emma and Davis become engaged and no longer free.\n3. Lacey proposes to Brent. Brent is engaged to Wanda, but he prefers Lacey. Brent breaks the engagement to Wanda, who becomes free. Lacey and Brent become engaged, with Lacey no longer free.\n4. Karen proposes to Brent. Brent is engaged to Lacey, whom he prefers to Karen. Brent rejects Karen, who remains free.\n5. Karen proposes to Hank. Hank is free, so that Karen and Hank become engaged and no longer free.\n6. Wanda proposes to Hank. Hank is engaged to Karen, but he prefers Wanda. Hank breaks the engagement with Karen, who becomes free. Wanda and Hank become engaged, with Wanda no longer free.\n7. Karen proposes to Davis. Davis is engaged to Emma, but he prefers Karen. Davis breaks the engagement to Emma, who becomes free. Karen and Davis become engaged, with Karen no longer free.\n8. Emma proposes to Hank. Hank is engaged to Wanda, whom he prefers to Emma. Hank rejects Emma, who remains free.\n9. Emma proposes to Oscar. Oscar is free, so that Emma and Oscar become engaged and no longer free.\n\nAt this point, everyone is engaged and nobody is free, so the **while** loop terminates. The procedure returns the stable matching we saw earlier.\n\nThe following theorem shows that not only does Gale-Shapley terminate, but that it always returns a stable matching, thereby proving that a stable matching always exists.\n\n**Theorem 25.9**: _The procedure Gale-Shapley always terminates and returns a stable matching._\n\n_Proof_Let's first show that the **while** loop of lines 2-9 always terminates, so that the procedure terminates. The proof is by contradiction. If the loop fails to terminate, it is because some woman remains free. In order for a woman to remain free, she must have proposed to all the men and been rejected by each one. In order for a man to reject a woman, he must be already engaged. Therefore, all the men are engaged. Once engaged, a man stays engaged (though not necessarily to the same woman). There are an equal number \\(n\\) of women and men, however, which means that every woman is engaged, leading to the contradiction that no women are free. We must also show that the **while** loop makes a bounded number of iterations. Since each of the \\(n\\) women goes through her ranking of the \\(n\\) men in order, possibly not reaching the end of her list, the total number of iterations is at most \\(n^{2}\\). Therefore, the **while** loop always terminates, and the procedure returns a matching.\n\nWe need to show that there are no blocking pairs. We first observe that once a man \\(m\\) is engaged to a woman \\(w\\), all subsequent actions for \\(m\\) occur in lines 6-8. Therefore, once a man is engaged, he stays engaged, and any time he breaks an engagement to a woman \\(w\\), it's for a woman whom he prefers to \\(w\\). Suppose that a woman \\(w\\) is matched with a man \\(m\\), but she prefers man \\(m^{\\prime}\\). We'll show that \\(w\\) and \\(m^{\\prime}\\) is not a blocking pair, because \\(m^{\\prime}\\) does not prefer \\(w\\) to his partner. Because \\(w\\) ranks \\(m^{\\prime}\\) higher than \\(m\\), she must have proposed to \\(m^{\\prime}\\) before proposing to \\(m\\), and \\(m^{\\prime}\\) either rejected her proposal or accepted it and later broke the engagement. If \\(m^{\\prime}\\) rejected the proposal from \\(w\\), it is because he was already engaged to some woman he prefers to \\(w\\). If \\(m^{\\prime}\\) accepted and later broke the engagement, he was at some point engaged to \\(w\\) but later accepted a proposal from a woman he prefers to \\(w\\). In either case, he ultimately ends up with a partner whom he prefers to \\(w\\). We conclude that even though \\(w\\) might prefer \\(m^{\\prime}\\) to her partner \\(m\\), it is not also the case that \\(m^{\\prime}\\) prefers \\(w\\) to his partner. Therefore, the procedure returns a matching containing no blocking pairs.\n\nExercise 25.2-1 asks you to provide the proof of the following corollary.\n\n_Corollary 25.10_: Given preference rankings for \\(n\\) women and \\(n\\) men, the Gale-Shapley algorithm can be implemented to run in \\(O(n^{2})\\) time.\n\nBecause line 2 can choose any free woman, you might wonder whether different choices can produce different stable matchings. The answer is no: as the followingtheorem shows, every execution of the Gale-Shapley produces exactly the same result. Moreover, the stable matching returned is optimal for the women.\n\n_Theorem 25.11_: Regardless of how women are chosen in line 2 of Gale-Shapley, the procedure always returns the same stable matching, and in this stable matching, each woman has the best partner possible in any stable matching.\n\n_Proof_ The proof that each woman has the best partner possible in any stable matching is by contradiction. Suppose that the Gale-Shapley procedure returns a stable matching \\(M\\), but that there is a different stable matching \\(M^{\\prime}\\) in which some woman \\(w\\) prefers her partner \\(m^{\\prime}\\) to the partner \\(m\\) she has in \\(M\\). Because \\(w\\) ranks \\(m^{\\prime}\\) higher than \\(m\\), she must have proposed to \\(m^{\\prime}\\) before proposing to \\(m\\). Then there is a woman \\(w^{\\prime}\\) whom \\(m^{\\prime}\\) prefers to \\(w\\), and \\(m^{\\prime}\\) was already engaged to \\(w^{\\prime}\\) when \\(w\\) proposed or \\(m^{\\prime}\\) accepted the proposal from \\(w\\) and later broke the engagement in favor of \\(w^{\\prime}\\). Either way, there is a moment when \\(m^{\\prime}\\) decided against \\(w\\) in favor of \\(w^{\\prime}\\). Now suppose, without loss of generality, that this moment was the first time that any man rejected a partner who belongs to some stable matching.\n\nWe claim that \\(w^{\\prime}\\) cannot have a partner \\(m^{\\prime\\prime}\\) in a stable matching whom she prefers to \\(m^{\\prime}\\). If there were such a man \\(m^{\\prime\\prime}\\), then in order for \\(w^{\\prime}\\) to propose to \\(m^{\\prime}\\), she would have proposed to \\(m^{\\prime\\prime}\\) and been rejected at some point before proposing to \\(m^{\\prime}\\). If \\(m^{\\prime}\\) accepted the proposal from \\(w\\) and later broke it to accept \\(w^{\\prime}\\), then since this was the first rejection in a stable matching, we get the contradiction that \\(m^{\\prime\\prime}\\) could not have rejected \\(w^{\\prime}\\) beforehand. If \\(m^{\\prime}\\) was already engaged to \\(w^{\\prime}\\) when \\(w\\) proposed, then again, \\(m^{\\prime\\prime}\\) could not have rejected \\(w^{\\prime}\\) beforehand, thus proving the claim.\n\nSince \\(w^{\\prime}\\) does not prefer anyone to \\(m^{\\prime}\\) in a stable matching and \\(w^{\\prime}\\) is not matched with \\(m^{\\prime}\\) in \\(M^{\\prime}\\) (because \\(m^{\\prime}\\) is matched with \\(w\\) in \\(M^{\\prime}\\)), \\(w^{\\prime}\\) prefers \\(m^{\\prime}\\) to her partner in \\(M^{\\prime}\\). Since \\(w^{\\prime}\\) prefers \\(m^{\\prime}\\) over her partner in \\(M^{\\prime}\\) and \\(m^{\\prime}\\) prefers \\(w^{\\prime}\\) over his partner \\(w\\) in \\(M^{\\prime}\\), the pair \\(w^{\\prime}\\) and \\(m^{\\prime}\\) is a blocking pair in \\(M^{\\prime}\\). Because \\(M^{\\prime}\\) has a blocking pair, it cannot be a stable matching, thereby contradicting the assumption that there exists some stable matching in which each woman has the best partner possible other than the matching \\(M\\) returned by Gale-Shapley.\n\nWe put no condition on the execution of the procedure, which means that all possible orders in which line 2 selects women result in the same stable matching being returned.\n\n_Corollary 25.12_: There can be stable matchings that the Gale-Shapley procedure does not return.\n\n_Proof_ Theorem 25.11 says that for a given set of rankings, Gale-Shapley returns just one matching, no matter how it chooses women in line 2. The earlier ex ample of three women and three men with three different stable matchings shows that there can be multiple stable matchings for a given set of rankings. A call of Gale-Shapley is capable of returning only one of these stable matchings.\n\nAlthough the Gale-Shapley procedure gives the best possible outcome for the women, the following corollary shows that it also produces the worst possible outcome for the men.\n\n**Corollary 25.13**: _In the stable matching returned by the procedure Gale-Shapley, each man has the worst partner possible in any stable matching._\n\n_Proof_ Let \\(M\\) be the matching returned by a call to Gale-Shapley. Suppose that there is another stable matching \\(M^{\\prime}\\) and a man \\(m\\) who prefers his partner \\(w\\) in \\(M\\) to his partner \\(w^{\\prime}\\) in \\(M^{\\prime}\\). Let the partner of \\(w\\) in \\(M^{\\prime}\\) be \\(m^{\\prime}\\). By Theorem 25.11, \\(m\\) is the best partner that \\(w\\) can have in any stable matching, which means that \\(w\\) prefers \\(m\\) to \\(m^{\\prime}\\). Since \\(m\\) prefers \\(w\\) to \\(w^{\\prime}\\), the pair \\(w\\) and \\(m\\) is a blocking pair in \\(M^{\\prime}\\), contradicting the assumption that \\(M^{\\prime}\\) is a stable matching.\n\n**Exercises**\n\n**25.2-1**: _Describe how to implement the Gale-Shapley algorithm so that it runs in \\(O(n^{2})\\) time._\n\n**25.2-2**: _Is it possible to have an unstable matching with just two women and two men? If so, provide and justify an example. If not, argue why not._\n\n**25.2-3**: _The National Resident Matching Program differs from the scenario for the stable-marriage problem set out in this section in two ways. First, a hospital may be matched with more than one student, so that hospital \\(h\\) takes \\(r_{h}\\geq 1\\) students. Second, the number of students might not equal the number of hospitals. Describe how to modify the Gale-Shapley algorithm to fit the requirements of the National Resident Matching Program._\n\n**25.2-4**: _Prove the following property, which is known as weak Pareto optimality:_\n\nLet \\(M\\) be the stable matching produced by the Gale-Shapley procedure, with women proposing to men. Then, for a given instance of the stable-marriage problem there is no matching -- stable or unstable -- such that every woman has a partner whom she prefers to her partner in the stable matching \\(M\\).\n\n#### 25.2-5\n\nThe _stable-roommates problem_ is similar to the stable-marriage problem, except that the graph is a complete graph, not bipartite, with an even number of vertices. Each vertex represents a person, and each person ranks all the other people. The definitions of blocking pairs and stable matching extend in the natural way: a blocking pair comprises two people who both prefer each other to their current partner, and a matching is stable if there are no blocking pairs. For example, consider four people--Wendy, Xenia, Yolanda, and Zelda--with the following preference lists:\n\nWendy: Xenia, Yolanda, Zelda\n\nXenia: Wendy, Zelda, Yolanda\n\nYolanda: Wendy, Zelda, Xenia\n\nZelda: Xenia, Yolanda, Wendy\n\nYou can verify that the following matching is stable:\n\nWendy and Xenia\n\nYolanda and Zelda\n\nUnlike the stable-marriage problem, the stable-roommates problem can have inputs for which no stable matching exists. Find such an input and explain why no stable matching exists.\n\n### The Hungarian algorithm for the assignment problem\n\nLet us once again add some information to a complete bipartite graph \\(G=(V,E)\\), where \\(V=L\\,\\cup\\,R\\). This time, instead of having the vertices of each side rank the vertices on the other side, we assign a weight to each edge. Again, let's assume that the vertex sets \\(L\\) and \\(R\\) each contain \\(n\\) vertices, so that the graph contains \\(n^{2}\\) edges. For \\(l\\in L\\) and \\(r\\in R\\), denote the weight of edge \\((l,r)\\) by \\(w(l,r)\\), which represents the utility gained by matching vertex \\(l\\) with vertex \\(r\\).\n\nThe goal is to find a perfect matching \\(M^{*}\\) (see Exercises 25.1-5 and 25.1-6) whose edges have the maximum total weight over all perfect matchings. That is, letting \\(w(M)=\\sum_{(l,r)\\in M}w(l,r)\\) denote the total weight of the edges in matching \\(M\\), we want to find a perfect matching \\(M^{*}\\) such that\n\n\\[w(M^{*})=\\max\\left\\{w(M):M\\text{ is a perfect matching}\\right\\}\\.\\]",
        "chapter": "Part VI Graph Algorithms",
        "section": "25 Matchings in Bipartite Graphs",
        "subsection": "25.2 The stable-marriage problem",
        "subsubsection": "N/A"
    },
    {
        "content": "woman has a partner whom she prefers to her partner in the stable matching \\(M\\).\n\n#### 25.2-5\n\nThe _stable-roommates problem_ is similar to the stable-marriage problem, except that the graph is a complete graph, not bipartite, with an even number of vertices. Each vertex represents a person, and each person ranks all the other people. The definitions of blocking pairs and stable matching extend in the natural way: a blocking pair comprises two people who both prefer each other to their current partner, and a matching is stable if there are no blocking pairs. For example, consider four people--Wendy, Xenia, Yolanda, and Zelda--with the following preference lists:\n\nWendy: Xenia, Yolanda, Zelda\n\nXenia: Wendy, Zelda, Yolanda\n\nYolanda: Wendy, Zelda, Xenia\n\nZelda: Xenia, Yolanda, Wendy\n\nYou can verify that the following matching is stable:\n\nWendy and Xenia\n\nYolanda and Zelda\n\nUnlike the stable-marriage problem, the stable-roommates problem can have inputs for which no stable matching exists. Find such an input and explain why no stable matching exists.\n\n### The Hungarian algorithm for the assignment problem\n\nLet us once again add some information to a complete bipartite graph \\(G=(V,E)\\), where \\(V=L\\,\\cup\\,R\\). This time, instead of having the vertices of each side rank the vertices on the other side, we assign a weight to each edge. Again, let's assume that the vertex sets \\(L\\) and \\(R\\) each contain \\(n\\) vertices, so that the graph contains \\(n^{2}\\) edges. For \\(l\\in L\\) and \\(r\\in R\\), denote the weight of edge \\((l,r)\\) by \\(w(l,r)\\), which represents the utility gained by matching vertex \\(l\\) with vertex \\(r\\).\n\nThe goal is to find a perfect matching \\(M^{*}\\) (see Exercises 25.1-5 and 25.1-6) whose edges have the maximum total weight over all perfect matchings. That is, letting \\(w(M)=\\sum_{(l,r)\\in M}w(l,r)\\) denote the total weight of the edges in matching \\(M\\), we want to find a perfect matching \\(M^{*}\\) such that\n\n\\[w(M^{*})=\\max\\left\\{w(M):M\\text{ is a perfect matching}\\right\\}\\.\\]We call finding such a maximum-weight perfect matching the _assignment problem_. A solution to the assignment problem is a perfect matching that maximizes the total utility. Like the stable-marriage problem, the assignment problem finds a matching that is \"good,\" but with a different definition of good: maximizing total value rather than achieving stability.\n\nAlthough you could enumerate all \\(n!\\) perfect matchings to solve the assignment problem, an algorithm known as the _Hungarian algorithm_ solves it much faster. This section will prove an \\(O(n^{4})\\) time bound, and Problem 25-2 asks you to refine the algorithm to reduce the running time to \\(O(n^{3})\\). Instead of working with the complete bipartite graph \\(G\\), the Hungarian algorithm works with a subgraph of \\(G\\) called the \"equality subgraph.\" The equality subgraph, which is defined below, changes over time and has the beneficial property that any perfect matching in the equality subgraph is also an optimal solution to the assignment problem.\n\nThe equality subgraph depends on assigning an attribute \\(h\\) to each vertex. We call \\(h\\) the _label_ of a vertex, and we say that \\(h\\) is a _feasible vertex labeling_ of \\(G\\) if\n\n\\(l.h+r.h\\geq w(l,r)\\) for all \\(l\\in L\\) and \\(r\\in R\\).\n\nA feasible vertex labeling always exists, such as the _default vertex labeling_ given by\n\n\\(l.h\\ =\\ \\max\\,\\{w(l,r):r\\in R\\}\\) for all \\(l\\in L\\),\n\n\\(r.h\\ =\\ 0\\) for all \\(r\\in R\\).\n\nGiven a feasible vertex labeling \\(h\\), the _equality subgraph_\\(G_{h}=(V,E_{h})\\) of \\(G\\) consists of the same vertices as \\(G\\) and the subset of edges\n\n\\(E_{h}=\\{(l,r)\\in E:l.h+r.h=w(l,r)\\}\\).\n\nThe following theorem ties together a perfect matching in an equality subgraph and an optimal solution to the assignment problem.\n\n**Theorem 25.14**: _Let \\(G=(V,E)\\), where \\(V=L\\cup R\\), be a complete bipartite graph where each edge \\((l,r)\\in E\\) has weight \\(w(l,r)\\). Let \\(h\\) be a feasible vertex labeling of \\(G\\) and \\(G_{h}\\) be the equality subgraph of \\(G\\). If \\(G_{h}\\) contains a perfect matching \\(M^{*}\\), then \\(M^{*}\\) is an optimal solution to the assignment problem on \\(G\\)._\n\n_Proof_ If \\(G_{h}\\) contains a perfect matching \\(M^{*}\\), then because \\(G_{h}\\) and \\(G\\) have the same sets of vertices, \\(M^{*}\\) is also a perfect matching in \\(G\\). Because each edge of \\(M^{*}\\) belongs to \\(G_{h}\\) and each vertex has exactly one incident edge from any perfect matching, we have \\[w(M^{*}) = \\sum_{(l,r)\\in M^{*}}w(l,r)\\] \\[= \\sum_{(l,r)\\in M^{*}}(l.h+r.h)\\quad\\mbox{(because all edges in $M^{*}$ belong to $G_{h}$)}\\] \\[= \\sum_{l\\in L}l.h+\\sum_{r\\in R}r.h\\quad\\mbox{(because $M^{*}$ is a perfect matching)}\\.\\]\n\nLetting \\(M\\) be any perfect matching in \\(G\\), we have\n\n\\[w(M) = \\sum_{(l,r)\\in M}w(l,r)\\] \\[\\leq \\sum_{(l,r)\\in M}(l.h+r.h)\\quad\\mbox{(because $h$ is a feasible vertex labeling)}\\] \\[= \\sum_{l\\in L}l.h+\\sum_{r\\in R}r.h\\quad\\mbox{(because $M$ is a perfect matching)}\\.\\]\n\nThus, we have\n\n\\[w(M)\\leq\\sum_{l\\in L}l.h+\\sum_{r\\in R}r.h=w(M^{*})\\, \\tag{25.3}\\]\n\nso that \\(M^{*}\\) is a maximum-weight perfect matching in \\(G\\).\n\nThe goal now becomes finding a perfect matching in an equality subgraph. Which equality subgraph? It does not matter! We have free rein to not only choose an equality subgraph, but to change which equality subgraph we choose as we go along. We just need to find _some_ perfect matching in _some_ equality subgraph.\n\nTo understand the equality subgraph better, consider again the proof of Theorem 25.14 and, in the second half, let \\(M\\) be any matching. The proof is still valid, in particular, inequality (25.3): the weight of any matching is always at most the sum of the vertex labels. If we choose any set of vertex labels that define an equality subgraph, then a maximum-cardinality matching in this equality subgraph has total value at most the sum of the vertex labels. If the set of vertex labels is the \"right\" one, then it will have total value equal to \\(w(M^{*})\\), and a maximum-cardinality matching in the equality subgraph is also a maximum-weight perfect matching. The Hungarian algorithm repeatedly modifies the matching and the vertex labels in order to achieve this goal.\n\nThe Hungarian algorithm starts with any feasible vertex labeling \\(h\\) and any matching \\(M\\) in the equality subgraph \\(G_{h}\\). It repeatedly finds an \\(M\\)-augmenting path \\(P\\) in \\(G_{h}\\) and, using Lemma 25.1, updates the matching to be \\(M\\oplus P\\), thereby incrementing the size of the matching. As long as there is some equality subgraph that contains an \\(M\\)-augmenting path, the size of the matching can increase, until a perfect matching is achieved.\n\nFour questions arise:\n\n1. What initial feasible vertex labeling should the algorithm start with? Answer: the default vertex labeling given by equations (25.1) and (25.2).\n2. What initial matching in \\(G_{h}\\) should the algorithm start with? Short answer: any matching, even an empty matching, but a greedy maximal matching works well.\n3. If an \\(M\\)-augmenting path exists in \\(G_{h}\\), how to find it? Short answer: use a variant of breadth-first search similar to the second phase of the procedure used in the Hopcroft-Karp algorithm to find a maximal set of shortest \\(M\\)-augmenting paths.\n4. What if the search for an \\(M\\)-augmenting path fails? Short answer: update the feasible vertex labeling to bring in at least one new edge.\n\nWe'll elaborate on the short answers using the example that starts in Figure 25.4. Here, \\(L=\\{l_{1},l_{2},\\ldots,l_{7}\\}\\) and \\(R=\\{r_{1},r_{2},\\ldots,r_{7}\\}\\). The edge weights appear in the matrix shown in part (a), where the weight \\(w(l_{i},r_{j})\\) appears in row \\(i\\) and column \\(j\\). The feasible vertex labels, given by the default vertex labeling, appear to the left of and above the matrix. Matrix entries in red indicate edges \\((l_{i},r_{j})\\) for which \\(l_{i}.h+r_{j}.h=w(l_{i},r_{j})\\), that is, edges in the equality subgraph \\(G_{h}\\) appearing in part (b) of the figure.\n\n##### Greedy maximal bipartite matching\n\nThere are several ways to implement a greedy method to find a maximal bipartite matching. The procedure Greedy-Bipartite-Matching shows one. Edges in Figure 25.4(b) highlighted in blue indicate the initial greedy maximal matching in \\(G_{h}\\). Exercise 25.3-2 asks you to show that the Greedy-Bipartite-Matching procedure returns a matching that is at least half the size of a maximum matching.\n\n##### Greedy-Bipartite-Matching\\((G)\\)\n\n```\n1\\(M=\\emptyset\\)\n2foreach vertex \\(l\\in L\\)\n3if\\(l\\) has an unmatched neighbor in \\(R\\)\n4 choose any such unmatched neighbor \\(r\\in R\\)\n5\\(M=M\\cup\\{(l,r)\\}\\)\n6return\\(M\\)\n```\n\n**Algorithm 2** Greedy-Bipartite-Matching\\((G)\\)\n\n```\n\n[MISSING_PAGE_POST]\n\n#### Finding an \\(M\\)-augmenting path in \\(G_{h}\\)\n\nTo find an \\(M\\)-augmenting path in the equality subgraph \\(G_{h}\\) with a matching \\(M\\), the Hungarian algorithm first creates the _directed equality subgraph_\\(G_{M,h}\\) from \\(G_{h}\\), just as the Hopcroft-Karp algorithm creates \\(G_{M}\\) from \\(G\\). As in the Hopcroft-Karp algorithm, you can think of an \\(M\\)-augmenting path as starting from an unmatched vertex in \\(L\\), ending at an unmatched vertex in \\(R\\), taking unmatched edges from \\(L\\) to \\(R\\), and taking matched edges from \\(R\\) to \\(L\\). Thus, \\(G_{M,h}=(V,E_{M,h})\\), where\n\n\\[E_{M,h} = \\{(l,r):l\\in L,r\\in R,\\text{ and }(l,r)\\in E_{h}-M\\}\\] (edges from\n\n\\[L\\]\n\n to\n\n\\[R\\]\n\n) \\[\\cup\\{(r,l):r\\in R,l\\in L,\\text{ and }(l,r)\\in M\\}\\] (edges from\n\n\\[R\\]\n\n to\n\n\\[L\\]\n\n). Because an \\(M\\)-augmenting path in the directed equality subgraph \\(G_{M.h}\\) is also an \\(M\\)-augmenting path in the equality subgraph \\(G_{h}\\), it suffices to find \\(M\\)-augmenting paths in \\(G_{M.h}\\). Figure 25.4(c) shows the directed equality subgraph \\(G_{M,h}\\) corresponding to the equality subgraph \\(G_{h}\\) and matching \\(M\\) from part (b) of the figure.\n\nFigure 25.4: The start of the Hungarian algorithm. **(a)** The matrix of edge weights for a bipartite graph with \\(L=\\{l_{1},l_{2},\\ldots,l_{7}\\}\\) and \\(R=\\{r_{1},r_{2},\\ldots,r_{7}\\}\\). The value in row \\(i\\) and column \\(j\\) indicates \\(w(l_{j},r_{j})\\). Feasible vertex labels appear above and next to the matrix. Red entries correspond to edges in the equality subgraph. **(b)** The equality subgraph \\(G_{h}\\). Edges highlighted in blue belong to the initial greedy maximal matching \\(M\\). Blue vertices are matched, and tan vertices are unmatched. **(c)** The directed equality subgraph \\(G_{M,h}\\) created from \\(G_{h}\\) by directing edges in \\(M\\) from \\(R\\) to \\(L\\) and all other edges from \\(L\\) to \\(R\\).\n\nWith the directed equality subgraph \\(G_{M,h}\\) in hand, the Hungarian algorithm searches for an \\(M\\)-augmenting path from any unmatched vertex in \\(L\\) to any unmatched vertex in \\(R\\). Any exhaustive graph-search method suffices. Here, we'll use breadth-first search, starting from all the unmatched vertices in \\(L\\) (just as the Hopcroft-Karp algorithm does when creating the \\(\\operatorname{\\mathrm{dag}}\\,H\\)), but stopping upon first discovering some unmatched vertex in \\(R\\). Figure 25.5 shows the idea. To start from all the unmatched vertices in \\(L\\), initialize the first-in, first-out queue with all the unmatched vertices in \\(L\\), rather than just one source vertex. Unlike the \\(\\operatorname{\\mathrm{dag}}\\,H\\) in the Hopcroft-Karp algorithm, here each vertex needs just one predecessor, so that the breadth-first search creates a _breadth-first forest_\\(F=(V_{F},E_{F})\\). Each unmatched vertex in \\(L\\) is a root in \\(F\\).\n\nIn Figure 25.5(g), the breadth-first search has found the \\(M\\)-augmenting path \\(\\langle(l_{4},r_{2}),(r_{2},l_{1}),(l_{1},r_{3}),(r_{3},l_{6}),(l_{6},r_{5})\\rangle\\). Figure 25.6(a) shows the new matching created by taking the symmetric difference of the matching \\(M\\) in Figure 25.5(a) with this \\(M\\)-augmenting path.\n\n### When the search for an \\(M\\)-augmenting path fails\n\nHaving updated the matching \\(M\\) from an \\(M\\)-augmenting path, the Hungarian algorithm updates the directed equality subgraph \\(G_{M,h}\\) according to the new matching and then starts a new breadth-first search from all the unmatched vertices in \\(L\\). Figure 25.6 shows the start of this process, picking up from Figure 25.5.\n\nIn Figure 25.6(d), the queue contains vertices \\(l_{4}\\) and \\(l_{3}\\). Neither of these vertices has an edge that leaves it, however, so that once these vertices are removed from the queue, the queue becomes empty. The search terminates at this point, before discovering an unmatched vertex in \\(R\\) to yield an \\(M\\)-augmenting path. Whenever this situation occurs, the most recently discovered vertices must belong to \\(L\\). Why? Whenever an unmatched vertex in \\(R\\) is discovered, the search has found an \\(M\\)-augmenting path, and when a matched vertex in \\(R\\) is discovered, it has an unvisited neighbor in \\(L\\), which the search can then discover.\n\nRecall that we have the freedom to work with any equality subgraph. We can change the directed equality subgraph \"on the fly,\" as long we do not counteract the work already done. The Hungarian algorithm updates the feasible vertex labeling \\(h\\) to fulfill the following criteria:\n\n1. No edge in the breadth-first forest \\(F\\) leaves the directed equality subgraph.\n2. No edge in the matching \\(M\\) leaves the directed equality subgraph.\n3. At least one edge \\((l,r)\\), where \\(l\\in L\\cap V_{F}\\) and \\(r\\in R-V_{F}\\) goes into \\(E_{h}\\), and hence into \\(E_{M,h}\\). Therefore, at least one vertex in \\(R\\) will be newly discovered.\n\nThus, at least one new edge enters the directed equality subgraph, and any edge that leaves the directed equality subgraph belongs to neither the matching \\(M\\) nor \n\n#### The Hungarian algorithm for the assignment problem\n\nFigure 25.5: Finding an \\(M\\)-augmenting path in \\(G_{M,h}\\) by breadth-first search. **(a)** The directed equality subgraph \\(G_{M,h}\\) from Figure 25.4(c). **(b)\u2013(g)** Successive versions of the breadth-first forest \\(F\\), shown as the vertices at each distance from the roots \u2014the unmatched vertices in \\(L\\) \u2014 are discovered. In parts (b)\u2013(f), the layer of vertices closest to the bottom of the figure are those in the first-in, first-out queue. For example, in part (b), the queue contains the roots \\(\\langle l_{4},l_{5},l_{7}\\rangle\\), and in part (e), the queue contains \\(\\langle r_{3},r_{4}\\rangle\\), at distance 3 from the roots. In part (g), the unmatched vertex \\(r_{5}\\) is discovered, so the breadth-first search terminates. The path \\(\\langle(l_{4},r_{2}),(r_{2},l_{1}),(l_{1},r_{3}),(r_{3},l_{6}),(l_{6},r_{5})\\rangle\\), highlighted in orange in parts (a) and (g), is an \\(M\\)-augmenting path. Taking its symmetric difference with the matching \\(M\\) yields a new matching with one more edge than \\(M\\).\n\nthe breadth-first forest \\(F\\). Newly discovered vertices in \\(R\\) are enqueued, but their distances are not necessarily \\(1\\) greater than the distances of the most recently discovered vertices in \\(L\\).\n\nTo update the feasible vertex labeling, the Hungarian algorithm first computes the value\n\n\\[\\delta=\\min\\left\\{l.h+r.h-w(l,r):l\\in F_{L}\\text{ and }r\\in R-F_{R}\\right\\}\\, \\tag{25.4}\\]\n\nwhere \\(F_{L}=L\\cap V_{F}\\) and \\(F_{R}=R\\cap V_{F}\\) denote the vertices in the breadth-first forest \\(F\\) that belong to \\(L\\) and \\(R\\), respectively. That is, \\(\\delta\\) is the smallest difference by which an edge incident on a vertex in \\(F_{L}\\) missed being in the current equality subgraph \\(G_{h}\\). The Hungarian algorithm then creates a new feasible vertex labeling, say \\(h^{\\prime}\\), by subtracting \\(\\delta\\) from \\(l.h\\) for all vertices \\(l\\in F_{L}\\) and adding \\(\\delta\\) to \\(r.h\\) for all vertices \\(r\\in F_{R}\\):\n\n\\[v.h^{\\prime}=\\left\\{\\begin{array}{ll}v.h-\\delta&\\text{if }v\\in F_{L}\\,\\\\ v.h+\\delta&\\text{if }v\\in F_{R}\\,\\\\ v.h&\\text{otherwise (}v\\in V-V_{F}\\.\\end{array}\\right. \\tag{25.5}\\]\n\nFigure 25.6: **(a)** The new matching \\(M\\) and the new directed equality subgraph \\(G_{M.h}\\) after updating the matching in Figure 25.5(a) with the \\(M\\)-augmenting path in Figure 25.5(g). **(b)\u2013(d)** Successive versions of the breadth-first forest \\(F\\) in a new breadth-first search with roots \\(l_{5}\\) and \\(l_{7}\\). After the vertices \\(l_{4}\\) and \\(l_{3}\\) in part (d) have been removed from the queue, the queue becomes empty before the search can discover an unmatched vertex in \\(R\\).\n\nThe following lemma shows that these changes achieve the three criteria above.\n\n**Lemma 25.15**: _Let \\(h\\) be a feasible vertex labeling for the complete bipartite graph \\(G\\) with equality subgraph \\(G_{h}\\), and let \\(M\\) be a matching for \\(G_{h}\\) and \\(F\\) be a breadth-first forest being constructed for the directed equality subgraph \\(G_{M,h}\\). Then, the labeling \\(h^{\\prime}\\) in equation (25.5) is a feasible vertex labeling for \\(G\\) with the following properties:_\n\n1. _If_ \\((u,v)\\) _is an edge in the breadth-first forest_ \\(F\\) _for_ \\(G_{M,h}\\)_, then_ \\((u,v)\\in E_{M,h^{\\prime}}\\)_._\n2. _If_ \\((l,r)\\) _belongs to the matching_ \\(M\\) _for_ \\(G_{h}\\)_, then_ \\((r,l)\\in E_{M,h^{\\prime}}\\)_._\n3. _There exist vertices_ \\(l\\in F_{L}\\) _and_ \\(r\\in R-F_{R}\\) _such that_ \\((l,r)\\notin E_{M,h}\\) _but_ \\((l,r)\\in E_{M,h^{\\prime}}\\)_._\n\nProofWe first show that \\(h^{\\prime}\\) is a feasible vertex labeling for \\(G\\). Because \\(h\\) is a feasible vertex labeling, we have \\(l.h+r.h\\geq w(l,r)\\) for all \\(l\\in L\\) and \\(r\\in R\\). In order for \\(h^{\\prime}\\) to not be a feasible vertex labeling, we would need \\(l.h^{\\prime}+r.h^{\\prime}<l.h+r.h\\) for some \\(l\\in L\\) and \\(r\\in R\\). The only way this could occur would be for some \\(l\\in F_{L}\\) and \\(r\\in R-F_{R}\\). In this instance, the amount of the decrease equals \\(\\delta\\), so that \\(l.h^{\\prime}+r.h^{\\prime}=l.h-\\delta+r.h\\). By equation (25.4), we have that \\(l.h-\\delta+r.h\\geq w(l,r)\\) for any \\(l\\in F_{L}\\) and \\(r\\in R-F_{R}\\), so that \\(l.h^{\\prime}+r.h^{\\prime}\\geq w(l,r)\\). For all other edges, we have \\(l.h^{\\prime}+r.h^{\\prime}\\geq l.h+r.h\\geq w(l,r)\\). Thus, \\(h^{\\prime}\\) is a feasible vertex labeling.\n\nNow we show that each of the three desired properties holds:\n\n1. If \\(l\\in F_{L}\\) and \\(r\\in F_{R}\\), then we have \\(l.h^{\\prime}+r.h^{\\prime}=l.h+r.h\\) because \\(\\delta\\) is added to the label of \\(l\\) and subtracted from the label of \\(r\\). Therefore, if an edge belongs to \\(F\\) for the directed graph \\(G_{M,h}\\), it also belongs to \\(G_{M,h^{\\prime}}\\).\n2. We claim that at the time the Hungarian algorithm computes the new feasible vertex labeling \\(h^{\\prime}\\), for every edge \\((l,r)\\in M\\), we have \\(l\\in F_{L}\\) if and only if \\(r\\in F_{R}\\). To see why, consider a matched vertex \\(r\\) and let \\((l,r)\\in M\\). First suppose that \\(r\\in F_{R}\\), so that the search discovered \\(r\\) and enqueued it. When \\(r\\) was removed from the queue, \\(l\\) was discovered, so \\(l\\in F_{L}\\). Now suppose that \\(r\\notin F_{R}\\), so \\(r\\) is undiscovered. We will show that \\(l\\notin F_{L}\\). The only edge in \\(G_{M,h}\\) that enters \\(l\\) is \\((r,l)\\), and since \\(r\\) is undiscovered, the search has not taken this edge; if \\(l\\in F_{L}\\), it is not because of the edge \\((r,l)\\). The only other way that a vertex in \\(L\\) can be in \\(F_{L}\\) is if it is a root of the search, but only unmatched vertices in \\(L\\) are roots and \\(l\\) is matched. Thus, \\(l\\notin F_{L}\\), and the claim is proved. We already saw that \\(l\\in F_{L}\\) and \\(r\\in F_{R}\\) implies \\(l.h^{\\prime}+r.h^{\\prime}=l.h+r.h\\). For the opposite case, when \\(l\\in L-F_{L}\\) and \\(R\\in R-F_{R}\\), we have that \\(l.h^{\\prime}=l.h\\) and \\(r.h^{\\prime}=r.h\\), so that again \\(l.h^{\\prime}+r.h^{\\prime}=l.h+r.h\\). Thus, if edge \\((l,r)\\) is in the matching \\(M\\) for the equality graph \\(G_{h}\\), then \\((r,l)\\in E_{M,h^{\\prime}}\\).\n\n3. Let \\((l,r)\\) be an edge not in \\(E_{h}\\) such that \\(l\\in F_{L}\\), \\(r\\in R-F_{R}\\), and \\(\\delta=l.h+r.h-w(l,r)\\). By the definition of \\(\\delta\\), there is at least one such edge. Then, we have \\[l.h^{\\prime}+r.h^{\\prime} = l.h-\\delta+r.h\\] \\[= l.h-(l.h+r.h-w(l,r))+r.h\\] \\[= w(l,r)\\,\\] and thus \\((l,r)\\in E_{h^{\\prime}}\\). Since \\((l,r)\\) is not in \\(E_{h}\\), it is not in the matching \\(M\\), so that in \\(E_{M,h^{\\prime}}\\) it must be directed from \\(L\\) to \\(R\\). Thus, \\((l,r)\\in E_{M,h^{\\prime}}\\).\n\nIt is possible for an edge to belong to \\(E_{M,h}\\) but not to \\(E_{M,h^{\\prime}}\\). By Lemma 25.15, any such edge belongs neither to the matching \\(M\\) nor to the breadth-first forest \\(F\\) at the time that the new feasible vertex labeling \\(h^{\\prime}\\) is computed. (See Exercise 25.3-3.)\n\nGoing back to Figure 25.6(d), the queue became empty before an \\(M\\)-augmenting path was found. Figure 25.7 shows the next steps taken by the algorithm. The value of \\(\\delta=1\\) is achieved by the edge \\((l_{5},r_{3})\\) because in Figure 25.4(a), \\(l_{5}.h+r_{3}.h-w(l_{5},r_{3})=6+0-5=1\\). In Figure 25.7(a), the values of \\(l_{3}.h\\), \\(l_{4}.h\\), \\(l_{5}.h\\), and \\(l_{7}.h\\) have decreased by \\(1\\) and the values of \\(r_{2}.h\\) and \\(r_{7}.h\\) have increased by \\(1\\) because these vertices are in \\(F\\). As a result, the edges \\((l_{1},r_{2})\\) and \\((l_{6},r_{7})\\) leave \\(G_{M,h}\\) and the edge \\((l_{5},r_{3})\\) enters. Figure 25.7(b) shows the new directed equality subgraph \\(G_{M,h}\\). With edge \\((l_{5},r_{3})\\) now in \\(G_{M,h}\\), Figure 25.7(c) shows that this edge is added to the breadth-first forest \\(F\\), and \\(r_{3}\\) is added to the queue. Parts (c)-(f) show the breadth-first forest continuing to be built until in part (f), the queue once again becomes empty after vertex \\(l_{2}\\), which has no edges leaving, is removed. Again, the algorithm must update the feasible vertex labeling and the directed equality subgraph. Now the value of \\(\\delta=1\\) is achieved by three edges: \\((l_{1},r_{6})\\), \\((l_{5},r_{6})\\), and \\((l_{7},r_{6})\\).\n\nAs Figure 25.8 shows in parts (a) and (b), these edges enter \\(G_{M,h}\\), and edge \\((l_{6},r_{3})\\) leaves. Part (c) shows that edge \\((l_{1},r_{6})\\) is added to the breadth-first forest. (Either of edges \\((l_{5},r_{6})\\) or \\((l_{7},r_{6})\\) could have been added instead.) Because \\(r_{6}\\) is unmatched, the search has found the \\(M\\)-augmenting path \\(\\langle(l_{5},r_{3}),(r_{3},l_{1}),(l_{1},r_{6})\\rangle,\\) highlighted in orange.\n\nFigure 25.9(a) shows \\(G_{M,h}\\) after the matching \\(M\\) has been updated by taking its symmetric difference with the \\(M\\)-augmenting path. The Hungarian algorithm starts its last breadth-first search, with vertex \\(l_{7}\\) as the only root. The search proceeds as shown in parts (b)-(h) of the figure, until the queue becomes empty after removing \\(l_{4}\\). This time, we find that \\(\\delta=2\\), achieved by the five edges \\((l_{2},r_{5})\\), \\((l_{3},r_{1})\\), \\((l_{4},r_{5})\\), \\((l_{5},r_{1})\\), and \\((l_{5},r_{5})\\), each of which enters \\(G_{M,h}\\). Figure 25.10(a) shows the results of decreasing the feasible vertex label of each vertex in \\(F_{L}\\) by \\(2\\) and increasing the feasible vertex label of each vertex in\n\nby 2, and Figure 25.10(b) shows the resulting directed equality subgraph \\(G_{M,h}\\). Part (c) shows that edge \\((l_{3},r_{1})\\) is added to the breadth-first forest. Since \\(r_{1}\\) is an unmatched vertex, the search terminates, having found the \\(M\\)-augmenting path \\(\\left\\langle(l_{7},r_{7}),(r_{7},l_{3}),(l_{3},r_{1})\\right\\rangle,\\) highlighted in orange. If \\(r_{1}\\) had been matched, vertex \\(r_{5}\\) would also have been added to the breadth-first forest, with any of \\(l_{2}\\), \\(l_{4}\\), or \\(l_{5}\\) as its parent.\n\nAfter updating the matching \\(M\\), the algorithm arrives at the perfect matching shown for the equality subgraph \\(G_{h}\\) in Figure 25.11. By Theorem 25.14, the edges in \\(M\\) form an optimal solution to the original assignment problem given in the matrix. Here, the weights of edges \\((l_{1},r_{6})\\), \\((l_{2},r_{4})\\), \\((l_{3},r_{1})\\), \\((l_{4},r_{2})\\), \\((l_{5},r_{3})\\), \\((l_{6},r_{5})\\), and \\((l_{7},r_{7})\\) sum to 65, which is the maximum weight of any matching.\n\nThe weight of the maximum-weight matching equals the sum of all the feasible vertex labels. These problems--maximizing the weight of a matching and mini\n\nFigure 25.7: Updating the feasible vertex labeling and the directed equality subgraph \\(G_{M,h}\\) when the queue becomes empty before finding an \\(M\\)-augmenting path. **(a)** With \\(\\delta=1\\), the values of \\(l_{3}.h\\), \\(l_{4}.h\\), \\(l_{5}.h\\), and \\(l_{7}.h\\) decreased by 1 and \\(r_{2}.h\\) and \\(r_{7}.h\\) increased by 1. Edges \\((l_{1},r_{2})\\) and \\((l_{6},r_{7})\\) leave \\(G_{M,h}\\), and edge \\((l_{5},r_{3})\\) enters. These changes are highlighted in yellow. **(b)** The resulting directed equality subgraph \\(G_{M,h}\\). **(c)\u2013(f)** With edge \\((l_{5},r_{3})\\) added to the breadth-first forest and \\(r_{3}\\) added to the queue, the breadth-first search continues until the queue once again becomes empty in part (f).\n\nmizing the sum of the feasible vertex labels -- are \"duals\" of each other, in a similar vein to how the value of a maximum flow equals the capacity of a minimum cut. Section 29.3 explores duality in more depth.\n\n### The Hungarian algorithm\n\nThe procedure Hungarian on page 737 and its subroutine Find-Augmenting-Path on page 738 follow the steps we have just seen. The third property in Lemma 25.15 ensures that in line 23 of Find-Augmenting-Path the queue is nonempty. The pseudocode uses the attribute \\(\\pi\\) to indicate predecessor vertices in the breadth-first forest. Instead of coloring vertices, as in the BFS procedure on page 556, the search puts the discovered vertices into the sets \\(F_{L}\\) and \\(F_{R}\\). Because the Hungarian algorithm does not need breadth-first distances, the pseudocode omits the \\(d\\) attribute computed by the BFS procedure.\n\nFigure 25.8: Another update to the feasible vertex labeling and directed equality subgraph \\(G_{M,h}\\) because the queue became empty before finding an \\(M\\)-augmenting path. **(a)** With \\(\\delta=1\\), the values of \\(l_{1}\\). \\(h\\), \\(l_{2}\\). \\(h\\), \\(l_{3}\\). \\(h\\), \\(l_{4}\\). \\(h\\), \\(l_{5}\\). \\(h\\), and \\(l_{7}\\). \\(h\\) decrease by \\(1\\), and \\(r_{2}\\). \\(h\\), \\(r_{3}\\). \\(h\\), \\(r_{4}\\). \\(h\\), and \\(r_{7}\\). \\(h\\) increase by \\(1\\). Edge \\((l_{6},r_{3})\\) leaves \\(G_{M,h}\\), and edges \\((l_{1},r_{6})\\), \\((l_{5},r_{6})\\) and \\((l_{7},r_{6})\\) enter. **(b)** The resulting directed equality subgraph \\(G_{M,h}\\). **(c)** With edge \\((l_{1},r_{6})\\) added to the breadth-first forest and \\(r_{6}\\) unmatched, the search terminates, having found the \\(M\\)-augmenting path \\(\\langle(l_{5},r_{3}),(r_{3},l_{1}),(l_{1},r_{6})\\rangle\\), highlighted in orange in parts (b) and (c).\n\n### 25.3 The Hungarian algorithm for the assignment problem\n\nNow, let's see why the Hungarian algorithm runs in \\(O(n^{4})\\) time, where \\(|V|=n/2\\) and \\(|E|=n^{2}\\) in the original graph \\(G\\). (Below we outline how to reduce the running time to \\(O(n^{3})\\).) You can go through the pseudocode of Hungarian to verify that lines 1-6 and 11 take \\(O(n^{2})\\) time. The **while** loop of lines 7-10 iterates at most \\(n\\) times, since each iteration increases the size of the matching \\(M\\) by 1. Each test in line 7 can take constant time by just checking whether \\(|M|<n\\), each update of \\(M\\) in line 9 takes \\(O(n)\\) time, and the updates in line 10 take \\(O(n^{2})\\) time.\n\nTo achieve the \\(O(n^{4})\\) time bound, it remains to show that each call of Find-Augmenting-Path runs in \\(O(n^{3})\\) time. Let's call each execution of lines 10-22\n\nFigure 25.9: **(a)** The new matching \\(M\\) and the new directed equality subgraph \\(G_{M,h}\\) after updating the matching in Figure 25.8 with the \\(M\\)-augmenting path in Figure 25.8 parts (b) and (c). **(b)\u2013(h)** Successive versions of the breadth-first forest \\(F\\) in a new breadth-first search with root \\(l_{7}\\). After the vertex \\(l_{4}\\) in part (h) has been removed from the queue, the queue becomes empty before the search discovers an unmatched vertex in \\(R\\).\n\na _growth step_. Ignoring the growth steps, you can verify that Find-Augmenting-Path is a breadth-first search. With the sets \\(F_{L}\\) and \\(F_{R}\\) represented appropriately, the breadth-first search takes \\(O(V+E)=O(n^{2})\\) time. Within a call of Find-Augmenting-Path, at most \\(n\\) growth steps can occur, since each growth step is guaranteed to discover at least one vertex in \\(R\\). Since there are at most \\(n^{2}\\) edges in \\(G_{M,h}\\), the **for** loop of lines 16-22 iterates at most \\(n^{2}\\) times per call of Find-Augmenting-Path. The bottleneck is lines 10 and 15, which take \\(O(n^{2})\\) time, so that Find-Augmenting-Path takes \\(O(n^{3})\\) time.\n\nExercise 25.3-5 asks you to show that reconstructing the directed equality subgraph \\(G_{M,h}\\) in line 15 is actually unnecessary, so that its cost can be eliminated. Reducing the cost of computing \\(\\delta\\) in line 10 to \\(O(n)\\) takes a little more effort and is the subject of Problem 25-2. With these changes, each call of Find-Augmenting-Path takes \\(O(n^{2})\\) time, so that the Hungarian algorithm runs in \\(O(n^{3})\\) time.\n\n#### The Hungarian algorithm for the assignment problem\n\nFigure 25.11: The final matching, shown for the equality subgraph \\(G_{h}\\) with blue edges and blue entries in the matrix. The weights of the edges in the matching sum to \\(65\\), which is the maximum for any matching in the original complete bipartite graph \\(G\\), as well as the sum of all the final feasible vertex labels.\n\n### Exercises\n\n#### 25.3-1\n\nThe Find-Augmenting-Path procedure checks in two places (lines 19 and 31) whether a vertex it discovers in \\(R\\) is unmatched. Show how to rewrite the pseudocode so that it checks for an unmatched vertex in \\(R\\) in only one place. What is the downside of doing so?\n\n#### 25.3-2\n\nShow that for any bipartite graph, the Greedy-Bipartite-Matching procedure on page 726 returns a matching at least half the size of a maximum matching.\n\n#### 25.3-3\n\nShow that if an edge \\((l,r)\\) belongs to the directed equality subgraph \\(G_{M,h}\\) but is not a member of \\(G_{M,h^{\\prime}}\\), where \\(h^{\\prime}\\) is given by equation (25.5), then \\(l\\in L-F_{L}\\) and \\(r\\in F_{R}\\) at the time that \\(h^{\\prime}\\) is computed.\n\n#### 25.3-4\n\nAt line 29 in the Find-Augmenting-Path procedure, it has already been established that \\(v\\in R\\). This line checks to see whether \\(v\\) is already discovered by testing whether \\(v\\in F_{R}\\). Why doesn't the procedure need to check whether \\(v\\) is already discovered for the case when \\(v\\in L\\), in lines 26-28?\n\n#### 25.3-5\n\nProfessor Hrabosky asserts that the directed equality subgraph \\(G_{M,h}\\) must be constructed and maintained by the Hungarian algorithm, so that line 6 of Hungarian and line 15 of Find-Augmenting-Path are required. Argue that the professor is incorrect by showing how to determine whether an edge belongs to \\(E_{M,h}\\) without explicitly constructing \\(G_{M,h}\\).\n\n#### 25.3-6\n\nHow can you modify the Hungarian algorithm to find a matching of vertices in \\(L\\) to vertices in \\(R\\) that minimizes, rather than maximizes, the sum of the edge weights in the matching?\n\n#### 25.3-7\n\nHow can an assignment problem with \\(|L|\\neq|R|\\) be modified so that the Hungarian algorithm solves it?\n\n## Problems\n\n### Perfect matchings in a regular bipartite graph\n\nProblem 20-3 asked about Euler tours in directed graphs. Prove that a connected, _undirected_ graph \\(G=(V,E)\\) has an Euler tour--a cycle traversing each edge exactly once, though it may visit a vertex multiple times--if and only if the degree of every vertex in \\(V\\) is even.\n\nAssuming that \\(G\\) is connected, undirected, and every vertex in \\(V\\) has even degree, give an \\(O(E)\\)-time algorithm to find an Euler tour of \\(G\\), as in Problem 20-3(b).\n\nExercise 25.1-6 states that if \\(G=(V,E)\\) is a \\(d\\)-regular bipartite graph, then it contains \\(d\\) disjoint perfect matchings. Suppose that \\(d\\) is an exact power of 2. Give an algorithm to find all \\(d\\) disjoint perfect matchings in a \\(d\\)-regular bipartite graph in \\(\\Theta(E\\lg d)\\) time.\n\n### Reducing the running time of the Hungarian algorithm to \\(O(n^{3})\\)\n\nIn this problem, you will show how to reduce the running time of the Hungarian algorithm from \\(O(n^{4})\\) to \\(O(n^{3})\\) by showing how to reduce the running time of the Find-Augmenting-Path procedure from \\(O(n^{3})\\) to \\(O(n^{2})\\). Exercise 25.3-5 demonstrates that line 6 of Hungarian and line 15 of Find-Augmenting-Path are unnecessary. Now you will show how to reduce the running time of each execution of line 10 in Find-Augmenting-Path to \\(O(n)\\).\n\nFor each vertex \\(r\\in R-F_{R}\\), define a new attribute \\(r.\\sigma\\), where\n\n\\[r.\\sigma=\\min\\left\\{l.h+r.h-w(l,r):l\\in F_{L}\\right\\}\\.\\]\n\nThat is, \\(r.\\sigma\\) indicates how close \\(r\\) is to being adjacent to some vertex \\(l\\in F_{L}\\) in the directed equality subgraph \\(G_{m,h}\\). Initially, before placing any vertices into \\(F_{L}\\), set \\(r.\\sigma\\) to \\(\\infty\\) for all \\(r\\in R\\).\n\nShow how to compute \\(\\delta\\) in line 10 in \\(O(n)\\) time, based on the \\(\\sigma\\) attribute.\n\nShow how to update all the \\(\\sigma\\) attributes in \\(O(n)\\) time after \\(\\delta\\) has been computed.\n\nShow that updating all the \\(\\sigma\\) attributes when \\(F_{L}\\) changes takes \\(O(n^{2})\\) time per call of Find-Augmenting-Path.\n\nConclude that the Hungarian procedure can be implemented to run in \\(O(n^{3})\\) time.",
        "chapter": "Part VI Graph Algorithms",
        "section": "25 Matchings in Bipartite Graphs",
        "subsection": "25.3 The Hungarian algorithm for the assignment problem",
        "subsubsection": "N/A"
    },
    {
        "content": "## Problems\n\n### Perfect matchings in a regular bipartite graph\n\nProblem 20-3 asked about Euler tours in directed graphs. Prove that a connected, _undirected_ graph \\(G=(V,E)\\) has an Euler tour--a cycle traversing each edge exactly once, though it may visit a vertex multiple times--if and only if the degree of every vertex in \\(V\\) is even.\n\nAssuming that \\(G\\) is connected, undirected, and every vertex in \\(V\\) has even degree, give an \\(O(E)\\)-time algorithm to find an Euler tour of \\(G\\), as in Problem 20-3(b).\n\nExercise 25.1-6 states that if \\(G=(V,E)\\) is a \\(d\\)-regular bipartite graph, then it contains \\(d\\) disjoint perfect matchings. Suppose that \\(d\\) is an exact power of 2. Give an algorithm to find all \\(d\\) disjoint perfect matchings in a \\(d\\)-regular bipartite graph in \\(\\Theta(E\\lg d)\\) time.\n\n### Reducing the running time of the Hungarian algorithm to \\(O(n^{3})\\)\n\nIn this problem, you will show how to reduce the running time of the Hungarian algorithm from \\(O(n^{4})\\) to \\(O(n^{3})\\) by showing how to reduce the running time of the Find-Augmenting-Path procedure from \\(O(n^{3})\\) to \\(O(n^{2})\\). Exercise 25.3-5 demonstrates that line 6 of Hungarian and line 15 of Find-Augmenting-Path are unnecessary. Now you will show how to reduce the running time of each execution of line 10 in Find-Augmenting-Path to \\(O(n)\\).\n\nFor each vertex \\(r\\in R-F_{R}\\), define a new attribute \\(r.\\sigma\\), where\n\n\\[r.\\sigma=\\min\\left\\{l.h+r.h-w(l,r):l\\in F_{L}\\right\\}\\.\\]\n\nThat is, \\(r.\\sigma\\) indicates how close \\(r\\) is to being adjacent to some vertex \\(l\\in F_{L}\\) in the directed equality subgraph \\(G_{m,h}\\). Initially, before placing any vertices into \\(F_{L}\\), set \\(r.\\sigma\\) to \\(\\infty\\) for all \\(r\\in R\\).\n\nShow how to compute \\(\\delta\\) in line 10 in \\(O(n)\\) time, based on the \\(\\sigma\\) attribute.\n\nShow how to update all the \\(\\sigma\\) attributes in \\(O(n)\\) time after \\(\\delta\\) has been computed.\n\nShow that updating all the \\(\\sigma\\) attributes when \\(F_{L}\\) changes takes \\(O(n^{2})\\) time per call of Find-Augmenting-Path.\n\nConclude that the Hungarian procedure can be implemented to run in \\(O(n^{3})\\) time.\n\n#### 25-3 Other matching problems\n\nThe Hungarian algorithm finds a maximum-weight perfect matching in a complete bipartite graph. It is possible to use the Hungarian algorithm to solve problems in other graphs by modifying the input graph, running the Hungarian algorithm, and then possibly modifying the output. Show how to solve the following matching problems in this manner.\n\n_a._: Give an algorithm to find a maximum-weight matching in a weighted bipartite graph that is not necessarily complete and with all edge weights positive. _b._: Redo part (a), but with edge weights allowed to also be 0 or negative. _c._: A _cycle cover_ in a directed graph, not necessarily bipartite, is a set of edge-disjoint directed cycles such that each vertex lies on at most one cycle. Given nonnegative edge weights \\(w(u,v)\\), let \\(C\\) be the set of edges in a cycle cover, and define \\(w(C)=\\sum_{(u,v)\\in C}w(u,v)\\) to be the weight of the cycle cover. Give an algorithm to find a maximum-weight cycle cover.\n\n#### 25-4 Fractional matchings\n\nIt is possible to define a _fractional matching_. Given a graph \\(G=(V,E)\\), we define a fractional matching \\(x\\) as a function \\(x:E\\to[0,1]\\) (real numbers between 0 and 1, inclusive) such that for every vertex \\(u\\in V\\), we have \\(\\sum_{(u,v)\\in E}x(u,v)\\leq 1\\). The value of a fractional matching is \\(\\sum_{(u,v)\\in E}x(u,v)\\). The definition of a fractional matching is identical to that of a matching, except that a matching has the additional constraint that \\(x(u,v)\\in\\{0,1\\}\\) for all edges \\((u,v)\\in E\\). Given a graph, we let \\(M^{*}\\) denote a maximum matching and \\(x^{*}\\) denote a fractional matching with maximum value.\n\n_a._: Argue that, for any bipartite graph, we must have \\(\\sum_{(u,v)\\in E}x^{*}(u,v)\\geq|M^{*}|\\). _b._: Prove that, for any bipartite graph, we must have \\(\\sum_{(u,v)\\in E}x^{*}(e)\\leq|M^{*}|\\). (_Hint:_ Give an algorithm that converts a fractional matching with an integer value to a matching.) Conclude that the maximum value of a fractional matching in a bipartite graph is the same as the size of the maximum cardinality matching. _c._: We can define a fractional matching in a weighted graph in the same manner: the value of the matching is now \\(\\sum_{(u,v)\\in E}w(u,v)x(u,v)\\). Extend the results of the previous parts to show that in a weighted bipartite graph, the maximum value of a weighted fractional matching is equal to the value of a maximum weighted matching.\n\n_d._ In a general graph, the analogous results do not necessarily hold. Give an example of a small graph that is not bipartite for which the fractional matching with maximum value is not a maximum matching.\n\n#### Computing vertex labels\n\nYou are given a complete bipartite graph \\(G=(V,E)\\) with edge weights \\(w(l,r)\\) for all \\((l,r)\\in E\\). You are also given a maximum-weight perfect matching \\(M^{*}\\) for \\(G\\). You wish to compute a feasible vertex labeling \\(h\\) such that \\(M^{*}\\) is a perfect matching in the equality subgraph \\(G_{h}\\). That is, you want to compute a labeling \\(h\\) of vertices such that\n\n\\[l.h+r.h\\ \\geq\\ w(l,r)\\] for all\n\n\\[l\\in L\\]\n\n and\n\n\\[r\\in R\\]\n\n, (25.6) \\[l.h+r.h\\ =\\ w(l,r)\\] for all\n\n\\[(l,r)\\in M^{*}\\]\n\n. (25.7)\n\n(Requirement (25.6) holds for all edges, and the stronger requirement (25.7) holds for all edges in \\(M^{*}\\).) Give an algorithm to compute the feasible vertex labeling \\(h\\), and prove that it is correct. (_Hint:_ Use the similarity between conditions (25.6) and (25.7) and some of the properties of shortest paths proved in Chapter 22, in particular the triangle inequality (Lemma 22.10) and the convergence property (Lemma 22.14.))\n\n## Chapter notes\n\nMatching algorithms have a long history and have been central to many breakthroughs in algorithm design and analysis. The book by Lovasz and Plummer [306] is an excellent reference on matching problems, and the chapter on matching in the book by Ahuja, Magnanti and Orlin [10] also has extensive references.\n\nThe Hopcroft-Karp algorithm is by Hopcroft and Karp [224]. Madry [308] gave an \\(\\widetilde{O}(E^{10/7})\\)-time algorithm, which is asymptotically faster than Hopcroft-Karp for sparse graphs.\n\nCorollary 25.4 is due to Berge [53], and it also holds in graphs that are not bipartite. Matching in general graphs requires more complicated algorithms. The first polynomial-time algorithm, running in \\(O(V^{4})\\) time, is due to Edmonds [130] (in a paper that also introduced the notion of a polynomial-time algorithm). Like the bipartite case, this algorithm also uses augmenting paths, although the algorithm for finding augmenting paths in general graphs is more involved than the one for bipartite graphs. Subsequently, several \\(O(\\sqrt{V}E)\\)-time algorithms appeared, including ones by Gabow and Tarjan [168] as part of an algorithm for weighted matching and a simpler one by Gabow [164].",
        "chapter": "Part VI Graph Algorithms",
        "section": "25 Matchings in Bipartite Graphs",
        "subsection": "Problems",
        "subsubsection": "N/A"
    },
    {
        "content": "_d._ In a general graph, the analogous results do not necessarily hold. Give an example of a small graph that is not bipartite for which the fractional matching with maximum value is not a maximum matching.\n\n#### Computing vertex labels\n\nYou are given a complete bipartite graph \\(G=(V,E)\\) with edge weights \\(w(l,r)\\) for all \\((l,r)\\in E\\). You are also given a maximum-weight perfect matching \\(M^{*}\\) for \\(G\\). You wish to compute a feasible vertex labeling \\(h\\) such that \\(M^{*}\\) is a perfect matching in the equality subgraph \\(G_{h}\\). That is, you want to compute a labeling \\(h\\) of vertices such that\n\n\\[l.h+r.h\\ \\geq\\ w(l,r)\\] for all\n\n\\[l\\in L\\]\n\n and\n\n\\[r\\in R\\]\n\n, (25.6) \\[l.h+r.h\\ =\\ w(l,r)\\] for all\n\n\\[(l,r)\\in M^{*}\\]\n\n. (25.7)\n\n(Requirement (25.6) holds for all edges, and the stronger requirement (25.7) holds for all edges in \\(M^{*}\\).) Give an algorithm to compute the feasible vertex labeling \\(h\\), and prove that it is correct. (_Hint:_ Use the similarity between conditions (25.6) and (25.7) and some of the properties of shortest paths proved in Chapter 22, in particular the triangle inequality (Lemma 22.10) and the convergence property (Lemma 22.14.))\n\n## Chapter notes\n\nMatching algorithms have a long history and have been central to many breakthroughs in algorithm design and analysis. The book by Lovasz and Plummer [306] is an excellent reference on matching problems, and the chapter on matching in the book by Ahuja, Magnanti and Orlin [10] also has extensive references.\n\nThe Hopcroft-Karp algorithm is by Hopcroft and Karp [224]. Madry [308] gave an \\(\\widetilde{O}(E^{10/7})\\)-time algorithm, which is asymptotically faster than Hopcroft-Karp for sparse graphs.\n\nCorollary 25.4 is due to Berge [53], and it also holds in graphs that are not bipartite. Matching in general graphs requires more complicated algorithms. The first polynomial-time algorithm, running in \\(O(V^{4})\\) time, is due to Edmonds [130] (in a paper that also introduced the notion of a polynomial-time algorithm). Like the bipartite case, this algorithm also uses augmenting paths, although the algorithm for finding augmenting paths in general graphs is more involved than the one for bipartite graphs. Subsequently, several \\(O(\\sqrt{V}E)\\)-time algorithms appeared, including ones by Gabow and Tarjan [168] as part of an algorithm for weighted matching and a simpler one by Gabow [164].\n\nThe Hungarian algorithm is described in the book by Bondy and Murty [67] and is based on work by Kuhn [273] and Munkres [337]. Kuhn adopted the name \"Hungarian algorithm\" because the algorithm derived from work by the Hungarian mathematicians D. Konig and J. Egervery. The algorithm is an early example of a primal-dual algorithm. A faster algorithm that runs in \\(O(\\sqrt{V}E\\log(VW))\\) time, where the edge weights are integers from \\(0\\) to \\(W\\), was given by Gabow and Tarjan [167], and an algorithm with the same time bound for maximum-weight matching in general graphs was given by Duan, Pettie, and Su [127].\n\nThe stable-marriage problem was first defined and analyzed by Gale and Shapley [169]. The stable-marriage problem has numerous variants. The books by Gusfield and Irving [203], Knuth [266], and Manlove [313] serve as excellent sources for cataloging and solving them.",
        "chapter": "Part VI Graph Algorithms",
        "section": "25 Matchings in Bipartite Graphs",
        "subsection": "Chapter notes",
        "subsubsection": "N/A"
    },
    {
        "content": "## Introduction\n\nThis part contains a selection of algorithmic topics that extend and complement earlier material in this book. Some chapters introduce new models of computation such as circuits or parallel computers. Others cover specialized domains such as matrices or number theory. The last two chapters discuss some of the known limitations to the design of efficient algorithms and introduce techniques for coping with those limitations.\n\nChapter 26 presents an algorithmic model for parallel computing based on task-parallel computing, and more specifically, fork-join parallelism. The chapter introduces the basics of the model, showing how to quantify parallelism in terms of the measures of work and span. It then investigates several interesting fork-join algorithms, including algorithms for matrix multiplication and merge sorting.\n\nAn algorithm that receives its input over time, rather than having the entire input available at the start, is called an \"online\" algorithm. Chapter 27 examines techniques used in online algorithms, starting with the \"toy\" problem of how long to wait for an elevator before taking the stairs. It then studies the \"move-to-front\" heuristic for maintaining a linked list and finishes with the online version of the caching problem we saw back in Section 15.4. The analyses of these online algorithms are remarkable in that they prove that these algorithms, which do not know their future inputs, perform within a constant factor of optimal algorithms that know the future inputs.\n\nChapter 28 studies efficient algorithms for operating on matrices. It presents two general methods--LU decomposition and LUP decomposition--for solving linear equations by Gaussian elimination in \\(O(n^{3})\\) time. It also shows that matrix inversion and matrix multiplication can be performed equally fast. The chapter concludes by showing how to compute a least-squares approximate solution when a set of linear equations has no exact solution.\n\nChapter 29 studies how to model problems as linear programs, where the goal is to maximize or minimize an objective, given limited resources and competing constraints. Linear programming arises in a variety of practical application areas. The chapter also addresses the concept of \"duality\" which, by establishing that a maximization problem and minimization problem have the same objective value, helps to show that solutions to each are optimal.\n\nChapter 30 studies operations on polynomials and shows how to use a well-known signal-processing technique -- the fast Fourier transform (FFT)-- to multiply two degree-\\(n\\) polynomials in \\(O(n\\lg n)\\) time. It also derives a parallel circuit to compute the FFT.\n\nChapter 31 presents number-theoretic algorithms. After reviewing elementary number theory, it presents Euclid's algorithm for computing greatest common divisors. Next, it studies algorithms for solving modular linear equations and for raising one number to a power modulo another number. Then, it explores an important application of number-theoretic algorithms: the RSA public-key cryptosystem. This cryptosystem can be used not only to encrypt messages so that an adversary cannot read them, but also to provide digital signatures. The chapter finishes with the Miller-Rabin randomized primality test, which enables finding large primes efficiently-- an essential requirement for the RSA system.\n\nChapter 32 studies the problem of finding all occurrences of a given pattern string in a given text string, a problem that arises frequently in text-editing programs. After examining the naive approach, the chapter presents an elegant approach due to Rabin and Karp. Then, after showing an efficient solution based on finite automata, the chapter presents the Knuth-Morris-Pratt algorithm, which modifies the automaton-based algorithm to save space by cleverly preprocessing the pattern. The chapter finishes by studying suffix arrays, which can not only find a pattern in a text string, but can do quite a bit more, such as finding the longest repeated substring in a text and finding the longest common substring appearing in two texts.\n\nChapter 33 examines three algorithms within the expansive field of machine learning. Machine-learning algorithms are designed to take in vast amounts of data, devise hypotheses about patterns in the data, and test these hypotheses. The chapter starts with \\(k\\)-means clustering, which groups data elements into \\(k\\) classes based on how similar they are to each other. It then shows how to use the technique of multiplicative weights to make predictions accurately based on a set of \"experts\" of varying quality. Perhaps surprisingly, even without knowing which experts are reliable and which are not, you can predict almost as accurately as the most reliable expert. The chapter finishes with gradient descent, an optimization technique that finds a local minimum value for a function. Gradient descent has many applications, including finding parameter settings for many machine-learning models.\n\nChapter 34 concerns NP-complete problems. Many interesting computational problems are NP-complete, but no polynomial-time algorithm is known for solving any of them. This chapter presents techniques for determining when a problem is NP-complete, using them to prove several classic problems NP-complete: determining whether a graph has a hamiltonian cycle (a cycle that includes every vertex), determining whether a boolean formula is satisfiable (whether there exists an assignment of boolean values to its variables that causes the formula to evaluate to true), and determining whether a given set of numbers has a subset that adds up to a given target value. The chapter also proves that the famous traveling-salesperson problem (find a shortest route that starts and ends at the same location and visits each of a set of locations once) is NP-complete.\n\nChapter 35 shows how to find approximate solutions to NP-complete problems efficiently by using approximation algorithms. For some NP-complete problems, approximate solutions that are near optimal are quite easy to produce, but for others even the best approximation algorithms known work progressively more poorly as the problem size increases. Then, there are some problems for which investing increasing amounts of computation time yields increasingly better approximate solutions. This chapter illustrates these possibilities with the vertex-cover problem (unweighted and weighted versions), an optimization version of 3-CNF satisfiability, the traveling-salesperson problem, the set-covering problem, and the subset-sum problem.\n\n## Chapter 2 Parallel Algorithms\n\nThe vast majority of algorithms in this book are _serial algorithms_ suitable for running on a uniprocessor computer that executes only one instruction at a time. This chapter extends our algorithmic model to encompass _parallel algorithms_, where multiple instructions can execute simultaneously. Specifically, we'll explore the elegant model of task-parallel algorithms, which are amenable to algorithmic design and analysis. Our study focuses on fork-join parallel algorithms, the most basic and best understood kind of task-parallel algorithm. Fork-join parallel algorithms can be expressed cleanly using simple linguistic extensions to ordinary serial code. Moreover, they can be implemented efficiently in practice.\n\nParallel computers -- computers with multiple processing units -- are ubiquitous. Handheld, laptop, desktop, and cloud machines are all _multicore computers_, or simply, _multicores_, containing multiple processing \"cores.\" Each processing core is a full-fledged processor that can directly access any location in a common _shared memory_. Multicores can be aggregated into larger systems, such as clusters, by using a network to interconnect them. These multicore clusters usually have a _distributed memory_, where one multicore's memory cannot be accessed directly by a processor in another multicore. Instead, the processor must explicitly send a message over the cluster network to a processor in the remote multicore to request any data it requires. The most powerful clusters are supercomputers, comprising many thousands of multicores. But since shared-memory programming tends to be conceptually easier than distributed-memory programming, and multicore machines are widely available, this chapter focuses on parallel algorithms for multicores.\n\nOne approach to programming multicores is _thread parallelism_. This processor-centric parallel-programming model employs a software abstraction of \"virtual processors,\" or _threads_ that share a common memory. Each thread maintains its own program counter and can execute code independently of the other threads. The operating system loads a thread onto a processing core for execution and switches it out when another thread needs to run.",
        "chapter": "Part VII Selected Topics",
        "section": "Introduction",
        "subsection": "N/A",
        "subsubsection": "N/A"
    },
    {
        "content": "Fork-join parallelism offers several important advantages:\n* The fork-join programming model is a simple extension of the familiar serial programming model used in most of this book. To describe a fork-join parallel algorithm, the pseudocode in this book needs just three added keywords: **parallel**, **spawn**, and **sync**. Deleting these parallel keywords from the parallel pseudocode results in ordinary serial pseudocode for the same problem, which we call the \"serial projection\" of the parallel algorithm.\n* The underlying task-parallel model provides a theoretically clean way to quantify parallelism based on the notions of \"work\" and \"span.\"\n* Spawning allows many divide-and-conquer algorithms to be parallelized naturally. Moreover, just as serial divide-and-conquer algorithms lend themselves to analysis using recurrences, so do parallel algorithms in the fork-join model.\n* The fork-join programming model is faithful to how multicore programming has been evolving in practice. A growing number of multicore environments support one variant or another of fork-join parallel programming, including Cilk [290, 291, 383, 396], Habanero-Java [466], the Java Fork-Join Framework [279], OpenMP [81], Task Parallel Library [289], Threading Building Blocks [376], and X10 [82].\n\nSection 26.1 introduces parallel pseudocode, shows how the execution of a task-parallel computation can be modeled as a directed acyclic graph, and presents the metrics of work, span, and parallelism, which you can use to analyze parallel algorithms. Section 26.2 investigates how to multiply matrices in parallel, and Section 26.3 tackles the tougher problem of designing an efficient parallel merge sort.\n\n### The basics of fork-join parallelism\n\nOur exploration of parallel programming begins with the problem of computing Fibonacci numbers recursively in parallel. We'll look at a straightforward serial Fibonacci calculation, which, although inefficient, serves as a good illustration of how to express parallelism in pseudocode.\n\nRecall that the Fibonacci numbers are defined by equation (3.31) on page 69:\n\n\\[F_{i}\\,=\\,\\left\\{\\begin{array}{ll}0&\\mbox{if }i\\,=\\,0\\,\\\\ 1&\\mbox{if }i\\,=\\,1\\,\\\\ F_{i-1}\\,+\\,F_{i-2}&\\mbox{if }i\\,\\geq\\,2\\.\\end{array}\\right.\\]\n\nTo calculate the \\(n\\)th Fibonacci number recursively, you could use the ordinary serial algorithm in the procedure Fib on the facing page. You would not really want to compute large Fibonacci numbers this way, because this computation does needless repeated work, but parallelizing it can be instructive.\n\n\\(\\begin{array}{l}\\mbox{\\sc Fib}(n)\\\\ \\mbox{\\sc Fib}(\\mbox{\\sc)}\\\\ \\mbox{\\sc 1}\\mbox{\\sc 2}\\mbox{\\sc 3}\\mbox{\\sc 4}\\mbox{\\sc 5}\\mbox{\\sc 6}\\mbox{\\sc 7}\\mbox{\\sc 8}\\mbox{\\sc 9}\\mbox{\\sc 1}\\mbox{\\sc 2}\\mbox{\\sc 3}\\mbox{\\sc 4}\\mbox{\\sc 5}\\mbox{\\sc 6}\\mbox{\\sc 7}\\mbox{\\sc 8}\\mbox{\\sc 1}\\mbox{\\sc 2}\\mbox{\\sc 3}\\mbox{\\sc 4}\\mbox{\\sc 5}\\mbox{\\sc 6}\\mbox{results in a call to Fib(4). Both instances of Fib(4) return the same result (\\(F_{4}=3\\)). Since the Fib procedure does not memoize (recall the definition of \"memoize\" from page 368), the second call to Fib(4) replicates the work that the first call performs, which is wasteful.\n\nAlthough the Fib procedure is a poor way to compute Fibonacci numbers, it can help us warm up to parallelism concepts. Perhaps the most basic concept is to understand is that if two parallel tasks operate on entirely different data, then-- absent other interference--they each produce the same outcomes when executed at the same time as when they run serially one after the other. Within Fib(_n_), for example, the two recursive calls in line 3 to Fib(_n_ - 1) and in line 4 to Fib(_n_ - 2) can safely execute in parallel because the computation performed by one in no way affects the other.\n\n### Parallel keywords\n\nThe P-Fib procedure on the next page computes Fibonacci numbers, but using the _parallel keywords_**spawn** and **sync** to indicate parallelism in the pseudocode.\n\nIf the keywords **spawn** and **sync** are deleted from P-Fib, the resulting pseudocode text is identical to Fib (other than renaming the procedure in the header\n\nFigure 26: The invocation tree for Fib(6). Each node in the tree represents a procedure instance whose children are the procedure instances it calls during its execution. Since each instance of Fib with the same argument does the same work to produce the same result, the inefficiency of this algorithm for computing the Fibonacci numbers can be seen by the vast number of repeated calls to compute the same thing. The portion of the tree shaded blue appears in task-parallel form in Figure 26.2.\n\n### The basics of fork-join parallelism\n\nP-Fib(_n_)\n\n```\n1if\\(n\\leq 1\\)return\\(n\\)\n2else\\(x=\\) spawnP-Fib(_n_-1) // don't wait for subroutine to return\n3\\(y=\\)P-Fib(_n_-2) // in parallel with spawned subroutine\n5sync // wait for spawned subroutine to finish\n6return\\(x+y\\)\n```\n\nand in the two recursive calls). We define the _serial projection1_ of a parallel algorithm to be the serial algorithm that results from ignoring the parallel directives, which in this case can be done by omitting the keywords **spawn** and **sync**. For **parallel for** loops, which we'll see later on, we omit the keyword **parallel**. Indeed, our parallel pseudocode possesses the elegant property that its serial projection is always ordinary serial pseudocode to solve the same problem.\n\nFootnote 1: In mathematics, a projection is an idempotent function, that is, a function \\(f\\) such that \\(f\\circ f=f\\). In this case, the function \\(f\\) maps the set \\(\\mathcal{P}\\) of fork-join programs to the set \\(\\mathcal{P}_{\\mathcal{S}}\\subset\\mathcal{P}\\) of serial programs, which are themselves fork-join programs with no parallelism. For a fork-join program \\(x\\in\\mathcal{P}\\), since we have \\(f(f(x))=f(x)\\), the serial projection, as we have defined it, is indeed a mathematical projection.\n\n#### Semantics of parallel keywords\n\n_Spawning_ occurs when the keyword **spawn** precedes a procedure call, as in line 3 of P-Fib. The semantics of a spawn differs from an ordinary procedure call in that the procedure instance that executes the spawn--the _parent_--may continue to execute in parallel with the spawned subroutine--its _child_--instead of waiting for the child to finish, as would happen in a serial execution. In this case, while the spawned child is computing P-Fib(_n_-1), the parent may go on to compute P-Fib(_n_-2) in line 4 in parallel with the spawned child. Since the P-Fib procedure is recursive, these two subroutine calls themselves create nested parallelism, as do their children, thereby creating a potentially vast tree of subcomputations, all executing in parallel.\n\nThe keyword **spawn** does not say, however, that a procedure _must_ execute in parallel with its spawned children, only that it _may_. The parallel keywords express the _logical parallelism_ of the computation, indicating which parts of the computation may proceed in parallel. At runtime, it is up to a _scheduler_ to determine which subcomputations actually run in parallel by assigning them to available processors as the computation unfolds. We'll discuss the theory behind task-parallel schedulers shortly (on page 759).\n\nA procedure cannot safely use the values returned by its spawned children until after it executes a **sync** statement, as in line 5. The keyword **sync** indicates that the procedure must wait as necessary for all its spawned children to finish before proceeding to the statement after the **sync** --the \"join\" of a fork-join parallel computation. The P-Fib procedure requires a **sync** before the **return** statement in line 6 to avoid the anomaly that would occur if \\(x\\) and \\(y\\) were summed before P-Fib(\\(n-1\\)) had finished and its return value had been assigned to \\(x\\). In addition to explicit join synchronization provided by the **sync** statement, it is convenient to assume that every procedure executes a **sync** implicitly before it returns, thus ensuring that all children finish before their parent finishes.\n\n#### A graph model for parallel execution\n\nIt helps to view the execution of a parallel computation --the dynamic stream of runtime instructions executed by processors under the direction of a parallel program --as a directed acyclic graph \\(G=(V,E)\\), called a _(parallel) trace_.2 Conceptually, the vertices in \\(V\\) are executed instructions, and the edges in \\(E\\) represent dependencies between instructions, where \\((u,v)\\in E\\) means that the parallel program required instruction \\(u\\) to execute before instruction \\(v\\).\n\nFootnote 2: Also called a _computation dag_ in the literature.\n\nIt's sometimes inconvenient, especially if we want to focus on the parallel structure of a computation, for a vertex of a trace to represent only one executed instruction. Consequently, if a chain of instructions contains no parallel or procedural control (no **spawn**, **sync**, procedure call, or **return** --via either an explicit **return** statement or the return that happens implicitly upon reaching the end of a procedure), we group the entire chain into a single _strand_. As an example, Figure 26.2 shows the trace that results from computing P-Fib(4) in the portion of Figure 26.1 shaded blue. Strands do not include instructions that involve parallel or procedural control. These control dependencies must be represented as edges in the trace.\n\nWhen a parent procedure calls a child, the trace contains an edge \\((u,v)\\) from the strand \\(u\\) in the parent that executes the call to the first strand \\(v\\) of the spawned child, as illustrated in Figure 26.2 by the edge from the orange strand in P-Fib(4) to the blue strand in P-Fib(2). When the last strand \\(v^{\\prime}\\) in the child returns, the trace contains an edge \\((v^{\\prime},u^{\\prime})\\) to the strand \\(u^{\\prime}\\), where \\(u^{\\prime}\\) is the successor strand of \\(u\\) in the parent, as with the edge from the white strand in P-Fib(2) to the white strand in P-Fib(4).\n\n#### The basics of fork-join parallelism\n\nWhen the parent spawns a child, however, the trace is a little different. The edge \\((u,v)\\) goes from parent to child as with a call, such as the edge from the blue strand in P-Fib(4) to the blue strand in P-Fib(3), but the trace contains another edge \\((u,u^{\\prime})\\) as well, indicating that \\(u\\)'s successor strand \\(u^{\\prime}\\) can continue to execute while \\(v\\) is executing. The edge from the blue strand in P-Fib(4) to the orange strand in P-Fib(4) illustrates one such edge. As with a call, there is an edge from the last strand \\(v^{\\prime}\\) in the child, but with a spawn, it no longer goes to \\(u\\)'s successor. Instead, the edge is \\((v^{\\prime},x)\\), where \\(x\\) is the strand immediately following the **sync** in the parent that ensures that the child has finished, as with the edge from the white strand in P-Fib(3) to the white strand in P-Fib(4).\n\nYou can figure out what parallel control created a particular trace. If a strand has two successors, one of them must have been spawned, and if a strand has multiple predecessors, the predecessors joined because of a **sync** statement. Thus, in the general case, the set \\(V\\) forms the set of strands, and the set \\(E\\) of directed edges represents dependencies between strands induced by parallel and procedural\n\nFigure 26.2: The trace of P-Fib(4) corresponding to the shaded portion of Figure 26.1. Each circle represents one strand, with blue circles representing any instructions executed in the part of the procedure (instance) up to the spawn of P-Fib(\\(n-1\\)) in line 3; orange circles representing the instructions executed in the part of the procedure that calls P-Fib(\\(n-2\\)) in line 4 up to the **sync** in line 5, where it suspends until the spawn of P-Fib(\\(n-1\\)) returns; and white circles representing the instructions executed in the part of the procedure after the **sync**, where it sums \\(x\\) and \\(y\\), up to the point where it returns the result. Strands belonging to the same procedure are grouped into a rounded rectangle, blue for spawned procedures and tan for called procedures. Assuming that each strand takes unit time, the work is 17 time units, since there are 17 strands, and the span is \\(8\\) time units, since the critical path\\(-\\)shown with blue edges\\(-\\)contains 8 strands.\n\ncontrol. If \\(G\\) contains a directed path from strand \\(u\\) to strand \\(v\\), we say that the two strands are _(logically) in series_. If there is no path in \\(G\\) either from \\(u\\) to \\(v\\) or from \\(v\\) to \\(u\\), the strands are _(logically) in parallel_.\n\nA fork-join parallel trace can be pictured as a dag of strands embedded in an invocation tree of procedure instances. For example, Figure 26.1 shows the invocation tree for (6), which also serves as the invocation tree for (6), the edges between procedure instances now representing either calls or spawns. Figure 26.2 zooms in on the subtree that is shaded blue, showing the strands that constitute each procedure instance in (4). All directed edges connecting strands run either within a procedure or along undirected edges of the invocation tree in Figure 26.1. (More general task-parallel traces that are not fork-join traces may contain some directed edges that do not run along the undirected tree edges.)\n\nOur analyses generally assume that parallel algorithms execute on an ideal parallel computer, which consists of a set of processors and a sequentially consistent shared memory. To understand sequential consistency, you first need to know that memory is accessed by load instructions, which copy data from a location in the memory to a register within a processor, and by store instructions, which copy data from a processor register to a location in the memory. A single line of pseudocode can entail several such instructions. For example, the line \\(x=y+z\\) could result in load instructions to fetch each of \\(y\\) and \\(z\\) from memory into a processor, an instruction to add them together inside the processor, and a store instruction to place the result \\(x\\) back into memory. In a parallel computer, several processors might need to load or store at the same time. Sequential consistency means that even if multiple processors attempt to access the memory simultaneously, the shared memory behaves as if exactly one instruction from one of the processors is executed at a time, even though the actual transfer of data may happen at the same time. It is as if the instructions were executed one at a time sequentially according to some global linear order among all the processors that preserves the individual orders in which each processor executes its own instructions.\n\nFor task-parallel computations, which are scheduled onto processors automatically by a runtime system, the sequentially consistent shared memory behaves as if a parallel computation's executed instructions were executed one by one in the order of a topological sort (see Section 20.4) of its trace. That is, you can reason about the execution by imagining that the individual instructions (not generally the strands, which may aggregate many instructions) are interleaved in some linear order that preserves the partial order of the trace. Depending on scheduling, the linear order could vary from one run of the program to the next, but the behavior of any execution is always as if the instructions executed serially in a linear order consistent with the dependencies within the trace.\n\nIn addition to making assumptions about semantics, the ideal parallel-computer model makes some performance assumptions. Specifically, it assumes that each processor in the machine has equal computing power, and it ignores the cost of scheduling. Although this last assumption may sound optimistic, it turns out that for algorithms with sufficient \"parallelism\" (a term we'll define precisely a little later), the overhead of scheduling is generally minimal in practice.\n\n##### Performance measures\n\nWe can gauge the theoretical efficiency of a task-parallel algorithm using _work_/ _span analysis_, which is based on two metrics: \"work\" and \"span.\" The _work_ of a task-parallel computation is the total time to execute the entire computation on one processor. In other words, the work is the sum of the times taken by each of the strands. If each strand takes unit time, the work is just the number of vertices in the trace. The _span_ is the fastest possible time to execute the computation on an unlimited number of processors, which corresponds to the sum of the times taken by the strands along a longest path in the trace, where \"longest\" means that each strand is weighted by its execution time. Such a longest path is called the _critical path_ of the trace, and thus the span is the weight of the longest (weighted) path in the trace. (Section 22.2, pages 617-619 shows how to find a critical path in a \\(\\mathrm{dag}\\ G=(V,E)\\) in \\(\\Theta(V\\ +\\ E)\\) time.) For a trace in which each strand takes unit time, the span equals the number of strands on the critical path. For example, the trace of Figure 26.2 has 17 vertices in all and 8 vertices on its critical path, so that if each strand takes unit time, its work is 17 time units and its span is 8 time units.\n\nThe actual running time of a task-parallel computation depends not only on its work and its span, but also on how many processors are available and how the scheduler allocates strands to processors. To denote the running time of a task-parallel computation on \\(P\\) processors, we subscript by \\(P\\). For example, we might denote the running time of an algorithm on \\(P\\) processors by \\(T_{P}\\). The work is the running time on a single processor, or \\(T_{1}\\). The span is the running time if we could run each strand on its own processor-- in other words, if we had an unlimited number of processors-- and so we denote the span by \\(T_{\\infty}\\).\n\nThe work and span provide lower bounds on the running time \\(T_{P}\\) of a task-parallel computation on \\(P\\) processors:\n\n* In one step, an ideal parallel computer with \\(P\\) processors can do at most \\(P\\) units of work, and thus in \\(T_{P}\\) time, it can perform at most \\(P\\,T_{P}\\) work. Since the total work to do is \\(T_{1}\\), we have \\(P\\,T_{P}\\geq T_{1}\\). Dividing by \\(P\\) yields the _work law_: \\(T_{P}\\ \\geq T_{1}/P\\).\n* A \\(P\\)-processor ideal parallel computer cannot run any faster than a machine with an unlimited number of processors. Looked at another way, a machine with an unlimited number of processors can emulate a \\(P\\)-processor machine by using just \\(P\\) of its processors. Thus, the _span law_ follows:\n\n\\[T_{P}\\,\\geq\\,T_{\\infty}. \\tag{26.3}\\]\n\nWe define the _speedup_ of a computation on \\(P\\) processors by the ratio \\(T_{1}/\\,T_{P}\\), which says how many times faster the computation runs on \\(P\\) processors than on one processor. By the work law, we have \\(T_{P}\\,\\geq\\,T_{1}/\\,P\\), which implies that \\(T_{1}/\\,T_{P}\\,\\leq\\,P\\). Thus, the speedup on a \\(P\\)-processor ideal parallel computer can be at most \\(P\\). When the speedup is linear in the number of processors, that is, when \\(T_{1}/\\,T_{P}\\,=\\,\\Theta(P)\\), the computation exhibits _linear speedup_. _Perfect linear speedup_ occurs when \\(T_{1}/\\,T_{P}\\,=\\,P\\).\n\nThe ratio \\(T_{1}/\\,T_{\\infty}\\) of the work to the span gives the _parallelism_ of the parallel computation. We can view the parallelism from three perspectives. As a ratio, the parallelism denotes the average amount of work that can be performed in parallel for each step along the critical path. As an upper bound, the parallelism gives the maximum possible speedup that can be achieved on any number of processors. Perhaps most important, the parallelism provides a limit on the possibility of attaining perfect linear speedup. Specifically, once the number of processors exceeds the parallelism, the computation cannot possibly achieve perfect linear speedup. To see this last point, suppose that \\(P\\,>\\,T_{1}/\\,T_{\\infty}\\), in which case the span law implies that the speedup satisfies \\(T_{1}/\\,T_{P}\\,\\leq\\,T_{1}/\\,T_{\\infty}\\,<\\,P\\). Moreover, if the number \\(P\\) of processors in the ideal parallel computer greatly exceeds the parallelism--that is, if \\(P\\,\\gg\\,T_{1}/\\,T_{\\infty}\\)--then \\(T_{1}/\\,T_{P}\\,\\ll\\,P\\), so that the speedup is much less than the number of processors. In other words, if the number of processors exceeds the parallelism, adding even more processors makes the speedup less perfect.\n\nAs an example, consider the computation P-Fib(4) in Figure 26.2, and assume that each strand takes unit time. Since the work is \\(T_{1}\\,=\\,17\\) and the span is \\(T_{\\infty}\\,=\\,8\\), the parallelism is \\(T_{1}/\\,T_{\\infty}\\,=\\,17/8\\,=\\,2.125\\). Consequently, achieving much more than double the performance is impossible, no matter how many processors execute the computation. For larger input sizes, however, we'll see that P-Fib(\\(n\\)) exhibits substantial parallelism.\n\nWe define the _(parallel) slackness_ of a task-parallel computation executed on an ideal parallel computer with \\(P\\) processors to be the ratio \\((T_{1}/\\,T_{\\infty})/\\,P\\,=\\,T_{1}/(\\,P\\,T_{\\infty})\\), which is the factor by which the parallelism of the computation exceeds the number of processors in the machine. Restating the bounds on speedup, if the slackness is less than 1, perfect linear speedup is impossible, because \\(T_{1}/(\\,P\\,T_{\\infty})\\,<\\,1\\) and the span law imply that \\(T_{1}/\\,T_{P}\\,\\leq\\,T_{1}/\\,T_{\\infty}\\,<\\,P\\). Indeed, as the slackness decreases from 1 and approaches 0, the speedup of the computation diverges further and further from perfect linear speedup. If the slackness is less than 1, additional parallelism in an algorithm can have a great impact on its execution efficiency. If the slackness is greater than 1, however, the work per processor is the limiting constraint. We'll see that as the slackness increases from 1, a good scheduler can achieve closer and closer to perfect linear speedup. But once the slackness is much greater than 1, the advantage of additional parallelism shows diminishing returns.\n\n### Scheduling\n\nGood performance depends on more than just minimizing the work and span. The strands must also be scheduled efficiently onto the processors of the parallel machine. Our fork-join parallel-programming model provides no way for a programmer to specify which strands to execute on which processors. Instead, we rely on the runtime system's scheduler to map the dynamically unfolding computation to individual processors. In practice, the scheduler maps the strands to static threads, and the operating system schedules the threads on the processors themselves. But this extra level of indirection is unnecessary for our understanding of scheduling. We can just imagine that the scheduler maps strands to processors directly.\n\nA task-parallel scheduler must schedule the computation without knowing in advance when procedures will be spawned or when they will finish--that is, it must operate _online_. Moreover, a good scheduler operates in a distributed fashion, where the threads implementing the scheduler cooperate to load-balance the computation. Provably good online, distributed schedulers exist, but analyzing them is complicated. Instead, to keep our analysis simple, we'll consider an online _centralized_ scheduler that knows the global state of the computation at any moment.\n\nIn particular, we'll analyze _greedy schedulers_, which assign as many strands to processors as possible in each time step, never leaving a processor idle if there is work that can be done. We'll classify each step of a greedy scheduler as follows:\n\n* _Complete step_: At least \\(P\\) strands are _ready_ to execute, meaning that all strands on which they depend have finished execution. A greedy scheduler assigns any \\(P\\) of the ready strands to the processors, completely utilizing all the processor resources.\n* _Incomplete step_: Fewer than \\(P\\) strands are ready to execute. A greedy scheduler assigns each ready strand to its own processor, leaving some processors idle for the step, but executing all the ready strands.\n\nThe work law tells us that the fastest running time \\(T_{P}\\) that we can hope for on \\(P\\) processors must be at least \\(T_{1}/P\\). The span law tells us that the fastest possible running time must be at least \\(T_{\\infty}\\). The following theorem shows that greedy scheduling is provably good in that it achieves the sum of these two lower bounds as an upper bound.\n\n**Theorem 26.1**: _On an ideal parallel computer with \\(P\\) processors, a greedy scheduler executes a task-parallel computation with work \\(T_{1}\\) and span \\(T_{\\infty}\\) in time_\n\n\\[T_{P}\\,\\leq\\,T_{1}/P\\,+\\,T_{\\infty}\\;. \\tag{26.4}\\]\n\n_Proof_ Without loss of generality, assume that each strand takes unit time. (If necessary, replace each longer strand by a chain of unit-time strands.) We'll consider complete and incomplete steps separately.\n\nIn each complete step, the \\(P\\) processors together perform a total of \\(P\\) work. Thus, if the number of complete steps is \\(k\\), the total work executing all the complete steps is \\(kP\\). Since the greedy scheduler doesn't execute any strand more than once and only \\(T_{1}\\) work needs to be performed, it follows that \\(kP\\,\\leq\\,T_{1}\\), from which we can conclude that the number \\(k\\) of complete steps is at most \\(T_{1}/P\\).\n\nNow, let's consider an incomplete step. Let \\(G\\) be the trace for the entire computation, let \\(G^{\\prime}\\) be the subtrace of \\(G\\) that has yet to be executed at the start of the incomplete step, and let \\(G^{\\prime\\prime}\\) be the subtrace remaining to be executed after the incomplete step. Consider the set \\(R\\) of strands that are ready at the beginning of the incomplete step, where \\(|R|\\,<\\,P\\). By definition, if a strand is ready, all its predecessors in trace \\(G\\) have executed. Thus the predecessors of strands in \\(R\\) do not belong to \\(G^{\\prime}\\). A longest path in \\(G^{\\prime}\\) must necessarily start at a strand in \\(R\\), since every other strand in \\(G^{\\prime}\\) has a predecessor and thus could not start a longest path. Because the greedy scheduler executes all ready strands during the incomplete step, the strands of \\(G^{\\prime\\prime}\\) are exactly those in \\(G^{\\prime}\\) minus the strands in \\(R\\). Consequently, the length of a longest path in \\(G^{\\prime\\prime}\\) must be 1 less than the length of a longest path in \\(G^{\\prime}\\). In other words, every incomplete step decreases the span of the trace remaining to be executed by 1. Hence, the number of incomplete steps can be at most \\(T_{\\infty}\\).\n\nSince each step is either complete or incomplete, the theorem follows.\n\nThe following corollary shows that a greedy scheduler always performs well.\n\n**Corollary 26.2**: _The running time \\(T_{P}\\) of any task-parallel computation scheduled by a greedy scheduler on a \\(P\\)-processor ideal parallel computer is within a factor of 2 of optimal._\n\n_Proof_ Let \\(T_{P}^{*}\\) be the running time produced by an optimal scheduler on a machine with \\(P\\) processors, and let \\(T_{1}\\) and \\(T_{\\infty}\\) be the work and span of the computation, respectively. Since the work and span laws--inequalities (26.2) and (26.3)--give \\(T_{P}^{*}\\,\\geq\\,\\max\\,\\{T_{1}/P,\\,T_{\\infty}\\}\\), Theorem 26.1 implies that\n\n\\[T_{P} \\,\\leq\\,T_{1}/P\\,+\\,T_{\\infty}\\] \\[\\,\\leq\\,2\\cdot\\max\\,\\{T_{1}/P,\\,T_{\\infty}\\}\\] \\[\\,\\leq\\,2T_{P}^{*}\\;.\\]\n\n### The basics of fork-join parallelism\n\nThe next corollary shows that, in fact, a greedy scheduler achieves near-perfect linear speedup on any task-parallel computation as the slackness grows.\n\n_Corollary 26.3_\n\nLet \\(T_{P}\\) be the running time of a task-parallel computation produced by a greedy scheduler on an ideal parallel computer with \\(P\\) processors, and let \\(T_{1}\\) and \\(T_{\\infty}\\) be the work and span of the computation, respectively. Then, if \\(P\\,\\ll\\,T_{1}/\\,T_{\\infty}\\), or equivalently, the parallel slackness is much greater than 1, we have \\(T_{P}\\,\\approx\\,T_{1}/\\,P\\), a speedup of approximately \\(P\\).\n\n_Proof_ If we suppose that \\(P\\,\\ll\\,T_{1}/\\,T_{\\infty}\\), then it follows that \\(T_{\\infty}\\,\\ll\\,T_{1}/\\,P\\), and hence Theorem 26.1 gives \\(T_{P}\\,\\leq\\,T_{1}/\\,P\\,+\\,T_{\\infty}\\,\\approx\\,T_{1}/\\,P\\). Since the work law (26.2) dictates that \\(T_{P}\\,\\geq\\,T_{1}/\\,P\\), we conclude that \\(T_{P}\\,\\approx\\,T_{1}/\\,P\\), which is a speedup of \\(T_{1}/\\,T_{P}\\,\\approx\\,P\\).\n\nThe \\(\\ll\\) symbol denotes \"much less,\" but how much is \"much less\"? As a rule of thumb, a slackness of at least 10--that is, 10 times more parallelism than processors--generally suffices to achieve good speedup. Then, the span term in the greedy bound, inequality (26.4), is less than 10% of the work-per-processor term, which is good enough for most engineering situations. For example, if a computation runs on only 10 or 100 processors, it doesn't make sense to value parallelism of, say 1,000,000, over parallelism of 10,000, even with the factor of 100 difference. As Problem 26-2 shows, sometimes reducing extreme parallelism yields algorithms that are better with respect to other concerns and which still scale up well on reasonable numbers of processors.\n\n### Analyzing parallel algorithms\n\nWe now have all the tools we need to analyze parallel algorithms using work/span analysis, allowing us to bound an algorithm's running time on any number of processors. Analyzing the work is relatively straightforward, since it amounts to nothing more than analyzing the running time of an ordinary serial algorithm, namely, the serial projection of the parallel algorithm. You should already be familiar with analyzing work, since that is what most of this textbook is about! Analyzing the span is the new thing that parallelism engenders, but it's generally no harder once you get the hang of it. Let's investigate the basic ideas using the P-Fib program.\n\nAnalyzing the work \\(T_{1}(n)\\) of P-Fib\\((n)\\) poses no hurdles, because we've already done it. The serial projection of P-Fib is effectively the original Fib procedure, and hence, we have \\(T_{1}(n)\\,=\\,T(n)\\,=\\,\\Theta(\\phi^{n})\\) from equation (26.1).\n\nFigure 26.3 illustrates how to analyze the span. If two traces are joined in series, their spans add to form the span of their composition, whereas if they are joinedin parallel, the span of their composition is the maximum of the spans of the two traces. As it turns out, the trace of any fork-join parallel computation can be built up from single strands by series-parallel composition.\n\nArmed with an understanding of series-parallel composition, we can analyze the span of P-Fib\\((n)\\). The spawned call to P-Fib\\((n-1)\\) in line 3 runs in parallel with the call to P-Fib\\((n-2)\\) in line 4. Hence, we can express the span of P-Fib\\((n)\\) as the recurrence\n\n\\[T_{\\infty}(n) = \\max\\,\\{T_{\\infty}(n-1),T_{\\infty}(n-2)\\}+\\Theta(1)\\] \\[= T_{\\infty}(n-1)+\\Theta(1)\\,\\]\n\nwhich has solution \\(T_{\\infty}(n)=\\Theta(n)\\). (The second equality above follows from the first because P-Fib\\((n-1)\\) uses P-Fib\\((n-2)\\) in its computation, so that the span of P-Fib\\((n-1)\\) must be at least as large as the span of P-Fib\\((n-2)\\).)\n\nThe parallelism of P-Fib\\((n)\\) is \\(T_{1}(n)/T_{\\infty}(n)=\\Theta(\\phi^{n}/n)\\), which grows dramatically as \\(n\\) gets large. Thus, Corollary 26.3 tells us that on even the largest parallel computers, a modest value for \\(n\\) suffices to achieve near perfect linear speedup for P-Fib\\((n)\\), because this procedure exhibits considerable parallel slackness.\n\n### Parallel loops\n\nMany algorithms contain loops for which all the iterations can operate in parallel. Although the **spawn** and **sync** keywords can be used to parallelize such loops, it is more convenient to specify directly that the iterations of such loops can run in parallel. Our pseudocode provides this functionality via the **parallel** keyword, which precedes the **for** keyword in a **for** loop statement.\n\nFigure 26.3: Series-parallel composition of parallel traces. **(a)** When two traces are joined in series, the work of the composition is the sum of their work, and the span of the composition is the sum of their spans. **(b)** When two traces are joined in parallel, the work of the composition remains the sum of their work, but the span of the composition is only the maximum of their spans.\n\n### The basics of fork-join parallelism\n\nAs an example, consider the problem of multiplying a square \\(n\\times n\\) matrix \\(A=(a_{ij})\\) by an \\(n\\)-vector \\(x=(x_{j})\\). The resulting \\(n\\)-vector \\(y=(y_{i})\\) is given by the equation\n\n\\[y_{i}=\\sum_{j=1}^{n}a_{ij}\\,x_{j}\\,\\]\n\nfor \\(i=1,2,\\ldots,n\\). The P-Mat-Vec procedure performs matrix-vector multiplication (actually, \\(y=y+Ax\\)) by computing all the entries of \\(y\\) in parallel. The **parallel for** keywords in line 1 of P-Mat-Vec indicate that the \\(n\\) iterations of the loop body, which includes a serial **for** loop, may be run in parallel. The initialization \\(y=0\\), if desired, should be performed before calling the procedure (and can be done with a **parallel for** loop).\n\nP-Mat-Vec(\\(A,x,y,n\\))\n\n**parallel for \\(i=1\\) to \\(n\\)**// parallel loop\n\n**for \\(j=1\\) to \\(n\\)**// serial loop\n\n\\(y_{i}=y_{i}+a_{ij}x_{j}\\)\n\nCompilers for fork-join parallel programs can implement **parallel for** loops in terms of **spawn** and **sync** by using recursive spawning. For example, for the **parallel for** loop in lines 1-3, a compiler can generate the auxiliary subroutine P-Mat-Vec-Recursive and call P-Mat-Vec-Recursive(\\(A,x,y,n,1,n\\)) in the place where the loop would be in the compiled code. As Figure 26.4 illustrates, this procedure recursively spawns the first half of the iterations of the loop to execute in parallel (line 5) with the second half of the iterations (line 6) and then executes a **sync** (line 7), thereby creating a binary tree of parallel execution. Each leaf represents a base case, which is the serial **for** loop of lines 2-3.\n\nP-Mat-Vec-Recursive(\\(A,x,y,n,i,i^{\\prime}\\))\n\n**if \\(i==i^{\\prime}\\)**// just one iteration to do?\n\n**for \\(j=1\\) to \\(n\\)**// mimic P-Mat-Vec serial loop\n\n\\(y_{i}=y_{i}+a_{ij}x_{j}\\)\n\n**else \\(mid=\\lfloor(i+i^{\\prime})/2\\rfloor\\)**// parallel divide-and-conquer\n\n**spawn P-Mat-Vec-Recursive(\\(A,x,y,n,i,mid\\))**\n\nP-Mat-Vec-Recursive(\\(A,x,y,n,mid+1,i^{\\prime}\\))\n\n**sync**\n\nTo calculate the work \\(T_{1}(n)\\) of P-Mat-Vec on an \\(n\\times n\\) matrix, simply compute the running time of its serial projection, which comes from replacing the **parallelfor** loop in line 1 with an ordinary **for** loop. The running time of the resulting serial pseudocode is \\(\\Theta(n^{2})\\), which means that \\(T_{1}(n)=\\Theta(n^{2})\\). This analysis seems to ignore the overhead for recursive spawning in implementing the parallel loops, however. Indeed, the overhead of recursive spawning does increase the work of a parallel loop compared with that of its serial projection, but not asymptotically. To see why, observe that since the tree of recursive procedure instances is a full binary tree, the number of internal nodes is one less than the number of leaves (see Exercise B.5-3 on page 1175). Each internal node performs constant work to divide the iteration range, and each leaf corresponds to a base case, which takes at least constant time (\\(\\Theta(n)\\) time in this case). Thus, by amortizing the overhead of recursive spawning over the work of the iterations in the leaves, we see that the overall work increases by at most a constant factor.\n\nTo reduce the overhead of recursive spawning, task-parallel platforms sometimes _coarsen_ the leaves of the recursion by executing several iterations in a single leaf, either automatically or under programmer control. This optimization comes at the expense of reducing the parallelism. If the computation has sufficient parallel slackness, however, near-perfect linear speedup won't be sacrificed.\n\nFigure 26.4: A trace for the computation of P-Mat-Vec-Recursive(\\(A,x,y,8,1,8\\)). The two numbers within each rounded rectangle give the values of the last two parameters (\\(i\\) and \\(i^{\\prime}\\) in the procedure header) in the invocation (spawn, in blue, or call, in tan) of the procedure. The blue circles represent strands corresponding to the part of the procedure up to the spawn of P-Mat-Vec-Recursive in line 5. The orange circles represent strands corresponding to the part of the procedure that calls P-Mat-Vec-Recursive in line 6 up to the **sync** in line 7, where it suspends until the spawned subroutine in line 5 returns. The white circles represent strands corresponding to the (negligible) part of the procedure after the **sync** up to the point where it returns.\n\n### The basics of fork-join parallelism\n\nAlthough recursive spawning doesn't affect the work of a parallel loop asymptotically, we must take it into account when analyzing the span. Consider a parallel loop with \\(n\\) iterations in which the \\(i\\)th iteration has span \\(\\mathit{iter}_{\\infty}(i)\\). Since the depth of recursion is logarithmic in the number of iterations, the parallel loop's span is\n\n\\[T_{\\infty}(n)=\\Theta(\\lg n)+\\max\\left\\{\\mathit{iter}_{\\infty}(i):1\\leq i\\, \\leq n\\right\\}\\;.\\]\n\nFor example, let's compute the span of the doubly nested loops in lines 1-3 of P-Mat-Vec. The span for the **parallel for** loop control is \\(\\Theta(\\lg n)\\). For each iteration of the outer parallel loop, the inner serial **for** loop contains \\(n\\) iterations of line 3. Since each iteration takes constant time, the total span for the inner serial **for** loop is \\(\\Theta(n)\\), no matter which iteration of the outer **parallel for** loop it's in. Thus, taking the maximum over all iterations of the outer loop and adding in the \\(\\Theta(\\lg n)\\) for loop control yields an overall span of \\(T_{\\infty}n=\\Theta(n)+\\Theta(\\lg n)=\\Theta(n)\\) for the procedure. Since the work is \\(\\Theta(n^{2})\\), the parallelism is \\(\\Theta(n^{2})/\\Theta(n)=\\Theta(n)\\). (Exercise 26.1-7 asks you to provide an implementation with even more parallelism.)\n\n##### Race conditions\n\nA parallel algorithm is _deterministic_ if it always does the same thing on the same input, no matter how the instructions are scheduled on the multicore computer. It is _nondeterministic_ if its behavior might vary from run to run when the input is the same. A parallel algorithm that is intended to be deterministic may nevertheless act nondeterministically, however, if it contains a difficult-to-diagnose bug called a \"determinacy race.\"\n\nFamous race bugs include the Therac-25 radiation therapy machine, which killed three people and injured several others, and the Northeast Blackout of 2003, which left over 50 million people in the United States without power. These pernicious bugs are notoriously hard to find. You can run tests in the lab for days without a failure, only to discover that your software sporadically crashes in the field, sometimes with dire consequences.\n\nA _determinacy race_ occurs when two logically parallel instructions access the same memory location and at least one of the instructions modifies the value stored in the location. The toy procedure Race-Example on the following page illustrates a determinacy race. After initializing \\(x\\) to 0 in line 1, Race-Example creates two parallel strands, each of which increments \\(x\\) in line 3. Although it might seem that a call of Race-Example should always print the value 2 (its serial projection certainly does), it could instead print the value 1. Let's see how this anomaly might occur.\n\nWhen a processor increments \\(x\\), the operation is not indivisible, but is composed of a sequence of instructions:\nFigure 26.5(a) illustrates a trace representing the execution of Race-Example, with the strands broken down to individual instructions. Recall that since an ideal parallel computer supports sequential consistency, you can view the parallel execution of a parallel algorithm as an interleaving of instructions that respects the dependencies in the trace. Part (b) of the figure shows the values in an execution of the computation that elicits the anomaly. The value \\(x\\) is kept in memory, and \\(r_{1}\\) and \\(r_{2}\\) are processor registers. In step 1, one of the processors sets \\(x\\) to 0. In steps 2 and 3, processor 1 loads \\(x\\) from memory into its register \\(r_{1}\\) and increments it, producing the value 1 in \\(r_{1}\\). At that point, processor 2 comes into the picture, executing instructions 4-6. Processor 2 loads \\(x\\) from memory into register \\(r_{2}\\); increments it, producing the value 1 in \\(r_{2}\\); and then stores this value into \\(x\\), setting \\(x\\) to 1. Now, processor 1 resumes with step 7, storing the value 1 in \\(r_{1}\\) into \\(x\\), which\n\nFigure 26.5: Illustration of the determinacy race in Race-Example. **(a)** A trace showing the dependencies among individual instructions. The processor registers are \\(r_{1}\\) and \\(r_{2}\\). Instructions unrelated to the race, such as the implementation of loop control, are omitted. **(b)** An execution sequence that elicits the bug, showing the values of \\(x\\) in memory and registers \\(r_{1}\\) and \\(r_{2}\\) for each step in the execution sequence.\n\nleaves the value of \\(x\\) unchanged. Therefore, step 8 prints the value 1, rather than the value 2 that the serial projection would print.\n\nLet's recap what happened. By sequential consistency, the effect of the parallel execution is as if the executed instructions of the two processors are interleaved. If processor 1 executes all its instructions before processor 2, a trivial interleaving, the value 2 is printed. Conversely, if processor 2 executes all its instructions before processor 1, the value 2 is still printed. When the instructions of the two processors interleave nontrivially, however, it is possible, as in this example execution, that one of the updates to \\(x\\) is lost, resulting in the value 1 being printed.\n\nOf course, many executions do not elicit the bug. That's the problem with determinacy races. Generally, most instruction orderings produce correct results, such as any where the instructions on the left branch execute before the instructions on the right branch, or vice versa. But some orderings generate improper results when the instructions interleave. Consequently, races can be extremely hard to test for. Your program may fail, but you may be unable to reliably reproduce the failure in subsequent tests, confounding your attempts to locate the bug in your code and fix it. Task-parallel programming environments often provide race-detection productivity tools to help you isolate race bugs.\n\nMany parallel programs in the real world are intentionally nondeterministic. They contain determinacy races, but they mitigate the dangers of nondeterminism through the use of mutual-exclusion locks and other methods of synchronization. For our purposes, however, we'll insist on an absence of determinacy races in the algorithms we develop. Nondeterministic programs are indeed interesting, but non-deterministic programming is a more advanced topic and unnecessary for a wide swath of interesting parallel algorithms.\n\nTo ensure that algorithms are deterministic, any two strands that operate in parallel should be _mutually noninterfering_: they only read, and do not modify, any memory locations accessed by both of them. Consequently, in a **parallel for** construct, such as the outer loop of P-Mat-Vec, we want all the iterations of the body, including any code an iteration executes in subroutines, to be mutually noninterfering. And between a **spawn** and its corresponding **sync**, we want the code executed by the spawned child and the code executed by the parent to be mutually noninterfering, once again including invoked subroutines.\n\nAs an example of how easy it is to write code with unintentional races, the P-Mat-Vec-Wrong procedure on the next page is a faulty parallel implementation of matrix-vector multiplication that achieves a span of \\(\\Theta(\\lg n)\\) by parallelizing the inner **for** loop. This procedure is incorrect, unfortunately, due to determinacy races when updating \\(y_{i}\\) in line 3, which executes in parallel for all \\(n\\) values of \\(j\\).\n\nIndex variables of **parallel for** loops, such as \\(i\\) in line 1 and \\(j\\) in line 2, do not cause races between iterations. Conceptually, each iteration of the loop creates an independent variable to hold the index of that iteration during that iteration'sexecution of the loop body. Even if two parallel iterations both access the same index variable, they really are accessing different variable instances--hence different memory locations--and no race occurs.\n\nA parallel algorithm with races can sometimes be deterministic. As an example, two parallel threads might store the same value into a shared variable, and it wouldn't matter which stored the value first. For simplicity, however, we generally prefer code without determinacy races, even if the races are benign. And good parallel programmers from on code with determinacy races that cause nondeterministic behavior, if deterministic code that performs comparably is an option.\n\nBut nondeterministic code does have its place. For example, you can't implement a parallel hash table, a highly practical data structure, without writing code containing determinacy races. Much research has centered around how to extend the fork-join model to incorporate limited \"structured\" nondeterminism while avoiding the full measure of complications that arise when nondeterminism is completely unrestricted.\n\n### A chess lesson\n\nTo illustrate the power of work/span analysis, this section closes with a true story that occurred during the development of one of the first world-class parallel chess-playing programs [106] many years ago. The timings below have been simplified for exposition.\n\nThe chess program was developed and tested on a 32-processor computer, but it was designed to run on a supercomputer with 512 processors. Since the supercomputer availability was limited and expensive, the developers ran benchmarks on the small computer and extrapolated performance to the large computer.\n\nAt one point, the developers incorporated an optimization into the program that reduced its running time on an important benchmark on the small machine from \\(T_{32}=65\\) seconds to \\(T^{\\prime}_{32}=40\\) seconds. Yet, the developers used the work and span performance measures to conclude that the optimized version, which was faster on 32 processors, would actually be slower than the original version on the 512 processors of the large machine. As a result, they abandoned the \"optimization.\"\n\nHere is their work/span analysis. The original version of the program had work \\(T_{1}=2048\\) seconds and span \\(T_{\\infty}=1\\) second. Let's treat inequality (26.4) on page 760 as the equation \\(T_{P}\\,=\\,T_{1}/P\\,+\\,T_{\\infty}\\), which we can use as an approximation to the running time on \\(P\\) processors. Then indeed we have \\(T_{32}=2048/32\\,+\\,1=65\\). With the optimization, the work becomes \\(T_{1}^{\\prime}=1024\\) seconds, and the span becomes \\(T_{\\infty}^{\\prime}=8\\) seconds. Our approximation gives \\(T_{32}^{\\prime}=1024/32\\,+\\,8=40\\).\n\nThe relative speeds of the two versions switch when we estimate their running times on 512 processors, however. The first version has a running time of \\(T_{512}=2048/512+1\\,=\\,5\\) seconds, and the second version runs in \\(T_{512}^{\\prime}=1024/512+8\\,=\\,10\\) seconds. The optimization that speeds up the program on 32 processors makes the program run for twice as long on 512 processors! The optimized version's span of 8, which is not the dominant term in the running time on 32 processors, becomes the dominant term on 512 processors, nullifying the advantage from using more processors. The optimization does not scale up.\n\nThe moral of the story is that work/span analysis, and measurements of work and span, can be superior to measured running times alone in extrapolating an algorithm's scalability.\n\n##### Exercises\n\n##### 26.1-1\n\nWhat does a trace for the execution of a serial algorithm look like?\n\n##### 26.1-2\n\nSuppose that line 4 of P-Fib spawns P-Fib\\((n-2)\\), rather than calling it as is done in the pseudocode. How would the trace of P-Fib\\((4)\\) in Figure 26.2 change? What is the impact on the asymptotic work, span, and parallelism?\n\n##### 26.1-3\n\nDraw the trace that results from executing P-Fib\\((5)\\). Assuming that each strand in the computation takes unit time, what are the work, span, and parallelism of the computation? Show how to schedule the trace on 3 processors using greedy scheduling by labeling each strand with the time step in which it is executed.\n\n##### 26.1-4\n\nProve that a greedy scheduler achieves the following time bound, which is slightly stronger than the bound proved in Theorem 26.1:\n\n\\[T_{P}\\,\\leq\\,\\frac{T_{1}-T_{\\infty}}{P}+T_{\\infty}. \\tag{26.5}\\]\n\n##### 26.1-5\n\nConstruct a trace for which one execution by a greedy scheduler can take nearly twice the time of another execution by a greedy scheduler on the same number of processors. Describe how the two executions would proceed.\n\n#### 26.1-6\n\nProfessor Karan measures her deterministic task-parallel algorithm on 4, 10, and 64 processors of an ideal parallel computer using a greedy scheduler. She claims that the three runs yielded \\(T_{4}=80\\) seconds, \\(T_{10}=42\\) seconds, and \\(T_{64}=10\\) seconds. Argue that the professor is either lying or incompetent. (_Hint:_ Use the work law (26.2), the span law (26.3), and inequality (26.5) from Exercise 26.1-4.)\n\n#### 26.1-7\n\nGive a parallel algorithm to multiply an \\(n\\times n\\) matrix by an \\(n\\)-vector that achieves \\(\\Theta(n^{2}/\\lg n)\\) parallelism while maintaining \\(\\Theta(n^{2})\\) work.\n\n#### 26.1-8\n\nAnalyze the work, span, and parallelism of the procedure P-Transpose, which transposes an \\(n\\times n\\) matrix \\(A\\) in place.\n\nP-Transpose(\\(A,n\\))\n\n1 **parallel for \\(j\\ =\\ 2\\) to \\(n\\)**\n\n2 **parallel for \\(i\\ =\\ 1\\) to \\(j\\ -1\\)**\n\n3 **exchange \\(a_{ij}\\) with \\(a_{ji}\\)**\n\n#### 26.1-9\n\nSuppose that instead of a **parallel for** loop in line 2, the P-Transpose procedure in Exercise 26.1-8 had an ordinary **for** loop. Analyze the work, span, and parallelism of the resulting algorithm.\n\n#### 26.1-10\n\nFor what number of processors do the two versions of the chess program run equally fast, assuming that \\(T_{P}\\ =\\ T_{1}/P\\ +\\ T_{\\infty}\\)?\n\n### 26.2 Parallel matrix multiplication\n\nIn this section, we'll explore how to parallelize the three matrix-multiplication algorithms from Sections 4.1 and 4.2. We'll see that each algorithm can be parallelized in a straightforward fashion using either parallel loops or recursive spawning. We'll analyze them using work/span analysis, and we'll see that each parallel algorithm attains the same performance on one processor as its corresponding serial algorithm, while scaling up to large numbers of processors.",
        "chapter": "Part VII Selected Topics",
        "section": "26 Parallel Algorithms",
        "subsection": "26.1 The basics of fork-join parallelism",
        "subsubsection": "N/A"
    },
    {
        "content": "#### 26.1-6\n\nProfessor Karan measures her deterministic task-parallel algorithm on 4, 10, and 64 processors of an ideal parallel computer using a greedy scheduler. She claims that the three runs yielded \\(T_{4}=80\\) seconds, \\(T_{10}=42\\) seconds, and \\(T_{64}=10\\) seconds. Argue that the professor is either lying or incompetent. (_Hint:_ Use the work law (26.2), the span law (26.3), and inequality (26.5) from Exercise 26.1-4.)\n\n#### 26.1-7\n\nGive a parallel algorithm to multiply an \\(n\\times n\\) matrix by an \\(n\\)-vector that achieves \\(\\Theta(n^{2}/\\lg n)\\) parallelism while maintaining \\(\\Theta(n^{2})\\) work.\n\n#### 26.1-8\n\nAnalyze the work, span, and parallelism of the procedure P-Transpose, which transposes an \\(n\\times n\\) matrix \\(A\\) in place.\n\nP-Transpose(\\(A,n\\))\n\n1 **parallel for \\(j\\ =\\ 2\\) to \\(n\\)**\n\n2 **parallel for \\(i\\ =\\ 1\\) to \\(j\\ -1\\)**\n\n3 **exchange \\(a_{ij}\\) with \\(a_{ji}\\)**\n\n#### 26.1-9\n\nSuppose that instead of a **parallel for** loop in line 2, the P-Transpose procedure in Exercise 26.1-8 had an ordinary **for** loop. Analyze the work, span, and parallelism of the resulting algorithm.\n\n#### 26.1-10\n\nFor what number of processors do the two versions of the chess program run equally fast, assuming that \\(T_{P}\\ =\\ T_{1}/P\\ +\\ T_{\\infty}\\)?\n\n### 26.2 Parallel matrix multiplication\n\nIn this section, we'll explore how to parallelize the three matrix-multiplication algorithms from Sections 4.1 and 4.2. We'll see that each algorithm can be parallelized in a straightforward fashion using either parallel loops or recursive spawning. We'll analyze them using work/span analysis, and we'll see that each parallel algorithm attains the same performance on one processor as its corresponding serial algorithm, while scaling up to large numbers of processors.\n\n### A parallel algorithm for matrix multiplication using parallel loops\n\nThe first algorithm we'll study is P-Matrix-Multiply, which simply parallelizes the two outer loops in the procedure Matrix-Multiply on page 1.\n\nP-Matrix-Multiply (\\(A\\), \\(B\\), \\(C\\), \\(n\\))\n\n**parallel for \\(i\\ =\\ 1\\) to \\(n\\)**// compute entries in each of \\(n\\) rows\n\n**parallel for \\(j\\ =\\ 1\\) to \\(n\\)**// compute \\(n\\) entries in row \\(i\\)\n\n**for \\(k\\ =\\ 1\\) to \\(n\\)**\n\n\\(c_{ij}\\ =\\ c_{ij}+a_{ik}\\cdot b_{kj}\\)**// add in another term of equation (4.1)\n\nLet's analyze P-Matrix-Multiply. Since the serial projection of the algorithm is just Matrix-Multiply, the work is the same as the running time of Matrix-Multiply: \\(T_{1}(n)=\\Theta(n^{3})\\). The span is \\(T_{\\infty}(n)=\\Theta(n)\\), because it follows a path down the tree of recursion for the **parallel for** loop starting in line 1, then down the tree of recursion for the **parallel for** loop starting in line 2, and then executes all \\(n\\) iterations of the ordinary **for** loop starting in line 3, resulting in a total span of \\(\\Theta(\\lg n)+\\Theta(\\lg n)+\\Theta(n)=\\Theta(n)\\). Thus the parallelism is \\(\\Theta(n^{3})/\\Theta(n)=\\Theta(n^{2})\\). (Exercise 26.2-3 asks you to parallelize the inner loop to obtain a parallelism of \\(\\Theta(n^{3}/\\lg n)\\), which you cannot do straightforwardly using **parallel for**, because you would create races.)\n\n### A parallel divide-and-conquer algorithm for matrix multiplication\n\nSection 4.1 shows how to multiply \\(n\\times n\\) matrices serially in \\(\\Theta(n^{3})\\) time using a divide-and-conquer strategy. Let's see how to parallelize that algorithm using recursive spawning instead of calls.\n\nThe serial Matrix-Multiply-Recursive procedure on page 1.1 takes as input three \\(n\\times n\\) matrices \\(A\\), \\(B\\), and \\(C\\) and performs the matrix calculation \\(C\\ =\\ C+A\\cdot B\\) by recursively performing eight multiplications of \\(n/2\\times n/2\\) submatrices of \\(A\\) and \\(B\\). The P-Matrix-Multiply-Recursive procedure on the following page implements the same divide-and-conquer strategy, but it uses spawning to perform the eight multiplications in parallel. To avoid determinacy races in updating the elements of \\(C\\), it creates a temporary matrix \\(D\\) to store four of the submatrix products. At the end, it adds \\(C\\) and \\(D\\) together to produce the final result. (Problem 2.1-2 asks you to eliminate the temporary matrix \\(D\\) at the expense of some parallelism.)\n\nLines 2-3 of P-Matrix-Multiply-Recursive handle the base case of multiplying \\(1\\times 1\\) matrices. The remainder of the procedure deals with the recursive case. Line 4 allocates a temporary matrix \\(D\\), and lines 5-7 zero it. Line 8 partitions each of the four matrices \\(A\\), \\(B\\), \\(C\\), and \\(D\\) into \\(n/2\\times n/2\\) submatrices. (Aswith Matrix-Multiply-Recursive on page 83, we're glossing over the subtle issue of how to use index calculations to represent submatrix sections of a matrix.) The spawned recursive call in line 9 sets \\(C_{11}=C_{11}+A_{11}\\cdot B_{11}\\), so that \\(C_{11}\\) accumulates the first of the two terms in equation (4.5) on page 82. Similarly, lines 10-12 cause each of \\(C_{12}\\), \\(C_{21}\\), and \\(C_{22}\\) in parallel to accumulate the first of the two terms in equations (4.6)-(4.8), respectively. Line 13 sets the submatrix \\(D_{11}\\) to the submatrix product \\(A_{12}\\cdot B_{21}\\), so that \\(D_{11}\\) equals the second of the two terms in equation (4.5). Lines 14-16 set each of \\(D_{12}\\), \\(D_{21}\\), and \\(D_{22}\\) in parallel to the second of the two terms in equations (4.6)-(4.8), respectively. The **sync** statement in line 17 ensures that all the spawned submatrix products in lines 9-16 have been computed, after which the doubly nested **parallel for** loops in lines 18-20 add the elements of \\(D\\) to the corresponding elements of \\(C\\).\n\nLet's analyze the P-Matrix-Multiply-Recursive procedure. We start by analyzing the work \\(M_{1}(n)\\), echoing the serial running-time analysis of its progenitor Matrix-Multiply-Recursive. The recursive case allocates and zeros the \n\n### 26.2 Parallel matrix multiplication\n\nThe matrix multiplication is a _multiplication_ matrix \\(D\\) in \\(\\Theta(n^{2})\\) time, partitions in \\(\\Theta(1)\\) time, performs eight recursive multiplications of \\(n/2\\times n/2\\) matrices, and finishes up with the \\(\\Theta(n^{2})\\) work from adding two \\(n\\times n\\) matrices. Thus the work outside the spawned recursive calls is \\(\\Theta(n^{2})\\), and the recurrence for the work \\(M_{1}(n)\\) becomes\n\n\\[M_{1}(n) = 8M_{1}(n/2)\\,+\\,\\Theta(n^{2})\\] \\[= \\Theta(n^{3})\\]\n\nby case 1 of the master theorem (Theorem 4.1). Not surprisingly, the work of this parallel algorithm is asymptotically the same as the running time of the procedure Matrix-Multiply on page 26.2, with its triply nested loops.\n\nLet's determine the span \\(M_{\\infty}(n)\\) of P-Matrix-Multiply-Recursive. Because the eight parallel recursive spawns all execute on matrices of the same size, the maximum span for any recursive spawn is just the span of a single one of them, or \\(M_{\\infty}(n/2)\\). The span for the doubly nested **parallel for** loops in lines 26-22 is \\(\\Theta(\\lg n)\\) because each loop control adds \\(\\Theta(\\lg n)\\) to the constant span of line 26. Similarly, the doubly nested **parallel for** loops in lines 26-22 add another \\(\\Theta(\\lg n)\\). Matrix partitioning by index calculation has \\(\\Theta(1)\\) span, which is dominated by the \\(\\Theta(\\lg n)\\) span of the nested loops. We obtain the recurrence\n\n\\[M_{\\infty}(n)=M_{\\infty}(n/2)\\,+\\,\\Theta(\\lg n). \\tag{26.6}\\]\n\nSince this recurrence falls under case 2 of the master theorem with \\(k=1\\), the solution is \\(M_{\\infty}(n)=\\Theta(\\lg^{2}n)\\).\n\nThe parallelism of P-Matrix-Multiply-Recursive is \\(M_{1}(n)/M_{\\infty}(n)=\\Theta(n^{3}/\\lg^{2}n)\\), which is huge. (Problem 26-2 asks you to simplify this parallel algorithm at the expense of just a little less parallelism.)\n\n### Parallelizing Strassen's method\n\nTo parallelize Strassen's algorithm, we can follow the same general outline as on pages 26-27, but use spawning. You may find it helpful to compare each step below with the corresponding step there. We'll analyze costs as we go along to develop recurrences \\(T_{1}(n)\\) and \\(T_{\\infty}(n)\\) for the overall work and span, respectively.\n\n1. If \\(n=1\\), the matrices each contain a single element. Perform a single scalar multiplication and a single scalar addition, and return. Otherwise, partition the input matrices \\(A\\) and \\(B\\) and output matrix \\(C\\) into \\(n/2\\times n/2\\) submatrices, as in equation (4.2) on page 26.2. This step takes \\(\\Theta(1)\\) work and \\(\\Theta(1)\\) span by index calculation.\n2. Create \\(n/2\\times n/2\\) matrices \\(S_{1},S_{2},\\ldots,S_{10}\\), each of which is the sum or difference of two submatrices from step 1. Create and zero the entries of seven \\(n/2\\times n/2\\) matrices \\(P_{1},\\,P_{2},\\ldots,\\,P_{7}\\) to hold seven \\(n/2\\times n/2\\) matrix products. All17 matrices can be created, and the \\(P_{i}\\) initialized, with doubly nested **parallel for** loops using \\(\\Theta(n^{2})\\) work and \\(\\Theta(\\lg n)\\) span.\n3. Using the submatrices from step 1 and the matrices \\(S_{1},S_{2},\\ldots,S_{10}\\) created in step 2, recursively spawn computations of each of the seven \\(n/2\\times n/2\\) matrix products \\(P_{1},P_{2},\\ldots,P_{7},\\) taking \\(7T_{1}(n/2)\\) work and \\(T_{\\infty}(n/2)\\) span.\n4. Update the four submatrices \\(C_{11},C_{12},C_{21},C_{22}\\) of the result matrix \\(C\\) by adding or subtracting various \\(P_{i}\\) matrices. Using doubly nested **parallel for** loops, computing all four submatrices takes \\(\\Theta(n^{2})\\) work and \\(\\Theta(\\lg n)\\) span.\n\nLet's analyze this algorithm. Since the serial projection is the same as the original serial algorithm, the work is just the running time of the serial projection, namely, \\(\\Theta(n^{\\lg 7})\\). As we did with P-Matrix-Multiply-Recursive, we can devise a recurrence for the span. In this case, seven recursive calls execute in parallel, but since they all operate on matrices of the same size, we obtain the same recurrence (26.6) as we did for P-Matrix-Multiply-Recursive, with solution \\(\\Theta(\\lg^{2}n)\\). Thus the parallel version of Strassen's method has parallelism \\(\\Theta(n^{\\lg 7}/\\lg^{2}n)\\), which is large. Although the parallelism is slightly less than that of P-Matrix-Multiply-Recursive, that's just because the work is also less.\n\n### Exercises\n\n#### 26.2-1\n\nDraw the trace for computing P-Matrix-Multiply on \\(2\\times 2\\) matrices, labeling how the vertices in your diagram correspond to strands in the execution of the algorithm. Assuming that each strand executes in unit time, analyze the work, span, and parallelism of this computation.\n\n#### 26.2-2\n\nRepeat Exercise 26.2-1 for P-Matrix-Multiply-Recursive.\n\n#### 26.2-3\n\nGive pseudocode for a parallel algorithm that multiplies two \\(n\\times n\\) matrices with work \\(\\Theta(n^{3})\\) but span only \\(\\Theta(\\lg n)\\). Analyze your algorithm.\n\n#### 26.2-4\n\nGive pseudocode for an efficient parallel algorithm that multiplies a \\(p\\times q\\) matrix by a \\(q\\times r\\) matrix. Your algorithm should be highly parallel even if any of \\(p\\), \\(q\\), and \\(r\\) equal 1. Analyze your algorithm.\n\n#### 26.2-5\n\nGive pseudocode for an efficient parallel version of the Floyd-Warshall algorithm (see Section 23.2), which computes shortest paths between all pairs of vertices in an edge-weighted graph. Analyze your algorithm.\n\n#### Parallel merge sort\n\nWe first saw serial merge sort in Section 2.3.1, and in Section 2.3.2 we analyzed its running time and showed it to be \\(\\Theta(n\\lg n)\\). Because merge sort already uses the divide-and-conquer method, it seems like a terrific candidate for implementing using fork-join parallelism.\n\nThe procedure P-Merge-Sort modifies merge sort to spawn the first recursive call. Like its serial counterpart Merge-Sort on page 26.2, the P-Merge-Sort procedure sorts the subarray \\(A[p:r]\\). After the **sync** statement in line 26.2 ensures that the two recursive spawns in lines 26.2 and 26.2 have finished, P-Merge-Sort calls the P-Merge procedure, a parallel merging algorithm, which is on page 26.2, but you don't need to bother looking at it right now.\n\nP-Merge-Sort(\\(A,\\,p,r\\))\n\n```\n1if\\(p\\geq r\\)// zero or one element?\n2return\n3\\(q=\\lfloor(p+r)/2\\rfloor\\)// midpoint of \\(A[p:r]\\)\n4// Recursively sort \\(A[p:q]\\) in parallel.\n5 spawn P-Merge-Sort(\\(A,\\,p,q\\))\n6// Recursively sort \\(A[q+1:r]\\) in parallel.\n7 spawn P-Merge-Sort(\\(A,\\,q+1,r\\))\n8sync// wait for spawns\n9// Merge \\(A[p:q]\\) and \\(A[q+1:r]\\) into \\(A[p:r]\\).\n10P-Merge(\\(A,\\,p,q,r\\))\n```\n\nFirst, let's use work/span analysis to get some intuition for why we need a parallel merge procedure. After all, it may seem as though there should be plenty of parallelism just by parallelizing Merge-Sort without worrying about parallelizing the merge. But what would happen if the call to P-Merge in line 26.2 of P-Merge-Sort were replaced by a call to the serial Merge procedure on page 26.2. Let's call the pseudocode so modified P-Naive-Merge-Sort.\n\nLet \\(T_{1}(n)\\) be the (worst-case) work of P-Naive-Merge-Sort on an \\(n\\)-element subarray, where \\(n=r-p+1\\) is the number of elements in \\(A[p:r]\\), and let \\(T_{\\infty}(n)\\)",
        "chapter": "Part VII Selected Topics",
        "section": "26 Parallel Algorithms",
        "subsection": "26.2 Parallel matrix multiplication",
        "subsubsection": "N/A"
    },
    {
        "content": "#### 26.2-5\n\nGive pseudocode for an efficient parallel version of the Floyd-Warshall algorithm (see Section 23.2), which computes shortest paths between all pairs of vertices in an edge-weighted graph. Analyze your algorithm.\n\n#### Parallel merge sort\n\nWe first saw serial merge sort in Section 2.3.1, and in Section 2.3.2 we analyzed its running time and showed it to be \\(\\Theta(n\\lg n)\\). Because merge sort already uses the divide-and-conquer method, it seems like a terrific candidate for implementing using fork-join parallelism.\n\nThe procedure P-Merge-Sort modifies merge sort to spawn the first recursive call. Like its serial counterpart Merge-Sort on page 26.2, the P-Merge-Sort procedure sorts the subarray \\(A[p:r]\\). After the **sync** statement in line 26.2 ensures that the two recursive spawns in lines 26.2 and 26.2 have finished, P-Merge-Sort calls the P-Merge procedure, a parallel merging algorithm, which is on page 26.2, but you don't need to bother looking at it right now.\n\nP-Merge-Sort(\\(A,\\,p,r\\))\n\n```\n1if\\(p\\geq r\\)// zero or one element?\n2return\n3\\(q=\\lfloor(p+r)/2\\rfloor\\)// midpoint of \\(A[p:r]\\)\n4// Recursively sort \\(A[p:q]\\) in parallel.\n5 spawn P-Merge-Sort(\\(A,\\,p,q\\))\n6// Recursively sort \\(A[q+1:r]\\) in parallel.\n7 spawn P-Merge-Sort(\\(A,\\,q+1,r\\))\n8sync// wait for spawns\n9// Merge \\(A[p:q]\\) and \\(A[q+1:r]\\) into \\(A[p:r]\\).\n10P-Merge(\\(A,\\,p,q,r\\))\n```\n\nFirst, let's use work/span analysis to get some intuition for why we need a parallel merge procedure. After all, it may seem as though there should be plenty of parallelism just by parallelizing Merge-Sort without worrying about parallelizing the merge. But what would happen if the call to P-Merge in line 26.2 of P-Merge-Sort were replaced by a call to the serial Merge procedure on page 26.2. Let's call the pseudocode so modified P-Naive-Merge-Sort.\n\nLet \\(T_{1}(n)\\) be the (worst-case) work of P-Naive-Merge-Sort on an \\(n\\)-element subarray, where \\(n=r-p+1\\) is the number of elements in \\(A[p:r]\\), and let \\(T_{\\infty}(n)\\)be the span. Because Merge is serial with running time \\(\\Theta(n)\\), both its work and span are \\(\\Theta(n)\\). Since the serial projection of P-Naive-Merge-Sort is exactly Merge-Sort, its work is \\(T_{1}(n)=\\Theta(n\\lg n)\\). The two recursive calls in lines 5 and 7 run in parallel, and so its span is given by the recurrence\n\n\\[T_{\\infty}(n) = T_{\\infty}(n/2)+\\Theta(n)\\] \\[= \\Theta(n)\\,\\]\n\nby case 1 of the master theorem. Thus the parallelism of P-Naive-Merge-Sort is \\(T_{1}(n)/T_{\\infty}(n)=\\Theta(\\lg n)\\), which is an unimpressive amount of parallelism. To sort a million elements, for example, since \\(\\lg 10^{6}\\approx 20\\), it might achieve linear speedup on a few processors, but it would not scale up to dozens of processors.\n\nThe parallelism bottleneck in P-Naive-Merge-Sort is plainly the Merge procedure. If we asymptotically reduce the span of merging, the master theorem dictates that the span of parallel merge sort will also get smaller. When you look at the pseudocode for Merge, it may seem that merging is inherently serial, but it's not. We can fashion a parallel merging algorithm. The goal is to reduce the span of parallel merging asymptotically, but if we want an efficient parallel algorithm, we must ensure that the \\(\\Theta(n)\\) bound on work doesn't increase.\n\nFigure 26.6 depicts the divide-and-conquer strategy that we'll use in P-Merge. The heart of the algorithm is a recursive auxiliary procedure P-Merge-Aux that merges two sorted subarrays of an array \\(A\\) into a subarray of another array \\(B\\) in parallel. Specifically, P-Merge-Aux merges \\(A[p_{1}\\!:\\!r_{1}]\\) and \\(A[p_{2}\\!:\\!r_{2}]\\) into subarray \\(B[p_{3}\\!:\\!r_{3}]\\), where \\(r_{3}=p_{3}+(r_{1}-p_{1}+1)+(r_{2}-p_{2}+1)-1=p_{3}+(r_{1}-p_{1})+(r_{2}-p_{2} )+1\\).\n\nThe key idea of the recursive merging algorithm in P-Merge-Aux is to split each of the two sorted subarrays of \\(A\\) around a pivot \\(x\\), such that all the elements in the lower part of each subarray are at most \\(x\\) and all the elements in the upper part of each subarray are at least \\(x\\). The procedure can then recurse in parallel on two subtasks: merging the two lower parts, and merging the two upper parts. The trick is to find a pivot \\(x\\) so that the recursion is not too lopsided. We don't want a situation such as that in Quicksort on page 183, where bad partitioning elements lead to a dramatic loss of asymptotic efficiency. We could opt to partition around a random element, as Randomized-Quicksort on page 192 does, but because the input subarrays are sorted, P-Merge-Aux can quickly determine a pivot that always works well.\n\nSpecifically, the recursive merging algorithm picks the pivot \\(x\\) as the middle element of the larger of the two input subarrays, which we can assume without loss of generality is \\(A[p_{1}\\!:\\!r_{1}]\\), since otherwise, the two subarrays can just switch roles. That is, \\(x=A[q_{1}]\\), where \\(q_{1}=\\lfloor(p_{1}+r_{1})/2\\rfloor\\). Because \\(A[p_{1}\\!:\\!r_{1}]\\) is sorted, \\(x\\) is a median of the subarray elements: every element in \\(A[p_{1}\\!:\\!q_{1}-1]\\) is no more than \\(x\\), and every element in \\(A[q_{1}+1\\!:\\!r_{1}]\\) is no less than \\(x\\). Then the \n\n### 26.3 Parallel merge sort\n\nalgorithm finds the \"split point\" \\(q_{2}\\) in the smaller subarray \\(A[p_{2}\\!:\\!r_{2}]\\) such that all the elements in \\(A[p_{2}\\!:\\!q_{2}\\!-\\!1]\\) (if any) are at most \\(x\\) and all the elements in \\(A[q_{2}\\!:\\!r_{2}]\\) (if any) are at least \\(x\\). Intuitively, the subarray \\(A[p_{2}\\!:\\!r_{2}]\\) would still be sorted if \\(x\\) were inserted between \\(A[q_{2}\\!-\\!1]\\) and \\(A[q_{2}]\\) (although the algorithm doesn't do that). Since \\(A[p_{2}\\!:\\!r_{2}]\\) is sorted, a minor variant of binary search (see Exercise 2.3-6) with \\(x\\) as the search key can find the split point \\(q_{2}\\) in \\(\\Theta(\\lg n)\\) time in the worst case. As we'll see when we get to the analysis, even if \\(x\\) splits \\(A[p_{2}\\!:\\!r_{2}]\\) badly\\(\\!-\\!x\\) is either smaller than all the subarray elements or larger--we'll still have at least \\(1/4\\) of the elements in each of the two recursive merges. Thus the larger of the recursive merges operates on at most \\(3/4\\) elements, and the recursion is guaranteed to bottom out after \\(\\Theta(\\lg n)\\) recursive calls.\n\nNow let's put these ideas into pseudocode. We start with the serial procedure Find-Split-Point(\\(A\\), \\(p\\!,r\\!,x\\)) on the next page, which takes as input a sorted subarray \\(A[p\\!:\\!r]\\) and a key \\(x\\). The procedure returns a split point of \\(A[p\\!:\\!r]\\): an index \\(q\\) in the range \\(p\\leq q\\leq r+1\\) such that all the elements in \\(A[p\\!:\\!q-1]\\) (if any) are at most \\(x\\) and all the elements in \\(A[q\\!:\\!r]\\) (if any) are at least \\(x\\).\n\nThe Find-Split-Point procedure uses binary search to find the split point. Lines 1 and 2 establish the range of indices for the search. Each time through the **while** loop, line 5 compares the middle element of the range with the search key \\(x\\), and lines 6 and 7 narrow the search range to either the lower half or the upper half of the subarray, depending on the result of the test. In the end, after the range has been narrowed to a single index, line 8 returns that index as the split point.\n\nFigure 26.6: The idea behind P-Merge-Aux, which merges two sorted subarrays \\(A[p_{1}\\!:\\!r_{1}]\\) and \\(A[p_{2}\\!:\\!r_{2}]\\) into the subarray \\(B[p_{3}\\!:\\!r_{3}]\\) in parallel. Letting \\(x=A[q_{1}]\\) (shown in yellow) be a median of \\(A[p_{1}\\!:\\!r_{1}]\\) and \\(q_{2}\\) be a place in \\(A[p_{2}\\!:\\!r_{2}]\\) such that \\(x\\) would fall between \\(A[q_{2}-1]\\) and \\(A[q_{2}]\\), every element in the subarrays \\(A[p_{1}\\!:\\!q_{1}-1]\\) and \\(A[p_{2}\\!:\\!q_{2}-1]\\) (shown in orange) is at most \\(x\\), and every element in the subarrays \\(A[q_{1}+1\\!:\\!r_{1}]\\) and \\(A[q_{2}+1\\!:\\!r_{2}]\\) (shown in blue) is at least \\(x\\). To merge, compute the index \\(q_{3}\\) where \\(x\\) belongs in \\(B[p_{3}\\!:\\!r_{3}]\\), copy \\(x\\) into \\(B[q_{3}]\\), and then recursively merge \\(A[p_{1}\\!:\\!q_{1}-1]\\) with \\(A[p_{2}\\!:\\!q_{2}-1]\\) into \\(B[p_{3}\\!:\\!q_{3}-1]\\) and \\(A[q_{1}+1\\!:\\!r_{1}]\\) with \\(A[q_{2}\\!:\\!r_{2}]\\) into \\(B[q_{3}+1\\!:\\!r_{3}]\\).\n\nBecause Find-Split-Point contains no parallelism, its span is just its serial running time, which is also its work. On a subarray \\(A[p:r]\\) of size \\(n=r-p+1\\), each iteration of the **while** loop halves the search range, which means that the loop terminates after \\(\\Theta(\\lg n)\\) iterations. Since each iteration takes constant time, the algorithm runs in \\(\\Theta(\\lg n)\\) (worst-case) time. Thus the procedure has work and span \\(\\Theta(\\lg n)\\).\n\nLet's now look at the pseudocode for the parallel merging procedure P-Merge on the next page. Most of the pseudocode is devoted to the recursive procedure P-Merge-Aux. The procedure P-Merge itself is just a \"wrapper\" that sets up for P-Merge-Aux. It allocates a new array \\(B[p:r]\\) to hold the output of P-Merge-Aux in line 1. It then calls P-Merge-Aux in line 2, passing the indices of the two subarrays to be merged and providing \\(B\\) as the output destination of the merged result, starting at index \\(p\\). After P-Merge-Aux returns, lines 3-4 perform a parallel copy of the output \\(B[p:r]\\) into the subarray \\(A[p:r]\\), which is where P-Merge-Sort expects it.\n\nThe P-Merge-Aux procedure is the interesting part of the algorithm. Let's start by understanding the parameters of this recursive parallel procedure. The input array \\(A\\) and the four indices \\(p_{1},r_{1},p_{2},r_{2}\\) specify the subarrays \\(A[p_{1}:r_{1}]\\) and \\(A[p_{2}:r_{2}]\\) to be merged. The array \\(B\\) and the index \\(p_{3}\\) indicate that the merged result should be stored into \\(B[p_{3}:r_{3}]\\), where \\(r_{3}=p_{3}+(r_{1}-p_{1})+(r_{2}-p_{2})+1\\), as we saw earlier. The end index \\(r_{3}\\) of the output subarray is not needed by the pseudocode, but it helps conceptually to name the end index, as in the comment in line 13.\n\nThe procedure begins by checking the base case of the recursion and doing some bookkeeping to simplify the rest of the pseudocode. Lines 1 and 2 test whether the two subarrays are both empty, in which case the procedure returns. Line 3 checks whether the first subarray contains fewer elements than the second subarray. Since the number of elements in the first subarray is \\(r_{1}-p_{1}+1\\) and the number in the second subarray is \\(r_{2}-p_{2}+1\\), the test omits the two \"\\(+1\\)'s.\" If the first subarrayis the smaller of the two, lines 4 and 5 switch the roles of the subarrays so that \\(A[p_{1},r_{1}]\\) refers to the larger subarray for the balance of the procedure.\n\nWe're now at the crux of P-Merge-Aux: implementing the parallel divide-and-conquer strategy. As we continue our pseudocode walk, you may find it helpful to refer again to Figure 26.6.\n\nFirst the divide step. Line 6 computes the midpoint \\(q_{1}\\) of \\(A[p_{1}\\!:\\!r_{1}]\\), which indexes a median \\(x=A[q_{1}]\\) of this subarray to be used as the pivot, and line 7 determines \\(x\\) itself. Next, line 8 uses the Find-Split-Point procedure to find the index \\(q_{2}\\) in \\(A[p_{2}\\!:\\!r_{2}]\\) such that all elements in \\(A[p_{2}\\!:\\!q_{2}-1]\\) are at most \\(x\\) and all the elements in \\(A[q_{2}\\!:\\!r_{2}]\\) are at least \\(x\\). Line 9 computes the index \\(q_{3}\\) of the element that divides the output subarray \\(B[p_{3}\\!:\\!r_{3}]\\) into \\(B[p_{3}\\!:\\!q_{3}-1]\\) and \\(B[q_{3}+1\\!:\\!r_{3}]\\), and then line 10 puts \\(x\\) directly into \\(B[q_{3}]\\), which is where it belongs in the output.\n\nNext is the conquer step, which is where the parallel recursion occurs. Lines 12 and 14 each spawn P-Merge-Aux to recursively merge from \\(A\\) into \\(B\\), the first to merge the smaller elements and the second to merge the larger elements. The \n\n**sync** statement in line 15 ensures that the subproblems finish before the procedure returns.\n\nThere is no combine step, as \\(B[p:r]\\) already contains the correct sorted output.\n\n### Work/span analysis of parallel merging\n\nLet's first analyze the worst-case span \\(T_{\\infty}(n)\\) of P-Merge-Aux on input subarrays that together contain a total of \\(n\\) elements. The call to Find-Split-Point in line 8 contributes \\(\\Theta(\\lg n)\\) to the span in the worst case, and the procedure performs at most a constant amount of additional serial work outside of the two recursive spawns in lines 12 and 14.\n\nBecause the two recursive spawns operate logically in parallel, only one of them contributes to the overall worst-case span. We claimed earlier that neither recursive invocation ever operates on more than \\(3n/4\\) elements. Let's see why. Let \\(n_{1}=r_{1}-p_{1}+1\\) and \\(n_{2}=r_{2}-p_{2}+1\\), where \\(n=n_{1}+n_{2}\\), be the sizes of the two subarrays when line 6 starts executing, that is, after we have established that \\(n_{2}\\leq n_{1}\\) by swapping the roles of the two subarrays, if necessary. Since the pivot \\(x\\) is a median of of \\(A[p_{1}:r_{1}]\\), in the worst case, a recursive merge involves at most \\(n_{1}/2\\) elements of \\(A[p_{1}:r_{1}]\\), but it might involve all \\(n_{2}\\) of the elements of \\(A[p_{2}:r_{2}]\\). Thus we can bound the number of elements involved in a recursive invocation of P-Merge-Aux by\n\n\\[n_{1}/2+n_{2} = (2n_{1}+4n_{2})/4\\] \\[\\leq (3n_{1}+3n_{2})/4\\quad(\\mbox{since $n_{2}\\leq n_{1}$})\\] \\[= 3n/4\\,\\]\n\nproving the claim.\n\nThe worst-case span of P-Merge-Aux can therefore be described by the following recurrence:\n\n\\[T_{\\infty}(n)=T_{\\infty}(3n/4)+\\Theta(\\lg n). \\tag{26.7}\\]\n\nBecause this recurrence falls under case 2 of the master theorem with \\(k=1\\), its solution is \\(T_{\\infty}(n)=\\Theta(\\lg^{2}n)\\).\n\nNow let's verify that the work \\(T_{1}(n)\\) of P-Merge-Aux on \\(n\\) elements is linear. A lower bound of \\(\\Omega(n)\\) is straightforward, since each of the \\(n\\) elements is copied from array \\(A\\) to array \\(B\\). We'll show that \\(T_{1}(n)=O(n)\\) by deriving a recurrence for the worst-case work. The binary search in line 8 costs \\(\\Theta(\\lg n)\\) in the worst case, which dominates the other work outside of the recursive spawns. For the recursive spawns, observe that although lines 12 and 14 might merge different numbers of elements, the two recursive spawns together merge at most \\(n-1\\) elements (since \\(x=A[q]\\) is not merged). Moreover, as we saw when analyzing the span, a recursive spawn operates on at most \\(3n/4\\) elements. We therefore obtain the recurrence\\(T_{1}(n)=T_{1}(\\alpha\\,n)+T_{1}((1-\\alpha)n)+\\Theta(\\lg n)\\),\n\nwhere \\(\\alpha\\) lies in the range \\(1/4\\leq\\alpha\\leq 3/4\\). The value of \\(\\alpha\\) can vary from one recursive invocation to another.\n\nWe'll use the substitution method (see Section 4.3) to prove that the above recurrence (26.8) has solution \\(T_{1}(n)=O(n)\\). (You could also use the Akra-Bazzi method from Section 4.7.) Assume that \\(T_{1}(n)\\leq c_{1}n-c_{2}\\lg n\\) for some positive constants \\(c_{1}\\) and \\(c_{2}\\). Using the properties of logarithms on pages 66-67--in particular, to deduce that \\(\\lg\\alpha+\\lg(1-\\alpha)=-\\Theta(1)\\)--substitution yields\n\n\\[\\begin{array}{l}T_{1}(n)\\ \\leq\\ (c_{1}\\alpha\\,n-c_{2}\\lg(\\alpha\\,n))+(c_{1}(1- \\alpha)n-c_{2}\\lg((1-\\alpha)n))+\\Theta(\\lg n)\\\\ \\for its span. The work recurrence has solution \\(T_{1}(n)=\\Theta(n\\lg n)\\) by case 2 of the master theorem with \\(k=0\\). The span recurrence has solution \\(T_{\\infty}(n)=\\Theta(\\lg^{3}n)\\), also by case 2 of the master theorem, but with \\(k=2\\).\n\nParallel merging gives P-Merge-Sort a parallelism advantage over P-Naive-Merge-Sort. The parallelism of P-Naive-Merge-Sort, which calls the serial Merge procedure, is only \\(\\Theta(\\lg n)\\). For P-Merge-Sort, the parallelism is\n\n\\[T_{1}(n)/\\,T_{\\infty}(n) = \\Theta(n\\lg n)/\\,\\Theta(\\lg^{3}n)\\] \\[= \\Theta(n/\\lg^{2}n)\\,\\]\n\nwhich is much better, both in theory and in practice. A good implementation in practice would sacrifice some parallelism by coarsening the base case in order to reduce the constants hidden by the asymptotic notation. For example, you could switch to an efficient serial sort, perhaps quicksort, when the number of elements to be sorted is sufficiently small.\n\n### Exercises\n\n#### 26.3-1\n\nExplain how to coarsen the base case of P-Merge.\n\n#### 26.3-2\n\nInstead of finding a median element in the larger subarray, as P-Merge does, suppose that the merge procedure finds a median of all the elements in the two sorted subarrays using the result of Exercise 9.3-10. Give pseudocode for an efficient parallel merging procedure that uses this median-finding procedure. Analyze your algorithm.\n\n#### 26.3-3\n\nGive an efficient parallel algorithm for partitioning an array around a pivot, as is done by the Partition procedure on page 184. You need not partition the array in place. Make your algorithm as parallel as possible. Analyze your algorithm. (_Hint:_ You might need an auxiliary array and might need to make more than one pass over the input elements.)\n\n#### 26.3-4\n\nGive a parallel version of FFT on page 890. Make your implementation as parallel as possible. Analyze your algorithm.\n\n#### 26.3-5\n\nShow how to parallelize Select from Section 9.3. Make your implementation as parallel as possible. Analyze your algorithm.\n\n## Problems\n\n### Implementing parallel loops using recursive spawning\n\nConsider the parallel procedure Sum-Arrays for performing pairwise addition on \\(n\\)-element arrays \\(A[1:n]\\) and \\(B[1:n]\\), storing the sums in \\(C[1:n]\\).\n\nSum-Arrays(\\(A,B,C,n\\))\n\n**parallel for \\(i\\ =\\ 1\\) to \\(n\\)**\n\n**2**\\(C[i]\\ =\\ A[i]+B[i]\\)\n\n* Rewrite the parallel loop in Sum-Arrays using recursive spawning in the manner of P-Mat-Vec-Recursive. Analyze the parallelism. Consider another implementation of the parallel loop in Sum-Arrays given by the procedure Sum-Arrays\\({}^{\\prime}\\), where the value _grain-size_ must be specified. Sum-Arrays\\({}^{\\prime}\\)(\\(A,B,C,n\\))\n\n**2**\\(r\\ =\\ \\lceil n/\\mbox{\\it grain-size}\\rceil\\)\n\n**3**for \\(k\\ =\\ 0\\) to \\(r-1\\)\n\n**4**spawn Add-Subarray(\\(A,B,C,k\\cdot\\mbox{\\it grain-size}\\ +1,\\)\n\n\\(\\min\\left\\{(k\\ +\\ 1)\\cdot\\mbox{\\it grain-size},n\\right\\}\\))\n\n**5**sync**\n\nAdd-Subarray(\\(A,B,C,i,j\\))\n\n**1**for \\(k\\ =\\ i\\) to \\(j\\)\n\n**2**\\(C[k]\\ =\\ A[k]+B[k]\\)\n\n* Suppose that you set _grain-size_\\(=\\ 1\\). What is the resulting parallelism?\n* Give a formula for the span of Sum-Arrays\\({}^{\\prime}\\) in terms of \\(n\\) and _grain-size_. Derive the best value for _grain-size_ to maximize parallelism.\n\n### Avoiding a temporary matrix in recursive matrix multiplication\n\nThe P-Matrix-Multiply-Recursive procedure on page 772 must allocate a temporary matrix \\(D\\) of size \\(n\\times n\\), which can adversely affect the constants hidden by the \\(\\Theta\\)-notation. The procedure has high parallelism, however: \\(\\Theta(n^{3}/\\log^{2}n)\\).",
        "chapter": "Part VII Selected Topics",
        "section": "26 Parallel Algorithms",
        "subsection": "26.3 Parallel merge sort",
        "subsubsection": "N/A"
    },
    {
        "content": "## Problems\n\n### Implementing parallel loops using recursive spawning\n\nConsider the parallel procedure Sum-Arrays for performing pairwise addition on \\(n\\)-element arrays \\(A[1:n]\\) and \\(B[1:n]\\), storing the sums in \\(C[1:n]\\).\n\nSum-Arrays(\\(A,B,C,n\\))\n\n**parallel for \\(i\\ =\\ 1\\) to \\(n\\)**\n\n**2**\\(C[i]\\ =\\ A[i]+B[i]\\)\n\n* Rewrite the parallel loop in Sum-Arrays using recursive spawning in the manner of P-Mat-Vec-Recursive. Analyze the parallelism. Consider another implementation of the parallel loop in Sum-Arrays given by the procedure Sum-Arrays\\({}^{\\prime}\\), where the value _grain-size_ must be specified.\n\nSum-Arrays\\({}^{\\prime}\\)(\\(A,B,C,n\\))\n\n**2**\\(r\\ =\\ \\lceil n/\\)_grain-size_\\(e\\rceil\\)\n\n**3**for \\(k\\ =\\ 0\\) to \\(r-1\\)\n\n**4**spawn Add-Subarray(\\(A,B,C,k\\cdot\\mbox{grain-size}\\ +\\ 1,\\)\n\n\\(\\min\\left\\{(k\\ +\\ 1)\\cdot\\mbox{grain-size},n\\right\\}\\))\n\n**5**sync**\n\nAdd-Subarray(\\(A,B,C,i,j\\))\n\n**1**for \\(k\\ =\\ i\\) to \\(j\\)\n\n**2**\\(C[k]\\ =\\ A[k]+B[k]\\)\n\n* Suppose that you set _grain-size_\\(=1\\). What is the resulting parallelism?\n* Give a formula for the span of Sum-Arrays\\({}^{\\prime}\\) in terms of \\(n\\) and _grain-size_. Derive the best value for _grain-size_ to maximize parallelism.\n\n### Avoiding a temporary matrix in recursive matrix multiplication\n\nThe P-Matrix-Multiply-Recursive procedure on page 772 must allocate a temporary matrix \\(D\\) of size \\(n\\times n\\), which can adversely affect the constants hidden by the \\(\\Theta\\)-notation. The procedure has high parallelism, however: \\(\\Theta(n^{3}/\\log^{2}n)\\)For example, ignoring the constants in the \\(\\Theta\\)-notation, the parallelism for multiplying \\(1000\\times 1000\\) matrices comes to approximately \\(1000^{3}/10^{2}=10^{7}\\), since \\(\\lg 1000\\approx 10\\). Most parallel computers have far fewer than 10 million processors.\n\n1. Parallelize Matrix-Multiply-Recursive without using temporary matrices so that it retains its \\(\\Theta(n^{3})\\) work. (_Hint:_ Spawn the recursive calls, but insert a **sync** in a judicious location to avoid races.)\n2. Give and solve recurrences for the work and span of your implementation.\n3. Analyze the parallelism of your implementation. Ignoring the constants in the \\(\\Theta\\)-notation, estimate the parallelism on \\(1000\\times 1000\\) matrices. Compare with the parallelism of P-Matrix-Multiply-Recursive, and discuss whether the trade-off would be worthwhile.\n\n#### Parallel matrix algorithms\n\nBefore attempting this problem, it may be helpful to read Chapter 28.\n\n1. Parallelize the LU-Decomposition procedure on page 827 by giving pseudocode for a parallel version of this algorithm. Make your implementation as parallel as possible, and analyze its work, span, and parallelism.\n2. Do the same for LUP-Decomposition on page 830.\n3. Do the same for LUP-Solve on page 824.\n4. Using equation (28.14) on page 835, write pseudocode for a parallel algorithm to invert a symmetric positive-definite matrix. Make your implementation as parallel as possible, and analyze its work, span, and parallelism.\n\n#### Parallel reductions and scan (prefix) computations\n\nA \\(\\otimes\\)**-reduction** of an array \\(x[1:n]\\), where \\(\\otimes\\) is an associative operator, is the value \\(y=x[1]\\otimes x[2]\\otimes\\cdots\\otimes x[n]\\). The Reduce procedure computes the \\(\\otimes\\)-reduction of a subarray \\(x[i:j]\\) serially.\n\nReduce(\\(x,i,j\\))\n2. \\(y\\,=\\,x[i]\\)\n3. \\(k\\,=\\,i\\,+\\,1\\) to \\(j\\)\n4. \\(y\\,=\\,y\\otimes x[k]\\)\n5. **return**\\(y\\)\nDesign and analyze a parallel algorithm P-Reduce that uses recursive spawninging to perform the same function with \\(\\Theta(n)\\) work and \\(\\Theta(\\lg n)\\) span.\n\nA related problem is that of computing a \\(\\otimes\\)-_scan_, sometimes called a \\(\\otimes\\)-_prefix computation_, on an array \\(x[1:n]\\), where \\(\\otimes\\) is once again an associative operator. The \\(\\otimes\\)-scan, implemented by the serial procedure Scan, produces the array \\(y[1:n]\\) given by\n\n\\[y[1] = x[1]\\,\\] \\[y[2] = x[1]\\otimes x[2]\\,\\] \\[y[3] = x[1]\\otimes x[2]\\otimes x[3]\\,\\] \\[\\vdots\\] \\[y[n] = x[1]\\otimes x[2]\\otimes x[3]\\otimes\\cdots\\otimes x[n]\\,\\]\n\nthat is, all prefixes of the array \\(x\\) \"summed\" using the \\(\\otimes\\) operator.\n\n\\(\\textsc{Scan}(x,n)\\)\n\nlet \\(y[1:n]\\) be a new array\n\n\\(y[1]=x[1]\\)\n\nfor \\(i=2\\)to\\(n\\)\n\n\\(y[i]=y[i-1]\\otimes x[i]\\)\n\nreturn\\(y\\)\n\nParallelizing Scan is not straightforward. For example, simply changing the **for** loop to a **parallel for** loop would create races, since each iteration of the loop body depends on the previous iteration. The procedures P-Scan-1 and P-Scan-1-Aux perform the \\(\\otimes\\)-scan in parallel, albeit inefficiently.\n\nP-Scan-1(\\(x,n\\))\n\nlet \\(y[1:n]\\) be a new array\n\nP-Scan-1-Aux(\\(x,y,1,n\\))\n\n**return\\(y\\)**\n\nP-Scan-1-Aux(\\(x,y,i,j\\))\n\n**parallel for \\(l=i\\)to\\(j\\)**\n\n\\(y[l]=\\textsc{P-Reduce}(x,1,l)\\)\n\nAnalyze the work, span, and parallelism of P-Scan-1.\n\nThe procedures P-Scan-2 and P-Scan-2-Aux use recursive spawning to perform a more efficient \\(\\otimes\\)-scan.\n\nP-Scan-2(\\(x,n\\))\n\nlet \\(y[1:n]\\) be a new array\n\nP-Scan-2-Aux(\\(x,y,1,n\\))\n\n**return**\\(y\\)\n\nP-Scan-2-Aux(\\(x,y,i,j\\))\n\n**if**\\(i==j\\)\n\n\\(y[i]=x[i]\\)\n\n**else**\\(k=\\lfloor(i+j)/2\\rfloor\\)\n\n**spawn** P-Scan-2-Aux(\\(x,y,i,k\\))\n\nP-Scan-2-Aux(\\(x,y,k+1,j\\))\n\n**sync**\n\n**parallel for**\\(l=k+1\\) **to**\\(j\\)\n\n\\(y[l]=y[k]\\otimes y[l]\\)\n\nArgue that P-Scan-2 is correct, and analyze its work, span, and parallelism.\n\nTo improve on both P-Scan-1 and P-Scan-2, perform the \\(\\otimes\\)-scan in two distinct passes over the data. The first pass gathers the terms for various contiguous subarrays of \\(x\\) into a temporary array \\(t\\), and the second pass uses the terms in \\(t\\) to compute the final result \\(y\\). The pseudocode in the procedures P-Scan-3, P-Scan-Up, and P-Scan-Down on the facing page implements this strategy, but certain expressions have been omitted.\n\n_d._ Fill in the three missing expressions in line 8 of P-Scan-Up and lines 5 and 6 of P-Scan-Down. Argue that with the expressions you supplied, P-Scan-3 is correct. (_Hint_: Prove that the value \\(v\\) passed to P-Scan-Down(\\(v,x,t,y,i,j\\)) satisfies \\(v=x[1]\\otimes x[2]\\otimes\\cdots\\otimes x[i-1]\\).)\n\n_e._ Analyze the work, span, and parallelism of P-Scan-3.\n\n_f._ Describe how to rewrite P-Scan-3 so that it doesn't require the use of the temporary array \\(t\\).\n\n_g._ Give an algorithm P-Scan-4(\\(x,n\\)) for a scan that operates in place. It should place its output in \\(x\\) and require only constant auxiliary storage.\n\n_h._ Describe an efficient parallel algorithm that uses a \\(+\\)-scan to determine whether a string of parentheses is well formed. For example, the string ( ( ) ( ) ) ( )is well formed, but the string ( ( ) ) ) ( ( ) is not. (_Hint:_ Interpret ( as a 1 and ) as a \\(-1\\), and then perform a \\(+\\)-scan.)\n\nP-Scan-3(\\(x,n\\))\n\n1 let \\(y[1:n]\\) and \\(t[1:n]\\) be new arrays\n\n2\\(y[1]=x[1]\\)\n\n3if\\(n>1\\)\n\n4 P-Scan-Up(\\(x,t,2,n\\))\n\n5 P-Scan-Down(\\(x[1],x,t,y,2,n\\))\n\n6return\\(y\\)\n\nP-Scan-Up(\\(x,t,i,j\\))\n\n1if\\(i==j\\)\n\n2return\\(x[i]\\)\n\n3else\n\n4\\(k=\\lfloor(i+j)/2\\rfloor\\)\n\n5\\(t[k]=\\) spawn P-Scan-Up(\\(x,t,i,k\\))\n\n6\\(right=\\) P-Scan-Up(\\(x,t,k+1,j\\))\n\n7sync\n\n8return// fill in the blank\n\nP-Scan-Down(\\(v,x,t,y,i,j\\))\n\n1if\\(i==j\\)\n\n2\\(y[i]=v\\otimes x[i]\\)\n\n3else\n\n4\\(k=\\lfloor(i+j)/2\\rfloor\\)\n\n5spawnP-Scan-Down(\\(\\underline{\\phantom{x,t,y,i,k}}\\), // fill in the blank\n\n6P-Scan-Down(\\(\\underline{\\phantom{x,t,y,k+1,j}}\\), \\(x,t,y,k+1,j\\)), // fill in the blank\n\n7sync\n\n#### Parallelizing a simple stencil calculation\n\nComputational science is replete with algorithms that require the entries of an array to be filled in with values that depend on the values of certain already computed neighboring entries, along with other information that does not change over the course of the computation. The pattern of neighboring entries does not change during the computation and is called a _stencil_. For example, Section 14.4 presents a stencil algorithm to compute a longest common subsequence, where the value in entry \\(c[i,j]\\) depends only on the values in \\(c[i-1,j]\\), \\(c[i,j-1]\\), and \\(c[i-1,j-1]\\)as well as the elements \\(x_{i}\\) and \\(y_{j}\\) within the two sequences given as inputs. The input sequences are fixed, but the algorithm fills in the two-dimensional array \\(c\\) so that it computes entry \\(c[i,j]\\) after computing all three entries \\(c[i-1,j],c[i,j-1]\\), and \\(c[i-1,j-1]\\).\n\nThis problem examines how to use recursive spawning to parallelize a simple stencil calculation on an \\(n\\times n\\) array \\(A\\) in which the value placed into entry \\(A[i,j]\\) depends only on values in \\(A[i^{\\prime},j^{\\prime}]\\), where \\(i^{\\prime}\\leq i\\) and \\(j^{\\prime}\\leq j\\) (and of course, \\(i^{\\prime}\\neq i\\) or \\(j^{\\prime}\\neq j\\)). In other words, the value in an entry depends only on values in entries that are above it and/or to its left, along with static information outside of the array. Furthermore, we assume throughout this problem that once the entries upon which \\(A[i,j]\\) depends have been filled in, the entry \\(A[i,j]\\) can be computed in \\(\\Theta(1)\\) time (as in the LCS-Length procedure of Section 14.4).\n\nPartition the \\(n\\times n\\) array \\(A\\) into four \\(n/2\\times n/2\\) subarrays as follows:\n\n\\[A=\\left(\\begin{array}{cc}A_{11}&A_{12}\\\\ A_{21}&A_{22}\\end{array}\\right)\\,. \\tag{26.9}\\]\n\nYou can immediately fill in subarray \\(A_{11}\\) recursively, since it does not depend on the entries in the other three subarrays. Once the computation of \\(A_{11}\\) finishes, you can fill in \\(A_{12}\\) and \\(A_{21}\\) recursively in parallel, because although they both depend on \\(A_{11}\\), they do not depend on each other. Finally, you can fill in \\(A_{22}\\) recursively.\n\n* Give parallel pseudocode that performs this simple stencil calculation using a divide-and-conquer algorithm Simple-Stencil based on the decomposition (26.9) and the discussion above. (Don't worry about the details of the base case, which depends on the specific stencil.) Give and solve recurrences for the work and span of this algorithm in terms of \\(n\\). What is the parallelism?\n* Modify your solution to part (a) to divide an \\(n\\times n\\) array into nine \\(n/3\\times n/3\\) subarrays, again recursing with as much parallelism as possible. Analyze this algorithm. How much more or less parallelism does this algorithm have compared with the algorithm from part (a)?\n* Generalize your solutions to parts (a) and (b) as follows. Choose an integer \\(b\\geq 2\\). Divide an \\(n\\times n\\) array into \\(b^{2}\\) subarrays, each of size \\(n/b\\times n/b\\), recursing with as much parallelism as possible. In terms of \\(n\\) and \\(b\\), what are the work, span, and parallelism of your algorithm? Argue that, using this approach, the parallelism must be \\(o(n)\\) for any choice of \\(b\\geq 2\\). (_Hint:_ For this argument, show that the exponent of \\(n\\) in the parallelism is strictly less than 1 for any choice of \\(b\\geq 2\\).)\n* Give pseudocode for a parallel algorithm for this simple stencil calculation that achieves \\(\\Theta(n/\\lg n)\\) parallelism. Argue using notions of work and span that the problem has \\(\\Theta(n)\\) inherent parallelism. Unfortunately, simple fork-join parallelism does not let you achieve this maximal parallelism.\n\n#### 26.6 Randomized parallel algorithms\n\nLike serial algorithms, parallel algorithms can employ random-number generators. This problem explores how to adapt the measures of work, span, and parallelism to handle the expected behavior of randomized task-parallel algorithms. It also asks you to design and analyze a parallel algorithm for randomized quicksort.\n\n* Explain how to modify the work law (26.2), span law (26.3), and greedy scheduler bound (26.4) to work with expectations when \\(T_{P}\\), \\(T_{1}\\), and \\(T_{\\infty}\\) are all random variables.\n* Consider a randomized parallel algorithm for which 1% of the time, \\(T_{1}=10^{4}\\) and \\(T_{10,000}=1\\), but for the remaining 99% of the time, \\(T_{1}=T_{10,000}=10^{9}\\). Argue that the _speedup_ of a randomized parallel algorithm should be defined as \\(\\mathrm{E}\\left[T_{1}\\right]/\\mathrm{E}\\left[T_{P}\\right]\\), rather than \\(\\mathrm{E}\\left[T_{1}/T_{P}\\right]\\).\n* Argue that the _parallelism_ of a randomized task-parallel algorithm should be defined as the ratio \\(\\mathrm{E}\\left[T_{1}\\right]/\\mathrm{E}\\left[T_{\\infty}\\right]\\).\n* Parallelize the Randomized-Quicksort algorithm on page 192 by using recursive spawning to produce P-Randomized-Quicksort. (Do not parallelize Randomized-Partition.)\n* Analyze your parallel algorithm for randomized quicksort. (_Hint:_ Review the analysis of Randomized-Select on page 230.)\n* Parallelize Randomized-Select on page 230. Make your implementation as parallel as possible. Analyze your algorithm. (_Hint:_ Use the partitioning algorithm from Exercise 26.3-3.)\n\n#### Chapter notes\n\nParallel computers and algorithmic models for parallel programming have been around in various forms for years. Prior editions of this book included material on sorting networks and the PRAM (Parallel Random-Access Machine) model. The data-parallel model [58, 217] is another popular algorithmic programming model, which features operations on vectors and matrices as primitives. The notion of sequential consistency is due to Lamport [275].\n\nGraham [197] and Brent [71] showed that there exist schedulers achieving the bound of Theorem 26.1. Eager, Zahorjan, and Lazowska [129] showed that",
        "chapter": "Part VII Selected Topics",
        "section": "26 Parallel Algorithms",
        "subsection": "Problems",
        "subsubsection": "N/A"
    },
    {
        "content": "the problem has \\(\\Theta(n)\\) inherent parallelism. Unfortunately, simple fork-join parallelism does not let you achieve this maximal parallelism.\n\n#### 26.6 Randomized parallel algorithms\n\nLike serial algorithms, parallel algorithms can employ random-number generators. This problem explores how to adapt the measures of work, span, and parallelism to handle the expected behavior of randomized task-parallel algorithms. It also asks you to design and analyze a parallel algorithm for randomized quicksort.\n\n* Explain how to modify the work law (26.2), span law (26.3), and greedy scheduler bound (26.4) to work with expectations when \\(T_{P}\\), \\(T_{1}\\), and \\(T_{\\infty}\\) are all random variables.\n* Consider a randomized parallel algorithm for which 1% of the time, \\(T_{1}=10^{4}\\) and \\(T_{10,000}=1\\), but for the remaining 99% of the time, \\(T_{1}=T_{10,000}=10^{9}\\). Argue that the _speedup_ of a randomized parallel algorithm should be defined as \\(\\mathrm{E}\\left[T_{1}\\right]/\\mathrm{E}\\left[T_{P}\\right]\\), rather than \\(\\mathrm{E}\\left[T_{1}/T_{P}\\right]\\).\n* Argue that the _parallelism_ of a randomized task-parallel algorithm should be defined as the ratio \\(\\mathrm{E}\\left[T_{1}\\right]/\\mathrm{E}\\left[T_{\\infty}\\right]\\).\n* Parallelize the Randomized-Quicksort algorithm on page 192 by using recursive spawning to produce P-Randomized-Quicksort. (Do not parallelize Randomized-Partition.)\n* Analyze your parallel algorithm for randomized quicksort. (_Hint:_ Review the analysis of Randomized-Select on page 230.)\n* Parallelize Randomized-Select on page 230. Make your implementation as parallel as possible. Analyze your algorithm. (_Hint:_ Use the partitioning algorithm from Exercise 26.3-3.)\n\n#### Chapter notes\n\nParallel computers and algorithmic models for parallel programming have been around in various forms for years. Prior editions of this book included material on sorting networks and the PRAM (Parallel Random-Access Machine) model. The data-parallel model [58, 217] is another popular algorithmic programming model, which features operations on vectors and matrices as primitives. The notion of sequential consistency is due to Lamport [275].\n\nGraham [197] and Brent [71] showed that there exist schedulers achieving the bound of Theorem 26.1. Eager, Zahorjan, and Lazowska [129] showed that any greedy scheduler achieves this bound and proposed the methodology of using work and span (although not by those names) to analyze parallel algorithms. Blelloch [57] developed an algorithmic programming model based on work and span (which he called \"depth\") for data-parallel programming. Blumofe and Leiserson [63] gave a distributed scheduling algorithm for task-parallel computations based on randomized \"work-stealing\" and showed that it achieves the bound \\(\\mathrm{E}\\left[T_{P}\\right]\\leq T_{1}/P+O(T_{\\infty})\\). Arora, Blumofe, and Plaxton [20] and Blelloch, Gibbons, and Matias [61] also provided provably good algorithms for scheduling task-parallel computations. The recent literature contains many algorithms and strategies for scheduling parallel programs.\n\nThe parallel pseudocode and programming model were influenced by Cilk [290, 291, 383, 396]. The open-source project OpenCilk (www.opencilk.org) provides Cilk programming as an extension to the C and C++ programming languages. All of the parallel algorithms in this chapter can be coded straightforwardly in Cilk.\n\nConcerns about nondeterministic parallel programs were expressed by Lee [281] and Bocchino, Adve, Adve, and Snir [64]. The algorithms literature contains many algorithmic strategies (see, for example, [60, 85, 118, 140, 160, 282, 283, 412, 461]) for detecting races and extending the fork-join model to avoid or safely embrace various kinds of nondeterminism. Blelloch, Fineman, Gibbons, and Shun [59] showed that deterministic parallel algorithms can often be as fast as, or even faster than, their nondeterministic counterparts.\n\nSeveral of the parallel algorithms in this chapter appeared in unpublished lecture notes by C. E. Leiserson and H. Prokop and were originally implemented in Cilk. The parallel merge-sorting algorithm was inspired by an algorithm due to Akl [12].\n\n## Chapter Online Algorithms\n\nMost problems described in this book have assumed that the entire input was available before the algorithm executes. In many situations, however, the input becomes available not in advance, but only as the algorithm executes. This idea was implicit in much of the discussion of data structures in Part III. The reason that you want to design, for example, a data structure that can handle \\(n\\) Insert, Delete, and Search operations in \\(O(\\lg n)\\) time per operation is most likely because you are going to receive \\(n\\) such operation requests without knowing in advance what operations will be coming. This idea was also implicit in amortized analysis in Chapter 16, where we saw how to maintain a table that can grow or shrink in response to a sequence of insertion and deletion operations, yet with a constant amortized cost per operation.\n\nAn _online algorithm_ receives its input progressively over time, rather than having the entire input available at the start, as in an _offline algorithm_. Online algorithms pertain to many situations in which information arrives gradually. A stock trader must make decisions today, without knowing what the prices will be tomorrow, yet wants to achieve good returns. A computer system must schedule arriving jobs without knowing what work will need to be done in the future. A store must decide when to order more inventory without knowing what the future demand will be. A driver for a ride-hailing service must decide whether to pick up a fare without knowing who will request rides in the future. In each of these situations, and many more, algorithmic decisions must be made without knowledge of the future.\n\nThere are several approaches for dealing with unknown future inputs. One approach is to form a probabilistic model of future inputs and design an algorithm that assumes future inputs conform to the model. This technique is common, for example, in the field of queuing theory, and it is also related to machine learning. Of course, you might not be able to develop a workable probabilistic model, or even if you can, some inputs might not conform to it. This chapter takes a differ",
        "chapter": "Part VII Selected Topics",
        "section": "26 Parallel Algorithms",
        "subsection": "Chapter notes",
        "subsubsection": "N/A"
    },
    {
        "content": "ent approach. Instead of assuming anything about the future input, we employ a conservative strategy of limiting how poor a solution any input can entail.\n\nThis chapter, therefore, adopts a worst-case approach, designing online algorithms that guarantee the quality of the solution for all possible future inputs. We'll analyze online algorithms by comparing the solution produced by the online algorithm with a solution produced by an optimal algorithm that knows the future inputs, and taking a worst-case ratio over all possible instances. We call this methodology _competitive analysis_. We'll use a similar approach when we study approximation algorithms in Chapter 35, where we'll compare the solution returned by an algorithm that might be suboptimal with the value of the optimal solution, and determine a worst-case ratio over all possible instances.\n\nWe start with a \"toy\" problem: deciding between whether to take the elevator or the stairs. This problem will introduce the basic methodology of thinking about online algorithms and how to analyze them via competitive analysis. We will then look at two problems that use competitive analysis. The first is how to maintain a search list so that the access time is not too large, and the second is about strategies for deciding which cache blocks to evict from a cache or other kind of fast computer memory.\n\n### 27.1 Waiting for an elevator\n\nOur first example of an online algorithm models a problem that you likely have encountered yourself: whether you should wait for an elevator to arrive or just take the stairs. Suppose that you enter a building and wish to visit an office that is \\(k\\) floors up. You have two choices: walk up the stairs or take the elevator. Let's assume, for convenience, that you can climb the stairs at the rate of one floor per minute. The elevator travels much faster than you can climb the stairs: it can ascend all \\(k\\) floors in just one minute. Your dilemma is that you do not know how long it will take for the elevator to arrive at the ground floor and pick you up. Should you take the elevator or the stairs? How do you decide?\n\nLet's analyze the problem. Taking the stairs takes \\(k\\) minutes, no matter what. Suppose you know that the elevator takes at most \\(B-1\\) minutes to arrive for some value of \\(B\\) that is considerably higher than \\(k\\). (The elevator could be going up when you call for it and then stop at several floors on its way down.) To keep things simple, let's also assume that the number of minutes for the elevator to arrive is an integer. Therefore, waiting for the elevator and taking it \\(k\\) floors up takes anywhere from one minute (if the elevator is already at the ground floor) to \\((B-1)+1=B\\) minutes (the worst case). Although you know \\(B\\) and \\(k\\),you don't know how long the elevator will take to arrive this time. You can use competitive analysis to inform your decision regarding whether to take the stairs or elevator. In the spirit of competitive analysis, you want to be sure that, no matter what the future brings (i.e., how long the elevator takes to arrive), you will not wait much longer than a seer who knows when the elevator will arrive.\n\nLet us first consider what the seer would do. If the seer knows that the elevator is going to arrive in at most \\(k-1\\) minutes, the seer waits for the elevator, and otherwise, the seer takes the stairs. Letting \\(m\\) denote the number of minutes it takes for the elevator to arrive at the ground floor, we can express the time that the seer spends as the function\n\n\\[t\\left(m\\right)=\\left\\{\\begin{array}{ll}m\\,+\\,1&\\mbox{if $m\\leq k-1$,}\\\\ k&\\mbox{if $m\\geq k$.}\\end{array}\\right. \\tag{27.1}\\]\n\nWe typically evaluate online algorithms by their _competitive ratio_. Let \\(\\mathcal{U}\\) denote the set (universe) of all possible inputs, and consider some input \\(I\\in\\mathcal{U}\\). For a minimization problem, such as the stairs-versus-elevator problem, if an online algorithm \\(A\\) produces a solution with value \\(A(I)\\) on input \\(I\\) and the solution from an algorithm \\(F\\) that knows the future has value \\(F(I)\\) on the same input, then the competitive ratio of algorithm \\(A\\) is\n\n\\[\\max\\left\\{A(I)/F(I):I\\in\\mathcal{U}\\right\\}\\.\\]\n\nIf an online algorithm has a competitive ratio of \\(c\\), we say that it is _c-competitive_. The competitive ratio is always at least \\(1\\), so that we want an online algorithm with a competitive ratio as close to \\(1\\) as possible.\n\nIn the stairs-versus-elevator problem, the only input is the time for the elevator to arrive. Algorithm \\(F\\) knows this information, but an online algorithm has to make a decision without knowing when the elevator will arrive. Consider the algorithm \"always take the stairs,\" which always takes exactly \\(k\\) minutes. Using equation (27.1), the competitive ratio is\n\n\\[\\max\\left\\{k/t(m):0\\leq m\\leq B-1\\right\\}. \\tag{27.2}\\]\n\nEnumerating the terms in equation (27.2) gives the competitive ratio as\n\n\\[\\max\\left\\{\\frac{k}{1},\\frac{k}{2},\\frac{k}{3},\\ldots,\\frac{k}{(k-1)},\\frac{k }{k},\\frac{k}{k},\\ldots,\\frac{k}{k}\\right\\}=k\\,\\]\n\nso that the competitive ratio is \\(k\\). The maximum is achieved when the elevator arrives immediately. In this case, taking the stairs requires \\(k\\) minutes, but the optimal solution takes just \\(1\\) minute.\n\nNow let's consider the opposite approach: \"always take the elevator.\" If it takes \\(m\\) minutes for the elevator to arrive at the ground floor, then this algorithm will always take \\(m\\,+\\,1\\) minutes. Thus the competitive ratio becomes\n\n\\[\\max\\left\\{(m\\,+\\,1)/t(m):0\\leq m\\leq B-1\\right\\}\\,\\]which we can again enumerate as\n\n\\[\\max\\left\\{\\frac{1}{1},\\frac{2}{2},\\ldots,\\frac{k}{k},\\frac{k+1}{k},\\frac{k+2}{k},\\ldots,\\frac{B}{k}\\right\\}=\\frac{B}{k}\\.\\]\n\nNow the maximum is achieved when the elevator takes \\(B-1\\) minutes to arrive, compared with the optimal approach of taking the stairs, which requires \\(k\\) minutes.\n\nHence, the algorithm \"always take the stairs\" has competitive ratio \\(k\\), and the algorithm \"always take the elevator\" has competitive ratio \\(B/k\\). Because we prefer the algorithm with smaller competitive ratio, if \\(k=10\\) and \\(B=300\\), we prefer \"always take the stairs,\" with competitive ratio 10, over \"always take the elevator,\" with competitive ratio 30. Taking the stairs is not always better, or necessarily more often better. It's just that taking the stairs guards better against the worst-case future.\n\nThese two approaches of always taking the stairs and always taking the elevator are extreme solutions, however. Instead, you can \"hedge your bets\" and guard even better against a worst-case future. In particular, you can wait for the elevator for a while, and then if it doesn't arrive, take the stairs. How long is \"a while\"? Let's say that \"a while\" is \\(k\\) minutes. Then the time \\(h(m)\\) required by this hedging strategy, as a function of the number \\(m\\) of minutes before the elevator arrives, is\n\n\\[h(m)=\\left\\{\\begin{array}{ll}m+1&\\mbox{if }m\\leq k\\,\\\\ 2k&\\mbox{if }m>k\\.\\end{array}\\right.\\]\n\nIn the second case, \\(h(m)=2k\\) because you wait for \\(k\\) minutes and then climb the stairs for \\(k\\) minutes. The competitive ratio is now\n\n\\[\\max\\left\\{h(m)/t(m):0\\leq m\\leq B-1\\right\\}\\.\\]\n\nEnumerating this ratio yields\n\n\\[\\max\\left\\{\\frac{1}{1},\\frac{2}{2},\\ldots,\\frac{k}{k},\\frac{k+1}{k},\\frac{2k} {k},\\frac{2k}{k},\\frac{2k}{k},\\ldots,\\frac{2k}{k}\\right\\}=2\\.\\]\n\nThe competitive ratio is now _independent_ of \\(k\\) and \\(B\\).\n\nThis example illustrates a common philosophy in online algorithms: we want an algorithm that guards against any possible worst case. Initially, waiting for the elevator guards against the case when the elevator arrives quickly, but eventually switching to the stairs guards against the case when the elevator takes a long time to arrive.\n\n### Exercises\n\n#### 27.1-1\n\nSuppose that when hedging your bets, you wait for \\(p\\) minutes, instead of for \\(k\\) minutes, before taking the stairs. What is the competitive ratio as a function of \\(p\\) and \\(k\\)? How should you choose \\(p\\) to minimize the competitive ratio?\n\n#### 27.1-2\n\nImagine that you decide to take up downhill skiing. Suppose that a pair of skis costs \\(r\\) dollars to rent for a day and \\(b\\) dollars to buy, where \\(b>r\\). If you knew in advance how many days you would ever ski, your decision whether to rent or buy would be easy. If you'll ski for at least \\(\\lceil b/r\\rceil\\) days, then you should buy skis, and otherwise you should rent. This strategy minimizes the total that you ever spend. In reality, you don't know in advance how many days you'll eventually ski. Even after you have skied several times, you still don't know how many more times you'll ever ski. Yet you don't want to waste your money. Give and analyze an algorithm that has a competitive ratio of 2, that is, an algorithm guaranteeing that, no matter how many times you ski, you never spend more than twice what you would have spent if you knew from the outset how many times you'll ski.\n\n#### 27.1-3\n\nIn \"concentration solitaire,\" a game for one person, you have \\(n\\) pairs of matching cards. The backs of the cards are all the same, but the fronts contain pictures of animals. One pair has pictures of aardvarks, one pair has pictures of bears, one pair has pictures of camels, and so on. At the start of the game, the cards are all placed face down. In each round, you can turn two cards face up to reveal their pictures. If the pictures match, then you remove that pair from the game. If they don't match, then you turn both of them over, hiding their pictures once again. The game ends when you have removed all \\(n\\) pairs, and your score is how many rounds you needed to do so. Suppose that you can remember the picture on every card that you have seen. Give an algorithm to play concentration solitaire that has a competitive ratio of 2.\n\n### Maintaining a search list\n\nThe next example of an online algorithm pertains to maintaining the order of elements in a linked list, as in Section 10.2. This problem often arises in practice for hash tables when collisions are resolved by chaining (see Section 11.2), since each slot contains a linked list. Reordering the linked list of elements in each slot of the hash table can boost the performance of searches measurably.",
        "chapter": "Part VII Selected Topics",
        "section": "27 Online Algorithms",
        "subsection": "27.1 Waiting for an elevator",
        "subsubsection": "N/A"
    },
    {
        "content": "### Exercises\n\n#### 27.1-1\n\nSuppose that when hedging your bets, you wait for \\(p\\) minutes, instead of for \\(k\\) minutes, before taking the stairs. What is the competitive ratio as a function of \\(p\\) and \\(k\\)? How should you choose \\(p\\) to minimize the competitive ratio?\n\n#### 27.1-2\n\nImagine that you decide to take up downhill skiing. Suppose that a pair of skis costs \\(r\\) dollars to rent for a day and \\(b\\) dollars to buy, where \\(b>r\\). If you knew in advance how many days you would ever ski, your decision whether to rent or buy would be easy. If you'll ski for at least \\(\\lceil b/r\\rceil\\) days, then you should buy skis, and otherwise you should rent. This strategy minimizes the total that you ever spend. In reality, you don't know in advance how many days you'll eventually ski. Even after you have skied several times, you still don't know how many more times you'll ever ski. Yet you don't want to waste your money. Give and analyze an algorithm that has a competitive ratio of 2, that is, an algorithm guaranteeing that, no matter how many times you ski, you never spend more than twice what you would have spent if you knew from the outset how many times you'll ski.\n\n#### 27.1-3\n\nIn \"concentration solitaire,\" a game for one person, you have \\(n\\) pairs of matching cards. The backs of the cards are all the same, but the fronts contain pictures of animals. One pair has pictures of aardvarks, one pair has pictures of bears, one pair has pictures of camels, and so on. At the start of the game, the cards are all placed face down. In each round, you can turn two cards face up to reveal their pictures. If the pictures match, then you remove that pair from the game. If they don't match, then you turn both of them over, hiding their pictures once again. The game ends when you have removed all \\(n\\) pairs, and your score is how many rounds you needed to do so. Suppose that you can remember the picture on every card that you have seen. Give an algorithm to play concentration solitaire that has a competitive ratio of 2.\n\n### Maintaining a search list\n\nThe next example of an online algorithm pertains to maintaining the order of elements in a linked list, as in Section 10.2. This problem often arises in practice for hash tables when collisions are resolved by chaining (see Section 11.2), since each slot contains a linked list. Reordering the linked list of elements in each slot of the hash table can boost the performance of searches measurably.\n\nThe list-maintenance problem can be set up as follows. You are given a list \\(L\\) of \\(n\\) elements \\(\\{x_{1},x_{2},\\ldots,x_{n}\\}\\). We'll assume that the list is doubly linked, although the algorithms and analysis work just as well for singly linked lists. Denote the position of element \\(x_{i}\\) in the list \\(L\\) by \\(r_{L}(x_{i})\\), where \\(1\\leq r_{L}(x_{i})\\leq n\\). Calling List-Search\\((L,x_{i})\\) on page 260 thus takes \\(\\Theta(r_{L}(x_{i}))\\) time.\n\nIf you know in advance something about the distribution of search requests, then it makes sense to arrange the list ahead of time to put the more frequently searched elements closer to the front, which minimizes the total cost (see Exercise 27.2-1). If instead you don't know anything about the search sequence, then no matter how you arrange the list, it is possible that every search is for whatever element appears at the tail of the list. The total searching time would then be \\(\\Theta(n\\,m)\\), where \\(m\\) is the number of searches.\n\nIf you notice patterns in the access sequence or you observe differences in the frequencies in which elements are accessed, then you might want to rearrange the list as you perform searches. For example, if you discover that every search is for a particular element, you could move that element to the front of the list. In general, you could rearrange the list after each call to List-Search. But how would you do so without knowing the future? After all, no matter how you move elements around, every search could be for the last element.\n\nBut it turns out that some search sequences are \"easier\" than others. Rather than just evaluate performance on the worst-case sequence, let's compare a reorganization scheme with whatever an optimal offline algorithm would do if it knew the search sequence in advance. That way, if the sequence is fundamentally hard, the optimal offline algorithm will also find it hard, but if the sequence is easy, we can hope to do reasonably well.\n\nTo ease analysis, we'll drop the asymptotic notation and say that the cost is just \\(i\\) to search for the \\(i\\)th element in the list. Let's also assume that the only way to reorder the elements in the list is by swapping two adjacent elements in the list. Because the list is doubly linked, each swap incurs a cost of \\(1\\). Thus, for example, a search for the sixth element followed by moving it forward two places (entailing two swaps) incurs a total cost \\(8\\). The goal is to minimize the total cost of calls to List-Search plus the total number of swaps performed.\n\nThe online algorithm that we'll explore is Move-To-Front\\((L,x)\\). This procedure first searches for \\(x\\) in the doubly linked list \\(L\\), and then it moves \\(x\\) to the front of the list.1 If \\(x\\) is located at position \\(r=r_{L}(x)\\) before the call, Move-To-Front swaps \\(x\\) with the element in position \\(r-1\\), then with the element in position \\(r-2\\)and so on, until it finally swaps \\(x\\) with the element in position 1. Thus if the call Move-To-Front\\((L,8)\\) executes on the list \\(L=\\langle 5,\\,3,\\,12,\\,4,\\,8,\\,9,\\,22\\rangle\\), the list becomes \\(\\langle 8,5,3,\\,12,\\,4,\\,9,\\,22\\rangle\\). The call Move-To-Front\\((L,k)\\) costs \\(2r_{L}(k)-1\\): it costs \\(r_{L}(k)\\) to search for \\(k\\), and it costs 1 for each of the \\(r_{L}(k)-1\\) swaps that move \\(k\\) to the front of the list.\n\nWe'll see that Move-To-Front has a competitive ratio of 4. Let's think about what this means. Move-To-Front performs a series of operations on a doubly linked list, accumulating cost. For comparison, suppose that there is an algorithm Foresee that knows the future. Like Move-To-Front, it also searches the list and moves elements around, but after each call it optimally rearranges the list for the future. (There may be more than one optimal order.) Thus Foresee and Move-To-Front maintain different lists of the same elements.\n\nConsider the example shown in Figure 27.1. Starting with the list \\(\\langle 1,2,3,4,5\\rangle\\), four searches occur, for the elements 5, 3, 4, and 4. The hypothetical procedure Foresee, after searching for 3, moves 4 to the front of the list, knowing that a search for 4 is imminent. It thus incurs a swap cost of 3 upon its second call, after which no further swap costs accrue. Move-To-Front incurs swap costs in each step, moving the found element to the front. In this example, Move-To-Front has a higher cost in each step, but that is not necessarily always the case.\n\nThe key to proving the competitive bound is to show that at any point, the total cost of Move-To-Front is not much higher than that of Foresee. Surprisingly, we can determine a bound on the costs incurred by Move-To-Front relative to Foresee even though Move-To-Front cannot see the future.\n\nIf we compare any particular step, Move-To-Front and Foresee may be operating on very different lists and do very different things. If we focus on the search for 4 above, we observe that Foresee actually moves it to the front of the list early, paying to move the element to the front before it is accessed. To capture this con\n\nFigure 27.1: The costs incurred by the procedures Foresee and Move-To-Front when searching for the elements 5, 3, 4, and 4, starting with the list \\(L=\\langle 1,\\,2,\\,3,\\,4,\\,5\\rangle\\). If Foresee instead moved 3 to the front after the search for 5, the cumulative cost would not change, nor would the cumulative cost change if 4 moved to the second position after the search for 5.\n\ncept, we use the idea of an _inversion_: a pair of elements, say \\(a\\) and \\(b\\), in which \\(a\\) appears before \\(b\\) in one list, but \\(b\\) appears before \\(a\\) in another list. For two lists \\(L\\) and \\(L^{\\prime}\\), let \\(I(L,L^{\\prime})\\), called the _inversion count_, denote the number of inversions between the two lists, that is, the number of pairs of elements whose order differs in the two lists. For example, with lists \\(L=\\langle 5,3,1,4,2\\rangle\\) and \\(L^{\\prime}=\\langle 3,1,2,4,5\\rangle\\), then out of the \\(\\binom{5}{2}=10\\) pairs, exactly five of them--\\((1,5),(2,4),(2,5),(3,5)\\), (4,5) --are inversions, since these pairs, and only these pairs, appear in different orders in the two lists. Thus the inversion count is \\(I(L,L^{\\prime})=5\\).\n\nIn order to analyze the algorithm, we define the following notation. Let \\(L^{M}_{i}\\) be the list maintained by Move-To-Front immediately after the \\(i\\)th search, and similarly, let \\(L^{F}_{i}\\) be Foresee's list immediately after the \\(i\\)th search. Let \\(c^{M}_{i}\\) and \\(c^{F}_{i}\\) be the costs incurred by Move-To-Front and Foresee on their \\(i\\)th calls, respectively. We don't know how many swaps Foresee performs in its \\(i\\)th call, but we'll denote that number by \\(t_{i}\\). Therefore, if the \\(i\\)th operation is a search for element \\(x\\), then\n\n\\[c^{M}_{i} = 2r_{L^{M}_{i-1}}(x)-1\\, \\tag{27.3}\\] \\[c^{F}_{i} = r_{L^{F}_{i-1}}(x)+t_{i}. \\tag{27.4}\\]\n\nIn order to compare these costs more carefully, let's break down the elements into subsets, depending on their positions in the two lists before the \\(i\\)th search, relative to the element \\(x\\) being searched for in the \\(i\\)th search. We define three sets:\n\n\\[BB = \\{\\mbox{elements before $x$ in both $L^{M}_{i-1}$ and $L^{F}_{i-1}$}\\}\\,\\] \\[BA = \\{\\mbox{elements before $x$ in $L^{M}_{i-1}$ but after $x$ in $L^{F}_{i-1}$}\\}\\,\\] \\[AB = \\{\\mbox{elements after $x$ in $L^{M}_{i-1}$ but before $x$ in $L^{F}_{i-1}$}\\}\\.\\]\n\nWe can now relate the position of element \\(x\\) in \\(L^{F}_{i-1}\\) and \\(L^{M}_{i-1}\\) to the sizes of these sets:\n\n\\[r_{L^{M}_{i-1}}(x) = |BB|+|BA|+1\\, \\tag{27.5}\\] \\[r_{L^{F}_{i-1}}(x) = |BB|+|AB|+1. \\tag{27.6}\\]\n\nWhen a swap occurs in one of the lists, it changes the relative positions of the two elements involved, which in turn changes the inversion count. Suppose that elements \\(x\\) and \\(y\\) are swapped in some list. Then the only possible difference in the inversion count between this list and _any_ other list depends on whether \\((x,y)\\) is an inversion. In fact, the inversion count of \\((x,y)\\) with respect to any other list _must_ change. If \\((x,y)\\) is an inversion before the swap, it no longer is afterward, and vice versa. Therefore, if two consecutive elements \\(x\\) and \\(y\\) swap positions in a list \\(L\\), then for any other list \\(L^{\\prime}\\), the value of the inversion count \\(I(L,L^{\\prime})\\) either increases by 1 or decreases by 1.\n\n### Maintaining a search list\n\nAs we compare Move-To-Front and Foresee searching and modifying their lists, we'll think about Move-To-Front executing on its list for the \\(i\\)th time and then Foresee executing on its list for the \\(i\\)th time. After Move-To-Front has executed for the \\(i\\)th time and before Foresee has executed for the \\(i\\)th time, we'll compare \\(I(L_{i-1}^{M},L_{i-1}^{F})\\) (the inversion count immediately before the \\(i\\)th call of Move-To-Front) with \\(I(L_{i}^{M},L_{i-1}^{F})\\) (the inversion count after the \\(i\\)th call of Move-To-Front but before the \\(i\\)th call of Foresee). We'll concern ourselves later with what Foresee does.\n\nLet us analyze what happens to the inversion count after executing the \\(i\\)th call of Move-To-Front, and suppose that it searches for element \\(x\\). More precisely, we'll compute \\(I(L_{i}^{M},L_{i-1}^{F})-I(L_{i-1}^{M},L_{i-1}^{F})\\), the change in the inversion count, which gives a rough idea of how much Move-To-Front's list becomes more or less like Foresee's list. After searching, Move-To-Front performs a series of swaps with each of the elements on the list \\(L_{i-1}^{M}\\) that precedes \\(x\\). Using the notation above, the number of such swaps is \\(|BB|+|BA|\\). Bearing in mind that the list \\(L_{i-1}^{F}\\) has yet to be changed by the \\(i\\)th call of Foresee, let's see how the inversion count changes.\n\nConsider a swap with an element \\(y\\in BB\\). Before the swap, \\(y\\) precedes \\(x\\) in both \\(L_{i-1}^{M}\\) and \\(L_{i-1}^{F}\\). After the swap, \\(x\\) precedes \\(y\\) in \\(L_{i}^{M}\\), and \\(L_{i-1}^{F}\\) does not change. Therefore, the inversion count increases by \\(1\\) for each element in \\(BB\\). Now consider a swap with an element \\(z\\in BA\\). Before the swap, \\(z\\) precedes \\(x\\) in \\(L_{i-1}^{M}\\) but \\(x\\) precedes \\(z\\) in \\(L_{i-1}^{F}\\). After the swap, \\(x\\) precedes \\(z\\) in both lists. Therefore, the inversion count decreases by \\(1\\) for each element in \\(BA\\). Thus altogether, the inversion count increases by\n\n\\[I(L_{i}^{M},L_{i-1}^{F})-I(L_{i-1}^{M},L_{i-1}^{F})=|BB|-|BA|\\enspace. \\tag{27.7}\\]\n\nWe have laid the groundwork needed to analyze Move-To-Front.\n\n**Theorem 27.1**: Algorithm Move-To-Front has a competitive ratio of \\(4\\).\n\n_Proof_ The proof uses a potential function, as described in Chapter 16 on amortized analysis. The value \\(\\Phi_{i}\\) of the potential function after the \\(i\\)th calls of Move-To-Front and Foresee depends on the inversion count:\n\n\\[\\Phi_{i}=2I(L_{i}^{M},L_{i}^{F})\\enspace.\\]\n\n(Intuitively, the factor of \\(2\\) embodies the notion that each inversion represents a cost of \\(2\\) for Move-To-Front relative to Foresee: \\(1\\) for searching and \\(1\\) for swapping.) By equation (27.7), after the \\(i\\)th call of Move-To-Front, but before the \\(i\\)th call of Foresee, the potential increases by \\(2(|BB|-|BA|)\\). Since the inversion count of the two lists is nonnegative, we have \\(\\Phi_{i}\\geq 0\\) for all \\(i\\geq 0\\)Assuming that Move-To-Front and Foresee start with the same list, the initial potential \\(\\Phi_{0}\\) is 0, so that \\(\\Phi_{i}\\geq\\Phi_{0}\\) for all \\(i\\).\n\nDrawing from equation (16.2) on page 456, the amortized cost \\(\\widehat{c}_{i}^{M}\\) of the \\(i\\)th Move-To-Front operation is\n\n\\[\\widehat{c}_{i}^{M}=c_{i}^{M}+\\Phi_{i}-\\Phi_{i-1}\\,\\]\n\nwhere \\(c_{i}^{M}\\), the actual cost of the \\(i\\)th Move-To-Front operation, is given by equation (27.3):\n\n\\[c_{i}^{M}=2r_{L_{i-1}^{M}}(x)-1\\.\\]\n\nNow, let's consider the potential change \\(\\Phi_{i}-\\Phi_{i-1}\\). Since both \\(L^{M}\\) and \\(L^{F}\\) change, let's consider the changes to one list at a time. Recall that when Move-To-Front moves element \\(x\\) to the front, it increases the potential by exactly \\(2(|BB|-|BA|)\\). We now consider how the optimal algorithm Foresee changes its list \\(L^{F}\\): it performs \\(t_{i}\\) swaps. Each swap performed by Foresee either increases or decreases the potential by 2, and thus the increase in potential by Foresee in the \\(i\\)th call can be at most \\(2t_{i}\\). We therefore have\n\n\\[\\widehat{c}_{i}^{M} = c_{i}^{M}+\\Phi_{i}-\\Phi_{i-1}\\] (27.8) \\[\\leq 2r_{L_{i-1}^{M}}(x)-1+2(|BB|-|BA|+t_{i})\\] \\[= 2r_{L_{i-1}^{M}}(x)-1+2(|BB|-(r_{L_{i-1}^{M}}(x)-1-|BB|)+t_{i})\\] \\[\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad \\qquadTherefore, we have\n\n\\[\\sum_{i=1}^{m}c_{i}^{\\,M} \\leq \\sum_{i=1}^{m}\\hat{c}_{i}^{\\,M}\\qquad\\mbox{(by equation (\\ref{eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eqeq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eqeq:eq:eq:eq:eqeq:eq:eq:eq:eq:eq:eq:eqeq:eq:eq:eq:eq:eq:eqeq:eq:eq:eq:eq:eqeq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eqeq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eqeq:eq:eq:eq:eqeq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eqeq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eqeq:eq:eq:eq:eq:eq:eqeq:eq:eq:eq:eq:eq:eq:eqeq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eqeq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eqeq:eq:eqeq:eq:eq:eq:eq:eqeq:eq:eq:eq:eq:eqeq:eq:eq:eq:eqeq:eqeq:eq:eqeq:eq:eq:eqeq:eq:eq:eq:eqeq:eq:eq:eqeq:eq:eq:eqeq:eq:eq:eqeq:eq:eq:eqeq:eq:eqeq:eq:eqeq:eq:eq:eqeq:eqeq:eq:eq:eq:eq:eq:eqeq:eq:eq:eq:eq:eqeq:eqeq:eq:eq:eqeq:eq:eqeq:eqeq:eq:eq:eqeq:eqeq:eq:eq:eq:eqeq:eq:eq:eqeq:eq:eq:eqeq:eqeq:eq:eq:eq:eqeq:eq:eqeq:eq:eq:eqeq:eq:eq:eqeq:eqeq:eq:eqeq:eq:eq:eqeq:eq:eq:eq:eqeq:eq:eq:eq:eq:eq:eq:eq:eq:eqeq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eqeq:eq:eq:eq:eqeq:eq:eq:eq:eq:eq\n\n#### 27.2-3\n\nAnother way to maintain a linked list for efficient searching is for each element to maintain a _frequency count_: the number of times that the element has been searched for. The idea is to rearrange list elements after searches so that the list is always sorted by decreasing frequency count, from largest to smallest. Either show that this algorithm is \\(O(1)\\)-competitive, or prove that it is not.\n\n#### 27.2-4\n\nThe model in this section charged a cost of \\(1\\) for each swap. We can consider an alternative cost model in which, after accessing \\(x\\), you can move \\(x\\) anywhere earlier in the list, and there is no cost for doing so. The only cost is the cost of the actual accesses. Show that Move-To-Front is \\(2\\)-competitive in this cost model, assuming that the number requests is sufficiently large. (_Hint:_ Use the potential function \\(\\Phi_{i}=I(L_{i}^{M},L_{i}^{F})\\).)\n\n### Online caching\n\nIn Section 15.4, we studied the caching problem, in which _blocks_ of data from the main memory of a computer are stored in the _cache_: a small but faster memory. In that section, we studied the offline version of the problem, in which we assumed that we knew the sequence of memory requests in advance, and we designed an algorithm to minimize the number of cache misses. In almost all computer systems, caching is, in fact, an online problem. We do not generally know the series of cache requests in advance; they are presented to the algorithm only as the requests for blocks are actually made. To gain a better understanding of this more realistic scenario, we analyze online algorithms for caching. We will first see that all deterministic online algorithms for caching have a lower bound of \\(\\Omega(k)\\) for the competitive ratio, where \\(k\\) is the size of the cache. We will then present an algorithm with a competitive ratio of \\(\\Theta(n)\\), where the input size is \\(n\\), and one with a competitive ratio of \\(O(k)\\), which matches the lower bound. We will end by showing how to use randomization to design an algorithm with a much better competitive ratio of \\(\\Theta(\\lg k)\\). We will also discuss the assumptions that underlie randomized online algorithms, via the notion of an adversary, such as we saw in Chapter 11 and will see in Chapter 31.\n\nYou can find the terminology used to describe the caching problem in Section 15.4, which you might wish to review before proceeding.",
        "chapter": "Part VII Selected Topics",
        "section": "27 Online Algorithms",
        "subsection": "27.2 Maintaining a search list",
        "subsubsection": "N/A"
    },
    {
        "content": "#### 27.2-3\n\nAnother way to maintain a linked list for efficient searching is for each element to maintain a _frequency count_: the number of times that the element has been searched for. The idea is to rearrange list elements after searches so that the list is always sorted by decreasing frequency count, from largest to smallest. Either show that this algorithm is \\(O(1)\\)-competitive, or prove that it is not.\n\n#### 27.2-4\n\nThe model in this section charged a cost of \\(1\\) for each swap. We can consider an alternative cost model in which, after accessing \\(x\\), you can move \\(x\\) anywhere earlier in the list, and there is no cost for doing so. The only cost is the cost of the actual accesses. Show that Move-To-Front is \\(2\\)-competitive in this cost model, assuming that the number requests is sufficiently large. (_Hint:_ Use the potential function \\(\\Phi_{i}=I(L_{i}^{M},L_{i}^{F})\\).)\n\n### Online caching\n\nIn Section 15.4, we studied the caching problem, in which _blocks_ of data from the main memory of a computer are stored in the _cache_: a small but faster memory. In that section, we studied the offline version of the problem, in which we assumed that we knew the sequence of memory requests in advance, and we designed an algorithm to minimize the number of cache misses. In almost all computer systems, caching is, in fact, an online problem. We do not generally know the series of cache requests in advance; they are presented to the algorithm only as the requests for blocks are actually made. To gain a better understanding of this more realistic scenario, we analyze online algorithms for caching. We will first see that all deterministic online algorithms for caching have a lower bound of \\(\\Omega(k)\\) for the competitive ratio, where \\(k\\) is the size of the cache. We will then present an algorithm with a competitive ratio of \\(\\Theta(n)\\), where the input size is \\(n\\), and one with a competitive ratio of \\(O(k)\\), which matches the lower bound. We will end by showing how to use randomization to design an algorithm with a much better competitive ratio of \\(\\Theta(\\lg k)\\). We will also discuss the assumptions that underlie randomized online algorithms, via the notion of an adversary, such as we saw in Chapter 11 and will see in Chapter 31.\n\nYou can find the terminology used to describe the caching problem in Section 15.4, which you might wish to review before proceeding.\n\n#### 27.3.1 Deterministic caching algorithms\n\nIn the caching problem, the input comprises a sequence of \\(n\\) memory requests, for data in blocks \\(b_{1},b_{2},\\ldots,b_{n}\\), in that order. The blocks requested are not necessarily distinct: each block may appear multiple times within the request sequence. After block \\(b_{i}\\) is requested, it resides in a cache that can hold up to \\(k\\) blocks, where \\(k\\) is a fixed cache size. We assume that \\(n>k\\), since otherwise we are assured that the cache can hold all the requested blocks at once. When a block \\(b_{i}\\) is requested, if it is already in the cache, then a _cache hit_ occurs and the cache remains unchanged. If \\(b_{i}\\) is not in the cache, then a _cache miss_ occurs. If the cache contains fewer than \\(k\\) blocks upon a cache miss, block \\(b_{i}\\) is placed into the cache, which now contains one block more than before. If a cache miss occurs with an already full cache, however, some block must be evicted from the cache before \\(b_{i}\\) can enter. Thus, a caching algorithm must decide which block to evict from the cache upon a cache miss when the cache is full. The goal is to minimize the number of cache misses over the entire request sequence. The caching algorithms considered in this chapter differ only in which block they decide to evict upon a cache miss. We do not consider abilities such as prefetching, in which a block is brought into the cache before an upcoming request in order to avert a future cache miss.\n\nThere are many online caching policies to determine which block to evict, including the following:\n\n* First-in, first-out (FIFO): evict the block that has been in the cache the longest time.\n* Last-in, first-out (LIFO): evict the block that has been in the cache the shortest time.\n* Least Recently Used (LRU): evict the block whose last use is furthest in the past.\n* Least Frequently Used (LFU): evict the block that has been accessed the fewest times, breaking ties by choosing the block that has been in the cache the longest.\n\nTo analyze these algorithms, we assume that the cache starts out empty, so that no evictions occur during the first \\(k\\) requests. We wish to compare the performance of an online algorithm to an optimal offline algorithm that knows the future requests. As we will soon see, all these deterministic online algorithms have a lower bound of \\(\\Omega(k)\\) for their competitive ratio. Some deterministic algorithms also have a competitive ratio with an \\(O(k)\\) upper bound, but some other deterministic algorithms are considerably worse, having a competitive ratio of \\(\\Theta(n/k)\\).\n\nWe now proceed to analyze the LIFO and LRU policies. In addition to assuming that \\(n>k\\), we will assume that at least \\(k\\) distinct blocks are requested. Otherwise, the cache never fills up and no blocks are evicted, so that all algorithms exhibit the same behavior. We begin by showing that LIFO has a large competitive ratio.\n\n**Theorem 27.2**: LIFO has a competitive ratio of \\(\\Theta(n/k)\\) for the online caching problem with \\(n\\) requests and a cache of size \\(k\\).\n\nProof.: We first show a lower bound of \\(\\Omega(n/k)\\). Suppose that the input consists of \\(k+1\\) blocks, numbered \\(1,2,\\ldots,k+1\\), and the request sequence is\n\n\\[1,\\ 2,\\ 3,\\ 4,\\ \\ldots,\\ k,\\ k+1,k,k\\ \\ \\ \\ +1,k,k\\ \\ \\ +1,\\ \\ldots\\,\\]\n\nwhere after the initial \\(1,2,\\ldots,k,k+1\\), the remainder of the sequence alternates between \\(k\\) and \\(k+1\\), with a total of \\(n\\) requests. The sequence ends on block \\(k\\) if \\(n\\) and \\(k\\) are either both even or both odd, and otherwise, the sequence ends on block \\(k+1\\). That is, \\(b_{i}=i\\) for \\(i=1,2,\\ldots k-1,b_{i}=k+1\\) for \\(i=k+1,k+3,\\ldots\\) and \\(b_{i}=k\\) for \\(i=k,k+2,\\ldots\\). How many blocks does LIFO evict? After the first \\(k\\) requests (which are considered to be cache misses), the cache is filled with blocks \\(1,2,\\ldots,k\\). The (\\(k+1\\))st request, which is for block \\(k+1\\), causes block \\(k\\) to be evicted. The (\\(k+2\\))nd request, which is for block \\(k\\), forces block \\(k+1\\) to be evicted, since that block was just placed into the cache. This behavior continues, alternately evicting blocks \\(k\\) and \\(k+1\\) for the remaining requests. LIFO, therefore, suffers a cache miss on every one of the \\(n\\) requests.\n\nThe optimal offline algorithm knows the entire sequence of requests in advance. Upon the first request of block \\(k+1\\), it just evicts any block except block \\(k\\), and then it never evicts another block. Thus, the optimal offline algorithm evicts only once. Since the first \\(k\\) requests are considered cache misses, the total number of cache misses is \\(k+1\\). The competitive ratio, therefore, is \\(n/(k+1)\\), or \\(\\Omega(n/k)\\).\n\nFor the upper bound, observe that on any input of size \\(n\\), any caching algorithm incurs at most \\(n\\) cache misses. Because the input contains at least \\(k\\) distinct blocks, any caching algorithm, including the optimal offline algorithm, must incur at least \\(k\\) cache misses. Therefore, LIFO has a competitive ratio of \\(O(n/k)\\).\n\nWe call such a competitive ratio _unbounded_, because it grows with the input size. Exercise 27.3-2 asks you to show that LFU also has an unbounded competitive ratio.\n\nFIFO and LRU have a much better competitive ratio of \\(\\Theta(k)\\). There is a big difference between competitive ratios of \\(\\Theta(n/k)\\) and \\(\\Theta(k)\\). The cache size \\(k\\) is independent of the input sequence and does not grow as more requests arrive over time. A competitive ratio that depends on \\(n\\), on the other hand, does grow with the size of the input sequence and thus can get quite large. It is preferable to use an algorithm with a competitive ratio that does not grow with the input sequence's size, when possible.\n\nWe now show that LRU has a competitive ratio of \\(\\Theta(k)\\), first showing the upper bound.\n\n**Theorem 27.3**: _LRU has a competitive ratio of \\(O(k)\\) for the online caching problem with \\(n\\) requests and a cache of size \\(k\\)._\n\n_Proof_ To analyze LRU, we will divide the sequence of requests into _epochs_. Epoch 1 begins with the first request. Epoch \\(i\\), for \\(i\\,>\\,1\\), begins upon encountering the (\\(k\\,+\\,1\\))st distinct request since the beginning of epoch \\(i\\,-\\,1\\). Consider the following example of requests with \\(k\\,=\\,3\\):\n\n\\[1,\\ 2,\\ 1,\\ 5,\\ 4,\\ 4,\\ 1,\\ 2,\\ 4,\\ 2,\\ 3,\\ 4,\\ 5,\\ 2,\\ 2,\\ 1,\\ 2,\\ 2. \\tag{27.10}\\]\n\nThe first \\(k\\,=\\,3\\) distinct requests are for blocks \\(1\\), \\(2\\) and \\(5\\), so epoch 2 begins with the first request for block \\(4\\). In epoch \\(2\\), the first 3 distinct requests are for blocks \\(4\\), \\(1\\), and \\(2\\). Requests for these blocks recur until the request for block \\(3\\), and with this request epoch \\(3\\) begins. Thus, this example has four epochs:\n\n\\[1,2,1,5\\qquad\\qquad 4,\\ 4,\\ 1,\\ 2,\\ 4,\\ 2\\qquad\\qquad 3,4,5\\qquad\\qquad 2,\\ 2,\\ 1,\\ 2,\\ 2. \\tag{27.11}\\]\n\nNow we consider the behavior of LRU. In each epoch, the first time a request for a particular block appears, it may cause a cache miss, but subsequent requests for that block within the epoch cannot cause a cache miss, since the block is now one of the \\(k\\) most recently used. For example, in epoch \\(2\\), the first request for block \\(4\\) causes a cache miss, but the subsequent requests for block \\(4\\) do not. (Exercise 27.3-1 asks you to show the contents of the cache after each request.) In epoch \\(3\\), requests for blocks \\(3\\) and \\(5\\) cause cache misses, but the request for block \\(4\\) does not, because it was recently accessed in epoch \\(2\\). Since only the first request for a block within an epoch can cause a cache miss and the cache holds \\(k\\) blocks, each epoch incurs at most \\(k\\) cache misses.\n\nNow consider the behavior of the optimal algorithm. The first request in each epoch must cause a cache miss, even for an optimal algorithm. The miss occurs because, by the definition of an epoch, there _must_ have been \\(k\\) other blocks accessed since the last access to this block.\n\nSince, for each epoch, the optimal algorithm incurs at least one miss and LRU incurs at most \\(k\\), the competitive ratio is at most \\(k/1\\,=\\,O(k)\\).\n\nExercise 27.3-3 asks you to show that FIFO also has a competitive ratio of \\(O(k)\\).\n\nWe could show lower bounds of \\(\\Omega(k)\\) on LRU and FIFO, but in fact, we can make a much stronger statement: _any_ deterministic online caching algorithm must have a competitive ratio of \\(\\Omega(k)\\). The proof relies on an adversary who knows the online algorithm being used and can tailor the future requests to cause the online algorithm to incur more cache misses than the optimal offline algorithm.\n\nConsider a scenario in which the cache has size \\(k\\) and the set of possible blocks to request is \\(\\{1,2,\\ldots,k\\,+1\\}\\). The first \\(k\\) requests are for blocks \\(1,2,\\ldots,k\\), sothat both the adversary and the deterministic online algorithm place these blocks into the cache. The next request is for block \\(k\\) + 1. In order to make room in the cache for block \\(k\\) + 1, the online algorithm evicts some block \\(b_{1}\\) from the cache. The adversary, knowing that the online algorithm has just evicted block \\(b_{1}\\), makes the next request be for \\(b_{1}\\), so that the online algorithm must evict some other block \\(b_{2}\\) to clear room in the cache for \\(b_{1}\\). As you might have guessed, the adversary makes the next request be for block \\(b_{2}\\), so that the online algorithm evicts some other block \\(b_{3}\\) to make room for \\(b_{2}\\). The online algorithm and the adversary continue in this manner. The online algorithm incurs a cache miss on every request and therefore incurs \\(n\\) cache misses over the \\(n\\) requests.\n\nNow let's consider an optimal offline algorithm, which knows the future. As discussed in Section 15.4, this algorithm is known as furthest-in-future, and it always evicts the block whose next request is furthest in the future. Since there are only \\(k\\) + 1 unique blocks, when furthest-in-future evicts a block, we know that it will not be accessed during at least the next \\(k\\) requests. Thus, after the first \\(k\\) cache misses, the optimal algorithm incurs a cache miss at most once every \\(k\\) requests. Therefore, the number of cache misses over \\(n\\) requests is at most \\(k\\) + \\(n/k\\).\n\nSince the deterministic online algorithm incurs \\(n\\) cache misses and the optimal offline algorithm incurs at most \\(k\\) + \\(n/k\\) cache misses, the competitive ratio is at least\n\n\\[\\frac{n}{k+n/k}=\\frac{nk}{n+k^{2}}\\.\\]\n\nFor \\(n\\geq k^{2}\\), the above expression is at least\n\n\\[\\frac{nk}{n+k^{2}}\\geq\\frac{nk}{2n}=\\frac{k}{2}\\.\\]\n\nThus, for sufficiently long request sequences, we have shown the following:\n\n**Theorem 27.4**: Any deterministic online algorithm for caching with a cache size of \\(k\\) has competitive ratio \\(\\Omega(k)\\). \\({}_{\\blacksquare}\\)\n\nAlthough we can analyze the common caching strategies from the point of view of competitive analysis, the results are somewhat unsatisfying. Yes, we can distinguish between algorithms with a competitive ratio of \\(\\Theta(k)\\) and those with unbounded competitive ratios. In the end, however, all of these competitive ratios are rather high. The online algorithms we have seen so far are deterministic, and it is this property that the adversary is able to exploit.\n\n#### Randomized caching algorithms\n\nIf we don't limit ourselves to deterministic online algorithms, we can use randomization to develop an online caching algorithm with a significantly smaller competitive ratio. Before describing the algorithm, let's discuss randomization in online algorithms in general. Recall that we analyze online algorithms with respect to an adversary who knows the online algorithm and can design requests knowing the decisions made by the online algorithm. With randomization, we must ask whether the adversary also knows the random choices made by the online algorithm. An adversary who does not know the random choices is _oblivious_, and an adversary who knows the random choices is _nonoblivious_. Ideally, we prefer to design algorithms against a nonoblivious adversary, as this adversary is stronger than an oblivious one. Unfortunately, a nonoblivious adversary mitigates much of the power of randomness, as an adversary who knows the outcome of random choices typically can act as if the online algorithm is deterministic. The oblivious adversary, on the other hand, does not know the random choices of the online algorithm, and that is the adversary we typically use.\n\nAs a simple illustration of the difference between an oblivious and nonoblivious adversary, imagine that you are flipping a fair coin \\(n\\) times, and the adversary wants to know how many heads you flipped. A nonoblivious adversary knows, after each flip, whether the coin came up heads or tails, and hence knows how many heads you flipped. An oblivious adversary, on the other hand, knows only that you are flipping a fair coin \\(n\\) times. The oblivious adversary, therefore, can reason that the number of heads follows a binomial distribution, so that the expected number of heads is \\(n/2\\) (by equation (C.41) on page 1199) and the variance is \\(n/4\\) (by equation (C.44) on page 1200). But the oblivious adversary has no way of knowing exactly how many heads you actually flipped.\n\nLet's return to caching. We'll start with a deterministic algorithm and then randomize it. The algorithm we'll use is an approximation of LRU called Marking. Rather than \"least recently used,\" think of Marking as simply \"recently used.\" Marking maintains a 1-bit attribute _mark_ for each block in the cache. Initially, all blocks in the cache are unmarked. When a block is requested, if it is already in the cache, it is marked. If the request is a cache miss, Marking checks to see whether there are any unmarked blocks in the cache. If all blocks are marked, then they are all changed to unmarked. Now, regardless of whether all blocks in the cache were marked when the request occurred, there is at least one unmarked block in the cache, and so an arbitrary unmarked block is evicted, and the requested block is placed into the cache and marked.\n\nHow should the block to evict from among the unmarked blocks in the cache be chosen? The procedure Randomized-Marking on the next page shows theprocess when the block is chosen randomly. The procedure takes as input a block \\(b\\) being requested.\n\nRandomized-Marking(\\(b\\))\n\n```\n1ifblock\\(b\\) resides in the cache,\n2\\(b.\\mathit{mark}\\,=\\,1\\)\n3else\n4ifall blocks\\(b^{\\prime}\\) in the cache have \\(b^{\\prime}.\\mathit{mark}\\,=\\,1\\)\n5\\(\\mathit{unmark}\\) all blocks \\(b^{\\prime}\\) in the cache, setting \\(b^{\\prime}.\\mathit{mark}\\,=\\,0\\)\n6 select an unmarked block \\(u\\) with \\(u.\\mathit{mark}\\,=\\,0\\) uniformly at random\n7\\(\\mathit{evict}\\) block \\(u\\)\n8 place block \\(b\\) into the cache\n9\\(b.\\mathit{mark}\\,=\\,1\\)\n```\n\nFor the purpose of analysis, we say that a new epoch begins immediately after each time line 5 executes. An epoch starts with no marked blocks in the cache. The first time a block is requested during an epoch, the number of marked blocks increases by 1, and any subsequent requests to that block do not change the number of marked blocks. Therefore, the number of marked blocks monotonically increases within an epoch. Under this view, epochs are the same as in the proof of Theorem 27.3: with a cache that holds \\(k\\) blocks, an epoch comprises requests for \\(k\\) distinct blocks (possibly fewer for the final epoch), and the next epoch begins upon a request for a block not in those \\(k\\).\n\nBecause we are going to analyze a randomized algorithm, we will compute the expected competitive ratio. Recall that for an input \\(I\\), we denote the solution value of an online algorithm \\(A\\) by \\(A(I)\\) and the solution value of an optimal algorithm \\(F\\) by \\(F(I)\\). Online algorithm \\(A\\) has an _expected competitive ratio_\\(c\\) if for all inputs \\(I\\), we have\n\n\\[\\mathrm{E}\\left[A(I)\\right]\\leq cF(I)\\, \\tag{27.12}\\]\n\nwhere the expectation is taken over the random choices made by \\(A\\).\n\nAlthough the deterministic Marking algorithm has a competitive ratio of \\(\\Theta(k)\\) (Theorem 27.4 provides the lower bound and see Exercise 27.3-4 for the upper bound), Randomized-Marking has a much smaller expected competitive ratio, namely \\(O(\\lg k)\\). The key to the improved competitive ratio is that the adversary cannot always make a request for a block that is not in the cache, since an oblivious adversary does not know which blocks are in the cache.\n\n**Theorem 27.5**: Randomized-Marking has an expected competitive ratio of \\(O(\\lg k)\\) for the online caching problem with \\(n\\) requests and a cache of size \\(k\\), against an oblivious adversary.\n\nBefore proving Theorem 27.5, we prove a basic probabilistic fact.\n\n**Lemma 27.6**: Suppose that a bag contains \\(x+y\\) balls: \\(x-1\\) blue balls, \\(y\\) white balls, and \\(1\\) red ball. You repeatedly choose a ball at random and remove it from the bag until you have chosen a total of \\(m\\) balls that are either blue or red, where \\(m\\leq x\\). You set aside each white ball you choose. Then, one of the balls chosen is the red ball with probability \\(m/x\\).\n\n_Proof_Choosing a white ball does not affect how many blue or red balls are chosen in any way. Therefore, we can continue the analysis as if there were no white balls and the bag contains just \\(x-1\\) blue balls and \\(1\\) red ball.\n\nLet \\(A\\) be the event that the red ball is not chosen, and let \\(A_{i}\\) be the event that the \\(i\\)th draw does not choose the red ball. By equation (C.22) on page 1190, we have\n\n\\[\\Pr\\left\\{A\\right\\} = \\Pr\\left\\{A_{1}\\cap A_{2}\\cap\\cdots\\cap A_{m}\\right\\} \\tag{27.13}\\] \\[= \\Pr\\left\\{A_{1}\\right\\}\\cdot\\Pr\\left\\{A_{2}\\mid A_{1}\\right\\} \\cdot\\Pr\\left\\{A_{3}\\mid A_{1}\\cap A_{2}\\right\\}\\cdots\\] \\[\\Pr\\left\\{A_{m}\\mid A_{1}\\cap A_{2}\\cap\\cdots\\cap A_{m-1}\\right\\} \\.\\]\n\nThe probability \\(\\Pr\\left\\{A_{1}\\right\\}\\) that the first ball is blue equals \\((x-1)/x\\), since initially there are \\(x-1\\) blue balls and \\(1\\) red ball. More generally, we have\n\n\\[\\Pr\\left\\{A_{i}\\mid A_{1}\\cap\\cdots\\cap A_{i-1}\\right\\}=\\frac{x-i}{x-i+1}\\, \\tag{27.14}\\]\n\nsince the \\(i\\)th draw is from \\(x-i\\) blue balls and \\(1\\) red ball. Equations (27.13) and (27.14) give\n\n\\[\\Pr\\left\\{A\\right\\}=\\left(\\frac{x-1}{x}\\right)\\!\\left(\\frac{x-2}{x-1}\\right) \\!\\left(\\frac{x-3}{x-2}\\right)\\cdots\\left(\\frac{x-m+1}{x-m+2}\\right)\\!\\left( \\frac{x-m}{x-m+1}\\right). \\tag{27.15}\\]\n\nThe right-hand side of equation (27.15) is a telescoping product, similar to the telescoping series in equation (A.12) on page 1143. The numerator of one term equals the denominator of the next, so that everything except the first denominator and last numerator cancel, and we obtain \\(\\Pr\\left\\{A\\right\\}=(x-m)/x\\). Since we actually want to compute \\(\\Pr\\left\\{\\bar{A}\\right\\}=1-\\Pr\\left\\{A\\right\\}\\), that is, the probability that the red ball _is_ chosen, we get \\(\\Pr\\left\\{\\bar{A}\\right\\}=1-(x-m)/x=m/x\\).\n\nNow we can prove Theorem 27.5.\n\n_Proof_ We'll analyze Randomized-Marking one epoch at a time. Within epoch \\(i\\), any request for a block \\(b\\) that is not the first request for block \\(b\\) in epoch \\(i\\) must result in a cache hit, since after the first request in epoch \\(i\\), block \\(b\\) resides in the cache and is marked, so that it cannot be evicted during the epoch. Therefore, since we are counting cache misses, we'll consider only the first request for each block within each epoch, disregarding all other requests.\n\nWe can classify the requests in an epoch as either old or new. If block \\(b\\) resides in the cache at the start of epoch \\(i\\), each request for block \\(b\\) during epoch \\(i\\) is an _old request_. Old requests in epoch \\(i\\) are for blocks requested in epoch \\(i-1\\). If a request in epoch \\(i\\) is not old, it is a _new request_, and it is for a block not requested in epoch \\(i-1\\). All requests in epoch \\(1\\) are new. For example, let's look again at the request sequence in example (27.11):\n\n1,2,1,5 4, 4, 1, 2, 4, 2 3,4,5 2, 2, 1, 2, 2.\n\nSince we can disregard all requests for a block within an epoch other than the first request, to analyze the cache behavior, we can view this request sequence as just\n\n1,2,5 4,1,2 3,4,5 2, 1.\n\nAll three requests in epoch 1 are new. In epoch 2, the requests for blocks 1 and 2 are old, but the request for block 4 is new. In epoch 3, the request for block 4 is old, and the requests for blocks 3 and 5 are new. Both requests in epoch 4 are new.\n\nWithin an epoch, each new request must cause a cache miss since, by definition, the block is not already in the cache. An old request, on the other hand, may or may not cause a cache miss. The old block is in the cache at the beginning of the epoch, but other requests might cause it to be evicted. Returning to our example, in epoch 2, the request for block 4 must cause a cache miss, as this request is new. The request for block 1, which is old, may or may not cause a cache miss. If block 1 was evicted when block 4 was requested, then a cache miss occurs and block 1 must be brought back into the cache. If instead block 1 was not evicted when block 4 was requested, then the request for block 1 results in a cache hit. The request for block 2 could incur a cache miss under two scenarios. One is if block 2 was evicted when block 4 was requested. The other is if block 1 was evicted when block 4 was requested, and then block 2 was evicted when block 1 was requested. We see that, within an epoch, each ensuing old request has an increasing chance of causing a cache miss.\n\nBecause we consider only the first request for each block within an epoch, we assume that each epoch contains exactly \\(k\\) requests, and each request within an epoch is for a unique block. (The last epoch might contain fewer than \\(k\\) requests. If it does, just add dummy requests to fill it out to \\(k\\) requests.) In epoch \\(i\\), denote the number of new requests by \\(r_{i}\\geq 1\\) (an epoch must contain at least one new request), so that the number of old requests is \\(k-r_{i}\\). As mentioned above, a new request always incurs a cache miss.\n\nLet us now focus on an arbitrary epoch \\(i\\) to obtain a bound on the expected number of cache misses within that epoch. In particular, let's think about the \\(j\\)th old request within the epoch, where \\(1\\leq j<k\\). Denote by \\(b_{ij}\\) the block requested in the \\(j\\)th old request of epoch \\(i\\), and denote by \\(n_{ij}\\) and \\(o_{ij}\\) the number of new and old requests, respectively, that occur within epoch \\(i\\) but before the \\(j\\)th old request. Because \\(j-1\\) old requests occur before the \\(j\\)th old request, we have \\(o_{ij}=j-1\\). We will show that the probability of a cache miss upon the \\(j\\)th old request is \\(n_{ij}/(k-o_{ij})\\), or \\(n_{ij}/(k-j+1)\\).\n\nStart by considering the first old request, for block \\(b_{i,1}\\). What is the probability that this request causes a cache miss? It causes a cache miss precisely when one of the \\(n_{i,1}\\) previous requests resulted in \\(b_{i,1}\\) being evicted. We can determine the probability that \\(b_{i,1}\\) was chosen for eviction by using Lemma 27.6: consider the \\(k\\) blocks in the cache to be \\(k\\) balls, with block \\(b_{i,1}\\) as the red ball, the other \\(k-1\\) blocks as the \\(k-1\\) blue balls, and no white balls. Each of the \\(n_{i,1}\\) requests chooses a block to evict with equal probability, corresponding to drawing balls \\(n_{i,1}\\) times. Thus, we can apply Lemma 27.6 with \\(x=k\\), \\(y=0\\), and \\(m=n_{i,1}\\), deriving the probability of a cache miss upon the first old request as \\(n_{i,1}/k\\), which equals \\(n_{ij}/(k-j+1)\\) since \\(j=1\\).\n\nIn order to determine the probability of a cache miss for subsequent old requests, we'll need an additional observation. Let's consider the second old request, which is for block \\(b_{i,2}\\). This request causes a cache miss precisely when one of the previous requests evicts \\(b_{i,2}\\). Let's consider two cases, based on the request for \\(b_{i,1}\\). In the first case, suppose that the request for \\(b_{i,1}\\) did not cause an eviction, because \\(b_{i,1}\\) was already in the cache. Then, the only way that \\(b_{i,2}\\) could have been evicted is by one of the \\(n_{i,2}\\) new requests that precedes it. What is the probability that this eviction happens? There are \\(n_{i,2}\\) chances for \\(b_{i,2}\\) to be evicted, but we also know that there is one block in the cache, namely \\(b_{i,1}\\), that is not evicted. Thus, we can again apply Lemma 27.6, but with \\(b_{i,1}\\) as the white ball, \\(b_{i,2}\\) as the red ball, the remaining blocks as the blue balls, and drawing balls \\(n_{i,2}\\) times. Applying Lemma 27.6, with \\(x=k-1\\), \\(y=1\\), and \\(m=n_{i,2}\\), we find that the probability of a cache miss is \\(n_{i,2}/(k-1)\\). In the second case, the request for \\(b_{i,1}\\) does cause an eviction, which can happen only if one of the new requests preceding the request for \\(b_{i,1}\\) evicts \\(b_{i,1}\\). Then, the request for \\(b_{i,1}\\) brings \\(b_{i,1}\\) back into the cache and evicts some other block. In this case, we know that of the new requests, one of them did not result in \\(b_{i,2}\\) being evicted, since \\(b_{i,1}\\) was evicted. Therefore, \\(n_{i,2}-1\\) new requests could evict \\(b_{i,2}\\), as could the request for \\(b_{i,1}\\), so that the number of requests that could evict \\(b_{i,2}\\) is \\(n_{i,2}\\). Each such request evicts a block chosen from among \\(k-1\\) blocks, since the request that resulted in evicting \\(b_{i,1}\\) did not also cause \\(b_{i,2}\\) to be evicted. Therefore, we can apply Lemma 27.6, with \\(x=k-1\\)\\(y=1\\), and \\(m=n_{i,2}\\), and get that the probability of a miss is \\(n_{i,2}/(k-1)\\). In both cases the probability is the same, and it equals \\(n_{ij}/(k-j+1)\\) since \\(j=2\\).\n\nMore generally, \\(o_{ij}\\) old requests occur before the \\(j\\)th old request. Each of these prior old requests either caused an eviction or did not. For those that caused an eviction, it is because they were evicted by a previous request, and for those that did not cause an eviction, it is because they were not evicted by any previous request. In either case, we can decrease the number of blocks that the random process is choosing from by 1 for each old request, and thus \\(o_{ij}\\) requests cannot cause \\(b_{ij}\\) to be evicted. Therefore, we can use Lemma 27.6 to determine the probability that \\(b_{ij}\\) was evicted by a previous request, with \\(x=k-o_{ij}\\), \\(y=o_{ij}\\) and \\(m=n_{ij}\\). Thus, we have proven our claim that the probability of a cache miss on the \\(j\\)th request for an old block is \\(n_{ij}/(k-o_{ij})\\), or \\(n_{ij}/(k-j+1)\\). Since \\(n_{ij}\\leq r_{i}\\) (recall that \\(r_{i}\\) is the number of new requests during epoch \\(i\\)), we have an upper bound of \\(r_{i}/(k-j+1)\\) on the probability that the \\(j\\)th old request incurs a cache miss.\n\nWe can now compute the expected number of misses during epoch \\(i\\) using indicator random variables, as introduced in Section 5.2. We define indicator random variables\n\n\\[Y_{ij} = \\mathrm{I}\\left\\{\\text{the $j$th old request in epoch $i$ incurs a cache miss}\\right\\}\\,\\] \\[Z_{ij} = \\mathrm{I}\\left\\{\\text{the $j$th new request in epoch $i$ incurs a cache miss}\\right\\}\\.\\]\n\nWe have \\(Z_{ij}=1\\) for \\(j=1,2,\\ldots,r_{i}\\), since every new request results in a cache miss. Let \\(X_{i}\\) be the random variable denoting the number of cache misses during epoch \\(i\\), so that\n\n\\[X_{i}=\\sum_{j=1}^{k-r_{i}}Y_{ij}+\\sum_{j=1}^{r_{i}}Z_{ij}\\,\\]\n\nand so\n\n\\[\\mathrm{E}\\left[X_{i}\\right] = \\mathrm{E}\\left[\\sum_{j=1}^{k-r_{i}}Y_{ij}+\\sum_{j=1}^{r_{i}}Z_{ ij}\\right]\\] \\[= \\sum_{j=1}^{k-r_{i}}\\mathrm{E}\\left[Y_{ij}\\right]+\\sum_{j=1}^{r_{ i}}\\mathrm{E}\\left[Z_{ij}\\right]\\quad\\text{ (by linearity of expectation)}\\] \\[\\leq \\sum_{j=1}^{k-r_{i}}\\frac{r_{i}}{k-j+1}+\\sum_{j=1}^{r_{i}}1\\quad \\text{ (by Lemma \\ref{lem:c_1} on page \\ref{lem:c_2})}\\] \\[= r_{i}\\left(\\sum_{j=1}^{k-r_{i}}\\frac{1}{k-j+1}+1\\right)\\]\n\n#### 27.3 Online caching\n\n\\[\\leq r_{i}\\left(\\sum_{j=1}^{k-1}\\frac{1}{k-j+1}+1\\right) \\tag{27.16}\\] \\[= r_{i}\\,H_{k}\\qquad\\qquad\\qquad\\qquad\\mbox{(by equation (A.8) on page \\ref{eq:201142}) }\\,\\]\n\nwhere \\(H_{k}\\) is the \\(k\\)th harmonic number.\n\nTo compute the expected total number of cache misses, we sum over all epochs. Let \\(p\\) denote the number of epochs and \\(X\\) be the random variable denoting the number of cache misses. Then, we have \\(X=\\sum_{i=1}^{p}X_{i}\\), so that\n\n\\[\\mbox{E}\\left[X\\right] = \\mbox{E}\\left[\\sum_{i=1}^{p}X_{i}\\right] \\tag{27.17}\\] \\[= \\sum_{i=1}^{p}\\mbox{E}\\left[X_{i}\\right]\\quad\\quad\\mbox{(by linearity of expectation)}\\] \\[\\leq \\sum_{i=1}^{p}r_{i}\\,H_{k}\\qquad\\mbox{(by inequality (27.16))}\\] \\[= H_{k}\\,\\sum_{i=1}^{p}r_{i}\\.\\]\n\nTo complete the analysis, we need to understand the behavior of the optimal offline algorithm. It could make a completely different set of decisions from those made by Randomized-Marking, and at any point its cache may look nothing like the cache of the randomized algorithm. Yet, we want to relate the number of cache misses of the optimal offline algorithm to the value in inequality (27.17), in order to have a competitive ratio that does not depend on \\(\\sum_{i=1}^{p}r_{i}\\). Focusing on individual epochs won't suffice. At the beginning of any epoch, the offline algorithm might have loaded the cache with exactly the blocks that will be requested in that epoch. Therefore, we cannot take any one epoch in isolation and claim that an offline algorithm must suffer any cache misses during that epoch.\n\nIf we consider two consecutive epochs, however, we can better analyze the optimal offline algorithm. Consider two consecutive epochs, \\(i-1\\) and \\(i\\). Each contains \\(k\\) requests for \\(k\\) different blocks. (Recall our assumption that all requests are first requests in an epoch.) Epoch \\(i\\) contains \\(r_{i}\\) requests for new blocks, that is, blocks that were not requested during epoch \\(i-1\\). Therefore, the number of distinct requests during epochs \\(i-1\\) and \\(i\\) is exactly \\(k+r_{i}\\). No matter what the cache contents were at the beginning of epoch \\(i-1\\), after \\(k+r_{i}\\) distinct requests, there must be at least \\(r_{i}\\) cache misses. There could be more, but there is no way to have fewer. Letting \\(m_{i}\\) denote the number of cache misses of the offline algorithm during epoch \\(i\\), we have just argued that\n\n\\[m_{i-1}+m_{i}\\geq r_{i}. \\tag{27.18}\\]The total number of cache misses of the offline algorithm is\n\n\\[\\sum_{i=1}^{p}m_{i} = \\frac{1}{2}\\sum_{i=1}^{p}2m_{i}\\] \\[= \\frac{1}{2}\\left(m_{1}+\\sum_{i=2}^{p}(m_{i-1}+m_{i})+m_{p}\\right)\\] \\[\\geq \\frac{1}{2}\\left(m_{1}+\\sum_{i=2}^{p}(m_{i-1}+m_{i})\\right)\\] \\[\\geq \\frac{1}{2}\\left(m_{1}+\\sum_{i=2}^{p}r_{i}\\right)\\qquad\\quad(\\mbox {by inequality (\\ref{eq:m1})})\\] \\[= \\frac{1}{2}\\sum_{i=1}^{p}r_{i}\\qquad\\qquad\\qquad\\quad(\\mbox{ because }m_{1}=r_{1})\\.\\]\n\nThe justification \\(m_{1}=r_{1}\\) for the last equality follows because, by our assumptions, the cache starts out empty and every request incurs a cache miss in the first epoch, even for the optimal offline adversary.\n\nTo conclude the analysis, because we have an upper bound of \\(H_{k}\\sum_{i=1}^{p}r_{i}\\) on the expected number of cache misses for Randomized-Marking and a lower bound of \\(\\frac{1}{2}\\sum_{i=1}^{p}r_{i}\\) on the number of cache misses for the optimal offline algorithm, the expected competitive ratio is at most\n\n\\[\\frac{H_{k}\\sum_{i=1}^{p}r_{i}}{\\frac{1}{2}\\sum_{i=1}^{p}r_{i}} = 2H_{k}\\] \\[= 2\\ln k\\,+\\,O(1)\\quad(\\mbox{by equation (\\ref{eq:m1}) on page 1142})\\] \\[= \\,O(\\lg k)\\.\\]\n\n## Exercises\n\n### 27.3-1\n\nFor the cache sequence (27.10), show the contents of the cache after each request and count the number of cache misses. How many misses does each epoch incur?\n\n### 27.3-2\n\nShow that LFU has a competitive ratio of \\(\\Theta(n/k)\\) for the online caching problem with \\(n\\) requests and a cache of size \\(k\\).\n\n### 27.3-3\n\nShow that FIFO has a competitive ratio of \\(O(k)\\) for the online caching problem with \\(n\\) requests and a cache of size \\(k\\).\n\n#### 27.3-4\n\nShow that the deterministic Marking algorithm has a competitive ratio of \\(O(k)\\) for the online caching problem with \\(n\\) requests and a cache of size \\(k\\).\n\n#### 27.3-5\n\nTheorem 27.4 shows that any deterministic online algorithm for caching has a competitive ratio of \\(\\Omega(k)\\), where \\(k\\) is the cache size. One way in which an algorithm might be able to perform better is to have some ability to know what the next few requests will be. We say that an algorithm is _1-lookahead_ if it has the ability to look ahead at the next \\(l\\) requests. Prove that for every constant \\(l\\geq 0\\) and every cache size \\(k\\geq\\)1, every deterministic \\(l\\)-lookahead algorithm has competitive ratio \\(\\Omega(k)\\).\n\n## Problems\n\n### 27-1 Cow-path problem\n\nThe Appalachian Trail (AT) is a marked hiking trail in the eastern United States extending between Springer Mountain in Georgia and Mount Katahdin in Maine. The trail is about 2,190 miles long. You decide that you are going to hike the AT from Georgia to Maine and back. You plan to learn more about algorithms while on the trail, and so you bring along your copy of _Introduction to Algorithms_ in your backpack.2 You have already read through this chapter before starting out. Because the beauty of the trail distracts you, you forget about reading this book until you have reached Maine and hiked halfway back to Georgia. At that point, you decide that you have already seen the trail and want to continue reading the rest of the book, starting with Chapter 28. Unfortunately, you find that the book is no longer in your pack. You must have left it somewhere along the trail, but you don't know where. It could be anywhere between Georgia and Maine. You want to find the book, but now that you have learned something about online algorithms, you want your algorithm for finding it to have a good competitive ratio. That is, no matter where the book is, if its distance from you is \\(x\\) miles away, you would like to be sure that you do not walk more than \\(cx\\) miles to find it, for some constant \\(c\\). You do not know \\(x\\), though you may assume that \\(x\\geq 1\\).3",
        "chapter": "Part VII Selected Topics",
        "section": "27 Online Algorithms",
        "subsection": "27.3 Online caching",
        "subsubsection": "N/A"
    },
    {
        "content": "#### 27.3-4\n\nShow that the deterministic Marking algorithm has a competitive ratio of \\(O(k)\\) for the online caching problem with \\(n\\) requests and a cache of size \\(k\\).\n\n#### 27.3-5\n\nTheorem 27.4 shows that any deterministic online algorithm for caching has a competitive ratio of \\(\\Omega(k)\\), where \\(k\\) is the cache size. One way in which an algorithm might be able to perform better is to have some ability to know what the next few requests will be. We say that an algorithm is _1-lookahead_ if it has the ability to look ahead at the next \\(l\\) requests. Prove that for every constant \\(l\\geq 0\\) and every cache size \\(k\\geq\\)1, every deterministic \\(l\\)-lookahead algorithm has competitive ratio \\(\\Omega(k)\\).\n\n## Problems\n\n### 27-1 Cow-path problem\n\nThe Appalachian Trail (AT) is a marked hiking trail in the eastern United States extending between Springer Mountain in Georgia and Mount Katahdin in Maine. The trail is about 2,190 miles long. You decide that you are going to hike the AT from Georgia to Maine and back. You plan to learn more about algorithms while on the trail, and so you bring along your copy of _Introduction to Algorithms_ in your backpack.2 You have already read through this chapter before starting out. Because the beauty of the trail distracts you, you forget about reading this book until you have reached Maine and hiked halfway back to Georgia. At that point, you decide that you have already seen the trail and want to continue reading the rest of the book, starting with Chapter 28. Unfortunately, you find that the book is no longer in your pack. You must have left it somewhere along the trail, but you don't know where. It could be anywhere between Georgia and Maine. You want to find the book, but now that you have learned something about online algorithms, you want your algorithm for finding it to have a good competitive ratio. That is, no matter where the book is, if its distance from you is \\(x\\) miles away, you would like to be sure that you do not walk more than \\(cx\\) miles to find it, for some constant \\(c\\). You do not know \\(x\\), though you may assume that \\(x\\geq 1\\).3What algorithm should you use, and what constant \\(c\\) can you prove bounds the total distance \\(c\\,x\\) that you would have to walk? Your algorithm should work for a trail of any length, not just the 2,190-mile-long AT.\n\n#### 27.2 Online scheduling to minimize average completion time\n\nProblem 15-2 discusses scheduling to minimize average completion time on one machine, without release times and preemption and with release times and preemption. Now you will develop an online algorithm for nonpreemptively scheduling a set of tasks with release times. Suppose you are given a set \\(S=\\{a_{1},a_{2},\\ldots,a_{n}\\}\\) of tasks, where task \\(a_{i}\\) has _release time_\\(r_{i}\\), before which it cannot start, and requires \\(p_{i}\\) units of processing time to complete once it has started. You have one computer on which to run the tasks. Tasks cannot be _preempted_, which is to say that once started, a task must run to completion without interruption. (See Problem 15-2 on page 446 for a more detailed description of this problem.) Given a schedule, let \\(C_{i}\\) be the _completion time_ of task \\(a_{i}\\), that is, the time at which task \\(a_{i}\\) completes processing. Your goal is to find a schedule that minimizes the average completion time, that is, to minimize \\((1/n)\\sum_{i=1}^{n}C_{i}\\).\n\nIn the online version of this problem, you learn about task \\(i\\) only when it arrives at its release time \\(r_{i}\\), and at that point, you know its processing time \\(p_{i}\\). The offline version of this problem is NP-hard (see Chapter 34), but you will develop a 2-competitive online algorithm.\n\n**a.**: Show that, if there are release times, scheduling by shortest processing time (when the machine becomes idle, start the already released task with the smallest processing time that has not yet run) is not \\(d\\)-competitive for any constant \\(d\\).\n\nIn order to develop an online algorithm, consider the preemptive version of this problem, which is discussed in Problem 15-2(b). One way to schedule is to run the tasks according to the shortest remaining processing time (SRPT) order. That is, at any point, the machine is running the available task with the smallest amount of remaining processing time.\n\n**b.**: Explain how to run SRPT as an online algorithm.\n**c.**: Suppose that you run SRPT and obtain completion times \\(C_{1}^{\\,P},\\ldots,C_{n}^{\\,P}\\). Show that\n\n\\[\\sum_{i\\,=\\,1}^{n}C_{i}^{\\,P}\\,\\leq\\,\\sum_{i\\,=\\,1}^{n}C_{i}^{\\,*}\\,\\]\n\nwhere the \\(C_{i}^{\\,*}\\) are the completion times in an optimal nonpreemptive schedule.\n\nConsider the (offline) algorithm Completion-Time-Schedule.\n\nCompletion-Time-Schedule(\\(S\\))\n\n1 compute an optimal schedule for the preemptive version of the problem\n\n2 renumber the tasks so that the completion times in the optimal\n\npreemptive schedule are ordered by their completion times\n\n\\(C_{1}^{\\,P}<C_{2}^{\\,P}<\\cdots<C_{n}^{\\,P}\\) in SRPT order\n\n3 greedily schedule the tasks nonpreemptively in the renumbered\n\norder \\(a_{1},\\ldots,a_{n}\\)\n\n4 let \\(C_{1},\\ldots,C_{n}\\) be the completion times of renumbered tasks \\(a_{1},\\ldots,a_{n}\\)\n\nin this nonpreemptive schedule\n\n5 **return**\\(C_{1},\\ldots,C_{n}\\)\n\n_d._ Prove that \\(C_{i}^{\\,P}\\geq\\max\\left\\{\\sum_{j=1}^{i}\\,p_{j},\\max\\left\\{r_{j}:j\\leq i\\right\\}\\right\\}\\) for \\(i=1,\\ldots,n\\).\n\n_e._ Prove that \\(C_{i}\\leq\\max\\left\\{r_{j}:j\\leq i\\right\\}+\\sum_{j=1}^{i}\\,p_{j}\\) for \\(i=1,\\ldots,n\\).\n\n_f._ Algorithm Completion-Time-Schedule is an offline algorithm. Explain how to modify it to produce an online algorithm.\n\n_g._ Combine parts (c)-(f) to show that the online version of Completion-Time-Schedule is 2-competitive.\n\n## Chapter notes\n\nOnline algorithms are widely used in many domains. Some good overviews include the textbook by Borodin and El-Yaniv [68], the collection of surveys edited by Fiat and Woeginger [142], and the survey by Albers [14].\n\nThe move-to-front heuristic from Section 27.2 was analyzed by Sleator and Tarjan [416, 417] as part of their early work on amortized analysis. This rule works quite well in practice.\n\nCompetitive analysis of online caching also originated with Sleator and Tarjan [417]. The randomized marking algorithm was proposed and analyzed by Fiat et al. [141]. Young [464] surveys online caching and paging algorithms, and Buchbinder and Naor [76] survey primal-dual online algorithms.\n\nSpecific types of online algorithms are described using other names. _Dynamic graph algorithms_ are online algorithms on graphs, where at each step a vertex or edge undergoes modification. Typically a vertex or edge is either inserted or",
        "chapter": "Part VII Selected Topics",
        "section": "27 Online Algorithms",
        "subsection": "Problems",
        "subsubsection": "N/A"
    },
    {
        "content": "Consider the (offline) algorithm Completion-Time-Schedule.\n\nCompletion-Time-Schedule(\\(S\\))\n\n1 compute an optimal schedule for the preemptive version of the problem\n\n2 renumber the tasks so that the completion times in the optimal\n\npreemptive schedule are ordered by their completion times\n\n\\(C_{1}^{\\,P}<C_{2}^{\\,P}<\\cdots<C_{n}^{\\,P}\\) in SRPT order\n\n3 greedily schedule the tasks nonpreemptively in the renumbered\n\norder \\(a_{1},\\ldots,a_{n}\\)\n\n4 let \\(C_{1},\\ldots,C_{n}\\) be the completion times of renumbered tasks \\(a_{1},\\ldots,a_{n}\\)\n\nin this nonpreemptive schedule\n\n5 **return**\\(C_{1},\\ldots,C_{n}\\)\n\n_d._ Prove that \\(C_{i}^{\\,P}\\geq\\max\\left\\{\\sum_{j=1}^{i}\\,p_{j},\\max\\left\\{r_{j}:j\\leq i\\right\\}\\right\\}\\) for \\(i=1,\\ldots,n\\).\n\n_e._ Prove that \\(C_{i}\\leq\\max\\left\\{r_{j}:j\\leq i\\right\\}+\\sum_{j=1}^{i}\\,p_{j}\\) for \\(i=1,\\ldots,n\\).\n\n_f._ Algorithm Completion-Time-Schedule is an offline algorithm. Explain how to modify it to produce an online algorithm.\n\n_g._ Combine parts (c)-(f) to show that the online version of Completion-Time-Schedule is 2-competitive.\n\n## Chapter notes\n\nOnline algorithms are widely used in many domains. Some good overviews include the textbook by Borodin and El-Yaniv [68], the collection of surveys edited by Fiat and Woeginger [142], and the survey by Albers [14].\n\nThe move-to-front heuristic from Section 27.2 was analyzed by Sleator and Tarjan [416, 417] as part of their early work on amortized analysis. This rule works quite well in practice.\n\nCompetitive analysis of online caching also originated with Sleator and Tarjan [417]. The randomized marking algorithm was proposed and analyzed by Fiat et al. [141]. Young [464] surveys online caching and paging algorithms, and Buchbinder and Naor [76] survey primal-dual online algorithms.\n\nSpecific types of online algorithms are described using other names. _Dynamic graph algorithms_ are online algorithms on graphs, where at each step a vertex or edge undergoes modification. Typically a vertex or edge is either inserted or deleted, or some associated property, such as edge weight, changes. Some graph problems need to be solved again after each change to the graph, and a good dynamic graph algorithm will not need to solve from scratch. For example, edges are inserted and deleted, and after each change to the graph, the minimum spanning tree is recomputed. Exercise 21.2-8 asks such a question. Similar questions can be asked for other graph algorithms, such as shortest paths, connectivity, or matching. The first paper in this field is credited to Even and Shiloach [138], who study how to maintain a shortest-path tree as edges are being deleted from a graph. Since then hundreds of papers have been published. Demetrescu et al. [110] survey early developments in dynamic graph algorithms.\n\nFor massive data sets, the input data might be too large to store. _Streaming algorithms_ model this situation by requiring the memory used by an algorithm to be significantly smaller than the input size. For example, you may have a graph with \\(n\\) vertices and \\(m\\) edges with \\(m\\gg n\\), but the memory allowed may be only \\(O(n)\\). Or you may have \\(n\\) numbers, but the memory allowed may only be \\(O(\\lg n)\\) or \\(O(\\sqrt{n})\\). A streaming algorithm is measured by the number of passes made over the data in addition to the running time of the algorithm. McGregor [322] surveys streaming algorithms for graphs and Muthukrishnan [341] surveys general streaming algorithms.\n\n## Chapter 28 Matrix Operations\n\nBecause operations on matrices lie at the heart of scientific computing, efficient algorithms for working with matrices have many practical applications. This chapter focuses on how to multiply matrices and solve sets of simultaneous linear equations. Appendix D reviews the basics of matrices.\n\nSection 28.1 shows how to solve a set of linear equations using LUP decompositions. Then, Section 28.2 explores the close relationship between multiplying and inverting matrices. Finally, Section 28.3 discusses the important class of symmetric positive-definite matrices and shows how to use them to find a least-squares solution to an overdetermined set of linear equations.\n\nOne important issue that arises in practice is _numerical stability_. Because actual computers have limits to how precisely they can represent floating-point numbers, round-off errors in numerical computations may become amplified over the course of a computation, leading to incorrect results. Such computations are called _numerically unstable_. Although we'll briefly consider numerical stability on occasion, we won't focus on it in this chapter. We refer you to the excellent book by Higham [216] for a thorough discussion of stability issues.\n\n### 28.1 Solving systems of linear equations\n\nNumerous applications need to solve sets of simultaneous linear equations. A linear system can be cast as a matrix equation in which each matrix or vector element belongs to a field, typically the real numbers \\(\\mathbb{R}\\). This section discusses how to solve a system of linear equations using a method called LUP decomposition.\n\nThe process starts with a set of linear equations in \\(n\\) unknowns \\(x_{1},x_{2},\\ldots,x_{n}\\):",
        "chapter": "Part VII Selected Topics",
        "section": "27 Online Algorithms",
        "subsection": "Chapter notes",
        "subsubsection": "N/A"
    },
    {
        "content": "## Chapter 28 Matrix Operations\n\nBecause operations on matrices lie at the heart of scientific computing, efficient algorithms for working with matrices have many practical applications. This chapter focuses on how to multiply matrices and solve sets of simultaneous linear equations. Appendix D reviews the basics of matrices.\n\nSection 28.1 shows how to solve a set of linear equations using LUP decompositions. Then, Section 28.2 explores the close relationship between multiplying and inverting matrices. Finally, Section 28.3 discusses the important class of symmetric positive-definite matrices and shows how to use them to find a least-squares solution to an overdetermined set of linear equations.\n\nOne important issue that arises in practice is _numerical stability_. Because actual computers have limits to how precisely they can represent floating-point numbers, round-off errors in numerical computations may become amplified over the course of a computation, leading to incorrect results. Such computations are called _numerically unstable_. Although we'll briefly consider numerical stability on occasion, we won't focus on it in this chapter. We refer you to the excellent book by Higham [216] for a thorough discussion of stability issues.\n\n### 28.1 Solving systems of linear equations\n\nNumerous applications need to solve sets of simultaneous linear equations. A linear system can be cast as a matrix equation in which each matrix or vector element belongs to a field, typically the real numbers \\(\\mathbb{R}\\). This section discusses how to solve a system of linear equations using a method called LUP decomposition.\n\nThe process starts with a set of linear equations in \\(n\\) unknowns \\(x_{1},x_{2},\\ldots,x_{n}\\):\\[\\begin{array}{lcl}a_{11}x_{1}&+&a_{12}x_{2}&+&\\cdots&+&a_{1n}x_{n}&=&b_{1}\\,\\\\ a_{21}x_{1}&+&a_{22}x_{2}&+&\\cdots&+&a_{2n}x_{n}&=&b_{2}\\,\\\\ &&&&&\\vdots&\\\\ a_{n1}x_{1}&+&a_{n2}x_{2}&+&\\cdots&+&a_{nn}x_{n}&=&b_{n}\\.\\end{array} \\tag{28.1}\\]\n\nA _solution_ to the equations (28.1) is a set of values for \\(x_{1},x_{2},\\ldots,x_{n}\\) that satisfy all of the equations simultaneously. In this section, we treat only the case in which there are exactly \\(n\\) equations in \\(n\\) unknowns.\n\nNext, rewrite equations (28.1) as the matrix-vector equation\n\n\\[\\left(\\begin{array}{cccc}a_{11}&a_{12}&\\cdots&a_{1n}\\\\ a_{21}&a_{22}&\\cdots&a_{2n}\\\\ \\vdots&\\vdots&\\ddots&\\vdots\\\\ a_{n1}&a_{n2}&\\cdots&a_{nn}\\end{array}\\right)\\left(\\begin{array}{c}x_{1}\\\\ x_{2}\\\\ \\vdots\\\\ x_{n}\\end{array}\\right)=\\left(\\begin{array}{c}b_{1}\\\\ b_{2}\\\\ \\vdots\\\\ b_{n}\\end{array}\\right)\\]\n\nor, equivalently, letting \\(A=(a_{ij})\\), \\(x=(x_{i})\\), and \\(b=(b_{i})\\), as\n\n\\[Ax=b. \\tag{28.2}\\]\n\nIf \\(A\\) is nonsingular, it possesses an inverse \\(A^{-1}\\), and\n\n\\[x=A^{-1}b \\tag{28.3}\\]\n\nis the solution vector. We can prove that \\(x\\) is the unique solution to equation (28.2) as follows. If there are two solutions, \\(x\\) and \\(x^{\\prime}\\), then \\(Ax=Ax^{\\prime}=b\\) and, letting \\(I\\) denote an identity matrix,\n\n\\[\\begin{array}{lcl}x&=&I\\,x\\\\ &=&(A^{-1}A)x\\\\ &=&A^{-1}(Ax)\\\\ &=&A^{-1}(Ax^{\\prime})\\\\ &=&(A^{-1}A)x^{\\prime}\\\\ &=&I\\,x^{\\prime}\\\\ &=&x^{\\prime}\\.\\end{array}\\]\n\nThis section focuses on the case in which \\(A\\) is nonsingular or, equivalently (by Theorem D.1 on page 1220), the rank of \\(A\\) equals the number \\(n\\) of unknowns. There are other possibilities, however, which merit a brief discussion. If the number of equations is less than the number \\(n\\) of unknowns--or, more generally, if the rank of \\(A\\) is less than \\(n\\)--then the system is _underdetermined_. An underdetermined system typically has infinitely many solutions, although it may have no solutions at all if the equations are inconsistent. If the number of equations exceeds the number \\(n\\) of unknowns, the system is _overdetermined_, and there may not exist any solutions. Section 28.3 addresses the important problem of finding good approximate solutions to overdetermined systems of linear equations.\n\nLet's return to the problem of solving the system \\(Ax=b\\) of \\(n\\) equations in \\(n\\) unknowns. One option is to compute \\(A^{-1}\\) and then, using equation (28.3), multiply \\(b\\) by \\(A^{-1}\\), yielding \\(x=A^{-1}b\\). This approach suffers in practice from numerical instability. Fortunately, another approach--LUP decomposition--is numerically stable and has the further advantage of being faster in practice.\n\n##### Overview of LUP decomposition\n\nThe idea behind LUP decomposition is to find three \\(n\\times n\\) matrices \\(L\\), \\(U\\), and \\(P\\) such that\n\n\\[PA=LU, \\tag{28.4}\\]\n\nwhere\n\n* \\(L\\) is a unit lower-triangular matrix,\n* \\(U\\) is an upper-triangular matrix, and\n* \\(P\\) is a permutation matrix.\n\nWe call matrices \\(L\\), \\(U\\), and \\(P\\) satisfying equation (28.4) an _LUP decomposition_ of the matrix \\(A\\). We'll show that every nonsingular matrix \\(A\\) possesses such a decomposition.\n\nComputing an LUP decomposition for the matrix \\(A\\) has the advantage that linear systems can be efficiently solved when they are triangular, as is the case for both matrices \\(L\\) and \\(U\\). If you have an LUP decomposition for \\(A\\), you can solve equation (28.2), \\(Ax=b\\), by solving only triangular linear systems, as follows. Multiply both sides of \\(Ax=b\\) by \\(P\\), yielding the equivalent equation \\(PAx=Pb\\). By Exercise D.1-4 on page 1219, multiplying both sides by a permutation matrix amounts to permuting the equations (28.1). By the decomposition (28.4), substituting \\(LU\\) for \\(PA\\) gives\n\n\\[LUx=Pb\\]\n\nYou can now solve this equation by solving two triangular linear systems. Define \\(y=Ux\\), where \\(x\\) is the desired solution vector. First, solve the lower-triangular system\n\n\\[Ly=Pb \\tag{28.5}\\]\n\nfor the unknown vector \\(y\\) by a method called \"forward substitution.\" Having solved for \\(y\\), solve the upper-triangular system \\[Ux=y \\tag{28.6}\\]\n\nfor the unknown \\(x\\) by a method called \"back substitution.\" Why does this process solve \\(Ax=b\\)? Because the permutation matrix \\(P\\) is invertible (see Exercise D.2-3 on page 1223), multiplying both sides of equation (28.4) by \\(P^{-1}\\) gives \\(P^{-1}PA=P^{-1}LU\\), so that\n\n\\[A=P^{-1}LU. \\tag{28.7}\\]\n\nHence, the vector \\(x\\) that satisfies \\(Ux=y\\) is the solution to \\(Ax=b\\):\n\n\\[Ax =P^{-1}LUx\\quad\\mbox{(by equation (\\ref{eq:P1}))}\\] \\[=P^{-1}Ly\\quad\\quad\\mbox{(by equation (\\ref{eq:P1}))}\\] \\[=P^{-1}Pb\\quad\\quad\\mbox{(by equation (\\ref{eq:P1}))}\\] \\[=b\\.\\]\n\nThe next step is to show how forward and back substitution work and then attack the problem of computing the LUP decomposition itself.\n\n##### Forward and back substitution\n\n_Forward substitution_ can solve the lower-triangular system (28.5) in \\(\\Theta(n^{2})\\) time, given \\(L\\), \\(P\\), and \\(b\\). An array \\(\\pi[1:n]\\) provides a more compact format to represent the permutation \\(P\\) than an \\(n\\times n\\) matrix that is mostly \\(0\\)s. For \\(i=1,2,\\ldots,n\\), the entry \\(\\pi[i]\\) indicates that \\(P_{i,\\pi[i]}=1\\) and \\(P_{ij}=0\\) for \\(j\\neq\\pi[i]\\). Thus, \\(PA\\) has \\(a_{\\pi[i],j}\\) in row \\(i\\) and column \\(j\\), and \\(Pb\\) has \\(b_{\\pi[i]}\\) as its \\(i\\)th element. Since \\(L\\) is unit lower-triangular, the matrix equation \\(Ly=Pb\\) is equivalent to the \\(n\\) equations\n\n\\[y_{1} = b_{\\pi[1]}\\,\\] \\[l_{21}y_{1}+\\quad y_{2} = b_{\\pi[2]}\\,\\] \\[l_{31}y_{1}+l_{32}y_{2}+\\quad y_{3} = b_{\\pi[3]}\\,\\] \\[\\vdots\\] \\[l_{n1}y_{1}+l_{n2}y_{2}+l_{n3}y_{3}+\\cdots+y_{n} = b_{\\pi[n]}\\.\\]\n\nThe first equation gives \\(y_{1}=b_{\\pi[1]}\\) directly. Knowing the value of \\(y_{1}\\), you can substitute it into the second equation, yielding\n\n\\[y_{2}=b_{\\pi[2]}-l_{21}y_{1}\\.\\]\n\nNext, you can substitute both \\(y_{1}\\) and \\(y_{2}\\) into the third equation, obtaining\n\n\\[y_{3}=b_{\\pi[3]}-(l_{31}y_{1}+l_{32}y_{2})\\.\\]\n\nIn general, you substitute \\(y_{1}\\), \\(y_{2}\\), \\(\\ldots\\), \\(y_{i-1}\\) \"forward\" into the \\(i\\)th equation to solve for \\(y_{i}\\):\\[y_{i}=b_{\\pi[i]}-\\sum_{j=1}^{i-1}l_{ij}\\,y_{j}\\.\\]\n\nOnce you've solved for \\(y\\), you can solve for \\(x\\) in equation (28.6) using _back substitution_, which is similar to forward substitution. This time, you solve the \\(n\\)th equation first and work backward to the first equation. Like forward substitution, this process runs in \\(\\Theta(n^{2})\\) time. Since \\(U\\) is upper-triangular, the matrix equation \\(Ux=y\\) is equivalent to the \\(n\\) equations\n\n\\[u_{11}x_{1}\\,+\\,u_{12}x_{2}\\,+\\cdots+ u_{1,n-2}x_{n-2}\\,+ u_{1,n-1}x_{n-1}\\,+ u_{1n}x_{n}\\,=\\,\\,y_{1}\\,\\] \\[u_{22}x_{2}\\,+\\cdots+ u_{2,n-2}x_{n-2}\\,+ u_{2,n-1}x_{n-1}\\,+ u_{2n}x_{n}\\,=\\,\\,y_{2}\\,\\] \\[\\vdots\\] \\[u_{n-2,n-2}x_{n-2}\\,+ u_{n-2,n-1}x_{n-1}\\,+u_{n-2,n}x_{n}\\,=\\,\\,y_{n-2}\\,\\] \\[u_{n-1,n-1}x_{n-1}\\,+u_{n-1,n}x_{n}\\,=\\,\\,y_{n-1}\\,\\] \\[u_{n,n}x_{n}\\,=\\,\\,y_{n}\\.\\]\n\nThus, you can solve for \\(x_{n},x_{n-1},\\ldots,x_{1}\\) successively as follows:\n\n\\[x_{n}\\,=\\,\\,y_{n}/u_{n,n}\\,\\] \\[x_{n-1}\\,=\\,\\,(y_{n-1}-u_{n-1,n}x_{n})/u_{n-1,n-1}\\,\\] \\[x_{n-2}\\,=\\,\\,(y_{n-2}-(u_{n-2,n-1}x_{n-1}+u_{n-2,n}x_{n}))/u_{n- 2,n-2}\\,\\] \\[\\vdots\\]\n\nor, in general,\n\n\\[x_{i}=\\left(y_{i}-\\sum_{j=i+1}^{n}u_{ij}x_{j}\\right)/u_{i\\,i}\\.\\]\n\nGiven \\(P\\,,\\,L\\,,\\,U\\,,\\) and \\(b\\,,\\) the procedure LUP-Solve on the next page solves for \\(x\\) by combining forward and back substitution. The permutation matrix \\(P\\) is represented by the array \\(\\pi\\,.\\) The procedure first solves for \\(y\\) using forward substitution in lines 2-3, and then it solves for \\(x\\) using backward substitution in lines 4-5. Since the summation within each of the **for** loops includes an implicit loop, the running time is \\(\\Theta(n^{2})\\).\n\nAs an example of these methods, consider the system of linear equations defined by \\(Ax=b\\), where\n\n\\[A=\\left(\\begin{array}{ccc}1&2&0\\\\ 3&4&4\\\\ 5&6&3\\end{array}\\right)\\ \\mbox{and}\\ \\ b=\\left(\\begin{array}{c}3\\\\ 7\\\\ 8\\end{array}\\right),\\]\n\n\\begin{tabular}{l} LUP-Solve(\\(L,U,\\pi,b,n\\)) \\\\\n1 let \\(x\\) and \\(y\\) be new vectors of length \\(n\\) \\\\\n2 for\\(i\\ =\\ 1\\) to \\(n\\) \\\\\n3 \\(y_{i}\\ =\\ b_{\\pi[i]}-\\sum_{j=1}^{i-1}\\,l_{ij}\\,y_{j}\\) \\\\\n4 for\\(i\\ =\\ n\\) downto 1 \\\\\n5 \\(x_{i}\\ =\\ \\left(y_{i}-\\sum_{j=i+1}^{n}\\,u_{ij}x_{j}\\right)/u_{i\\,i}\\) \\\\\n6 return\\(x\\) \\\\ \\end{tabular} and we want to solve for the unknown \\(x\\). The LUP decomposition is\n\n\\[L=\\left(\\begin{array}{ccc}1&0&0\\\\ 0.2&1&0\\\\ 0.6&0.5&1\\end{array}\\right),\\ \\ U=\\left(\\begin{array}{ccc}5&6&3\\\\ 0&0.8&-0.6\\\\ 0&0&2.5\\end{array}\\right),\\ \\ \\mbox{and}\\ \\ P=\\left(\\begin{array}{ccc}0&0&1\\\\ 1&0&0\\\\ 0&1&0\\end{array}\\right).\\]\n\n(You might want to verify that \\(PA=LU\\).) Using forward substitution, solve \\(Ly=Pb\\) for \\(y\\):\n\n\\[\\left(\\begin{array}{ccc}1&0&0\\\\ 0.2&1&0\\\\ 0.6&0.5&1\\end{array}\\right)\\left(\\begin{array}{c}y_{1}\\\\ y_{2}\\\\ y_{3}\\end{array}\\right)=\\left(\\begin{array}{c}8\\\\ 3\\\\ 7\\end{array}\\right),\\]\n\nobtaining\n\n\\[y=\\left(\\begin{array}{c}8\\\\ 1.4\\\\ 1.5\\end{array}\\right)\\]\n\nby computing first \\(y_{1}\\), then \\(y_{2}\\), and finally \\(y_{3}\\). Then, using back substitution, solve \\(Ux=y\\) for \\(x\\):\n\n\\[\\left(\\begin{array}{ccc}5&6&3\\\\ 0&0.8&-0.6\\\\ 0&0&2.5\\end{array}\\right)\\left(\\begin{array}{c}x_{1}\\\\ x_{2}\\\\ x_{3}\\end{array}\\right)=\\left(\\begin{array}{c}8\\\\ 1.4\\\\ 1.5\\end{array}\\right),\\]\n\nthereby obtaining the desired answer\n\n\\[x=\\left(\\begin{array}{c}-1.4\\\\ 2.2\\\\ 0.6\\end{array}\\right)\\]\n\nby computing first \\(x_{3}\\), then \\(x_{2}\\), and finally \\(x_{1}\\).\n\n### Computing an LU decomposition\n\nGiven an LUP decomposition for a nonsingular matrix \\(A\\), you can use forward and back substitution to solve the system \\(Ax=b\\) of linear equations. Now let's seehow to efficiently compute an LUP decomposition for \\(A\\). We start with the simpler case in which \\(A\\) is an \\(n\\times n\\) nonsingular matrix and \\(P\\) is absent (or, equivalently, \\(P=I_{n}\\), the \\(n\\times n\\) identity matrix), so that \\(A=LU\\). We call the two matrices \\(L\\) and \\(U\\) an \\(LU\\)_decomposition_ of \\(A\\).\n\nTo create an LU decomposition, we'll use a process known as _Gaussian elimination_. Start by subtracting multiples of the first equation from the other equations in order to remove the first variable from those equations. Then subtract multiples of the second equation from the third and subsequent equations so that now the first and second variables are removed from them. Continue this process until the system that remains has an upper-triangular form--this is the matrix \\(U\\). The matrix \\(L\\) comprises the row multipliers that cause variables to be eliminated.\n\nTo implement this strategy, let's start with a recursive formulation. The input is an \\(n\\times n\\) nonsingular matrix \\(A\\). If \\(n=1\\), then nothing needs to be done: just choose \\(L=I_{1}\\) and \\(U=A\\). For \\(n>1\\), break \\(A\\) into four parts:\n\n\\[A = \\left(\\begin{array}{c|cc}a_{11}&a_{12}&\\cdots&a_{1n}\\\\ \\hline a_{21}&a_{22}&\\cdots&a_{2n}\\\\ \\vdots&\\vdots&\\ddots&\\vdots\\\\ a_{n1}&a_{n2}&\\cdots&a_{nn}\\end{array}\\right) \\tag{28.8}\\] \\[= \\left(\\begin{array}{cc}a_{11}&w^{\\rm T}\\\\ v&A^{\\prime}\\end{array}\\right),\\]\n\nwhere \\(v=(a_{21},a_{31},\\ldots,a_{n1})\\) is a column \\((n-1)\\)-vector, \\(w^{\\rm T}=(a_{12},a_{13},\\ldots,a_{1n})^{\\rm T}\\) is a row \\((n-1)\\)-vector, and \\(A^{\\prime}\\) is an \\((n-1)\\times(n-1)\\) matrix. Then, using matrix algebra (verify the equations by simply multiplying through), factor \\(A\\) as\n\n\\[A = \\left(\\begin{array}{cc}a_{11}&w^{\\rm T}\\\\ v&A^{\\prime}\\end{array}\\right) \\tag{28.9}\\] \\[= \\left(\\begin{array}{cc}1&0\\\\ v/a_{11}&I_{n-1}\\end{array}\\right)\\!\\!\\left(\\begin{array}{cc}a_{11}&w^{\\rm T }\\\\ 0&A^{\\prime}-vw^{\\rm T}/a_{11}\\end{array}\\right).\\]\n\nThe 0s in the first and second matrices of equation (28.9) are row and column \\((n-1)\\)-vectors, respectively. The term \\(vw^{\\rm T}/a_{11}\\) is an \\((n-1)\\times(n-1)\\) matrix formed by taking the outer product of \\(v\\) and \\(w\\) and dividing each element of the result by \\(a_{11}\\). Thus it conforms in size to the matrix \\(A^{\\prime}\\) from which it is subtracted. The resulting \\((n-1)\\times(n-1)\\) matrix\n\n\\[A^{\\prime}-vw^{\\rm T}/a_{11} \\tag{28.10}\\]\n\nis called the _Schur complement_ of \\(A\\) with respect to \\(a_{11}\\).\n\nWe claim that if \\(A\\) is nonsingular, then the Schur complement is nonsingular, too. Why? Suppose that the Schur complement, which is \\((n-1)\\times(n-1)\\), is singular. Then by Theorem D.1, it has row rank strictly less than \\(n-1\\). Because the bottom \\(n-1\\) entries in the first column of the matrix \\[\\left(\\begin{array}{cc}a_{11}&w^{\\rm T}\\\\ 0&A^{\\prime}-vw^{\\rm T}/a_{11}\\end{array}\\right)\\]\n\nare all \\(0\\), the bottom \\(n-1\\) rows of this matrix must have row rank strictly less than \\(n-1\\). The row rank of the entire matrix, therefore, is strictly less than \\(n\\). Applying Exercise D.2-8 on page 1223 to equation (28.9), \\(A\\) has rank strictly less than \\(n\\), and from Theorem D.1, we derive the contradiction that \\(A\\) is singular.\n\nBecause the Schur complement is nonsingular, it, too, has an LU decomposition, which we can find recursively. Let's say that\n\n\\[A^{\\prime}-vw^{\\rm T}/a_{11}=L^{\\prime}U^{\\prime}\\,\\]\n\nwhere \\(L^{\\prime}\\) is unit lower-triangular and \\(U^{\\prime}\\) is upper-triangular. The LU decomposition of \\(A\\) is then \\(A=LU\\), with\n\n\\[L=\\left(\\begin{array}{cc}1&0\\\\ v/a_{11}&L^{\\prime}\\end{array}\\right)\\ \\mbox{and}\\ \\ U=\\left(\\begin{array}{cc}a_{11}&w^{\\rm T }\\\\ 0&U^{\\prime}\\end{array}\\right)\\,,\\]\n\nas shown by\n\n\\[A = \\left(\\begin{array}{cc}1&0\\\\ v/a_{11}&I_{n-1}\\end{array}\\right)\\!\\left(\\begin{array}{cc}a_{11}&w^{\\rm T }\\\\ 0&A^{\\prime}-vw^{\\rm T}/a_{11}\\end{array}\\right)\\ \\ \\mbox{(by equation (\\ref{eq:L11}))}\\] \\[= \\left(\\begin{array}{cc}1&0\\\\ v/a_{11}&I_{n-1}\\end{array}\\right)\\!\\left(\\begin{array}{cc}a_{11}&w^{\\rm T }\\\\ 0&L^{\\prime}U^{\\prime}\\end{array}\\right)\\] \\[= \\left(\\begin{array}{cc}a_{11}&w^{\\rm T}\\\\ v&vw^{\\rm T}/a_{11}+L^{\\prime}U^{\\prime}\\end{array}\\right)\\] \\[= \\left(\\begin{array}{cc}1&0\\\\ v/a_{11}&L^{\\prime}\\end{array}\\right)\\!\\left(\\begin{array}{cc}a_{11}&w^{\\rm T }\\\\ 0&U^{\\prime}\\end{array}\\right)\\] \\[= LU.\\]\n\nBecause \\(L^{\\prime}\\) is unit lower-triangular, so is \\(L\\), and because \\(U^{\\prime}\\) is upper-triangular, so is \\(U\\).\n\nOf course, if \\(a_{11}=0\\), this method doesn't work, because it divides by \\(0\\). It also doesn't work if the upper leftmost entry of the Schur complement \\(A^{\\prime}-vw^{\\rm T}/a_{11}\\) is \\(0\\), since the next step of the recursion will divide by it. The denominators in each step of LU decomposition are called _pivots_, and they occupy the diagonal elements of the matrix \\(U\\). The permutation matrix \\(P\\) included in LUP decomposition provides a way to avoid dividing by \\(0\\), as we'll see below. Using permutations to avoid division by \\(0\\) (or by small numbers, which can contribute to numerical instability), is called _pivoting_.\n\nAn important class of matrices for which LU decomposition always works correctly is the class of symmetric positive-definite matrices. Such matrices require no pivoting to avoid dividing by \\(0\\) in the recursive strategy outlined above. We will prove this result, as well as several others, in Section 28.3.\n\n#### 28.1 Solving systems of linear equations\n\nThe pseudocode in the procedure LU-Decomposition follows the recursive strategy, except that an iteration loop replaces the recursion. (This transformation is a standard optimization for a \"tail-recursive\" procedure-- one whose last operation is a recursive call to itself. See Problem 7-5 on page 202.) The procedure initializes the matrix \\(U\\) with 0s below the diagonal and matrix \\(L\\) with 1s on its diagonal and 0s above the diagonal. Each iteration works on a square submatrix, using its upper leftmost element as the pivot to compute the \\(v\\) and \\(w\\) vectors and the Schur complement, which becomes the square submatrix worked on by the next iteration.\n\n```\nLU-Decomposition(\\(A,n\\))\n1 let \\(L\\) and \\(U\\) be new \\(n\\times n\\) matrices\n2 initialize \\(U\\) with 0s below the diagonal\n3 initialize \\(L\\) with 1s on the diagonal and 0s above the diagonal\n4for\\(k\\,=\\,1\\)to\\(n\\)\n5\\(u_{kk}\\,=\\,a_{kk}\\)\n6for\\(i\\,=\\,k\\,+\\,1\\)to\\(n\\)\n7\\(l_{i\\,k}\\,=\\,a_{i\\,k}/a_{kk}\\)\n8\\(u_{ki}\\,=\\,a_{ki}\\)\n9for\\(i\\,=\\,k\\,+\\,1\\)to\\(n\\)\n10for\\(j\\,=\\,k\\,+\\,1\\)to\\(n\\)\n11\\(a_{ij}\\,=\\,a_{ij}-l_{i\\,k}u_{kj}\\)\n12return\\(L\\) and \\(U\\)\n```\n\nEach recursive step in the description above takes place in one iteration of the outer **for** loop of lines 4-11. Within this loop, line 5 determines the pivot to be \\(u_{kk}=a_{kk}\\). The **for** loop in lines 6-8 (which does not execute when \\(k\\,=\\,n\\)) uses the \\(v\\) and \\(w\\) vectors to update \\(L\\) and \\(U\\). Line 7 determines the below-diagonal elements of \\(L\\), storing \\(v_{i}/a_{kk}\\) in \\(l_{i\\,k}\\), and line 8 computes the above-diagonal elements of \\(U\\), storing \\(w_{i}\\) in \\(u_{ki}\\). Finally, lines 9-11 compute the elements of the Schur complement and store them back into the matrix \\(A\\). (There is no need to divide by \\(a_{kk}\\) in line 11 because that already happened when line 7 computed \\(l_{i\\,k}\\).) Because line 11 is triply nested, LU-Decomposition runs in \\(\\Theta(n^{3})\\) time.\n\nFigure 28.1 illustrates the operation of LU-Decomposition. It shows a standard optimization of the procedure that stores the significant elements of \\(L\\) and \\(U\\) in place in the matrix \\(A\\). Each element \\(a_{ij}\\) corresponds to either \\(l_{ij}\\) (if \\(i\\,>\\,j\\)) or \\(u_{ij}\\) (if \\(i\\,\\leq\\,j\\)), so that the matrix \\(A\\) holds both \\(L\\) and \\(U\\) when the procedure terminates. To obtain the pseudocode for this optimization from the pseudocode for the LU-Decomposition procedure, just replace each reference to \\(l\\) or \\(u\\) by \\(a\\). You can verify that this transformation preserves correctness.\n\n### Computing an LUP decomposition\n\nIf the diagonal of the matrix given to LU-Decomposition contains any 0s, then the procedure will attempt to divide by 0, which would cause disaster. Even if the diagonal contains no 0s, but does have numbers with small absolute values, dividing by such numbers can cause numerical instabilities. Therefore, LUP decomposition pivots on entries with the largest absolute values that it can find.\n\nIn LUP decomposition, the input is an \\(n\\times n\\) nonsingular matrix \\(A\\), with a goal of finding a permutation matrix \\(P\\), a unit lower-triangular matrix \\(L\\), and an upper-triangular matrix \\(U\\) such that \\(PA=LU\\). Before partitioning the matrix \\(A\\), as LU decomposition does, LUP decomposition moves a nonzero element, say \\(a_{k1}\\), from somewhere in the first column to the \\((1,1)\\) position of the matrix. For the greatest numerical stability, LUP decomposition chooses the element in the first column with the greatest absolute value as \\(a_{k1}\\). (The first column cannot contain only 0s, for then \\(A\\) would be singular, because its determinant would be 0, by Theorems D.4 and D.5 on page 1221.) In order to preserve the set of equations, LUP decomposition exchanges row 1 with row \\(k\\), which is equivalent to multiplying \\(A\\) by a\n\nFigure 28.1: The operation of LU-Decomposition. **(a)** The matrix \\(A\\). **(b)** The result of the first iteration of the outer **for** loop of lines 4\u201311. The element \\(a_{11}=2\\) highlighted in blue is the pivot, the tan column is \\(v/a_{11}\\), and the tan row is \\(w^{\\rm T}\\). The elements of \\(U\\) computed thus far are above the horizontal line, and the elements of \\(L\\) are to the left of the vertical line. The Schur complement matrix \\(A^{\\prime}-vw^{\\rm T}/a_{11}\\) occupies the lower right. **(c)** The result of the next iteration of the outer **for** loop, on the Schur complement matrix from part (b). The element \\(a_{22}=4\\) highlighted in blue is the pivot, and the tan column and row are \\(v/a_{22}\\) and \\(w^{\\rm T}\\) (in the partitioning of the Schur complement), respectively. Lines divide the matrix into the elements of \\(U\\) computed so far (above), the elements of \\(L\\) computed so far (left), and the new Schur complement (lower right). **(d)** After the next iteration, the matrix \\(A\\) is factored. The element 3 in the new Schur complement becomes part of \\(U\\) when the recursion terminates.) **(e)** The factorization \\(A=LU\\).\n\npermutation matrix \\(Q\\) on the left (Exercise D.1-4 on page 1219). Thus, the analog to equation (28.8) expresses \\(QA\\) as\n\n\\[Q\\,A=\\left(\\begin{array}{cc}a_{k1}&w^{\\rm T}\\\\ v&A^{\\prime}\\end{array}\\right)\\,,\\]\n\nwhere \\(v=(a_{21},a_{31},\\ldots,a_{n1})\\), except that \\(a_{11}\\) replaces \\(a_{k1}\\); \\(w^{\\rm T}=(a_{k2},a_{k3},\\)\\(\\ldots,a_{kn})^{\\rm T}\\); and \\(A^{\\prime}\\) is an \\((n-1)\\times(n-1)\\) matrix. Since \\(a_{k1}\\neq 0\\), the analog to equation (28.9) guarantees no division by \\(0\\):\n\n\\[Q\\,A = \\left(\\begin{array}{cc}a_{k1}&w^{\\rm T}\\\\ v&A^{\\prime}\\end{array}\\right)\\] \\[= \\left(\\begin{array}{cc}1&0\\\\ v/a_{k1}&I_{n-1}\\end{array}\\right)\\!\\!\\left(\\begin{array}{cc}a_{k1}&w^{\\rm T }\\\\ 0&A^{\\prime}-v\\,w^{\\rm T}/a_{k1}\\end{array}\\right)\\,.\\]\n\nJust as in LU decomposition, if \\(A\\) is nonsingular, then the Schur complement \\(A^{\\prime}-vw^{\\rm T}/a_{k1}\\) is nonsingular, too. Therefore, you can recursively find an LUP decomposition for it, with unit lower-triangular matrix \\(L^{\\prime}\\), upper-triangular matrix \\(U^{\\prime}\\), and permutation matrix \\(P^{\\prime}\\), such that\n\n\\[P^{\\prime}(A^{\\prime}-vw^{\\rm T}/a_{k1})=L^{\\prime}U^{\\prime}\\.\\]\n\nDefine\n\n\\[P\\,=\\left(\\begin{array}{cc}1&0\\\\ 0&P^{\\prime}\\end{array}\\right)Q\\,\\]\n\nwhich is a permutation matrix, since it is the product of two permutation matrices (Exercise D.1-4 on page 1219). This definition of \\(P\\) gives\n\n\\[PA = \\left(\\begin{array}{cc}1&0\\\\ 0&P^{\\prime}\\end{array}\\right)\\!\\!Q\\,A\\] \\[= \\left(\\begin{array}{cc}1&0\\\\ 0&P^{\\prime}\\end{array}\\right)\\!\\!\\left(\\begin{array}{cc}1&0\\\\ v/a_{k1}&I_{n-1}\\end{array}\\right)\\!\\!\\left(\\begin{array}{cc}a_{k1}&w^{\\rm T }\\\\ 0&A^{\\prime}-vw^{\\rm T}/a_{k1}\\end{array}\\right)\\] \\[= \\left(\\begin{array}{cc}1&0\\\\ P^{\\prime}v/a_{k1}&P^{\\prime}\\end{array}\\right)\\!\\!\\left(\\begin{array}{cc}a_ {k1}&w^{\\rm T}\\\\ 0&A^{\\prime}-vw^{\\rm T}/a_{k1}\\end{array}\\right)\\] \\[= \\left(\\begin{array}{cc}1&0\\\\ P^{\\prime}v/a_{k1}&I_{n-1}\\end{array}\\right)\\!\\!\\left(\\begin{array}{cc}a_ {k1}&w^{\\rm T}\\\\ 0&P^{\\prime}(A^{\\prime}-vw^{\\rm T}/a_{k1})\\end{array}\\right)\\] \\[= \\left(\\begin{array}{cc}1&0\\\\ P^{\\prime}v/a_{k1}&I_{n-1}\\end{array}\\right)\\!\\!\\left(\\begin{array}{cc}a_ {k1}&w^{\\rm T}\\\\ 0&L^{\\prime}U^{\\prime}\\end{array}\\right)\\] \\[= \\left(\\begin{array}{cc}1&0\\\\ P^{\\prime}v/a_{k1}&L^{\\prime}\\end{array}\\right)\\!\\!\\left(\\begin{array}{cc}a_ {k1}&w^{\\rm T}\\\\ 0&U^{\\prime}\\end{array}\\right)\\] \\[= LU,\\]which yields the LUP decomposition. Because \\(L^{\\prime}\\) is unit lower-triangular, so is \\(L\\), and because \\(U^{\\prime}\\) is upper-triangular, so is \\(U\\).\n\nNotice that in this derivation, unlike the one for LU decomposition, both the column vector \\(v/a_{k1}\\) and the Schur complement \\(A^{\\prime}-vw^{\\mathrm{T}}/a_{k1}\\) are multiplied by the permutation matrix \\(P^{\\prime}\\). The procedure LUP-decomposition gives the pseudocode for LUP decomposition.\n\n\\(\\mathrm{LUP-Decomposition}(A,n)\\)\n\n let \\(\\pi[1:n]\\) be a new array\n\n for \\(i\\,=\\,1\\)to\\(n\\)\n\n \\(\\pi[i]\\,=\\,i\\)   // initialize \\(\\pi\\) to the identity permutation\n\n for \\(k\\,=\\,1\\)to\\(n\\)\n\n \\(p\\,=\\,0\\)\n\n for \\(i\\,=\\,k\\)to\\(n\\)   // find largest absolute value in column \\(k\\)\n\n if \\(|a_{ik}|\\,>\\,p\\)\n\n \\(p\\,=\\,|a_{ik}|\\)\n\n \\(k^{\\prime}\\,=\\,i\\)   // row number of the largest found so far\n\n if \\(p\\,==\\,0\\)\n\n \\(\\mathrm{error}\\) \"singular matrix\"\n\n exchange \\(\\pi[k]\\) with \\(\\pi[k^{\\prime}]\\)\n\n for \\(i\\,=\\,1\\)to\\(n\\)\n\n exchange \\(a_{ki}\\) with \\(a_{k^{\\prime}i}\\)   // exchange rows \\(k\\) and \\(k^{\\prime}\\)\n\n for \\(i\\,=\\,k\\,+\\,1\\)to\\(n\\)\n\n \\(a_{ik}\\,=\\,a_{ik}/a_{kk}\\)\n\n for \\(j\\,=\\,k\\,+\\,1\\)to\\(n\\)\n\n \\(a_{ij}\\,=\\,a_{ij}-a_{ik}a_{kj}\\)   // compute \\(L\\) and \\(U\\) in place in \\(A\\)\n\nLike LU-Decomposition, the LUP-Decomposition procedure replaces the recursion with an iteration loop. As an improvement over a direct implementation of the recursion, the procedure dynamically maintains the permutation matrix \\(P\\) as an array \\(\\pi\\), where \\(\\pi[i]\\,=\\,j\\) means that the \\(i\\)th row of \\(P\\) contains a \\(1\\) in column \\(j\\). The LUP-Decomposition procedure also implements the improvement mentioned earlier, computing \\(L\\) and \\(U\\) in place in the matrix \\(A\\). Thus, when the procedure terminates,\n\n\\[a_{ij}\\,=\\,\\left\\{\\begin{array}{ll}l_{ij}&\\mbox{if $i\\,>\\,j$}\\,\\\\ u_{ij}&\\mbox{if $i\\,\\leq\\,j$}\\.\\end{array}\\right.\\]\n\nFigure 28.2 illustrates how LUP-Decomposition factors a matrix. Lines 2-3 initialize the array \\(\\pi\\) to represent the identity permutation. The outer **for** loop of lines 4-18 implements the recursion, finding an LUP decomposition of\n\n#### Solving systems of linear equations\n\nThe equation of LUP-Decomposition.**(a)** The input matrix \\(A\\) with the identity permutation of the rows in yellow on the left. The first step of the algorithm determines that the element 5 highlighted in blue in the third row is the pivot for the first column. **(b)** Rows 1 and 3 are swapped and the permutation is updated. The tan column and row represent \\(v\\) and \\(w^{\\mathrm{T}}\\). **(c)** The vector \\(v\\) is replaced by \\(v/5\\), and the lower right of the matrix is updated with the Schur complement. Lines divide the matrix into three regions: elements of \\(U\\) (above), elements of \\(L\\) (left), and elements of the Schur complement (lower right). **(d)-(f)** The second step. **(g)-(i)** The third step. No further changes occur on the fourth (final) step. **(j)** The LUP decomposition \\(PA=LU\\).\n\nFigure 28.2: The operation of LUP-Decomposition. **(a)** The input matrix \\(A\\) with the identity permutation of the rows in yellow on the left. The first step of the algorithm determines that the element 5 highlighted in blue in the third row is the pivot for the first column. **(b)** Rows 1 and 3 are swapped and the permutation is updated. The tan column and row represent \\(v\\) and \\(w^{\\mathrm{T}}\\). **(c)** The vector \\(v\\) is replaced by \\(v/5\\), and the lower right of the matrix is updated with the Schur complement. Lines divide the matrix into three regions: elements of \\(U\\) (above), elements of \\(L\\) (left), and elements of the Schur complement (lower right). **(d)-(f)** The second step. **(g)-(i)** The third step. No further changes occur on the fourth (final) step. **(j)** The LUP decomposition \\(PA=LU\\).\n\nthe \\((n-k+1)\\times(n-k+1)\\) submatrix whose upper left is in row \\(k\\) and column \\(k\\). Each time through the outer loop, lines 5-9 determine the element \\(a_{k^{\\prime}k}\\) with the largest absolute value of those in the current first column (column \\(k\\)) of the \\((n-k+1)\\times(n-k+1)\\) submatrix that the procedure is currently working on. If all elements in the current first column are 0, lines 10-11 report that the matrix is singular. To pivot, line 12 exchanges \\(\\pi[k^{\\prime}]\\) with \\(\\pi[k]\\), and lines 13-14 exchange the \\(k\\)th and \\(k^{\\prime}\\)th rows of \\(A\\), thereby making the pivot element \\(a_{kk}\\). (The entire rows are swapped because in the derivation of the method above, not only is \\(A^{\\prime}-vw^{\\mathrm{T}}/a_{k1}\\) multiplied by \\(P^{\\prime}\\), but so is \\(v/a_{k1}\\).) Finally, the Schur complement is computed by lines 15-18 in much the same way as it is computed by lines 6-11 of LU-Decomposition, except that here the operation is written to work in place.\n\nBecause of its triply nested loop structure, LUP-Decomposition has a running time of \\(\\Theta(n^{3})\\), which is the same as that of LU-Decomposition. Thus, pivoting costs at most a constant factor in time.\n\n##### Exercises\n\n##### 28.1-1\n\nSolve the equation\n\n\\[\\left(\\begin{array}{rr}1&0&0\\\\ 4&1&0\\\\ -6&5&1\\end{array}\\right)\\left(\\begin{array}{c}x_{1}\\\\ x_{2}\\\\ x_{3}\\end{array}\\right)=\\left(\\begin{array}{c}3\\\\ 14\\\\ -7\\end{array}\\right)\\]\n\nby using forward substitution.\n\n##### 28.1-2\n\nFind an LU decomposition of the matrix\n\n\\[\\left(\\begin{array}{rr}4&-5&6\\\\ 8&-6&7\\\\ 12&-7&12\\end{array}\\right).\\]\n\n##### 28.1-3\n\nSolve the equation\n\n\\[\\left(\\begin{array}{rr}1&5&4\\\\ 2&0&3\\\\ 5&8&2\\end{array}\\right)\\left(\\begin{array}{c}x_{1}\\\\ x_{2}\\\\ x_{3}\\end{array}\\right)=\\left(\\begin{array}{c}12\\\\ 9\\\\ 5\\end{array}\\right)\\]\n\nby using an LUP decomposition.\n\n##### 28.1-4\n\nDescribe the LUP decomposition of a diagonal matrix.\n\n#### 28.1-5\n\nDescribe the LUP decomposition of a permutation matrix, and prove that it is unique.\n\n#### 28.1-6\n\nShow that for all \\(n\\geq 1\\), there exists a singular \\(n\\times n\\) matrix that has an LU decomposition.\n\n#### 28.1-7\n\nIn LU-Decomposition, is it necessary to perform the outermost **for** loop iteration when \\(k=n\\)? How about in LUP-Decomposition?\n\n#### 28.2 Inverting matrices\n\nAlthough you can use equation (28.3) to solve a system of linear equations by computing a matrix inverse, in practice you are better off using more numerically stable techniques, such as LUP decomposition. Sometimes, however, you really do need to compute a matrix inverse. This section shows how to use LUP decomposition to compute a matrix inverse. It also proves that matrix multiplication and computing the inverse of a matrix are equivalently hard problems, in that (subject to technical conditions) an algorithm for one can solve the other in the same asymptotic running time. Thus, you can use Strassen's algorithm (see Section 4.2) for matrix multiplication to invert a matrix. Indeed, Strassen's original paper was motivated by the idea that a set of a linear equations could be solved more quickly than by the usual method.\n\n#### Computing a matrix inverse from an LUP decomposition\n\nSuppose that you have an LUP decomposition of a matrix \\(A\\) in the form of three matrices \\(L\\), \\(U\\), and \\(P\\) such that \\(PA=LU\\). Using LUP-Solve, you can solve an equation of the form \\(Ax=b\\) in \\(\\Theta(n^{2})\\) time. Since the LUP decomposition depends on \\(A\\) but not \\(b\\), you can run LUP-Solve on a second set of equations of the form \\(Ax=b^{\\prime}\\) in \\(\\Theta(n^{2})\\) additional time. In general, once you have the LUP decomposition of \\(A\\), you can solve, in \\(\\Theta(k\\,n^{2})\\) time, \\(k\\) versions of the equation \\(Ax=b\\) that differ only in the vector \\(b\\).\n\nLet's think of the equation\n\n\\[Ax=I_{n}\\, \\tag{28.11}\\]\n\nwhich defines the matrix \\(X\\), the inverse of \\(A\\), as a set of \\(n\\) distinct equations of the form \\(Ax=b\\). To be precise, let \\(X_{i}\\) denote the \\(i\\)th column of \\(X\\), and recall that the",
        "chapter": "Part VII Selected Topics",
        "section": "28 Matrix Operations",
        "subsection": "28.1 Solving systems of linear equations",
        "subsubsection": "N/A"
    },
    {
        "content": "#### 28.1-5\n\nDescribe the LUP decomposition of a permutation matrix, and prove that it is unique.\n\n#### 28.1-6\n\nShow that for all \\(n\\geq 1\\), there exists a singular \\(n\\times n\\) matrix that has an LU decomposition.\n\n#### 28.1-7\n\nIn LU-Decomposition, is it necessary to perform the outermost **for** loop iteration when \\(k=n\\)? How about in LUP-Decomposition?\n\n#### 28.2 Inverting matrices\n\nAlthough you can use equation (28.3) to solve a system of linear equations by computing a matrix inverse, in practice you are better off using more numerically stable techniques, such as LUP decomposition. Sometimes, however, you really do need to compute a matrix inverse. This section shows how to use LUP decomposition to compute a matrix inverse. It also proves that matrix multiplication and computing the inverse of a matrix are equivalently hard problems, in that (subject to technical conditions) an algorithm for one can solve the other in the same asymptotic running time. Thus, you can use Strassen's algorithm (see Section 4.2) for matrix multiplication to invert a matrix. Indeed, Strassen's original paper was motivated by the idea that a set of a linear equations could be solved more quickly than by the usual method.\n\n#### Computing a matrix inverse from an LUP decomposition\n\nSuppose that you have an LUP decomposition of a matrix \\(A\\) in the form of three matrices \\(L\\), \\(U\\), and \\(P\\) such that \\(PA=LU\\). Using LUP-Solve, you can solve an equation of the form \\(Ax=b\\) in \\(\\Theta(n^{2})\\) time. Since the LUP decomposition depends on \\(A\\) but not \\(b\\), you can run LUP-Solve on a second set of equations of the form \\(Ax=b^{\\prime}\\) in \\(\\Theta(n^{2})\\) additional time. In general, once you have the LUP decomposition of \\(A\\), you can solve, in \\(\\Theta(k\\,n^{2})\\) time, \\(k\\) versions of the equation \\(Ax=b\\) that differ only in the vector \\(b\\).\n\nLet's think of the equation\n\n\\[Ax=I_{n}\\, \\tag{28.11}\\]\n\nwhich defines the matrix \\(X\\), the inverse of \\(A\\), as a set of \\(n\\) distinct equations of the form \\(Ax=b\\). To be precise, let \\(X_{i}\\) denote the \\(i\\)th column of \\(X\\), and recall that theunit vector \\(e_{i}\\) is the \\(i\\)th column of \\(I_{n}\\). You can then solve equation (28.11) for \\(X\\) by using the LUP decomposition for \\(A\\) to solve each equation\n\n\\(AX_{i}=e_{i}\\)\n\nseparately for \\(X_{i}\\). Once you have the LUP decomposition, you can compute each of the \\(n\\) columns \\(X_{i}\\) in \\(\\Theta(n^{2})\\) time, and so you can compute \\(X\\) from the LUP decomposition of \\(A\\) in \\(\\Theta(n^{3})\\) time. Since you find the LUP decomposition of \\(A\\) in \\(\\Theta(n^{3})\\) time, you can compute the inverse \\(A^{-1}\\) of a matrix \\(A\\) in \\(\\Theta(n^{3})\\) time.\n\n#### Matrix multiplication and matrix inversion\n\nNow let's see how the theoretical speedups obtained for matrix multiplication translate to speedups for matrix inversion. In fact, we'll prove something stronger: matrix inversion is equivalent to matrix multiplication, in the following sense. If \\(M(n)\\) denotes the time to multiply two \\(n\\times n\\) matrices, then a nonsingular \\(n\\times n\\) matrix can be inverted in \\(O(M(n))\\) time. Moreover, if \\(I(n)\\) denotes the time to invert a nonsingular \\(n\\times n\\) matrix, then two \\(n\\times n\\) matrices can be multiplied in \\(O(I(n))\\) time. We prove these results as two separate theorems.\n\n**Theorem 28.1** (Multiplication is no harder than inversion): _If an \\(n\\times n\\) matrix can be inverted in \\(I(n)\\) time, where \\(I(n)=\\Omega(n^{2})\\) and \\(I(n)\\) satisfies the regularity condition \\(I(3n)=O(I(n))\\), then two \\(n\\times n\\) matrices can be multiplied in \\(O(I(n))\\) time._\n\n_Proof_ Let \\(A\\) and \\(B\\) be \\(n\\times n\\) matrices. To compute their product \\(C=AB\\), define the \\(3n\\times 3n\\) matrix \\(D\\) by\n\n\\(D=\\left(\\begin{array}{ccc}I_{n}&A&0\\\\ 0&I_{n}&B\\\\ 0&0&I_{n}\\end{array}\\right).\\)\n\nThe inverse of \\(D\\) is\n\n\\(D^{-1}=\\left(\\begin{array}{ccc}I_{n}&-A&AB\\\\ 0&I_{n}&-B\\\\ 0&0&I_{n}\\end{array}\\right),\\)\n\nand thus to compute the product \\(AB\\), just take the upper right \\(n\\times n\\) submatrix of \\(D^{-1}\\).\n\nConstructing matrix \\(D\\) takes \\(\\Theta(n^{2})\\) time, which is \\(O(I(n))\\) from the assumption that \\(I(n)=\\Omega(n^{2})\\), and inverting \\(D\\) takes \\(O(I(3n))=O(I(n))\\) time, by the regularity condition on \\(I(n)\\). We thus have \\(M(n)=O(I(n))\\).\n\nNote that \\(I(n)\\) satisfies the regularity condition whenever \\(I(n)=\\Theta(n^{c}\\lg^{d}n)\\) for any constants \\(c>0\\) and \\(d\\geq 0\\).\n\n### 28.2 Inverting matrices\n\nThe proof that matrix inversion is no harder than matrix multiplication relies on some properties of symmetric positive-definite matrices proved in Section 28.3.\n\n_Theorem 28.2 (Inversion is no harder than multiplication)_\n\nSuppose that two \\(n\\times n\\) real matrices can be multiplied in \\(M(n)\\) time, where \\(M(n)=\\Omega(n^{2})\\) and \\(M(n)\\) satisfies the following two regularity conditions:\n\n1. \\(M(n+k)=O(M(n))\\) for any \\(k\\) in the range \\(0\\leq k<n\\), and\n2. \\(M(n/2)\\leq c\\,M(n)\\) for some constant \\(c<1/2\\).\n\nThen the inverse of any real nonsingular \\(n\\times n\\) matrix can be computed in \\(O(M(n))\\) time.\n\n_Proof_ Let \\(A\\) be an \\(n\\times n\\) matrix with real-valued entries that is nonsingular. Assume that \\(n\\) is an exact power of 2 (i.e., \\(n=2^{l}\\) for some integer \\(l\\)); we'll see at the end of the proof what to do if \\(n\\) is not an exact power of 2.\n\nFor the moment, assume that the \\(n\\times n\\) matrix \\(A\\) is symmetric and positive-definite. Partition each of \\(A\\) and its inverse \\(A^{-1}\\) into four \\(n/2\\times n/2\\) submatrices:\n\n\\[A=\\left(\\begin{array}{cc}B&C^{\\rm T}\\\\ C&D\\end{array}\\right)\\ \\mbox{and}\\ \\ A^{-1}=\\left(\\begin{array}{cc}R&T\\\\ U&V\\end{array}\\right)\\,. \\tag{28.12}\\]\n\nThen, if we let\n\n\\[S=D-CB^{-1}C^{\\rm T} \\tag{28.13}\\]\n\nbe the Schur complement of \\(A\\) with respect to \\(B\\) (we'll see more about this form of Schur complement in Section 28.3), we have\n\n\\[A^{-1}=\\left(\\begin{array}{cc}R&T\\\\ U&V\\end{array}\\right)=\\left(\\begin{array}{cc}B^{-1}+B^{-1}C^{\\rm T}S^{-1}CB^{- 1}&-B^{-1}C^{\\rm T}S^{-1}\\\\ -S^{-1}CB^{-1}&S^{-1}\\end{array}\\right)\\,, \\tag{28.14}\\]\n\nsince \\(AA^{-1}=I_{n}\\), as you can verify by performing the matrix multiplication. Because \\(A\\) is symmetric and positive-definite, Lemmas 28.4 and 28.5 in Section 28.3 imply that \\(B\\) and \\(S\\) are both symmetric and positive-definite. By Lemma 28.3 in Section 28.3, therefore, the inverses \\(B^{-1}\\) and \\(S^{-1}\\) exist, and by Exercise D.2-6 on page 1223, \\(B^{-1}\\) and \\(S^{-1}\\) are symmetric, so that \\((B^{-1})^{\\rm T}=B^{-1}\\) and \\((S^{-1})^{\\rm T}=S^{-1}\\). Therefore, to compute the submatrices\n\n\\[R = B^{-1}+B^{-1}C^{\\rm T}S^{-1}CB^{-1}\\,\\] \\[T = -B^{-1}C^{\\rm T}S^{-1}\\,\\] \\[U = -S^{-1}CB^{-1}\\,\\ \\mbox{ and}\\] \\[V = S^{-1}\\]\n\nof \\(A^{-1}\\), do the following, where all matrices mentioned are \\(n/2\\times n/2\\):1. Form the submatrices \\(B\\), \\(C\\), \\(C^{\\rm T}\\), and \\(D\\) of \\(A\\).\n2. Recursively compute the inverse \\(B^{-1}\\) of \\(B\\).\n3. Compute the matrix product \\(W=CB^{-1}\\), and then compute its transpose \\(W^{\\rm T}\\), which equals \\(B^{-1}C^{\\rm T}\\) (by Exercise D.1-2 on page 1219 and \\((B^{-1})^{\\rm T}=B^{-1}\\)).\n4. Compute the matrix product \\(X=WC^{\\rm T}\\), which equals \\(CB^{-1}C^{\\rm T}\\), and then compute the matrix \\(S=D-X=D-CB^{-1}C^{\\rm T}\\).\n5. Recursively compute the inverse \\(S^{-1}\\) of \\(S\\).\n6. Compute the matrix product \\(Y=S^{-1}W\\), which equals \\(S^{-1}CB^{-1}\\), and then compute its transpose \\(Y^{\\rm T}\\), which equals \\(B^{-1}C^{\\rm T}S^{-1}\\) (by Exercise D.1-2, \\((B^{-1})^{\\rm T}=B^{-1}\\), and \\((S^{-1})^{\\rm T}=S^{-1}\\)).\n7. Compute the matrix product \\(Z=W^{\\rm T}Y\\), which equals \\(B^{-1}C^{\\rm T}S^{-1}CB^{-1}\\).\n8. Set \\(R=B^{-1}+Z\\).\n9. Set \\(T=-Y^{\\rm T}\\).\n10. Set \\(U=-Y\\).\n11. Set \\(V=S^{-1}\\).\n\nThus, to invert an \\(n\\times n\\) symmetric positive-definite matrix, invert two \\(n/2\\times n/2\\) matrices in steps 2 and 5; perform four multiplications of \\(n/2\\times n/2\\) matrices in steps 3, 4, 6, and 7; plus incur an additional cost of \\(O(n^{2})\\) for extracting submatrices from \\(A\\), inserting submatrices into \\(A^{-1}\\), and performing a constant number of additions, subtractions, and transposes on \\(n/2\\times n/2\\) matrices. The running time is given by the recurrence\n\n\\[\\begin{array}{l}I(n)\\ \\leq\\ 2I(n/2)+4M(n/2)+O(n^{2})\\\\\\(A^{-1}=(A^{\\rm T}A)^{-1}A^{\\rm T}\\),\n\nsince \\(((A^{\\rm T}A)^{-1}A^{\\rm T})A=(A^{\\rm T}A)^{-1}(A^{\\rm T}A)=I_{n}\\) and a matrix inverse is unique. Therefore, to compute \\(A^{-1}\\), first multiply \\(A^{\\rm T}\\) by \\(A\\) to obtain \\(A^{\\rm T}A\\), then invert the symmetric positive-definite matrix \\(A^{\\rm T}A\\) using the above divide-and-conquer algorithm, and finally multiply the result by \\(A^{\\rm T}\\). Each of these three steps takes \\(O(M(n))\\) time, and thus any nonsingular matrix with real entries can be inverted in \\(O(M(n))\\) time.\n\nThe above proof assumed that \\(A\\) is an \\(n\\times n\\) matrix, where \\(n\\) is an exact power of 2. If \\(n\\) is not an exact power of 2, then let \\(k<n\\) be such that \\(n+k\\) is an exact power of 2, and define the \\((n+k)\\times(n+k)\\) matrix \\(A^{\\prime}\\) as\n\n\\(A^{\\prime}=\\left(\\begin{array}{cc}A&0\\\\ 0&I_{k}\\end{array}\\right).\\)\n\nThen the inverse of \\(A^{\\prime}\\) is\n\n\\(\\left(\\begin{array}{cc}A&0\\\\ 0&I_{k}\\end{array}\\right)^{-1}=\\left(\\begin{array}{cc}A^{-1}&0\\\\ 0&I_{k}\\end{array}\\right),\\)\n\nApply the method of the proof to \\(A^{\\prime}\\) to compute the inverse of \\(A^{\\prime}\\), and take the first \\(n\\) rows and \\(n\\) columns of the result as the desired answer \\(A^{-1}\\). The first regularity condition on \\(M(n)\\) ensures that enlarging the matrix in this way increases the running time by at most a constant factor.\n\nThe proof of Theorem 28.2 suggests how to solve the equation \\(Ax=b\\) by using LU decomposition without pivoting, so long as \\(A\\) is nonsingular. Let \\(y=A^{\\rm T}b\\). Multiply both sides of the equation \\(Ax=b\\) by \\(A^{\\rm T}\\), yielding \\((A^{\\rm T}A)x=A^{\\rm T}b=y\\). This transformation doesn't affect the solution \\(x\\), since \\(A^{\\rm T}\\) is invertible. Because \\(A^{\\rm T}A\\) is symmetric positive-definite, it can be factored by computing an LU decomposition. Then, use forward and back substitution to solve for \\(x\\) in the equation \\((A^{\\rm T}A)x=y\\). Although this method is theoretically correct, in practice the procedure LUP-Decomposition works much better. LUP decomposition requires fewer arithmetic operations by a constant factor, and it has somewhat better numerical properties.\n\nExercises\n\n#### 28.2-1\n\nLet \\(M(n)\\) be the time to multiply two \\(n\\times n\\) matrices, and let \\(S(n)\\) denote the time required to square an \\(n\\times n\\) matrix. Show that multiplying and squaring matrices have essentially the same difficulty: an \\(M(n)\\)-time matrix-multiplication algorithm implies an \\(O(M(n))\\)-time squaring algorithm, and an \\(S(n)\\)-time squaring algorithm implies an \\(O(S(n))\\)-time matrix-multiplication algorithm.\n\n#### 28.2-2\n\nLet \\(M(n)\\) be the time to multiply two \\(n\\times n\\) matrices. Show that an \\(M(n)\\)-time matrix-multiplication algorithm implies an \\(O(M(n))\\)-time LUP-decomposition algorithm. (The LUP decomposition your method produces need not be the same as the result produced by the LUP-Decomposition procedure.)\n\n#### 28.2-3\n\nLet \\(M(n)\\) be the time to multiply two \\(n\\times n\\) boolean matrices, and let \\(T(n)\\) be the time to find the transitive closure of an \\(n\\times n\\) boolean matrix. (See Section 23.2.) Show that an \\(M(n)\\)-time boolean matrix-multiplication algorithm implies an \\(O(M(n)\\lg n)\\)-time transitive-closure algorithm, and a \\(T(n)\\)-time transitive-closure algorithm implies an \\(O(T(n))\\)-time boolean matrix-multiplication algorithm.\n\n#### 28.2-4\n\nDoes the matrix-inversion algorithm based on Theorem 28.2 work when matrix elements are drawn from the field of integers modulo 2? Explain.\n\n* _28.2-5_ Generalize the matrix-inversion algorithm of Theorem 28.2 to handle matrices of complex numbers, and prove that your generalization works correctly. (_Hint:_ Instead of the transpose of \\(A\\), use the _conjugate transpose_\\(A^{*}\\), which you obtain from the transpose of \\(A\\) by replacing every entry with its complex conjugate. Instead of symmetric matrices, consider _Hermitian_ matrices, which are matrices \\(A\\) such that \\(A=A^{*}\\).)\n\n### 28.3 Symmetric positive-definite matrices and least-squares approximation\n\nSymmetric positive-definite matrices have many interesting and desirable properties. An \\(n\\times n\\) matrix \\(A\\) is _symmetric positive-definite_ if \\(A=A^{\\rm T}\\) (\\(A\\) is symmetric) and \\(x^{\\rm T}Ax>0\\) for all \\(n\\)-vectors \\(x\\neq 0\\) (\\(A\\) is positive-definite). Symmetric positive-definite matrices are nonsingular, and an LU decomposition on them will not divide by 0. This section proves these and several other important properties of symmetric positive-definite matrices. We'll also see an interesting application to curve fitting by a least-squares approximation.\n\nThe first property we prove is perhaps the most basic.\n\n**Lemma 28.3**: Any positive-definite matrix is nonsingular.",
        "chapter": "Part VII Selected Topics",
        "section": "28 Matrix Operations",
        "subsection": "28.2 Inverting matrices",
        "subsubsection": "N/A"
    },
    {
        "content": "#### 28.2-2\n\nLet \\(M(n)\\) be the time to multiply two \\(n\\times n\\) matrices. Show that an \\(M(n)\\)-time matrix-multiplication algorithm implies an \\(O(M(n))\\)-time LUP-decomposition algorithm. (The LUP decomposition your method produces need not be the same as the result produced by the LUP-Decomposition procedure.)\n\n#### 28.2-3\n\nLet \\(M(n)\\) be the time to multiply two \\(n\\times n\\) boolean matrices, and let \\(T(n)\\) be the time to find the transitive closure of an \\(n\\times n\\) boolean matrix. (See Section 23.2.) Show that an \\(M(n)\\)-time boolean matrix-multiplication algorithm implies an \\(O(M(n)\\lg n)\\)-time transitive-closure algorithm, and a \\(T(n)\\)-time transitive-closure algorithm implies an \\(O(T(n))\\)-time boolean matrix-multiplication algorithm.\n\n#### 28.2-4\n\nDoes the matrix-inversion algorithm based on Theorem 28.2 work when matrix elements are drawn from the field of integers modulo 2? Explain.\n\n* _28.2-5_ Generalize the matrix-inversion algorithm of Theorem 28.2 to handle matrices of complex numbers, and prove that your generalization works correctly. (_Hint:_ Instead of the transpose of \\(A\\), use the _conjugate transpose_\\(A^{*}\\), which you obtain from the transpose of \\(A\\) by replacing every entry with its complex conjugate. Instead of symmetric matrices, consider _Hermitian_ matrices, which are matrices \\(A\\) such that \\(A=A^{*}\\).)\n\n### 28.3 Symmetric positive-definite matrices and least-squares approximation\n\nSymmetric positive-definite matrices have many interesting and desirable properties. An \\(n\\times n\\) matrix \\(A\\) is _symmetric positive-definite_ if \\(A=A^{\\rm T}\\) (\\(A\\) is symmetric) and \\(x^{\\rm T}Ax>0\\) for all \\(n\\)-vectors \\(x\\neq 0\\) (\\(A\\) is positive-definite). Symmetric positive-definite matrices are nonsingular, and an LU decomposition on them will not divide by 0. This section proves these and several other important properties of symmetric positive-definite matrices. We'll also see an interesting application to curve fitting by a least-squares approximation.\n\nThe first property we prove is perhaps the most basic.\n\n_Lemma 28.3_ Any positive-definite matrix is nonsingular.\n\n_Proof_ Suppose that a matrix \\(A\\) is singular. Then by Corollary D.3 on page 1221, there exists a nonzero vector \\(x\\) such that \\(Ax=0\\). Hence, \\(x^{\\rm T}Ax=0\\), and \\(A\\) cannot be positive-definite.\n\nThe proof that an LU decomposition on a symmetric positive-definite matrix \\(A\\) won't divide by \\(0\\) is more involved. We begin by proving properties about certain submatrices of \\(A\\). Define the \\(k\\)th _leading submatrix_ of \\(A\\) to be the matrix \\(A_{k}\\) consisting of the intersection of the first \\(k\\) rows and first \\(k\\) columns of \\(A\\).\n\n**Lemma 28.4**: _If \\(A\\) is a symmetric positive-definite matrix, then every leading submatrix of \\(A\\) is symmetric and positive-definite._\n\n_Proof_ Since \\(A\\) is symmetric, each leading submatrix \\(A_{k}\\) is also symmetric. We'll prove that \\(A_{k}\\) is positive-definite by contradiction. If \\(A_{k}\\) is not positive-definite, then there exists a \\(k\\)-vector \\(x_{k}\\neq 0\\) such that \\(x_{k}^{\\rm T}A_{k}x_{k}\\leq 0\\). Let \\(A\\) be \\(n\\times n\\), and\n\n\\[A=\\left(\\begin{array}{cc}A_{k}&B^{\\rm T}\\\\ B&C\\end{array}\\right) \\tag{28.16}\\]\n\nfor submatrices \\(B\\) (which is \\((n-k)\\times k\\)) and \\(C\\) (which is \\((n-k)\\times(n-k)\\)). Define the \\(n\\)-vector \\(x=(\\begin{array}{cc}x_{k}^{\\rm T}&0\\end{array})^{\\rm T}\\), where \\(n-k\\) 0s follow \\(x_{k}\\). Then we have\n\n\\[x^{\\rm T}Ax = (\\begin{array}{cc}x_{k}^{\\rm T}&0\\end{array})\\left(\\begin{array} []{cc}A_{k}&B^{\\rm T}\\\\ B&C\\end{array}\\right)\\left(\\begin{array}{cc}x_{k}\\\\ 0\\end{array}\\right)\\] \\[= (\\begin{array}{cc}x_{k}^{\\rm T}&0\\end{array})\\left(\\begin{array} []{cc}A_{k}x_{k}\\\\ Bx_{k}\\end{array}\\right)\\] \\[= \\begin{array}{cc}x_{k}^{\\rm T}A_{k}x_{k}\\\\ \\leq&0\\end{array},\\]\n\nwhich contradicts \\(A\\) being positive-definite.\n\nWe now turn to some essential properties of the Schur complement. Let \\(A\\) be a symmetric positive-definite matrix, and let \\(A_{k}\\) be a leading \\(k\\times k\\) submatrix of \\(A\\). Partition \\(A\\) once again according to equation (28.16). Equation (28.10) generalizes to define the _Schur complement_\\(S\\) of \\(A\\) with respect to \\(A_{k}\\) as\n\n\\[S=C-BA_{k}^{-1}B^{\\rm T}\\;. \\tag{28.17}\\]\n\n(By Lemma 28.4, \\(A_{k}\\) is symmetric and positive-definite, and therefore, \\(A_{k}^{-1}\\) exists by Lemma 28.3, and \\(S\\) is well defined.) The earlier definition (28.10) of the Schur complement is consistent with equation (28.17) by letting \\(k=1\\).\n\nThe next lemma shows that the Schur-complement matrices of symmetric positive-definite matrices are themselves symmetric and positive-definite. We used this result in Theorem 28.2, and its corollary will help prove that LU decomposition works for symmetric positive-definite matrices.\n\n**Lemma 28.5** (Schur complement lemma): _If \\(A\\) is a symmetric positive-definite matrix and \\(A_{k}\\) is a leading \\(k\\times k\\) submatrix of \\(A\\), then the Schur complement \\(S\\) of \\(A\\) with respect to \\(A_{k}\\) is symmetric and positive-definite._\n\n_Proof_ Because \\(A\\) is symmetric, so is the submatrix \\(C\\). By Exercise D.2-6 on page 1223, the product \\(BA_{k}^{-1}\\,B^{\\rm T}\\) is symmetric. Since \\(C\\) and \\(BA_{k}^{-1}\\,B^{\\rm T}\\) are symmetric, then by Exercise D.1-1 on page 1219, so is \\(S\\).\n\nIt remains to show that \\(S\\) is positive-definite. Consider the partition of \\(A\\) given in equation (28.16). For any nonzero vector \\(x\\), we have \\(x^{\\rm T}Ax>0\\) by the assumption that \\(A\\) is positive-definite. Let the subvectors \\(y\\) and \\(z\\) consist of the first \\(k\\) and last \\(n-k\\) elements in \\(x\\), respectively, and thus they are compatible with \\(A_{k}\\) and \\(C\\), respectively. Because \\(A_{k}^{-1}\\) exists, we have\n\n\\[x^{\\rm T}Ax = \\left(\\begin{array}{cc}y^{\\rm T}&z^{\\rm T}\\end{array}\\right) \\left(\\begin{array}{cc}A_{k}&B^{\\rm T}\\\\ B&C\\end{array}\\right)\\left(\\begin{array}{c}y\\\\ z\\end{array}\\right)\\] (28.18) \\[= \\left(\\begin{array}{cc}y^{\\rm T}&z^{\\rm T}\\end{array}\\right) \\left(\\begin{array}{c}A_{k}y+B^{\\rm T}z\\\\ By+Cz\\end{array}\\right)\\] \\[= y^{\\rm T}A_{k}\\,y+y^{\\rm T}B^{\\rm T}z+z^{\\rm T}By+z^{\\rm T}Cz\\] \\[= \\left(y+A_{k}^{-1}\\,B^{\\rm T}z\\right)^{\\rm T}A_{k}(y+A_{k}^{-1}B^ {\\rm T}z)+z^{\\rm T}(C-BA_{k}^{-1}\\,B^{\\rm T})z\\,\\] This last equation, which you can verify by multiplying through, amounts to \"completing the square\" of the quadratic form. (See Exercise 28.3-2.)\n\nSince \\(x^{\\rm T}Ax>0\\) holds for any nonzero \\(x\\), pick any nonzero \\(z\\) and then choose \\(y=-A_{k}^{-1}\\,B^{\\rm T}z\\), which causes the first term in equation (28.18) to vanish, leaving\n\n\\[z^{\\rm T}(C-BA_{k}^{-1}\\,B^{\\rm T})z=z^{\\rm T}Sz\\]\n\nas the value of the expression. For any \\(z\\neq 0\\), we therefore have \\(z^{\\rm T}Sz=x^{\\rm T}Ax>0\\), and thus \\(S\\) is positive-definite.\n\n**Corollary 28.6**: _LU decomposition of a symmetric positive-definite matrix never causes a division by 0._\n\n_Proof_ Let \\(A\\) be an \\(n\\times n\\) symmetric positive-definite matrix. In fact, we'll prove a stronger result than the statement of the corollary: every pivot is strictly positive. The first pivot is \\(a_{11}\\). Let \\(e_{1}\\) be the length-\\(n\\) unit vector \\((\\begin{array}{cccc}1&0&0&\\cdots&0\\end{array})^{\\rm T}\\), so that \\(a_{11}=e_{1}^{\\rm T}Ae_{1}\\), which is positive because \\(e_{1}\\) is nonzero and \\(A\\) is positive definite. Since the first step of LU decomposition produces the Schur complement of \\(A\\) with respect to \\(A_{1}=(a_{11})\\), Lemma 28.5 implies by induction that all pivots are positive.\n\n##### Least-squares approximation\n\nOne important application of symmetric positive-definite matrices arises in fitting curves to given sets of data points. You are given a set of \\(m\\) data points\n\n\\[(x_{1},y_{1}),(x_{2},y_{2}),\\ldots,(x_{m},y_{m})\\,\\]\n\nwhere you know that the \\(y_{i}\\) are subject to measurement errors. You wish to determine a function \\(F(x)\\) such that the approximation errors\n\n\\[\\eta_{i}=F(x_{i})-y_{i} \\tag{28.19}\\]\n\nare small for \\(i=1,2,\\ldots,m\\). The form of the function \\(F\\) depends on the problem at hand. Let's assume that it has the form of a linearly weighted sum\n\n\\[F(x)=\\sum_{j=1}^{n}c_{j}\\,f_{j}(x)\\,\\]\n\nwhere the number \\(n\\) of summands and the specific _basis functions_\\(f_{j}\\) are chosen based on knowledge of the problem at hand. A common choice is \\(f_{j}(x)=x^{j-1}\\), which means that\n\n\\[F(x)=c_{1}+c_{2}x+c_{3}x^{2}+\\cdots+c_{n}x^{n-1}\\]\n\nis a polynomial of degree \\(n-1\\) in \\(x\\). Thus, if you are given \\(m\\) data points \\((x_{1},y_{1}),(x_{2},y_{2}),\\ldots,(x_{m},y_{m})\\), you need to calculate \\(n\\) coefficients \\(c_{1},c_{2},\\ldots,c_{n}\\) that minimize the approximation errors \\(\\eta_{1},\\eta_{2},\\ldots,\\eta_{m}\\).\n\nBy choosing \\(n=m\\), you can calculate each \\(y_{i}\\)_exactly_ in equation (28.19). Such a high-degree polynomial \\(F\\) \"fits the noise\" as well as the data, however, and generally gives poor results when used to predict \\(y\\) for previously unseen values of \\(x\\). It is usually better to choose \\(n\\) significantly smaller than \\(m\\) and hope that by choosing the coefficients \\(c_{j}\\) well, you can obtain a function \\(F\\) that finds the significant patterns in the data points without paying undue attention to the noise. Some theoretical principles exist for choosing \\(n\\), but they are beyond the scope of this text. In any case, once you choose a value of \\(n\\) that is less than \\(m\\), you end up with an overdetermined set of equations whose solution you wish to approximate. Let's see how to do so.\n\nLet\n\n\\[A=\\left(\\begin{array}{cccccc}f_{1}(x_{1})&f_{2}(x_{1})&\\ldots&f&{}_{n}(x_{1})\\\\ f_{1}(x_{2})&f_{2}(x_{2})&\\ldots&f&{}_{n}(x_{2})\\\\ \\vdots&\\vdots&\\ddots&\\vdots\\\\ f_{1}(x_{m})&f_{2}(x_{m})&\\ldots&f&{}_{n}(x_{m})\\end{array}\\right)\\]\n\ndenote the matrix of values of the basis functions at the given points, that is, \\(a_{ij}=f_{j}(x_{i})\\). Let \\(c=(c_{k})\\) denote the desired \\(n\\)-vector of coefficients. Then,\n\n\\[Ac = \\left(\\begin{array}{ccccc}f_{1}(x_{1})&f_{2}(x_{1})&\\ldots&f&{}_ {n}(x_{1})\\\\ f_{1}(x_{2})&f_{2}(x_{2})&\\ldots&f&{}_{n}(x_{2})\\\\ \\vdots&\\vdots&\\ddots&\\vdots\\\\ f_{1}(x_{m})&f_{2}(x_{m})&\\ldots&f&{}_{n}(x_{m})\\end{array}\\right)\\left( \\begin{array}{c}c_{1}\\\\ c_{2}\\\\ \\vdots\\\\ c_{n}\\end{array}\\right)\\] \\[= \\left(\\begin{array}{c}F(x_{1})\\\\ F(x_{2})\\\\ \\vdots\\\\ F(x_{m})\\end{array}\\right)\\]\n\nis the \\(m\\)-vector of \"predicted values\" for \\(y\\). Thus,\n\n\\[\\eta=Ac-y\\]\n\nis the \\(m\\)-vector of _approximation errors_.\n\nTo minimize approximation errors, let's minimize the norm of the error vector \\(\\eta\\), which gives a _least-squares solution_, since\n\n\\[\\left\\|\\eta\\right\\|=\\left(\\,\\sum_{i=1}^{m}\\eta_{i}^{2}\\,\\right)^{1/2}\\.\\]\n\nBecause\n\n\\[\\left\\|\\eta\\right\\|^{2}=\\left\\|Ac-y\\right\\|^{2}=\\sum_{i=1}^{m}\\left(\\,\\sum_{j =1}^{n}a_{ij}c_{j}-y_{i}\\,\\right)^{2}\\,\\]\n\nto minimize \\(\\left\\|\\eta\\right\\|\\), differentiate \\(\\left\\|\\eta\\right\\|^{2}\\) with respect to each \\(c_{k}\\) and then set the result to 0:\n\n\\[\\frac{d\\,\\left\\|\\eta\\right\\|^{2}}{dc_{k}}=\\sum_{i=1}^{m}2\\left(\\,\\sum_{j=1}^{ n}a_{ij}c_{j}-y_{i}\\,\\right)a_{ik}=0. \\tag{28.20}\\]\n\nThe \\(n\\) equations (28.20) for \\(k=1,2,\\ldots,n\\) are equivalent to the single matrix equatio\\((Ac-y)^{\\rm T}A=0\\)\n\nor, equivalently (using Exercise D.1-2 on page 1219), to\n\n\\(A^{\\rm T}(Ac-y)=0\\),\n\nwhich implies\n\n\\(A^{\\rm T}Ac=A^{\\rm T}y\\). (28.21)\n\nIn statistics, equation (28.21) is called the _normal equation_. The matrix \\(A^{\\rm T}A\\) is symmetric by Exercise D.1-2, and if \\(A\\) has full column rank, then by Theorem D.6 on page 1222, \\(A^{\\rm T}A\\) is positive-definite as well. Hence, \\((A^{\\rm T}A)^{-1}\\) exists, and the solution to equation (28.21) is\n\n\\[c = \\left((A^{\\rm T}A)^{-1}A^{\\rm T}\\right)y \\tag{28.22}\\] \\[= A^{+}y\\,\\]\n\nwhere the matrix \\(A^{+}=((A^{\\rm T}A)^{-1}A^{\\rm T})\\) is the _pseudoinverse_ of the matrix \\(A\\). The pseudoinverse naturally generalizes the notion of a matrix inverse to the case in which \\(A\\) is not square. (Compare equation (28.22) as the approximate solution to \\(Ac=y\\) with the solution \\(A^{-1}b\\) as the exact solution to \\(Ax=b\\).)\n\nAs an example of producing a least-squares fit, suppose that you have five data points\n\n\\((x_{1},y_{1})\\ =\\ (-1,2)\\),\n\n\\((x_{2},y_{2})\\ =\\ (1,1)\\),\n\n\\((x_{3},y_{3})\\ =\\ (2,1)\\),\n\n\\((x_{4},y_{4})\\ =\\ (3,0)\\),\n\n\\((x_{5},y_{5})\\ =\\ (5,3)\\),\n\nshown as orange dots in Figure 28.3, and you want to fit these points with a quadratic polynomial\n\n\\(F(x)=c_{1}+c_{2}x+c_{3}x^{2}\\).\n\nStart with the matrix of basis-function values\n\n\\(A=\\left(\\begin{array}{ccc}1&x_{1}&x_{1}^{2}\\\\ 1&x_{2}&x_{2}^{2}\\\\ 1&x_{3}&x_{3}^{2}\\\\ 1&x_{4}&x_{4}^{2}\\\\ 1&x_{5}&x_{5}^{2}\\end{array}\\right)=\\left(\\begin{array}{ccc}1&-1&1\\\\ 1&1&1\\\\ 1&2&4\\\\ 1&3&9\\\\ 1&5&25\\end{array}\\right)\\,\\)\n\nwhose pseudoinverse is \\[A^{+}=\\left(\\begin{array}{rrrrr}0.500&0.300&0.200&0.100&-0.100\\\\ -0.388&0.093&0.190&0.193&-0.088\\\\ 0.060&-0.036&-0.048&-0.036&0.060\\end{array}\\right).\\]\n\nMultiplying \\(y\\) by \\(A^{+}\\) gives the coefficient vector\n\n\\[c=\\left(\\begin{array}{rrr}1.200\\\\ -0.757\\\\ 0.214\\end{array}\\right),\\]\n\nwhich corresponds to the quadratic polynomial\n\n\\[F(x)=1.200-0.757x+0.214x^{2}\\]\n\nas the closest-fitting quadratic to the given data, in a least-squares sense.\n\nAs a practical matter, you would typically solve the normal equation (28.21) by multiplying \\(y\\) by \\(A^{\\rm T}\\) and then finding an LU decomposition of \\(A^{\\rm T}A\\). If \\(A\\) has full rank, the matrix \\(A^{\\rm T}A\\) is guaranteed to be nonsingular, because it is symmetric and positive-definite. (See Exercise D.1-2 and Theorem D.6.)\n\nFigure 28.3: The least-squares fit of a quadratic polynomial to the set of five data points \\(\\{(-1,2),(1,1),(2,1),(3,0),(5,3)\\}\\). The orange dots are the data points, and the blue dots are their estimated values predicted by the polynomial \\(F(x)=1.2-0.757x+0.214x^{2}\\), the quadratic polynomial that minimizes the sum of the squared errors, plotted in blue. Each orange line shows the error for one data point.\n\nfor the carbon-dioxide concentrations measured in Mauna Loa, Hawaii from 19901 to 2019, where \\(x\\) is the number of years elapsed since 1990. This curve is the famous \"Keeling curve,\" illustrating curve-fitting to nonpolynomial formulas. The sine and cosine terms allow modeling of seasonal variations in CO\\({}_{2}\\) concentrations. The red curve shows the measured CO\\({}_{2}\\) concentrations. The best fit, shown in black, has the form\n\nFootnote 1: The year in which _Introduction to Algorithms_ was first published.\n\n\\[352.83+1.39x+0.02x^{2}+2.83\\sin(2\\pi x)-0.94\\cos(2\\pi x)\\.\\]\n\nWe close this section with an example in Figure 28.4, illustrating that a curve can also fit a nonpolynomial function. The curve confirms one aspect of climate change: that carbon dioxide (CO\\({}_{2}\\)) concentrations have steadily increased over a period of 29 years. Linear and quadratic terms model the annual increase, and sine and cosine terms model seasonal variations.\n\nFigure 28.4: A least-squares fit of a curve of the form\n\n### Exercises\n\n#### 28.3-1\n\nProve that every diagonal element of a symmetric positive-definite matrix is positive.\n\n#### 28.3-2\n\nLet \\(A=\\left(\\begin{array}{cc}a&b\\\\ b&c\\end{array}\\right)\\) be a \\(2\\times 2\\) symmetric positive-definite matrix. Prove that its determinant \\(ac-b^{2}\\) is positive by \"completing the square\" in a manner similar to that used in the proof of Lemma 28.5.\n\n#### 28.3-3\n\nProve that the maximum element in a symmetric positive-definite matrix lies on the diagonal.\n\n#### 28.3-4\n\nProve that the determinant of each leading submatrix of a symmetric positive-definite matrix is positive.\n\n#### 28.3-5\n\nLet \\(A_{k}\\) denote the \\(k\\)th leading submatrix of a symmetric positive-definite matrix \\(A\\). Prove that \\(\\det(A_{k})/\\det(A_{k-1})\\) is the \\(k\\)th pivot during LU decomposition, where, by convention, \\(\\det(A_{0})=1\\).\n\n#### 28.3-6\n\nFind the function of the form\n\n\\(F(x)=c_{1}+c_{2}x\\lg x+c_{3}e^{x}\\)\n\nthat is the best least-squares fit to the data points\n\n\\((1,1)\\), \\((2,1)\\), \\((3,3)\\), \\((4,8)\\).\n\n#### 28.3-7\n\nShow that the pseudoinverse \\(A^{+}\\) satisfies the following four equations:\n\n\\(AA^{+}A=A\\),\n\n\\(A^{+}AA^{+}=A^{+}\\),\n\n\\((AA^{+})^{\\rm T}=AA^{+}\\),\n\n\\((A^{+}A)^{\\rm T}=A^{+}A\\).\n\n## Problems\n\n### 28-1 Tridiagonal systems of linear equations\n\nConsider the tridiagonal matrix\n\n\\[A=\\left(\\begin{array}{rrrrr}1&-1&0&0&0\\\\ -1&2&-1&0&0\\\\ 0&-1&2&-1&0\\\\ 0&0&-1&2&-1\\\\ 0&0&0&-1&2\\end{array}\\right)\\.\\]\n\n* Find an LU decomposition of \\(A\\).\n* Solve the equation \\(Ax=\\left(\\begin{array}{rrrrr}1&1&1&1&1\\end{array}\\right)\\)\\({}^{\\rm T}\\) by using forward and back substitution.\n* Find the inverse of \\(A\\).\n* Show how to solve the equation \\(Ax=b\\) for any \\(n\\times n\\) symmetric positive-definite, tridiagonal matrix \\(A\\) and any \\(n\\)-vector \\(b\\) in \\(O(n)\\) time by performing an LU decomposition. Argue that any method based on forming \\(A^{-1}\\) is asymptotically more expensive in the worst case.\n* Show how to solve the equation \\(Ax=b\\) for any \\(n\\times n\\) nonsingular, tridiagonal matrix \\(A\\) and any \\(n\\)-vector \\(b\\) in \\(O(n)\\) time by performing an LUP decomposition.\n\n### 28-2 Splines\n\nA practical method for interpolating a set of points with a curve is to use _cubic splines_. You are given a set \\(\\{(x_{i},y_{i}):i=0,1,\\ldots,n\\}\\) of \\(n+1\\) point-value pairs, where \\(x_{0}<x_{1}<\\cdots<x_{n}\\). Your goal is to fit a piecewise-cubic curve (spline) \\(f(x)\\) to the points. That is, the curve \\(f(x)\\) is made up of \\(n\\) cubic polynomials \\(f_{i}(x)=a_{i}+b_{i}x+c_{i}x^{2}+d_{i}x^{3}\\) for \\(i=0,1,\\ldots,n-1\\), where if \\(x\\) falls in the range \\(x_{i}\\leq x\\leq x_{i+1}\\), then the value of the curve is given by \\(f(x)=f_{i}(x-x_{i})\\). The points \\(x_{i}\\) at which the cubic polynomials are \"pasted\" together are called _knots_. For simplicity, assume that \\(x_{i}=i\\) for \\(i=0,1,\\ldots,n\\).\n\nTo ensure continuity of \\(f(x)\\), require that\n\n\\[f(x_{i})\\ \\ \\ \\ =\\ f_{i}(0)\\ =\\ y_{i}\\,\\] \\[f(x_{i+1})\\ =\\ f_{i}(1)\\ =\\ y_{i+1}\\]\n\nfor \\(i=0,1,\\ldots,n-1\\). To ensure that \\(f(x)\\) is sufficiently smooth, also require the first derivative to be continuous at each knot:",
        "chapter": "Part VII Selected Topics",
        "section": "28 Matrix Operations",
        "subsection": "28.3 Symmetric positive-definite matrices and least-squares approximation",
        "subsubsection": "N/A"
    },
    {
        "content": "## Problems\n\n### 28-1 Tridiagonal systems of linear equations\n\nConsider the tridiagonal matrix\n\n\\[A=\\left(\\begin{array}{rrrrr}1&-1&0&0&0\\\\ -1&2&-1&0&0\\\\ 0&-1&2&-1&0\\\\ 0&0&-1&2&-1\\\\ 0&0&0&-1&2\\end{array}\\right)\\.\\]\n\n* Find an LU decomposition of \\(A\\).\n* Solve the equation \\(Ax=\\left(\\begin{array}{rrrrr}1&1&1&1&1\\end{array}\\right)\\)\\({}^{\\rm T}\\) by using forward and back substitution.\n* Find the inverse of \\(A\\).\n* Show how to solve the equation \\(Ax=b\\) for any \\(n\\times n\\) symmetric positive-definite, tridiagonal matrix \\(A\\) and any \\(n\\)-vector \\(b\\) in \\(O(n)\\) time by performing an LU decomposition. Argue that any method based on forming \\(A^{-1}\\) is asymptotically more expensive in the worst case.\n* Show how to solve the equation \\(Ax=b\\) for any \\(n\\times n\\) nonsingular, tridiagonal matrix \\(A\\) and any \\(n\\)-vector \\(b\\) in \\(O(n)\\) time by performing an LUP decomposition.\n\n### 28-2 Splines\n\nA practical method for interpolating a set of points with a curve is to use _cubic splines_. You are given a set \\(\\{(x_{i},y_{i}):i=0,1,\\ldots,n\\}\\) of \\(n+1\\) point-value pairs, where \\(x_{0}<x_{1}<\\cdots<x_{n}\\). Your goal is to fit a piecewise-cubic curve (spline) \\(f(x)\\) to the points. That is, the curve \\(f(x)\\) is made up of \\(n\\) cubic polynomials \\(f_{i}(x)=a_{i}+b_{i}x+c_{i}x^{2}+d_{i}x^{3}\\) for \\(i=0,1,\\ldots,n-1\\), where if \\(x\\) falls in the range \\(x_{i}\\leq x\\leq x_{i+1}\\), then the value of the curve is given by \\(f(x)=f_{i}(x-x_{i})\\). The points \\(x_{i}\\) at which the cubic polynomials are \"pasted\" together are called _knots_. For simplicity, assume that \\(x_{i}=i\\) for \\(i=0,1,\\ldots,n\\).\n\nTo ensure continuity of \\(f(x)\\), require that\n\n\\[f(x_{i})\\ \\ \\ \\ =\\ f_{i}(0)\\ =\\ y_{i}\\,\\] \\[f(x_{i+1})\\ =\\ f_{i}(1)\\ =\\ y_{i+1}\\]\n\nfor \\(i=0,1,\\ldots,n-1\\). To ensure that \\(f(x)\\) is sufficiently smooth, also require the first derivative to be continuous at each knot:\\(f^{\\prime}(x_{i+1})=f^{\\prime}_{i}(1)=f^{\\prime}_{i+1}(0)\\) for \\(i=0,1,\\ldots,n-2\\). **a.**: Suppose that for \\(i=0,1,\\ldots,n\\), in addition to the point-value pairs \\(\\{(x_{i},y_{i})\\}\\), you are also given the first derivative \\(D_{i}=f^{\\prime}(x_{i})\\) at each knot. Express each coefficient \\(a_{i}\\), \\(b_{i}\\), \\(c_{i}\\), and \\(d_{i}\\) in terms of the values \\(y_{i}\\), \\(y_{i+1}\\), \\(D_{i}\\), and \\(D_{i+1}\\). (Remember that \\(x_{i}=i\\).) How quickly can you compute the \\(4n\\) coefficients from the point-value pairs and first derivatives?\n\nThe question remains of how to choose the first derivatives of \\(f(x)\\) at the knots. One method is to require the second derivatives to be continuous at the knots:\n\n\\(f^{\\prime\\prime}(x_{i+1})=f^{\\prime\\prime}_{i}(1)=f^{\\prime\\prime}_{i+1}(0)\\) for \\(i=0,1,\\ldots,n-2\\). At the first and last knots, assume that \\(f^{\\prime\\prime}(x_{0})=f^{\\prime\\prime}_{0}(0)=0\\) and \\(f^{\\prime\\prime}(x_{n})=f^{\\prime\\prime}_{n-1}(1)=0\\). These assumptions make \\(f(x)\\) a _natural_ cubic spline. **b.**: Use the continuity constraints on the second derivative to show that for \\(i=1,2,\\ldots,n-1\\),\n\n\\(D_{i-1}+4D_{i}+D_{i+1}=3(y_{i+1}-y_{i-1})\\). **c.**: Show that\n\n\\(2D_{0}+D_{1}=3(y_{1}-y_{0})\\), (28.24) \\(D_{n-1}+2D_{n}=3(y_{n}-y_{n-1})\\). **d.**: Rewrite equations (28.23)-(28.25) as a matrix equation involving the vector \\(D=(\\begin{array}{cccc}D_{0}&D_{1}&D_{2}&\\cdots&D_{n}\\end{array})^{\\rm T}\\) of unknowns. What attributes does the matrix in your equation have? **e.**: Argue that a natural cubic spline can interpolate a set of \\(n+1\\) point-value pairs in \\(O(n)\\) time (see Problem 28-1). **f.**: Show how to determine a natural cubic spline that interpolates a set of \\(n+1\\) points \\((x_{i},y_{i})\\) satisfying \\(x_{0}<x_{1}<\\cdots<x_{n}\\), even when \\(x_{i}\\) is not necessarily equal to \\(i\\). What matrix equation must your method solve, and how quickly does your algorithm run?\n\n**Chapter notes**\n\nMany excellent texts describe numerical and scientific computation in much greater detail than we have room for here. The following are especially readable: George",
        "chapter": "Part VII Selected Topics",
        "section": "28 Matrix Operations",
        "subsection": "Problems",
        "subsubsection": "N/A"
    },
    {
        "content": "\\(f^{\\prime}(x_{i+1})=f^{\\prime}_{i}(1)=f^{\\prime}_{i+1}(0)\\) for \\(i=0,1,\\ldots,n-2\\). **a.**: Suppose that for \\(i=0,1,\\ldots,n\\), in addition to the point-value pairs \\(\\{(x_{i},y_{i})\\}\\), you are also given the first derivative \\(D_{i}=f^{\\prime}(x_{i})\\) at each knot. Express each coefficient \\(a_{i}\\), \\(b_{i}\\), \\(c_{i}\\), and \\(d_{i}\\) in terms of the values \\(y_{i}\\), \\(y_{i+1}\\), \\(D_{i}\\), and \\(D_{i+1}\\). (Remember that \\(x_{i}=i\\).) How quickly can you compute the \\(4n\\) coefficients from the point-value pairs and first derivatives?\n\nThe question remains of how to choose the first derivatives of \\(f(x)\\) at the knots. One method is to require the second derivatives to be continuous at the knots:\n\n\\(f^{\\prime\\prime}(x_{i+1})=f^{\\prime\\prime}_{i}(1)=f^{\\prime\\prime}_{i+1}(0)\\) for \\(i=0,1,\\ldots,n-2\\). At the first and last knots, assume that \\(f^{\\prime\\prime}(x_{0})=f^{\\prime\\prime}_{0}(0)=0\\) and \\(f^{\\prime\\prime}(x_{n})=f^{\\prime\\prime}_{n-1}(1)=0\\). These assumptions make \\(f(x)\\) a _natural_ cubic spline. **b.**: Use the continuity constraints on the second derivative to show that for \\(i=1,2,\\ldots,n-1\\),\n\n\\(D_{i-1}+4D_{i}+D_{i+1}=3(y_{i+1}-y_{i-1})\\). **c.**: Show that\n\n\\(2D_{0}+D_{1}=3(y_{1}-y_{0})\\), (28.24) \\(D_{n-1}+2D_{n}=3(y_{n}-y_{n-1})\\). **d.**: Rewrite equations (28.23)-(28.25) as a matrix equation involving the vector \\(D=(\\begin{array}{cccc}D_{0}&D_{1}&D_{2}&\\cdots&D_{n}\\end{array})^{\\rm T}\\) of unknowns. What attributes does the matrix in your equation have? **e.**: Argue that a natural cubic spline can interpolate a set of \\(n+1\\) point-value pairs in \\(O(n)\\) time (see Problem 28-1). **f.**: Show how to determine a natural cubic spline that interpolates a set of \\(n+1\\) points \\((x_{i},y_{i})\\) satisfying \\(x_{0}<x_{1}<\\cdots<x_{n}\\), even when \\(x_{i}\\) is not necessarily equal to \\(i\\). What matrix equation must your method solve, and how quickly does your algorithm run?\n\n**Chapter notes**\n\nMany excellent texts describe numerical and scientific computation in much greater detail than we have room for here. The following are especially readable: George and Liu [180], Golub and Van Loan [192], Press, Teukolsky, Vetterling, and Flannery [365, 366], and Strang [422, 423].\n\nGolub and Van Loan [192] discuss numerical stability. They show why \\(\\det(A)\\) is not necessarily a good indicator of the stability of a matrix \\(A,\\) proposing instead to use \\(\\left\\|A\\right\\|_{\\infty}\\left\\|A^{-1}\\right\\|_{\\infty},\\) where \\(\\left\\|A\\right\\|_{\\infty}=\\max\\left\\{\\sum_{j=1}^{n}\\left|a_{ij}\\right|:1\\leq i \\leq n\\right\\}\\). They also address the question of how to compute this value without actually computing \\(A^{-1}.\\)\n\nGaussian elimination, upon which the LU and LUP decompositions are based, was the first systematic method for solving linear systems of equations. It was also one of the earliest numerical algorithms. Although it was known earlier, its discovery is commonly attributed to C. F. Gauss (1777-1855). In his famous paper [424], Strassen showed that an \\(n\\times n\\) matrix can be inverted in \\(O(n^{\\lg 7})\\) time. Winograd [460] originally proved that matrix multiplication is no harder than matrix inversion, and the converse is due to Aho, Hopcroft, and Ullman [5].\n\nAnother important matrix decomposition is the _singular value decomposition_, or \\(S\\!V\\!D\\). The SVD factors an \\(m\\times n\\) matrix \\(A\\) into \\(A=Q_{1}\\,\\Sigma Q_{2}^{\\mathrm{T}},\\) where \\(\\Sigma\\) is an \\(m\\times n\\) matrix with nonzero values only on the diagonal, \\(Q_{1}\\) is \\(m\\times m\\) with mutually orthonormal columns, and \\(Q_{2}\\) is \\(n\\times n\\), also with mutually orthonormal columns. Two vectors are _orthonormal_ if their inner product is \\(0\\) and each vector has a norm of \\(1.\\) The books by Strang [422, 423] and Golub and Van Loan [192] contain good treatments of the SVD.\n\nStrang [423] has an excellent presentation of symmetric positive-definite matrices and of linear algebra in general.\n\nMany problems take the form of maximizing or minimizing an objective, given limited resources and competing constraints. If you can specify the objective as a linear function of certain variables, and if you can specify the constraints on resources as equalities or inequalities on those variables, then you have a _linear-programming problem_. Linear programs arise in a variety of practical applications. We begin by studying an application in electoral politics.\n\n#### A political problem\n\nSuppose that you are a politician trying to win an election. Your district has three different types of areas--urban, suburban, and rural. These areas have, respectively, 100,000, 200,000, and 50,000 registered voters. Although not all the registered voters actually go to the polls, you decide that to govern effectively, you would like at least half the registered voters in each of the three regions to vote for you. You are honorable and would never consider supporting policies you don't believe in. You realize, however, that certain issues may be more effective in winning votes in certain places. Your primary issues are preparing for a zombie apocalypse, equipping sharks with lasers, building highways for flying cars, and allowing dolphins to vote.\n\nAccording to your campaign staff's research, you can estimate how many votes you win or lose from each population segment by spending $1,000 on advertising on each issue. This information appears in the table of Figure 29.1. In this table, each entry indicates the number of thousands of either urban, suburban, or rural voters who would be won over by spending $1,000 on advertising in support of a particular issue. Negative entries denote votes that would be lost. Your task is to figure out the minimum amount of money that you need to spend in order to win 50,000 urban votes, 100,000 suburban votes, and 25,000 rural votes.\n\nYou could, by trial and error, devise a strategy that wins the required number of votes, but the strategy you come up with might not be the least expensive one. For example, you could devote $20,000 of advertising to preparing for a zombie",
        "chapter": "Part VII Selected Topics",
        "section": "28 Matrix Operations",
        "subsection": "Chapter notes",
        "subsubsection": "N/A"
    },
    {
        "content": "linear. In Section 29.2, we will see several other examples of modeling via linear programs. Section 29.3 discusses duality, an important concept in linear programming and other optimization algorithms.\n\n### Linear programming formulations and algorithms\n\nLinear programs take a particular form, which we will examine in this section. Multiple algorithms have been developed to solve linear programs. Some run in polynomial time, some do not, but they are all too complicated to show here. Instead, we will give an example that demonstrates some ideas behind the simplex algorithm, which is currently the most commonly deployed solution method.\n\n#### General linear programs\n\nIn the general linear-programming problem, we wish to optimize a linear function subject to a set of linear inequalities. Given a set of real numbers \\(a_{1},a_{2},\\ldots,a_{n}\\) and a set of variables \\(x_{1},x_{2},\\ldots,x_{n}\\), we define a _linear function_\\(f\\) on those variables by\n\n\\[f(x_{1},x_{2},\\ldots,x_{n})=a_{1}x_{1}+a_{2}x_{2}+\\cdots+a_{n}x_{n}=\\sum_{j=1}^ {n}a_{j}x_{j}\\.\\]\n\nIf \\(b\\) is a real number and \\(f\\) is a linear function, then the equation\n\n\\[f(x_{1},x_{2},\\ldots,x_{n})=b\\]\n\nis a _linear equality_ and the inequalities\n\n\\[f(x_{1},x_{2},\\ldots,x_{n})\\leq b\\ \\ \\mbox{and}\\ \\ f(x_{1},x_{2},\\ldots,x_{n}) \\geq b\\]\n\nare _linear inequalities_. We use the general term _linear constraints_ to denote either linear equalities or linear inequalities. Linear programming does not allow strict inequalities. Formally, a _linear-programming problem_ is the problem of either minimizing or maximizing a linear function subject to a finite set of linear constraints. If minimizing, we call the linear program a _minimization linear program_, and if maximizing, we call the linear program a _maximization linear program_.\n\nIn order to discuss linear-programming algorithms and properties, it will be helpful to use a standard notation for the input. By convention, a maximization linear program takes as input \\(n\\) real numbers \\(c_{1},c_{2},\\ldots,c_{n}\\); \\(m\\) real numbers \\(b_{1},b_{2},\\ldots,b_{m}\\); and \\(mn\\) real numbers \\(a_{ij}\\) for \\(i=1,2,\\ldots,m\\) and \\(j=1,2,\\ldots,n\\)The goal is to find \\(n\\) real numbers \\(x_{1},x_{2},\\ldots,x_{n}\\) that\n\n\\[\\mbox{maximize}\\quad\\sum_{j=1}^{n}c_{j}x_{j} \\tag{29.11}\\]\n\nsubject to\n\n\\[\\sum_{j=1}^{n}a_{ij}x_{j}\\ \\leq\\ b_{i}\\ \\ \\mbox{for}\\ i\\ =1,2,\\ldots,m \\tag{29.12}\\]\n\n\\[x_{j}\\ \\geq\\ 0\\ \\ \\mbox{for}\\ j\\ =1,2,\\ldots,n\\ . \\tag{29.13}\\]\n\nWe call expression (29.11) the _objective function_ and the \\(n+m\\) inequalities in lines (29.12) and (29.13) the _constraints_. The \\(n\\) constraints in line (29.13) are the _nonnegativity constraints_. It can sometimes be more convenient to express a linear program in a more compact form. If we create an \\(m\\times n\\) matrix \\(A=(a_{ij})\\), an \\(m\\)-vector \\(b=(b_{i})\\), an \\(n\\)-vector \\(c\\ =(c_{j})\\), and an \\(n\\)-vector \\(x\\ =(x_{j})\\), then we can rewrite the linear program defined in (29.11)-(29.13) as\n\n\\[\\mbox{maximize}\\ \\ \\ c^{\\rm T}x \\tag{29.14}\\]\n\nsubject to\n\n\\[Ax\\ \\leq\\ b \\tag{29.15}\\]\n\n\\[x\\ \\geq\\ 0\\ . \\tag{29.16}\\]\n\nIn line (29.14), \\(c^{\\rm T}x\\) is the inner product of two \\(n\\)-vectors. In inequality (29.15), \\(Ax\\) is the \\(m\\)-vector that is the product of an \\(m\\times n\\) matrix and an \\(n\\)-vector, and in inequality (29.16), \\(x\\geq 0\\) means that each entry of the vector \\(x\\) must be nonnegative. We call this representation the _standard form_ for a linear program, and we adopt the convention that \\(A,\\,b\\), and \\(c\\) always have the dimensions given above.\n\nThe standard form above may not naturally correspond to real-life situations you are trying to model. For example, you might have equality constraints or variables that can take on negative values. Exercises 29.1-6 and 29.1-7 ask you to show how to convert any linear program into this standard form.\n\nWe now introduce terminology to describe solutions to linear programs. We denote a particular setting of the values in a variable, say \\(x\\), by putting a bar over the variable name: \\(\\bar{x}\\). If \\(\\bar{x}\\) satisfies all the constraints, then it is a _feasible solution_, but if it fails to satisfy at least one constraint, then it is an _infeasible solution_. We say that a solution \\(\\bar{x}\\) has _objective value_\\(c^{\\rm T}\\bar{x}\\). A feasible solution \\(\\bar{x}\\) whose objective value is maximum over all feasible solutions is an _optimal solution_, and we call its objective value \\(c^{\\rm T}\\bar{x}\\) the _optimal objective value_. If a linear program has no feasible solutions, we say that the linear program is _infeasible_, and otherwise, it is _feasible_. The set of points that satisfy all the constraints is the _feasible region_. If a linear program has some feasible solutions but does not have a finite optimal objective value, then the feasible region is _unbounded_ and so is the linear program. Exercise 29.1-5 asks you to show that a linear program can have a finite optimal objective value even if the feasible region is unbounded.\n\n### 29.1 Linear programming formulations and algorithms\n\nOne of the reasons for the power and popularity of linear programming is that linear programs can, in general, be solved efficiently. There are two classes of algorithms, known as ellipsoid algorithms and interior-point algorithms, that solve linear programs in polynomial time. In addition, the simplex algorithm is widely used. Although it does not run in polynomial time in the worst case, it tends to perform well in practice.\n\nWe will not give a detailed algorithm for linear programming, but will discuss a few important ideas. First, we will give an example of using a geometric procedure to solve a two-variable linear program. Although this example does not immediately generalize to an efficient algorithm for larger problems, it introduces some important concepts for linear programming and for optimization in general.\n\n#### A two-variable linear program\n\nLet us first consider the following linear program with two variables:\n\n\\[\\mbox{maximize}\\quad x_{1}\\ +\\quad x_{2} \\tag{29.17}\\]\n\nsubject to\n\n\\[4x_{1}\\ -\\quad x_{2}\\ \\leq\\quad 8 \\tag{29.18}\\] \\[2x_{1}\\ +\\quad x_{2}\\ \\leq\\ 10\\] (29.19) \\[5x_{1}\\ -\\ 2x_{2}\\ \\geq-2\\] (29.20) \\[x_{1},x_{2}\\ \\geq\\quad 0\\quad. \\tag{29.21}\\]\n\nFigure 29.2(a) graphs the constraints in the \\((x_{1},x_{2})\\)-Cartesian coordinate system. The feasible region in the two-dimensional space (highlighted in blue in the figure) is convex.1 Conceptually, you could evaluate the objective function \\(x_{1}+x_{2}\\) at each point in the feasible region, and then identify a point that has the maximum objective value as an optimal solution. For this example (and for most linear programs), however, the feasible region contains an infinite number of points, and so to solve this linear program, you need an efficient way to find a point that achieves the maximum objective value without explicitly evaluating the objective function at every point in the feasible region.\n\nFootnote 1: An intuitive definition of a convex region is that it fulfills the requirement that for any two points in the region, all points on a line segment between them are also in the region.\n\nIn two dimensions, you can optimize via a graphical procedure. The set of points for which \\(x_{1}+x_{2}=z,\\) for any \\(z\\), is a line with a slope of \\(-1\\). Plotting \\(x_{1}+x_{2}=0\\) produces the line with slope \\(-1\\) through the origin, as in Figure 29.2(b). The intersection of this line and the feasible region is the set of feasible solutions that have an objective value of \\(0\\). In this case, that intersection of the line with the feasible region is the single point \\((0,0)\\). More generally, for any value \\(z\\), theintersection of the line \\(x_{1}+x_{2}=z\\) and the feasible region is the set of feasible solutions that have objective value \\(z\\). Figure 29.2(b) shows the lines \\(x_{1}+x_{2}=0\\), \\(x_{1}+x_{2}=4\\), and \\(x_{1}+x_{2}=8\\). Because the feasible region in Figure 29.2 is bounded, there must be some maximum value \\(z\\) for which the intersection of the line \\(x_{1}+x_{2}=z\\) and the feasible region is nonempty. Any point in the feasible region that maximizes \\(x_{1}+x_{2}\\) is an optimal solution to the linear program, which in this case is the vertex of the feasible region at \\(x_{1}=2\\) and \\(x_{2}=6\\), with objective value \\(8\\).\n\nIt is no accident that an optimal solution to the linear program occurs at a vertex of the feasible region. The maximum value of \\(z\\) for which the line \\(x_{1}+x_{2}=z\\) intersects the feasible region must be on the boundary of the feasible region, and thus the intersection of this line with the boundary of the feasible region is either a single vertex or a line segment. If the intersection is a single vertex, then there is just one optimal solution, and it is that vertex. If the intersection is a line segment, every point on that line segment must have the same objective value. In particular, both endpoints of the line segment are optimal solutions. Since each endpoint of a line segment is a vertex, there is an optimal solution at a vertex in this case as well.\n\nAlthough you cannot easily graph linear programs with more than two variables, the same intuition holds. If you have three variables, then each constraint corresponds to a half-space in three-dimensional space. The intersection of these half-space is a half-space in three-dimensional space. The intersection of these half-space is a half-space in three-dimensional space.\n\nspaces forms the feasible region. The set of points for which the objective function obtains a given value \\(z\\) is now a plane (assuming no degenerate conditions). If all coefficients of the objective function are nonnegative, and if the origin is a feasible solution to the linear program, then as you move this plane away from the origin, in a direction normal to the objective function, you find points of increasing objective value. (If the origin is not feasible or if some coefficients in the objective function are negative, the intuitive picture becomes slightly more complicated.) As in two dimensions, because the feasible region is convex, the set of points that achieve the optimal objective value must include a vertex of the feasible region. Similarly, if you have \\(n\\) variables, each constraint defines a half-space in \\(n\\)-dimensional space. We call the feasible region formed by the intersection of these half-spaces a _simplex_. The objective function is now a hyperplane and, because of convexity, an optimal solution still occurs at a vertex of the simplex. Any algorithm for linear programming must also identify linear programs that have no solutions, as well as linear programs that have no finite optimal solution.\n\nThe _simplex algorithm_ takes as input a linear program and returns an optimal solution. It starts at some vertex of the simplex and performs a sequence of iterations. In each iteration, it moves along an edge of the simplex from a current vertex to a neighboring vertex whose objective value is no smaller than that of the current vertex (and usually is larger.) The simplex algorithm terminates when it reaches a local maximum, which is a vertex from which all neighboring vertices have a smaller objective value. Because the feasible region is convex and the objective function is linear, this local optimum is actually a global optimum. In Section 29.3, we'll see an important concept called \"duality,\" which we'll use to prove that the solution returned by the simplex algorithm is indeed optimal.\n\nThe simplex algorithm, when implemented carefully, often solves general linear programs quickly in practice. With some carefully contrived inputs, however, the simplex algorithm can require exponential time. The first polynomial-time algorithm for linear programming was the _ellipsoid algorithm_, which runs slowly in practice. A second class of polynomial-time algorithms are known as _interior-point methods_. In contrast to the simplex algorithm, which moves along the exterior of the feasible region and maintains a feasible solution that is a vertex of the simplex at each iteration, these algorithms move through the interior of the feasible region. The intermediate solutions, while feasible, are not necessarily vertices of the simplex, but the final solution is a vertex. For large inputs, interior-point algorithms can run as fast as, and sometimes faster than, the simplex algorithm. The chapter notes point you to more information about these algorithms.\n\nIf you add to a linear program the additional requirement that all variables take on integer values, you have an _integer linear program_. Exercise 34.5-3 on page 1098 asks you to show that just finding a feasible solution to this problem is NP-hard. Since no polynomial-time algorithms are known for any NP-hard prob lems, there is no known polynomial-time algorithm for integer linear programming. In contrast, a general linear-programming problem can be solved in polynomial time.\n\n**Exercises**\n\n_29.1-1_\n\nConsider the linear program\n\nminimize \\(\\;-2x_{1}\\;+\\;3x_{2}\\)\n\nsubject to\n\n\\(\\;x_{1}\\;+\\;\\;x_{2}\\;=\\;7\\)\n\n\\(\\;x_{1}\\;-\\;2x_{2}\\;\\leq\\;4\\)\n\n\\(\\;x_{1}\\;\\geq\\;0\\;\\;\\;.\\)\n\nGive three feasible solutions to this linear program. What is the objective value of each one?\n\n_29.1-2_\n\nConsider the following linear program, which has a nonpositivity constraint:\n\nminimize \\(\\;2x_{1}\\;+\\;7x_{2}\\;+\\;x_{3}\\)\n\nsubject to\n\n\\(\\;x_{1}\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\; \\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\; \\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\; \\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\; \\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\; \\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\; \\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\; \\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\; \\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\; \\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\; \\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\; \\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\; \\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\; \\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\; \\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\; \\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\; \\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\; \\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\; \\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\; \\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\; \\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\; \\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\; \\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\; \\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\; \\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\; \\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\; \\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\; \\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\; \\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\; \\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\; \\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\; \\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\; \\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\; \\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\; \n\n#### 29.1-4\n\nShow that the following linear program is unbounded:\n\n\\[\\begin{array}{rcccc}\\mbox{maximize}&x_{1}&-&x_{2}\\\\ \\mbox{subject to}&\\\\ &-2x_{1}&+&x_{2}&\\leq-1\\\\ &-x_{1}&-&2x_{2}&\\leq-2\\\\ &&x_{1},x_{2}&\\geq&0\\end{array}\\.\\]\n\n#### 29.1-5\n\nGive an example of a linear program for which the feasible region is not bounded, but the optimal objective value is finite.\n\n#### 29.1-6\n\nSometimes, in a linear program, you need to convert constraints from one form to another.\n\n_a._: Show how to convert an equality constraint into an equivalent set of inequalities. That is, given a constraint \\(\\sum_{j=1}^{n}a_{ij}x_{j}=b_{i}\\), give a set of inequalities that will be satisfied if and only if \\(\\sum_{j=1}^{n}a_{ij}x_{j}=b_{i}\\),\n\n_b._: Show how to convert an inequality constraint \\(\\sum_{j=1}^{n}a_{ij}x_{j}\\leq b_{i}\\) into an equality constraint and a nonnegativity constraint. You will need to introduce an additional variable \\(s\\), and use the constraint that \\(s\\geq 0\\).\n\n#### 29.1-7\n\nExplain how to convert a minimization linear program to an equivalent maximization linear program, and argue that your new linear program is equivalent to the original one.\n\n#### 29.1-8\n\nIn the political problem at the beginning of this chapter, there are feasible solutions that correspond to winning more voters than there actually are in the district. For example, you can set \\(x_{2}\\) to 200, \\(x_{3}\\) to 200, and \\(x_{1}=x_{4}=0\\). That solution is feasible, yet it seems to say that you will win 400,000 suburban voters, even though there are only 200,000 actual suburban voters. What constraints can you add to the linear program to ensure that you never seem to win more voters than there actually are? Even if you don't add these constraints, argue that the optimal solution to this linear program can never win more voters than there actually are in the district.\n\n### 29.2 Formulating problems as linear programs\n\nLinear programming has many applications. Any textbook on operations research is filled with examples of linear programming, and linear programming has become a standard tool taught to students in most business schools. The election scenario is one typical example. Here are two more examples:\n\n* An airline wishes to schedule its flight crews. The Federal Aviation Administration imposes several constraints, such as limiting the number of consecutive hours that each crew member can work and insisting that a particular crew work only on one model of aircraft during each month. The airline wants to schedule crews on all of its flights using as few crew members as possible.\n* An oil company wants to decide where to drill for oil. Siting a drill at a particular location has an associated cost and, based on geological surveys, an expected payoff of some number of barrels of oil. The company has a limited budget for locating new drills and wants to maximize the amount of oil it expects to find, given this budget.\n\nLinear programs also model and solve graph and combinatorial problems, such as those appearing in this book. We have already seen a special case of linear programming used to solve systems of difference constraints in Section 22.4. In this section, we'll study how to formulate several graph and network-flow problems as linear programs. Section 35.4 uses linear programming as a tool to find an approximate solution to another graph problem.\n\nPerhaps the most important aspect of linear programming is to be able to recognize when you can formulate a problem as a linear program. Once you cast a problem as a polynomial-sized linear program, you can solve it in polynomial time by the ellipsoid algorithm or interior-point methods. Several linear-programming software packages can solve problems efficiently, so that once the problem is in the form of a linear program, such a package can solve it.\n\nWe'll look at several concrete examples of linear-programming problems. We start with two problems that we have already studied: the single-source shortest-paths problem from Chapter 22 and the maximum-flow problem from Chapter 24. We then describe the minimum-cost-flow problem. (Although the minimum-cost-flow problem has a polynomial-time algorithm that is not based on linear programming, we won't describe the algorithm.) Finally, we describe the multicommodity-flow problem, for which the only known polynomial-time algorithm is based on linear programming.\n\nWhen we solved graph problems in Part VI, we used attribute notation, such as \\(v.d\\) and \\((u,v).f\\). Linear programs typically use subscripted variables rather than",
        "chapter": "Part VII Selected Topics",
        "section": "29 Linear Programming",
        "subsection": "29.1 Linear programming formulations and algorithms",
        "subsubsection": "N/A"
    },
    {
        "content": "### 29.2 Formulating problems as linear programs\n\nLinear programming has many applications. Any textbook on operations research is filled with examples of linear programming, and linear programming has become a standard tool taught to students in most business schools. The election scenario is one typical example. Here are two more examples:\n\n* An airline wishes to schedule its flight crews. The Federal Aviation Administration imposes several constraints, such as limiting the number of consecutive hours that each crew member can work and insisting that a particular crew work only on one model of aircraft during each month. The airline wants to schedule crews on all of its flights using as few crew members as possible.\n* An oil company wants to decide where to drill for oil. Siting a drill at a particular location has an associated cost and, based on geological surveys, an expected payoff of some number of barrels of oil. The company has a limited budget for locating new drills and wants to maximize the amount of oil it expects to find, given this budget.\n\nLinear programs also model and solve graph and combinatorial problems, such as those appearing in this book. We have already seen a special case of linear programming used to solve systems of difference constraints in Section 22.4. In this section, we'll study how to formulate several graph and network-flow problems as linear programs. Section 35.4 uses linear programming as a tool to find an approximate solution to another graph problem.\n\nPerhaps the most important aspect of linear programming is to be able to recognize when you can formulate a problem as a linear program. Once you cast a problem as a polynomial-sized linear program, you can solve it in polynomial time by the ellipsoid algorithm or interior-point methods. Several linear-programming software packages can solve problems efficiently, so that once the problem is in the form of a linear program, such a package can solve it.\n\nWe'll look at several concrete examples of linear-programming problems. We start with two problems that we have already studied: the single-source shortest-paths problem from Chapter 22 and the maximum-flow problem from Chapter 24. We then describe the minimum-cost-flow problem. (Although the minimum-cost-flow problem has a polynomial-time algorithm that is not based on linear programming, we won't describe the algorithm.) Finally, we describe the multicommodity-flow problem, for which the only known polynomial-time algorithm is based on linear programming.\n\nWhen we solved graph problems in Part VI, we used attribute notation, such as \\(v.d\\) and \\((u,v).f\\). Linear programs typically use subscripted variables rather thanobjects with attached attributes, however. Therefore, when we express variables in linear programs, we indicate vertices and edges through subscripts. For example, we denote the shortest-path weight for vertex \\(v\\) not by \\(v.d\\) but by \\(d_{v}\\), and we denote the flow from vertex \\(u\\) to vertex \\(v\\) not by \\((u,v)\\),\\(f\\) but by \\(f_{uv}\\). For quantities that are given as inputs to problems, such as edge weights or capacities, we continue to use notations such as \\(w(u,v)\\) and \\(c(u,v)\\).\n\n##### Shortest paths\n\nWe can formulate the single-source shortest-paths problem as a linear program. We'll focus on how to formulate the single-pair shortest-path problem, leaving the extension to the more general single-source shortest-paths problem as Exercise 29.2-2.\n\nIn the single-pair shortest-path problem, the input is a weighted, directed graph \\(G=(V,E)\\), with weight function \\(w:E\\to\\mathbb{R}\\) mapping edges to real-valued weights, a source vertex \\(s\\), and destination vertex \\(t\\). The goal is to compute the value \\(d_{t}\\), which is the weight of a shortest path from \\(s\\) to \\(t\\). To express this problem as a linear program, you need to determine a set of variables and constraints that define when you have a shortest path from \\(s\\) to \\(t\\). The triangle inequality (Lemma 22.10 on page 633) gives \\(d_{v}\\leq d_{u}+w(u,v)\\) for each edge \\((u,v)\\in E\\). The source vertex initially receives a value \\(d_{s}=0\\), which never changes. Thus the following linear program expresses the shortest-path weight from \\(s\\) to \\(t\\):\n\nmaximize \\[d_{t}\\] (29.22) subject to \\[d_{v} \\leq d_{u}+w(u,v)\\;\\;\\text{for each edge $(u,v)\\in E$}\\] (29.23) \\[d_{s} = 0\\;\\;.\\] (29.24)\n\nYou might be surprised that this linear program maximizes an objective function when it is supposed to compute shortest paths. Minimizing the objective function would be a mistake, because when all the edge weights are nonnegative, setting \\(\\tilde{d}_{v}=0\\) for all \\(v\\in V\\) (recall that a bar over a variable name denotes a specific setting of the variable's value) would yield an optimal solution to the linear program without solving the shortest-paths problem. Maximizing is the right thing to do because an optimal solution to the shortest-paths problem sets each \\(\\tilde{d}_{v}\\) to \\(\\min\\left\\{\\tilde{d}_{u}+w(u,v):u\\in V\\text{ and }(u,v)\\in E\\right\\}\\), so that \\(\\tilde{d}_{v}\\) is the largest value that is less than or equal to all of the values in the set \\(\\left\\{\\tilde{d}_{u}+w(u,v)\\right\\}\\). Therefore, it makes sense to maximize \\(d_{v}\\) for all vertices \\(v\\) on a shortest path from \\(s\\) to \\(t\\) subject to these constraints, and maximizing \\(d_{t}\\) achieves this goal.\n\nThis linear program has \\(|V|\\) variables \\(d_{v}\\), one for each vertex \\(v\\in V\\). It also has \\(|E|+1\\) constraints: one for each edge, plus the additional constraint that the source vertex's shortest-path weight always has the value \\(0\\).\n\n### Maximum flow\n\nNext, let's express the maximum-flow problem as a linear program. Recall that the input is a directed graph \\(G=(V,E)\\) in which each edge \\((u,v)\\in E\\) has a nonnegative capacity \\(c(u,v)\\geq 0\\), and two distinguished vertices: a source \\(s\\) and a sink \\(t\\). As defined in Section 24.1, a flow is a nonnegative real-valued function \\(f:V\\times V\\to\\mathbb{R}\\) that satisfies the capacity constraint and flow conservation. A maximum flow is a flow that satisfies these constraints and maximizes the flow value, which is the total flow coming out of the source minus the total flow into the source. A flow, therefore, satisfies linear constraints, and the value of a flow is a linear function. Recalling also that we assume that \\(c(u,v)=0\\) if \\((u,v)\\notin E\\) and that there are no antiparallel edges, the maximum-flow problem can be expressed as a linear program:\n\n\\[\\text{maximize}\\ \\ \\sum_{v\\in V}f_{sv}\\ -\\ \\sum_{v\\in V}f_{vs}\\] (29.25) subject to \\[f_{uv} \\ \\leq\\ c(u,v)\\ \\ \\text{for each}\\ u,v\\in V \\tag{29.26}\\] \\[\\sum_{v\\in V}f_{vu} \\ =\\ \\sum_{v\\in V}f_{uv}\\ \\ \\text{for each}\\ u\\in V-\\{s,t\\}\\] (29.27) \\[f_{uv} \\ \\geq\\ 0\\ \\ \\ \\ \\ \\ \\ \\ \\ \\text{for each}\\ u,v\\in V\\ . \\tag{29.28}\\]\n\nThis linear program has \\(\\left|V\\right|^{2}\\) variables, corresponding to the flow between each pair of vertices, and it has \\(2\\left|V\\right|^{2}+\\left|V\\right|-2\\) constraints.\n\nIt is usually more efficient to solve a smaller-sized linear program. The linear program in (29.25)-(29.28) has, for ease of notation, a flow and capacity of \\(0\\) for each pair of vertices \\(u,v\\) with \\((u,v)\\notin E\\). It is more efficient to rewrite the linear program so that it has \\(O(V\\ +\\ E)\\) constraints. Exercise 29.2-4 asks you to do so.\n\n### Minimum-cost flow\n\nIn this section, we have used linear programming to solve problems for which we already knew efficient algorithms. In fact, an efficient algorithm designed specifically for a problem, such as Dijkstra's algorithm for the single-source shortest-paths problem, will often be more efficient than linear programming, both in theory and in practice.\n\nThe real power of linear programming comes from the ability to solve new problems. Recall the problem faced by the politician in the beginning of this chapter. The problem of obtaining a sufficient number of votes, while not spending too much money, is not solved by any of the algorithms that we have studied in this book, yet it can be solved by linear programming. Books about with such real-world problems that linear programming can solve. Linear programming is alsoparticularly useful for solving variants of problems for which we may not already know of an efficient algorithm.\n\nConsider, for example, the following generalization of the maximum-flow problem. Suppose that, in addition to a capacity \\(c(u,v)\\) for each edge \\((u,v)\\), you are given a real-valued cost \\(a(u,v)\\). As in the maximum-flow problem, assume that \\(c(u,v)=0\\) if \\((u,v)\\notin E\\) and that there are no antiparallel edges. If you send \\(f_{uv}\\) units of flow over edge \\((u,v)\\), you incur a cost of \\(a(u,v)\\cdot f_{uv}\\). You are also given a flow demand \\(d\\). You wish to send \\(d\\) units of flow from \\(s\\) to \\(t\\) while minimizing the total cost \\(\\sum_{(u,v)\\in E}a(u,v)\\cdot f_{uv}\\) incurred by the flow. This problem is known as the _minimum-cost-flow problem_.\n\nFigure 29.3(a) shows an example of the minimum-cost-flow problem, with a goal of sending \\(4\\) units of flow from \\(s\\) to \\(t\\) while incurring the minimum total cost. Any particular legal flow, that is, a function \\(f\\) satisfying constraints (29.26)-(29.28), incurs a total cost of \\(\\sum_{(u,v)\\in E}a(u,v)\\cdot f_{uv}\\). What is the particular \\(4\\)-unit flow that minimizes this cost? Figure 29.3(b) shows an optimal solution, with total cost \\(\\sum_{(u,v)\\in E}a(u,v)\\cdot f_{uv}=(2\\cdot 2)+(5\\cdot 2)+(3\\cdot 1)+(7 \\cdot 1)+(1\\cdot 3)=27\\).\n\nThere are polynomial-time algorithms specifically designed for the minimum-cost-flow problem, but they are beyond the scope of this book. The minimum-cost-flow problem can be expressed as a linear program, however. The linear program looks similar to the one for the maximum-flow problem with the additional constraint that the value of the flow must be exactly \\(d\\) units, and with the new objective function of minimizing the cost:\n\nFigure 29.3: **(a)** An example of a minimum-cost-flow problem. Capacities are denoted by \\(c\\) and costs by \\(a\\). Vertex \\(s\\) is the source, and vertex \\(t\\) is the sink. The goal is to send \\(4\\) units of flow from \\(s\\) to \\(t\\). **(b)** A solution to the minimum-cost flow problem in which \\(4\\) units of flow are sent from \\(s\\) to \\(t\\). For each edge, the flow and capacity are written as flow/capacity.\n\n\\[\\text{minimize}\\ \\ \\sum_{(u,v)\\in E}a(u,v)\\cdot f_{uv}\\] (29.29) subject to \\[f_{uv} \\ \\leq\\ c(u,v)\\ \\ \\text{for each}\\ u,v\\in V\\] \\[\\sum_{v\\in V}f_{vu}-\\sum_{v\\in V}f_{uv} \\ =\\ 0\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\text{for each}\\ u\\in V-\\{s,t\\}\\] \\[\\sum_{v\\in V}f_{sv}-\\sum_{v\\in V}f_{vs} \\ =\\ d\\] \\[f_{uv} \\ \\geq\\ 0\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\text{for each}\\ u,v\\in V\\ . \\tag{29.30}\\]\n\n##### Multicommodity flow\n\nAs a final example, let's consider another flow problem. Suppose that the Lucky Puck company from Section 24.1 decides to diversify its product line and ship not only hockey pucks, but also hockey sticks and hockey helmets. Each piece of equipment is manufactured in its own factory, has its own warehouse, and must be shipped, each day, from factory to warehouse. The sticks are manufactured in Vancouver and are needed in Saskatoon, and the helmets are manufactured in Edmonton and must be shipped to Regina. The capacity of the shipping network does not change, however, and the different items, or _commodities_, must share the same network.\n\nThis example is an instance of a _multicommodity-flow problem_. The input to this problem is once again a directed graph \\(G=(V,E)\\) in which each edge \\((u,v)\\in E\\) has a nonnegative capacity \\(c(u,v)\\geq 0\\). As in the maximum-flow problem, implicitly assume that \\(c(u,v)=0\\) for \\((u,v)\\notin E\\) and that the graph has no antiparallel edges. In addition, there are \\(k\\) different commodities, \\(K_{1},K_{2},\\ldots,K_{k}\\), with commodity \\(i\\) specified by the triple \\(K_{i}=(s_{i},t_{i},d_{i})\\). Here, vertex \\(s_{i}\\) is the source of commodity \\(i\\), vertex \\(t_{i}\\) is the sink of commodity \\(i\\), and \\(d_{i}\\) is the demand for commodity \\(i\\), which is the desired flow value for the commodity from \\(s_{i}\\) to \\(t_{i}\\). We define a flow for commodity \\(i\\), denoted by \\(f_{i}\\), (so that \\(f_{i}{}_{uv}\\) is the flow of commodity \\(i\\) from vertex \\(u\\) to vertex \\(v\\)) to be a real-valued function that satisfies the flow-conservation and capacity constraints. We define \\(f_{uv}\\), the _aggregate flow_, to be the sum of the various commodity flows, so that \\(f_{uv}=\\sum_{i=1}^{k}f_{i}{}_{uv}\\). The aggregate flow on edge \\((u,v)\\) must be no more than the capacity of edge \\((u,v)\\). This problem has no objective function: the question is to determine whether such a flow exists. Thus the linear program for this problem has a \"null\" objective function:minimize 0 subject to\n\n\\[\\sum_{i=1}^{k}f_{iuv}\\ \\leq\\ c(u,v)\\ \\ \\mbox{for each}\\ u,v\\in V\\]\n\n\\[\\sum_{v\\in V}f_{iuv}-\\sum_{v\\in V}f_{ivu}\\ =\\ 0 \\mbox{for each}\\ i\\ =\\ 1,2,\\ldots,k\\ \\mbox{and}\\]\n\n\\[\\mbox{for each}\\ u\\in V-\\{s_{i},t_{i}\\}\\]\n\n\\[\\sum_{v\\in V}f_{i,s_{i},v}-\\sum_{v\\in V}f_{i,v,s_{i}}\\ =\\ d_{i} \\mbox{for each}\\ i\\ =\\ 1,2,\\ldots,k\\]\n\n\\[f_{iuv}\\ \\geq\\ 0 \\mbox{for each}\\ u,v\\in V\\ \\mbox{and}\\]\n\n\\[\\mbox{for each}\\ i\\ =\\ 1,2,\\ldots,k\\ \\.\\]\n\nThe only known polynomial-time algorithm for this problem expresses it as a linear program and then solves it with a polynomial-time linear-programming algorithm.\n\n##### Exercises\n\n##### 29.2-1\n\nWrite out explicitly the linear program corresponding to finding the shortest path from vertex \\(s\\) to vertex \\(x\\) in Figure 22.2(a) on page 29.\n\n##### 29.2-2\n\nGiven a graph \\(G\\), write a linear program for the single-source shortest-paths problem. The solution should have the property that \\(d_{v}\\) is the shortest-path weight from the source vertex \\(s\\) to \\(v\\) for each vertex \\(v\\in V\\).\n\n##### 29.2-3\n\nWrite out explicitly the linear program corresponding to finding the maximum flow in Figure 24.1(a).\n\n##### 29.2-4\n\nRewrite the linear program for maximum flow (29.25)-(29.28) so that it uses only \\(O(V\\ +\\ E)\\) constraints.\n\n##### 29.2-5\n\nWrite a linear program that, given a bipartite graph \\(G=(V,E)\\), solves the maximum-bipartite-matching problem.\n\n##### 29.2-6\n\nThere can be more than one way to model a particular problem as a linear program. This exercise gives an alternative formulation for the maximum-flow problem. Let \\(\\mathcal{P}\\ =\\ \\{P_{1},\\,P_{2},\\ldots,P_{p}\\}\\) be the set of _all_ possible directed simple paths from source to sink \\(t\\). Using decision variables \\(x_{1},\\ldots,x_{p}\\), where \\(x_{i}\\) is the amount of flow on path \\(i\\), formulate a linear program for the maximum-flow problem. What is an upper bound on \\(p\\), the number of directed simple paths from \\(s\\) to \\(t\\)?\n\n#### 29.2-7\n\nIn the _minimum-cost multicommodity-flow problem_, the input is a directed graph \\(G=(V,E)\\) in which each edge \\((u,v)\\in E\\) has a nonnegative capacity \\(c(u,v)\\geq 0\\) and a cost \\(a(u,v)\\). As in the multicommodity-flow problem, there are \\(k\\) different commodities, \\(K_{1},K_{2},\\ldots,K_{k}\\), with commodity \\(i\\) specified by the triple \\(K_{i}=(s_{i},t_{i},d_{i})\\). We define the flow \\(f_{i}\\) for commodity \\(i\\) and the aggregate flow \\(f_{uv}\\) on edge \\((u,v)\\) as in the multicommodity-flow problem. A feasible flow is one in which the aggregate flow on each edge \\((u,v)\\) is no more than the capacity of edge \\((u,v)\\). The cost of a flow is \\(\\sum_{u,v\\in V}a(u,v)\\cdot f_{uv}\\), and the goal is to find the feasible flow of minimum cost. Express this problem as a linear program.\n\n### Duality\n\nWe will now introduce a powerful concept called _linear-programming duality_. In general, given a maximization problem, duality allows you to formulate a related minimization problem that has the same objective value. The idea of duality is actually more general than linear programming, but we restrict our attention to linear programming in this section.\n\nDuality enables us to prove that a solution is indeed optimal. We saw an example of duality in Chapter 24 with Theorem 24.6, the max-flow min-cut theorem. Suppose that, given an instance of a maximum-flow problem, you find a flow \\(f\\) with value \\(|f|\\). How do you know whether \\(f\\) is a maximum flow? By the max-flow min-cut theorem, if you can find a cut whose value is also \\(|f|\\), then you have verified that \\(f\\) is indeed a maximum flow. This relationship provides an example of duality: given a maximization problem, define a related minimization problem such that the two problems have the same optimal objective values.\n\nGiven a linear program in standard form in which the objective is to maximize, let's see how to formulate a _dual_ linear program in which the objective is to minimize and whose optimal value is identical to that of the original linear program. When referring to dual linear programs, we call the original linear program the _primal_.\n\nGiven the primal linear program",
        "chapter": "Part VII Selected Topics",
        "section": "29 Linear Programming",
        "subsection": "29.2 Formulating problems as linear programs",
        "subsubsection": "N/A"
    },
    {
        "content": "to sink \\(t\\). Using decision variables \\(x_{1},\\ldots,x_{p}\\), where \\(x_{i}\\) is the amount of flow on path \\(i\\), formulate a linear program for the maximum-flow problem. What is an upper bound on \\(p\\), the number of directed simple paths from \\(s\\) to \\(t\\)?\n\n#### 29.2-7\n\nIn the _minimum-cost multicommodity-flow problem_, the input is a directed graph \\(G=(V,E)\\) in which each edge \\((u,v)\\in E\\) has a nonnegative capacity \\(c(u,v)\\geq 0\\) and a cost \\(a(u,v)\\). As in the multicommodity-flow problem, there are \\(k\\) different commodities, \\(K_{1},K_{2},\\ldots,K_{k}\\), with commodity \\(i\\) specified by the triple \\(K_{i}=(s_{i},t_{i},d_{i})\\). We define the flow \\(f_{i}\\) for commodity \\(i\\) and the aggregate flow \\(f_{uv}\\) on edge \\((u,v)\\) as in the multicommodity-flow problem. A feasible flow is one in which the aggregate flow on each edge \\((u,v)\\) is no more than the capacity of edge \\((u,v)\\). The cost of a flow is \\(\\sum_{u,v\\in V}a(u,v)\\cdot f_{uv}\\), and the goal is to find the feasible flow of minimum cost. Express this problem as a linear program.\n\n### Duality\n\nWe will now introduce a powerful concept called _linear-programming duality_. In general, given a maximization problem, duality allows you to formulate a related minimization problem that has the same objective value. The idea of duality is actually more general than linear programming, but we restrict our attention to linear programming in this section.\n\nDuality enables us to prove that a solution is indeed optimal. We saw an example of duality in Chapter 24 with Theorem 24.6, the max-flow min-cut theorem. Suppose that, given an instance of a maximum-flow problem, you find a flow \\(f\\) with value \\(|f|\\). How do you know whether \\(f\\) is a maximum flow? By the max-flow min-cut theorem, if you can find a cut whose value is also \\(|f|\\), then you have verified that \\(f\\) is indeed a maximum flow. This relationship provides an example of duality: given a maximization problem, define a related minimization problem such that the two problems have the same optimal objective values.\n\nGiven a linear program in standard form in which the objective is to maximize, let's see how to formulate a _dual_ linear program in which the objective is to minimize and whose optimal value is identical to that of the original linear program. When referring to dual linear programs, we call the original linear program the _primal_.\n\nGiven the primal linear program \\[\\sum_{j=1}^{n}c_{j}x_{j} \\tag{29.31}\\]\n\nsubject to\n\n\\[\\sum_{j=1}^{n}a_{ij}x_{j}\\ \\leq\\ b_{i}\\ \\ \\mbox{for}\\ i\\ =\\ 1,2,\\ldots,m \\tag{29.32}\\]\n\n\\[x_{j}\\ \\geq\\ 0\\ \\ \\mbox{for}\\ j\\ =\\ 1,2,\\ldots,n\\ \\, \\tag{29.33}\\]\n\nits dual is\n\nminimize \\[\\sum_{i=1}^{m}b_{i}\\,y_{i}\\] (29.34) subject to \\[\\sum_{i=1}^{m}a_{ij}\\,y_{i}\\ \\geq\\ c_{j}\\ \\ \\mbox{for}\\ j\\ =\\ 1,2,\\ldots,n\\] (29.35) \\[y_{i}\\ \\geq\\ 0\\ \\ \\mbox{for}\\ i\\ =\\ 1,2,\\ldots,m\\ \\.\\] (29.36)\n\nMechanically, to form the dual, change the maximization to a minimization, exchange the roles of coefficients on the right-hand sides and in the objective function, and replace each \\(\\leq\\) by \\(\\geq\\). Each of the \\(m\\) constraints in the primal corresponds to a variable \\(y_{i}\\) in the dual. Likewise, each of the \\(n\\) constraints in the dual corresponds to a variable \\(x_{j}\\) in the primal. For example, consider the following primal linear program:\n\nmaximize \\[3x_{1}\\ +\\ \\ x_{2}\\ +\\ 4x_{3}\\] (29.37) subject to \\[x_{1}\\ +\\ \\ x_{2}\\ +\\ 3x_{3}\\ \\leq\\ 30\\] (29.38) \\[2x_{1}\\ +\\ 2x_{2}\\ +\\ 5x_{3}\\ \\leq\\ 24\\] (29.39) \\[4x_{1}\\ +\\ \\ x_{2}\\ +\\ 2x_{3}\\ \\leq\\ 36\\] (29.40) \\[x_{1},x_{2},x_{3}\\ \\geq\\ 0\\ \\.\\] (29.41)\n\nIts dual is\n\nminimize \\[30y_{1}\\ +\\ 24y_{2}\\ +\\ 36y_{3}\\] (29.42) subject to \\[y_{1}\\ +\\ \\ 2y_{2}\\ +\\ \\ 4y_{3}\\ \\geq\\ 3\\] (29.43) \\[y_{1}\\ +\\ \\ 2y_{2}\\ +\\ \\ \\ \\ y_{3}\\ \\geq\\ 1\\] (29.44) \\[3y_{1}\\ +\\ \\ 5y_{2}\\ +\\ \\ 2y_{3}\\ \\geq\\ 4\\] (29.45) \\[y_{1},y_{2},y_{3}\\ \\geq\\ 0\\ \\.\\] (29.46)\n\nAlthough forming the dual can be considered a mechanical operation, there is an intuitive explanation. Consider the primal maximization problem (29.37)-(29.41). Each constraint gives an upper bound on the objective function. In addition, if you take one or more constraints and add together nonnegative multiples of them, you get a valid constraint. For example, you can add constraints (29.38) and (29.39) to obtain the constraint \\(3x_{1}+3x_{2}+8x_{3}\\leq 54\\). Any feasible solution to the primal must satisfy this new constraint, but there is something else interesting about it. Comparing this new constraint to the objective function (29.37), you can see that for each variable, the corresponding coefficient is at least as large as the coefficient in the objective function. Thus, since the variables \\(x_{1}\\), \\(x_{2}\\) and \\(x_{3}\\) are nonnegative, we have that\n\n\\[3x_{1}+x_{2}+4x_{3}\\ \\leq\\ 3x_{1}+3x_{2}+8x_{3}\\ \\leq\\ 54\\,\\]\n\nand so the solution value to the primal is at most 54. In other words, adding these two constraints together has generated an upper bound on the objective value.\n\nIn general, for any nonnegative multipliers \\(y_{1}\\), \\(y_{2}\\), and \\(y_{3}\\), you can generate a constraint\n\n\\[y_{1}(x_{1}+x_{2}+3x_{3})+y_{2}(2x_{1}+2x_{2}+5x_{3})+y_{3}(4x_{1}+x_{2}+2x_{3 })\\ \\leq\\ 30y_{1}+24y_{2}+36y_{3}\\]\n\nfrom the primal constraints or, by distributing and regrouping,\n\n\\[(y_{1}+2y_{2}+4y_{3})x_{1}+(y_{1}+2y_{2}+y_{3})x_{2}+(3y_{1}+5y_{2}+2y_{3})x_{ 3}\\ \\leq\\ 30y_{1}+24y_{2}+36y_{3}\\.\\]\n\nNow, as long as this constraint has coefficients of \\(x_{1}\\), \\(x_{2}\\), and \\(x_{3}\\) that are at least their objective-function coefficients, it is a valid upper bound. That is, as long as\n\n\\[y_{1}\\ +\\ 2y_{2}\\ +\\ 4y_{3}\\ \\geq\\ 3\\,\\] \\[y_{1}\\ +\\ 2y_{2}\\ +\\ \\ \\ y_{3}\\ \\geq\\ 1\\,\\] \\[3y_{1}\\ +\\ 5y_{2}\\ +\\ 2y_{3}\\ \\geq\\ 4\\,\\]\n\nyou have a valid upper bound of \\(30y_{1}+24y_{2}+36y_{3}\\). The multipliers \\(y_{1}\\), \\(y_{2}\\), and \\(y_{3}\\) must be nonnegative, because otherwise you cannot combine the inequalities. Of course, you would like the upper bound to be as small as possible, and so you want to choose \\(y\\) to minimize \\(30y_{1}+24y_{2}+36y_{3}\\). Observe that we have just described the dual linear program as the problem of finding the smallest possible upper bound on the primal.\n\nWe'll formalize this idea and show in Theorem 29.4 that, if the linear program and its dual are feasible and bounded, then the optimal value of the dual linear program is always equal to the optimal value of the primal linear program. We begin by demonstrating _weak duality_, which states that any feasible solution to the primal linear program has a value no greater than that of any feasible solution to the dual linear program.\n\n**Lemma 29.1** (Weak linear-programming duality): _Let \\(\\bar{x}\\) be any feasible solution to the primal linear program in (29.31)-(29.33), and let \\(\\bar{y}\\) be any feasible solution to its dual linear program in (29.34)-(29.36). Then_\\[\\sum_{j=1}^{n}c_{j}\\bar{x}_{j}\\,\\leq\\,\\sum_{i=1}^{m}b_{i}\\,\\bar{y}_{i}\\.\\]\n\n_Proof_ We have\n\n\\[\\sum_{j=1}^{n}c_{j}\\bar{x}_{j} \\leq\\,\\sum_{j\\,=1}^{n}\\Bigg{(}\\sum_{i=1}^{m}a_{ij}\\,\\bar{y}_{i} \\Bigg{)}\\,\\bar{x}_{j}\\quad\\mbox{(by inequalities (\\ref{eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq: eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq: eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eqeq:eq:eq:eq:eq:eqeq:eq:eq:eq:eq:eq:eq:eqeq:eq:eqeq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eqeq:eq:eq:eq:eq:eqeq:eq:eq:eq:eq:eq:eq:eqeq:eqeq:eq:eqeq:eq:eq:eq:eqeq:eq:eqeq:eq:eqeq:eqeq:eq:eqeq:eqeq:eq:eqeq:eqeq:eqeq:eqeq:eqeq:eqeq:eq:eqeqeq:eq:eqeq:eqeq:eqeq:eqeqeq:eq:eqeq:eqeq:eqeq:eqeq:eq:eqeq:eqeqeq:eqeq:eqeq:eqeq:eqeqeq:eqeq:eqeq:eqeqeq:eqeq:eqeq:eqeq:eqeq:eqeqeq:eqeq:eqeq:eqeqeq:eqeq:eqeqeq:eqeq:eqeqeq:eqeq:eqeqeq:eqeqeq:eqeqeq:eqeqeq:eqeqeq:eqeq:eqeqeq:eqeqeq:eqeqeq:eqeqeq:eqeq:eqeqeq:eqeq:eqeqeq:eqeqeq:eqeqeq:eqeqeq:eqeqeq:eqeq:eqeqeq:eqeqeq:eqeqeqeq:eqeqeq:eqeq:eqeqeq:eqeqeq:eqeqeqeq:eqeqeqeq:eqeqeq:eqeqeqeq:eqeqeq:eqeqeq:eqeqeq:eqeqeqeqeq:eqeqeqeq:eqeqeqeq:eqeqeqeq:eqeqeqeq:eqeqeqeq:eqeqeq:eqeqeq:eqeqeq:eqeqeq:eqeqeqeq:eqeqeqeq:eqeq:eqeqeqeq:eqeqeqeqeq:eqeqeqeq:eqeqeq:eqeqeq:eqeqeqeq:eqeqeqeq:eqeqeqeq:eqeqeq:eqeqeq:eqeqeqeq:eqeqeqeqeq:eqeqeqeqeq:eqeqeqeq:eqeqeqeqeq:eqeqeqeq:eqeqeqeqeq:eqeqeqeq:eqeqeqeq:eqeqeq:eqeqeqeqeq:eqeqeqeqeq:eqeqeqeqeq:eqeqeqeq:eqeqeqeqeq:eqeqeqeqeq:eqeqeqeqeqeqeq:eqeqeqeqeqeq:eqeqeqeqeqeqeq:eqeqeqeqeqeq:eqeqeqeqeqeq:eqeqeqeq:eqeqeqeq:eqeqeqeqeqeq:eqeqeqeqeqeq:eqeqeqeqeq:eqeqeqeqeqeq:eqeqeqeqeq:eqeqeqeqeqeqeq:eqeqeqeqeqeq:eqeqeqeqeqeq:eqeqeqeqeqeq:eqeqeqeqeqeq:eqeqeqeqeqeq:eqeqeqeq:eqeqeqeqeqeqeq:eqeqeqeqeqeq:eqeqeqeqeqeqeq:eqeqeqeqeqeqeq:eqeqeqeqeqeqeq:eqeqeqeqeqeq:eqeqeqeqeqeqeq:eqeqeqeqeqeq:eqeqeqeqeqeqeq:eqeqeqeqeqeqeq:eqeqeqeqeqeqeqeqeq:eqeqeqeqeqeqeqeqeqeq:eq\n\n**Theorem 29.4** (Linear-programming duality): _Given the primal linear program in (29.31)-(29.33) and its corresponding dual in (29.34)-(29.36), if both are feasible and bounded, then for optimal solutions \\(x^{*}\\) and \\(y^{*}\\), we have \\(c^{\\rm T}x^{*}=b^{\\rm T}y^{*}\\)._\n\n_Proof_ Let \\(\\mu=b^{\\rm T}y^{*}\\) be the optimal value of the dual linear program given in (29.34)-(29.36). Consider an augmented set of primal constraints in which we add a constraint to (29.31)-(29.33) that the objective value is at least \\(\\mu\\). We write out this _augmented primal_ as\n\n\\[Ax\\ \\leq\\ b\\, \\tag{29.47}\\] \\[c^{\\rm T}x\\ \\geq\\ \\mu. \\tag{29.48}\\]\n\nWe can multiply (29.48) through by \\(-1\\) and rewrite (29.47)-(29.48) as\n\n\\[\\left(\\begin{array}{c}A\\\\ -c^{\\rm T}\\end{array}\\right)x\\ \\leq\\left(\\begin{array}{c}b\\\\ -\\mu\\end{array}\\right). \\tag{29.49}\\]\n\nHere, \\(\\left(\\begin{array}{c}A\\\\ -c^{\\rm T}\\end{array}\\right)\\) denotes an \\((m+1)\\times n\\) matrix, \\(x\\) is an \\(n\\)-vector, and \\(\\left(\\begin{array}{c}b\\\\ -\\mu\\end{array}\\right)\\) denotes an \\((m+1)\\)-vector.\n\nWe claim that if there is a feasible solution \\(\\bar{x}\\) to the augmented primal, then the theorem is proved. To establish this claim, observe that \\(\\bar{x}\\) is also a feasible solution to the original primal and that it has objective value at least \\(\\mu\\). We can then apply Lemma 29.1, which states that the objective value of the primal is at most \\(\\mu\\), to complete the proof of the theorem.\n\nIt therefore remains to show that the augmented primal has a feasible solution. Suppose, for the purpose of contradiction, that the augmented primal is infeasible, which means that there is no \\(v\\in\\mathbb{R}^{n}\\) such that \\(\\left(\\begin{array}{c}A\\\\ -c^{\\rm T}\\end{array}\\right)v\\ \\leq\\ \\left(\\begin{array}{c}b\\\\ -\\mu\\end{array}\\right)\\). We can apply Farkas's lemma, Lemma 29.3, to inequalty (29.49) with\n\n\\[M=\\left(\\begin{array}{c}A\\\\ -c^{\\rm T}\\end{array}\\right)\\ \\mbox{and}\\ \\ g=\\left(\\begin{array}{c}b\\\\ -\\mu\\end{array}\\right)\\.\\]\n\nBecause the augmented primal is infeasible, condition 1 of Farkas's lemma does not hold. Therefore, condition 2 must apply, so that there must exist a \\(w\\in\\mathbb{R}^{m+1}\\) such that \\(w\\geq 0\\), \\(w^{\\rm T}M=0\\), and \\(w^{\\rm T}g<0\\). Let's write \\(w\\) as \\(w=\\left(\\begin{array}{c}\\bar{y}\\\\ \\lambda\\end{array}\\right)\\) for some \\(\\bar{y}\\in\\mathbb{R}^{m}\\) and \\(\\lambda\\in\\mathbb{R}\\), where \\(\\bar{y}\\geq 0\\) and \\(\\lambda\\geq 0\\). Substituting for \\(w\\), \\(M\\), and \\(g\\) in condition 2 gives\n\n\\[\\left(\\begin{array}{c}\\bar{y}\\\\ \\lambda\\end{array}\\right)^{\\rm T}\\!\\!\\left(\\begin{array}{c}A\\\\ -c^{\\rm T}\\end{array}\\right)=0\\ \\ \\mbox{and}\\ \\left(\\begin{array}{c}\\bar{y}\\\\ \\lambda\\end{array}\\right)^{\\rm T}\\!\\!\\left(\\begin{array}{c}b\\\\ -\\mu\\end{array}\\right)<0\\.\\]\n\n### Duality\n\nUnpacking the matrix notation gives\n\n\\[\\bar{y}^{\\rm T}A-\\lambda c^{\\rm T}=0\\;\\;{\\rm and}\\;\\;\\bar{y}^{\\rm T}b-\\lambda\\mu<0\\;. \\tag{29.50}\\]\n\nWe now show that the requirements in (29.50) contradict the assumption that \\(\\mu\\) is the optimal solution value for the dual linear program. We consider two cases.\n\nThe first case is when \\(\\lambda=0\\). In this case, (29.50) simplifies to\n\n\\[\\bar{y}^{\\rm T}A=0\\;\\;{\\rm and}\\;\\;\\bar{y}^{\\rm T}b<0\\;. \\tag{29.51}\\]\n\nWe'll now construct a dual feasible solution \\(y^{\\prime}\\) with an objective value smaller than \\(b^{\\rm T}y^{\\star}\\). Set \\(y^{\\prime}=y^{\\star}+\\epsilon\\,\\bar{y}\\), for any \\(\\epsilon>0\\). Since\n\n\\[y^{\\prime}{}^{\\rm T}A = (y^{\\star}+\\epsilon\\,\\bar{y})^{\\rm T}A\\] \\[= y^{\\star}{}^{\\rm T}A+\\epsilon\\,\\bar{y}^{\\rm T}A\\] \\[= y^{\\star}{}^{\\rm T}A\\qquad\\qquad\\quad({\\rm by}\\ (\\ref{eq:y1}))\\] \\[\\geq c^{\\rm T}\\qquad\\qquad\\qquad\\quad({\\rm because}\\ y^{\\star}\\ {\\rm is \\ feasible})\\,\\]\n\n\\(y^{\\prime}\\) is feasible. Now consider the objective value\n\n\\[b^{\\rm T}y^{\\prime} = b^{\\rm T}(y^{\\star}+\\epsilon\\,\\bar{y})\\] \\[= b^{\\rm T}y^{\\star}+\\epsilon\\,b^{\\rm T}\\bar{y}\\] \\[< b^{\\rm T}y^{\\star}\\,\\]\n\nwhere the last inequality follows because \\(\\epsilon>0\\) and, by (29.51), \\(\\bar{y}^{\\rm T}b=b^{\\rm T}\\bar{y}<0\\) (since both \\(\\bar{y}^{\\rm T}b\\) and \\(b^{\\rm T}\\bar{y}\\) are the inner product of \\(b\\) and \\(\\bar{y}\\)), and so their product is negative. Thus we have a feasible dual solution of value less than \\(\\mu\\), which contradicts \\(\\mu\\) being the optimal objective value.\n\nWe now consider the second case, where \\(\\lambda>0\\). In this case, we can take (29.50) and divide through by \\(\\lambda\\) to obtain\n\n\\[(\\bar{y}^{\\rm T}/\\lambda)A-(\\lambda/\\lambda)c^{\\rm T}=0\\;\\;{\\rm and}\\;\\;(\\bar {y}^{\\rm T}/\\lambda)b-(\\lambda/\\lambda)\\mu<0\\;. \\tag{29.52}\\]\n\nNow set \\(y^{\\prime}=\\bar{y}/\\lambda\\) in (29.52), giving\n\n\\[y^{\\prime}{}^{\\rm T}A=c^{\\rm T}\\;\\;{\\rm and}\\;\\;y^{\\prime}{}^{\\rm T}b<\\mu\\;.\\]\n\nThus, \\(y^{\\prime}\\) is a feasible dual solution with objective value strictly less than \\(\\mu\\), a contradiction. We conclude that the augmented primal has a feasible solution, and the theorem is proved.\n\n### Fundamental theorem of linear programming\n\nWe conclude this chapter by stating the fundamental theorem of linear programming, which extends Theorem 29.4 to the cases when the linear program may be either feasible or unbounded. Exercise 29.3-8 asks you to provide the proof.\n\n**Theorem 29.5** (Fundamental theorem of linear programming): Any linear program, given in standard form, either\n\n1. has an optimal solution with a finite objective value,\n2. is infeasible, or\n3. is unbounded.\n\n**Exercises**\n\n_29.3-1_\n\nFormulate the dual of the linear program given in lines (29.6)-(29.10) on page 852.\n\n_29.3-2_\n\nYou have a linear program that is not in standard form. You could produce the dual by first converting it to standard form, and then taking the dual. It would be more convenient, however, to produce the dual directly. Explain how to directly take the dual of an arbitrary linear program.\n\n_29.3-3_\n\nWrite down the dual of the maximum-flow linear program, as given in lines (29.25)-(29.28) on page 862. Explain how to interpret this formulation as a minimum-cut problem.\n\n_29.3-4_\n\nWrite down the dual of the minimum-cost-flow linear program, as given in lines (29.29)-(29.30) on page 864. Explain how to interpret this problem in terms of graphs and flows.\n\n_29.3-5_\n\nShow that the dual of the dual of a linear program is the primal linear program.\n\n_29.3-6_\n\nWhich result from Chapter 24 can be interpreted as weak duality for the maximum-flow problem?\n\n_29.3-7_\n\nConsider the following 1-variable primal linear program:\n\nmaximize \\[tx\\] subject to \\[rx\\ \\leq\\ s\\] \\[x\\ \\geq\\ 0\\,\\]where \\(r\\), \\(s\\), and \\(t\\) are arbitrary real numbers. State for which values of \\(r\\), \\(s\\), and \\(t\\) you can assert that\n\n1. Both the primal linear program and its dual have optimal solutions with finite objective values.\n2. The primal is feasible, but the dual is infeasible.\n3. The dual is feasible, but the primal is infeasible.\n4. Neither the primal nor the dual is feasible.\n\n#### 29.3-8\n\nProve the fundamental theorem of linear programming, Theorem 29.5.\n\n## Problems\n\n### Linear-inequality feasibility\n\nGiven a set of \\(m\\) linear inequalities on \\(n\\) variables \\(x_{1},x_{2},\\ldots,x_{n}\\), the _linear-inequality feasibility problem_ asks whether there is a setting of the variables that simultaneously satisfies each of the inequalities.\n\n1. Given an algorithm for the linear-programming problem, show how to use it to solve a linear-inequality feasibility problem. The number of variables and constraints that you use in the linear-programming problem should be polynomial in \\(n\\) and \\(m\\).\n2. Given an algorithm for the linear-inequality feasibility problem, show how to use it to solve a linear-programming problem. The number of variables and linear inequalities that you use in the linear-inequality feasibility problem should be polynomial in \\(n\\) and \\(m\\), the number of variables and constraints in the linear program.\n\n### Complementary slackness\n\ndescribes a relationship between the values of primal variables and dual constraints and between the values of dual variables and primal constraints. Let \\(\\bar{x}\\) be a feasible solution to the primal linear program given in (29.31)-(29.33), and let \\(\\bar{y}\\) be a feasible solution to the dual linear program given in (29.34)-(29.36). Complementary slackness states that the following conditions are necessary and sufficient for \\(\\bar{x}\\) and \\(\\bar{y}\\) to be optimal:",
        "chapter": "Part VII Selected Topics",
        "section": "29 Linear Programming",
        "subsection": "29.3 Duality",
        "subsubsection": "N/A"
    },
    {
        "content": "where \\(r\\), \\(s\\), and \\(t\\) are arbitrary real numbers. State for which values of \\(r\\), \\(s\\), and \\(t\\) you can assert that\n\n1. Both the primal linear program and its dual have optimal solutions with finite objective values.\n2. The primal is feasible, but the dual is infeasible.\n3. The dual is feasible, but the primal is infeasible.\n4. Neither the primal nor the dual is feasible.\n\n#### 29.3-8\n\nProve the fundamental theorem of linear programming, Theorem 29.5.\n\n## Problems\n\n### Linear-inequality feasibility\n\nGiven a set of \\(m\\) linear inequalities on \\(n\\) variables \\(x_{1},x_{2},\\ldots,x_{n}\\), the _linear-inequality feasibility problem_ asks whether there is a setting of the variables that simultaneously satisfies each of the inequalities.\n\n1. Given an algorithm for the linear-programming problem, show how to use it to solve a linear-inequality feasibility problem. The number of variables and constraints that you use in the linear-programming problem should be polynomial in \\(n\\) and \\(m\\).\n2. Given an algorithm for the linear-inequality feasibility problem, show how to use it to solve a linear-programming problem. The number of variables and linear inequalities that you use in the linear-inequality feasibility problem should be polynomial in \\(n\\) and \\(m\\), the number of variables and constraints in the linear program.\n\n### Complementary slackness\n\ndescribes a relationship between the values of primal variables and dual constraints and between the values of dual variables and primal constraints. Let \\(\\bar{x}\\) be a feasible solution to the primal linear program given in (29.31)-(29.33), and let \\(\\bar{y}\\) be a feasible solution to the dual linear program given in (29.34)-(29.36). Complementary slackness states that the following conditions are necessary and sufficient for \\(\\bar{x}\\) and \\(\\bar{y}\\) to be optimal:\\[\\sum_{i=1}^{m}a_{ij}\\,\\bar{y}_{i}\\,=\\,c_{j}\\,\\,\\,\\,\\mbox{or}\\,\\,\\,\\,\\bar{x}_{j}\\,= \\,0\\,\\,\\,\\,\\,\\,\\mbox{for}\\,\\,j\\,=\\,1,2,\\ldots,n\\]\n\nand\n\n\\[\\sum_{j=1}^{n}a_{ij}\\,\\bar{x}_{j}\\,=\\,b_{i}\\,\\,\\,\\,\\mbox{or}\\,\\,\\,\\,\\bar{y}_{i}\\, =\\,0\\,\\,\\,\\,\\,\\mbox{for}\\,\\,i\\,=\\,1,2,\\ldots,m\\,\\,.\\]\n\n**a.**: Verify that complementary slackness holds for the linear program in lines (29.37)-(29.41).\n**b.**: Prove that complementary slackness holds for any primal linear program and its corresponding dual.\n**c.**: Prove that a feasible solution \\(\\bar{x}\\) to a primal linear program given in lines (29.31)-(29.33) is optimal if and only if there exist values \\(\\,\\bar{y}\\,=\\,(\\bar{y}_{1},\\bar{y}_{2},\\ldots,\\bar{y}_{m})\\) such that\n\n1. \\(\\bar{y}\\) is a feasible solution to the dual linear program given in (29.34)-(29.36),\n2. \\(\\sum_{i=1}^{m}a_{ij}\\,\\bar{y}_{i}\\,=\\,c_{j}\\) for all \\(j\\) such that \\(\\bar{x}_{j}\\,>\\,0\\), and\n3. \\(\\bar{y}_{i}\\,=\\,0\\) for all \\(i\\) such that \\(\\sum_{j=1}^{n}a_{ij}\\,\\bar{x}_{j}\\,<\\,b_{i}\\,\\).\n\n_29-3 Integer linear programming_\n\nAn _integer linear-programming problem_ is a linear-programming problem with the additional constraint that the variables \\(x\\) must take on integer values. Exercise 34.5-3 on page 1098 shows that just determining whether an integer linear program has a feasible solution is NP-hard, which means that there is no known polynomial-time algorithm for this problem.\n\n**a.**: Show that weak duality (Lemma 29.1) holds for an integer linear program.\n**b.**: Show that duality (Theorem 29.4) does not always hold for an integer linear program.\n**c.**: Given a primal linear program in standard form, let \\(P\\) be the optimal objective value for the primal linear program, \\(D\\) be the optimal objective value for its dual, \\(IP\\) be the optimal objective value for the integer version of the primal (that is, the primal with the added constraint that the variables take on integer values), and \\(ID\\) be the optimal objective value for the integer version of the dual. Assuming that both the primal integer program and the dual integer program are feasible and bounded, show that\n\n\\[IP\\,\\leq\\,P\\,=\\,D\\,\\leq\\,ID\\,\\,.\\]\n\n#### 29-4 Farkas's lemma\n\nProve Farkas's lemma, Lemma 29.3.\n\n#### 29-5 Minimum-cost circulation\n\nThis problem considers a variant of the minimum-cost-flow problem from Section 29.2 in which there is no demand, source, or sink. Instead, the input, as before, contains a flow network, capacity constraints \\(c(u,v)\\), and edge costs \\(a(u,v)\\). A flow is feasible if it satisfies the capacity constraint on every edge and flow conservation at _every_ vertex. The goal is to find, among all feasible flows, the one of minimum cost. We call this problem the _minimum-cost-circulation problem_.\n\n* Formulate the minimum-cost-circulation problem as a linear program.\n* Suppose that for all edges \\((u,v)\\in E\\), we have \\(a(u,v){>}0\\). What does an optimal solution to the minimum-cost-circulation problem look like?\n* Formulate the maximum-flow problem as a minimum-cost-circulation problem linear program. That is, given a maximum-flow problem instance \\(G=(V,E)\\) with source \\(s\\), sink \\(t\\) and edge capacities \\(c\\), create a minimum-cost-circulation problem by giving a (possibly different) network \\(G^{\\prime}=(V^{\\prime},E^{\\prime})\\) with edge capacities \\(c^{\\prime}\\) and edge costs \\(a^{\\prime}\\) such that you can derive a solution to the maximum-flow problem from a solution to the minimum-cost-circulation problem.\n* Formulate the single-source shortest-path problem as a minimum-cost-circulation problem linear program.\n\n## Chapter notes\n\nThis chapter only begins to study the wide field of linear programming. A number of books are devoted exclusively to linear programming, including those by Chvatal [94], Gass [178], Karloff [246], Schrijver [398], and Vanderbei [444]. Many other books give a good coverage of linear programming, including those by Papadimitriou and Steiglitz [353] and Ahuja, Magnanti, and Orlin [7]. The coverage in this chapter draws on the approach taken by Chvatal.\n\nThe simplex algorithm for linear programming was invented by G. Dantzig in 1947. Shortly after, researchers discovered how to formulate a number of problems in a variety of fields as linear programs and solve them with the simplex algorithm. As a result, applications of linear programming flourished, along with several algorithms. Variants of the simplex algorithm remain the most popular",
        "chapter": "Part VII Selected Topics",
        "section": "29 Linear Programming",
        "subsection": "Problems",
        "subsubsection": "N/A"
    },
    {
        "content": "#### 29-4 Farkas's lemma\n\nProve Farkas's lemma, Lemma 29.3.\n\n#### 29-5 Minimum-cost circulation\n\nThis problem considers a variant of the minimum-cost-flow problem from Section 29.2 in which there is no demand, source, or sink. Instead, the input, as before, contains a flow network, capacity constraints \\(c(u,v)\\), and edge costs \\(a(u,v)\\). A flow is feasible if it satisfies the capacity constraint on every edge and flow conservation at _every_ vertex. The goal is to find, among all feasible flows, the one of minimum cost. We call this problem the _minimum-cost-circulation problem_.\n\n* Formulate the minimum-cost-circulation problem as a linear program.\n* Suppose that for all edges \\((u,v)\\in E\\), we have \\(a(u,v){>}0\\). What does an optimal solution to the minimum-cost-circulation problem look like?\n* Formulate the maximum-flow problem as a minimum-cost-circulation problem linear program. That is, given a maximum-flow problem instance \\(G=(V,E)\\) with source \\(s\\), sink \\(t\\) and edge capacities \\(c\\), create a minimum-cost-circulation problem by giving a (possibly different) network \\(G^{\\prime}=(V^{\\prime},E^{\\prime})\\) with edge capacities \\(c^{\\prime}\\) and edge costs \\(a^{\\prime}\\) such that you can derive a solution to the maximum-flow problem from a solution to the minimum-cost-circulation problem.\n* Formulate the single-source shortest-path problem as a minimum-cost-circulation problem linear program.\n\n## Chapter notes\n\nThis chapter only begins to study the wide field of linear programming. A number of books are devoted exclusively to linear programming, including those by Chvatal [94], Gass [178], Karloff [246], Schrijver [398], and Vanderbei [444]. Many other books give a good coverage of linear programming, including those by Papadimitriou and Steiglitz [353] and Ahuja, Magnanti, and Orlin [7]. The coverage in this chapter draws on the approach taken by Chvatal.\n\nThe simplex algorithm for linear programming was invented by G. Dantzig in 1947. Shortly after, researchers discovered how to formulate a number of problems in a variety of fields as linear programs and solve them with the simplex algorithm. As a result, applications of linear programming flourished, along with several algorithms. Variants of the simplex algorithm remain the most popularmethods for solving linear-programming problems. This history appears in a number of places, including the notes in [94] and [246].\n\nThe ellipsoid algorithm was the first polynomial-time algorithm for linear programming and is due to L. G. Khachian in 1979. It was based on earlier work by N. Z. Shor, D. B. Judin, and A. S. Nemirovskii. Grotschel, Lovasz, and Schrijver [201] describe how to use the ellipsoid algorithm to solve a variety of problems in combinatorial optimization. To date, the ellipsoid algorithm does not appear to be competitive with the simplex algorithm in practice.\n\nKarmarkar's paper [247] includes a description of the first interior-point algorithm. Many subsequent researchers designed interior-point algorithms. Good surveys appear in the article of Goldfarb and Todd [189] and the book by Ye [463].\n\nAnalysis of the simplex algorithm remains an active area of research. V. Klee and G. J. Minty constructed an example on which the simplex algorithm runs through \\(2^{n}-1\\) iterations. The simplex algorithm usually performs well in practice, and many researchers have tried to give theoretical justification for this empirical observation. A line of research begun by K. H. Borgwardt, and carried on by many others, shows that under certain probabilistic assumptions on the input, the simplex algorithm converges in expected polynomial time. Spielman and Teng [421] made progress in this area, introducing the \"smoothed analysis of algorithms\" and applying it to the simplex algorithm.\n\nThe simplex algorithm is known to run efficiently in certain special cases. Particularly noteworthy is the network-simplex algorithm, which is the simplex algorithm, specialized to network-flow problems. For certain network problems, including the shortest-paths, maximum-flow, and minimum-cost-flow problems, variants of the network-simplex algorithm run in polynomial time. See, for example, the article by Orlin [349] and the citations therein.\n\n## Chapter 3 Polynomials and the FFT\n\nThe straightforward method of adding two polynomials of degree \\(n\\) takes \\(\\Theta(n)\\) time, but the straightforward method of multiplying them takes \\(\\Theta(n^{2})\\) time. This chapter will show how the fast Fourier transform, or FFT, can reduce the time to multiply polynomials to \\(\\Theta(n\\lg n)\\).\n\nThe most common use for Fourier transforms, and hence the FFT, is in signal processing. A signal is given in the _time domain_: as a function mapping time to amplitude. Fourier analysis expresses the signal as a weighted sum of phase-shifted sinusoids of varying frequencies. The weights and phases associated with the frequencies characterize the signal in the _frequency domain_. Among the many everyday applications of FFT's are compression techniques used to encode digital video and audio information, including MP3 files. Many fine books delve into the rich area of signal processing, and the chapter notes reference a few of them.\n\n### Polynomials\n\nA _polynomial_ in the variable \\(x\\) over an algebraic field \\(F\\) represents a function \\(A(x)\\) as a formal sum:\n\n\\[A(x)=\\sum_{j=0}^{n-1}a_{j}x^{j}\\.\\]\n\nThe values \\(a_{0},a_{1},\\ldots,a_{n-1}\\) are the _coefficients_ of the polynomial. The coefficients and \\(x\\) are drawn from a field \\(F\\), typically the set \\(\\mathbb{C}\\) of complex numbers. A polynomial \\(A(x)\\) has _degree_\\(k\\) if its highest nonzero coefficient is \\(a_{k}\\), in which case we say that \\(\\text{degree}\\,(A)=k\\). Any integer strictly greater than the degree of a polynomial is a _degree-bound_ of that polynomial. Therefore, the degree of a polynomial of degree-bound \\(n\\) may be any integer between \\(0\\) and \\(n-1\\), inclusive.\n\nA variety of operations extend to polynomials. For _polynomial addition_, if \\(A(x)\\) and \\(B(x)\\) are polynomials of degree-bound \\(n\\), their _sum_ is a polynomial \\(C(x)\\), also",
        "chapter": "Part VII Selected Topics",
        "section": "29 Linear Programming",
        "subsection": "Chapter notes",
        "subsubsection": "N/A"
    },
    {
        "content": "### Chapter outline\n\nSection 30.1 presents two ways to represent polynomials: the coefficient representation and the point-value representation. The straightforward method for multiplying polynomials of degree \\(n\\) --equations (30.1) and (30.2)-- takes \\(\\,\\Theta(n^{2})\\) time with polynomials represented in coefficient form, but only \\(\\,\\Theta(n)\\) time with point-value form. Converting between the two representations, however, reduces the time to multiply polynomials to just \\(\\,\\Theta(n\\lg n)\\). To see why this approach works, you must first understand complex roots of unity, which Section 30.2 covers. Section 30.2 then uses the FFT and its inverse to perform the conversions. Because the FFT is used so often in signal processing, it is often implemented as a circuit in hardware, and Section 30.3 illustrates the structure of such circuits.\n\nThis chapter relies on complex numbers, and within this chapter the symbol \\(\\,i\\) denotes \\(\\sqrt{-1}\\) exclusively.\n\n### Representing polynomials\n\nThe coefficient and point-value representations of polynomials are in a sense equivalent: a polynomial in point-value form has a unique counterpart in coefficient form. This section introduces the two representations and shows how to combine them in order to multiply two degree-bound \\(n\\) polynomials in \\(\\,\\Theta(n\\lg n)\\) time.\n\n#### Coefficient representation\n\nA _coefficient representation_ of a polynomial \\(\\,A(x)=\\sum_{j=0}^{n-1}a_{j}x^{j}\\) of degree-bound \\(n\\) is a vector of coefficients \\(a=(a_{0},a_{1},\\ldots,a_{n-1})\\). Matrix equations in this chapter generally treat vectors as column vectors.\n\nThe coefficient representation is convenient for certain operations on polynomials. For example, the operation of _evaluating_ the polynomial \\(\\,A(x)\\) at a given point \\(x_{0}\\) consists of computing the value of \\(\\,A(x_{0})\\). To evaluate a polynomial in \\(\\,\\Theta(n)\\) time, use _Horner's rule_:\n\n\\[\\,A(x_{0})=a_{0}+x_{0}\\left(a_{1}+x_{0}\\left(a_{2}+\\cdots+x_{0}\\left(a_{n-2}+x _{0}(a_{n-1})\\right)\\cdots\\right)\\right)\\.\\]\n\nSimilarly, adding two polynomials represented by the coefficient vectors \\(a=(a_{0},a_{1},\\ldots,a_{n-1})\\) and \\(b=(b_{0},b_{1},\\ldots,b_{n-1})\\) takes \\(\\,\\Theta(n)\\) time: just produce the coefficient vector \\(c=(c_{0},c_{1},\\ldots,c_{n-1})\\), where \\(c_{j}=a_{j}+b_{j}\\) for \\(j=0,1,\\ldots,n-1\\).\n\nNow, consider multiplying two degree-bound \\(n\\) polynomials \\(\\,A(x)\\) and \\(\\,B(x)\\) represented in coefficient form. The method described by equations (30.1) and (30.2) takes \\(\\,\\Theta(n^{2})\\) time, since it multiplies each coefficient in the vector \\(a\\) by each coefficient in the vector \\(b\\). The operation of multiplying polynomials in coefficient form seems to be considerably more difficult than that of evaluating a polynomial or adding two polynomials. The resulting coefficient vector \\(c\\), given by equation (30.2), is also called the _convolution_ of the input vectors \\(a\\) and \\(b\\), denoted \\(c=a\\otimes b\\). Since multiplying polynomials and computing convolutions are fundamental computational problems of considerable practical importance, this chapter concentrates on efficient algorithms for them.\n\n##### Point-value representation\n\nA _point-value representation_ of a polynomial \\(A(x)\\) of degree-bound \\(n\\) is a set of \\(n\\)_point-value pairs_\n\n\\[\\{(x_{0},y_{0}),(x_{1},y_{1}),\\ldots,(x_{n-1},y_{n-1})\\}\\]\n\nsuch that all of the \\(x_{k}\\) are distinct and\n\n\\[y_{k}=A(x_{k}) \\tag{30.3}\\]\n\nfor \\(k=0,1,\\ldots,n-1\\). A polynomial has many different point-value representations, since any set of \\(n\\) distinct points \\(x_{0},x_{1},\\ldots,x_{n-1}\\) can serve as a basis for the representation.\n\nComputing a point-value representation for a polynomial given in coefficient form is in principle straightforward, since all you have to do is select \\(n\\) distinct points \\(x_{0},x_{1},\\ldots,x_{n-1}\\) and then evaluate \\(A(x_{k})\\) for \\(k=0,1,\\ldots,n-1\\). With Horner's method, evaluating a polynomial at \\(n\\) points takes \\(\\Theta(n^{2})\\) time. We'll see later that if you choose the points \\(x_{k}\\) cleverly, you can accelerate this computation to run in \\(\\Theta(n\\lg n)\\) time.\n\nThe inverse of evaluation--determining the coefficient form of a polynomial from a point-value representation--is _interpolation_. The following theorem shows that interpolation is well defined when the desired interpolating polynomial must have a degree-bound equal to the given number of point-value pairs.\n\n_Theorem 30.1 (Uniqueness of an interpolating polynomial)_\n\nFor any set \\(\\{(x_{0},y_{0}),(x_{1},y_{1}),\\ldots,(x_{n-1},y_{n-1})\\}\\) of \\(n\\) point-value pairs such that all the \\(x_{k}\\) values are distinct, there is a unique polynomial \\(A(x)\\) of degree-bound \\(n\\) such that \\(y_{k}=A(x_{k})\\) for \\(k=0,1,\\ldots,n-1\\).\n\n_Proof_ The proof relies on the existence of the inverse of a certain matrix. Equation (30.3) is equivalent to the matrix equation \n\n### Representing polynomials\n\n\\[\\left(\\begin{array}{ccccc}1&x_{0}&x_{0}^{2}&\\cdots&x_{0}^{n-1}\\\\ 1&x_{1}&x_{1}^{2}&\\cdots&x_{1}^{n-1}\\\\ \\vdots&\\vdots&\\vdots&\\ddots&\\vdots\\\\ 1&x_{n-1}&x_{n-1}^{2}&\\cdots&x_{n-1}^{n-1}\\end{array}\\right)\\left(\\begin{array} []{c}a_{0}\\\\ a_{1}\\\\ \\vdots\\\\ a_{n-1}\\end{array}\\right)=\\left(\\begin{array}{c}y_{0}\\\\ y_{1}\\\\ \\vdots\\\\ y_{n-1}\\end{array}\\right)\\,. \\tag{30.4}\\]\n\nThe matrix on the left is denoted \\(V(x_{0},x_{1},\\ldots,x_{n-1})\\) and is known as a _Vandermonde matrix_. By Problem D-1 on page 1223, this matrix has determinant\n\n\\[\\prod_{0\\leq j\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\, \\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\, \\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\, \\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\, \\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\, \\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\, \\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\, \\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\, \\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\, \\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\, \\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\, \\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\, \\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\, \\and for \\(B\\),\n\n\\[\\{(x_{0},y^{\\prime}_{0}),(x_{1},y^{\\prime}_{1}),\\ldots,(x_{n-1},y^{\\prime}_{n-1}) \\}\\enspace,\\]\n\nwhere \\(A\\) and \\(B\\) are evaluated at the _same_\\(n\\) points, then a point-value representation for \\(C\\) is\n\n\\[\\{(x_{0},y_{0}+y^{\\prime}_{0}),(x_{1},y_{1}+y^{\\prime}_{1}),\\ldots,(x_{n-1},y _{n-1}+y^{\\prime}_{n-1})\\}\\enspace.\\]\n\nThus the time to add two polynomials of degree-bound \\(n\\) in point-value form is \\(\\Theta(n)\\).\n\nSimilarly, the point-value representation is convenient for multiplying polynomials. If \\(C(x)=A(x)\\,B(x)\\), then \\(C(x_{k})=A(x_{k})\\,B(x_{k})\\) for any point \\(x_{k}\\), and to obtain a point-value representation for \\(C\\), just pointwise multiply a point-value representation for \\(A\\) by a point-value representation for \\(B\\). Polynomial multiplication differs from polynomial addition in one key aspect, however: degree\\((C)=\\) degree\\((A)+\\) degree\\((B)\\), so that if \\(A\\) and \\(B\\) have degree-bound \\(n\\), then \\(C\\) has degree-bound \\(2n\\). A standard point-value representation for \\(A\\) and \\(B\\) consists of \\(n\\) point-value pairs for each polynomial. Multiplying these together gives \\(n\\) point-value pairs, but \\(2n\\) pairs are necessary to interpolate a unique polynomial \\(C\\) of degree-bound \\(2n\\). (See Exercise 30.1-4.) Instead, begin with \"extended\" point-value representations for \\(A\\) and for \\(B\\) consisting of \\(2n\\) point-value pairs each. Given an extended point-value representation for \\(A\\),\n\n\\[\\{(x_{0},y_{0}),(x_{1},y_{1}),\\ldots,(x_{2n-1},y_{2n-1})\\}\\enspace,\\]\n\nand a corresponding extended point-value representation for \\(B\\),\n\n\\[\\{(x_{0},y^{\\prime}_{0}),(x_{1},y^{\\prime}_{1}),\\ldots,(x_{2n-1},y^{\\prime}_{ 2n-1})\\}\\enspace,\\]\n\nthen a point-value representation for \\(C\\) is\n\n\\[\\{(x_{0},y_{0}y^{\\prime}_{0}),(x_{1},y_{1}y^{\\prime}_{1}),\\ldots,(x_{2n-1},y _{2n-1}y^{\\prime}_{2n-1})\\}\\enspace.\\]\n\nGiven two input polynomials in extended point-value form, multiplying them to obtain the point-value form of the result takes just \\(\\Theta(n)\\) time, much less than the \\(\\Theta(n^{2})\\) time required to multiply polynomials in coefficient form.\n\nFinally, let's consider how to evaluate a polynomial given in point-value form at a new point. For this problem, the simplest approach known is to first convert the polynomial to coefficient form and then evaluate it at the new point.\n\n### Fast multiplication of polynomials in coefficient form\n\nCan the linear-time multiplication method for polynomials in point-value form expedite polynomial multiplication in coefficient form? The answer hinges on \n\n### 30.1 Representing polynomials\n\nwhether it is possible convert a polynomial quickly from coefficient form to point-value form (evaluate) and vice versa (interpolate).\n\nAny points can serve as evaluation points, but certain evaluation points allow conversion between representations in only \\(\\Theta(n\\lg n)\\) time. As we'll see in Section 30.2, if \"complex roots of unity\" are the evaluation points, then the discrete Fourier transform (or DFT) evaluates and the inverse DFT interpolates. Section 30.2 shows how the FFT accomplishes the DFT and inverse DFT operations in \\(\\Theta(n\\lg n)\\) time.\n\nFigure 30.1 shows this strategy graphically. One minor detail concerns degree-bounds. The product of two polynomials of degree-bound \\(n\\) is a polynomial of degree-bound \\(2n\\). Before evaluating the input polynomials \\(A\\) and \\(B\\), therefore, first double their degree-bounds to \\(2n\\) by adding \\(n\\) high-order coefficients of \\(0\\). Because the vectors have \\(2n\\) elements, use \"complex \\((2n)\\)th roots of unity,\" which are denoted by the \\(\\omega_{2n}\\) terms in Figure 30.1.\n\nThe following procedure takes advantage of the FFT to multiply two polynomials \\(A(x)\\) and \\(B(x)\\) of degree-bound \\(n\\) in \\(\\Theta(n\\lg n)\\)-time, where the input and output representations are in coefficient form. The procedure assumes that \\(n\\) is an exact power of \\(2\\), so if it isn't, just add high-order zero coefficients.\n\n1. **Double degree-bound:** Create coefficient representations of \\(A(x)\\) and \\(B(x)\\) as degree-bound \\(2n\\) polynomials by adding \\(n\\) high-order zero coefficients to each.\n\nFigure 30.1: A graphical outline of an efficient polynomial-multiplication process. Representations on the top are in coefficient form, and those on the bottom are in point-value form. The arrows from left to right correspond to the multiplication operation. The \\(\\omega_{2n}\\) terms are complex \\((2n)\\)th roots of unity.\n\n2. **Evaluate:** Compute point-value representations of \\(A(x)\\) and \\(B(x)\\) of length \\(2n\\) by applying the FFT of order \\(2n\\) on each polynomial. These representations contain the values of the two polynomials at the \\((2n)\\)th roots of unity.\n3. **Pointwise multiply:** Compute a point-value representation for the polynomial \\(C(x)=A(x)B(x)\\) by multiplying these values together pointwise. This representation contains the value of \\(C(x)\\) at each \\((2n)\\)th root of unity.\n4. **Interpolate:** Create the coefficient representation of the polynomial \\(C(x)\\) by applying the FFT on \\(2n\\) point-value pairs to compute the inverse DFT.\n\nSteps (1) and (3) take \\(\\Theta(n)\\) time, and steps (2) and (4) take \\(\\Theta(n\\lg n)\\) time. Thus, once we show how to use the FFT, we will have proven the following.\n\n_Theorem 30.2_\n\nTwo polynomials of degree-bound \\(n\\) with both the input and output representations in coefficient form can be multiplied in \\(\\Theta(n\\lg n)\\) time.\n\n### Exercises\n\n_30.1-1_\n\nMultiply the polynomials \\(A(x)=7x^{3}-x^{2}+x-10\\) and \\(B(x)=8x^{3}-6x+3\\) using equations (30.1) and (30.2).\n\n_30.1-2_\n\nAnother way to evaluate a polynomial \\(A(x)\\) of degree-bound \\(n\\) at a given point \\(x_{0}\\) is to divide \\(A(x)\\) by the polynomial \\((x-x_{0})\\), obtaining a quotient polynomial \\(q(x)\\) of degree-bound \\(n-1\\) and a remainder \\(r\\), such that\n\n\\[A(x)=q(x)(x-x_{0})+r\\.\\]\n\nThen we have \\(A(x_{0})=r\\). Show how to compute the remainder \\(r\\) and the coefficients of \\(q(x)\\) from \\(x_{0}\\) and the coefficients of \\(A\\) in \\(\\Theta(n)\\) time.\n\n_30.1-3_\n\nGiven a polynomial \\(A(x)=\\sum_{j=0}^{n-1}a_{j}x^{j}\\), define \\(A^{\\rm rev}(x)=\\sum_{j=0}^{n-1}a_{n-1-j}x^{j}\\). Show how to derive a point-value representation for \\(A^{\\rm rev}(x)\\) from a point-value representation for \\(A(x)\\), assuming that none of the points is \\(0\\).\n\n_30.1-4_\n\nProve that \\(n\\) distinct point-value pairs are necessary to uniquely specify a polynomial of degree-bound \\(n\\), that is, if fewer than \\(n\\) distinct point-value pairs are given, they fail to specify a unique polynomial of degree-bound \\(n\\). (_Hint:_ Using Theorem 30.1, what can you say about a set of \\(n-1\\) point-value pairs to which you add one more arbitrarily chosen point-value pair?)\n\n### 30.2 The DFT and FFT\n\n#### 30.2 The DFT and FFT\n\nThe DFT and FFT are described in detail in Section 30.1.1. The DFT and FFT are described in detail in Section 30.1.2. The DFT and FFT are described in detail in Section 30.1.3. The DFT and FFT are described in detail in Section 30.1.4.\n\n#### 30.3.1 The DFT and FFT\n\nThe DFT and FFT are described in detail in Section 30.1.5. The DFT and FFT are described in detail in Section 30.1.6.\n\n#### 30.3.2 The DFT and FFT\n\nThe DFT and FFT are described in detail in Section 30.1.7.\n\n#### 30.3.3 The DFT and FFT\n\nThe DFT and FFT are described in detail in Section 30.1.8.\n\n#### 30.3.4 The DFT and FFT\n\nThe DFT and FFT are described in detail in Section 30.1.9.\n\n#### 30.4.1 The DFT and FFT\n\nThe DFT and FFT are described in detail in Section 30.1.9.\n\n#### 30.4.2 The DFT and FFT\n\nThe DFT and FFT are described in detail in Section 30.1.9.\n\n#### 30.4.3 The DFT and FFT\n\nThe DFT and FFT are described in detail in Section 30.1.9.\n\n#### 30.4.4 The DFT and FFT\n\nThe DFT and FFT are described in detail in Section 30.1.9.\n\n#### 30.4.5 The DFT and FFT\n\nThe DFT and FFT are described in detail in Section 30.1.9.\n\n#### 30.4.6 The DFT and FFT\n\nThe DFT and FFT are described in detail in Section 30.1.9.\n\n#### 30.4.7 The DFT and FFT\n\nThe DFT and FFT are described in detail in Section 30.1.9.\n\n#### 30.4.8 The DFT and FFT\n\nThe DFT and FFT are described in detail in Section 30.1.9.\n\n#### 30.4.9 The DFT and FFT\n\nThe DFT and FFT are described in detail in Section 30.1.9.\n\n#### 30.4.1 The DFT and FFT\n\nThe DFT and FFT are described in detail in Section 30.1.9.\n\n#### 30.4.1 The DFT and FFT\n\nThe DFT and FFT are described in detail in Section 30.1.9.\n\n#### 30.4.2 The DFT and FFT\n\nThe DFT and FFT are described in detail in Section 30.1.9.\n\n#### 30.4.3 The DFT and FFT\n\nThe DFT and FFT are described in detail in Section 30.1.9.\n\n#### 30.4.4 The DFT and FFT\n\nThe DFT and FFT are described in detail in Section 30.1.9.\n\n#### 30.4.5 The DFT and FFT\n\nThe DFT and FFT are described in detail in Section 30.1.9.\n\n#### 30.4.6 The DFT and FFT\n\nThe DFT and FFT are described in detail in Section 30.1.9.\n\n#### 30.4.7 The DFT and FFT\n\nThe DFT and FFT are described in detail in Section 30.1.9.\n\n#### 30.4.8 The DFT and FFT\n\nThe DFT and FFT are described in detail in Section 30.1.9.\n\n#### 30.4.9 The DFT and FFT\n\nThe DFT and FFT are described in detail in Section 30.1.9.\n\n#### 30.4.1 The DFT and FFT\n\nThe DFT and FFT are described in detail in Section 30.1.9.\n\n#### 30.4.1 The DFT and FFT\n\nThe DFT and FFT are described in detail in Section 30.1.9.\n\n#### 30.4.2 The DFT and FFT\n\nThe DFT and FFT are described in detail in Section 30.1.9.\n\n#### 30.4.3 The DFT and FFT\n\nThe DFT and FFT are described in detail in Section 30.1.9.\n\n#### 30.4.1 The DFT and FFT\n\nThe DFT and FFT are described in detail in Section 30.1.9.\n\n#### 30.4.2 The DFT and FFT\n\nThe DFT and FFT are described in detail in Section 30.1.9.\n\n#### 30.4.3 The DFT and FFT\n\nThe DFT and FFT are described in detail in Section 30.1.9.\n\n#### 30.4.4 The DFT and FFT\n\nThe DFT and FFT are described in detail in Section 30.1.9.\n\n#### 30.4.5 The DFT and FFT\n\nThe DFT and FFT are described in detail in Section 30.1.9.\n\n#### 30.4.6 The DFT and FFT\n\nThe DFT and FFT are described in detail in Section 30.1.9.\n\n#### 30.4.7 The DFT and FFT\n\nThe DFT and FFT are described in detail in Section 30.1.9.\n\n#### 30.4.8 The DFT and FFT\n\nThe DFT and FFT are described in detail in Section 30.1.9.\n\n#### 30.4.9 The DFT and FFT\n\nThe DFT and FFT are described in detail in Section 30.1.9.\n\n#### 30.4.1 The DFT and FFT\n\nThe DFT and FFT are described in detail in Section 30.1.9.\n\n#### 30.4.1 The DFT and FFT\n\nThe DFT and FFT are described in detail in Section 30.1.9.\n\n#### 30.4.2 The DFT and FFT\n\nThe DFT and FFT are described in detail in Section 30.1.9.\n\n#### 30.4.3 The DFT and FFT\n\nThe DFT and FFT are described in detail in Section 30.1.9.\n\n#### 30.4.1 The DFT and FFT\n\nThe DFT and FFT are described in detail in Section 30.1.9.\n\n#### 30.4.2 The DFT and FFT\n\nThe DFT and FFT are described in detail in Section 30.1.9.\n\n#### 30.4.3 The DFT and FFT\n\nThe DFT and FFT are described in detail in Section 30.1.9.\n\n#### 30.4.4 The DFT and FFT\n\nThe DFT and FFT are described in detail in Section 30.1.9.\n\n#### 30.4.5 The DFT and FFT\n\nThe DFT and FFT are described in detail in Section 30.1.9.\n\n#### 30.4.6 The DFT and FFT\n\nThe DFT and FFT are described in detail in Section 30.1.9.\n\n#### 30.4.7 The DFT and FFT\n\nThe DFT and FFT are described in detail in Section 30.1.9.\n\n#### 30.4.8 The DFT and FFT\n\nThe DFT and FFT are described in detail in Section 30.1.9.\n\n#### 30.4.9 The DFT and FFT\n\nThe DFT and FFT are described in detail in Section 30.1.9.\n\n#### 30.4.1 The DFT and FFT\n\nThe DFT and FFT are described in detail in Section 30.1.9.\n\n#### 30.4.1 The DFT and FFT\n\nThe DFT and FFT are described in detail in Section 30.1.9.\n\n#### 30.4.2 The DFT and FFT\n\nThe DFT and FFT are described in detail in Section 30.1.9.\n\n#### 30.4.3 The DFT and FFT\n\nThe DFT and FFT are described in detail in Section 30.1.9.\n\n#### 30.4.1 The DFT and FFT\n\nThe DFT and FFT are described in detail in Section 30.1.9.\n\n#### 30.4.2 The DFT and FFT\n\nThe DFT and FFT are described in detail in Section 30.1.9.\n\n#### 30.4.3 The DFT and FFT\n\nThe DFT and FFT are described in detail in Section 30.1.9.\n\n#### 30.4.4 The DFT and FFT\n\nThe DFT and FFT are described in detail in Section 30.1.9.\n\n#### 30.4.5 The DFT and FFT\n\nThe DFT and FFT are described in detail in Section 30.1.9.\n\n#### 30.4.6 The DFT and FFT\n\nThe DFT and FFT are described in detail in Section 30.1.9.\n\n#### 30.4.7 The DFT and FFT\n\nThe DFT and FFT are described in detail in detail in Section 30.1.9.\n\n#### 30.4.8 The DFT and FFT\n\nThe DFT and FFT are described in detail in detail in Section 30.1.9.\n\n#### 30.4.9 The DFT and FFT\n\nThe DFT and FFT are described in detail in detail in Section 30.1.9.\n\n#### 30.4.1 The DFT and FFT\n\nThe DFT and FFT are described in detail in detail in Section 30.1.9.\n\n#### 30.4.1 The DFT and FFT\n\nThe DFT and FFT are described in detail in detail in Section 30.1.9.\n\n#### 30.4.2 The DFT and FFT\n\nThe DFT and FFT are described in detail in detail in Section 30.1.9.\n\n#### 30.4.3 The DFT and FFT\n\nThe DFT and FFT are described in detail in detail in Section 30.1.9.\n\n#### 30.4.1 The DFT and FFT\n\nThe DFT and FFT are described in detail in detail in Section 30.1.9.\n\n#### 30.4.2 The DFT and FFT\n\nThe DFT and FFT are described in detail in detail in Section 30.1.9.\n\n#### 30.4.3 The DFT and FFT\n\nThe DFT and FFT are described in detail in detail in Section 30.1.9.\n\n#### 30.4.4 The DFT and FFT\n\nThe DFT and FFT are described in detail in detail in Section 30.1.9.\n\n#### 30.4.5 The DFT and FFT\n\nThe DFT and FFT are described in detail in detail in Section 30.1.9.\n\n#### 30.4.6 The DFT and FFT\n\nThe DFT and FFT are described in detail in detail in Section 30.1.9.\n\n#### 30.4.7 The DFT and FFT\n\nThe DFT and FFT are described in detail in detail in Section 30.1.9.\n\n#### 30.4.8 The DFT and FFT\n\nThe DFT and FFT are described in detail in detail in Section 30.1.9.\n\n#### 30.4.9 The DFT and FFT\n\nThe DFT and FFT are described in detail in detail in Section 30.1.9.\n\n#### 30.4.1 The DFT and FFT\n\nThe DFT and FFT are described in detail in detail in Section 30.1.9.\n\n#### 30.4.1 The DFT and FFT\n\nThe DFT and FFT are described in detail in detail in Section 30.1.9.\n\n#### 30.4.1 The DFT and FFT\n\nThe DFT and FFT are described in detail in detail in detail in Section 30.1.9.\n\n#### 30.4.2 The DFT and FFT\n\nThe DFT and FFT are described in detail in detail in Section 30.1.9.\n\n#### 30.4.3 The DFT and FFT\n\nThe DFT and FFT are described in detail in detail in detail in Section 30.1.9.\n\n#### 30.4.4 The DFT and FFT\n\nThe DFT and FFT are described in detail in detail in detail in Section 30.1.9.\n\n#### 30.4.5 The DFT and FFT\n\nThe DFT and FFT are described in detail in detail in detail in Section 30.1.9.\n\n#### 30.4.6 The DFT and FFT\n\nThe DFT and FFT are described in detail in detail in detail in Section 30.1.9.\n\n#### 30.7.1 The DFT\n\nThe DFT and FFT are described in detail in detail in detail in Section 30.1.9.\n\n#### 30.7.2 The DFT and FFT\n\nThe DFT and FFT are described in detail in detail in detail in Section 30.1.9.\n\n#### 30.7.3 The DFT and FFT\n\nThe DFT and FFT are described in detail in detail in detail in Section 30.1.9.\n\n#### 30.7.4 The DFT\n\nThe DFT and FFT are described in detail in detail in detail in Section 30.1.9.\n\n#### 30.7.5 The DFT\n\nThe DFT and FFT are described in detail in detail in detail in Section 30.1.9.\n\n#### 30.7.6 The DFT\n\nThe DFT and FFT are described in detail in detail in detail in Section 30.1.9.\n\n#### 30.7.7.7 The DFT\n\nThe DFT and FFT are described in detail in detail in detail in Section 30.1.9.\n\n#### 30.7.8 The DFT and FFT\n\nThe DFT and FFT are described in detail in detail in detail in Section 30.1.9.\n\n#### 30.8.1 The DFT and FFT\n\nThe FFT is described in detail in detail in detail in Section 30.1.9.\n\n#### 30.9.1 The DFT and FFT\n\nThe FFT is described in detail in detail in detail in Section 30.1.9.\n\n#### 30.9.2 The DFT and FFT\n\nThe FFT is described in detail in detail in detail in detail in Section 30.1.9.\n\n#### 30.9.3 The DFT\n\nThe FFT and FFT are described in detail in detail in detail in Section 30.1.9.\n\n#### 30.9.4 The DFT and FFT\n\nThe FFT is described in detail in detail in detail in Section 30.1.9.\n\n#### 30.9.5 The DFT and FFT\n\nThe FFT is described in detail in detail in detail in detail in Section 30.1.9.\n\n#### 30.6.1 The DFT and FFT\n\nThe FFT is described in detail in detail in detail in Section 30.1.9.\n\n#### 30.7.1 The DFT and FFT\n\nThe FFT is described in detail in detail in detail in Section 30.1.9.",
        "chapter": "Part VII Selected Topics",
        "section": "30 Polynomials and the FFT",
        "subsection": "30.1 Representing polynomials",
        "subsubsection": "N/A"
    },
    {
        "content": "### 30.2 The DFT and FFT\n\n#### 30.2 The DFT and FFT\n\nThe DFT and FFT are described in detail in Section 30.1.1. The DFT and FFT are described in detail in Section 30.1.2. The DFT and FFT are described in detail in Section 30.1.3. The DFT and FFT are described in detail in Section 30.1.4.\n\n#### 30.3.1 The DFT and FFT\n\nThe DFT and FFT are described in detail in Section 30.1.5. The DFT and FFT are described in detail in Section 30.1.6.\n\n#### 30.3.2 The DFT and FFT\n\nThe DFT and FFT are described in detail in Section 30.1.7.\n\n#### 30.3.3 The DFT and FFT\n\nThe DFT and FFT are described in detail in Section 30.1.8.\n\n#### 30.3.4 The DFT and FFT\n\nThe DFT and FFT are described in detail in Section 30.1.9.\n\n#### 30.4.1 The DFT and FFT\n\nThe DFT and FFT are described in detail in Section 30.1.9.\n\n#### 30.4.2 The DFT and FFT\n\nThe DFT and FFT are described in detail in Section 30.1.9.\n\n#### 30.4.3 The DFT and FFT\n\nThe DFT and FFT are described in detail in Section 30.1.9.\n\n#### 30.4.4 The DFT and FFT\n\nThe DFT and FFT are described in detail in Section 30.1.9.\n\n#### 30.4.5 The DFT and FFT\n\nThe DFT and FFT are described in detail in Section 30.1.9.\n\n#### 30.4.6 The DFT and FFT\n\nThe DFT and FFT are described in detail in Section 30.1.9.\n\n#### 30.4.7 The DFT and FFT\n\nThe DFT and FFT are described in detail in Section 30.1.9.\n\n#### 30.4.8 The DFT and FFT\n\nThe DFT and FFT are described in detail in Section 30.1.9.\n\n#### 30.4.9 The DFT and FFT\n\nThe DFT and FFT are described in detail in Section 30.1.9.\n\n#### 30.4.1 The DFT and FFT\n\nThe DFT and FFT are described in detail in Section 30.1.9.\n\n#### 30.4.1 The DFT and FFT\n\nThe DFT and FFT are described in detail in Section 30.1.9.\n\n#### 30.4.2 The DFT and FFT\n\nThe DFT and FFT are described in detail in Section 30.1.9.\n\n#### 30.4.3 The DFT and FFT\n\nThe DFT and FFT are described in detail in Section 30.1.9.\n\n#### 30.4.4 The DFT and FFT\n\nThe DFT and FFT are described in detail in Section 30.1.9.\n\n#### 30.4.5 The DFT and FFT\n\nThe DFT and FFT are described in detail in Section 30.1.9.\n\n#### 30.4.6 The DFT and FFT\n\nThe DFT and FFT are described in detail in Section 30.1.9.\n\n#### 30.4.7 The DFT and FFT\n\nThe DFT and FFT are described in detail in Section 30.1.9.\n\n#### 30.4.8 The DFT and FFT\n\nThe DFT and FFT are described in detail in Section 30.1.9.\n\n#### 30.4.9 The DFT and FFT\n\nThe DFT and FFT are described in detail in Section 30.1.9.\n\n#### 30.4.1 The DFT and FFT\n\nThe DFT and FFT are described in detail in Section 30.1.9.\n\n#### 30.4.1 The DFT and FFT\n\nThe DFT and FFT are described in detail in Section 30.1.9.\n\n#### 30.4.2 The DFT and FFT\n\nThe DFT and FFT are described in detail in Section 30.1.9.\n\n#### 30.4.3 The DFT and FFT\n\nThe DFT and FFT are described in detail in Section 30.1.9.\n\n#### 30.4.1 The DFT and FFT\n\nThe DFT and FFT are described in detail in Section 30.1.9.\n\n#### 30.4.2 The DFT and FFT\n\nThe DFT and FFT are described in detail in Section 30.1.9.\n\n#### 30.4.3 The DFT and FFT\n\nThe DFT and FFT are described in detail in Section 30.1.9.\n\n#### 30.4.4 The DFT and FFT\n\nThe DFT and FFT are described in detail in Section 30.1.9.\n\n#### 30.4.5 The DFT and FFT\n\nThe DFT and FFT are described in detail in Section 30.1.9.\n\n#### 30.4.6 The DFT and FFT\n\nThe DFT and FFT are described in detail in Section 30.1.9.\n\n#### 30.4.7 The DFT and FFT\n\nThe DFT and FFT are described in detail in Section 30.1.9.\n\n#### 30.4.8 The DFT and FFT\n\nThe DFT and FFT are described in detail in Section 30.1.9.\n\n#### 30.4.9 The DFT and FFT\n\nThe DFT and FFT are described in detail in Section 30.1.9.\n\n#### 30.4.1 The DFT and FFT\n\nThe DFT and FFT are described in detail in Section 30.1.9.\n\n#### 30.4.1 The DFT and FFT\n\nThe DFT and FFT are described in detail in Section 30.1.9.\n\n#### 30.4.2 The DFT and FFT\n\nThe DFT and FFT are described in detail in Section 30.1.9.\n\n#### 30.4.3 The DFT and FFT\n\nThe DFT and FFT are described in detail in Section 30.1.9.\n\n#### 30.4.1 The DFT and FFT\n\nThe DFT and FFT are described in detail in Section 30.1.9.\n\n#### 30.4.2 The DFT and FFT\n\nThe DFT and FFT are described in detail in Section 30.1.9.\n\n#### 30.4.3 The DFT and FFT\n\nThe DFT and FFT are described in detail in Section 30.1.9.\n\n#### 30.4.4 The DFT and FFT\n\nThe DFT and FFT are described in detail in Section 30.1.9.\n\n#### 30.4.5 The DFT and FFT\n\nThe DFT and FFT are described in detail in Section 30.1.9.\n\n#### 30.4.6 The DFT and FFT\n\nThe DFT and FFT are described in detail in Section 30.1.9.\n\n#### 30.4.7 The DFT and FFT\n\nThe DFT and FFT are described in detail in Section 30.1.9.\n\n#### 30.4.8 The DFT and FFT\n\nThe DFT and FFT are described in detail in Section 30.1.9.\n\n#### 30.4.9 The DFT and FFT\n\nThe DFT and FFT are described in detail in Section 30.1.9.\n\n#### 30.4.1 The DFT and FFT\n\nThe DFT and FFT are described in detail in Section 30.1.9.\n\n#### 30.4.1 The DFT and FFT\n\nThe DFT and FFT are described in detail in Section 30.1.9.\n\n#### 30.4.2 The DFT and FFT\n\nThe DFT and FFT are described in detail in Section 30.1.9.\n\n#### 30.4.3 The DFT and FFT\n\nThe DFT and FFT are described in detail in Section 30.1.9.\n\n#### 30.4.1 The DFT and FFT\n\nThe DFT and FFT are described in detail in Section 30.1.9.\n\n#### 30.4.2 The DFT and FFT\n\nThe DFT and FFT are described in detail in Section 30.1.9.\n\n#### 30.4.3 The DFT and FFT\n\nThe DFT and FFT are described in detail in Section 30.1.9.\n\n#### 30.4.4 The DFT and FFT\n\nThe DFT and FFT are described in detail in Section 30.1.9.\n\n#### 30.4.5 The DFT and FFT\n\nThe DFT and FFT are described in detail in Section 30.1.9.\n\n#### 30.4.6 The DFT and FFT\n\nThe DFT and FFT are described in detail in Section 30.1.9.\n\n#### 30.4.7 The DFT and FFT\n\nThe DFT and FFT are described in detail in detail in Section 30.1.9.\n\n#### 30.4.8 The DFT and FFT\n\nThe DFT and FFT are described in detail in detail in Section 30.1.9.\n\n#### 30.4.9 The DFT and FFT\n\nThe DFT and FFT are described in detail in detail in Section 30.1.9.\n\n#### 30.4.1 The DFT and FFT\n\nThe DFT and FFT are described in detail in detail in Section 30.1.9.\n\n#### 30.4.1 The DFT and FFT\n\nThe DFT and FFT are described in detail in detail in Section 30.1.9.\n\n#### 30.4.2 The DFT and FFT\n\nThe DFT and FFT are described in detail in detail in Section 30.1.9.\n\n#### 30.4.3 The DFT and FFT\n\nThe DFT and FFT are described in detail in detail in Section 30.1.9.\n\n#### 30.4.1 The DFT and FFT\n\nThe DFT and FFT are described in detail in detail in Section 30.1.9.\n\n#### 30.4.2 The DFT and FFT\n\nThe DFT and FFT are described in detail in detail in Section 30.1.9.\n\n#### 30.4.3 The DFT and FFT\n\nThe DFT and FFT are described in detail in detail in Section 30.1.9.\n\n#### 30.4.4 The DFT and FFT\n\nThe DFT and FFT are described in detail in detail in Section 30.1.9.\n\n#### 30.4.5 The DFT and FFT\n\nThe DFT and FFT are described in detail in detail in Section 30.1.9.\n\n#### 30.4.6 The DFT and FFT\n\nThe DFT and FFT are described in detail in detail in Section 30.1.9.\n\n#### 30.4.7 The DFT and FFT\n\nThe DFT and FFT are described in detail in detail in Section 30.1.9.\n\n#### 30.4.8 The DFT and FFT\n\nThe DFT and FFT are described in detail in detail in Section 30.1.9.\n\n#### 30.4.9 The DFT and FFT\n\nThe DFT and FFT are described in detail in detail in Section 30.1.9.\n\n#### 30.4.1 The DFT and FFT\n\nThe DFT and FFT are described in detail in detail in Section 30.1.9.\n\n#### 30.4.1 The DFT and FFT\n\nThe DFT and FFT are described in detail in detail in Section 30.1.9.\n\n#### 30.4.1 The DFT and FFT\n\nThe DFT and FFT are described in detail in detail in detail in Section 30.1.9.\n\n#### 30.4.2 The DFT and FFT\n\nThe DFT and FFT are described in detail in detail in Section 30.1.9.\n\n#### 30.4.3 The DFT and FFT\n\nThe DFT and FFT are described in detail in detail in detail in Section 30.1.9.\n\n#### 30.4.4 The DFT and FFT\n\nThe DFT and FFT are described in detail in detail in detail in Section 30.1.9.\n\n#### 30.4.5 The DFT and FFT\n\nThe DFT and FFT are described in detail in detail in detail in Section 30.1.9.\n\n#### 30.4.6 The DFT and FFT\n\nThe DFT and FFT are described in detail in detail in detail in Section 30.1.9.\n\n#### 30.7.1 The DFT\n\nThe DFT and FFT are described in detail in detail in detail in Section 30.1.9.\n\n#### 30.7.2 The DFT and FFT\n\nThe DFT and FFT are described in detail in detail in detail in Section 30.1.9.\n\n#### 30.7.3 The DFT and FFT\n\nThe DFT and FFT are described in detail in detail in detail in Section 30.1.9.\n\n#### 30.7.4 The DFT\n\nThe DFT and FFT are described in detail in detail in detail in Section 30.1.9.\n\n#### 30.7.5 The DFT\n\nThe DFT and FFT are described in detail in detail in detail in Section 30.1.9.\n\n#### 30.7.6 The DFT\n\nThe DFT and FFT are described in detail in detail in detail in Section 30.1.9.\n\n#### 30.7.7.7 The DFT\n\nThe DFT and FFT are described in detail in detail in detail in Section 30.1.9.\n\n#### 30.7.8 The DFT and FFT\n\nThe DFT and FFT are described in detail in detail in detail in Section 30.1.9.\n\n#### 30.8.1 The DFT and FFT\n\nThe FFT is described in detail in detail in detail in Section 30.1.9.\n\n#### 30.9.1 The DFT and FFT\n\nThe FFT is described in detail in detail in detail in Section 30.1.9.\n\n#### 30.9.2 The DFT and FFT\n\nThe FFT is described in detail in detail in detail in detail in Section 30.1.9.\n\n#### 30.9.3 The DFT\n\nThe FFT and FFT are described in detail in detail in detail in Section 30.1.9.\n\n#### 30.9.4 The DFT and FFT\n\nThe FFT is described in detail in detail in detail in Section 30.1.9.\n\n#### 30.9.5 The DFT and FFT\n\nThe FFT is described in detail in detail in detail in detail in Section 30.1.9.\n\n#### 30.6.1 The DFT and FFT\n\nThe FFT is described in detail in detail in detail in Section 30.1.9.\n\n#### 30.7.1 The DFT and FFT\n\nThe FFT is described in detail in detail in detail in Section 30.1.9.\n\n\\(\\omega_{n}=e^{2\\pi i/n}\\)\n\nis the _principal nth root of unity_.2 All other complex \\(n\\)th roots of unity are powers of \\(\\omega_{n}\\).\n\nFootnote 2: Many other authors define \\(\\omega_{n}\\) differently: \\(\\omega_{n}=e^{-2\\pi i/n}\\). This alternative definition tends to be used for signal-processing applications. The underlying mathematics is substantially the same with either definition of \\(\\omega_{n}\\).\n\nThe \\(n\\) complex \\(n\\)th roots of unity,\n\n\\(\\omega_{n}^{0},\\omega_{n}^{1},\\ldots,\\omega_{n}^{n-1}\\),\n\nform a group under multiplication (see Section 31.3). This group has the same structure as the additive group (\\(\\mathbb{Z}_{n}\\), \\(+\\)) modulo \\(n\\), since \\(\\omega_{n}^{n}=\\omega_{n}^{0}=1\\) implies that \\(\\omega_{n}^{j}\\omega_{n}^{k}=\\omega_{n}^{j+k}=\\omega_{n}^{(j+k)\\bmod n}\\). Similarly, \\(\\omega_{n}^{-1}=\\omega_{n}^{n-1}\\). The following lemmas furnish some essential properties of the complex \\(n\\)th roots of unity.\n\n**Lemma 30.3** (Cancellation lemma): _For any integers \\(n>0\\), \\(k\\geq 0\\), and \\(d\\,>0\\),_\n\n\\(\\omega_{dn}^{\\,dk}=\\omega_{n}^{k}\\) _._\n\nProofThe lemma follows directly from equation (30.6), since\n\n\\(\\omega_{dn}^{\\,dk} = \\left(e^{2\\pi i/dn}\\right)^{\\,dk}\\)\n\n\\(= \\left(e^{2\\pi i/n}\\right)^{\\,k}\\)\n\n\\(= \\omega_{n}^{k}\\) _._\n\n### The DFT and FFT\n\n**Corollary 30.4**: For any even integer \\(n>0\\),\n\n\\(\\omega_{n}^{n/2}=\\omega_{2}=-1\\).\n\n_Proof_The proof is left as Exercise 30.2-1.\n\n**Lemma 30.5** (Halving lemma): If \\(n>0\\) is even, then the squares of the \\(n\\) complex \\(n\\)th roots of unity are the \\(n/2\\) complex \\((n/2)\\)th roots of unity.\n\n_Proof_By the cancellation lemma, \\((\\omega_{n}^{k})^{2}=\\omega_{n/2}^{k}\\) for any nonnegative integer \\(k\\). Squaring all of the complex \\(n\\)th roots of unity produces each \\((n/2)\\)th root of unity exactly twice, since\n\n\\((\\omega_{n}^{k+n/2})^{2}\\ =\\ \\omega_{n}^{2k+n}\\)\n\n\\(\\ \\\\[\\sum_{j=0}^{n-1}\\left(\\omega_{n}^{k}\\right)^{j} = \\frac{(\\omega_{n}^{k})^{n}-1}{\\omega_{n}^{k}-1}\\] \\[= \\frac{(\\omega_{n}^{n})^{k}-1}{\\omega_{n}^{k}-1}\\] \\[= \\frac{(1)^{k}-1}{\\omega_{n}^{k}-1}\\] \\[= 0\\.\\]\n\nTo see that the denominator is not 0, note that \\(\\omega_{n}^{k}=1\\) only when \\(k\\) is divisible by \\(n\\), which the lemma statement prohibits.\n\n### The DFT\n\nRecall the goal of evaluating a polynomial\n\n\\[A(x)=\\sum_{j=0}^{n-1}a_{j}x^{j}\\]\n\nof degree-bound \\(n\\) at \\(\\omega_{n}^{0},\\omega_{n}^{1},\\omega_{n}^{2},\\ldots,\\omega_{n}^{n-1}\\) (that is, at the \\(n\\) complex \\(n\\)th roots of unity).3 The polynomial \\(A\\) is given in coefficient form: \\(a=(a_{0},a_{1},\\ldots,a_{n-1})\\). Let us define the results \\(y_{k}\\), for \\(k=0,1,\\ldots,n-1\\), by\n\nFootnote 3: The length \\(n\\) is actually what Section 30.1 referred to as \\(2n\\), since the degree-bound of the given polynomials doubles prior to evaluation. In the context of polynomial multiplication, therefore, we are actually working with complex \\((2n)\\)th roots of unity.\n\n\\[y_{k} = A(\\omega_{n}^{k}) \\tag{30.8}\\] \\[= \\sum_{j=0}^{n-1}a_{j}\\omega_{n}^{kj}\\.\\]\n\nThe vector \\(y=(y_{0},y_{1},\\ldots,y_{n-1})\\) is the _discrete Fourier transform (DFT)_ of the coefficient vector \\(a=(a_{0},a_{1},\\ldots,a_{n-1})\\). We also write \\(y={\\rm DFT}_{n}(a)\\).\n\n### The FFT\n\nThe _fast Fourier transform (FFT)_ takes advantage of the special properties of the complex roots of unity to compute \\({\\rm DFT}_{n}(a)\\) in \\(\\Theta(n\\lg n)\\) time, as opposed to the \\(\\Theta(n^{2})\\) time of the straightforward method. Assume throughout that \\(n\\) is an exact power of 2. Although strategies for dealing with sizes that are not exact powers of 2 are known, they are beyond the scope of this book.\n\n### The DFT and FFT\n\nThe FFT method employs a divide-and-conquer strategy, using the even-indexed and odd-indexed coefficients of \\(A(x)\\) separately to define the two new polynomials \\(A^{\\rm even}(x)\\) and \\(A^{\\rm odd}(x)\\) of degree-bound \\(n/2\\):\n\n\\[A^{\\rm even}(x) = a_{0}+a_{2}x+a_{4}x^{2}+\\cdots+a_{n-2}x^{n/2-1}\\,\\] \\[A^{\\rm odd}(x) = a_{1}+a_{3}x+a_{5}x^{2}+\\cdots+a_{n-1}x^{n/2-1}\\.\\]\n\nNote that \\(A^{\\rm even}\\) contains all the even-indexed coefficients of \\(A\\) (the binary representation of the index ends in 0) and \\(A^{\\rm odd}\\) contains all the odd-indexed coefficients (the binary representation of the index ends in 1). It follows that\n\n\\[A(x)=A^{\\rm even}(x^{2})+x\\,A^{\\rm odd}(x^{2})\\, \\tag{30.9}\\]\n\nso that the problem of evaluating \\(A(x)\\) at \\(\\omega_{n}^{0},\\omega_{n}^{1},\\ldots,\\omega_{n}^{n-1}\\) reduces to\n\n1. evaluating the degree-bound \\(n/2\\) polynomials \\(A^{\\rm even}(x)\\) and \\(A^{\\rm odd}(x)\\) at the points \\[(\\omega_{n}^{0})^{2},(\\omega_{n}^{1})^{2},\\ldots,(\\omega_{n}^{n-1})^{2}\\,\\] (30.10) and then\n2. combining the results according to equation (30.9).\n\nBy the halving lemma, the list of values (30.10) consists not of \\(n\\) distinct values but only of the \\(n/2\\) complex \\((n/2)\\)th roots of unity, with each root occurring exactly twice. Therefore, the FFT recursively evaluates the polynomials \\(A^{\\rm even}\\) and \\(A^{\\rm odd}\\) of degree-bound \\(n/2\\) at the \\(n/2\\) complex \\((n/2)\\)th roots of unity. These subproblems have exactly the same form as the original problem, but are half the size, dividing an \\(n\\)-element DFT\\({}_{n}\\) computation into two \\(n/2\\)-element DFT\\({}_{n/2}\\) computations. This decomposition is the basis for the FFT procedure on the next page, which computes the DFT of an \\(n\\)-element vector \\(a=(a_{0},a_{1},\\ldots,a_{n-1})\\), where \\(n\\) is an exact power of 2.\n\nThe FFT procedure works as follows. Lines 1-2 represent the base case of the recursion. The DFT of 1 element is the element itself, since in this case\n\n\\[y_{0} = a_{0}\\,\\omega_{1}^{0}\\] \\[= a_{0}\\cdot 1\\] \\[= a_{0}\\.\\]\n\nLines 5-6 define the coefficient vectors for the polynomials \\(A^{\\rm even}\\) and \\(A^{\\rm odd}\\). Lines 3, 4, and 12 guarantee that \\(\\omega\\) is updated properly so that whenever lines 10-11 are executed, \\(\\omega=\\omega_{n}^{k}\\). (Keeping a running value of \\(\\omega\\) from iteration to iteration savestime over computing \\(\\omega_{n}^{k}\\) from scratch each time through the **for** loop.4) Lines 7-8 perform the recursive DFT\\({}_{n/2}\\) computations, setting, for \\(k=0,1,\\ldots,n/2-1\\),\n\nFootnote 4: The downside of iteratively updating \\(\\omega\\) is that round-off errors can accumulate, especially for larger input sizes. Several techniques to limit the magnitude of FFT round-off errors have been proposed, but are beyond the scope of this book. If several FFTs are going to be run on inputs of the same size, then it might be worthwhile to directly precompute a table of all \\(n/2\\) values of \\(\\omega_{n}^{k}\\).\n\n\\[y_{k}^{\\rm even} = A^{\\rm even}(\\omega_{n/2}^{k})\\,\\] \\[y_{k}^{\\rm odd} = A^{\\rm odd}(\\omega_{n/2}^{k})\\,\\] or, since \\(\\omega_{n/2}^{k}=\\omega_{n}^{2k}\\) by the cancellation lemma, \\[y_{k}^{\\rm even} = A^{\\rm even}(\\omega_{n}^{2k})\\,\\] \\[y_{k}^{\\rm odd} = A^{\\rm odd}(\\omega_{n}^{2k})\\.\\] Lines 10-11 combine the results of the recursive DFT\\({}_{n/2}\\) calculations. For the first \\(n/2\\) results \\(y_{0}\\), \\(y_{1},\\ldots,y_{n/2-1}\\), line 10 yields \\[y_{k} = y_{k}^{\\rm even}+\\omega_{n}^{k}y_{k}^{\\rm odd}\\] \\[= A^{\\rm even}(\\omega_{n}^{2k})+\\omega_{n}^{k}A^{\\rm odd}(\\omega_ {n}^{2k})\\] \\[= A(\\omega_{n}^{k})\\qquad\\qquad\\qquad\\qquad\\mbox{(by equation (\\ref{eq:y1}))}\\.\\] For \\(y_{n/2}\\), \\(y_{n/2+1},\\ldots,y_{n-1}\\), letting \\(k=0,1,\\ldots,n/2-1\\), line 11 yields\n\n### The DFT and FFT\n\n\\[\\begin{array}{rcl}y_{k+(n/2)}&=&y_{k}^{\\rm even}-\\omega_{n}^{k}\\,y_{k}^{\\rm odd }\\\\ &=&y_{k}^{\\rm even}+\\omega_{n}^{k+(n/2)}\\,y_{k}^{\\rm odd}\\\\ &=&A^{\\rm even}(\\omega_{n}^{2k})+\\omega_{n}^{k+(n/2)}\\,A^{\\rm odd}(\\omega_{n}^ {2k})\\\\ &=&A^{\\rm even}(\\omega_{n}^{2k+n})+\\omega_{n}^{k+(n/2)}\\,A^{\\rm odd}(\\omega_{n} ^{2k+n})\\\\ &=&A(\\omega_{n}^{k+(n/2)})\\end{array}\\] (since \\[\\omega_{n}^{k+(n/2)}=-\\omega_{n}^{k}\\] ) \\[\\begin{array}{rcl}=&A^{\\rm even}(\\omega_{n}^{2k+n})+\\omega_{n}^{k+(n/ 2)}\\,A^{\\rm odd}(\\omega_{n}^{2k+n})&\\mbox{(since $\\omega_{n}^{2k+n}=\\omega_{n}^{2k}$)}\\\\ &=&A(\\omega_{n}^{k+(n/2)})\\end{array}\\] (by equation (30.9)).\n\nThus the vector \\(y\\) returned by FFT is indeed the DFT of the input vector \\(a\\).\n\nLines 10 and 11 multiply each value \\(y_{k}^{\\rm odd}\\) by \\(\\omega_{n}^{k}\\), for \\(k=0,1,\\ldots,n/2-1\\). Line 10 adds this product to \\(y_{k}^{\\rm even}\\), and line 11 subtracts it. Because each factor \\(\\omega_{n}^{k}\\) appears in both its positive and negative forms, we call the factors \\(\\omega_{n}^{k}\\)_twiddle factors_.\n\nTo determine the running time of the procedure FFT, note that exclusive of the recursive calls, each invocation takes \\(\\Theta(n)\\) time, where \\(n\\) is the length of the input vector. The recurrence for the running time is therefore\n\n\\[\\begin{array}{rcl}T(n)&=&2T(n/2)+\\Theta(n)\\\\ &=&\\Theta(n\\lg n)\\,\\end{array}\\]\n\nby case 2 of the master theorem (Theorem 4.1). Thus the FFT can evaluate a polynomial of degree-bound \\(n\\) at the complex \\(n\\)th roots of unity in \\(\\Theta(n\\lg n)\\) time.\n\n#### Interpolation at the complex roots of unity\n\nThe polynomial multiplication scheme entails converting from coefficient form to point-value form by evaluating the polynomial at the complex roots of unity, point-wise multiplying, and finally converting from point-value form back to coefficient form by interpolating. We've just seen how to evaluate, so now we'll see how to interpolate the complex roots of unity by a polynomial. To interpolate, we'll write the DFT as a matrix equation and then look at the form of the matrix inverse.\n\nFrom equation (30.4), we can write the DFT as the matrix product \\(y=V_{n}a\\), where \\(V_{n}\\) is a Vandermonde matrix containing the appropriate powers of \\(\\omega_{n}\\):\n\n\\[\\left(\\begin{array}{c}y_{0}\\\\ y_{1}\\\\ y_{2}\\\\ y_{3}\\\\ \\vdots\\\\ y_{n-1}\\end{array}\\right)\\ =\\ \\left(\\begin{array}{cccccc}1&1&1&1&\\cdots&1\\\\ 1&\\omega_{n}&\\omega_{n}^{2}&\\omega_{n}^{3}&\\cdots&\\omega_{n}^{n-1}\\\\ 1&\\omega_{n}^{2}&\\omega_{n}^{4}&\\omega_{n}^{6}&\\cdots&\\omega_{n}^{2(n-1)}\\\\ 1&\\omega_{n}^{3}&\\omega_{n}^{6}&\\omega_{n}^{9}&\\cdots&\\omega_{n}^{3(n-1)}\\\\ \\vdots&\\vdots&\\vdots&\\vdots&\\ddots&\\vdots\\\\ 1&\\omega_{n}^{n-1}&\\omega_{n}^{2(n-1)}&\\omega_{n}^{3(n-1)}&\\cdots&\\omega_{n}^{(n -1)(n-1)}\\end{array}\\right)\\left(\\begin{array}{c}a_{0}\\\\ a_{1}\\\\ a_{2}\\\\ a_{3}\\\\ \\vdots\\\\ a_{n-1}\\end{array}\\right)\\.\\]\n\nThe \\((k,j)\\) entry of \\(V_{n}\\) is \\(\\omega_{n}^{kj}\\), for \\(j,k=0,1,\\ldots,n-1\\). The exponents of the entries of \\(V_{n}\\) form a multiplication table for factors \\(0\\) to \\(n-1\\).\n\nFor the inverse operation, which we write as \\(a={\\rm DFT}_{n}^{-1}(y)\\), multiply \\(y\\) by the matrix \\(V_{n}^{-1}\\), the inverse of \\(V_{n}\\).\n\n**Theorem 30.7**: For \\(j,k=0,1,\\ldots,n-1\\), the \\((j,k)\\) entry of \\(V_{n}^{-1}\\) is \\(\\omega_{n}^{-jk}/n\\).\n\nProof.: We show that \\(V_{n}^{-1}V_{n}=I_{n}\\), the \\(n\\times n\\) identity matrix. Consider the \\((k,k^{\\prime})\\) entry of \\(V_{n}^{-1}V_{n}\\):\n\n\\[[V_{n}^{-1}V_{n}]_{kk^{\\prime}} = \\sum_{j=0}^{n-1}(\\omega_{n}^{-jk}/n)(\\omega_{n}^{jk^{\\prime}})\\] \\[= \\sum_{j=0}^{n-1}\\omega_{n}^{j(k^{\\prime}-k)}/n\\.\\]\n\nThis summation equals \\(1\\) if \\(k^{\\prime}=k\\), and it is \\(0\\) otherwise by the summation lemma (Lemma 30.6). Note that in order for the summation lemma to apply, \\(k^{\\prime}-k\\) must not be divisible by \\(n\\). Indeed, it is not, since \\(-(n-1)\\leq k^{\\prime}-k\\leq n-1\\).\n\nWith the inverse matrix \\(V_{n}^{-1}\\) defined, \\({\\rm DFT}_{n}^{-1}(y)\\) is given by\n\n\\[a_{j} = \\sum_{k=0}^{n-1}y_{k}\\,\\frac{\\omega^{-jk}}{n} \\tag{30.11}\\] \\[= \\frac{1}{n}\\sum_{k=0}^{n-1}y_{k}\\omega_{n}^{-kj}\\]\n\nfor \\(j=0,1,\\ldots,n-1\\). By comparing equations (30.8) and (30.11), you can see that if you modify the FFT algorithm to switch the roles of \\(a\\) and \\(y\\), replace \\(\\omega_{n}\\) by \\(\\omega_{n}^{-1}\\), and divide each element of the result by \\(n\\), you get the inverse DFT (see Exercise 30.2-4). Thus, \\({\\rm DFT}_{n}^{-1}\\) is computable in \\(\\Theta(n\\lg n)\\) time as well.\n\nThus, the FFT and the inverse FFT provide a way to transform a polynomial of degree-bound \\(n\\) back and forth between its coefficient representation and a point-value representation in only \\(\\Theta(n\\lg n)\\) time. In the context of polynomial multiplication, we have shown the following about the convolution \\(a\\otimes b\\) of vectors \\(a\\) and \\(b\\):\n\n**Theorem 30.8** (Convolution theorem): For any two vectors \\(a\\) and \\(b\\) of length \\(n\\), where \\(n\\) is an exact power of \\(2\\),\n\n\\(a\\otimes b={\\rm DFT}_{2n}^{-1}({\\rm DFT}_{2n}(a)\\cdot{\\rm DFT}_{2n}(b))\\),\n\nwhere the vectors \\(a\\) and \\(b\\) are padded with \\(0\\)s to length \\(2n\\) and \\(\\cdot\\) denotes the componentwise product of two \\(2n\\)-element vectors.\n\n#### 30.2 The DFT and FFT\n\n**Exercises**\n\n_30.2-1_\n\nProve Corollary 30.4.\n\n_30.2-2_\n\nCompute the DFT of the vector \\((0,1,2,3)\\).\n\n_30.2-3_\n\nDo Exercise 30.1-1 by using the \\(\\Theta(n\\lg n)\\)-time scheme.\n\n_30.2-4_\n\nWrite pseudocode to compute \\(\\mathrm{DFT}_{n}^{-1}\\) in \\(\\Theta(n\\lg n)\\) time.\n\n_30.2-5_\n\nDescribe the generalization of the FFT procedure to the case in which \\(n\\) is an exact power of 3. Give a recurrence for the running time, and solve the recurrence.\n\n\\(\\bigstar\\) _30.2-6_\n\nInstead of performing an \\(n\\)-element FFT over the field of complex numbers (where \\(n\\) is an exact power of 2), let's use the ring \\(\\mathbb{Z}_{m}\\) of integers modulo \\(m\\), where \\(m=2^{tn/2}+1\\) and \\(t\\) is an arbitrary positive integer. We can use \\(\\omega=2^{t}\\) instead of \\(\\omega_{n}\\) as a principal \\(n\\)th root of unity, modulo \\(m\\). Prove that the DFT and the inverse DFT are well defined in this system.\n\n_30.2-7_\n\nGiven a list of values \\(z_{0},z_{1},\\ldots,z_{n-1}\\) (possibly with repetitions), show how to find the coefficients of a polynomial \\(P(x)\\) of degree-bound \\(n+1\\) that has zeros only at \\(z_{0},z_{1},\\ldots,z_{n-1}\\) (possibly with repetitions). Your procedure should run in \\(O(n\\lg^{2}n)\\) time. (_Hint:_ The polynomial \\(P(x)\\) has a zero at \\(z_{j}\\) if and only if \\(P(x)\\) is a multiple of \\((x-z_{j})\\).)\n\n\\(\\bigstar\\) _30.2-8_\n\nThe _chirp transform_ of a vector \\(a=(a_{0},a_{1},\\ldots,a_{n-1})\\) is the vector \\(y=(y_{0},y_{1},\\ldots,y_{n-1})\\), where \\(y_{k}=\\sum_{j=0}^{n-1}a_{j}z^{kj}\\) and \\(z\\) is any complex number. The DFT is therefore a special case of the chirp transform, obtained by taking \\(z=\\omega_{n}\\). Show how to evaluate the chirp transform for any complex number \\(z\\) in \\(O(n\\lg n)\\) time. (_Hint:_ Use the equation\n\n\\[y_{k}=z^{k^{2}/2}\\sum_{j=0}^{n-1}\\left(a_{j}z^{j^{2}/2}\\right)\\left(z^{-(k-j)^ {2}/2}\\right)\\]\n\nto view the chirp transform as a convolution.)\n\n### FFT circuits\n\nMany of the FFT's applications in signal processing require the utmost speed, and so the FFT is often implemented as a circuit in hardware. The FFT's divide-and-conquer structure enables the circuit to have a parallel structure so that the _depth_ of the circuit--the maximum number of computational elements between any output and any input that can reach it--is \\(\\Theta(\\lg n)\\). Moreover, the structure of the FFT circuit has several interesting mathematical properties, which we won't go into here.\n\n##### Butterfly operations\n\nNotice that the **for** loop of lines 9-12 of the FFT procedure computes the value \\(\\omega_{n}^{k}\\;y_{k}^{\\rm odd}\\) twice per iteration: once in line 10 and once in line 11. A good optimizing compiler produces code that evaluates this _common subexpression_ just once, storing its value into a temporary variable, so that lines 10-11 are treated like the three lines\n\n\\[\\begin{array}{l}t\\;=\\;\\omega\\;y_{k}^{\\rm odd}\\\\ y_{k}\\;=\\;y_{k}^{\\rm even}+t\\\\ y_{k+(n/2)}\\;=\\;y_{k}^{\\rm even}-t\\end{array}\\]\n\nThis operation, multiplying the twiddle factor \\(\\omega=\\omega_{n}^{k}\\) by \\(y_{k}^{\\rm odd}\\), storing the product into the temporary variable \\(t\\), and adding and subtracting \\(t\\) from \\(y_{k}^{\\rm even}\\), is known as a _butterfly operation_. Figure 30.3 shows it as a circuit, and you can see how it vaguely resembles the shape of a butterfly. (Although less colorfully, it could have been called a \"bowtie\" operation.)\n\nFigure 30.3: A circuit for a butterfly operation. **(a)** The two input values enter from the left, the twiddle factor \\(\\omega_{n}^{k}\\) is multiplied by \\(y_{k}^{\\rm odd}\\), and the sum and difference are output on the right. **(b)** A simplified drawing of a butterfly operation, which we\u2019ll use when drawing the parallel FFT circuit.",
        "chapter": "Part VII Selected Topics",
        "section": "30 Polynomials and the FFT",
        "subsection": "30.2 The DFT and FFT",
        "subsubsection": "N/A"
    },
    {
        "content": "### FFT circuits\n\nMany of the FFT's applications in signal processing require the utmost speed, and so the FFT is often implemented as a circuit in hardware. The FFT's divide-and-conquer structure enables the circuit to have a parallel structure so that the _depth_ of the circuit--the maximum number of computational elements between any output and any input that can reach it--is \\(\\Theta(\\lg n)\\). Moreover, the structure of the FFT circuit has several interesting mathematical properties, which we won't go into here.\n\n#### Butterfly operations\n\nNotice that the **for** loop of lines 9-12 of the FFT procedure computes the value \\(\\omega_{n}^{k}\\;y_{k}^{\\rm odd}\\) twice per iteration: once in line 10 and once in line 11. A good optimizing compiler produces code that evaluates this _common subexpression_ just once, storing its value into a temporary variable, so that lines 10-11 are treated like the three lines\n\n\\[\\begin{array}{l}t\\;=\\;\\omega\\;y_{k}^{\\rm odd}\\\\ y_{k}\\;=\\;y_{k}^{\\rm even}+t\\\\ y_{k+(n/2)}\\;=\\;y_{k}^{\\rm even}-t\\end{array}\\]\n\nThis operation, multiplying the twiddle factor \\(\\omega=\\omega_{n}^{k}\\) by \\(y_{k}^{\\rm odd}\\), storing the product into the temporary variable \\(t\\), and adding and subtracting \\(t\\) from \\(y_{k}^{\\rm even}\\), is known as a _butterfly operation_. Figure 30.3 shows it as a circuit, and you can see how it vaguely resembles the shape of a butterfly. (Although less colorfully, it could have been called a \"bowtie\" operation.)\n\nFigure 30.3: A circuit for a butterfly operation. **(a)** The two input values enter from the left, the twiddle factor \\(\\omega_{n}^{k}\\) is multiplied by \\(y_{k}^{\\rm odd}\\), and the sum and difference are output on the right. **(b)** A simplified drawing of a butterfly operation, which we\u2019ll use when drawing the parallel FFT circuit.\n\n### 30.3 FFT circuits\n\nThe FFT procedure follows the divide-and-conquer strategy that we first saw in Section 2.3.1:\n\n**Divide** the \\(n\\)-element input vector into its \\(n/2\\) even-indexed and \\(n/2\\) odd-indexed elements.\n**Conquer**: by recursively computing the DFTs of the two subproblems, each of size \\(n/2\\).\n**Combine** by performing \\(n/2\\) butterfly operations. These butterfly operations work with twiddle factors \\(\\omega_{n}^{0},\\omega_{n}^{1},\\ldots,\\omega_{n}^{n/2-1}\\).\n\nThe circuit schema in Figure 30.4 follows the conquer and combine steps of this pattern for an FFT circuit with \\(n\\) inputs and \\(n\\) outputs, denoted by \\(\\mathrm{FFT}_{n}\\). Each line is a wire that carries a value. Inputs enter from the left, one per wire, and outputs exit from the right. The conquer step runs the inputs through two \\(\\mathrm{FFT}_{n/2}\\) circuits, which are also constructed recursively. The values produced by the two \\(\\mathrm{FFT}_{n/2}\\) circuits feed into \\(n/2\\) butterfly circuits, with twiddle factors \\(\\omega_{n}^{0},\\omega_{n}^{1},\\ldots,\\omega_{n}^{n/2}-1\\)\n\nFigure 30.4: The schema for the conquer and combine steps of an \\(n\\)-input, \\(n\\)-output FFT circuit, \\(\\mathrm{FFT}_{n}\\), shown for \\(n=8\\). Inputs enter from the left, and outputs exit from the right. The input values first go through two \\(\\mathrm{FFT}_{n/2}\\) circuits, and then \\(n/2\\) butterfly circuits combine the results. Only the top and bottom wires entering a butterfly interact with it: wires that pass through the middle of a butterfly do not affect that butterfly, nor are their values changed by that butterfly.\n\nto combine the results. The base case of the recursion occurs when \\(n=1\\), where the sole output value equals the sole input value. An FFT\\({}_{1}\\) circuit, therefore, does nothing, and so the smallest nontrivial FFT circuit is FFT\\({}_{2}\\), a single butterfly operation whose twiddle factor is \\(\\omega_{2}^{0}=1\\).\n\n##### Permuting the inputs\n\nHow does the divide step enter into the circuit design? Let's examine how input vectors to the various recursive calls of the FFT procedure relate to the original input vector, so that the circuit can emulate the divide step at the start for all levels of recursion. Figure 30.5 arranges the input vectors to the recursive calls in an invocation of FFT in a tree structure, where the initial call is for \\(n=8\\). The tree has one node for each call of the procedure, labeled by the elements of the initial call as they appear in the corresponding input vector. Each FFT invocation makes two recursive calls, unless it has received a 1-element vector. The first call appears in the left child, and the second call appears in the right child.\n\nLooking at the tree, observe that if you arrange the elements of the initial vector \\(a\\) into the order in which they appear in the leaves, you can trace the execution of the FFT procedure, but bottom up instead of top down. First, take the elements in pairs, compute the DFT of each pair using one butterfly operation, and replace the pair with its DFT. The vector then holds \\(n/2\\) two-element DFTs. Next, take these \\(n/2\\) DFTs in pairs and compute the DFT of the four vector elements they come from by executing two butterfly operations, replacing two two-element DFTs with one four-element DFT. The vector then holds \\(n/4\\) four-element DFTs. Continue in this manner until the vector holds two (\\(n/2\\))-element DFTs, which \\(n/2\\) butterfly operations combine into the final \\(n\\)-element DFT. In other words, you can start with the elements of the initial vector \\(a\\), but rearranged as in the leaves of Figure 30.5, and then feed them directly into a circuit that follows the schema in Figure 30.4.\n\nFigure 30.5: The tree of input vectors to the recursive calls of the FFT procedure. The initial invocation is for \\(n=8\\).\n\n### FFT circuits\n\nLet's think about the permutation that rearranges the input vector. The order in which the leaves appear in Figure 30.5 is a _bit-reversal permutation_. That is, letting \\(\\operatorname{rev}(k)\\) be the \\(\\lg n\\)-bit integer formed by reversing the bits of the binary representation of \\(k\\), then vector element \\(a_{k}\\) moves to position \\(\\operatorname{rev}(k)\\). In Figure 30.5, for example, the leaves appear in the order \\(0,4,2,6,1,5,3,7\\). This sequence in binary is \\(000,100,010,110,001,101,111\\), and you can obtain it by reversing the bits of each number in the sequence \\(0,1,2,3,4,6,7\\) or, in binary, \\(000,001,010,011,100,101,110,111\\). To see in general that the input vector should be rearranged by a bit-reversal permutation, note that at the top level of the tree, indices whose low-order bit is \\(0\\) go into the left subtree and indices whose low-order bit is \\(1\\) go into the right subtree. Stripping off the low-order bit at each level, continue this process down the tree, until you get the order given by the bit-reversal permutation at the leaves.\n\n#### The full FFT circuit\n\nFigure 30.6 depicts the entire circuit for \\(n=8\\). The circuit begins with a bit-reversal permutation of the inputs, followed by \\(\\lg n\\) stages, each stage consisting of \\(n/2\\) butterflies executed in parallel. Assuming that each butterfly circuit has constant depth, the full circuit has depth \\(\\Theta(\\lg n)\\). The butterfly operations at each level of recursion in the FFT procedure are independent, and so the circuit performs them in parallel. The figure shows wires running from left to right, carrying values through the \\(\\lg n\\) stages. For \\(s=1,2,\\ldots,\\lg n\\), stage \\(s\\) consists of \\(n/2^{s}\\) groups of butterflies, with \\(2^{s-1}\\) butterflies per group. The twiddle factors in stage \\(s\\) are \\(\\omega_{m}^{0},\\omega_{m}^{1},\\ldots,\\omega_{m}^{m/2-1}\\), where \\(m=2^{s}\\).\n\n#### Exercises\n\n#### 30.3-1\n\nShow the values on the wires for each butterfly input and output in the FFT circuit of Figure 30.6, given the input vector \\((0,2,3,-1,4,5,7,9)\\).\n\n#### 30.3-2\n\nConsider an \\(\\operatorname{FFT}_{n}\\) circuit, such as in Figure 30.6, with wires \\(0,1,\\ldots,n-1\\) (wire \\(j\\) has output \\(y_{j}\\)) and stages numbered as in the figure. Stage \\(s\\), for \\(s=1,2\\ldots,\\lg n\\), consists of \\(n/2^{s}\\) groups of butterflies. Which two wires are inputs and outputs for the \\(j\\)th butterfly circuit in the \\(g\\)th group in stage \\(s\\)?\n\n#### 30.3-3\n\nConsider a \\(b\\)-bit integer \\(k\\) in the range \\(0\\leq k<2^{b}\\). Treating \\(k\\) as a \\(b\\)-element vector over \\(\\{0,1\\}\\), describe a \\(b\\times b\\) matrix \\(M\\) such that the matrix-vector product \\(Mk\\) is the binary representation of \\(\\operatorname{rev}(k)\\).\n\n### 30.3-4\n\nWrite pseudocode for the procedure Bit-Reverse-Permutation\\((a,n)\\), which performs the bit-reversal permutation on a vector \\(a\\) of length \\(n\\) in-place. Assume that you may call the procedure Bit-Reverse-Of\\((k,b)\\), which returns an integer that is the \\(b\\)-bit reversal of the nonnegative integer \\(k\\), where \\(0\\leq k<2^{b}\\).\n* _30.3-5_ Suppose that the adders within the butterfly operations of a given FFT circuit sometimes fail in such a manner that they always produce a 0 output, independent of their inputs. In addition, suppose that exactly one adder has failed, but you don't know which one. Describe how you can identify the failed adder by supplying inputs to the overall FFT circuit and observing the outputs. How efficient is your method?\n\nFigure 30.6: A full circuit that computes the FFT in parallel, here shown for \\(n=8\\) inputs. It has \\(\\lg n\\) stages, and each stage comprises \\(n/2\\) butterflies that can operate in parallel. As in Figure 30.4, only the top and bottom wires entering a butterfly interact with it. For example, the top butterfly in stage 2 has inputs and outputs only on wires 0 and 2 (the wires with outputs \\(y_{0}\\) and \\(y_{2}\\), respectively). This circuit has depth \\(\\Theta(\\lg n)\\) and performs \\(\\Theta(n\\lg n)\\) butterfly operations altogether.\n\n## Problems\n\n### Divide-and-conquer multiplication\n\n* Show how to multiply two linear polynomials \\(ax+b\\) and \\(cx+d\\) using only three multiplications. (_Hint:_ One of the multiplications is \\((a+b)\\cdot(c+d)\\).)\n* Give two divide-and-conquer algorithms for multiplying two polynomials of degree-bound \\(n\\) in \\(\\Theta(n^{\\lg 3})\\) time. The first algorithm should divide the input polynomial coefficients into a high half and a low half, and the second algorithm should divide them according to whether their index is odd or even.\n* Show how to multiply two \\(n\\)-bit integers in \\(O(n^{\\lg 3})\\) steps, where each step operates on at most a constant number of 1-bit values.\n\n### Multidimensional fast Fourier transform\n\nThe 1-dimensional discrete Fourier transform defined by equation (30.8) generalizes to \\(d\\) dimensions. The input is a \\(d\\)-dimensional array \\(A=(a_{j_{1},j_{2},\\ldots,j_{d}})\\) whose dimensions are \\(n_{1},n_{2},\\ldots,n_{d}\\), where \\(n_{1}n_{2}\\cdots n_{d}=n\\). The \\(d\\)-dimensional discrete Fourier transform is defined by the equation\n\n\\[y_{k_{1},k_{2},\\ldots,k_{d}}=\\sum_{j_{1}=0}^{n_{1}-1}\\sum_{j_{2}=0}^{n_{2}-1} \\cdots\\sum_{j_{d}=0}^{n_{d}-1}a_{j_{1},j_{2},\\ldots,j_{d}}\\omega_{n_{1}}^{j_{ 1}k_{1}}\\omega_{n_{2}}^{j_{2}k_{2}}\\cdots\\omega_{n_{d}}^{j_{d}k_{d}}\\]\n\nfor \\(0\\leq k_{1}<n_{1}\\), \\(0\\leq k_{2}<n_{2}\\),..., \\(0\\leq k_{d}<n_{d}\\).\n\n* Show how to produce a \\(d\\)-dimensional DFT by computing 1-dimensional DFTs on each dimension in turn. That is, first compute \\(n/n_{1}\\) separate 1-dimensional DFTs along dimension 1. Then, using the result of the DFTs along dimension 1 as the input, compute \\(n/n_{2}\\) separate 1-dimensional DFTs along dimension 2. Using this result as the input, compute \\(n/n_{3}\\) separate 1-dimensional DFTs along dimension 3, and so on, through dimension \\(d\\).\n* Show that the ordering of dimensions does not matter, so that if you compute the 1-dimensional DFTs in any order of the \\(d\\) dimensions, you compute the \\(d\\)-dimensional DFT.\n* Show that if you compute each 1-dimensional DFT by computing the fast Fourier transform, the total time to compute a \\(d\\)-dimensional DFT is \\(O(n\\lg n)\\), independent of \\(d\\).",
        "chapter": "Part VII Selected Topics",
        "section": "30 Polynomials and the FFT",
        "subsection": "30.3 FFT circuits",
        "subsubsection": "N/A"
    },
    {
        "content": "## Problems\n\n### Divide-and-conquer multiplication\n\nShow how to multiply two linear polynomials \\(ax+b\\) and \\(cx+d\\) using only three multiplications. (_Hint:_ One of the multiplications is \\((a+b)\\cdot(c+d)\\).)\n\nGive two divide-and-conquer algorithms for multiplying two polynomials of degree-bound \\(n\\) in \\(\\Theta(n^{\\lg 3})\\) time. The first algorithm should divide the input polynomial coefficients into a high half and a low half, and the second algorithm should divide them according to whether their index is odd or even.\n\nShow how to multiply two \\(n\\)-bit integers in \\(O(n^{\\lg 3})\\) steps, where each step operates on at most a constant number of 1-bit values.\n\n### Multidimensional fast Fourier transform\n\nThe 1-dimensional discrete Fourier transform defined by equation (30.8) generalizes to \\(d\\) dimensions. The input is a \\(d\\)-dimensional array \\(A=(a_{j_{1},j_{2},\\ldots,j_{d}})\\) whose dimensions are \\(n_{1},n_{2},\\ldots,n_{d}\\), where \\(n_{1}n_{2}\\cdots n_{d}=n\\). The \\(d\\)-dimensional discrete Fourier transform is defined by the equation\n\n\\[y_{k_{1},k_{2},\\ldots,k_{d}}=\\sum_{j_{1}=0}^{n_{1}-1}\\sum_{j_{2}=0}^{n_{2}-1} \\cdots\\sum_{j_{d}=0}^{n_{d}-1}a_{j_{1},j_{2},\\ldots,j_{d}}\\omega_{n_{1}}^{j_{ 1}k_{1}}\\omega_{n_{2}}^{j_{2}k_{2}}\\cdots\\omega_{n_{d}}^{j_{d}k_{d}}\\]\n\nfor \\(0\\leq k_{1}<n_{1}\\), \\(0\\leq k_{2}<n_{2}\\),..., \\(0\\leq k_{d}<n_{d}\\).\n\nShow how to produce a \\(d\\)-dimensional DFT by computing 1-dimensional DFTs on each dimension in turn. That is, first compute \\(n/n_{1}\\) separate 1-dimensional DFTs along dimension 1. Then, using the result of the DFTs along dimension 1 as the input, compute \\(n/n_{2}\\) separate 1-dimensional DFTs along dimension 2. Using this result as the input, compute \\(n/n_{3}\\) separate 1-dimensional DFTs along dimension 3, and so on, through dimension \\(d\\).\n\nShow that the ordering of dimensions does not matter, so that if you compute the 1-dimensional DFTs in any order of the \\(d\\) dimensions, you compute the \\(d\\)-dimensional DFT.\n\nShow that if you compute each 1-dimensional DFT by computing the fast Fourier transform, the total time to compute a \\(d\\)-dimensional DFT is \\(O(n\\lg n)\\), independent of \\(d\\).\n\n### 30.3 Evaluating all derivatives of a polynomial at a point\n\nGiven a polynomial \\(A(x)\\) of degree-bound \\(n\\), we define its \\(t\\)th derivative by\n\n\\[A^{(t)}(x)=\\left\\{\\begin{array}{ll}A(x)&\\mbox{if $t\\,=\\,0$,}\\\\ \\frac{d}{dx}A^{(t-1)}(x)&\\mbox{if $1\\,\\leq\\,t\\,\\leq n-1$,}\\\\ 0&\\mbox{if $t\\,\\geq\\,n$.}\\end{array}\\right.\\]\n\nIn this problem, you will show how to determine \\(A^{(t)}(x_{0})\\) for \\(t=0,1,\\ldots,n-1\\), given the coefficient representation \\((a_{0},a_{1},\\ldots,a_{n-1})\\) of \\(A(x)\\) and a point \\(x_{0}\\).\n\n**a.** Given coefficients \\(b_{0},b_{1},\\ldots,b_{n-1}\\) such that\n\n\\[A(x)=\\sum_{j=0}^{n-1}b_{j}(x-x_{0})^{j}\\,\\]\n\nshow how to compute \\(A^{(t)}(x_{0})\\), for \\(t=0,1,\\ldots,n-1\\), in \\(O(n)\\) time.\n\n**b.** Explain how to find \\(b_{0},b_{1},\\ldots,b_{n-1}\\) in \\(O(n\\lg n)\\) time, given \\(A(x_{0}+\\omega_{n}^{k})\\) for \\(k=0,1,\\ldots,n-1\\).\n\n**c.** Prove that\n\n\\[A(x_{0}+\\omega_{n}^{k})=\\sum_{r=0}^{n-1}\\left(\\frac{\\omega_{n}^{kr}}{r!}\\,\\sum _{j=0}^{n-1}f(j)g(r-j)\\right)\\,\\]\n\nwhere \\(f(j)=a_{j}\\cdot j\\)! and\n\n\\[g(l)=\\left\\{\\begin{array}{ll}x_{0}^{-l}/(-l)!&\\mbox{if $-(n-1)\\leq l\\,\\leq 0$,}\\\\ 0&\\mbox{if $1\\leq l\\,\\leq n-1$.}\\end{array}\\right.\\]\n\n**d.** Explain how to evaluate \\(A(x_{0}+\\omega_{n}^{k})\\) for \\(k=0,1,\\ldots,n-1\\) in \\(O(n\\lg n)\\) time. Conclude that you can evaluate all nontrivial derivatives of \\(A(x)\\) at \\(x_{0}\\) in \\(O(n\\lg n)\\) time.\n\n### 30.4 Polynomial evaluation at multiple points\n\nProblem 2-3 showed how to evaluate a polynomial of degree-bound \\(n\\) at a single point in \\(O(n)\\) time using Horner's rule. This chapter described how to evaluate such a polynomial at all \\(n\\) complex roots of unity in \\(O(n\\lg n)\\) time using the FFT. Now, you will show how to evaluate a polynomial of degree-bound \\(n\\) at \\(n\\) arbitrary points in \\(O(n\\lg^{2}n)\\) time.\n\nTo do so, assume that you can compute the polynomial remainder when one such polynomial is divided by another in \\(O(n\\lg n)\\) time. For example, the remainder of \\(3x^{3}+x^{2}-3x+1\\) when divided by \\(x^{2}+x+2\\) is\n\n\\((3x^{3}+x^{2}-3x+1)\\) mod \\((x^{2}+x+2)=-7x+5\\).\n\nGiven the coefficient representation of a polynomial \\(A(x)=\\sum_{k=0}^{n-1}a_{k}x^{k}\\) and \\(n\\) points \\(x_{0},x_{1},\\ldots,x_{n-1}\\), your goal is to compute the \\(n\\) values \\(A(x_{0}),A(x_{1}),\\ldots,\\)\\(A(x_{n-1})\\). For \\(0\\leq i\\leq j\\leq n-1\\), define the polynomials \\(P_{i/j}(x)=\\prod_{k=i}^{j}(x-x_{k})\\) and \\(Q_{ij}(x)=A(x)\\) mod \\(P_{ij}(x)\\). Note that \\(Q_{ij}(x)\\) has degree at most \\(j-i\\).\n\n_a._ Prove that \\(A(x)\\) mod \\((x-z)=A(z)\\) for any point \\(z\\).\n\n_b._ Prove that \\(Q_{kk}(x)=A(x_{k})\\) and that \\(Q_{0,n-1}(x)=A(x)\\).\n\n_c._ Prove that for \\(i\\leq k\\leq j\\), we have both \\(Q_{ik}(x)=Q_{ij}(x)\\) mod \\(P_{ik}(x)\\) and \\(Q_{kj}(x)=Q_{ij}(x)\\) mod \\(P_{kj}(x)\\).\n\n_d._ Give an \\(O(n\\lg^{2}n)\\)-time algorithm to evaluate \\(A(x_{0})\\), \\(A(x_{1}),\\ldots,A(x_{n-1})\\).\n\n_30-5 FFT using modular arithmetic_\n\nAs defined, the discrete Fourier transform requires computation with complex numbers, which can result in a loss of precision due to round-off errors. For some problems, the answer is known to contain only integers, and a variant of the FFT based on modular arithmetic can guarantee that the answer is calculated exactly. An example of such a problem is that of multiplying two polynomials with integer coefficients. Exercise 30.2-6 gives one approach, using a modulus of length \\(\\Omega(n)\\) bits to handle a DFT on \\(n\\) points. This problem explores another approach that uses a modulus of the more reasonable length \\(O(\\lg n)\\), but it requires that you understand the material of Chapter 31. Let \\(n\\) be an exact power of \\(2\\).\n\n_a._ You wish to search for the smallest \\(k\\) such that \\(p=k\\,n+1\\) is prime. Give a simple heuristic argument why you might expect \\(k\\) to be approximately \\(\\ln n\\). (The value of \\(k\\) might be much larger or smaller, but you can reasonably expect to examine \\(O(\\lg n)\\) candidate values of \\(k\\) on average.) How does the expected length of \\(p\\) compare to the length of \\(n\\)?\n\nLet \\(g\\) be a generator of \\(\\mathbb{Z}_{p}^{\\star}\\), and let \\(w=g^{k}\\) mod \\(p\\).\n\n_b._ Argue that the DFT and the inverse DFT are well-defined inverse operations modulo \\(p\\), where \\(w\\) is used as a principal \\(n\\)th root of unity.\n\n_c._ Show how to make the FFT and its inverse work modulo \\(p\\) in \\(O(n\\lg n)\\) time, where operations on words of \\(O(\\lg n)\\) bits take unit time. Assume that the algorithm is given \\(p\\) and \\(w\\).\n\n4. Compute the DFT modulo \\(p=17\\) of the vector \\((0,5,3,7,7,2,1,6)\\). (_Hint:_ Verify and use the fact that \\(g=3\\) is a generator of \\(\\mathbb{Z}_{17}^{*}\\).)\n\n## Chapter notes\n\nVan Loan's book [442] provides an outstanding treatment of the fast Fourier transform. Press, Teukolsky, Vetterling, and Flannery [365, 366] offer a good description of the fast Fourier transform and its applications. For an excellent introduction to signal processing, a popular FFT application area, see the texts by Oppenheim and Schafer [347] and Oppenheim and Willsky [348]. The Oppenheim and Schafer book also shows how to handle cases in which \\(n\\) is not an exact power of 2.\n\nFourier analysis is not limited to 1-dimensional data. It is widely used in image processing to analyze data in two or more dimensions. The books by Gonzalez and Woods [194] and Pratt [363] discuss multidimensional Fourier transforms and their use in image processing, and books by Tolimieri, An, and Lu [439] and Van Loan [442] discuss the mathematics of multidimensional fast Fourier transforms.\n\nCooley and Tukey [101] are widely credited with devising the FFT in the 1960s. The FFT had in fact been discovered many times previously, but its importance was not fully realized before the advent of modern digital computers. Although Press, Teukolsky, Vetterling, and Flannery attribute the origins of the method to Runge and Konig in 1924, an article by Heideman, Johnson, and Burrus [211] traces the history of the FFT as far back as C. F. Gauss in 1805.\n\nFrigo and Johnson [161] developed a fast and flexible implementation of the FFT, called FFTW (\"fastest Fourier transform in the West\"). FFTW is designed for situations requiring multiple DFT computations on the same problem size. Before actually computing the DFTs, FFTW executes a \"planner,\" which, by a series of trial runs, determines how best to decompose the FFT computation for the given problem size on the host machine. FFTW adapts to use the hardware cache efficiently, and once subproblems are small enough, FFTW solves them with optimized, straight-line code. Moreover, FFTW has the advantage of taking \\(\\Theta(n\\lg n)\\) time for any problem size \\(n\\), even when \\(n\\) is a large prime.\n\nAlthough the standard Fourier transform assumes that the input represents points that are uniformly spaced in the time domain, other techniques can approximate the FFT on \"nonequispaced\" data. The article by Ware [449] provides an overview.",
        "chapter": "Part VII Selected Topics",
        "section": "30 Polynomials and the FFT",
        "subsection": "Problems",
        "subsubsection": "N/A"
    },
    {
        "content": "4. Compute the DFT modulo \\(p=17\\) of the vector \\((0,5,3,7,7,2,1,6)\\). (_Hint:_ Verify and use the fact that \\(g=3\\) is a generator of \\(\\mathbb{Z}_{17}^{*}\\).)\n\n## Chapter notes\n\nVan Loan's book [442] provides an outstanding treatment of the fast Fourier transform. Press, Teukolsky, Vetterling, and Flannery [365, 366] offer a good description of the fast Fourier transform and its applications. For an excellent introduction to signal processing, a popular FFT application area, see the texts by Oppenheim and Schafer [347] and Oppenheim and Willsky [348]. The Oppenheim and Schafer book also shows how to handle cases in which \\(n\\) is not an exact power of \\(2\\).\n\nFourier analysis is not limited to \\(1\\)-dimensional data. It is widely used in image processing to analyze data in two or more dimensions. The books by Gonzalez and Woods [194] and Pratt [363] discuss multidimensional Fourier transforms and their use in image processing, and books by Tolimieri, An, and Lu [439] and Van Loan [442] discuss the mathematics of multidimensional fast Fourier transforms.\n\nCooley and Tukey [101] are widely credited with devising the FFT in the 1960s. The FFT had in fact been discovered many times previously, but its importance was not fully realized before the advent of modern digital computers. Although Press, Teukolsky, Vetterling, and Flannery attribute the origins of the method to Runge and Konig in 1924, an article by Heideman, Johnson, and Burrus [211] traces the history of the FFT as far back as C. F. Gauss in 1805.\n\nFrigo and Johnson [161] developed a fast and flexible implementation of the FFT, called FFTW (\"fastest Fourier transform in the West\"). FFTW is designed for situations requiring multiple DFT computations on the same problem size. Before actually computing the DFTs, FFTW executes a \"planner,\" which, by a series of trial runs, determines how best to decompose the FFT computation for the given problem size on the host machine. FFTW adapts to use the hardware cache efficiently, and once subproblems are small enough, FFTW solves them with optimized, straight-line code. Moreover, FFTW has the advantage of taking \\(\\Theta(n\\lg n)\\) time for any problem size \\(n\\), even when \\(n\\) is a large prime.\n\nAlthough the standard Fourier transform assumes that the input represents points that are uniformly spaced in the time domain, other techniques can approximate the FFT on \"nonequispaced\" data. The article by Ware [449] provides an overview.\n\nNumber theory was once viewed as a beautiful but largely useless subject in pure mathematics. Today number-theoretic algorithms are used widely, due in large part to the invention of cryptographic schemes based on large prime numbers. These schemes are feasible because we can find large primes quickly, and they are secure because we do not know how to factor the product of large primes (or solve related problems, such as computing discrete logarithms) efficiently. This chapter presents some of the number theory and related algorithms that underlie such applications.\n\nWe start in Section 31.1 by introducing basic concepts of number theory, such as divisibility, modular equivalence, and unique prime factorization. Section 31.2 studies one of the world's oldest algorithms: Euclid's algorithm for computing the greatest common divisor of two integers, and Section 31.3 reviews concepts of modular arithmetic. Section 31.4 then explores the set of multiples of a given number \\(a\\), modulo \\(n\\), and shows how to find all solutions to the equation \\(ax=b\\pmod{n}\\) by using Euclid's algorithm. The Chinese remainder theorem is presented in Section 31.5. Section 31.6 considers powers of a given number \\(a\\), modulo \\(n\\), and presents a repeated-squaring algorithm for efficiently computing \\(a^{b}\\bmod n\\), given \\(a\\), \\(b\\), and \\(n\\). This operation is at the heart of efficient primality testing and of much modern cryptography, such as the RSA public-key cryptosystem described in Section 31.7. We wrap up in Section 31.8, which examines a randomized primality test. This test finds large primes efficiently, an essential step in creating keys for the RSA cryptosystem.\n\n#### Size of inputs and cost of arithmetic computations\n\nBecause we'll be working with large integers, we need to adjust how to think about the size of an input and about the cost of elementary arithmetic operations.\n\nIn this chapter, a \"large input\" typically means an input containing \"large integers\" rather than an input containing \"many integers\" (as for sorting). Thus, the size of an input depends on the _number of bits_ required to represent that input, not just the number of integers in the input. An algorithm with integer in",
        "chapter": "Part VII Selected Topics",
        "section": "30 Polynomials and the FFT",
        "subsection": "Chapter notes",
        "subsubsection": "N/A"
    },
    {
        "content": "puts \\(a_{1},a_{2},\\ldots,a_{k}\\) is a _polynomial-time algorithm_ if it runs in time polynomial in \\(\\lg a_{1},\\lg a_{2},\\ldots,\\lg a_{k}\\), that is, polynomial in the lengths of its binary-encoded inputs.\n\nMost of this book considers the elementary arithmetic operations (multiplications, divisions, or computing remainders) as primitive operations that take one unit of time. Counting the number of such arithmetic operations that an algorithm performs provides a basis for making a reasonable estimate of the algorithm's actual running time on a computer. Elementary operations can be time-consuming, however, when their inputs are large. It thus becomes appropriate to measure how many _bit operations_ a number-theoretic algorithm requires. In this model, multiplying two \\(\\beta\\)-bit integers by the ordinary method uses \\(\\Theta(\\beta^{2})\\) bit operations. Similarly, dividing a \\(\\beta\\)-bit integer by a shorter integer or taking the remainder of a \\(\\beta\\)-bit integer when divided by a shorter integer requires \\(\\Theta(\\beta^{2})\\) time by simple algorithms. (See Exercise 31.1-12.) Faster methods are known. For example, a simple divide-and-conquer method for multiplying two \\(\\beta\\)-bit integers has a running time of \\(\\Theta(\\beta^{\\lg 3})\\), and \\(O(\\beta\\lg\\beta\\lg\\beta)\\) time is possible. For practical purposes, however, the \\(\\Theta(\\beta^{2})\\) algorithm is often best, and we use this bound as a basis for our analyses. In this chapter, we'll usually analyze algorithms in terms of both the number of arithmetic operations and the number of bit operations they require.\n\n### Elementary number-theoretic notions\n\nThis section provides a brief review of notions from elementary number theory concerning the set \\(\\mathbb{Z}=\\{\\ldots,-2,-1,0,1,2,\\ldots\\}\\) of integers and the set \\(\\mathbb{N}=\\{0,1,2,\\ldots\\}\\) of natural numbers.\n\n#### Divisibility and divisors\n\nThe notion of one integer being divisible by another is key to the theory of numbers. The notation \\(d\\mid a\\) (read \"\\(d\\)_divides_\\(a\\)\") means that \\(a=k\\,d\\) for some integer \\(k\\). Every integer divides \\(0\\). If \\(a>0\\) and \\(d\\mid a\\), then \\(|d|\\leq|a|\\). If \\(d\\mid a\\), then we also say that \\(a\\) is a _multiple_ of \\(d\\). If \\(d\\) does not divide \\(a\\), we write \\(d\\nmid a\\).\n\nIf \\(d\\mid a\\) and \\(d\\geq 0\\), then \\(d\\) is a _divisor_ of \\(a\\). Since \\(d\\mid a\\) if and only if \\(-d\\mid a\\), without loss of generality, we define the divisors of \\(a\\) to be nonnegative, with the understanding that the negative of any divisor of \\(a\\) also divides \\(a\\). A divisor of a nonzero integer \\(a\\) is at least \\(1\\) but not greater than \\(|a|\\). For example, the divisors of \\(24\\) are \\(1,2,3,4,6,8,12\\), and \\(24\\).\n\nEvery positive integer \\(a\\) is divisible by the _trivial divisors_\\(1\\) and \\(a\\). The nontrivial divisors of \\(a\\) are the _factors_ of \\(a\\). For example, the factors of \\(20\\) are \\(2,4,5,\\) and \\(10\\)\n\n### Prime and composite numbers\n\nAn integer \\(a>1\\) whose only divisors are the trivial divisors \\(1\\) and \\(a\\) is a _prime number_ or, more simply, a _prime_. Primes have many special properties and play a critical role in number theory. The first \\(20\\) primes, in order, are\n\n2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71\n\nExercise 31.1-2 asks you to prove that there are infinitely many primes. An integer \\(a>1\\) that is not prime is a _composite number_ or, more simply, a _composite_. For example, \\(39\\) is composite because \\(3\\mid 39\\). We call the integer \\(1\\) a _unit_, and it is neither prime nor composite. Similarly, the integer \\(0\\) and all negative integers are neither prime nor composite.\n\n### The division theorem, remainders, and modular equivalence\n\nGiven an integer \\(n\\), we can partition the integers into those that are multiples of \\(n\\) and those that are not multiples of \\(n\\). Much number theory is based upon refining this partition by classifying the integers that are not multiples of \\(n\\) according to their remainders when divided by \\(n\\). The following theorem provides the basis for this refinement. We omit the proof (but see, for example, Niven and Zuckerman [345]).\n\n_Theorem 31.1 (Division theorem)_\n\nFor any integer \\(a\\) and any positive integer \\(n\\), there exist unique integers \\(q\\) and \\(r\\) such that \\(0\\leq r<n\\) and \\(a=qn+r\\).\n\nThe value \\(q=\\lfloor a/n\\rfloor\\) is the _quotient_ of the division. The value \\(r=a\\) mod \\(n\\) is the _remainder_ (or _residue_) of the division, so that \\(n\\mid a\\) if and only if \\(a\\mod n=0\\).\n\nThe integers partition into \\(n\\) equivalence classes according to their remainders modulo \\(n\\). The _equivalence class modulo \\(n\\)_ containing an integer \\(a\\) is\n\n\\([a]_{n}=\\{a+k\\,n:k\\in\\mathbb{Z}\\}\\) .\n\nFor example, \\([3]_{7}=\\{\\ldots,-11,-4,3,10,17,\\ldots\\}\\), and \\([-4]_{7}\\) and \\([10]_{7}\\) also denote this set. With the notation defined on page 64, writing \\(a\\in[b]_{n}\\) is the same as writing \\(a=b\\pmod{n}\\). The set of all such equivalence classes is\n\n\\(\\mathbb{Z}_{n}=\\{[a]_{n}:0\\leq a\\leq n-1\\}\\) .\n\nWhen you see the definition\n\n\\(\\mathbb{Z}_{n}=\\{0,1,\\ldots,n-1\\}\\) ,\n\nyou should read it as equivalent to equation (31.1) with the understanding that \\(0\\) represents \\([0]_{n}\\), \\(1\\) represents \\([1]_{n}\\), and so on. Each class is represented by itssmallest nonnegative element. You should keep the underlying equivalence classes in mind, however. For example, if we refer to \\(-1\\) as a member of \\(\\mathbb{Z}_{n}\\), we are really referring to \\([n-1]_{n}\\), since \\(-1=n-1\\pmod{n}\\).\n\n##### Common divisors and greatest common divisors\n\nIf \\(d\\) is a divisor of \\(a\\) and \\(d\\) is also a divisor of \\(b\\), then \\(d\\) is a _common divisor_ of \\(a\\) and \\(b\\). For example, the divisors of 30 are 1, 2, 3, 5, 6, 10, 15, and 30, and so the common divisors of 24 and 30 are 1, 2, 3, and 6. Any pair of integers has a common divisor of 1.\n\nAn important property of common divisors is that\n\nif\n\n\\[d\\mid a\\]\n\n and\n\n\\[d\\mid b\\]\n\n, then\n\n\\[d\\mid(a+b)\\]\n\n and\n\n\\[d\\mid(a-b)\\]\n\n. (31.3)\n\nMore generally, for any integers \\(x\\) and \\(y\\),\n\nif\n\n\\[d\\mid a\\]\n\n and\n\n\\[d\\mid b\\]\n\n, then\n\n\\[d\\mid(ax+by)\\]\n\n. (31.4)\n\nAlso, if\n\n\\[a\\mid b\\]\n\n, then either\n\n\\[|a|\\leq|b|\\]\n\n or\n\n\\[b=0\\]\n\n, which implies that\n\nif\n\n\\[a\\mid b\\]\n\n and\n\n\\[b\\mid a\\]\n\n, then\n\n\\[a=\\pm b\\]\n\n. (31.5)\n\nThe _greatest common divisor_ of two integers \\(a\\) and \\(b\\) which are not both 0, denoted by \\(\\gcd(a,b)\\), is the largest of the common divisors of \\(a\\) and \\(b\\). For example, \\(\\gcd(24,30)=6\\), \\(\\gcd(5,7)=1\\), and \\(\\gcd(0,9)=9\\). If \\(a\\) and \\(b\\) are both nonzero, then \\(\\gcd(a,b)\\) is an integer between 1 and \\(\\min\\left\\{|a|,|b|\\right\\}\\). We define \\(\\gcd(0,0)\\) to be 0, so that standard properties of the gcd function (such as equation (31.9) below) hold universally.\n\nExercise 31.1-9 asks you to prove the following elementary properties of the gcd function:\n\n\\[\\gcd(a,b) = \\gcd(b,a)\\], (31.6) \\[\\gcd(a,b) = \\gcd(-a,b)\\], (31.7) \\[\\gcd(a,b) = \\gcd(|a|,|b|)\\], (31.8) \\[\\gcd(a,0) = |a|\\], (31.9) \\[\\gcd(a,ka) = |a|\\qquad\\mbox{for any $k\\in\\mathbb{Z}$ }. \\tag{31.10}\\]\n\nThe following theorem provides an alternative and useful way to characterize \\(\\gcd(a,b)\\).\n\n_Theorem 31.2_\n\nIf \\(a\\) and \\(b\\) are any integers, not both zero, then \\(\\gcd(a,b)\\) is the smallest positive element of the set \\(\\{ax+by:x,y\\in\\mathbb{Z}\\}\\) of linear combinations of \\(a\\) and \\(b\\).\n\n_Proof_Let \\(s\\) be the smallest positive such linear combination of \\(a\\) and \\(b\\), and let \\(s=ax+by\\) for some \\(x\\), \\(y\\in\\mathbb{Z}\\). Let \\(q=\\lfloor a/s\\rfloor\\). Equation (3.11) on page 64 then implies\n\n\\[a\\ \\mathrm{mod}\\ s =\\ a-qs\\] \\[=\\ a-q(ax+by)\\] \\[=\\ a\\ (1-qx)+b\\ (-qy),\\]\n\nso that \\(a\\ \\mathrm{mod}\\ s\\) is a linear combination of \\(a\\) and \\(b\\) as well. Because \\(s\\) is the smallest _positive_ such linear combination and \\(0\\leq a\\ \\mathrm{mod}\\ s<s\\) (inequality (3.12) on page 64), \\(a\\ \\mathrm{mod}\\ s\\) cannot be positive. Hence, \\(a\\ \\mathrm{mod}\\ s=0\\). Therefore, we have that \\(s\\ |\\ a\\) and, by analogous reasoning, \\(s\\ |\\ b\\). Thus, \\(s\\) is a common divisor of \\(a\\) and \\(b\\), so that \\(\\gcd(a,b)\\geq s\\). By definition, \\(\\gcd(a,b)\\) divides both \\(a\\) and \\(b\\), and \\(s\\) is defined as a linear combination of \\(a\\) and \\(b\\). Equation (31.4) therefore implies that \\(\\gcd(a,b)\\ |\\ s\\). But \\(\\gcd(a,b)\\ |\\ s\\) and \\(s>0\\) imply that \\(\\gcd(a,b)\\leq s\\). Combining \\(\\gcd(a,b)\\geq s\\) and \\(\\gcd(a,b)\\leq s\\) yields \\(\\gcd(a,b)=s\\). We conclude that \\(s\\), the smallest positive linear combination of \\(a\\) and \\(b\\), is also their greatest common divisor.\n\nTheorem 31.2 engenders three useful corollaries.\n\n_Corollary 31.3_\n\nFor any integers \\(a\\) and \\(b\\), if \\(d\\ |\\ a\\) and \\(d\\ |\\ b\\), then \\(d\\ |\\ \\gcd(a,b)\\).\n\n_Proof_This corollary follows from equation (31.4) and Theorem 31.2, because \\(\\gcd(a,b)\\) is a linear combination of \\(a\\) and \\(b\\),\n\n_Corollary 31.4_\n\nFor all integers \\(a\\) and \\(b\\) and any nonnegative integer \\(n\\), we have\n\n\\[\\gcd(an\\,,bn)=n\\gcd(a,b)\\.\\]\n\n_Proof_If \\(n=0\\), the corollary is trivial. If \\(n>0\\), then \\(\\gcd(an\\,,bn)\\) is the smallest positive element of the set \\(\\{anx+bny:x,y\\in\\mathbb{Z}\\}\\), which in turn is \\(n\\) times the smallest positive element of the set \\(\\{ax+by:x,y\\in\\mathbb{Z}\\}\\).\n\n_Corollary 31.5_\n\nFor all positive integers \\(n\\), \\(a\\), and \\(b\\), if \\(n\\ |\\ ab\\) and \\(\\gcd(a,n)=1\\), then \\(n\\ |\\ b\\).\n\n_Proof_Exercise 31.1-5 asks you to provide the proof.\n\n### Relatively prime integers\n\nTwo integers \\(a\\) and \\(b\\) are _relatively prime_ if their only common divisor is \\(1\\), that is, if \\(\\gcd(a,b)=1\\). For example, \\(8\\) and \\(15\\) are relatively prime, since the divisors of \\(8\\) are \\(1\\), \\(2\\), \\(4\\), and \\(8\\), and the divisors of \\(15\\) are \\(1\\), \\(3\\), \\(5\\), and \\(15\\). The following theorem states that if two integers are each relatively prime to an integer \\(p\\), then their product is relatively prime to \\(p\\).\n\n**Theorem 31.6**: For any integers \\(a\\), \\(b\\), and \\(p\\), we have \\(\\gcd(ab,p)=1\\) if and only if \\(\\gcd(a,p)=1\\) and \\(\\gcd(b,p)=1\\) both hold.\n\n_Proof_ If \\(\\gcd(a,p)=1\\) and \\(\\gcd(b,p)=1\\), then it follows from Theorem 31.2 that there exist integers \\(x\\), \\(y\\), \\(x^{\\prime}\\), and \\(y^{\\prime}\\) such that\n\n\\[\\begin{array}{ll}ax+py&=\\ 1\\,\\\\ bx^{\\prime}+py^{\\prime}&=\\ 1\\.\\end{array}\\]\n\nMultiplying these equations and rearranging gives\n\n\\[\\begin{array}{ll}ab(xx^{\\prime})+p(ybx^{\\prime}+y^{\\prime}ax\\,+\\,pyy^{ \\prime})=1\\.\\end{array}\\]\n\nSince \\(1\\) is thus a positive linear combination of \\(ab\\) and \\(p\\), it is the smallest positive linear combination. Applying Theorem 31.2 implies \\(\\gcd(ab,p)=1\\), completing the proof in this direction.\n\nConversely, if \\(\\gcd(ab,p)=1\\), then Theorem 31.2 implies that there exist integers \\(x\\) and \\(y\\) such that\n\n\\[\\begin{array}{ll}abx\\,+\\,py\\,=1\\.\\end{array}\\]\n\nWriting \\(abx\\) as \\(a(bx)\\) and applying Theorem 31.2 again proves that \\(\\gcd(a,p)=1\\). Proving that \\(\\gcd(b,p)=1\\) is similar.\n\nIntegers \\(n_{1}\\), \\(n_{2}\\),..., \\(n_{k}\\) are _pairwise relatively prime_ if \\(\\gcd(n_{i},n_{j})=1\\) for \\(1\\leq i<j\\,\\leq k\\).\n\n### Unique prime factorization\n\nAn elementary but important fact about divisibility by primes is the following.\n\n**Theorem 31.7**: For all primes \\(p\\) and all integers \\(a\\) and \\(b\\), if \\(p\\mid ab\\), then \\(p\\mid a\\) or \\(p\\mid b\\) (or both).\n\n_Proof_ Assume for the purpose of contradiction that \\(p\\mid ab\\), but that \\(p\\nmid a\\) and \\(p\\nmid b\\). Because \\(p>1\\) and \\(ab=kp\\) for some \\(k\\in\\mathbb{Z}\\), equation (31.10) givesthat \\(\\gcd(ab,\\,p)=p\\). We also have that \\(\\gcd(a,\\,p)=1\\) and \\(\\gcd(b,\\,p)=1\\), since the only divisors of \\(p\\) are 1 and \\(p\\), and we assumed that \\(p\\) divides neither \\(a\\) nor \\(b\\). Theorem 31.6 then implies that \\(\\gcd(ab,\\,p)=1\\), contradicting \\(\\gcd(ab,\\,p)=p\\). This contradiction completes the proof.\n\nA consequence of Theorem 31.7 is that any composite integer can be uniquely factored into a product of primes. Exercise 31.1-11 asks you to provide a proof.\n\n_Theorem 31.8_ (_Unique prime factorization_): There is exactly one way to write any composite integer \\(a\\) as a product of the form \\(a=p_{1}^{e_{1}}p_{2}^{e_{2}}\\cdots p_{r}^{e_{r}}\\), where the \\(p_{i}\\) are prime, \\(p_{1}<p_{2}<\\cdots<p_{r}\\), and the \\(e_{i}\\) are positive integers.\n\nAs an example, the unique prime factorization of the number 6000 is \\(2^{4}\\cdot 3^{1}\\cdot 5^{3}\\).\n\n**Exercises**\n\n_31.1-1_\n\nProve that if \\(a>b>0\\) and \\(c=a+b\\), then \\(c\\mod a=b\\).\n\n_31.1-2_\n\nProve that there are infinitely many primes. (_Hint:_ Show that none of the primes \\(p_{1},\\,p_{2},\\ldots,\\,p_{k}\\) divide \\((p_{1}p_{2}\\cdots p_{k})+1\\).)\n\n_31.1-3_\n\nProve that if \\(a\\mid b\\) and \\(b\\mid c\\), then \\(a\\mid c\\).\n\n_31.1-4_\n\nProve that if \\(p\\) is prime and \\(0<k<p\\), then \\(\\gcd(k,\\,p)=1\\).\n\n_31.1-5_\n\nProve Corollary 31.5.\n\n_31.1-6_\n\nProve that if \\(p\\) is prime and \\(0<k<p\\), then \\(p\\mid\\binom{p}{k}\\). Conclude that for all integers \\(a\\) and \\(b\\) and all primes \\(p\\),\n\n\\[(a+b)^{p}=a^{p}+b^{p}\\pmod{p}\\.\\]\n\n_31.1-7_\n\nProve that if \\(a\\) and \\(b\\) are any positive integers such that \\(a\\mid b\\), then (\\(x\\) mod \\(b\\)) mod \\(a=x\\) mod \\(a\\) for any \\(x\\). Prove, under the same assumptions, that \\(x=y\\) (mod \\(b\\)) implies \\(x=y\\) (mod \\(a\\)) for any integers \\(x\\) and \\(y\\).\n\n_31.1-8_ For any integer \\(k>0\\), an integer \\(n\\) is a _kth power_ if there exists an integer \\(a\\) such that \\(a^{k}=n\\). Furthermore, \\(n>1\\) is a _nontrivial power_ if it is a \\(k\\)th power for some integer \\(k>1\\). Show how to determine whether a given \\(\\beta\\)-bit integer \\(n\\) is a nontrivial power in time polynomial in \\(\\beta\\).\n\n_31.1-9_ Prove equations (31.6)-(31.10).\n\n_31.1-10_ Show that the gcd operator is associative. That is, prove that for all integers \\(a\\), \\(b\\), and \\(c\\), we have\n\n\\[\\gcd(a,\\gcd(b,c))=\\gcd(\\gcd(a,b),c)\\.\\]\n\n_31.1-11_ Prove Theorem 31.8.\n\n_31.1-12_ Give efficient algorithms for the operations of dividing a \\(\\beta\\)-bit integer by a shorter integer and of taking the remainder of a \\(\\beta\\)-bit integer when divided by a shorter integer. Your algorithms should run in \\(\\Theta(\\beta^{2})\\) time.\n\n_31.1-13_\n\n Give an efficient algorithm to convert a given \\(\\beta\\)-bit (binary) integer to a decimal representation. Argue that if multiplication or division of integers whose length is at most \\(\\beta\\) takes \\(M(\\beta)\\) time, where \\(M(\\beta)=\\Omega(\\beta)\\), then you can convert binary to decimal in \\(O(M(\\beta)\\lg\\beta)\\) time. (_Hint:_ Use a divide-and-conquer approach, obtaining the top and bottom halves of the result with separate recursions.)\n\n_31.1-14_ Professor Marshall sets up \\(n\\) lightbulbs in a row. The lightbulbs all have switches, so that if he presses a bulb, it toggles on if it was off and off if it was on. The lightbulbs all start off. For \\(i=1,2,3,\\ldots,n\\), the professor presses bulb \\(i,2i,3i,\\ldots\\). After the last press, which lightbulbs are on? Prove your answer.\n\n### Greatest common divisor\n\nIn this section, we describe Euclid's algorithm for efficiently computing the greatest common divisor of two integers. When we analyze the running time, we'll see a surprising connection with the Fibonacci numbers, which yield a worst-case input for Euclid's algorithm.\n\nWe restrict ourselves in this section to nonnegative integers. This restriction is justified by equation (31.8), which states that \\(\\gcd(a,b)=\\gcd(|a|,|b|)\\).\n\nIn principle, for positive integers \\(a\\) and \\(b\\), their prime factorizations suffice to compute \\(\\gcd(a,b)\\). Indeed, if\n\n\\[a\\ =\\ p_{1}^{e_{1}}\\ p_{2}^{e_{2}}\\cdots p_{r}^{e_{r}}\\, \\tag{31.11}\\] \\[b\\ =\\ p_{1}^{f_{1}}\\ p_{2}^{f_{2}}\\cdots p_{r}^{f_{r}}\\, \\tag{31.12}\\]\n\nwith 0 exponents being used to make the set of primes \\(p_{1}\\), \\(p_{2},\\ldots,p_{r}\\) the same for both \\(a\\) and \\(b\\), then, as Exercise 31.2-1 asks you to show,\n\n\\[\\gcd(a,b)\\ =\\ p_{1}^{\\min\\{e_{1},f_{1}\\}}\\ p_{2}^{\\min\\{e_{2},f_{2}\\}}\\cdots p_{r}^{ \\min\\{e_{r},f_{r}\\}}. \\tag{31.13}\\]\n\nThe best algorithms to date for factoring do not run in polynomial time. Thus, this approach to computing greatest common divisors seems unlikely to yield an efficient algorithm.\n\nEuclid's algorithm for computing greatest common divisors relies on the following theorem.\n\n**Theorem 31.9** (GCD recursion theorem): _For any nonnegative integer \\(a\\) and any positive integer \\(b\\),_\n\n\\[\\gcd(a,b)\\ =\\gcd(b,a\\ {\\rm mod}\\ b)\\.\\]\n\nWe will show that \\(\\gcd(a,b)\\) and \\(\\gcd(b,a\\ {\\rm mod}\\ b)\\) divide each other. Since they are both nonnegative, equation (31.5) then implies that they must be equal.\n\nWe first show that \\(\\gcd(a,b)\\mid\\gcd(b,a\\ {\\rm mod}\\ b)\\). If we let \\(d\\ =\\gcd(a,b)\\), then \\(d\\mid a\\) and \\(d\\ \\mid b\\). By equation (3.11) on page 64, \\(a\\ {\\rm mod}\\ b\\ =\\ a-qb\\), where \\(q\\ =\\ \\lfloor a/b\\rfloor\\). Since \\(a\\ {\\rm mod}\\ b\\) is thus a linear combination of \\(a\\) and \\(b\\), equation (31.4) implies that \\(d\\ \\mid(a\\ {\\rm mod}\\ b)\\). Therefore, since \\(d\\ \\mid b\\) and \\(d\\ \\mid(a\\ {\\rm mod}\\ b)\\), Corollary 31.3 implies that \\(d\\ \\mid\\gcd(b,a\\ {\\rm mod}\\ b)\\), that is,\n\n\\[\\gcd(a,b)\\ |\\ \\gcd(b,a\\ {\\rm mod}\\ b). \\tag{31.14}\\]\n\nShowing that \\(\\gcd(b,a\\ {\\rm mod}\\ b)\\mid\\gcd(a,b)\\) is almost the same. If we now let \\(d\\ =\\gcd(b,a\\ {\\rm mod}\\ b)\\), then \\(d\\ |\\ b\\) and \\(d\\ \\mid(a\\ {\\rm mod}\\ b)\\). Since \\(a=qb\\ +(a\\ {\\rm mod}\\ b)\\)",
        "chapter": "Part VII Selected Topics",
        "section": "31 Number-Theoretic Algorithms",
        "subsection": "31.1 Elementary number-theoretic notions",
        "subsubsection": "N/A"
    },
    {
        "content": "### Greatest common divisor\n\nIn this section, we describe Euclid's algorithm for efficiently computing the greatest common divisor of two integers. When we analyze the running time, we'll see a surprising connection with the Fibonacci numbers, which yield a worst-case input for Euclid's algorithm.\n\nWe restrict ourselves in this section to nonnegative integers. This restriction is justified by equation (31.8), which states that \\(\\gcd(a,b)=\\gcd(|a|,|b|)\\).\n\nIn principle, for positive integers \\(a\\) and \\(b\\), their prime factorizations suffice to compute \\(\\gcd(a,b)\\). Indeed, if\n\n\\[a\\ =\\ p_{1}^{e_{1}}\\,p_{2}^{e_{2}}\\cdots p_{r}^{e_{r}}\\, \\tag{31.11}\\] \\[b\\ =\\ p_{1}^{\\,f_{1}}\\,p_{2}^{\\,f_{2}}\\cdots p_{r}^{\\,f_{r}}\\, \\tag{31.12}\\]\n\nwith 0 exponents being used to make the set of primes \\(p_{1}\\), \\(p_{2},\\ldots,p_{r}\\) the same for both \\(a\\) and \\(b\\), then, as Exercise 31.2-1 asks you to show,\n\n\\[\\gcd(a,b)\\ =\\ p_{1}^{\\min\\{e_{1},f_{1}\\}}\\,p_{2}^{\\min\\{e_{2},f_{2}\\}}\\cdots p_{r}^{ \\min\\{e_{r},f_{r}\\}}. \\tag{31.13}\\]\n\nThe best algorithms to date for factoring do not run in polynomial time. Thus, this approach to computing greatest common divisors seems unlikely to yield an efficient algorithm.\n\nEuclid's algorithm for computing greatest common divisors relies on the following theorem.\n\n**Theorem 31.9** (GCD recursion theorem): _For any nonnegative integer \\(a\\) and any positive integer \\(b\\),_\n\n\\[\\gcd(a,b)\\ =\\gcd(b,a\\ {\\rm mod}\\ b)\\.\\]\n\nWe will show that \\(\\gcd(a,b)\\) and \\(\\gcd(b,a\\ {\\rm mod}\\ b)\\) divide each other. Since they are both nonnegative, equation (31.5) then implies that they must be equal.\n\nWe first show that \\(\\gcd(a,b)\\mid\\gcd(b,a\\ {\\rm mod}\\ b)\\). If we let \\(d\\ =\\gcd(a,b)\\), then \\(d\\mid a\\) and \\(d\\ \\mid b\\). By equation (3.11) on page 3.14, \\(a\\ {\\rm mod}\\ b\\ =\\ a-qb\\), where \\(q\\ =\\ \\lfloor a/b\\rfloor\\). Since \\(a\\ {\\rm mod}\\ b\\) is thus a linear combination of \\(a\\) and \\(b\\), equation (31.4) implies that \\(d\\ \\mid(a\\ {\\rm mod}\\ b)\\). Therefore, since \\(d\\ \\mid b\\) and \\(d\\ \\mid(a\\ {\\rm mod}\\ b)\\), Corollary 31.3 implies that \\(d\\ \\mid\\gcd(b,a\\ {\\rm mod}\\ b)\\), that is,\n\n\\[\\gcd(a,b)\\mid\\gcd(b,a\\ {\\rm mod}\\ b). \\tag{31.14}\\]\n\nShowing that \\(\\gcd(b,a\\ {\\rm mod}\\ b)\\mid\\gcd(a,b)\\) is almost the same. If we now let \\(d\\ =\\gcd(b,a\\ {\\rm mod}\\ b)\\), then \\(d\\ \\mid b\\) and \\(d\\ \\mid(a\\ {\\rm mod}\\ b)\\). Since \\(a=qb\\ +(a\\ {\\rm mod}\\ b)\\)where \\(q=\\lfloor a/b\\rfloor\\), we have that \\(a\\) is a linear combination of \\(b\\) and (\\(a\\) mod \\(b\\)). By equation (31.4), we conclude that \\(d\\mid a\\). Since \\(d\\mid b\\) and \\(d\\mid a\\), we have that \\(d\\mid\\gcd(a,b)\\) by Corollary 31.3, so that \\(\\gcd(b,a\\bmod b)\\mid\\gcd(a,b)\\). Using equation (31.5) to combine equations (31.14) and (31.15) completes the proof.\n\n### Euclid's algorithm\n\nEuclid's _Elements_ (circa 300 b.c.e.) describes the following gcd algorithm, although its origin might be even earlier. The recursive procedure Euclid implements Euclid's algorithm, based directly on Theorem 31.9. The inputs \\(a\\) and \\(b\\) are arbitrary nonnegative integers.\n\n\\[\\begin{array}{l}\\mbox{\\sc Euclid}(a,b)\\\\ \\mbox{\\sc 1}\\mbox{\\sc 1then the procedure makes just one more recursive call than when \\(a>b,\\) because in this case \\(\\textsc{Euclid}(a,b)\\) immediately makes the recursive call \\(\\textsc{Euclid}(b,a),\\) and now the first argument is greater than the second.\n\nOur analysis relies on the Fibonacci numbers \\(F_{k},\\) defined by the recurrence equation (3.31) on page 3.3.\n\n**Lemma 3.10**: If \\(a>b\\geq 1\\) and the call \\(\\textsc{Euclid}(a,b)\\) performs \\(k\\geq 1\\) recursive calls, then \\(a\\geq F_{k+2}\\) and \\(b\\geq F_{k+1}.\\)\n\nThe proof proceeds by induction on \\(k\\). For the base case of the induction, let \\(k=1\\). Then, \\(b\\geq 1=F_{2}\\), and since \\(a>b\\), we must have \\(a\\geq 2=F_{3}\\). Since \\(b>(a\\bmod b)\\), in each recursive call the first argument is strictly larger than the second. The assumption that \\(a>b\\) therefore holds for each recursive call.\n\nAssuming inductively that the lemma holds if the procedure makes \\(k-1\\) recursive calls, we shall prove that the lemma holds for \\(k\\) recursive calls. Since \\(k>0\\), we have \\(b>0\\), and \\(\\textsc{Euclid}(a,b)\\) calls \\(\\textsc{Euclid}(b,a\\bmod b)\\) recursively, which in turn makes \\(k-1\\) recursive calls. The inductive hypothesis then implies that \\(b\\geq F_{k+1}\\) (thus proving part of the lemma), and \\(a\\bmod b\\geq F_{k}\\). We have\n\n\\[b+(a\\bmod b) = b+(a-b\\lfloor a/b\\rfloor)\\qquad\\text{(by equation (\\ref{eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:have \\(F_{k+1}\\bmod F_{k}=F_{k-1}\\). Because \\(\\textsc{Euclid}(a,b)\\) calls \\(\\textsc{Euclid}(b,a\\bmod b)\\) when \\(b>0\\), the call \\(\\textsc{Euclid}(F_{k+1},F_{k})\\) recurses one time more than the call \\(\\textsc{Euclid}(F_{k},F_{k-1})\\), or exactly \\(k-1\\) times, which meets the upper bound given by Theorem 3.11.\n\nSince \\(F_{k}\\) is approximately \\(\\phi^{k}/\\sqrt{5}\\), where \\(\\phi\\) is the golden ratio (\\(1+\\sqrt{5}\\))/2 defined by equation (3.32) on page 3.1, the number of recursive calls in Euclid is \\(O(\\lg b)\\). (See Exercise 3.2-5 for a tighter bound.) Therefore, a call of Euclid on two \\(\\beta\\)-bit numbers performs \\(O(\\beta)\\) arithmetic operations and \\(O(\\beta^{3})\\) bit operations (assuming that multiplication and division of \\(\\beta\\)-bit numbers take \\(O(\\beta^{2})\\) bit operations). Problem 3.2-2 asks you to prove an \\(O(\\beta^{2})\\) bound on the number of bit operations.\n\n### The extended form of Euclid's algorithm\n\nBy rewriting Euclid's algorithm, we can gain additional useful information. Specifically, let's extend the algorithm to compute the integer coefficients \\(x\\) and \\(y\\) such that\n\n\\[d\\,=\\gcd(a,b)=ax+by\\, \\tag{3.16}\\]\n\nwhere either or both of \\(x\\) and \\(y\\) may be zero or negative. These coefficients will prove useful later for computing modular multiplicative inverses. The procedure Extended-Euclid takes as input a pair of nonnegative integers and returns a triple of the form \\((d,x,y)\\) that satisfies equation (3.16). As an example, Figure 3.1 traces out the call Extended-Euclid (99, 78).\n\nExtended-Euclid (\\(a,b\\))\n\n**if**\\(b\\) == 0\n\n**return**\\((a,1,0)\\)\n\n**else**\\((d^{\\prime},x^{\\prime},y^{\\prime})=\\textsc{Extended-Euclid}(b,a\\bmod b)\\)\n\n**(\\(d,x,y\\))**\\(=(d^{\\prime},y^{\\prime},x^{\\prime}-\\lfloor a/b\\rfloor\\,y^{\\prime})\\)\n\n**return**\\((d,x,y)\\)\n\nThe Extended-Euclid procedure is a variation of the Euclid procedure. Line 1 is equivalent to the test \"\\(b==0\\)\" in line 1 of Euclid. If \\(b=0\\), then Extended-Euclid returns not only \\(d\\,=\\,a\\) in line 2, but also the coefficients \\(x=1\\) and \\(y=0\\), so that \\(a=ax+by\\). If \\(b\\neq 0\\), Extended-Euclid first computes \\((d^{\\prime},x^{\\prime},y^{\\prime})\\) such that \\(d^{\\prime}=\\gcd(b,a\\bmod b)\\) and\n\n\\[d^{\\prime}\\,=\\,bx^{\\prime}\\,+\\,(a\\bmod b)y^{\\prime}. \\tag{3.17}\\]\n\nAs in the Euclid procedure, we have \\(d\\,=\\,\\gcd(a,b)=d^{\\prime}\\,=\\,\\gcd(b,a\\bmod b)\\). To obtain \\(x\\) and \\(y\\) such that \\(d\\,=\\,ax+by\\), let's rewrite equation (3.17), setting \\(d\\,=\\,d^{\\,\\prime}\\) and using equation (3.11):\n\n\\[d \\,=\\,\\,bx^{\\,\\prime}\\,+\\,(a-b\\,\\lfloor a/b\\rfloor)y^{\\,\\prime}\\] \\[\\,=\\,\\,ay^{\\,\\prime}\\,+\\,b(x^{\\,\\prime}-\\lfloor a/b\\rfloor\\,y^{ \\,\\prime})\\,\\,.\\]\n\nThus, choosing \\(x=y^{\\,\\prime}\\) and \\(y=x^{\\,\\prime}-\\lfloor a/b\\rfloor\\,y^{\\,\\prime}\\) satisfies the equation \\(d\\,=\\,ax+by\\,\\), thereby proving the correctness of Extended-Euclid.\n\nSince the number of recursive calls made in Euclid is equal to the number of recursive calls made in Extended-Euclid, the running times of Euclid and Extended-Euclid are the same, to within a constant factor. That is, for \\(a>b>0\\), the number of recursive calls is \\(\\,\\mathcal{O}(\\lg b)\\).\n\n##### Exercises\n\n##### 31.2-1\n\nProve that equations (31.11) and (31.12) imply equation (31.13).\n\n##### 31.2-2\n\nCompute the values \\((d,x,y)\\) that the call Extended-Euclid\\((899,493)\\) returns.\n\n##### 31.2-3\n\nProve that for all integers \\(a\\,,k\\,,\\) and \\(n\\,,\\)\n\n\\[\\gcd(a,n)\\,=\\,\\gcd(a+k\\,n\\,,n)\\,\\,. \\tag{31.18}\\]\n\nUse equation (31.18) to show that \\(a\\,=\\,1\\pmod{n}\\) implies \\(\\gcd(a,n)\\,=\\,1\\).\n\n##### 31.2-4\n\nRewrite Euclid in an iterative form that uses only a constant amount of memory (that is, stores only a constant number of integer values).\n\nFigure 31.1: How Extended-Euclid computes \\(\\gcd(99,78)\\). Each line shows one level of the recursion: the values of the inputs \\(a\\) and \\(b\\), the computed value \\(\\lfloor a/b\\rfloor\\), and the values \\(d\\,,\\,x\\), and \\(y\\) returned. The triple \\((d\\,,x,y)\\) returned becomes the triple \\((d\\,^{\\prime},x^{\\prime},y^{\\,\\prime})\\) used at the next higher level of recursion. The call Extended-Euclid\\((99,78)\\) returns \\((3,-11,14)\\), so that \\(\\gcd(99,78)\\,=\\,3\\,=\\,99\\cdot(-11)\\,+\\,78\\cdot 14\\).\n\n#### 31.2-5\n\nIf \\(a>b\\geq 0\\), show that the call \\(\\textsc{Euclid}(a,b)\\) makes at most \\(1+\\log_{\\phi}b\\) recursive calls. Improve this bound to \\(1+\\log_{\\phi}(b/\\gcd(a,b))\\).\n\n#### 31.2-6\n\nWhat does Extended-Euclid (\\(F_{k+1},\\,F_{k}\\)) return? Prove your answer correct.\n\n#### 31.2-7\n\nDefine the gcd function for more than two arguments by the recursive equation \\(\\gcd(a_{0},a_{1},\\ldots,a_{n})=\\gcd(a_{0},\\gcd(a_{1},a_{2},\\ldots,a_{n}))\\). Show that the gcd function returns the same answer independent of the order in which its arguments are specified. Also show how to find integers \\(x_{0},x_{1},\\ldots,x_{n}\\) such that \\(\\gcd(a_{0},a_{1},\\ldots,a_{n})=a_{0}x_{0}+a_{1}x_{1}+\\cdots+a_{n}x_{n}\\). Show that the number of divisions performed by your algorithm is \\(O(n+\\lg(\\max\\,\\{a_{0},a_{1},\\ldots,a_{n}\\}))\\).\n\n#### 31.2-8\n\nThe _least common multiple_\\(\\operatorname{lcm}(a_{1},a_{2},\\ldots,a_{n})\\) of integers \\(a_{1},a_{2},\\ldots,a_{n}\\) is the smallest nonnegative integer that is a multiple of each \\(a_{i}\\). Show how to compute \\(\\operatorname{lcm}(a_{1},a_{2},\\ldots,a_{n})\\) efficiently using the (two-argument) gcd operation as a subroutine.\n\n#### 31.2-9\n\nProve that \\(n_{1},n_{2},n_{3}\\), and \\(n_{4}\\) are pairwise relatively prime if and only if\n\n\\[\\gcd(n_{1}n_{2},n_{3}n_{4})=\\gcd(n_{1}n_{3},n_{2}n_{4})=1\\.\\]\n\nMore generally, show that \\(n_{1},n_{2},\\ldots,n_{k}\\) are pairwise relatively prime if and only if a set of \\(\\lceil\\lg k\\rceil\\) pairs of numbers derived from the \\(n_{i}\\) are relatively prime.\n\n### 31.3 Modular arithmetic\n\nInformally, you can think of modular arithmetic as arithmetic as usual over the integers, except that when working modulo \\(n\\), then every result \\(x\\) is replaced by the element of \\(\\{0,1,\\ldots,n-1\\}\\) that is equivalent to \\(x\\), modulo \\(n\\) (so that \\(x\\) is replaced by \\(x\\) mod \\(n\\)). This informal model suffices if you stick to the operations of addition, subtraction, and multiplication. A more formal model for modular arithmetic, which follows, is best described within the framework of group theory.",
        "chapter": "Part VII Selected Topics",
        "section": "31 Number-Theoretic Algorithms",
        "subsection": "31.2 Greatest common divisor",
        "subsubsection": "N/A"
    },
    {
        "content": "#### 31.2-5\n\nIf \\(a>b\\geq 0\\), show that the call \\(\\textsc{Euclid}(a,b)\\) makes at most \\(1+\\log_{\\phi}b\\) recursive calls. Improve this bound to \\(1+\\log_{\\phi}(b/\\gcd(a,b))\\).\n\n#### 31.2-6\n\nWhat does Extended-Euclid (\\(F_{k+1},\\,F_{k}\\)) return? Prove your answer correct.\n\n#### 31.2-7\n\nDefine the gcd function for more than two arguments by the recursive equation \\(\\gcd(a_{0},a_{1},\\ldots,a_{n})=\\gcd(a_{0},\\gcd(a_{1},a_{2},\\ldots,a_{n}))\\). Show that the gcd function returns the same answer independent of the order in which its arguments are specified. Also show how to find integers \\(x_{0},x_{1},\\ldots,x_{n}\\) such that \\(\\gcd(a_{0},a_{1},\\ldots,a_{n})=a_{0}x_{0}+a_{1}x_{1}+\\cdots+a_{n}x_{n}\\). Show that the number of divisions performed by your algorithm is \\(O(n+\\lg(\\max\\,\\{a_{0},a_{1},\\ldots,a_{n}\\}))\\).\n\n#### 31.2-8\n\nThe _least common multiple_\\(\\operatorname{lcm}(a_{1},a_{2},\\ldots,a_{n})\\) of integers \\(a_{1},a_{2},\\ldots,a_{n}\\) is the smallest nonnegative integer that is a multiple of each \\(a_{i}\\). Show how to compute \\(\\operatorname{lcm}(a_{1},a_{2},\\ldots,a_{n})\\) efficiently using the (two-argument) gcd operation as a subroutine.\n\n#### 31.2-9\n\nProve that \\(n_{1},n_{2},n_{3}\\), and \\(n_{4}\\) are pairwise relatively prime if and only if\n\n\\[\\gcd(n_{1}n_{2},n_{3}n_{4})=\\gcd(n_{1}n_{3},n_{2}n_{4})=1\\.\\]\n\nMore generally, show that \\(n_{1},n_{2},\\ldots,n_{k}\\) are pairwise relatively prime if and only if a set of \\(\\lceil\\lg k\\rceil\\) pairs of numbers derived from the \\(n_{i}\\) are relatively prime.\n\n### 31.3 Modular arithmetic\n\nInformally, you can think of modular arithmetic as arithmetic as usual over the integers, except that when working modulo \\(n\\), then every result \\(x\\) is replaced by the element of \\(\\{0,1,\\ldots,n-1\\}\\) that is equivalent to \\(x\\), modulo \\(n\\) (so that \\(x\\) is replaced by \\(x\\) mod \\(n\\)). This informal model suffices if you stick to the operations of addition, subtraction, and multiplication. A more formal model for modular arithmetic, which follows, is best described within the framework of group theory.\n\n#### Finite groups\n\nA _group_\\((S,\\oplus)\\) is a set \\(S\\) together with a binary operation \\(\\oplus\\) defined on \\(S\\) for which the following properties hold:\n\n1. **Closure:** For all \\(a,b\\in S\\), we have \\(a\\oplus b\\in S\\).\n2. **Identity:** There exists an element \\(e\\in S\\), called the _identity_ of the group, such that \\(e\\oplus a=a\\oplus e=a\\) for all \\(a\\in S\\).\n3. **Associativity:** For all \\(a,b,c\\in S\\), we have \\((a\\oplus b)\\oplus c=a\\oplus(b\\oplus c)\\).\n4. **Inverses:** For each \\(a\\in S\\), there exists a unique element \\(b\\in S\\), called the _inverse_ of \\(a\\), such that \\(a\\oplus b=b\\oplus a=e\\).\n\nAs an example, consider the familiar group \\((\\mathbb{Z},+)\\) of the integers \\(\\mathbb{Z}\\) under the operation of addition: \\(0\\) is the identity, and the inverse of \\(a\\) is \\(-a\\). An _abelian group_\\((S,\\oplus)\\) satisfies the _commutative law_\\(a\\oplus b=b\\oplus a\\) for all \\(a,b\\in S\\). The _size_ of group \\((S,\\oplus)\\) is \\(|S|\\), and if \\(|S|<\\infty\\), then \\((S,\\oplus)\\) is a _finite group_.\n\n#### The groups defined by modular addition and multiplication\n\nWe can form two finite abelian groups by using addition and multiplication modulo \\(n\\), where \\(n\\) is a positive integer. These groups are based on the equivalence classes of the integers modulo \\(n\\), defined in Section 31.1.\n\nTo define a group on \\(\\mathbb{Z}_{n}\\), we need suitable binary operations, which we obtain by redefining the ordinary operations of addition and multiplication. We can define addition and multiplication operations for \\(\\mathbb{Z}_{n}\\), because the equivalence class of two integers uniquely determines the equivalence class of their sum or product. That is, if \\(a=a^{\\prime}\\pmod{n}\\) and \\(b=b^{\\prime}\\pmod{n}\\), then\n\n\\[a+b = a^{\\prime}+b^{\\prime}\\pmod{n}\\,,\\] \\[ab = a^{\\prime}b^{\\prime}\\pmod{n}\\,.\\]\n\nThus, we define addition and multiplication modulo \\(n\\), denoted \\(+_{n}\\) and \\(\\cdot_{n}\\), by\n\n\\[[a]_{n}+_{n}[b]_{n} = [a+b]_{n}\\,, \\tag{31.19}\\] \\[[a]_{n}\\cdot_{n}[b]_{n} = [ab]_{n}\\,.\\]\n\n(We can define subtraction similarly on \\(\\mathbb{Z}_{n}\\) by \\([a]_{n}-_{n}[b]_{n}=[a-b]_{n}\\), but division is more complicated, as we'll see.) These facts justify the common and convenient practice of using the smallest nonnegative element of each equivalence class as its representative when performing computations in \\(\\mathbb{Z}_{n}\\). We add, subtract, and multiply as usual on the representatives, but we replace each result \\(x\\) by the representative of its class, that is, by \\(x\\) mod \\(n\\).\n\nUsing this definition of addition modulo \\(n\\), we define the _additive group modulo_\\(n\\) as \\((\\mathbb{Z}_{n},+_{n})\\). The size of the additive group modulo \\(n\\) is \\(|\\mathbb{Z}_{n}|=n\\). Figure 31.2(a) gives the operation table for the group \\((\\mathbb{Z}_{6},+_{6})\\).\n\n**Theorem 31.12**: _The system \\((\\mathbb{Z}_{n},+_{n})\\) is a finite abelian group._\n\n_Proof_ Equation (31.19) shows that \\((\\mathbb{Z}_{n},+_{n})\\) is closed. Associativity and commutativity of \\(+_{n}\\) follow from the associativity and commutativity of \\(+\\):\n\n\\[\\begin{array}{rcl}([a]_{n}+_{n}[b]_{n})+_{n}[c]_{n}&=&[a+b]_{n}+_{n}[c]_{n}\\\\ &=&[(a+b)+c]_{n}\\\\ &=&[a+(b+c)]_{n}\\\\ &=&[a]_{n}+_{n}[b+c]_{n}\\\\ &=&[a]_{n}+_{n}([b]_{n}+_{n}[c]_{n})\\;,\\\\ \\\\ [a]_{n}+_{n}[b]_{n}&=&[a+b]_{n}\\\\ &=&[b+a]_{n}\\\\ &=&[b]_{n}+_{n}[a]_{n}\\;.\\end{array}\\]\n\nThe identity element of \\((\\mathbb{Z}_{n},+_{n})\\) is \\(0\\) (that is, \\([0]_{n}\\)). The (additive) inverse of an element \\(a\\) (that is, of \\([a]_{n}\\)) is the element \\(-a\\) (that is, \\([-a]_{n}\\) or \\([n-a]_{n}\\)), since \\([a]_{n}+_{n}[-a]_{n}=[a-a]_{n}=[0]_{n}\\).\n\nFigure 31.2: Two finite groups. Equivalence classes are denoted by their representative elements. **(a)** The group \\((\\mathbb{Z}_{6},+_{6})\\). **(b)** The group \\((\\mathbb{Z}_{15}^{\\star},\\cdot_{15})\\).\n\n### Modular arithmetic\n\nUsing the definition of multiplication modulo \\(n\\), we define the _multiplicative group modulo \\(n\\)_ as \\((\\mathbb{Z}_{n}^{*},\\cdot_{n})\\). The elements of this group are the set \\(\\mathbb{Z}_{n}^{*}\\) of elements in \\(\\mathbb{Z}_{n}\\) that are relatively prime to \\(n\\), so that each one has a unique inverse, modulo \\(n\\):\n\n\\[\\mathbb{Z}_{n}^{*}=\\left\\{[a]_{n}\\in\\mathbb{Z}_{n}:\\gcd(a,n)=1\\right\\}\\.\\]\n\nTo see that \\(\\mathbb{Z}_{n}^{*}\\) is well defined, note that for \\(0\\leq a<n\\), we have \\(a=(a+k\\,n)\\pmod{n}\\) for all integers \\(k\\). By Exercise 31.2-3, therefore, \\(\\gcd(a,n)=1\\) implies \\(\\gcd(a+k\\,n,n)=1\\) for all integers \\(k\\). Since \\([a]_{n}=\\{a+k\\,n:k\\in\\mathbb{Z}\\}\\), the set \\(\\mathbb{Z}_{n}^{*}\\) is well defined. An example of such a group is\n\n\\[\\mathbb{Z}_{15}^{*}=\\left\\{1,2,4,7,8,11,13,14\\right\\}\\,\\]\n\nwhere the group operation is multiplication modulo \\(15\\). (We have denoted an element \\([a]_{15}\\) as \\(a\\), and thus, for example, we denote \\([7]_{15}\\) as \\(7\\).) Figure 31.2(b) shows the group \\((\\mathbb{Z}_{15}^{*},\\cdot_{15})\\). For example, \\(8\\cdot 11=13(\\mod 15)\\), working in \\(\\mathbb{Z}_{15}^{*}\\). The identity for this group is \\(1\\).\n\n_Theorem 31.13_: The system \\((\\mathbb{Z}_{n}^{*},\\cdot_{n})\\) is a finite abelian group.\n\n_Proof_ Theorem 31.6 implies that \\((\\mathbb{Z}_{n}^{*},\\cdot_{n})\\) is closed. Associativity and commutativity can be proved for \\(\\cdot_{n}\\) as they were for \\(+_{n}\\) in the proof of Theorem 31.12. The identity element is \\([1]_{n}\\). To show the existence of inverses, let \\(a\\) be an element of \\(\\mathbb{Z}_{n}^{*}\\) and let \\((d,x,y)\\) be returned by Extended-Euclid\\((a,n)\\). Then we have \\(d=1\\), since \\(a\\in\\mathbb{Z}_{n}^{*}\\), and\n\n\\[ax+ny=1\\, \\tag{31.20}\\]\n\nor equivalently,\n\n\\[ax=1\\ \\pmod{n}\\.\\]\n\nThus \\([x]_{n}\\) is a multiplicative inverse of \\([a]_{n}\\), modulo \\(n\\). Furthermore, we claim that \\([x]_{n}\\in\\mathbb{Z}_{n}^{*}\\). To see why, equation (31.20) demonstrates that the smallest positive linear combination of \\(x\\) and \\(n\\) must be \\(1\\). Therefore, Theorem 31.2 implies that \\(\\gcd(x,n)=1\\). We defer the proof that inverses are uniquely defined until Corollary 31.26 in Section 31.4.\n\nAs an example of computing multiplicative inverses, suppose that \\(a=5\\) and \\(n=11\\). Then Extended-Euclid\\((a,n)\\) returns \\((d,x,y)=(1,-2,1)\\), so that \\(1=5\\cdot(-2)+11\\cdot 1\\). Thus, \\([-2]_{11}\\) (i.e., \\([9]_{11}\\)) is the multiplicative inverse of \\([5]_{11}\\).\n\nWhen working with the groups \\((\\mathbb{Z}_{n},+_{n})\\) and \\((\\mathbb{Z}_{n}^{*},\\cdot_{n})\\) in the remainder of this chapter, we follow the convenient practice of denoting equivalence classes by their representative elements and denoting the operations \\(+_{n}\\) and \\(\\cdot_{n}\\) by the usualarithmetic notations \\(+\\) and \\(\\cdot\\) (or juxtaposition, so that \\(ab=a\\cdot b\\)) respectively. Furthermore, equivalences modulo \\(n\\) may also be interpreted as equations in \\(\\mathbb{Z}_{n}\\). For example, the following two statements are equivalent:\n\n\\(ax=b\\pmod{n}\\)\n\nand\n\n\\([a]_{n}\\cdot_{n}[x]_{n}=[b]_{n}\\).\n\nAs a further convenience, we sometimes refer to a group \\((S,\\oplus)\\) merely as \\(S\\) when the operation \\(\\oplus\\) is understood from context. We may thus refer to the groups \\((\\mathbb{Z}_{n},+_{n})\\) and \\((\\mathbb{Z}_{n}^{*},\\cdot_{n})\\) as just \\(\\mathbb{Z}_{n}\\) and \\(\\mathbb{Z}_{n}^{*}\\), respectively.\n\nWe denote the (multiplicative) inverse of an element \\(a\\) by \\((a^{-1}\\bmod n)\\). Division in \\(\\mathbb{Z}_{n}^{*}\\) is defined by the equation \\(a/b=ab^{-1}\\pmod{n}\\). For example, in \\(\\mathbb{Z}_{15}^{*}\\) we have that \\(7^{-1}=13(\\mod 15)\\), since \\(7\\cdot 13=91=1\\pmod{15}\\), so that \\(2/7=2\\cdot 13=11(\\mod 15)\\).\n\nThe size of \\(\\mathbb{Z}_{n}^{*}\\) is denoted \\(\\phi(n)\\). This function, known as _Euler's phi function_, satisfies the equation\n\n\\[\\phi(n)=n\\prod_{\\mbox{$p$ prime such that $p\\mid n$}}\\left(1-\\frac{1}{p}\\right)\\, \\tag{31.21}\\]\n\nso that \\(p\\) runs over all the primes dividing \\(n\\) (including \\(n\\) itself, if \\(n\\) is prime). We won't prove this formula here. Intuitively, begin with a list of the \\(n\\) remainders \\(\\{0,1,\\ldots,n-1\\}\\) and then, for each prime \\(p\\) that divides \\(n\\), cross out every multiple of \\(p\\) in the list. For example, since the prime divisors of \\(45\\) are \\(3\\) and \\(5\\),\n\n\\[\\phi(45) = 45\\left(1-\\frac{1}{3}\\right)\\left(1-\\frac{1}{5}\\right)\\] \\[= 45\\left(\\frac{2}{3}\\right)\\left(\\frac{4}{5}\\right)\\] \\[= 24\\.\\] If \\(p\\) is prime, then \\(\\mathbb{Z}_{p}^{*}=\\{1,2,\\ldots,\\,p-1\\}\\), and\n\n\\[\\phi(p) = p\\left(1-\\frac{1}{p}\\right) \\tag{31.22}\\] \\[= p-1\\.\\] If \\(n\\) is composite, then \\(\\phi(n){\\prec}n\\)\\(-1\\), although it can be shown that \\[\\phi(n){\\succ} \\frac{n}{e^{\\gamma}\\ln\\ln n\\,+\\,3/\\ln\\ln n} \\tag{31.23}\\]for \\(n\\geq 3\\), where \\(\\gamma=0.5772156649\\ldots\\) is _Euler's constant_. A somewhat simpler (but looser) lower bound for \\(n>5\\) is\n\n\\[\\phi(n)\\!\\!\\!>\\ \\ \\frac{n}{6\\ln\\ln n}. \\tag{31.24}\\]\n\nThe lower bound (31.23) is essentially the best possible, since\n\n\\[\\liminf_{n\\to\\infty}\\frac{\\phi(n)}{n/\\ln\\ln n}\\,=\\,e^{-\\gamma}. \\tag{31.25}\\]\n\n##### Subgroups\n\nIf \\((S,\\oplus)\\) is a group, \\(S^{\\prime}\\subseteq S\\), and \\((S^{\\prime},\\oplus)\\) is also a group, then \\((S^{\\prime},\\oplus)\\) is a _subgroup_ of \\((S,\\oplus)\\). For example, the even integers form a subgroup of the integers under the operation of addition. The following theorem, whose proof we leave as Exercise 31.3-3, provides a useful tool for recognizing subgroups.\n\n_Theorem 31.14 (A nonempty closed subset of a finite group is a subgroup)_\n\nIf \\((S,\\oplus)\\) is a finite group and \\(S^{\\prime}\\) is any nonempty subset of \\(S\\) such that \\(a\\oplus b\\in S^{\\prime}\\) for all \\(a,b\\in S^{\\prime}\\), then \\((S^{\\prime},\\oplus)\\) is a subgroup of \\((S,\\oplus)\\).\n\nFor example, the set \\(\\{0,2,4,6\\}\\) forms a subgroup of \\(\\mathbb{Z}_{8}\\), since it is nonempty and closed under the operation \\(+\\) (that is, it is closed under \\(+_{8}\\)).\n\nThe following theorem, whose proof is omitted, provides an extremely useful constraint on the size of a subgroup.\n\n_Theorem 31.15 (Lagrange's theorem)_\n\nIf \\((S,\\oplus)\\) is a finite group and \\((S^{\\prime},\\oplus)\\) is a subgroup of \\((S,\\oplus)\\), then \\(|S^{\\prime}|\\) is a divisor of \\(|S|\\).\n\nA subgroup \\(S^{\\prime}\\) of a group \\(S\\) is a _proper_ subgroup if \\(S^{\\prime}\\neq S\\). We'll use the following corollary in the analysis in Section 31.8 of the Miller-Rabin primality test procedure.\n\n_Corollary 31.16_\n\nIf \\(S^{\\prime}\\) is a proper subgroup of a finite group \\(S\\), then \\(|S^{\\prime}|\\leq|S|/2\\).\n\n##### Subgroups generated by an element\n\nTheorem 31.14 affords us a straightforward way to produce a subgroup of a finite group \\((S,\\oplus)\\): choose an element \\(a\\) and take all elements that can be generated from \\(a\\) using the group operation. Specifically, define \\(a^{(k)}\\) for \\(k\\geq 1\\) by \\[a^{(k)}=\\bigoplus_{i\\,=\\,1}^{k}a=\\underbrace{a\\oplus a\\oplus\\cdots\\oplus a}_{k}\\enspace.\\]\n\nFor example, taking \\(a=2\\) in the group \\(\\mathbb{Z}_{6}\\) yields the sequence\n\n\\[a^{(1)},a^{(2)},a^{(3)},\\ldots=2,4,0,2,4,0,2,4,0,\\ldots\\enspace.\\]\n\nWe have \\(a^{(k)}=ka\\mod n\\) in the group \\(\\mathbb{Z}_{n}\\), and \\(a^{(k)}=a^{k}\\mod n\\) in the group \\(\\mathbb{Z}_{n}^{*}\\). We define the _subgroup generated by \\(a\\)_, denoted \\(\\langle a\\rangle\\) or \\((\\langle a\\rangle,\\oplus)\\), by\n\n\\[\\langle a\\rangle=\\left\\{a^{(k)}:k\\geq 1\\right\\}\\enspace.\\]\n\nWe say that \\(a\\)_generates_ the subgroup \\(\\langle a\\rangle\\) or that \\(a\\) is a _generator_ of \\(\\langle a\\rangle\\). Since \\(S\\) is finite, \\(\\langle a\\rangle\\) is a finite subset of \\(S\\), possibly including all of \\(S\\). Since the associativity of \\(\\oplus\\) implies\n\n\\[a^{(i)}\\oplus a^{(j)}=a^{(i\\,+\\,j)}\\enspace,\\]\n\n\\(\\langle a\\rangle\\) is closed and therefore, by Theorem 3.14, \\(\\langle a\\rangle\\) is a subgroup of \\(S\\). For example, in \\(\\mathbb{Z}_{6}\\), we have\n\n\\[\\langle 0\\rangle =\\ \\{0\\}\\enspace,\\] \\[\\langle 1\\rangle =\\ \\{0,1,2,3,4,5\\}\\enspace,\\] \\[\\langle 2\\rangle =\\ \\{0,2,4\\}\\enspace.\\]\n\nSimilarly, in \\(\\mathbb{Z}_{7}^{*}\\), we have\n\n\\[\\langle 1\\rangle =\\ \\{1\\}\\enspace,\\] \\[\\langle 2\\rangle =\\ \\{1,2,4\\}\\enspace,\\] \\[\\langle 3\\rangle =\\ \\{1,2,3,4,5,6\\}\\enspace.\\]\n\nThe _order_ of \\(a\\) (in the group \\(S\\)), denoted \\(\\operatorname{ord}(a)\\), is defined as the smallest positive integer \\(t\\) such that \\(a^{(t)}=e\\). (Recall that \\(e\\in S\\) is the group identity.)\n\n**Theorem 3.17**: _For any finite group \\((S,\\oplus)\\) and any \\(a\\in S\\), the order of \\(a\\) is equal to the size of the subgroup it generates, or \\(\\operatorname{ord}(a)=|\\langle a\\rangle|\\)._\n\n_Proof_ Let \\(t=\\operatorname{ord}(a)\\). Since \\(a^{(t)}=e\\) and \\(a^{(t+k)}=a^{(t)}\\oplus a^{(k)}=a^{(k)}\\) for \\(k\\geq 1\\), if \\(i>t\\), then \\(a^{(i)}=a^{(j)}\\) for some \\(j<i\\). Therefore, as we generate elements by \\(a\\), we see no new elements after \\(a^{(t)}\\). Thus, \\(\\langle a\\rangle=\\left\\{a^{(1)},a^{(2)},\\ldots,a^{(t)}\\right\\}\\), and so \\(|\\langle a\\rangle|\\leq t\\). To show that \\(|\\langle a\\rangle|\\geq t\\), we show that each element of the sequence \\(a^{(1)},a^{(2)},\\ldots,a^{(t)}\\) is distinct. Suppose for the purpose of contradiction that \\(a^{(i)}=a^{(j)}\\) for some \\(i\\) and \\(j\\) satisfying \\(1\\leq i<j\\leq t\\). Then, \\(a^{(i\\,+\\,k)}=a^{(j\\,+\\,k)}\\) for \\(k\\geq 0\\). But this equation implies that \\(a^{(i+(t-j))}=a^{(j+(t-j))}=e\\), a contradiction, since \\(i+(t-j)<t\\) but \\(t\\) is the least positive value such that \\(a^{(t)}=e\\). Therefore, each element of the sequence \\(a^{(1)},a^{(2)},\\ldots,a^{(t)}\\) is distinct, and \\(|\\langle a\\rangle|\\geq t\\). We conclude that \\(\\operatorname{ord}(a)=|\\langle a\\rangle|\\).\n\n_Corollary 31.18_: The sequence \\(a^{(1)},a^{(2)},\\ldots\\) is periodic with period \\(t=\\operatorname{ord}(a)\\), that is, \\(a^{(i)}=a^{(j)}\\) if and only if \\(i=j\\pmod{t}\\).\n\nConsistent with the above corollary, we define \\(a^{(0)}\\) as \\(e\\) and \\(a^{(i)}\\) as \\(a^{(i\\bmod{t})}\\), where \\(t=\\operatorname{ord}(a)\\), for all integers \\(i\\).\n\n_Corollary 31.19_: If \\((S,\\oplus)\\) is a finite group with identity \\(e\\), then for all \\(a\\in S\\),\n\n\\(a^{(|S|)}=e\\).\n\n_Proof_Lagrange's theorem (Theorem 31.15) implies that \\(\\operatorname{ord}(a)\\mid|S|\\), and so \\(|S|=0\\pmod{t}\\), where \\(t=\\operatorname{ord}(a)\\). Therefore, \\(a^{(|S|)}=a^{(0)}=e\\).\n\nExercises\n\n_31.3-1_\n\nDraw the group operation tables for the groups \\((\\mathbb{Z}_{4},+_{4})\\) and \\((\\mathbb{Z}_{5}^{*},\\cdot_{5})\\). Show that these groups are isomorphic by exhibiting a one-to-one correspondence \\(f\\) between \\(\\mathbb{Z}_{4}\\) and \\(\\mathbb{Z}_{5}^{*}\\) such that \\(a+b=c\\pmod{4}\\) if and only if \\(f(a)\\cdot f(b)=f(c)\\pmod{5}\\).\n\n_31.3-2_\n\nList all subgroups of \\(\\mathbb{Z}_{9}\\) and of \\(\\mathbb{Z}_{13}^{*}\\).\n\n_31.3-3_\n\nProve Theorem 31.14.\n\n_31.3-4_\n\nShow that if \\(p\\) is prime and \\(e\\) is a positive integer, then\n\n\\(\\phi(p^{e})=p^{e-1}(p-1)\\).\n\n_31.3-5_\n\nShow that for any integer \\(n>1\\) and for any \\(a\\in\\mathbb{Z}_{n}^{*}\\), the function \\(f_{a}:\\mathbb{Z}_{n}^{*}\\to\\mathbb{Z}_{n}^{*}\\) defined by \\(f_{a}(x)=ax\\bmod{n}\\) is a permutation of \\(\\mathbb{Z}_{n}^{*}\\).\n\n### 31.4 Solving modular linear equations\n\nWe now consider the problem of finding solutions to the equation\n\n\\[ax=b\\ \\ \\ (\\mathrm{mod}\\ n)\\, \\tag{31.26}\\]\n\nwhere \\(a>0\\) and \\(n>0\\). This problem has several applications. For example, we'll use it in Section 31.7 as part of the procedure to find keys in the RSA public-key cryptosystem. We assume that \\(a\\,,b\\,,\\) and \\(n\\) are given, and we wish to find all values of \\(x\\), modulo \\(n\\), that satisfy equation (31.26). The equation may have zero, one, or more than one such solution.\n\nLet \\(\\langle a\\rangle\\) denote the subgroup of \\(\\mathbb{Z}_{n}\\) generated by \\(a\\). Since \\(\\langle a\\rangle=\\{a^{(x)}:x>0\\}=\\{ax\\ \\mathrm{mod}\\ n:x>0\\}\\), equation (31.26) has a solution if and only if \\([b]\\in\\langle a\\rangle\\). Lagrange's theorem (Theorem 31.15) tells us that \\(|\\langle a\\rangle|\\) must be a divisor of \\(n\\). The following theorem gives us a precise characterization of \\(\\langle a\\rangle\\).\n\n_Theorem 31.20_\n\nFor any positive integers \\(a\\) and \\(n\\), if \\(d=\\gcd(a,n)\\), then we have\n\n\\[\\langle a\\rangle =\\ \\langle d\\,\\rangle\\] \\[=\\ \\{0,d\\,,2d\\,,\\ldots,((n/d)-1)d\\}\\] in \\(\\mathbb{Z}_{n}\\), and thus \\[|\\langle a\\rangle|=n/d.\\]\n\nProofWe begin by showing that \\(d\\in\\langle a\\rangle\\). Recall that Extended-Euclid\\((a,n)\\) returns a triple \\((d,x,y)\\) such that \\(ax+ny=d\\). Thus, \\(ax=d\\ \\ (\\mathrm{mod}\\ n)\\), so that \\(d\\in\\langle a\\rangle\\). In other words, \\(d\\) is a multiple of \\(a\\) in \\(\\mathbb{Z}_{n}\\).\n\nSince \\(d\\in\\langle a\\rangle\\), it follows that every multiple of \\(d\\) belongs to \\(\\langle a\\rangle\\), because any multiple of a multiple of \\(a\\) is itself a multiple of \\(a\\). Thus, \\(\\langle a\\rangle\\) contains every element in \\(\\{0,d,2d\\,,\\ldots,((n/d)-1)d\\}\\). That is, \\(\\langle d\\rangle\\subseteq\\langle a\\rangle\\).\n\nWe now show that \\(\\langle a\\rangle\\subseteq\\langle d\\rangle\\). If \\(m\\in\\langle a\\rangle\\), then \\(m=ax\\ \\mathrm{mod}\\ n\\) for some integer \\(x\\), and so \\(m=ax+ny\\) for some integer \\(y\\). Because \\(d=\\gcd(a,n)\\), we know that \\(d\\mid a\\) and \\(d\\mid n\\), and so \\(d\\mid m\\) by equation (31.4). Therefore, \\(m\\in\\langle d\\rangle\\).\n\nCombining these results, we have that \\(\\langle a\\rangle=\\langle d\\rangle\\). To see that \\(|\\langle a\\rangle|=n/d\\), observe that there are exactly \\(n/d\\) multiples of \\(d\\) between \\(0\\) and \\(n-1\\), inclusive.\n\n_Corollary 31.21_\n\nThe equation \\(ax=b\\ \\ (\\mathrm{mod}\\ n)\\) is solvable for the unknown \\(x\\) if and only if \\(d\\mid b\\), where \\(d=\\gcd(a,n)\\).",
        "chapter": "Part VII Selected Topics",
        "section": "31 Number-Theoretic Algorithms",
        "subsection": "31.3 Modular arithmetic",
        "subsubsection": "N/A"
    },
    {
        "content": "### 31.4 Solving modular linear equations\n\nWe now consider the problem of finding solutions to the equation\n\n\\[ax=b\\ \\ \\ (\\mathrm{mod}\\ n)\\, \\tag{31.26}\\]\n\nwhere \\(a>0\\) and \\(n>0\\). This problem has several applications. For example, we'll use it in Section 31.7 as part of the procedure to find keys in the RSA public-key cryptosystem. We assume that \\(a\\,,b\\,,\\) and \\(n\\) are given, and we wish to find all values of \\(x\\), modulo \\(n\\), that satisfy equation (31.26). The equation may have zero, one, or more than one such solution.\n\nLet \\(\\langle a\\rangle\\) denote the subgroup of \\(\\mathbb{Z}_{n}\\) generated by \\(a\\). Since \\(\\langle a\\rangle=\\{a^{(x)}:x>0\\}=\\{ax\\ \\mathrm{mod}\\ n:x>0\\}\\), equation (31.26) has a solution if and only if \\([b]\\in\\langle a\\rangle\\). Lagrange's theorem (Theorem 31.15) tells us that \\(|\\langle a\\rangle|\\) must be a divisor of \\(n\\). The following theorem gives us a precise characterization of \\(\\langle a\\rangle\\).\n\n**Theorem 31.20**: For any positive integers \\(a\\) and \\(n\\), if \\(d\\,=\\,\\gcd(a,n)\\), then we have\n\n\\[\\langle a\\rangle =\\ \\langle d\\,\\rangle\\] \\[=\\ \\{0,d\\,,2d\\,,\\ldots,((n/d)-1)d\\}\\] in \\(\\mathbb{Z}_{n}\\), and thus \\[|\\langle a\\rangle|=n/d.\\]\n\nWe begin by showing that \\(d\\,\\in\\,\\langle a\\rangle\\). Recall that Extended-Euclid\\((a,n)\\) returns a triple \\((d,x,y)\\) such that \\(ax+ny=d\\). Thus, \\(ax=d\\ \\ (\\mathrm{mod}\\ n)\\), so that \\(d\\,\\in\\,\\langle a\\rangle\\). In other words, \\(d\\,\\) is a multiple of \\(a\\) in \\(\\mathbb{Z}_{n}\\).\n\nSince \\(d\\,\\in\\,\\langle a\\rangle\\), it follows that every multiple of \\(d\\) belongs to \\(\\langle a\\rangle\\), because any multiple of a multiple of \\(a\\) is itself a multiple of \\(a\\). Thus, \\(\\langle a\\rangle\\) contains every element in \\(\\{0,d,2d\\,,\\ldots,((n/d)-1)d\\}\\). That is, \\(\\langle d\\rangle\\subseteq\\langle a\\rangle\\).\n\nWe now show that \\(\\langle a\\rangle\\subseteq\\langle d\\rangle\\). If \\(m\\,\\in\\,\\langle a\\rangle\\), then \\(m\\,=\\,ax\\ \\mathrm{mod}\\ n\\) for some integer \\(x\\), and so \\(m\\,=\\,ax+ny\\) for some integer \\(y\\). Because \\(d\\,=\\,\\gcd(a,n)\\), we know that \\(d\\,\\mid\\,a\\) and \\(d\\,\\mid\\,n\\,,\\) and so \\(d\\,\\mid\\,m\\) by equation (31.4). Therefore, \\(m\\,\\in\\,\\langle d\\rangle\\).\n\nCombining these results, we have that \\(\\langle a\\rangle=\\langle d\\,\\rangle\\). To see that \\(|\\langle a\\rangle|=n/d\\), observe that there are exactly \\(n/d\\) multiples of \\(d\\) between \\(0\\) and \\(n-1\\), inclusive.\n\n**Corollary 31.21**: The equation \\(ax=b\\ \\ (\\mathrm{mod}\\ n)\\) is solvable for the unknown \\(x\\) if and only if \\(d\\,\\mid\\,b\\,,\\) where \\(d\\,=\\,\\gcd(a,n)\\).\n\n_Proof_ The equation \\(ax=b\\pmod{n}\\) is solvable if and only if \\([b]\\in\\langle a\\rangle\\), which is the same as saying\n\n\\[(b\\ {\\rm mod}\\ n)\\in\\{0,d,2d,\\ldots,((n/d)-1)d\\}\\,\\]\n\nby Theorem 31.20. If \\(0\\leq b<n\\), then \\(b\\in\\langle a\\rangle\\) if and only if \\(d\\mid b\\), since the members of \\(\\langle a\\rangle\\) are precisely the multiples of \\(d\\). If \\(b<0\\) or \\(b\\geq n\\), the corollary then follows from the observation that \\(d\\mid b\\) if and only if \\(d\\mid(b\\ {\\rm mod}\\ n)\\), since \\(b\\) and \\(b\\ {\\rm mod}\\ n\\) differ by a multiple of \\(n\\), which is itself a multiple of \\(d\\).\n\n_Corollary 31.22_\n\nThe equation \\(ax=b\\pmod{n}\\) either has \\(d\\) distinct solutions modulo \\(n\\), where \\(d\\,=\\gcd(a,n)\\), or it has no solutions.\n\n_Proof_ If \\(ax=b\\pmod{n}\\) has a solution, then \\(b\\in\\langle a\\rangle\\). By Theorem 31.17, \\({\\rm ord}(a)=|\\langle a\\rangle|\\), and so Corollary 31.18 and Theorem 31.20 imply that the sequence \\(ai\\ {\\rm mod}\\ n\\), for \\(i=0,1,\\ldots\\), is periodic with period \\(|\\langle a\\rangle|=n/d\\). If \\(b\\in\\langle a\\rangle\\), then \\(b\\) appears exactly \\(d\\) times in the sequence \\(ai\\ {\\rm mod}\\ n\\), for \\(i\\,=0,1,\\ldots,n-1\\), since the length-\\((n/d)\\) block of values \\(\\langle a\\rangle\\) repeats exactly \\(d\\) times as \\(i\\) increases from \\(0\\) to \\(n-1\\). The indices \\(x\\) of the \\(d\\) positions for which \\(ax\\ {\\rm mod}\\ n=b\\) are the solutions of the equation \\(ax=b\\pmod{n}\\).\n\n_Theorem 31.23_\n\nLet \\(d\\,=\\gcd(a,n)\\), and suppose that \\(d\\,=\\,ax^{\\prime}+ny^{\\prime}\\) for some integers \\(x^{\\prime}\\) and \\(y^{\\prime}\\) (for example, as computed by Extended-Euclid). If \\(d\\mid b\\), then the equation \\(ax=b\\pmod{n}\\) has as one of its solutions the value \\(x_{0}\\), where\n\n\\[x_{0}=x^{\\prime}(b/d)\\ {\\rm mod}\\ n\\.\\]\n\n_Proof_ We have\n\n\\[\\begin{array}{l}ax_{0}\\ =\\ ax^{\\prime}(b/d)\\ (\\ {\\rm mod}\\ n)\\\\ \\ =\\ d(b/d)\\ \\ \\ (\\ {\\rm mod}\\ n)\\ \\ \\ \\ \\ \\ \\ \\ \\ ({\\rm because}\\ ax^{\\prime}=d\\ \\ ({\\rm mod}\\ n))\\\\ \\ =\\ b\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ ({\\rm mod}\\ n)\\,\\end{array}\\]\n\nand thus \\(x_{0}\\) is a solution to \\(ax=b\\pmod{n}\\).\n\n_Theorem 31.24_\n\nSuppose that the equation \\(ax=b\\pmod{n}\\) is solvable (that is, \\(d\\mid b\\), where \\(d\\,=\\,\\gcd(a,n)\\)) and that \\(x_{0}\\) is any solution to this equation. Then, this equation has exactly \\(d\\) distinct solutions, modulo \\(n\\), given by \\(x_{i}\\,=\\,x_{0}\\,+\\,i(n/d)\\) for \\(i\\,=\\,0,1,\\ldots,d\\,-1\\).\n\n_Proof_ Because \\(n/d>0\\) and \\(0\\leq i\\,(n/d)<n\\) for \\(i=0,1,\\ldots,d-1\\), the values \\(x_{0},\\,x_{1},\\ldots,x_{d-1}\\) are all distinct, modulo \\(n\\). Since \\(x_{0}\\) is a solution of \\(ax=b\\pmod{n}\\), we have \\(ax_{0}\\bmod n=b\\pmod{n}\\). Thus, for \\(i=0,1,\\ldots,d-1\\), we have\n\n\\[ax_{i}\\bmod n = a\\,(x_{0}+i\\,n/d)\\bmod n\\] \\[= (ax_{0}+ai\\,n/d)\\bmod n\\] \\[= a\\,x_{0}\\bmod n\\quad(\\mbox{because }d\\mid a\\mbox{ implies that }ai\\,n/d\\mbox{ is a multiple of }n)\\] \\[= b\\pmod{n}\\;,\\]\n\nand hence \\(ax_{i}=b\\pmod{n}\\), making \\(x_{i}\\) a solution, too. By Corollary 31.22, the equation \\(ax=b\\pmod{n}\\) has exactly \\(d\\) solutions, so that \\(x_{0},x_{1},\\ldots,x_{d-1}\\) must be all of them.\n\nWe have now developed the mathematics needed to solve the equation \\(ax=b\\pmod{n}\\). The procedure Modular-Linear-Equation-Solver prints all solutions to this equation. The inputs \\(a\\) and \\(n\\) are arbitrary positive integers, and \\(b\\) is an arbitrary integer.\n\nModular-Linear-Equation-Solver\\((a,b,n)\\)\n\n\\((d,x^{\\prime},y^{\\prime})=\\) Extended-Euclid\\((a,n)\\)\n\n**if**\\(d\\mid b\\)\n\n\\(x_{0}=x^{\\prime}(b/d)\\bmod n\\)\n\n**for**\\(i\\,=\\,0\\)**to**\\(d-1\\)\n\nprint \\((x_{0}+i(n/d))\\bmod n\\)\n\n**else** print \"no solutions\"\n\nAs an example of the operation of Modular-Linear-Equation-Solver, consider the equation \\(14x=30(\\bmod 100)\\) (and thus \\(a=14\\), \\(b=30\\), and \\(n=100\\)). Calling Extended-Euclid in line 1 gives \\((d,x^{\\prime},y^{\\prime})=(2,-7,1)\\). Since \\(2\\mid 30\\), lines 3-5 execute. Line 3 computes \\(x_{0}=(-7)(15)\\bmod 100=95\\). The **for** loop of lines 4-5 prints the two solutions, 95 and 45.\n\nThe procedure Modular-Linear-Equation-Solver works as follows. The call to Extended-Euclid in line 1 returns a triple \\((d,x^{\\prime},y^{\\prime})\\) such that \\(d=\\gcd(a,n)\\) and \\(d=ax^{\\prime}+ny^{\\prime}\\). Therefore, \\(x^{\\prime}\\) is a solution to the equation \\(ax^{\\prime}=d\\pmod{n}\\). If \\(d\\) does not divide \\(b\\), then the equation \\(ax=b\\pmod{n}\\) has no solution, by Corollary 31.21. Line 2 checks to see whether \\(d\\mid b\\), and if not, line 6 reports that there are no solutions. Otherwise, line 3 computes a solution \\(x_{0}\\) to \\(ax=b\\pmod{n}\\), as Theorem 31.23 suggests. Given one solution, Theorem 31.24 states that adding multiples of \\((n/d)\\), modulo \\(n\\), yields the other \\(d-1\\) solutions. The **for** loop of lines 4-5 prints out all \\(d\\) solutions, beginning with \\(x_{0}\\) and spaced \\(n/d\\) apart, modulo \\(n\\).\n\nModular-Linear-Equation-Solver performs \\(O(\\lg n+\\gcd(a,n))\\) arithmetic operations, since Extended-Euclid performs \\(O(\\lg n)\\) arithmetic operations, and each iteration of the **for** loop of lines 4-5 performs a constant number of arithmetic operations.\n\nThe following corollaries of Theorem 31.24 give specializations of particular interest.\n\n_Corollary 31.25_\n\nFor any \\(n>1\\), if \\(\\gcd(a,n)=1\\), then the equation \\(ax=b\\pmod{n}\\) has a unique solution, modulo \\(n\\).\n\nIf \\(b=1\\), a common case of considerable interest, the \\(x\\) that solves the equation is a **multiplicative inverse** of \\(a\\), modulo \\(n\\).\n\n_Corollary 31.26_\n\nFor any \\(n>1\\), if \\(\\gcd(a,n)=1\\), then the equation \\(ax=1\\pmod{n}\\) has a unique solution, modulo \\(n\\). Otherwise, it has no solution.\n\nThanks to Corollary 31.26, the notation \\(a^{-1}\\bmod n\\) refers to _the_ multiplicative inverse of \\(a\\), modulo \\(n\\), when \\(a\\) and \\(n\\) are relatively prime. If \\(\\gcd(a,n)=1\\), then the unique solution to the equation \\(ax=1\\pmod{n}\\) is the integer \\(x\\) returned by Extended-Euclid, since the equation\n\n\\(\\gcd(a,n)=1=ax+ny\\)\n\nimplies \\(ax=1\\pmod{n}\\). Thus, Extended-Euclid can compute \\(a^{-1}\\bmod n\\) efficiently.\n\n#### Exercises\n\n_31.4-1_\n\nFind all solutions to the equation \\(35x=10(\\mod 50)\\).\n\n_31.4-2_\n\nProve that the equation \\(ax=ay(\\bmod n)\\) implies \\(x=y\\pmod{n}\\) whenever \\(\\gcd(a,n)=1\\). Show that the condition \\(\\gcd(a,n)=1\\) is necessary by supplying a counterexample with \\(\\gcd(a,n)>1\\).\n\n#### 31.4-3\n\nConsider the following change to line 3 of the procedure Modular-Linear-Equation-Solver:\n\n\\[x_{0}\\,=\\,x^{\\prime}(b/d)\\,\\,\\text{mod}\\,\\,(n/d)\\]\n\nWith this change, will the procedure still work? Explain why or why not.\n\n* _31.4-4_ Let \\(p\\) be prime and \\(f(x)=(f_{0}+f_{1}x+\\cdots+f_{t}x^{t})\\) (mod \\(p\\)) be a polynomial of degree \\(t\\), with coefficients \\(f_{i}\\) drawn from \\(\\mathbb{Z}_{p}\\). We say that \\(a\\,\\in\\,\\mathbb{Z}_{p}\\) is a _zero_ of \\(f\\) if \\(f(a)=0\\) (mod \\(p\\)). Prove that if \\(a\\) is a zero of \\(f\\), then \\(f(x)=(x-a)g(x)(\\mod p)\\) for some polynomial \\(g(x)\\) of degree \\(t-1\\). Prove by induction on \\(t\\) that if \\(p\\) is prime, then a polynomial \\(f(x)\\) of degree \\(t\\) can have at most \\(t\\) distinct zeros modulo \\(p\\).\n\n### 31.5 The Chinese remainder theorem\n\nAround 100 c.e., the Chinese mathematician Sun-Tsu solved the problem of finding those integers \\(x\\) that leave remainders 2, 3, and 2 when divided by 3, 5, and 7 respectively. One such solution is \\(x=23\\), and all solutions are of the form \\(23+105k\\) for arbitrary integers \\(k\\). The \"Chinese remainder theorem\" provides a correspondence between a system of equations modulo a set of pairwise relatively prime moduli (for example, 3, 5, and 7) and an equation modulo their product (for example, 105).\n\nThe Chinese remainder theorem has two major applications. Let the integer \\(n\\) be factored as \\(n=n_{1}n_{2}\\cdots n_{k}\\), where the factors \\(n_{i}\\) are pairwise relatively prime. First, the Chinese remainder theorem is a descriptive \"structure theorem\" that describes the structure of \\(\\mathbb{Z}_{n}\\) as identical to that of the Cartesian product \\(\\mathbb{Z}_{n_{1}}\\times\\mathbb{Z}_{n_{2}}\\times\\cdots\\times\\mathbb{Z}_{n_{k}}\\) with componentwise addition and multiplication modulo \\(n_{i}\\) in the \\(i\\)th component. Second, this description helps in designing efficient algorithms, since working in each of the systems \\(\\mathbb{Z}_{n_{i}}\\) can be more efficient (in terms of bit operations) than working modulo \\(n\\).\n\n**Theorem 31.27** (Chinese remainder theorem): _Let \\(n=n_{1}n_{2}\\cdots n_{k}\\), where the \\(n_{i}\\) are pairwise relatively prime. Consider the correspondence_\n\n\\[a\\,\\leftrightarrow\\,(a_{1},a_{2},\\ldots,a_{k})\\, \\tag{31.27}\\]\n\n_where \\(a\\,\\in\\,\\mathbb{Z}_{n}\\), \\(a_{i}\\,\\in\\,\\mathbb{Z}_{n_{i}}\\), and_",
        "chapter": "Part VII Selected Topics",
        "section": "31 Number-Theoretic Algorithms",
        "subsection": "31.4 Solving modular linear equations",
        "subsubsection": "N/A"
    },
    {
        "content": "#### 31.4-3\n\nConsider the following change to line 3 of the procedure Modular-Linear-Equation-Solver:\n\n\\[x_{0}\\,=\\,x^{\\prime}(b/d)\\,\\,\\text{mod}\\,\\,(n/d)\\]\n\nWith this change, will the procedure still work? Explain why or why not.\n\n* _31.4-4_ Let \\(p\\) be prime and \\(f(x)=(f_{0}+f_{1}x+\\cdots+f_{t}x^{t})\\) (mod \\(p\\)) be a polynomial of degree \\(t\\), with coefficients \\(f_{i}\\) drawn from \\(\\mathbb{Z}_{p}\\). We say that \\(a\\,\\in\\,\\mathbb{Z}_{p}\\) is a _zero_ of \\(f\\) if \\(f(a)=0\\) (mod \\(p\\)). Prove that if \\(a\\) is a zero of \\(f\\), then \\(f(x)=(x-a)g(x)(\\mod p)\\) for some polynomial \\(g(x)\\) of degree \\(t-1\\). Prove by induction on \\(t\\) that if \\(p\\) is prime, then a polynomial \\(f(x)\\) of degree \\(t\\) can have at most \\(t\\) distinct zeros modulo \\(p\\).\n\n### 31.5 The Chinese remainder theorem\n\nAround 100 c.e., the Chinese mathematician Sun-Tsu solved the problem of finding those integers \\(x\\) that leave remainders 2, 3, and 2 when divided by 3, 5, and 7 respectively. One such solution is \\(x=23\\), and all solutions are of the form \\(23+105k\\) for arbitrary integers \\(k\\). The \"Chinese remainder theorem\" provides a correspondence between a system of equations modulo a set of pairwise relatively prime moduli (for example, 3, 5, and 7) and an equation modulo their product (for example, 105).\n\nThe Chinese remainder theorem has two major applications. Let the integer \\(n\\) be factored as \\(n=n_{1}n_{2}\\cdots n_{k}\\), where the factors \\(n_{i}\\) are pairwise relatively prime. First, the Chinese remainder theorem is a descriptive \"structure theorem\" that describes the structure of \\(\\mathbb{Z}_{n}\\) as identical to that of the Cartesian product \\(\\mathbb{Z}_{n_{1}}\\times\\mathbb{Z}_{n_{2}}\\times\\cdots\\times\\mathbb{Z}_{n_{k}}\\) with componentwise addition and multiplication modulo \\(n_{i}\\) in the \\(i\\)th component. Second, this description helps in designing efficient algorithms, since working in each of the systems \\(\\mathbb{Z}_{n_{i}}\\) can be more efficient (in terms of bit operations) than working modulo \\(n\\).\n\n**Theorem 31.27** (Chinese remainder theorem): _Let \\(n=n_{1}n_{2}\\cdots n_{k}\\), where the \\(n_{i}\\) are pairwise relatively prime. Consider the correspondence_\n\n\\[a\\,\\leftrightarrow\\,(a_{1},a_{2},\\ldots,a_{k})\\, \\tag{31.27}\\]\n\n_where \\(a\\,\\in\\,\\mathbb{Z}_{n}\\), \\(a_{i}\\,\\in\\,\\mathbb{Z}_{n_{i}}\\), and_\\(a_{i}=a\\mod n_{i}\\)\n\nfor \\(i=1,2,\\ldots,k\\). Then, mapping (31.27) is a one-to-one mapping (bijection) between \\({\\mathbb{Z}}_{n}\\) and the Cartesian product \\({\\mathbb{Z}}_{n_{1}}\\times{\\mathbb{Z}}_{n_{2}}\\times\\cdots\\times{\\mathbb{Z}}_{ n_{k}}\\). Operations performed on the elements of \\({\\mathbb{Z}}_{n}\\) can be equivalently performed on the corresponding \\(k\\)-tuples by performing the operations independently in each coordinate position in the appropriate system. That is, if\n\n\\(a\\ \\leftrightarrow\\ (a_{1},a_{2},\\ldots,a_{k})\\),\n\n\\(b\\ \\leftrightarrow\\ (b_{1},b_{2},\\ldots,b_{k})\\),\n\nthen\n\n\\((a+b)\\) mod \\(n\\)\\(\\ \\leftrightarrow\\ ((a_{1}+b_{1})\\) mod \\(n_{1},\\ldots,(a_{k}+b_{k})\\) mod \\(n_{k})\\),\n\n\\((a-b)\\) mod \\(n\\)\\(\\ \\leftrightarrow\\ ((a_{1}-b_{1})\\) mod \\(n_{1},\\ldots,(a_{k}-b_{k})\\) mod \\(n_{k})\\),\n\n\\((ab)\\) mod \\(n\\)\\(\\ \\ \\ \\leftrightarrow\\ (a_{1}b_{1}\\) mod \\(n_{1},\\ldots,a_{k}b_{k}\\) mod \\(n_{k})\\).\n\nProofLet's see how to translate between the two representations. Going from \\(a\\) to \\((a_{1},a_{2},\\ldots,a_{k})\\) requires only \\(k\\) \"mod\" operations. The reverse--computing \\(a\\) from inputs \\((a_{1},a_{2},\\ldots,a_{k})\\)--is only slightly more complicated.\n\nWe begin by defining \\(m_{i}=n/n_{i}\\) for \\(i=1,2,\\ldots,k\\). Thus, \\(m_{i}\\) is the product of all of the \\(n_{j}\\)'s other than \\(n_{i}\\): \\(m_{i}=n_{1}n_{2}\\cdots n_{i-1}n_{i+1}\\cdots n_{k}\\). We next define\n\n\\[c_{i}=m_{i}(m_{i}^{-1}\\ {\\rm mod}\\ n_{i}) \\tag{31.31}\\]\n\nfor \\(i=1,2,\\ldots,k\\). Equation (31.31) is well defined: since \\(m_{i}\\) and \\(n_{i}\\) are relatively prime (by Theorem 31.6), Corollary 31.26 guarantees that \\(m_{i}^{-1}\\) mod \\(n_{i}\\) exists. Here is how to compute \\(a\\) as a function of the \\(a_{i}\\) and \\(c_{i}\\):\n\n\\[a=(a_{1}c_{1}+a_{2}c_{2}+\\cdots+a_{k}c_{k})\\pmod{n}. \\tag{31.32}\\]\n\nWe now show that equation (31.32) ensures that \\(a=a_{i}\\pmod{n_{i}}\\) for \\(i=1,2,\\ldots,k\\). If \\(j\\neq i\\), then \\(m_{j}=0\\pmod{n_{i}}\\), which implies that \\(c_{j}=m_{j}=0\\pmod{n_{i}}\\). Note also that \\(c_{i}=1\\pmod{n_{i}}\\), from equation (31.31). We thus have the appealing and useful correspondence\n\n\\[c_{i}\\ \\leftrightarrow\\ (0,0,\\ldots,0,1,0,\\ldots,0)\\,\\]\n\na vector that has 0s everywhere except in the \\(i\\)th coordinate, where it has a 1. The \\(c_{i}\\) thus form a \"basis\" for the representation, in a certain sense. For each \\(i\\), therefore, we have\n\n\\(a\\ =\\ a_{i}c_{i}\\) (mod \\(n_{i}\\)) \\(=\\ a_{i}m_{i}\\)(\\(m_{i}^{-1}\\) mod \\(n_{i}\\)) (mod \\(n_{i}\\)) \\(=\\ a_{i}\\) (mod \\(n_{i}\\)),which is what we wished to show: our method of computing \\(a\\) from the \\(a_{i}\\)'s produces a result \\(a\\) that satisfies the constraints \\(a=a_{i}\\pmod{n_{i}}\\) for \\(i=1,2,\\ldots,k\\). The correspondence is one-to-one, since we can transform in both directions. Finally, equations (31.28)-(31.30) follow directly from Exercise 31.1-7, since \\(x\\bmod n_{i}=(x\\bmod n)\\bmod n_{i}\\) for any \\(x\\) and \\(i=1,2,\\ldots,k\\).\n\nWe'll use the following corollaries later in this chapter.\n\n_Corollary 31.28_\n\nIf \\(n_{1},n_{2},\\ldots,n_{k}\\) are pairwise relatively prime and \\(n=n_{1}n_{2}\\cdots n_{k}\\), then for any integers \\(a_{1},a_{2},\\ldots,a_{k}\\), the set of simultaneous equations\n\n\\(x=a_{i}\\pmod{n_{i}}\\),\n\nfor \\(i=1,2,\\ldots,k\\), has a unique solution modulo \\(n\\) for the unknown \\(x\\).\n\n_Corollary 31.29_\n\nIf \\(n_{1},n_{2},\\ldots,n_{k}\\) are pairwise relatively prime and \\(n=n_{1}n_{2}\\cdots n_{k}\\), then for all integers \\(x\\) and \\(a\\),\n\n\\(x=a\\pmod{n_{i}}\\)\n\nfor \\(i=1,2,\\ldots,k\\) if and only if\n\n\\(x=a\\pmod{n}\\).\n\nAs an example of the application of the Chinese remainder theorem, suppose that you are given the two equations\n\n\\(a=2\\pmod{5}\\),\n\n\\(a=3\\pmod{13}\\),\n\nso that \\(a_{1}=2\\), \\(n_{1}=m_{2}=5\\), \\(a_{2}=3\\), and \\(n_{2}=m_{1}=13\\), and you wish to compute \\(a\\bmod 65\\), since \\(n=n_{1}n_{2}=65\\). Because \\(13^{-1}=2\\pmod{5}\\) and \\(5^{-1}=8\\pmod{13}\\), you compute\n\n\\(c_{1}=13\\cdot(2\\bmod 5)=26\\),\n\n\\(c_{2}=5\\cdot(8\\bmod 13)=40\\),\n\nand\n\n\\(a=2\\cdot 26+3\\cdot 40\\) (\\(\\bmod\\) 65)\n\n\\(=52+120\\) (\\(\\bmod\\) 65)\n\n\\(=42\\) (\\(\\bmod\\) 65).\n\nSee Figure 31.3 for an illustration of the Chinese remainder theorem, modulo 65.\n\nThus, you can work modulo \\(n\\) by working modulo \\(n\\) directly or by working in the transformed representation using separate modulo \\(n_{i}\\) computations, as convenient. The computations are entirely equivalent.\n\n##### Exercises\n\n_31.5-1_\n\nFind all solutions to the equations \\(x=4\\pmod{5}\\) and \\(x=5\\pmod{11}\\).\n\n_31.5-2_\n\nFind all integers \\(x\\) that leave remainders 1, 2, and 3 when divided by 9, 8, and 7, respectively.\n\n_31.5-3_\n\nArgue that, under the definitions of Theorem 31.27, if \\(\\gcd(a,n)=1\\), then\n\n\\((a^{-1}\\bmod n)\\leftrightarrow((a_{1}^{-1}\\bmod n_{1}),(a_{2}^{-1}\\bmod n_{2} ),\\ldots,(a_{k}^{-1}\\bmod n_{k}))\\).\n\n_31.5-4_\n\nUnder the definitions of Theorem 31.27, prove that for any polynomial \\(f\\), the number of roots of the equation \\(f(x)=0\\pmod{n}\\) equals the product of the number of roots of each of the equations \\(f(x)=0\\pmod{n_{1}}\\), \\(f(x)=0\\pmod{n_{2}}\\),..., \\(f(x)=0\\pmod{n_{k}}\\).\n\nFigure 31.3: An illustration of the Chinese remainder theorem for \\(n_{1}=5\\) and \\(n_{2}=13\\). For this example, \\(c_{1}=26\\) and \\(c_{2}=40\\). In row \\(i\\), column \\(j\\) is shown the value of \\(a\\), modulo 65, such that \\(a\\bmod 5=i\\) and \\(a\\bmod 13=j\\). Note that row 0, column 0 contains a 0. Similarly, row 4, column 12 contains a 64 (equivalent to \\(-1\\)). Since \\(c_{1}=26\\), moving down a row increases \\(a\\) by 26. Similarly, \\(c_{2}=40\\) means that moving right by a column increases \\(a\\) by 40. Increasing \\(a\\) by 1 corresponds to moving diagonally downward and to the right, wrapping around from the bottom to the top and from the right to the left.\n\n### Powers of an element\n\nAlong with considering the multiples of a given element \\(a\\), modulo \\(n\\), we often consider the sequence of powers of \\(a\\), modulo \\(n\\), where \\(a\\in\\mathbb{Z}_{n}^{*}\\):\n\n\\(a^{0}\\), \\(a^{1}\\), \\(a^{2}\\), \\(a^{3}\\), \\(\\ldots\\),\n\nmodulo \\(n\\). Indexing from \\(0\\), the \\(0\\)th value in this sequence is \\(a^{0}\\) mod \\(n=1\\), and the \\(i\\)th value is \\(a^{i}\\) mod \\(n\\). For example, the powers of \\(3\\) modulo \\(7\\) are\n\n\\(i\\)\\(0\\)\\(1\\)\\(2\\)\\(3\\)\\(4\\)\\(5\\)\\(6\\)\\(7\\)\\(8\\)\\(9\\)\\(10\\)\\(11\\)\\(\\cdots\\)\n\n\\(3^{i}\\) mod \\(7\\)\\(1\\)\\(3\\)\\(2\\)\\(6\\)\\(4\\)\\(5\\)\\(1\\)\\(3\\)\\(2\\)\\(6\\)\\(4\\)\\(5\\)\\(\\cdots\\)\n\nand the powers of \\(2\\) modulo \\(7\\) are\n\n\\(i\\)\\(0\\)\\(1\\)\\(2\\)\\(3\\)\\(4\\)\\(5\\)\\(6\\)\\(7\\)\\(8\\)\\(9\\)\\(10\\)\\(11\\)\\(\\cdots\\)\n\n\\(2^{i}\\) mod \\(7\\)\\(1\\)\\(2\\)\\(4\\)\\(1\\)\\(2\\)\\(4\\)\\(1\\)\\(2\\)\\(4\\)\\(1\\)\\(2\\)\\(4\\)\\(1\\)\\(2\\)\\(4\\)\\(\\cdots\\)\n\nIn this section, let \\(\\langle a\\rangle\\) denote the subgroup of \\(\\mathbb{Z}_{n}^{*}\\) generated by \\(a\\) through repeated multiplication, and let \\(\\operatorname{ord}_{n}(a)\\) (the \"order of \\(a\\), modulo \\(n\\)\") denote the order of \\(a\\) in \\(\\mathbb{Z}_{n}^{*}\\). For example, \\(\\langle 2\\rangle=\\{1,2,4\\}\\) in \\(\\mathbb{Z}_{7}^{*}\\), and \\(\\operatorname{ord}_{7}(2)=3\\). Using the definition of the Euler phi function \\(\\phi(n)\\) as the size of \\(\\mathbb{Z}_{n}^{*}\\) (see Section 31.3), we now translate Corollary 31.19 into the notation of \\(\\mathbb{Z}_{n}^{*}\\) to obtain Euler's theorem and specialize it to \\(\\mathbb{Z}_{p}^{*}\\), where \\(p\\) is prime, to obtain Fermat's theorem.\n\n_Theorem 31.30 (Euler's theorem)_\n\nFor any integer \\(n>1\\),\n\n\\(a^{\\phi(n)}=1\\pmod{n}\\) for all \\(a\\in\\mathbb{Z}_{n}^{*}\\).\n\n_Theorem 31.31 (Fermat's theorem)_\n\nIf \\(p\\) is prime, then\n\n\\(a^{p-1}=1\\pmod{p}\\) for all \\(a\\in\\mathbb{Z}_{p}^{*}\\).\n\n_Proof_ By equation (31.22), \\(\\phi(p)=p-1\\) if \\(p\\) is prime.\n\nFermat's theorem applies to every element in \\(\\mathbb{Z}_{p}\\) except \\(0\\), since \\(0\\notin\\mathbb{Z}_{p}^{*}\\). For all \\(a\\in\\mathbb{Z}_{p}\\), however, we have \\(a^{p}=a\\pmod{p}\\) if \\(p\\) is prime.\n\nIf \\(\\operatorname{ord}_{n}(g)=|\\mathbb{Z}_{n}^{*}|\\), then every element in \\(\\mathbb{Z}_{n}^{*}\\) is a power of \\(g\\), modulo \\(n\\), and \\(g\\) is a _primitive root_ or a _generator_ of \\(\\mathbb{Z}_{n}^{*}\\). For example, \\(3\\) is a primitive root, modulo \\(7\\), but \\(2\\) is not a primitive root, modulo \\(7\\). If \\(\\mathbb{Z}_{n}^{*}\\) possesses a primitive root, the group \\(\\mathbb{Z}_{n}^{*}\\) is _cyclic_. We omit the proof of the following theorem, which is proven by Niven and Zuckerman [345].",
        "chapter": "Part VII Selected Topics",
        "section": "31 Number-Theoretic Algorithms",
        "subsection": "31.5 The Chinese remainder theorem",
        "subsubsection": "N/A"
    },
    {
        "content": "### Powers of an element\n\nAlong with considering the multiples of a given element \\(a\\), modulo \\(n\\), we often consider the sequence of powers of \\(a\\), modulo \\(n\\), where \\(a\\in\\mathbb{Z}_{n}^{*}\\):\n\n\\(a^{0}\\), \\(a^{1}\\), \\(a^{2}\\), \\(a^{3}\\), \\(\\ldots\\),\n\nmodulo \\(n\\). Indexing from \\(0\\), the \\(0\\)th value in this sequence is \\(a^{0}\\) mod \\(n=1\\), and the \\(i\\)th value is \\(a^{i}\\) mod \\(n\\). For example, the powers of \\(3\\) modulo \\(7\\) are\n\n\\(i\\)\\(0\\)\\(1\\)\\(2\\)\\(3\\)\\(4\\)\\(5\\)\\(6\\)\\(7\\)\\(8\\)\\(9\\)\\(10\\)\\(11\\)\\(\\cdots\\)\n\n\\(3^{i}\\) mod \\(7\\)\\(1\\)\\(3\\)\\(2\\)\\(6\\)\\(4\\)\\(5\\)\\(1\\)\\(3\\)\\(2\\)\\(6\\)\\(4\\)\\(5\\)\\(\\cdots\\)\n\nand the powers of \\(2\\) modulo \\(7\\) are\n\n\\(i\\)\\(0\\)\\(1\\)\\(2\\)\\(3\\)\\(4\\)\\(5\\)\\(6\\)\\(7\\)\\(8\\)\\(9\\)\\(10\\)\\(11\\)\\(\\cdots\\)\n\n\\(2^{i}\\) mod \\(7\\)\\(1\\)\\(2\\)\\(4\\)\\(1\\)\\(2\\)\\(4\\)\\(1\\)\\(2\\)\\(4\\)\\(1\\)\\(2\\)\\(4\\)\\(1\\)\\(2\\)\\(4\\)\\(\\cdots\\)\n\nIn this section, let \\(\\langle a\\rangle\\) denote the subgroup of \\(\\mathbb{Z}_{n}^{*}\\) generated by \\(a\\) through repeated multiplication, and let \\(\\operatorname{ord}_{n}(a)\\) (the \"order of \\(a\\), modulo \\(n\\)\") denote the order of \\(a\\) in \\(\\mathbb{Z}_{n}^{*}\\). For example, \\(\\langle 2\\rangle=\\{1,2,4\\}\\) in \\(\\mathbb{Z}_{7}^{*}\\), and \\(\\operatorname{ord}_{7}(2)=3\\). Using the definition of the Euler phi function \\(\\phi(n)\\) as the size of \\(\\mathbb{Z}_{n}^{*}\\) (see Section 31.3), we now translate Corollary 31.19 into the notation of \\(\\mathbb{Z}_{n}^{*}\\) to obtain Euler's theorem and specialize it to \\(\\mathbb{Z}_{p}^{*}\\), where \\(p\\) is prime, to obtain Fermat's theorem.\n\n_Theorem 31.30 (Euler's theorem)_\n\nFor any integer \\(n>1\\),\n\n\\(a^{\\phi(n)}=1\\pmod{n}\\) for all \\(a\\in\\mathbb{Z}_{n}^{*}\\).\n\n_Theorem 31.31 (Fermat's theorem)_\n\nIf \\(p\\) is prime, then\n\n\\(a^{p-1}=1\\pmod{p}\\) for all \\(a\\in\\mathbb{Z}_{p}^{*}\\).\n\n_Proof_ By equation (31.22), \\(\\phi(p)=p-1\\) if \\(p\\) is prime.\n\nFermat's theorem applies to every element in \\(\\mathbb{Z}_{p}\\) except \\(0\\), since \\(0\\notin\\mathbb{Z}_{p}^{*}\\). For all \\(a\\in\\mathbb{Z}_{p}\\), however, we have \\(a^{p}=a\\pmod{p}\\) if \\(p\\) is prime.\n\nIf \\(\\operatorname{ord}_{n}(g)=|\\mathbb{Z}_{n}^{*}|\\), then every element in \\(\\mathbb{Z}_{n}^{*}\\) is a power of \\(g\\), modulo \\(n\\), and \\(g\\) is a _primitive root_ or a _generator_ of \\(\\mathbb{Z}_{n}^{*}\\). For example, \\(3\\) is a primitive root, modulo \\(7\\), but \\(2\\) is not a primitive root, modulo \\(7\\). If \\(\\mathbb{Z}_{n}^{*}\\) possesses a primitive root, the group \\(\\mathbb{Z}_{n}^{*}\\) is _cyclic_. We omit the proof of the following theorem, which is proven by Niven and Zuckerman [345].\n\n**Theorem 31.32**: _The values of \\(n>1\\) for which \\(\\mathbb{Z}_{n}^{*}\\) is cyclic are \\(2\\), \\(4\\), \\(p^{e}\\), and \\(2p^{e}\\), for all primes \\(p>2\\) and all positive integers \\(e\\)._\n\nIf \\(g\\) is a primitive root of \\(\\mathbb{Z}_{n}^{*}\\) and \\(a\\) is any element of \\(\\mathbb{Z}_{n}^{*}\\), then there exists a \\(z\\) such that \\(g^{z}=a\\pmod{n}\\). This \\(z\\) is a _discrete logarithm_ or an _index_ of \\(a\\), modulo \\(n\\), to the base \\(g\\). We denote this value as \\(\\operatorname{ind}_{n,g}(a)\\).\n\n**Theorem 31.33** (Discrete logarithm theorem): _If \\(g\\) is a primitive root of \\(\\mathbb{Z}_{n}^{*}\\), then the equation \\(g^{x}=g^{y}\\pmod{n}\\) holds if and only if the equation \\(x=y\\pmod{\\phi(n)}\\) holds._\n\n_Proof_ Suppose first that \\(x=y\\pmod{\\phi(n)}\\). Then, we have \\(x=y+k\\phi(n)\\) for some integer \\(k\\), and thus\n\n\\[\\begin{array}{llll}g^{x}&=&g^{y+k\\phi(n)}&\\pmod{n}\\\\ &=&g^{y}\\cdot(g^{\\phi(n)})^{k}&\\pmod{n}\\\\ &=&g^{y}\\cdot 1^{k}&\\pmod{n}&\\pmod{\\text{by Euler's theorem}}\\\\ &=&g^{y}&\\pmod{n}\\.\\end{array}\\]\n\nConversely, suppose that \\(g^{x}=g^{y}\\pmod{n}\\). Because the sequence of powers of \\(g\\) generates every element of \\(\\langle g\\rangle\\) and \\(|\\langle g\\rangle|=\\phi(n)\\), Corollary 31.18 implies that the sequence of powers of \\(g\\) is periodic with period \\(\\phi(n)\\). Therefore, if \\(g^{x}=g^{y}\\pmod{n}\\), we must have \\(x=y\\pmod{\\phi(n)}\\).\n\nLet's now turn our attention to the square roots of \\(1\\), modulo a prime power. The following properties will be useful to justify the primality-testing algorithm in Section 31.8.\n\n**Theorem 31.34**: _If \\(p\\) is an odd prime and \\(e\\geq 1\\), then the equation_\n\n\\[x^{2}=1\\pmod{p^{e}} \\tag{31.33}\\]\n\n_has only two solutions, namely \\(x=1\\) and \\(x=-1\\)._\n\n_Proof_ By Exercise 31.6-2, equation (31.33) is equivalent to\n\n\\[p^{e}\\mid(x-1)(x+1)\\.\\]\n\nSince \\(p>2\\), we can have \\(p\\mid(x-1)\\) or \\(p\\mid(x+1)\\), but not both. (Otherwise, by property (31.3), \\(p\\) would also divide their difference \\((x+1)-(x-1)=2\\).) If \\(p\\nmid(x-1)\\), then \\(\\gcd(p^{e},x-1)=1\\), and by Corollary 31.5, we would have \\(p^{e}\\mid(x+1)\\). That is, \\(x=-1\\pmod{p^{e}}\\). Symmetrically, if \\(p\\nmid(x+1)\\)then \\(\\gcd(p^{e},x+1)=1\\), and Corollary 31.5 implies that \\(p^{e}\\mid(x-1)\\), so that \\(x=1\\pmod{p^{e}}\\). Therefore, either \\(x=-1\\pmod{p^{e}}\\) or \\(x=1\\pmod{p^{e}}\\).\n\nA number \\(x\\) is a **nontrivial square root of \\(1,\\) modulo \\(n\\)**, if it satisfies the equation \\(x^{2}=1\\pmod{n}\\) but \\(x\\) is equivalent to neither of the two \"trivial\" square roots: \\(1\\) or \\(-1,\\) modulo \\(n\\). For example, \\(6\\) is a nontrivial square root of \\(1\\), modulo \\(35\\). We'll use the following corollary to Theorem 31.34 in Section 31.8 to prove the Miller-Rabin primality-testing procedure correct.\n\n_Corollary 31.35_\n\nIf there exists a nontrivial square root of \\(1,\\) modulo \\(n\\), then \\(n\\) is composite.\n\n_Proof_By the contrapositive of Theorem 31.34, if there exists a nontrivial square root of \\(1\\), modulo \\(n\\), then \\(n\\) cannot be an odd prime or a power of an odd prime. Nor can \\(n\\) be \\(2\\), because if \\(x^{2}=1\\pmod{2}\\), then \\(x=1\\pmod{2}\\), and therefore, all square roots of \\(1,\\) modulo \\(2\\), are trivial. Thus, \\(n\\) cannot be prime. Finally, we must have \\(n>1\\) for a nontrivial square root of \\(1\\) to exist. Therefore, \\(n\\) must be composite.\n\n### Raising to powers with repeated squaring\n\nA frequently occurring operation in number-theoretic computations is raising one number to a power modulo another number, also known as **modular exponentiation**. More precisely, we would like an efficient way to compute \\(a^{b}\\bmod n\\), where \\(a\\) and \\(b\\) are nonnegative integers and \\(n\\) is a positive integer. Modular exponentiation is an essential operation in many primality-testing routines and in the RSA public-key cryptosystem. The method of **repeated squaring** solves this problem efficiently.\n\nRepeated squaring is based on the following formula to compute \\(a^{b}\\) for nonnegative integers \\(a\\) and \\(b\\):\n\n\\[a^{b}=\\left\\{\\begin{array}{ll}1&\\mbox{if $b=0$,}\\\\ (a^{b/2})^{2}&\\mbox{if $b>0$ and $b$ is even,}\\\\ a\\cdot a^{b-1}&\\mbox{if $b>0$ and $b$ is odd.}\\end{array}\\right. \\tag{31.34}\\]\n\nThe last case, where \\(b\\) is odd, reduces to the one of the first two cases, since if \\(b\\) is odd, then \\(b-1\\) is even. The recursive procedure Modular-Exponentiation on the next page computes \\(a^{b}\\bmod n\\) using equation (31.34), but performing all computations modulo \\(n\\). The term \"repeated squaring\" comes from squaring the intermediate result \\(d=a^{b/2}\\) in line 5. Figure 31.4 shows the values of the parameter \\(b\\), the local variable \\(d\\), and the value returned at each level of the recursion for the call Modular-Exponentiation\\((7,560,561)\\), which returns the result \\(1\\).\n\n#### Powers of an element\n\n\\[\\begin{array}{_31.6-4_\n\nGive a nonrecursive (i.e., iterative) version of Modular-Exponentiation.\n\n_31.6-5_\n\nAssuming that you know \\(\\phi(n)\\), explain how to compute \\(a^{-1}\\) mod \\(n\\) for any \\(a\\in\\mathbb{Z}_{n}^{*}\\) using the procedure Modular-Exponentiation.\n\n### 31.7 The RSA public-key cryptosystem\n\nWith a public-key cryptosystem, you can _encrypt_ messages sent between two communicating parties so that an eavesdropper who overhears the encrypted messages will not be able to decode, or _decrypt_, them. A public-key cryptosystem also enables a party to append an unforgeable \"digital signature\" to the end of an electronic message. Such a signature is the electronic version of a handwritten signature on a paper document. It can be easily checked by anyone, forged by no one, yet loses its validity if any bit of the message is altered. It therefore provides authentication of both the identity of the signer and the contents of the signed message. It is the perfect tool for electronically signed business contracts, electronic checks, electronic purchase orders, and other electronic communications that parties wish to authenticate.\n\nThe RSA public-key cryptosystem relies on the dramatic difference between the ease of finding large prime numbers and the difficulty of factoring the product of two large prime numbers. Section 31.8 describes an efficient procedure for finding large prime numbers.\n\n#### Public-key cryptosystems\n\nIn a public-key cryptosystem, each participant has both a _public key_ and a _secret key_. Each key is a piece of information. For example, in the RSA cryptosystem, each key consists of a pair of integers. The participants \"Alice\" and \"Bob\" are traditionally used in cryptography examples. We denote the public keys for Alice and Bob as \\(P_{A}\\) and \\(P_{B}\\), respectively, and likewise the secret keys are \\(S_{A}\\) for Alice and \\(S_{B}\\) for Bob.\n\nEach participant creates his or her own public and secret keys. Secret keys are kept secret, but public keys can be revealed to anyone or even published. In fact, it is often convenient to assume that everyone's public key is available in a public directory, so that any participant can easily obtain the public key of any other participant.",
        "chapter": "Part VII Selected Topics",
        "section": "31 Number-Theoretic Algorithms",
        "subsection": "31.6 Powers of an element",
        "subsubsection": "N/A"
    },
    {
        "content": "_31.6-4_\n\nGive a nonrecursive (i.e., iterative) version of Modular-Exponentiation.\n\n_31.6-5_\n\nAssuming that you know \\(\\phi(n)\\), explain how to compute \\(a^{-1}\\) mod \\(n\\) for any \\(a\\in\\mathbb{Z}_{n}^{*}\\) using the procedure Modular-Exponentiation.\n\n### 31.7 The RSA public-key cryptosystem\n\nWith a public-key cryptosystem, you can _encrypt_ messages sent between two communicating parties so that an eavesdropper who overhears the encrypted messages will not be able to decode, or _decrypt_, them. A public-key cryptosystem also enables a party to append an unforgeable \"digital signature\" to the end of an electronic message. Such a signature is the electronic version of a handwritten signature on a paper document. It can be easily checked by anyone, forged by no one, yet loses its validity if any bit of the message is altered. It therefore provides authentication of both the identity of the signer and the contents of the signed message. It is the perfect tool for electronically signed business contracts, electronic checks, electronic purchase orders, and other electronic communications that parties wish to authenticate.\n\nThe RSA public-key cryptosystem relies on the dramatic difference between the ease of finding large prime numbers and the difficulty of factoring the product of two large prime numbers. Section 31.8 describes an efficient procedure for finding large prime numbers.\n\n#### Public-key cryptosystems\n\nIn a public-key cryptosystem, each participant has both a _public key_ and a _secret key_. Each key is a piece of information. For example, in the RSA cryptosystem, each key consists of a pair of integers. The participants \"Alice\" and \"Bob\" are traditionally used in cryptography examples. We denote the public keys for Alice and Bob as \\(P_{A}\\) and \\(P_{B}\\), respectively, and likewise the secret keys are \\(S_{A}\\) for Alice and \\(S_{B}\\) for Bob.\n\nEach participant creates his or her own public and secret keys. Secret keys are kept secret, but public keys can be revealed to anyone or even published. In fact, it is often convenient to assume that everyone's public key is available in a public directory, so that any participant can easily obtain the public key of any other participant.\n\n#### The RSA public-key cryptosystem\n\nThe public and secret keys specify functions that can be applied to any message. Let \\(\\mathcal{D}\\) denote the set of permissible messages. For example, \\(\\mathcal{D}\\) might be the set of all finite-length bit sequences. The simplest, and original, formulation of public-key cryptography requires one-to-one functions from \\(\\mathcal{D}\\) to itself, based on the public and secret keys. We denote the function based on Alice's public key \\(P_{A}\\) by \\(P_{A}()\\) and the function based on her secret key \\(S_{A}\\) by \\(S_{A}()\\). The functions \\(P_{A}()\\) and \\(S_{A}()\\) are thus permutations of \\(\\mathcal{D}\\). We assume that the functions \\(P_{A}()\\) and \\(S_{A}()\\) are efficiently computable given the corresponding keys \\(P_{A}\\) and \\(S_{A}\\).\n\nThe public and secret keys for any participant are a \"matched pair\" in that they specify functions that are inverses of each other. That is,\n\n\\[M = S_{A}(P_{A}(M))\\, \\tag{31.35}\\] \\[M = P_{A}(S_{A}(M)) \\tag{31.36}\\]\n\nfor any message \\(M\\in\\mathcal{D}\\). Transforming \\(M\\) with the two keys \\(P_{A}\\) and \\(S_{A}\\) successively, in either order, yields back the original message \\(M\\).\n\nA public-key cryptosystem requires that Alice, and only Alice, be able to compute the function \\(S_{A}()\\) in any practical amount of time. This assumption is crucial to keeping encrypted messages sent to Alice private and to knowing that Alice's digital signatures are authentic. Alice must keep her key \\(S_{A}\\) secret. If she does not, whoever else has access to \\(S_{A}\\) can decrypt messages intended only for Alice and can also forge her digital signature. The assumption that only Alice can reasonably compute \\(S_{A}()\\) must hold even though everyone knows \\(P_{A}\\) and can compute \\(P_{A}()\\), the inverse function to \\(S_{A}()\\), efficiently. These requirements appear formidable, but we'll see how to satisfy them.\n\nIn a public-key cryptosystem, encryption works as shown in Figure 31.5. Suppose that Bob wishes to send Alice a message \\(M\\) encrypted so that it looks like\n\nFigure 31.5: Encryption in a public key system. Bob encrypts the message \\(M\\) using Alice\u2019s public key \\(P_{A}\\) and transmits the resulting ciphertext \\(C=P_{A}(M)\\) over a communication channel to Alice. An eavesdropper who captures the transmitted ciphertext gains no information about \\(M\\). Alice receives \\(C\\) and decrypts it using her secret key to obtain the original message \\(M=S_{A}(C)\\).\n\nunintelligible gibberish to an eavesdropper. The scenario for sending the message goes as follows.\n\n* Bob obtains Alice's public key \\(P_{A}\\), perhaps from a public directory or perhaps directly from Alice.\n* Bob computes the _ciphertext_\\(C=P_{A}(M)\\) corresponding to the message \\(M\\) and sends \\(C\\) to Alice.\n* When Alice receives the ciphertext \\(C\\), she applies her secret key \\(S_{A}\\) to retrieve the original message: \\(S_{A}(C)=S_{A}(P_{A}(M))=M\\).\n\nBecause \\(S_{A}()\\) and \\(P_{A}()\\) are inverse functions, Alice can compute \\(M\\) from \\(C\\). Because only Alice is able to compute \\(S_{A}()\\), only Alice can compute \\(M\\) from \\(C\\). Because Bob encrypts \\(M\\) using \\(P_{A}()\\), only Alice can understand the transmitted message.\n\nDigital signatures can be implemented within this formulation of a public-key cryptosystem. (There are other ways to construct digital signatures, but we won't go into them here.) Suppose now that Alice wishes to send Bob a digitally signed response \\(M^{\\prime}\\). Figure 31.6 shows how the digital-signature scenario proceeds.\n\n* Alice computes her _digital signature_\\(\\sigma\\) for the message \\(M^{\\prime}\\) using her secret key \\(S_{A}\\) and the equation \\(\\sigma=S_{A}(M^{\\prime})\\).\n* Alice sends the message/signature pair \\((M^{\\prime},\\sigma)\\) to Bob.\n* When Bob receives \\((M^{\\prime},\\sigma)\\), he can verify that it originated from Alice by using Alice's public key to verify the equation \\(M^{\\prime}=P_{A}(\\sigma)\\). (Presumably, \\(M^{\\prime}\\) contains Alice's name, so that Bob knows whose public key to use.) If the equation holds, then Bob concludes that the message \\(M^{\\prime}\\) was actually signed by Alice. If\n\nFigure 31.6: Digital signatures in a public-key system. Alice signs the message \\(M^{\\prime}\\) by appending her digital signature \\(\\sigma=S_{A}(M^{\\prime})\\) to it. She transmits the message/signature pair \\((M^{\\prime},\\sigma)\\) to Bob, who verifies it by checking the equation \\(M^{\\prime}=P_{A}(\\sigma)\\). If the equation holds, he accepts \\((M^{\\prime},\\sigma)\\) as a message that Alice has signed.\n\nthe equation fails to hold, Bob concludes either that the information he received was corrupted by transmission errors or that the pair \\((M^{\\prime},\\sigma)\\) is an attempted forgery.\n\nBecause a digital signature provides both authentication of the signer's identity and authentication of the contents of the signed message, it is analogous to a handwritten signature at the end of a written document.\n\nA digital signature must be verifiable by anyone who has access to the signer's public key. A signed message can be verified by one party and then passed on to other parties who can also verify the signature. For example, the message might be an electronic check from Alice to Bob. After Bob verifies Alice's signature on the check, he can give the check to his bank, who can then also verify the signature and effect the appropriate funds transfer.\n\nA signed message may or may not be encrypted. The message can be \"in the clear\" and not protected from disclosure. By composing the above protocols for encryption and for signatures, Alice can create a message to Bob that is both signed and encrypted. Alice first appends her digital signature to the message and then encrypts the resulting message/signature pair with Bob's public key. Bob decrypts the received message with his secret key to obtain both the original message and its digital signature. Bob can then verify the signature using Alice's public key. The corresponding combined process using paper-based systems would be to sign the paper document and then seal the document inside a paper envelope that is opened only by the intended recipient.\n\n##### The RSA cryptosystem\n\nIn the _RSA public-key cryptosystem_, a participant creates a public key and a secret key with the following procedure:\n\n1. Select at random two large prime numbers \\(p\\) and \\(q\\) such that \\(p\\neq q\\). The primes \\(p\\) and \\(q\\) might be, say, 1024 bits each.\n2. Compute \\(n=pq\\).\n3. Select a small odd integer \\(e\\) that is relatively prime to \\(\\phi(n)\\), which, by equation (31.21), equals \\((p-1)(q-1)\\).\n4. Compute \\(d\\) as the multiplicative inverse of \\(e\\), modulo \\(\\phi(n)\\). (Corollary 31.26 guarantees that \\(d\\) exists and is uniquely defined. You can use the technique of Section 31.4 to compute \\(d\\), given \\(e\\) and \\(\\phi(n)\\).)\n5. Publish the pair \\(P=(e,n)\\) as the participant's _RSA public key_.\n6. Keep secret the pair \\(S=(d,n)\\) as the participant's _RSA secret key_.\n\nFor this scheme, the domain \\(\\mathcal{D}\\) is the set \\(\\mathbb{Z}_{n}\\). To transform a message \\(M\\) associated with a public key \\(P=(e,n)\\), compute\n\n\\[P(M)=M^{e}\\ \\mathrm{mod}\\ n. \\tag{31.37}\\]\n\nTo transform a ciphertext \\(C\\) associated with a secret key \\(S=(d,n)\\), compute\n\n\\[S(C)=C^{d}\\ \\mathrm{mod}\\ n. \\tag{31.38}\\]\n\nThese equations apply to both encryption and signatures. To create a signature, the signer's secret key is applied to the message to be signed, rather than to a ciphertext. To verify a signature, the public key of the signer is applied to the signature rather than to a message to be encrypted.\n\nTo implement the public-key and secret-key operations (31.37) and (31.38), you can use the procedure Modular-Exponentiation described in Section 31.6. To analyze the running time of these operations, assume that the public key \\((e,n)\\) and secret key \\((d,n)\\) satisfy \\(\\lg e=O(1)\\), \\(\\lg d\\leq\\beta\\), and \\(\\lg n\\leq\\beta\\). Then, applying a public key requires \\(O(1)\\) modular multiplications and uses \\(O(\\beta^{2})\\) bit operations. Applying a secret key requires \\(O(\\beta)\\) modular multiplications, using \\(O(\\beta^{3})\\) bit operations.\n\n_Theorem 31.36 (Correctness of RSA)_\n\nThe RSA equations (31.37) and (31.38) define inverse transformations of \\(\\mathbb{Z}_{n}\\) satisfying equations (31.35) and (31.36).\n\n_Proof_ From equations (31.37) and (31.38), we have that for any \\(M\\in\\mathbb{Z}_{n}\\),\n\n\\[P(S(M))=S(P(M))=M^{ed}\\ \\ \\ (\\mathrm{mod}\\ n)\\.\\]\n\nSince \\(e\\) and \\(d\\) are multiplicative inverses modulo \\(\\phi(n)=(p-1)(q-1)\\),\n\n\\[ed=1+k(p-1)(q-1)\\]\n\nfor some integer \\(k\\). But then, if \\(M\\neq 0\\ \\ (\\mathrm{mod}\\ p)\\), we have\n\n\\[\\begin{array}{ll}M^{ed}&=\\ M(M^{p-1})^{k(q-1)}&(\\mathrm{mod}\\ p)\\\\ &=\\ M((M\\ \\mathrm{mod}\\ p)^{p-1})^{k(q-1)}&(\\mathrm{mod}\\ p)\\\\ &=\\ M(1)^{k(q-1)}&(\\mathrm{mod}\\ p)\\qquad(\\mathrm{by\\ Theorem\\ \\ref{thm:31}})\\\\ &=\\ M&(\\mathrm{mod}\\ p)\\.\\end{array}\\]\n\nAlso, \\(M^{ed}=M\\ \\ (\\mathrm{mod}\\ p)\\) if \\(M=0\\ \\ (\\mathrm{mod}\\ p)\\). Thus,\n\n\\[M^{ed}=M\\ \\ \\ (\\mathrm{mod}\\ p)\\]\n\nfor all \\(M\\). Similarly,\\(M^{\\,ed}\\,=\\,M\\pmod{q}\\)\n\nfor all \\(M\\). Thus, by Corollary 31.29 to the Chinese remainder theorem,\n\n\\(M^{\\,ed}\\,=\\,M\\pmod{n}\\)\n\nfor all \\(M\\).\n\nThe security of the RSA cryptosystem rests in large part on the difficulty of factoring large integers. If an adversary can factor the modulus \\(n\\) in a public key, then the adversary can derive the secret key from the public key, using the knowledge of the factors \\(p\\) and \\(q\\) in the same way that the creator of the public key used them. Therefore, if factoring large integers is easy, then breaking the RSA cryptosystem is easy. The converse statement, that if factoring large integers is hard, then breaking RSA is hard, is unproven. After two decades of research, however, no easier method has been found to break the RSA public-key cryptosystem than to factor the modulus \\(n\\). And factoring large integers is surprisingly difficult. By randomly selecting and multiplying together two 1024-bit primes, you can create a public key that cannot be \"broken\" in any feasible amount of time with current technology. In the absence of a fundamental breakthrough in the design of number-theoretic algorithms, and when implemented with care following recommended standards, the RSA cryptosystem is capable of providing a high degree of security in applications.\n\nIn order to achieve security with the RSA cryptosystem, however, you should use integers that are quite long--more than 1000 bits--to resist possible advances in the art of factoring. In 2021, RSA moduli are commonly in the range of 2048 to 4096 bits. To create moduli of such sizes, you must find large primes efficiently. Section 31.8 addresses this problem.\n\nFor efficiency, RSA is often used in a \"hybrid\" or \"key-management\" mode with fast cryptosystems that are not public-key cryptosystems. With such a _symmetric-key_ system, the encryption and decryption keys are identical. If Alice wishes to send a long message \\(M\\) to Bob privately, she selects a random key \\(K\\) for the fast symmetric-key cryptosystem and encrypts \\(M\\) using \\(K\\), obtaining ciphertext \\(C\\), where \\(C\\) is as long as \\(M\\), but \\(K\\) is quite short. Then she encrypts \\(K\\) using Bob's public RSA key. Since \\(K\\) is short, computing \\(P_{B}(K)\\) is fast (much faster than computing \\(P_{B}(M)\\)). She then transmits (\\(C\\), \\(P_{B}(K)\\)) to Bob, who decrypts \\(P_{B}(K)\\) to obtain \\(K\\) and then uses \\(K\\) to decrypt \\(C\\), obtaining \\(M\\).\n\nA similar hybrid approach creates digital signatures efficiently. This approach combines RSA with a public _collision-resistant hash function_\\(h\\)--a function that is easy to compute but for which it is computationally infeasible to find two messages \\(M\\) and \\(M^{\\prime}\\) such that \\(h(M)\\,=\\,h(M^{\\prime})\\). The value \\(h(M)\\) is a short (say, 256-bit) \"fingerprint\" of the message \\(M\\). If Alice wishes to sign a message \\(M\\), she first applies \\(h\\) to \\(M\\) to obtain the fingerprint \\(h(M)\\), which she then encrypts with her secret key. She sends \\((M,S_{A}(h(M)))\\) to Bob as her signed version of \\(M\\).\n\nBob can verify the signature by computing \\(h(M)\\) and verifying that \\(P_{A}\\) applied to \\(S_{A}(h(M))\\) as received equals \\(h(M)\\). Because no one can create two messages with the same fingerprint, it is computationally infeasible to alter a signed message and preserve the validity of the signature.\n\nOne way to distribute public keys uses _certificates_. For example, assume that there is a \"trusted authority\" \\(T\\) whose public key is known by everyone. Alice can obtain from \\(T\\) a signed message (her certificate) stating that \"Alice's public key is \\(P_{A}\\).\" This certificate is \"self-authenticating\" since everyone knows \\(P_{T}\\). Alice can include her certificate with her signed messages, so that the recipient has Alice's public key immediately available in order to verify her signature. Because her key was signed by \\(T\\), the recipient knows that Alice's key is really Alice's.\n\n#### Exercises\n\n_31.7-1_\n\nConsider an RSA key set with \\(p=11\\), \\(q=29\\), \\(n=319\\), and \\(e=3\\). What value of \\(d\\) should be used in the secret key? What is the encryption of the message \\(M=100\\)?\n\n_31.7-2_\n\nProve that if Alice's public exponent \\(e\\) is 3 and an adversary obtains Alice's secret exponent \\(d\\), where \\(0<d<\\phi(n)\\), then the adversary can factor Alice's modulus \\(n\\) in time polynomial in the number of bits in \\(n\\). (Although you are not asked to prove it, you might be interested to know that this result remains true even if the condition \\(e=3\\) is removed. See Miller [327].)\n\n* _31.7-3_\n\nProve that RSA is multiplicative in the sense that\n\n\\[P_{A}(M_{1})P_{A}(M_{2})=P_{A}(M_{1}M_{2})\\ \\ \\ (\\mbox{mod}\\ n)\\.\\]\n\nUse this fact to prove that if an adversary had a procedure that could efficiently decrypt 1% of messages from \\(\\mathbb{Z}_{n}\\) encrypted with \\(P_{A}\\), then the adversary could employ a probabilistic algorithm to decrypt every message encrypted with \\(P_{A}\\) with high probability.\n\n## 31.8 Primality testing\n\nThis section shows how to find large primes. We begin with a discussion of the density of primes, proceed to examine a plausible, but incomplete, approach to",
        "chapter": "Part VII Selected Topics",
        "section": "31 Number-Theoretic Algorithms",
        "subsection": "31.7 The RSA public-key cryptosystem",
        "subsubsection": "N/A"
    },
    {
        "content": "Bob can verify the signature by computing \\(h(M)\\) and verifying that \\(P_{A}\\) applied to \\(S_{A}(h(M))\\) as received equals \\(h(M)\\). Because no one can create two messages with the same fingerprint, it is computationally infeasible to alter a signed message and preserve the validity of the signature.\n\nOne way to distribute public keys uses _certificates_. For example, assume that there is a \"trusted authority\" \\(T\\) whose public key is known by everyone. Alice can obtain from \\(T\\) a signed message (her certificate) stating that \"Alice's public key is \\(P_{A}\\).\" This certificate is \"self-authenticating\" since everyone knows \\(P_{T}\\). Alice can include her certificate with her signed messages, so that the recipient has Alice's public key immediately available in order to verify her signature. Because her key was signed by \\(T\\), the recipient knows that Alice's key is really Alice's.\n\n#### Exercises\n\n_31.7-1_\n\nConsider an RSA key set with \\(p=11\\), \\(q=29\\), \\(n=319\\), and \\(e=3\\). What value of \\(d\\) should be used in the secret key? What is the encryption of the message \\(M=100\\)?\n\n_31.7-2_\n\nProve that if Alice's public exponent \\(e\\) is 3 and an adversary obtains Alice's secret exponent \\(d\\), where \\(0<d<\\phi(n)\\), then the adversary can factor Alice's modulus \\(n\\) in time polynomial in the number of bits in \\(n\\). (Although you are not asked to prove it, you might be interested to know that this result remains true even if the condition \\(e=3\\) is removed. See Miller [327].)\n\n* _31.7-3_\n\nProve that RSA is multiplicative in the sense that\n\n\\[P_{A}(M_{1})P_{A}(M_{2})=P_{A}(M_{1}M_{2})\\ \\ \\ (\\mbox{mod}\\ n)\\.\\]\n\nUse this fact to prove that if an adversary had a procedure that could efficiently decrypt 1% of messages from \\(\\mathbb{Z}_{n}\\) encrypted with \\(P_{A}\\), then the adversary could employ a probabilistic algorithm to decrypt every message encrypted with \\(P_{A}\\) with high probability.\n\n## 31.8 Primality testing\n\nThis section shows how to find large primes. We begin with a discussion of the density of primes, proceed to examine a plausible, but incomplete, approach to primality testing, and then present an effective randomized primality test due to Miller and Rabin.\n\n##### The density of prime numbers\n\nMany applications, such as cryptography, call for finding large \"random\" primes. Fortunately, large primes are not too rare, so that it is feasible to test random integers of the appropriate size until you find one that is prime. The _prime distribution function_\\(\\pi(n)\\) specifies the number of primes that are less than or equal to \\(n\\). For example, \\(\\pi(10)=4\\), since there are 4 prime numbers less than or equal to 10, namely, 2, 3, 5, and 7. The prime number theorem gives a useful approximation to \\(\\pi(n)\\).\n\n**Theorem 31.37** (Prime number theorem): \\(\\lim_{n\\to\\infty}\\frac{\\pi(n)}{n/\\ln n}=1\\)_._\n\nThe approximation \\(n/\\ln n\\) gives reasonably accurate estimates of \\(\\pi(n)\\) even for small \\(n\\). For example, it is off by less than 6% at \\(n=10^{9}\\), where \\(\\pi(n)=50{,}847{,}534\\) and \\(n/\\ln n\\approx 48{,}254{,}942\\). (To a number theorist, \\(10^{9}\\) is a small number.)\n\nThe process of randomly selecting an integer \\(n\\) and determining whether it is prime is really just a Bernoulli trial (see Section C.4). By the prime number theorem, the probability of a success--that is, the probability that \\(n\\) is prime--is approximately \\(1/\\ln n\\). The geometric distribution says how many trials must occur to obtain a success, and by equation (C.36) on page 1197, the expected number of trials is approximately \\(\\ln n\\). Thus, in order to find a prime that has the same length as \\(n\\) by testing integers chosen randomly near \\(n\\), the expected number examined would be approximately \\(\\ln n\\). For example, the expectation is that finding a 1024-bit prime would require testing approximately \\(\\ln 2^{1024}\\approx 710\\) randomly chosen 1024-bit numbers for primality. (Of course, to cut this figure in half, choose only odd integers.)\n\nThe remainder of this section shows how to determine whether a large odd integer \\(n\\) is prime. For notational convenience, we assume that \\(n\\) has the prime factorization\n\n\\[n=p_{1}^{e_{1}}p_{2}^{e_{2}}\\cdots p_{r}^{e_{r}}\\,\\]\n\nwhere \\(r\\geq 1\\), \\(p_{1}\\), \\(p_{2}\\),..., \\(p_{r}\\) are the prime factors of \\(n\\), and \\(e_{1},e_{2},\\ldots,e_{r}\\) are positive integers. The integer \\(n\\) is prime if and only if \\(r=1\\) and \\(e_{1}=1\\).\n\nOne simple approach to the problem of testing for primality is _trial division_: try dividing \\(n\\) by each integer \\(2,3,5,7,9,\\ldots,\\lfloor\\sqrt{n}\\rfloor\\), skipping even integers greater than 2. We can conclude that \\(n\\) is prime if and only if none of the trial divisors divides \\(n\\). Assuming that each trial division takes constant time, the worst-case running time is \\(\\Theta(\\sqrt{n})\\), which is exponential in the length of \\(n\\). (Recall that if \\(n\\) is encoded in binary using \\(\\beta\\) bits, then \\(\\beta=\\lceil\\lg(n+1)\\rceil\\), and so \\(\\sqrt{n}=\\Theta(2^{\\beta/2})\\).) Thus, trial division works well only if \\(n\\) is very small or happens to have a small prime factor. When it works, trial division has the advantage that it not only determines whether \\(n\\) is prime or composite, it also determines one of \\(n\\)'s prime factors if \\(n\\) is composite.\n\nThis section focuses on finding out whether a given number \\(n\\) is prime. If \\(n\\) is composite, we won't worry about finding its prime factorization. Computing the prime factorization of a number is computationally expensive. You might be surprised that it turns out to be much easier to ascertain whether a given number is prime than it is to determine the prime factorization of the number if it is not prime.\n\n##### Pseudoprimality testing\n\nWe'll start with a method for primality testing that \"almost works\" and, in fact, is good enough for many practical applications. Later on, we'll refine this method to remove the small defect. Let \\(\\mathbb{Z}_{n}^{+}\\) denote the nonzero elements of \\(\\mathbb{Z}_{n}\\):\n\n\\(\\mathbb{Z}_{n}^{+}=\\{1,2,\\ldots,n-1\\}\\) .\n\nIf \\(n\\) is prime, then \\(\\mathbb{Z}_{n}^{+}=\\mathbb{Z}_{n}^{*}\\).\n\nWe say that \\(n\\) is a _base-a pseudoprime_ if \\(n\\) is composite and\n\n\\(a^{n-1}=1\\)  (mod \\(n\\)) .\n\nFermat's theorem (Theorem 31.31 on page 932) implies that if \\(n\\) is prime, then \\(n\\) satisfies equation (31.39) for every \\(a\\) in \\(\\mathbb{Z}_{n}^{+}\\). Thus, if there is any \\(a\\in\\mathbb{Z}_{n}^{+}\\) such that \\(n\\) does _not_ satisfy equation (31.39), then \\(n\\) is certainly composite. Surprisingly, the converse _almost_ holds, so that this criterion forms an almost perfect test for primality. Instead of trying every value of \\(a\\in\\mathbb{Z}_{n}^{+}\\), test to see whether \\(n\\) satisfies equation (31.39) for just \\(a=2\\). If not, then declare \\(n\\) to be composite by returning composite. Otherwise, return prime, guessing that \\(n\\) is prime (when, in fact, all we know is that \\(n\\) is either prime or a base-2 pseudoprime).\n\nThe procedure Pseudoprime on the next page pretends in this manner to check whether \\(n\\) is prime. It uses the procedure Modular-Exponentiation from Section 31.6. It assumes that the input \\(n\\) is an odd integer greater than 2. This procedure can make errors, but only of one type. That is, if it says that \\(n\\) is composite, then it is always correct. If it says that \\(n\\) is prime, however, then it makes an error only if \\(n\\) is a base-2 pseudoprime.\n\nHow often does Pseudoprime err? Surprisingly rarely. There are only 22 values of \\(n\\) less than 10,000 for which it errs, the first four of which are 341, 561, 645,and 1105. We won't prove it, but the probability that this program makes an error on a randomly chosen \\(\\beta\\)-bit number goes to 0 as \\(\\beta\\) approaches \\(\\infty\\). Using more precise estimates due to Pomerance [361] of the number of base-2 pseudoprimes of a given size, a randomly chosen 512-bit number that is called prime by Pseudoprime has less than one chance in \\(10^{20}\\) of being a base-2 pseudoprime, and a randomly chosen 1024-bit number that is called prime has less than one chance in \\(10^{41}\\) of being a base-2 pseudoprime. Thus, if you are merely trying to find a large prime for some application, for all practical purposes you almost never go wrong by choosing large numbers at random until one of them causes Pseudoprime to return prime. But when the numbers being tested for primality are not randomly chosen, you might need a better approach for testing primality. As we'll see, a little more cleverness, and some randomization, will yield a primality-testing method that works well on all inputs.\n\nSince Pseudoprime checks equation (31.39) for only \\(a=2,\\) you might think that you could eliminate all the errors by simply checking equation (31.39) for a second base number, say \\(a=3\\). Better yet, you could check equation (31.39) for even more values of \\(a\\). Unfortunately, even checking for several values of \\(a\\) does not eliminate all errors, because there exist composite integers \\(n\\), known as _Carmichael numbers_, that satisfy equation (31.39) for _all_\\(a\\in\\mathbb{Z}_{n}^{*}\\). (The equation does fail when \\(\\gcd(a,n)>1\\)--that is, when \\(a\\notin\\mathbb{Z}_{n}^{*}\\)--but demonstrating that \\(n\\) is composite by finding such an \\(a\\) can be difficult if \\(n\\) has only large prime factors.) The first three Carmichael numbers are 561, 1105, and 1729. Carmichael numbers are extremely rare. For example, only 255 of them are less than 100,000,000. Exercise 31.8-2 helps explain why they are so rare.\n\nLet's see how to improve the primality test so that Carmichael numbers won't fool it.\n\n##### The Miller-Rabin randomized primality test\n\nThe Miller-Rabin primality test overcomes the problems of the simple procedure Pseudoprime with two modifications:\n\n* It tries several randomly chosen base values \\(a\\) instead of just one base value.\n* While computing each modular exponentiation, it looks for a nontrivial square root of 1, modulo \\(n\\), during the final set of squarings. If it finds one, it stopsand returns composite. Corollary 31.35 from Section 31.6 justifies detecting composites in this manner.\n\nThe pseudocode for the Miller-Rabin primality test appears in the procedures Miller-Rabin and Witness. The input \\(n>2\\) to Miller-Rabin is the odd number to be tested for primality, and \\(s\\) is the number of randomly chosen base values from \\(\\mathbb{Z}_{n}^{+}\\) to be tried. The code uses the random-number generator Random described on page 129: Random(\\(2,n-2\\)) returns a randomly chosen integer \\(a\\) satisfying \\(2\\leq a\\leq n-2\\). (This range of values avoids having \\(a=\\pm 1\\pmod{n}\\).) The call of the auxiliary procedure Witness(\\(a,n\\)) returns true if and only if \\(a\\) is a \"witness\" to the compositeness of \\(n-\\)that is, if it is possible using \\(a\\) to prove (in a manner that we will see) that \\(n\\) is composite. The test Witness(\\(a,n\\)) is an extension of, but more effective than, the test in equation (31.39) that formed the basis for Pseudoprime, using \\(a=2\\).\n\nLet's first understand how Witness works, and then we'll see how the Miller-Rabin primality test uses it. Let \\(n-1=2^{t}u\\) where \\(t\\geq 1\\) and \\(u\\) is odd. That is, the binary representation of \\(n-1\\) is the binary representation of the odd integer \\(u\\) followed by exactly \\(t\\) zeros. Therefore, \\(a^{n-1}=(a^{u})^{2^{t}}\\pmod{n}\\), so that one way to compute \\(a^{n-1}\\bmod{n}\\) is to first compute \\(a^{u}\\bmod{n}\\) and then square the result \\(t\\) times successively.\n\n\\begin{tabular}{l l} Miller-Rabin(\\(n,s\\)) & // \\(n>2\\) is odd \\\\\n1 & \\(\\mbox{\\bf for }j\\ =\\ 1\\mbox{\\bf to }s\\) \\\\\n2 & \\(a\\ =\\ \\mbox{\\rm Random}(2,n-2)\\) \\\\\n3 & \\(\\mbox{\\bf if Witness}(a,n)\\) \\\\\n4 & \\(\\mbox{\\bf return composite }\\) & // definitely \\\\\n5 & \\(\\mbox{\\bf return prime }\\) & // almost surely \\\\ \\end{tabular}\n\n\\begin{tabular}{l l} Witness(\\(a,n\\)) \\\\\n1 & let \\(t\\) and \\(u\\) be such that \\(t\\geq 1,u\\) is odd, and \\(n-1=2^{t}u\\) \\\\\n2 & \\(x_{0}\\ =\\ \\mbox{\\rm Modular-Exponentiation}(a,u,n)\\) \\\\\n3 & \\(i\\ =\\ 1\\mbox{\\bf to }t\\) \\\\\n4 & \\(x_{i}\\ =\\ x_{i-1}^{2}\\bmod{n}\\) \\\\\n5 & \\(x_{i}\\ =\\ 1\\mbox{\\rm and }x_{i-1}\\neq 1\\mbox{\\rm and }x_{i-1}\\neq n-1\\) \\\\\n6 & \\(\\mbox{\\bf return true }\\) & // found a nontrivial square root of 1 \\\\\n7 & \\(x_{t}\\ \\neq\\ 1\\) \\\\\n8 & \\(\\mbox{\\bf return true }\\) & // composite, as in Pseudoprime \\\\\n9 & \\(\\mbox{\\bf return false }\\) \\\\ \\end{tabular}\n\n#### 31.8 Primality testing\n\nThis pseudocode for Witness computes \\(a^{n-1}\\bmod n\\) by first computing the value \\(x_{0}=a^{u}\\bmod n\\) in line 2 and then repeatedly squaring the result \\(t\\) times in the **for** loop of lines 3-6. By induction on \\(i\\), the sequence \\(x_{0}\\), \\(x_{1}\\),..., \\(x_{t}\\) of values computed satisfies the equation \\(x_{i}=a^{2^{i}u}\\pmod{n}\\) for \\(i=0,1,\\ldots,t\\), so that in particular \\(x_{t}=a^{n-1}\\pmod{n}\\). After line 4 performs a squaring step, however, the loop will terminate early if lines 5-6 detect that a nontrivial square root of 1 has just been discovered. (We'll explain these tests shortly.) If so, the procedure stops and returns true. Lines 7-8 return true if the value computed for \\(x_{t}=a^{n-1}\\pmod{n}\\) is not equal to 1, just as the Pseudoprime procedure returns composite in this case. Line 9 returns false if lines 6 or 8 have not returned true.\n\nThe following lemma proves the correctness of Witness.\n\n**Lemma 31.38**: _If Witness\\((a,n)\\) returns true, then a proof that \\(n\\) is composite can be constructed using \\(a\\) as a witness._\n\n_Proof_ If Witness returns true from line 8, it's because line 7 determined that \\(x_{t}=a^{n-1}\\bmod n\\neq 1\\). If \\(n\\) is prime, however, Fermat's theorem (Theorem 31.31) says that \\(a^{n-1}=1\\pmod{n}\\) for all \\(a\\in\\mathbb{Z}_{n}^{*}\\). Since \\(\\mathbb{Z}_{n}^{+}=\\mathbb{Z}_{n}^{*}\\) if \\(n\\) is prime, Fermat's theorem also says that \\(a^{n-1}=1\\pmod{n}\\) for all \\(a\\in\\mathbb{Z}_{n}^{+}\\). Therefore, \\(n\\) cannot be prime, and the equation \\(a^{n-1}\\bmod n\\neq 1\\) proves this fact.\n\nIf Witness returns true from line 6, then it has discovered that \\(x_{i-1}\\) is a nontrivial square root of 1, modulo \\(n\\), since we have that \\(x_{i-1}\\neq\\pm 1\\pmod{n}\\) yet \\(x_{i}=x_{i-1}^{2}=1\\pmod{n}\\). Corollary 31.35 on page 934 states that only if \\(n\\) is composite can there exist a nontrivial square root of \\(1,\\) modulo \\(n\\), so that demonstrating that \\(x_{i-1}\\) is a nontrivial square root of \\(1,\\) modulo \\(n\\) proves that \\(n\\) is composite.\n\nThus, if the call Witness\\((a,n)\\) returns true, then \\(n\\) is surely composite, and the witness \\(a\\), along with the reason that the procedure returns true (did it return from line 6 or from line 8?), provides a proof that \\(n\\) is composite.\n\nLet's explore an alternative view of the behavior of Witness as a function of the sequence \\(X=\\langle x_{0},\\,x_{1},\\ldots,x_{t}\\rangle\\). We'll find this view useful later on, when we analyze the error rate of the Miller-Rabin primality test. Note that if \\(x_{i}=1\\) for some \\(0\\leq i<t\\), Witness might not compute the rest of the sequence. If it were to do so, however, each value \\(x_{i+1},x_{i+2},\\ldots,x_{t}\\) would be 1, so we can consider these positions in the sequence \\(X\\) as being all 1s. There are four cases:\n\n1. \\(X=\\langle\\ldots,d\\rangle\\), where \\(d\\neq 1\\): the sequence \\(X\\) does not end in 1. Return true in line 8, since \\(a\\) is a witness to the compositeness of \\(n\\) (by Fermat's Theorem).\n\n2. \\(X=\\langle 1,\\,1,\\,\\ldots,\\,1\\rangle\\): the sequence \\(X\\) is all \\(1\\)s. Return false, since \\(a\\) is not a witness to the compositeness of \\(n\\).\n3. \\(X=\\langle\\ldots,-1,1,\\ldots,1\\rangle\\): the sequence \\(X\\) ends in \\(1\\), and the last non-\\(1\\) is equal to \\(-1\\). Return false, since \\(a\\) is not a witness to the compositeness of \\(n\\).\n4. \\(X=\\langle\\ldots,d,1,\\ldots,1\\rangle\\), where \\(d\\neq\\pm 1\\): the sequence \\(X\\) ends in \\(1\\), but the last non-\\(1\\) is not \\(-1\\). Return true in line \\(6\\): \\(a\\) is a witness to the compositeness of \\(n\\), since \\(d\\) is a nontrivial square root of \\(1\\).\n\nNow, let's examine the Miller-Rabin primality test based on how it uses the Witness procedure. As before, assume that \\(n\\) is an odd integer greater than \\(2\\).\n\nThe procedure Miller-Rabin is a probabilistic search for a proof that \\(n\\) is composite. The main loop (beginning on line \\(1\\)) picks up to \\(s\\) random values of \\(a\\) from \\(\\mathbb{Z}_{n}^{+}\\), except for \\(1\\) and \\(n-1\\) (line \\(2\\)). If it picks a value of \\(a\\) that is a witness to the compositeness of \\(n\\), then Miller-Rabin returns composite on line \\(4\\). Such a result is always correct, by the correctness of Witness. If Miller-Rabin finds no witness in \\(s\\) trials, then the procedure assumes that it found no witness because no witnesses exist, and therefore it assumes that \\(n\\) is prime. We'll see that this result is likely to be correct if \\(s\\) is large enough, but there is still a tiny chance that the procedure could be unlucky in its choice of \\(s\\) random values of \\(a\\), so that even though the procedure failed to find a witness, at least one witness exists.\n\nTo illustrate the operation of Miller-Rabin, let \\(n\\) be the Carmichael number \\(561\\), so that \\(n-1=560=2^{4}\\cdot 35\\), \\(t=4\\), and \\(u=35\\). If the procedure chooses \\(a=7\\) as a base, the column for \\(b=35\\) in Figure 31.4 (Section 31.6) shows that Witness computes \\(x_{0}=a^{35}=241(\\mod 561)\\). Because of how the Modular-Exponentiation procedure operates recursively on its parameter \\(b\\), the first four columns in Figure 31.4 represent the factor \\(2^{4}\\) of \\(560\\)--the rightmost four zeros in the binary representation of \\(560\\)--reading these four zeros from right to left in the binary representation. Thus Witness computes the sequence \\(X=\\langle 241,298,1667,1\\quad\\rangle\\). Then, in the last squaring step, Witness discovers that \\(a^{280}\\) is a nontrivial square root of \\(1\\) since \\(a^{280}=67(\\mod n)\\) and \\((a^{280})^{2}=a^{560}=1\\pmod{n}\\). Therefore, \\(a=7\\) is a witness to the compositeness of \\(n\\), Witness\\((7,n)\\) returns true, and Miller-Rabin returns composite.\n\nIf \\(n\\) is a \\(\\beta\\)-bit number, Miller-Rabin requires \\(O(s\\beta)\\) arithmetic operations and \\(O(s\\beta^{3})\\) bit operations, since it requires asymptotically no more work than \\(s\\) modular exponentiations.\n\n### Error rate of the Miller-Rabin primality test\n\nIf Miller-Rabin returns prime, then there is a very slim chance that it has made an error. Unlike Pseudoprime, however, the chance of error does not depend on \\(n\\): there are no bad inputs for this procedure. Rather, it depends on the size of and the \"luck of the draw\" in choosing base values \\(a\\). Moreover, since each test is more stringent than a simple check of equation (31.39), we can expect on general principles that the error rate should be small for randomly chosen integers \\(n\\). The following theorem presents a more precise argument.\n\n_Theorem 31.39_\n\nIf \\(n\\) is an odd composite number, then the number of witnesses to the compositeness of \\(n\\) is at least \\((n-1)/2\\).\n\n_Proof_ The proof shows that the number of nonwitnesses is at most \\((n-1)/2\\), which implies the theorem.\n\nWe start by claiming that any nonwitness must be a member of \\(\\mathbb{Z}_{n}^{*}\\). Why? Consider any nonwitness \\(a\\). It must satisfy \\(a^{n-1}=1\\pmod{n}\\) or, equivalently, \\(a\\cdot a^{n-2}=1\\pmod{n}\\). Thus the equation \\(ax=1\\pmod{n}\\) has a solution, namely \\(a^{n-2}\\). By Corollary 31.21 on page 924, \\(\\gcd(a,n)\\mid 1\\), which in turn implies that \\(\\gcd(a,n)=1\\). Therefore, \\(a\\) is a member of \\(\\mathbb{Z}_{n}^{*}\\), and all nonwitnesses belong to \\(\\mathbb{Z}_{n}^{*}\\).\n\nTo complete the proof, we show that not only are all nonwitnesses contained in \\(\\mathbb{Z}_{n}^{*}\\), they are all contained in a proper subgroup \\(B\\) of \\(\\mathbb{Z}_{n}^{*}\\) (recall that \\(B\\) is a _proper_ subgroup of \\(\\mathbb{Z}_{n}^{*}\\) when \\(B\\) is subgroup of \\(\\mathbb{Z}_{n}^{*}\\) but \\(B\\) is not equal to \\(\\mathbb{Z}_{n}^{*}\\)). By Corollary 31.16 on page 921, we then have \\(|B|\\leq|\\mathbb{Z}_{n}^{*}|/2\\). Since \\(|\\mathbb{Z}_{n}^{*}|\\leq n-1\\), we obtain \\(|B|\\leq(n-1)/2\\). Therefore, if all nonwitnesses are contained in a proper subgroup of \\(\\mathbb{Z}_{n}^{*}\\), then the number of nonwitnesses is at most \\((n-1)/2\\), so that the number of witnesses must be at least \\((n-1)/2\\).\n\nTo find a proper subgroup \\(B\\) of \\(\\mathbb{Z}_{n}^{*}\\) containing all of the nonwitnesses, we consider two cases.\n\n_Case 1:_ There exists an \\(x\\in\\mathbb{Z}_{n}^{*}\\) such that\n\n\\[x^{n-1}\\neq 1\\pmod{n}\\.\\]\n\nIn other words, \\(n\\) is not a Carmichael number. Since, as noted earlier, Carmichael numbers are extremely rare, case 1 is the more typical case (e.g., when \\(n\\) has been chosen randomly and is being tested for primality).\n\nLet \\(B=\\{b\\in\\mathbb{Z}_{n}^{*}:b^{n-1}=1\\pmod{n}\\}\\). The set \\(B\\) must be nonempty, since \\(1\\in B\\). The set \\(B\\) is closed under multiplication modulo \\(n\\), and so \\(B\\) is a subgroup of \\(\\mathbb{Z}_{n}^{*}\\) by Theorem 31.14. Every nonwitness belongs to \\(B\\), since a nonwitness \\(a\\) satisfies \\(a^{n-1}=1\\pmod{n}\\). Since \\(x\\in\\mathbb{Z}_{n}^{*}-B\\), we have that \\(B\\) is a proper subgroup of \\(\\mathbb{Z}_{n}^{*}\\).\n\n_Case 2:_ For all \\(x\\in\\mathbb{Z}_{n}^{*}\\),\n\n\\[x^{n-1}=1\\pmod{n}. \\tag{31.40}\\]In other words, \\(n\\) is a Carmichael number. This case is extremely rare in practice. Unlike a pseudoprimality test, however, the Miller-Rabin test can efficiently determine that Carmichael numbers are composite, as we're about to see.\n\nIn this case, \\(n\\) cannot be a prime power. To see why, suppose to the contrary that \\(n=p^{e}\\), where \\(p\\) is a prime and \\(e>1\\). We derive a contradiction as follows. Since we assume that \\(n\\) is odd, \\(p\\) must also be odd. Theorem 31.32 on page 933 implies that \\(\\mathbb{Z}_{n}^{*}\\) is a cyclic group: it contains a generator \\(g\\) such that \\(\\operatorname{ord}_{n}(g)=|\\mathbb{Z}_{n}^{*}|=\\phi(n)=p^{e}(1-1/p)=(p-1)p^{e-1}\\). (The formula for \\(\\phi(n)\\) comes from equation (31.21) on page 920.) By equation (31.40), we have \\(g^{n-1}=1\\pmod{n}\\). Then the discrete logarithm theorem (Theorem 31.33 on page 933, taking \\(y=0\\)) implies that \\(n-1=0\\pmod{\\phi(n)}\\), or\n\n\\[(p-1)p^{e-1}\\mid p^{e}-1\\.\\]\n\nThis statement is a contradiction for \\(e>1\\), since \\((p-1)p^{e-1}\\) is divisible by the prime \\(p\\), but \\(p^{e}-1\\) is not. Thus \\(n\\) is not a prime power.\n\nSince the odd composite number \\(n\\) is not a prime power, we decompose it into a product \\(n_{1}n_{2}\\), where \\(n_{1}\\) and \\(n_{2}\\) are odd numbers greater than \\(1\\) that are relatively prime to each other. (There may be several ways to decompose \\(n\\), and it does not matter which one we choose. For example, if \\(n=p_{1}^{e_{1}}p_{2}^{e_{2}}\\cdots p_{r}^{e_{r}}\\), then we can choose \\(n_{1}=p_{1}^{e_{1}}\\) and \\(n_{2}=p_{2}^{e_{2}}p_{3}^{e_{3}}\\cdots p_{r}^{e_{r}}\\).)\n\nRecall that \\(t\\) and \\(u\\) are such that \\(n-1=2^{t}u\\), where \\(t\\geq 1\\) and \\(u\\) is odd, and that for an input \\(a\\), the procedure Witness computes the sequence\n\n\\[X=\\langle a^{u},a^{2u},a^{2^{2}u},\\ldots,a^{2^{t}u}\\rangle\\]\n\nwhere all computations are performed modulo \\(n\\).\n\nLet us call a pair \\((v,j)\\) of integers _acceptable_ if \\(v\\in\\mathbb{Z}_{n}^{*}\\), \\(j\\in\\{0,1,\\ldots,t\\}\\), and\n\n\\[v^{2^{j}u}=-1\\pmod{n}\\.\\]\n\nAcceptable pairs certainly exist, since \\(u\\) is odd. Choose \\(v=n-1\\) and \\(j=0\\), and let \\(u=2k+1\\), so that \\(v^{2^{j}u}=(n-1)^{u}=(n-1)^{2k+1}\\). Taking this number modulo \\(n\\) gives \\((n-1)^{2k+1}=(n-1)^{2k}\\cdot(n-1)=(-1)^{2k}\\cdot-1=-1\\pmod{n}\\). Thus, \\((n-1,0)\\) is an acceptable pair. Now pick the largest possible \\(j\\) such that there exists an acceptable pair \\((v,j)\\), and fix \\(v\\) so that \\((v,j)\\) is an acceptable pair. Let\n\n\\[B=\\{x\\in\\mathbb{Z}_{n}^{*}:x^{2^{j}u}=\\pm 1\\pmod{n}\\}\\.\\]\n\nSince \\(B\\) is closed under multiplication modulo \\(n\\), it is a subgroup of \\(\\mathbb{Z}_{n}^{*}\\). By Theorem 31.15 on page 921, therefore, \\(|B|\\) divides \\(|\\mathbb{Z}_{n}^{*}|\\). Every nonwitness must be a member of \\(B\\), since the sequence \\(X\\) produced by a nonwitness must either be all \\(1\\)s or else contain a \\(-1\\) no later than the \\(j\\)th position, by the maximality of \\(j\\)(If \\((a,j^{\\prime})\\) is acceptable, where \\(a\\) is a nonwitness, we must have \\(j^{\\prime}\\leq j\\) by how we chose \\(j\\).)\n\nWe now use the existence of \\(v\\) to demonstrate that there exists a \\(w\\in\\mathbb{Z}_{n}^{*}-B\\), and hence that \\(B\\) is a proper subgroup of \\(\\mathbb{Z}_{n}^{*}\\). Since \\(v^{2^{j}u}=-1\\pmod{n}\\), we also have \\(v^{2^{j}u}=-1\\pmod{n_{1}}\\) by Corollary 31.29 to the Chinese remainder theorem. By Corollary 31.28, there exists a \\(w\\) simultaneously satisfying the equations\n\n\\(w\\ =\\ v\\pmod{n_{1}}\\),\n\n\\(w\\ =\\ 1\\pmod{n_{2}}\\).\n\nTherefore,\n\n\\(w^{2^{j}u}\\ =\\ -1\\pmod{n_{1}}\\),\n\n\\(w^{2^{j}u}\\ =\\ \\ 1\\pmod{n_{2}}\\).\n\nCorollary 31.29 gives that \\(w^{2^{j}u}\\neq 1\\pmod{n_{1}}\\) implies \\(w^{2^{j}u}\\neq 1\\pmod{n}\\) and also that \\(w^{2^{j}u}\\neq-1\\pmod{n_{2}}\\) implies \\(w^{2^{j}u}\\neq-1\\pmod{n}\\). Hence, we conclude that \\(w^{2^{j}u}\\neq\\pm 1\\pmod{n}\\), and so \\(w\\notin B\\).\n\nIt remains to show that \\(w\\in\\mathbb{Z}_{n}^{*}\\). We start by working separately modulo \\(n_{1}\\) and modulo \\(n_{2}\\). Working modulo \\(n_{1}\\), since \\(v\\in\\mathbb{Z}_{n}^{*}\\), we have that \\(\\gcd(v,n)=1\\). Also, we have \\(\\gcd(v,n_{1})=1\\), since if \\(v\\) does not have any common divisors with \\(n\\), then it certainly does not have any common divisors with \\(n_{1}\\). Since \\(w=v\\pmod{n_{1}}\\), we see that \\(\\gcd(w,n_{1})=1\\). Working modulo \\(n_{2}\\), we have \\(w=1\\pmod{n_{2}}\\) implies \\(\\gcd(w,n_{2})=1\\) by Exercise 31.2-3. Since \\(\\gcd(w,n_{1})=1\\) and \\(\\gcd(w,n_{2})=1\\), Theorem 31.6 on page 908 yields \\(\\gcd(w,n_{1}n_{2})=\\gcd(w,n)=1\\). That is, \\(w\\in\\mathbb{Z}_{n}^{*}\\).\n\nTherefore, we have \\(w\\in\\mathbb{Z}_{n}^{*}-B\\), and we can conclude in case 2 that \\(B\\), which includes all nonwitnesses, is a proper subgroup of \\(\\mathbb{Z}_{n}^{*}\\) and therefore has size at most \\((n-1)/2\\).\n\nIn either case, the number of witnesses to the compositeness of \\(n\\) is at least \\((n-1)/2\\).\n\n**Theorem 31.40**: For any odd integer \\(n>2\\) and positive integer \\(s\\), the probability that Miller-Rabin\\((n,s)\\) errs is at most \\(2^{-s}\\).\n\n_Proof_ By Theorem 31.39, if \\(n\\) is composite, then each execution of the **for** loop of lines 1-4 of Miller-Rabin has a probability of at least \\(1/2\\) of discovering a witness to the compositeness of \\(n\\). Miller-Rabin makes an error only if it is so unlucky as to miss discovering a witness to the compositeness of \\(n\\) on each of the \\(s\\) iterations of the main loop. The probability of such a sequence of misses is at most \\(2^{-s}\\).\n\nIf \\(n\\) is prime, Miller-Rabin always reports Prime, and if \\(n\\) is composite, the chance that Miller-Rabin reports Prime is at most \\(2^{-s}\\).\n\nWhen applying Miller-Rabin to a large randomly chosen integer \\(n\\), however, we need to consider as well the prior probability that \\(n\\) is prime, in order to correctly interpret Miller-Rabin's result. Suppose that we fix a bit length \\(\\beta\\) and choose at random an integer \\(n\\) of length \\(\\beta\\) bits to be tested for primality, so that \\(\\beta\\approx\\lg n\\approx 1.443\\ln n\\). Let \\(A\\) denote the event that \\(n\\) is prime. By the prime number theorem (Theorem 31.37), the probability that \\(n\\) is prime is approximately\n\n\\[\\Pr\\left\\{A\\right\\} \\approx\\ 1/\\ln n\\] \\[\\approx\\ 1.443/\\beta.\\]\n\nNow let \\(B\\) denote the event that Miller-Rabin returns Prime. We have that \\(\\Pr\\left\\{\\overline{B}\\mid A\\right\\}=0\\) (or equivalently, that \\(\\Pr\\left\\{B\\mid A\\right\\}=1\\)) and \\(\\Pr\\left\\{B\\mid\\overline{A}\\right\\}\\leq 2^{-s}\\) (or equivalently, that \\(\\Pr\\left\\{\\overline{B}\\mid\\overline{A}\\right\\}>1-2^{-s}\\)).\n\nBut what is \\(\\Pr\\left\\{A\\mid B\\right\\}\\), the probability that \\(n\\) is prime, given that Miller-Rabin has returned Prime? By the alternate form of Bayes's theorem (equation (C.20) on page 1189) and approximating \\(\\Pr\\left\\{B\\mid\\overline{A}\\right\\}\\) by \\(2^{-s}\\), we have\n\n\\[\\Pr\\left\\{A\\mid B\\right\\} =\\ \\frac{\\Pr\\left\\{A\\right\\}\\Pr\\left\\{B\\mid A\\right\\}}{\\Pr \\left\\{A\\right\\}\\Pr\\left\\{B\\mid A\\right\\}+\\Pr\\left\\{\\overline{A}\\right\\}\\Pr \\left\\{B\\mid\\overline{A}\\right\\}}\\] \\[\\approx\\ \\frac{(1/\\ln n)\\cdot 1}{(1/\\ln n)\\cdot 1+(1-1/\\ln n) \\cdot 2^{-s}}\\] \\[\\approx\\ \\frac{1}{1+2^{-s}(\\ln n-1)}\\.\\]\n\nThis probability does not exceed \\(1/2\\) until \\(s\\) exceeds \\(\\lg(\\ln n-1)\\). Intuitively, that many initial trials are needed just for the confidence derived from failing to find a witness to the compositeness of \\(n\\) to overcome the prior bias in favor of \\(n\\) being composite. For a number with \\(\\beta=1024\\) bits, this initial testing requires about\n\n\\[\\lg(\\ln n-1) \\approx\\ \\lg(\\beta/1.443)\\] \\[\\approx\\ 9\\]\n\ntrials. In any case, choosing \\(s=50\\) should suffice for almost any imaginable application.\n\nIn fact, the situation is much better. If you are trying to find large primes by applying Miller-Rabin to large randomly chosen odd integers, then choosing a small value of \\(s\\) (say 3) is unlikely to lead to erroneous results, though we won't prove it here. The reason is that for a randomly chosen odd composite integer \\(n\\), the expected number of nonwitnesses to the compositeness of \\(n\\) is likely to be considerably smaller than \\((n-1)/2\\).\n\nIf the integer \\(n\\) is not chosen randomly, however, the best that can be proven is that the number of nonwitnesses is at most \\((n-1)/4\\), using an improved version of Theorem 39. Furthermore, there do exist integers \\(n\\) for which the number of nonwitnesses is \\((n-1)/4\\).\n\n### Exercises\n\n_31.8-1_\n\nProve that if an odd integer \\(n>1\\) is not a prime or a prime power, then there exists a nontrivial square root of \\(1\\), modulo \\(n\\).\n\n_31.8-2_\n\nIt is possible to strengthen Euler's theorem (Theorem 39) slightly to the form\n\n\\(a^{\\lambda(n)}=1\\pmod{n}\\) for all \\(a\\in\\mathbb{Z}_{n}^{*}\\),\n\nwhere \\(n=p_{1}^{e_{1}}\\cdots p_{r}^{e_{r}}\\) and \\(\\lambda(n)\\) is defined by\n\n\\(\\lambda(n)=\\operatorname{lcm}(\\phi(p_{1}^{e_{1}}),\\ldots,\\phi(p_{r}^{e_{r}}))\\).\n\nProve that \\(\\lambda(n)\\mid\\phi(n)\\). A composite number \\(n\\) is a Carmichael number if \\(\\lambda(n)\\mid n-1\\). The smallest Carmichael number is \\(561=3\\cdot 11\\cdot 17\\), for which \\(\\lambda(n)=\\operatorname{lcm}(2,10,16)=80\\), which divides \\(560\\). Prove that Carmichael numbers must be both \"square-free\" (not divisible by the square of any prime) and the product of at least three primes. (For this reason, they are not common.)\n\n_31.8-3_\n\nProve that if \\(x\\) is a nontrivial square root of \\(1\\), modulo \\(n\\), then \\(\\gcd(x-1,n)\\) and \\(\\gcd(x+1,n)\\) are both nontrivial divisors of \\(n\\).\n\n## Problems\n\n_31-1 Binary gcd algorithm_\n\nMost computers can perform the operations of subtraction, testing the parity (odd or even) of a binary integer, and halving more quickly than computing remainders. This problem investigates the _binary gcd algorithm_, which avoids the remainder computations used in Euclid's algorithm.\n\n_a._ Prove that if \\(a\\) and \\(b\\) are both even, then \\(\\gcd(a,b)=2\\cdot\\gcd(a/2,b/2)\\).\n\n_b._ Prove that if \\(a\\) is odd and \\(b\\) is even, then \\(\\gcd(a,b)=\\gcd(a,b/2)\\).\n\n_c._ Prove that if \\(a\\) and \\(b\\) are both odd, then \\(\\gcd(a,b)=\\gcd((a-b)/2,b)\\).",
        "chapter": "Part VII Selected Topics",
        "section": "31 Number-Theoretic Algorithms",
        "subsection": "31.8 Primality testing",
        "subsubsection": "N/A"
    },
    {
        "content": "If the integer \\(n\\) is not chosen randomly, however, the best that can be proven is that the number of nonwitnesses is at most \\((n-1)/4\\), using an improved version of Theorem 31.39. Furthermore, there do exist integers \\(n\\) for which the number of nonwitnesses is \\((n-1)/4\\).\n\n### Exercises\n\n_31.8-1_\n\nProve that if an odd integer \\(n>1\\) is not a prime or a prime power, then there exists a nontrivial square root of \\(1\\), modulo \\(n\\).\n\n_31.8-2_\n\nIt is possible to strengthen Euler's theorem (Theorem 31.30) slightly to the form\n\n\\(a^{\\lambda(n)}=1\\pmod{n}\\) for all \\(a\\in\\mathbb{Z}_{n}^{*}\\),\n\nwhere \\(n=p_{1}^{e_{1}}\\cdots p_{r}^{e_{r}}\\) and \\(\\lambda(n)\\) is defined by\n\n\\(\\lambda(n)=\\operatorname{lcm}(\\phi(p_{1}^{e_{1}}),\\ldots,\\phi(p_{r}^{e_{r}}))\\).\n\nProve that \\(\\lambda(n)\\mid\\phi(n)\\). A composite number \\(n\\) is a Carmichael number if \\(\\lambda(n)\\mid n-1\\). The smallest Carmichael number is \\(561=3\\cdot 11\\cdot 17\\), for which \\(\\lambda(n)=\\operatorname{lcm}(2,10,16)=80\\), which divides \\(560\\). Prove that Carmichael numbers must be both \"square-free\" (not divisible by the square of any prime) and the product of at least three primes. (For this reason, they are not common.)\n\n_31.8-3_\n\nProve that if \\(x\\) is a nontrivial square root of \\(1\\), modulo \\(n\\), then \\(\\gcd(x-1,n)\\) and \\(\\gcd(x+1,n)\\) are both nontrivial divisors of \\(n\\).\n\n## Problems\n\n_31-1 Binary gcd algorithm_\n\nMost computers can perform the operations of subtraction, testing the parity (odd or even) of a binary integer, and halving more quickly than computing remainders. This problem investigates the _binary gcd algorithm_, which avoids the remainder computations used in Euclid's algorithm.\n\n_a._ Prove that if \\(a\\) and \\(b\\) are both even, then \\(\\gcd(a,b)=2\\cdot\\gcd(a/2,b/2)\\).\n\n_b._ Prove that if \\(a\\) is odd and \\(b\\) is even, then \\(\\gcd(a,b)=\\gcd(a,b/2)\\).\n\n_c._ Prove that if \\(a\\) and \\(b\\) are both odd, then \\(\\gcd(a,b)=\\gcd((a-b)/2,b)\\).\n\n* Design an efficient binary gcd algorithm for input integers \\(a\\) and \\(b\\), where \\(a\\geq b\\), that runs in \\(O(\\lg a)\\) time. Assume that each subtraction, parity test, and halving takes unit time.\n* _31-2 Analysis of bit operations in Euclid's algorithm_\n* Consider the ordinary \"paper and pencil\" algorithm for long division: dividing \\(a\\) by \\(b\\), which yields a quotient \\(q\\) and remainder \\(r\\). Show that this method requires \\(O((1+\\lg q)\\lg b)\\) bit operations.\n* Define \\(\\mu(ab)\\ =(1+\\lg a)(1+\\lg b)\\). Show that the number of bit operations performed by Euclid in reducing the problem of computing gcd\\((a,b)\\) to that of computing gcd\\((b,a\\mod b)\\) is at most \\(c(\\mu(a,b)-\\mu(ba\\mod b))\\) for some sufficiently large constant \\(c>0\\).\n* Show that Euclid\\((a,b)\\) requires \\(O(\\mu(a,b))\\) bit operations in general and \\(O(\\beta^{2})\\) bit operations when applied to two \\(\\beta\\)-bit inputs.\n\n### 31-3 Three algorithms for Fibonacci numbers\n\nThis problem compares the efficiency of three methods for computing the \\(n\\)th Fibonacci number \\(F_{n}\\), given \\(n\\). Assume that the cost of adding, subtracting, or multiplying two numbers is \\(O(1)\\), independent of the size of the numbers.\n\n* Show that the running time of the straightforward recursive method for computing \\(F_{n}\\) based on recurrence (3.31) on page 31 is exponential in \\(n\\). (See, for example, the Fib procedure on page 31.)\n* Show how to compute \\(F_{n}\\) in \\(O(n)\\) time using memoization.\n* Show how to compute \\(F_{n}\\) in \\(O(\\lg n)\\) time using only integer addition and multiplication. (_Hint:_ Consider the matrix \\(\\left(\\begin{array}{cc}0&1\\\\ 1&1\\end{array}\\right)\\) and its powers.)\n* Assume now that adding two \\(\\beta\\)-bit numbers takes \\(\\Theta(\\beta)\\) time and that multiplying two \\(\\beta\\)-bit numbers takes \\(\\Theta(\\beta^{2})\\) time. What is the running time of these three methods under this more reasonable cost measure for the elementary arithmetic operations?\n\n### 31-4 Quadratic residues\n\nLet \\(p\\) be an odd prime. A number \\(a\\in Z_{p}^{*}\\) is a _quadratic residue_ modulo \\(p\\), if the equation \\(x^{2}=a\\pmod{p}\\) has a solution for the unknown \\(x\\).\n\n* Show that there are exactly \\((p-1)/2\\) quadratic residues, modulo \\(p\\).\n\n_b._ If \\(p\\) is prime, we define the _Legendre symbol_\\(\\left(\\frac{a}{p}\\right)\\), for \\(a\\in\\mathbb{Z}_{p}^{*}\\), to be \\(1\\) if \\(a\\) is a quadratic residue, modulo \\(p\\), and \\(-1\\) otherwise. Prove that if \\(a\\in\\mathbb{Z}_{p}^{*}\\), then \\(\\left(\\frac{a}{p}\\right)=a^{(p-1)/2}\\pmod{p}\\).\n\nGive an efficient algorithm that determines whether a given number \\(a\\) is a quadratic residue, modulo \\(p\\). Analyze the efficiency of your algorithm.\n\n_c._ Prove that if \\(p\\) is a prime of the form \\(4k+3\\) and \\(a\\) is a quadratic residue in \\(\\mathbb{Z}_{p}^{*}\\), then \\(a^{k+1}\\bmod p\\) is a square root of \\(a\\), modulo \\(p\\). How much time is required to find the square root of a quadratic residue \\(a\\), modulo \\(p\\)?\n\n_d._ Describe an efficient randomized algorithm for finding a nonquadratic residue, modulo an arbitrary prime \\(p\\), that is, a member of \\(\\mathbb{Z}_{p}^{*}\\) that is not a quadratic residue. How many arithmetic operations does your algorithm require on average?\n\n## Chapter notes\n\nKnuth [260] contains a good discussion of algorithms for finding the greatest common divisor, as well as other basic number-theoretic algorithms. Dixon [121] gives an overview of factorization and primality testing. Bach [33], Riesel [378], and Bach and Shallit [34] provide overviews of the basics of computational number theory; Shoup [411] provides a more recent survey. The conference proceedings edited by Pomerance [362] contains several excellent survey articles.\n\nKnuth [260] discusses the origin of Euclid's algorithm. It appears in Book 7, Propositions 1 and 2, of the Greek mathematician Euclid's _Elements_, which was written around 300 b.c.e. Euclid's description may have been derived from an algorithm due to Eudoxus around 375 b.c.e. Euclid's algorithm may hold the honor of being the oldest nontrivial algorithm, rivaled only by an algorithm for multiplication known to the ancient Egyptians. Shallit [407] chronicles the history of the analysis of Euclid's algorithm.\n\nKnuth attributes a special case of the Chinese remainder theorem (Theorem 31.27) to the Chinese mathematician Sun-Tsu, who lived sometime between 200 b.c.e. and 200 c.e.--the date is quite uncertain. The same special case was given by the Greek mathematician Nichomachus around 100 c.e. It was generalized by Qin Jiushao in 1247. The Chinese remainder theorem was finally stated and proved in its full generality by L. Euler in 1734.\n\nThe randomized primality-testing algorithm presented here is due to Miller [327] and Rabin [373] and is the fastest randomized primality-testing algorithm known,",
        "chapter": "Part VII Selected Topics",
        "section": "31 Number-Theoretic Algorithms",
        "subsection": "Problems",
        "subsubsection": "N/A"
    },
    {
        "content": "_b._ If \\(p\\) is prime, we define the _Legendre symbol_\\(\\left(\\frac{a}{p}\\right)\\), for \\(a\\in\\mathbb{Z}_{p}^{*}\\), to be \\(1\\) if \\(a\\) is a quadratic residue, modulo \\(p\\), and \\(-1\\) otherwise. Prove that if \\(a\\in\\mathbb{Z}_{p}^{*}\\), then \\(\\left(\\frac{a}{p}\\right)=a^{(p-1)/2}\\pmod{p}\\).\n\nGive an efficient algorithm that determines whether a given number \\(a\\) is a quadratic residue, modulo \\(p\\). Analyze the efficiency of your algorithm.\n\n_c._ Prove that if \\(p\\) is a prime of the form \\(4k+3\\) and \\(a\\) is a quadratic residue in \\(\\mathbb{Z}_{p}^{*}\\), then \\(a^{k+1}\\bmod p\\) is a square root of \\(a\\), modulo \\(p\\). How much time is required to find the square root of a quadratic residue \\(a\\), modulo \\(p\\)?\n\n_d._ Describe an efficient randomized algorithm for finding a nonquadratic residue, modulo an arbitrary prime \\(p\\), that is, a member of \\(\\mathbb{Z}_{p}^{*}\\) that is not a quadratic residue. How many arithmetic operations does your algorithm require on average?\n\n## Chapter notes\n\nKnuth [260] contains a good discussion of algorithms for finding the greatest common divisor, as well as other basic number-theoretic algorithms. Dixon [121] gives an overview of factorization and primality testing. Bach [33], Riesel [378], and Bach and Shallit [34] provide overviews of the basics of computational number theory; Shoup [411] provides a more recent survey. The conference proceedings edited by Pomerance [362] contains several excellent survey articles.\n\nKnuth [260] discusses the origin of Euclid's algorithm. It appears in Book 7, Propositions 1 and 2, of the Greek mathematician Euclid's _Elements_, which was written around 300 b.c.e. Euclid's description may have been derived from an algorithm due to Eudoxus around 375 b.c.e. Euclid's algorithm may hold the honor of being the oldest nontrivial algorithm, rivaled only by an algorithm for multiplication known to the ancient Egyptians. Shallit [407] chronicles the history of the analysis of Euclid's algorithm.\n\nKnuth attributes a special case of the Chinese remainder theorem (Theorem 31.27) to the Chinese mathematician Sun-Tsu, who lived sometime between 200 b.c.e. and 200 c.e.--the date is quite uncertain. The same special case was given by the Greek mathematician Nichomachus around 100 c.e. It was generalized by Qin Jiushao in 1247. The Chinese remainder theorem was finally stated and proved in its full generality by L. Euler in 1734.\n\nThe randomized primality-testing algorithm presented here is due to Miller [327] and Rabin [373] and is the fastest randomized primality-testing algorithm known,to within constant factors. The proof of Theorem 31.40 is a slight adaptation of one suggested by Bach [32]. A proof of a stronger result for Miller-Rabin was given by Monier [332, 333]. For many years primality-testing was the classic example of a problem where randomization appeared to be necessary to obtain an efficient (polynomial-time) algorithm. In 2002, however, Agrawal, Kayal, and Saxena [4] surprised everyone with their deterministic polynomial-time primality-testing algorithm. Until then, the fastest deterministic primality testing algorithm known, due to Cohen and Lenstra [97], ran in \\((\\lg n)^{O(\\lg\\lg n)}\\) time on input \\(n\\), which is just slightly superpolynomial. Nonetheless, for practical purposes, randomized primality-testing algorithms remain more efficient and are generally preferred.\n\nBeauchemin, Brassard, Crepeau, Goutier, and Pomerance [40] nicely discuss the problem of finding large \"random\" primes.\n\nThe concept of a public-key cryptosystem is due to Diffie and Hellman [115]. The RSA cryptosystem was proposed in 1977 by Rivest, Shamir, and Adleman [380]. Since then, the field of cryptography has blossomed. Our understanding of the RSA cryptosystem has deepened, and modern implementations use significant refinements of the basic techniques presented here. In addition, many new techniques have been developed for proving cryptosystems to be secure. For example, Goldwasser and Micali [190] show that randomization can be an effective tool in the design of secure public-key encryption schemes. For signature schemes, Goldwasser, Micali, and Rivest [191] present a digital-signature scheme for which every conceivable type of forgery is provably as difficult as factoring. Katz and Lindell [253] provide an overview of modern cryptography.\n\nThe best algorithms for factoring large numbers have a running time that grows roughly exponentially with the cube root of the length of the number \\(n\\) to be factored. The general number-field sieve factoring algorithm (as developed by Buhler, Lenstra, and Pomerance [77] as an extension of the ideas in the number-field sieve factoring algorithm by Pollard [360] and Lenstra et al. [295] and refined by Coppersmith [102] and others) is perhaps the most efficient such algorithm in general for large inputs. Although it is difficult to give a rigorous analysis of this algorithm, under reasonable assumptions we can derive a running-time estimate of \\(L(1/3,n)^{1.902+o(1)}\\), where \\(L(\\alpha,n)=e^{(\\ln n)^{\\alpha}(\\ln\\ln n)^{1-\\alpha}}\\).\n\nThe elliptic-curve method due to Lenstra [296] may be more effective for some inputs than the number-field sieve method, since it can find a small prime factor \\(p\\) quite quickly. With this method, the time to find \\(p\\) is estimated to be \\(L(1/2,p)^{\\sqrt{2}+o(1)}\\).\n\n## Chapter 3 String Matching\n\nText-editing programs frequently need to find all occurrences of a pattern in the text. Typically, the text is a document being edited, and the pattern searched for is a particular word supplied by the user. Efficient algorithms for this problem --called \"string matching\"--can greatly aid the responsiveness of the text-editing program. Among their many other applications, string-matching algorithms search for particular patterns in DNA sequences. Internet search engines also use them to find web pages relevant to queries.\n\nThe string-matching problem can be stated formally as follows. The text is given as an array \\(T[1:n]\\) of length \\(n\\), and the pattern is an array \\(P[1:m]\\) of length \\(m\\leq n\\). The elements of \\(P\\) and \\(T\\) are characters drawn from an alphabet \\(\\Sigma\\), which is a finite set of characters. For example, \\(\\Sigma\\) could be the set \\(\\{0,1\\}\\), or it could be the set \\(\\{a,b,\\ldots,z\\}\\). The character arrays \\(P\\) and \\(T\\) are often called _strings_ of characters.\n\nAs Figure 32.1 shows, pattern \\(P\\)_occurs with shift_\\(s\\) in text \\(T\\) (or, equivalently, that pattern \\(P\\)_occurs beginning at position \\(s+1\\)_ in text \\(T\\)) if \\(0\\leq s\\leq n-m\\) and \\(T[s+1:s+m]=P[1:m]\\), that is, if \\(T[s+j]=P[j]\\), for \\(1\\leq j\\leq m\\). If \\(P\\) occurs with shift \\(s\\) in \\(T\\), then \\(s\\) is a _valid shift_, and otherwise, \\(s\\) is an _invalid shift_. The _string-matching problem_ is the problem of finding all valid shifts with which a given pattern \\(P\\) occurs in a given text \\(T\\).\n\nFigure 32.1: An example of the string-matching problem to find all occurrences of the pattern \\(P=\\texttt{abaa}\\) in the text \\(T=\\texttt{abcaabcaabcabac}\\). The pattern occurs only once in the text, at shift \\(s=3\\), which is a valid shift. A vertical line connects each character of the pattern to its matching character in the text, and all matched characters are shaded blue.",
        "chapter": "Part VII Selected Topics",
        "section": "31 Number-Theoretic Algorithms",
        "subsection": "Chapter notes",
        "subsubsection": "N/A"
    },
    {
        "content": "can state the string-matching problem as that of finding all shifts \\(s\\) in the range \\(0\\leq s\\leq n-m\\) such that \\(P\\sqsupset T[\\,:\\,s+m]\\).\n\nOur pseudocode allows two equal-length strings to be compared for equality as a primitive operation. If the strings are compared from left to right and the comparison stops when a mismatch is discovered, we assume that the time taken by such a test is a linear function of the number of matching characters discovered. To be precise, the test \"\\(x=y\\)\" is assumed to take \\(\\Theta(t)\\) time, where \\(t\\) is the length of the longest string \\(z\\) such that \\(z\\sqsubset x\\) and \\(z\\sqsubset y\\).\n\n### The naive string-matching algorithm\n\nThe Naive-String-Matcher procedure finds all valid shifts using a loop that checks the condition \\(P[1:m]=T[s+1:s+m]\\) for each of the \\(n-m+1\\) possible values of \\(s\\).\n\nNaive-String-Matcher(\\(T,P,n,m\\))\n\n**for \\(s=0\\) to \\(n-m\\)**\n\n**if \\(P[1:m]==T[s+1:s+m]\\)**\n\nprint \"Pattern occurs with shift\" \\(s\\)\n\nFigure 32.3 portrays the naive string-matching procedure as sliding a \"template\" containing the pattern over the text, noting for which shifts all of the characters on the template equal the corresponding characters in the text. The **for** loop of lines 1-3 considers each possible shift explicitly. The test in line 2 determines whether the current shift is valid. This test implicitly loops to check corresponding character positions until all positions match successfully or a mismatch is found. Line 3 prints out each valid shift \\(s\\).\n\nProcedure Naive-String-Matcher takes \\(O((n-m+1)m)\\) time, and this bound is tight in the worst case. For example, consider the text string \\(\\mathtt{a}^{n}\\) (a string of \\(n\\) a's) and the pattern \\(\\mathtt{a}^{m}\\). For each of the \\(n-m+1\\) possible values of the shift \\(s\\), the implicit loop on line 2 to compare corresponding characters must execute \\(m\\) times to validate the shift. The worst-case running time is thus \\(\\Theta((n-m+1)m)\\), which is \\(\\Theta(n^{2})\\) if \\(m=\\lfloor n/2\\rfloor\\). Because it requires no preprocessing, Naive-String-Matcher's running time equals its matching time.\n\nNaive-String-Matcher is far from an optimal procedure for this problem. Indeed, this chapter will show that the Knuth-Morris-Pratt algorithm is much better in the worst case. The naive string-matcher is inefficient because it entirely ignores information gained about the text for one value of \\(s\\) when it considers other values of \\(s\\). Such information can be quite valuable, however. For example, if \\(P=\\mathtt{aaab}\\)and \\(s=0\\) is valid, then none of the shifts 1, 2, or 3 are valid, since \\(T[4]=\\mathsf{b}\\). The following sections examine several ways to make effective use of this sort of information.\n\n##### Exercises\n\n##### 32.1-1\n\nShow the comparisons the naive string matcher makes for the pattern \\(P=\\mathtt{0}\\mathtt{0}\\mathtt{0}\\mathtt{1}\\) in the text \\(T=\\mathtt{0}\\mathtt{0}\\mathtt{0}\\mathtt{0}\\mathtt{1}\\mathtt{0}\\mathtt{0} \\mathtt{0}\\mathtt{1}\\mathtt{0}\\mathtt{0}\\mathtt{0}\\mathtt{1}\\).\n\n##### 32.1-2\n\nSuppose that all characters in the pattern \\(P\\) are different. Show how to accelerate Naive-String-Matcher to run in \\(O(n)\\) time on an \\(n\\)-character text \\(T\\).\n\n##### 32.1-3\n\nSuppose that pattern \\(P\\) and text \\(T\\) are _randomly_ chosen strings of length \\(m\\) and \\(n\\), respectively, from the \\(d\\)-ary alphabet \\(\\Sigma_{d}=\\{0,1,\\ldots,d-1\\}\\), where \\(d\\geq 2\\). Show that the _expected_ number of character-to-character comparisons made by the implicit loop in line 2 of the naive algorithm is\n\n\\[(n-m+1)\\frac{1-d^{-m}}{1-d^{-1}}\\leq 2(n-m+1)\\]\n\nover all executions of this loop. (Assume that the naive algorithm stops comparing characters for a given shift once it finds a mismatch or matches the entire pattern.) Thus, for randomly chosen strings, the naive algorithm is quite efficient.\n\n##### 32.1-4\n\nSuppose that the pattern \\(P\\) may contain occurrences of a _gap character_\\(\\diamondsuit\\) that can match an _arbitrary_ string of characters (even one of 0 length). For example, the pattern \\(\\mathtt{ab}\\diamondsuit\\mathtt{ba}\\diamondsuit\\mathtt{c}\\) occurs in the text \\(\\mathtt{c}\\mathtt{a}\\mathtt{b}\\mathtt{c}\\mathtt{c}\\mathtt{b}\\mathtt{a} \\mathtt{c}\\mathtt{b}\\mathtt{c}\\mathtt{a}\\mathtt{b}\\) as\n\nFigure 32.3: The operation of the Naive-String-Matcher procedure for the pattern \\(P=\\mathtt{a}\\mathtt{a}\\mathtt{b}\\) and the text \\(T=\\mathtt{a}\\mathtt{c}\\mathtt{a}\\mathtt{b}\\mathtt{c}\\). Imagine the pattern \\(P\\) as a template that slides next to the text. **(a)\u2013(d)** The four successive alignments tried by the naive string matcher. In each part, vertical lines connect corresponding regions found to match (shown in blue), and a red jagged line connects the first mismatched character found, if any. The algorithm finds one occurrence of the pattern, at shift \\(s=2\\), shown in part (c).\n\n### The Rabin-Karp algorithm\n\nRabin and Karp proposed a string-matching algorithm that performs well in practice and that also generalizes to other algorithms for related problems, such as two-dimensional pattern matching. The Rabin-Karp algorithm uses \\(\\Theta(m)\\) preprocessing time, and its worst-case running time is \\(\\Theta((n-m+1)m)\\). Based on certain assumptions, however, its average-case running time is better.\n\nThis algorithm makes use of elementary number-theoretic notions such as the equivalence of two numbers modulo a third number. You might want to refer to Section 31.1 for the relevant definitions.\n\nFor expository purposes, let's assume that \\(\\Sigma=\\{\\texttt{0},\\texttt{1},\\texttt{2},\\ldots,\\texttt{9}\\}\\), so that each character is a decimal digit. (In the general case, you can assume that each character is a digit in radix-\\(d\\) notation, so that it has a numerical value in the range 0 to \\(d-1\\), where \\(d=|\\Sigma|\\).) You can then view a string of \\(k\\) consecutive characters as representing a length-\\(k\\) decimal number. For example, the character string 31415 corresponds to the decimal number 31,415. Because we interpret the input characters as both graphical symbols and digits, it will be convenient in this section to denote them as digits in standard text font.\n\nGiven a pattern \\(P\\left[1\\!:\\!m\\right]\\), let \\(p\\) denote its corresponding decimal value. In a similar manner, given a text \\(T[1\\!:\\!n]\\), let \\(t_{s}\\) denote the decimal value of the length-\\(m\\) substring \\(T[s+1\\!:\\!s+m]\\), for \\(s=0,1,\\ldots,n-m\\). Certainly, \\(t_{s}=p\\) if and only if \\(T[s+1\\!:\\!s+m]=P\\left[1\\!:\\!m\\right]\\), and thus, \\(s\\) is a valid shift if and only if \\(t_{s}=p\\). If you could compute \\(p\\) in \\(\\Theta(m)\\) time and all the \\(t_{s}\\) values in a total of \\(\\Theta(n-m+1)\\) time,2 then you could determine all valid shifts \\(s\\) in \\(\\Theta(m)+\\Theta(n-m+1)=\\Theta(n)\\)",
        "chapter": "Part VII Selected Topics",
        "section": "32 String Matching",
        "subsection": "32.1 The naive string-matching algorithm",
        "subsubsection": "N/A"
    },
    {
        "content": "### The Rabin-Karp algorithm\n\nRabin and Karp proposed a string-matching algorithm that performs well in practice and that also generalizes to other algorithms for related problems, such as two-dimensional pattern matching. The Rabin-Karp algorithm uses \\(\\Theta(m)\\) preprocessing time, and its worst-case running time is \\(\\Theta((n-m+1)m)\\). Based on certain assumptions, however, its average-case running time is better.\n\nThis algorithm makes use of elementary number-theoretic notions such as the equivalence of two numbers modulo a third number. You might want to refer to Section 31.1 for the relevant definitions.\n\nFor expository purposes, let's assume that \\(\\Sigma=\\{\\texttt{0},\\texttt{1},\\texttt{2},\\ldots,\\texttt{9}\\}\\), so that each character is a decimal digit. (In the general case, you can assume that each character is a digit in radix-\\(d\\) notation, so that it has a numerical value in the range 0 to \\(d-1\\), where \\(d\\,=\\,|\\Sigma|\\).) You can then view a string of \\(k\\) consecutive characters as representing a length-\\(k\\) decimal number. For example, the character string 31415 corresponds to the decimal number 31,415. Because we interpret the input characters as both graphical symbols and digits, it will be convenient in this section to denote them as digits in standard text font.\n\nGiven a pattern \\(P\\,[1\\!:\\!m]\\), let \\(p\\) denote its corresponding decimal value. In a similar manner, given a text \\(T[1\\!:\\!n]\\), let \\(t_{s}\\) denote the decimal value of the length-\\(m\\) substring \\(T[s\\!+\\!1\\!:\\!s+m]\\), for \\(s=0,1,\\ldots,n-m\\). Certainly, \\(t_{s}\\,=\\,p\\) if and only if \\(T[s\\!+\\!1\\!:\\!s+m]\\,=\\,P\\,[1\\!:\\!m]\\), and thus, \\(s\\) is a valid shift if and only if \\(t_{s}\\,=\\,p\\). If you could compute \\(p\\) in \\(\\Theta(m)\\) time and all the \\(t_{s}\\) values in a total of \\(\\Theta(n-m+1)\\) time,2 then you could determine all valid shifts \\(s\\) in \\(\\Theta(m)+\\Theta(n-m+1)=\\Theta(n)\\)time by comparing \\(p\\) with each of the \\(t_{s}\\) values. (For the moment, let's not worry about the possibility that \\(p\\) and the \\(t_{s}\\) values might be very large numbers.)\n\nIndeed, you can compute \\(p\\) in \\(\\Theta(m)\\) time using Horner's rule (see Problem 2-3):\n\n\\[p=P[m]+10\\left(P[m-1]+10\\left(P[m-2]+\\cdots+10(P[2]+10P[1])\\cdots\\right) \\right)\\,.\\]\n\nSimilarly, you can compute \\(t_{0}\\) from \\(T[1:m]\\) in \\(\\Theta(m)\\) time.\n\nTo compute the remaining values \\(t_{1},t_{2},\\ldots,t_{n-m}\\) in \\(\\Theta(n-m)\\) time, observe that you can compute \\(t_{s+1}\\) from \\(t_{s}\\) in constant time, since\n\n\\[t_{s+1}=10\\,\\left(t_{s}-10^{m-1}T[s+1]\\right)+T[s+m+1]\\,. \\tag{32.1}\\]\n\nSubtracting \\(10^{m-1}T[s+1]\\) removes the high-order digit from \\(t_{s}\\), multiplying the result by 10 shifts the number left by one digit position, and adding \\(T[s+m+1]\\) brings in the appropriate low-order digit. For example, suppose that \\(m=5\\), \\(t_{s}=31415\\), and the new low-order digit is \\(T[s+5+1]=2\\). The high-order digit to remove is \\(T[s+1]=3\\), and so\n\n\\[t_{s+1} = 10\\,\\left(31415-10000\\cdot 3\\right)+2\\] \\[= 14152\\]\n\nIf you precompute the constant \\(10^{m-1}\\) (which you can do in \\(O(\\lg m)\\) time using the techniques of Section 31.6, although for this application a straightforward \\(O(m)\\)-time method suffices), then each execution of equation (32.1) takes a constant number of arithmetic operations. Thus, you can compute \\(p\\) in \\(\\Theta(m)\\) time, and you can compute all of \\(t_{0},t_{1},\\ldots,t_{n-m}\\) in \\(\\Theta(n-m+1)\\) time. Therefore, you can find all occurrences of the pattern \\(P[1:m]\\) in the text \\(T[1:n]\\) with \\(\\Theta(m)\\) preprocessing time and \\(\\Theta(n-m+1)\\) matching time.\n\nThis scheme works well if \\(P\\) is short enough and the alphabet \\(\\Sigma\\) is small enough that arithmetic operations on \\(p\\) and \\(t_{s}\\) take constant time. But what if \\(P\\) is long, or if the size of \\(\\Sigma\\) means that instead of powers of \\(10\\) in equation (32.1) you have to use powers of a larger number (such as powers of \\(256\\) for the extended ASCII character set)? Then the values of \\(p\\) and \\(t_{s}\\) might be too large to work with in constant time. Fortunately, this problem can be solved, as Figure 32.4 shows: compute \\(p\\) and the \\(t_{s}\\) values modulo a suitable modulus \\(q\\). You can compute \\(p\\) modulo \\(q\\) in \\(\\Theta(m)\\) time and all the \\(t_{s}\\) values modulo \\(q\\) in \\(\\Theta(n-m+1)\\) time. With \\(|\\Sigma|=10\\), if you choose the modulus \\(q\\) as a prime such that \\(10\\,q\\) just fits within one computer word, then you can perform all the necessary computations with single-precision arithmetic. In general, with a \\(d\\)-ary alphabet \\(\\{0,1,\\ldots,d-1\\}\\), choose \\(q\\) so that \\(dq\\) fits within a computer word and adjust the recurrence equation (32.1) to work modulo \\(q\\), so that it becomes\n\n\\[t_{s+1}=\\left(d(t_{s}-T[s+1]h)+T[s+m+1]\\right)\\,\\mbox{mod}\\,\\,q\\,\\,, \\tag{32.2}\\]\nFigure 32.4: The Rabin-Karp algorithm. Each character is a decimal digit. Values are computed modulo 13. **(a)** A text string. A window of length 5 is shaded blue. The numerical value of the blue number, computed modulo 13, yields the value 7. **(b)** The same text string with values computed modulo 13 for each possible position of a length-5 window. Assuming the pattern \\(P=31415,\\) look for windows whose value modulo 13 is 7, since \\(31415=7\\pmod{13}\\). The algorithm finds two such windows, shaded blue in the figure. The first, beginning at text position 7, is indeed an occurrence of the pattern. The second window, beginning at text position 13, is a spurious hit. **(c)** How to compute the value for a window in constant time, given the value for the previous window. The first window has value \\(31415.\\) Dropping the high-order digit 3, shifting left (multiplying by 10), and then adding in the low-order digit 2 gives the new value \\(14152.\\) Because all computations are performed modulo 13, the value for the first window is 7, and the value for the new window is 8.\n\nwhere \\(h=d^{m-1}\\bmod q\\) is the value of the digit \"1\" in the high-order position of an \\(m\\)-digit text window.\n\nThe solution of working modulo \\(q\\) is not perfect, however: \\(t_{s}=p\\pmod{q}\\) does not automatically mean that \\(t_{s}=p\\). On the other hand, if \\(t_{s}\\neq p\\pmod{q}\\), then you definitely know that \\(t_{s}\\neq p\\), so that shift \\(s\\) is invalid. Thus you can use the test \\(t_{s}=p\\pmod{q}\\) as a fast heuristic test to rule out invalid shifts. If \\(t_{s}=p\\pmod{q}\\)--a _hit_--then you need to test further to see whether \\(s\\) is really valid or you just have a _spurious hit_. This additional test explicitly checks the condition \\(P[1\\!:\\!m]=T[s+1\\!:\\!s+m]\\). If \\(q\\) is large enough, then you would hope that spurious hits occur infrequently enough that the cost of the extra checking is low.\n\nThe procedure Rabin-Karp-Matcher on the next page makes these ideas precise. The inputs to the procedure are the text \\(T\\), the pattern \\(P\\), their lengths \\(n\\) and \\(m\\), the radix \\(d\\) to use (which is typically taken to be \\(|\\Sigma|\\)), and the prime \\(q\\) to use. The procedure works as follows. All characters are interpreted as radix-\\(d\\) digits. The subscripts on \\(t\\) are provided only for clarity: the procedure works correctly if all the subscripts are dropped. Line 1 initializes \\(h\\) to the value of the high-order digit position of an \\(m\\)-digit window. Lines 2-6 compute \\(p\\) as the value of \\(P[1\\!:\\!m]\\bmod q\\) and \\(t_{0}\\) as the value of \\(T[1\\!:\\!m]\\bmod q\\). The **for** loop of lines 7-12 iterates through all possible shifts \\(s\\), maintaining the following invariant:\n\nWhenever line 8 is executed, \\(t_{s}=T[s+1\\!:\\!s+m]\\bmod q\\).\n\nIf a hit occurs because \\(p=t_{s}\\) in line 8, then line 9 determines whether \\(s\\) is a valid shift or the hit was spurious via the test \\(P[1\\!:\\!m]==T[s+1\\!:\\!s+m]\\). Line 10 prints out any valid shifts that are found. If \\(s<n-m\\) (checked in line 11), then the **for** loop will iterate at least one more time, and so line 12 first executes to ensure that the loop invariant holds upon the next iteration. Line 12 computes the value of \\(t_{s+1}\\bmod q\\) from the value of \\(t_{s}\\bmod q\\) in constant time using equation (32.2) directly.\n\nRabin-Karp-Matcher takes \\(\\Theta(m)\\) preprocessing time, and its matching time is \\(\\Theta((n-m+1)m)\\) in the worst case, since (like the naive string-matching algorithm) the Rabin-Karp algorithm explicitly verifies every valid shift. If \\(P=\\mathtt{a}^{m}\\) and \\(T=\\mathtt{a}^{n}\\), then verifying takes \\(\\Theta((n-m+1)m)\\) time, since each of the \\(n-m+1\\) possible shifts is valid.\n\nIn many applications, you expect few valid shifts--perhaps some constant \\(c\\) of them. In such applications, the expected matching time of the algorithm is only \\(O((n-m+1)+cm)=O(n+m)\\), plus the time required to process spurious hits. We can base a heuristic analysis on the assumption that reducing values modulo \\(q\\) acts like a random mapping from \\(\\Sigma^{*}\\) to \\(\\mathbb{Z}_{q}\\). The expected number of spurious hits is then \\(O(n/q)\\), because we can estimate the chance that an arbitrary \\(t_{s}\\) will be equivalent to \\(p\\), modulo \\(q\\), as \\(1/q\\). Since there are \\(O(n)\\) positions at which the test of line 8 fails (actually, at most \\(n-m+1\\) positions) and checking each hit takes \\(O(m)\\) time in line 9, the expected matching time taken by the Rabin-Karp algorithm is\n\n\\[O(n)+O(m(v+n/q))\\,\\]\n\nwhere \\(v\\) is the number of valid shifts. This running time is \\(O(n)\\) if \\(v=O(1)\\) and you choose \\(q\\geq m\\). That is, if the expected number of valid shifts is small (\\(O(1)\\)) and you choose the prime \\(q\\) to be larger than the length of the pattern, then you can expect the Rabin-Karp procedure to use only \\(O(n+m)\\) matching time. Since \\(m\\leq n\\), this expected matching time is \\(O(n)\\).\n\n### Exercises\n\n#### 32.2-1\n\nWorking modulo \\(q=11\\), how many spurious hits does the Rabin-Karp matcher encounter in the text \\(T=3141592653589793\\) when looking for the pattern \\(P=26\\)?\n\n#### 32.2-2\n\nDescribe how to extend the Rabin-Karp method to the problem of searching a text string for an occurrence of any one of a given set of \\(k\\) patterns. Start by assuming that all \\(k\\) patterns have the same length. Then generalize your solution to allow the patterns to have different lengths.\n\n#### 32.2-3\n\nShow how to extend the Rabin-Karp method to handle the problem of looking for a given \\(m\\times m\\) pattern in an \\(n\\times n\\) array of characters. (The pattern may be shifted vertically and horizontally, but it may not be rotated.)\nAlice has a copy of a long \\(n\\)-bit file \\(A=\\langle a_{n-1},\\,a_{n-2},\\ldots,\\,a_{0}\\rangle\\), and Bob similarly has an \\(n\\)-bit file \\(B=\\langle b_{n-1},\\,b_{n-2},\\ldots,\\,b_{0}\\rangle\\). Alice and Bob wish to know if their files are identical. To avoid transmitting all of \\(A\\) or \\(B\\), they use the following fast probabilistic check. Together, they select a prime \\(q\\!\\!>\\!\\!1000n\\) and randomly select an integer \\(x\\) from \\(\\{0,1,\\ldots,q-1\\}\\). Letting\n\n\\[A(x)=\\left(\\,\\sum_{i=0}^{n-1}a_{i}x^{i}\\,\\right)\\,\\mbox{mod}\\,\\,q\\quad\\mbox{ and}\\quad B(x)=\\left(\\,\\sum_{i=0}^{n-1}b_{i}x^{i}\\,\\right)\\,\\mbox{mod}\\,\\,q\\,\\,,\\]\n\nAlice evaluates \\(A(x)\\) and Bob evaluates \\(B(x)\\). Prove that if \\(A\\neq B\\), there is at most one chance in 1000 that \\(A(x)=B(x)\\), whereas if the two files are the same, \\(A(x)\\) is necessarily the same as \\(B(x)\\). (_Hint:_ See Exercise 31.4-4.)\n\n### String matching with finite automata\n\nMany string-matching algorithms build a finite automaton\\(-\\)a simple machine for processing information\\(-\\)that scans the text string \\(T\\) for all occurrences of the pattern \\(P\\). This section presents a method for building such an automaton. These string-matching automata are efficient: they examine each text character _exactly once_, taking constant time per text character. The matching time used\\(-\\)after preprocessing the pattern to build the automaton\\(-\\)is therefore \\(\\Theta(n)\\). The time to build the automaton, however, can be large if \\(\\Sigma\\) is large. Section 32.4 describes a clever way around this problem.\n\nWe begin this section with the definition of a finite automaton. We then examine a special string-matching automaton and show how to use it to find occurrences of a pattern in a text. Finally, we'll see how to construct the string-matching automaton for a given input pattern.\n\n#### Finite automata\n\nA _finite automaton_\\(M\\), illustrated in Figure 32.5, is a 5-tuple \\((Q,q_{0},A,\\Sigma,\\delta)\\), where\n\n* \\(Q\\) is a finite set of _states_,\n* \\(q_{0}\\in Q\\) is the _start state_,\n* \\(A\\subseteq Q\\) is a distinguished set of _accepting states_,\n* \\(\\Sigma\\) is a finite _input alphabet_,\n* \\(\\delta\\) is a function from \\(Q\\times\\Sigma\\) into \\(Q\\), called the _transition function_ of \\(M\\).",
        "chapter": "Part VII Selected Topics",
        "section": "32 String Matching",
        "subsection": "32.2 The Rabin-Karp algorithm",
        "subsubsection": "N/A"
    },
    {
        "content": "Alice has a copy of a long \\(n\\)-bit file \\(A=\\langle a_{n-1},\\,a_{n-2},\\ldots,\\,a_{0}\\rangle\\), and Bob similarly has an \\(n\\)-bit file \\(B=\\langle b_{n-1},\\,b_{n-2},\\ldots,\\,b_{0}\\rangle\\). Alice and Bob wish to know if their files are identical. To avoid transmitting all of \\(A\\) or \\(B\\), they use the following fast probabilistic check. Together, they select a prime \\(q\\!\\!>\\!\\!1000n\\) and randomly select an integer \\(x\\) from \\(\\{0,1,\\ldots,q-1\\}\\). Letting\n\n\\[A(x)=\\left(\\,\\sum_{i=0}^{n-1}a_{i}x^{i}\\,\\right)\\,\\mbox{mod}\\,\\,q\\quad\\mbox{ and}\\quad B(x)=\\left(\\,\\sum_{i=0}^{n-1}b_{i}x^{i}\\,\\right)\\,\\mbox{mod}\\,\\,q\\,\\,,\\]\n\nAlice evaluates \\(A(x)\\) and Bob evaluates \\(B(x)\\). Prove that if \\(A\\neq B\\), there is at most one chance in 1000 that \\(A(x)=B(x)\\), whereas if the two files are the same, \\(A(x)\\) is necessarily the same as \\(B(x)\\). (_Hint:_ See Exercise 31.4-4.)\n\n### String matching with finite automata\n\nMany string-matching algorithms build a finite automaton\\(-\\)a simple machine for processing information\\(-\\)that scans the text string \\(T\\) for all occurrences of the pattern \\(P\\). This section presents a method for building such an automaton. These string-matching automata are efficient: they examine each text character _exactly once_, taking constant time per text character. The matching time used\\(-\\)after preprocessing the pattern to build the automaton\\(-\\)is therefore \\(\\Theta(n)\\). The time to build the automaton, however, can be large if \\(\\Sigma\\) is large. Section 32.4 describes a clever way around this problem.\n\nWe begin this section with the definition of a finite automaton. We then examine a special string-matching automaton and show how to use it to find occurrences of a pattern in a text. Finally, we'll see how to construct the string-matching automaton for a given input pattern.\n\n#### Finite automata\n\nA _finite automaton_\\(M\\), illustrated in Figure 32.5, is a 5-tuple \\((Q,q_{0},A,\\Sigma,\\delta)\\), where\n\n* \\(Q\\) is a finite set of _states_,\n* \\(q_{0}\\in Q\\) is the _start state_,\n* \\(A\\subseteq Q\\) is a distinguished set of _accepting states_,\n* \\(\\Sigma\\) is a finite _input alphabet_,\n* \\(\\delta\\) is a function from \\(Q\\times\\Sigma\\) into \\(Q\\), called the _transition function_ of \\(M\\).\n\nThe finite automaton begins in state \\(q_{0}\\) and reads the characters of its input string one at a time. If the automaton is in state \\(q\\) and reads input character \\(a\\), it moves (\"makes a transition\") from state \\(q\\) to state \\(\\delta(q,a)\\). Whenever its current state \\(q\\) is a member of \\(A\\), the machine \\(M\\) has _accepted_ the string read so far. An input that is not accepted is _rejected_.\n\nA finite automaton \\(M\\) induces a function \\(\\phi\\), called the _final-state function_, from \\(\\Sigma^{*}\\) to \\(Q\\) such that \\(\\phi(w)\\) is the state \\(M\\) ends up in after reading the string \\(w\\). Thus, \\(M\\) accepts a string \\(w\\) if and only if \\(\\phi(w)\\in A\\). We define the function \\(\\phi\\) recursively, using the transition function:\n\n\\[\\phi(\\varepsilon) = q_{0}\\,\\] \\[\\phi(wa) = \\delta(\\phi(w),a)\\quad\\mbox{for $w\\in\\Sigma^{*},a\\in\\Sigma$}\\.\\]\n\n##### String-matching automata\n\nFor a given pattern \\(P\\), a preprocessing step constructs a string-matching automaton specific to \\(P\\). The automaton then searches the text string for occurrences of \\(P\\). Figure 32.6 illustrates the automaton for the pattern \\(P=\\mathtt{ababaca}\\). From now on, let's assume that \\(P\\) is fixed, and for brevity, we won't bother to indicate the dependence upon \\(P\\) in our notation.\n\nIn order to specify the string-matching automaton corresponding to a given pattern \\(P[1\\!:\\!m]\\), we first define an auxiliary function \\(\\sigma\\), called the _suffix function_ corresponding to the pattern \\(P\\). The function \\(\\sigma\\) maps \\(\\Sigma^{*}\\) to \\(\\{0,1,\\ldots,m\\}\\) such that \\(\\sigma(x)\\) is the length of the longest prefix of \\(P\\) that is also a suffix of \\(x\\):\n\n\\[\\sigma(x)=\\max\\left\\{k\\,:\\,P\\left[\\,:\\!k\\right]\\sqr\n\nFigure 32.5: A simple two-state finite automaton with state set \\(Q=\\{0,1\\}\\), start state \\(q_{0}=0\\), and input alphabet \\(\\Sigma=\\{\\mathtt{a},\\mathtt{b}\\}\\). **(a)** A tabular representation of the transition function \\(\\delta\\). **(b)** An equivalent state-transition diagram. State 1, in orange, is the only accepting state. Directed edges represent transitions. For example, the edge from state 1 to state 0 labeled \\(\\mathtt{b}\\) indicates that \\(\\delta(1,\\mathtt{b})=0\\). This automaton accepts those strings that end in an odd number of \\(\\mathtt{a}\\)\u2019s. More precisely, it accepts a string \\(x\\) if and only if \\(x=yz\\), where \\(y=\\varepsilon\\) or \\(y\\) ends with a \\(\\mathtt{b}\\), and \\(z=\\mathtt{a}^{k}\\), where \\(k\\) is odd. For example, on input \\(\\mathtt{abaaa}\\), including the start state, this automaton enters the sequence of states \\(\\langle 0,1,0,1,0,1\\rangle\\), and so it accepts this input. For input \\(\\mathtt{abbaa},\\) it enters the sequence of states \\(\\langle 0,1,0,0,1,0\\rangle\\), and so it rejects this input.\n\n#### String matching with finite automata\n\nThe suffix function \\(\\sigma\\) is well defined since the empty string \\(P[\\,:\\,0]=\\varepsilon\\) is a suffix of every string. As examples, for the pattern \\(P=\\mathtt{ab}\\), we have \\(\\sigma(\\varepsilon)=0\\), \\(\\sigma(\\mathtt{ccaca})=1\\), and \\(\\sigma(\\mathtt{ccab})=2\\). For a pattern \\(P\\) of length \\(m\\), we have \\(\\sigma(x)=m\\) if and only if \\(P\\,\\sqsupset\\,x\\). From the definition of the suffix function, \\(x\\,\\sqsupset\\,y\\) implies \\(\\sigma(x)\\leq\\sigma(y)\\) (see Exercise 32.3-4).\n\nWe are now ready to define the string-matching automaton that corresponds to a given pattern \\(P[\\,1\\,:\\,m]\\):\n\nFigure 32.6: **(a)** A state-transition diagram for the string-matching automaton that accepts all strings ending in the string \\(\\mathtt{ababaca}\\). State \\(0\\) is the start state, and state \\(7\\) (in orange) is the only accepting state. The transition function \\(\\delta\\) is defined by equation (32.4), and a directed edge from state \\(i\\) to state \\(j\\) labeled \\(a\\) represents \\(\\delta(i,a)=j\\). The right-going edges forming the \u201cspine\u201d of the automaton, shown in blue, correspond to successful matches between pattern and input characters. Except for the edges from state \\(7\\) to states \\(1\\) and \\(2\\), the left-going edges correspond to mismatches. Some edges corresponding to mismatches are omitted: by convention, if a state \\(i\\) has no outgoing edge labeled \\(a\\) for some \\(a\\in\\Sigma\\), then \\(\\delta(i,a)=0\\). **(b)** The corresponding transition function \\(\\delta\\), and the pattern string \\(P=\\mathtt{ababaca}\\). The entries corresponding to successful matches between pattern and input characters are shown in blue. **(c)** The operation of the automaton on the text \\(T=\\mathtt{abababacaba}\\). Under each text character \\(T[i]\\) appears the state \\(\\phi(T[\\,:\\,i])\\) that the automaton is in after processing the prefix \\(T[\\,:\\,i]\\). The substring of the pattern that occurs in the text is highlighted in blue. The automaton finds this one occurrence of the pattern, ending in position \\(9\\).\n\nThe state set \\(Q\\) is \\(\\{0,1,\\ldots,m\\}\\). The start state \\(q_{0}\\) is state \\(0\\), and state \\(m\\) is the only accepting state.\n* The transition function \\(\\delta\\) is defined, for any state \\(q\\) and character \\(a\\), by \\[\\delta(q,a)=\\sigma(P[\\,:\\!q]a)\\.\\] (32.4)\n\nAs the automaton consumes characters of the text \\(T\\), it is trying to build a match of the pattern \\(P\\) against the most recently seen characters of \\(T\\). At any time, the state number \\(q\\) gives the length of the longest prefix of \\(P\\) that matches the most recently seen text characters. Whenever the automaton reaches state \\(m\\), the \\(m\\) most recently seen text characters match the first \\(m\\) characters of \\(P\\). Since \\(P\\) has length \\(m\\), reaching state \\(m\\) means that the \\(m\\) most recently seen text characters match the entire pattern, so that the automaton has found a match.\n\nWith this intuition behind the design of the automaton, here is the reasoning behind defining \\(\\delta(q,a)=\\sigma(P[\\,:\\!q]a)\\). Suppose that the automaton is in state \\(q\\) after reading the first \\(i\\) characters of the text, that is, \\(q=\\phi(T[\\,:\\!i])\\). The intuitive idea then says that \\(q\\) also equals the length of the longest prefix of \\(P\\) that matches a suffix of \\(T[\\,:\\!i]\\) or, equivalently, that \\(q=\\sigma(T[\\,:\\!i])\\). Thus, since \\(\\phi(T[\\,:\\!i])\\) and \\(\\sigma(T[\\,:\\!i])\\) both equal \\(q\\), we will see (in Theorem 32.4 on page 32) that the automaton maintains the following invariant:\n\n\\[\\phi(T[\\,:\\!i])=\\sigma(T[\\,:\\!i]). \\tag{32.5}\\]\n\nIf the automaton is in state \\(q\\) and reads the next character \\(T[i+1]=a\\), then the transition should lead to the state corresponding to the longest prefix of \\(P\\) that is a suffix of \\(T[\\,:\\!i]a\\). That state is \\(\\sigma(T[\\,:\\!i]a)\\), and equation (32.5) gives \\(\\phi(T[\\,:\\!i]a)=\\sigma(T[\\,:\\!i]a)\\). Because \\(P[\\,:\\!q]\\) is the longest prefix of \\(P\\) that is a suffix of \\(T[\\,:\\!i]\\), the longest prefix of \\(P\\) that is a suffix of \\(T[\\,:\\!i]a\\) has length not only \\(\\sigma(T[\\,:\\!i]a)\\), but also \\(\\sigma(P[\\,:\\!q]a)\\), and so \\(\\phi(T[\\,:\\!i]a)=\\sigma(P[\\,:\\!q]a)\\). (Lemma 32.3 on page 32 will prove that \\(\\sigma(T[\\,:\\!i]a)=\\sigma(P[\\,:\\!q]a)\\).) Thus, when the automaton is in state \\(q\\), the transition function \\(\\delta\\) on character \\(a\\) should take the automaton to state \\(\\delta(q,a)=\\delta(\\phi(T[\\,:\\!i]),a)=\\phi(T[\\,:\\!i]a)=\\sigma(P[\\,:\\!q]a)\\) (with the last equality following from equation (32.5)).\n\nThere are two cases to consider, depending on whether the next character continues to match the pattern. In the first case, \\(a=P[q+1]\\), so that the character \\(a\\) continues to match the pattern. In this case, because \\(\\delta(q,a)=q+1\\), the transition continues to go along the \"spine\" of the automaton (the blue edges in Figure 32.6(a)). In the second case, \\(a\\neq P[q+1]\\), so that \\(a\\) does not extend the match being built. In this case, we need to find the longest prefix of \\(P\\) that is also a suffix of \\(T[\\,:\\!i]a\\), which will have length at most \\(q\\). The preprocessing step matches the pattern against itself when creating the string-matching automaton, so that the transition function can quickly identify the longest such smaller prefix of \\(P\\).\n\nLet's look at an example. Consider state 5 in the string-matching automaton of Figure 32.6. In state 5, the five most recently read characters of \\(T\\) are \\(\\mathtt{ababa}\\), the characters along the spine of the automaton that reach state 5. If the next character of \\(T\\) is \\(\\mathbf{c}\\), then the most recently read characters of \\(T\\) are \\(\\mathtt{ababac}\\), which is the prefix of \\(P\\) with length 6. The automaton should continue along the spine to state 6. This is the first case, in which the match continues, and \\(\\delta(5,\\mathbf{c})=6\\). To illustrate the second case, suppose that in state 5, the next character of \\(T\\) is \\(\\mathbf{b}\\), so the most recently read characters of \\(T\\) are \\(\\mathtt{ababab}\\). Here, the longest prefix of \\(P\\) that matches the most recently read characters of \\(T\\)--that is, a suffix of the portion of \\(T\\) read so far--is \\(\\mathtt{abab}\\), with length 4, so \\(\\delta(5,\\mathbf{b})=4\\).\n\nTo clarify the operation of a string-matching automaton, the simple and efficient procedure Finite-Automaton-Matcher simulates the behavior of such an automaton (represented by its transition function \\(\\delta\\)) in finding occurrences of a pattern \\(P\\) of length \\(m\\) in an input text \\(T[1\\!:\\!n]\\). As for any string-matching automaton for a pattern of length \\(m\\), the state set \\(Q\\) is \\(\\{0,1,\\ldots,m\\}\\), the start state is 0, and the only accepting state is state \\(m\\). From the simple loop structure of Finite-Automaton-Matcher, you can see that its matching time on a text string of length \\(n\\) is \\(\\Theta(n)\\), assuming that each lookup of the transition function \\(\\delta\\) takes constant time. This matching time, however, does not include the preprocessing time required to compute the transition function. We address this problem later, after first proving that the procedure Finite-Automaton-Matcher operates correctly.\n\n```\n1\\(q=0\\)\n2for\\(i=1\\)to\\(n\\)\n3\\(q=\\delta(q,T[i])\\)\n4if\\(q==m\\)\n5print \"Pattern occurs with shift\"\\(i-m\\)\n```\n\nLet's examine how the automaton operates on an input text \\(T[1\\!:\\!n]\\). We will prove that the automaton is in state \\(\\sigma(T[\\!:\\!i])\\) after reading character \\(T[i]\\). Since \\(\\sigma(T[\\!:\\!i])=m\\) if and only if \\(P\\sqsupset T[\\!:\\!i]\\), the machine is in the accepting state \\(m\\) if and only if it has just read the pattern \\(P\\). We start with two lemmas about the suffix function \\(\\sigma\\).\n\n**Lemma 32.2** (_Suffix-function inequality_): _For any string \\(x\\) and character \\(a\\), we have \\(\\sigma(xa)\\leq\\sigma(x)+1\\).__Proof_Referring to Figure 32.7, let \\(r=\\sigma(xa)\\). If \\(r=0\\), then the conclusion \\(\\sigma(xa)=r\\leq\\sigma(x)+1\\) is trivially satisfied since \\(\\sigma(x)\\) is nonnegative. Now assume that \\(r>0\\). Then, \\(P[\\,:\\!r]\\sqsupseteq xa\\), by the definition of \\(\\sigma\\). Thus, \\(P[\\,:\\!r-1]\\sqsupseteq x\\), by dropping the \\(a\\) from both the end of \\(P[\\,:\\!r]\\) and the end of \\(xa\\). Therefore, \\(r-1\\leq\\sigma(x)\\), since \\(\\sigma(x)\\) is the largest \\(k\\) such that \\(P[\\,:\\!k]\\sqsupseteq x\\), and thus \\(\\sigma(xa)=r\\leq\\sigma(x)+1\\).\n\n**Lemma 32.3** (_Suffix-function recursion lemma_): _For any string \\(x\\) and character \\(a\\), if \\(q=\\sigma(x)\\), then \\(\\sigma(xa)=\\sigma(P[\\,:\\!q]a)\\)._\n\n_Proof_The definition of \\(\\sigma\\) gives that \\(P[\\,:\\!q]\\sqsupseteq x\\). As Figure 32.8 shows, we also have \\(P[\\,:\\!q]a\\sqsupseteq xa\\). Let \\(r=\\sigma(xa)\\). Then \\(P[\\,:\\!r]\\sqsupseteq xa\\) and, by Lemma 32.2, \\(r\\leq q+1\\). Thus, we have \\(|P[\\,:\\!r]|=r\\leq q+1=|P[\\,:\\!q]a|\\). Since \\(P[\\,:\\!q]a\\sqsupseteq xa\\), \\(P[\\,:\\!r]\\sqsupseteq xa\\), and \\(|P[\\,:\\!r]|\\leq|P[\\,:\\!q]a|\\), Lemma 32.1 on page 959 implies that \\(P[\\,:\\!r]\\sqsupseteq P[\\,:\\!q]a\\). Therefore, \\(r\\leq\\sigma(P[\\,:\\!q]a)\\), that is, \\(\\sigma(xa)\\leq\\sigma(P[\\,:\\!q]a)\\). But we also have \\(\\sigma(P[\\,:\\!q]a)\\leq\\sigma(xa)\\), since \\(P[\\,:\\!q]a\\sqsupseteq xa\\). Thus, \\(\\sigma(xa)=\\sigma(P[\\,:\\!q]a)\\).\n\nFigure 32.7: An illustration for the proof of Lemma 32.2. The figure shows that \\(r\\leq\\sigma(x)+1\\), where \\(r=\\sigma(xa)\\).\n\nFigure 32.8: An illustration for the proof of Lemma 32.3. The figure shows that \\(r=\\sigma(P[\\,:\\!q]a)\\), where \\(q=\\sigma(x)\\) and \\(r=\\sigma(xa)\\).\n\nWe are now ready to prove the main theorem characterizing the behavior of a string-matching automaton on a given input text. As noted above, this theorem shows that the automaton is merely keeping track, at each step, of the longest prefix of the pattern that is a suffix of what has been read so far. In other words, the automaton maintains the invariant (32.5).\n\n**Theorem 32.4**: If \\(\\phi\\) is the final-state function of a string-matching automaton for a given pattern \\(P\\) and \\(T[\\,1\\,:\\,n]\\) is an input text for the automaton, then\n\n\\[\\phi(T[\\,:\\,i\\,])=\\sigma(T[\\,:\\,i\\,])\\]\n\nfor \\(i\\,=\\,0,1,\\ldots,n\\).\n\n_Proof_ The proof is by induction on \\(i\\). For \\(i\\,=\\,0\\), the theorem is trivially true, since \\(T[\\,:\\,0]=\\varepsilon\\). Thus, \\(\\phi(T[\\,:\\,0])=0=\\sigma(T[\\,:\\,0])\\).\n\nNow assume that \\(\\phi(T[\\,:\\,i\\,])=\\sigma(T[\\,:\\,i\\,])\\). We will prove that \\(\\phi(T[\\,:\\,i\\,+\\,1])=\\sigma(T[\\,:\\,i\\,+\\,1])\\). Let \\(q\\) denote \\(\\phi(T[\\,:\\,i])\\), so that \\(q=\\sigma(T[\\,:\\,i\\,])\\), and let \\(a\\) denote \\(T[i\\,+\\,1]\\). Then,\n\n\\[\\phi(T[\\,:\\,i\\,+\\,1]) = \\phi(T[\\,:\\,i]a)\\] (by the definitions of \\[T[\\,:\\,i\\,+\\,1]\\) and \\[a\\] ) \\[= \\delta(\\phi(T[\\,:\\,i]),a)\\] (by the definition of \\[\\phi\\] ) \\[= \\delta(q,a)\\] (by the definition of \\[q\\] ) \\[= \\sigma(P[\\,:\\,q]a)\\] (by the definition (32.4) of \\[\\delta\\] ) \\[= \\sigma(T[\\,:\\,i]a)\\] (by Lemma 32.3) \\[= \\sigma(T[\\,:\\,i\\,+\\,1])\\] (by the definition of \\[T[\\,:\\,i\\,+\\,1]\\)).\n\nBy Theorem 32.4, if the machine enters state \\(q\\) on line 3, then \\(q\\) is the largest value such that \\(P[\\,:\\,q]\\sqsupset T[\\,:\\,i\\,]\\). Thus, in line 4, \\(q=m\\) if and only if the machine has just read an occurrence of the pattern \\(P\\). Therefore, Finite-Automaton-Matcher operates correctly.\n\n### Computing the transition function\n\nThe procedure Compute-Transition-Function on the following page computes the transition function \\(\\delta\\) from a given pattern \\(P[1\\,:\\,m]\\). It computes \\(\\delta(q,a)\\) in a straightforward manner according to its definition in equation (32.4). The nested loops beginning on lines 1 and 2 consider all states \\(q\\) and all characters \\(a\\), and lines 3-6 set \\(\\delta(q,a)\\) to be the largest \\(k\\) such that \\(P[\\,:\\,k\\,]\\sqsupset P[\\,:\\,q]a\\). The code starts with the largest conceivable value of \\(k\\), which is \\(q+1\\), unless \\(q\\,=\\,m\\), in which case \\(k\\) cannot be larger than \\(m\\). It then decreases \\(k\\) until \\(P[\\,:\\,k]\\) is a suffix of \\(P[\\,:\\,q]a\\), which must eventually occur, since \\(P[\\,:\\,0]=\\varepsilon\\) is a suffix of every string.\n\nThe running time of Compute-Transition-Function is \\(O(m^{3}\\,|\\,\\Sigma|)\\), because the outer loops contribute a factor of \\(m\\,|\\,\\Sigma|\\), the inner **while** loop can run at most \\(m+1\\) times, and the test for whether \\(P\\,[\\,:\\,k]\\) is a suffix of \\(P\\,[\\,:\\,q]a\\) on line 4 can require comparing up to \\(m\\) characters. Much faster procedures exist. By utilizing some cleverly computed information about the pattern \\(P\\) (see Exercise 32.4-8), the time required to compute \\(\\delta\\) from \\(P\\) improves to \\(O(m\\,|\\,\\Sigma|)\\). This improved procedure for computing \\(\\delta\\) provides a way to find all occurrences of a length-\\(m\\) pattern in a length-\\(n\\) text over an alphabet \\(\\Sigma\\) with \\(O(m\\,|\\,\\Sigma|)\\) preprocessing time and \\(\\Theta(n)\\) matching time.\n\n### Exercises\n\n#### 32.3-1\n\nDraw a state-transition diagram for the string-matching automaton for the pattern \\(P\\,=\\,\\mathtt{aabab}\\) over the alphabet \\(\\Sigma=\\{\\mathtt{a},\\mathtt{b}\\}\\) and illustrate its operation on the text string \\(T=\\mathtt{aaababaabaababa* _32.3-5_ Given two patterns \\(P\\) and \\(P^{\\prime}\\), describe how to construct a finite automaton that determines all occurrences of _either_ pattern. Try to minimize the number of states in your automaton. _32.3-6_ Given a pattern \\(P\\) containing gap characters (see Exercise 32.1-4), show how to build a finite automaton that can find an occurrence of \\(P\\) in a text \\(T\\) in \\(O(n)\\) matching time, where \\(n=|T|\\).\n\n## 32.4 The Knuth-Morris-Pratt algorithm\n\nKnuth, Morris, and Pratt developed a linear-time string matching algorithm that avoids computing the transition function \\(\\delta\\) altogether. Instead, the KMP algorithm uses an auxiliary function \\(\\pi\\), which it precomputes from the pattern in \\(\\Theta(m)\\) time and stores in an array \\(\\pi[1\\!:\\!m]\\). The array \\(\\pi\\) allows the algorithm to compute the transition function \\(\\delta\\) efficiently (in an amortized sense) \"on the fly\" as needed. Loosely speaking, for any state \\(q=0,1,\\ldots,m\\) and any character \\(a\\in\\Sigma\\), the value \\(\\pi[q]\\) contains the information needed to compute \\(\\delta(q,a)\\) but that does not depend on \\(a\\). Since the array \\(\\pi\\) has only \\(m\\) entries, whereas \\(\\delta\\) has \\(\\Theta(m\\,|\\Sigma|)\\) entries, the KMP algorithm saves a factor of \\(|\\Sigma|\\) in the preprocessing time by computing \\(\\pi\\) rather than \\(\\delta\\). Like the procedure Finite-Automaton-Matcher, once preprocessing has completed, the KMP algorithm uses \\(\\Theta(n)\\) matching time.\n\n### The prefix function for a pattern\n\nThe prefix function \\(\\pi\\) for a pattern encapsulates knowledge about how the pattern matches against shifts of itself. The KMP algorithm takes advantage of this information to avoid testing useless shifts in the naive pattern-matching algorithm and to avoid precomputing the full transition function \\(\\delta\\) for a string-matching automaton.\n\nConsider the operation of the naive string matcher. Figure 32.9(a) shows a particular shift \\(s\\) of a template containing the pattern \\(P=\\mathtt{ababaca}\\mathtt{a}\\) against a text \\(T\\). For this example, \\(q=5\\) of the characters have matched successfully, but the 6th pattern character fails to match the corresponding text character. The information that \\(q\\) characters have matched successfully determines the corresponding text characters. Because these \\(q\\) text characters match, certain shifts must be invalid. In the example of the figure, the shift \\(s+1\\) is necessarily invalid, since the first pattern character (a) would be aligned with a text character that does not match the first pattern character, but does match the second pattern character (b). The shift",
        "chapter": "Part VII Selected Topics",
        "section": "32 String Matching",
        "subsection": "32.3 String matching with finite automata",
        "subsubsection": "N/A"
    },
    {
        "content": "* _32.3-5_ Given two patterns \\(P\\) and \\(P^{\\prime}\\), describe how to construct a finite automaton that determines all occurrences of _either_ pattern. Try to minimize the number of states in your automaton. _32.3-6_ Given a pattern \\(P\\) containing gap characters (see Exercise 32.1-4), show how to build a finite automaton that can find an occurrence of \\(P\\) in a text \\(T\\) in \\(O(n)\\) matching time, where \\(n=|T|\\).\n\n## 32.4 The Knuth-Morris-Pratt algorithm\n\nKnuth, Morris, and Pratt developed a linear-time string matching algorithm that avoids computing the transition function \\(\\delta\\) altogether. Instead, the KMP algorithm uses an auxiliary function \\(\\pi\\), which it precomputes from the pattern in \\(\\Theta(m)\\) time and stores in an array \\(\\pi[1\\!:\\!m]\\). The array \\(\\pi\\) allows the algorithm to compute the transition function \\(\\delta\\) efficiently (in an amortized sense) \"on the fly\" as needed. Loosely speaking, for any state \\(q=0,1,\\ldots,m\\) and any character \\(a\\in\\Sigma\\), the value \\(\\pi[q]\\) contains the information needed to compute \\(\\delta(q,a)\\) but that does not depend on \\(a\\). Since the array \\(\\pi\\) has only \\(m\\) entries, whereas \\(\\delta\\) has \\(\\Theta(m\\,|\\Sigma|)\\) entries, the KMP algorithm saves a factor of \\(|\\Sigma|\\) in the preprocessing time by computing \\(\\pi\\) rather than \\(\\delta\\). Like the procedure Finite-Automaton-Matcher, once preprocessing has completed, the KMP algorithm uses \\(\\Theta(n)\\) matching time.\n\n### The prefix function for a pattern\n\nThe prefix function \\(\\pi\\) for a pattern encapsulates knowledge about how the pattern matches against shifts of itself. The KMP algorithm takes advantage of this information to avoid testing useless shifts in the naive pattern-matching algorithm and to avoid precomputing the full transition function \\(\\delta\\) for a string-matching automaton.\n\nConsider the operation of the naive string matcher. Figure 32.9(a) shows a particular shift \\(s\\) of a template containing the pattern \\(P=\\mathtt{ababaca}\\mathtt{a}\\) against a text \\(T\\). For this example, \\(q=5\\) of the characters have matched successfully, but the 6th pattern character fails to match the corresponding text character. The information that \\(q\\) characters have matched successfully determines the corresponding text characters. Because these \\(q\\) text characters match, certain shifts must be invalid. In the example of the figure, the shift \\(s+1\\) is necessarily invalid, since the first pattern character (a) would be aligned with a text character that does not match the first pattern character, but does match the second pattern character (b). The shift \\(s^{\\prime}=s+2\\) shown in part (b) of the figure, however, aligns the first three pattern characters with three text characters that necessarily match.\n\nMore generally, suppose that you know that \\(P[\\,:\\,q]\\sqsupset T[\\,:\\,s+q]\\) or, equivalently, that \\(P[1\\,:\\,q]=T[s+1\\,:\\,s+q]\\). You want to shift \\(P\\) so that some shorter prefix \\(P[\\,:\\,k]\\) of \\(P\\) matches a suffix of \\(T[\\,:\\,s+q]\\), if possible. You might have more than one choice for how much to shift, however. In Figure 32.9(b), shifting \\(P\\) by 2 positions works, so that \\(P[\\,:\\,3]\\sqsupset T[\\,:\\,s+q]\\), but so does shifting \\(P\\) by 4 positions, so that \\(P[\\,:\\,1]\\sqsupset T[\\,:\\,s+q]\\) in Figure 32.9(c). If more than one shift amount works, you should choose the smallest shift amount so that you do not miss any potential matches. Put more precisely, you want to answer this question:\n\nGiven that pattern characters \\(P[1\\,:\\,q]\\) match text characters \\(T[s+1\\,:\\,s+q]\\) (that is, \\(P[\\,:\\,q]\\sqsupset T[\\,:\\,s+q]\\)), what is the least shift \\(s^{\\prime}>s\\) such that for some \\(k<q\\),\n\n\\[P[1\\,:\\,k]=T[s^{\\prime}+1\\,:\\,s^{\\prime}+k]\\, \\tag{32.6}\\]\n\n(that is, \\(P[\\,:\\,k]\\sqsupset T[\\,:\\,s^{\\prime}+k]\\)), where \\(s^{\\prime}+k=s+q\\)?\n\nHere's another way to look at this question. If you know \\(P[\\,:\\,q]\\sqsupset T[\\,:\\,s+q]\\), then how do you find the longest proper prefix \\(P[\\,:\\,k]\\) of \\(P[\\,:\\,q]\\) that is also a suffix of \\(T[\\,:\\,s+q]\\)? These questions are equivalent because given \\(s\\) and \\(q\\), requiring \\(s^{\\prime}+k=s+q\\) means that finding the smallest shift \\(s^{\\prime}\\) (2 in Figure 32.9(b)) is tantamount to finding the longest prefix length \\(k\\) (3 in Figure 32.9(b)). If you add the difference \\(q-k\\) in the lengths of these prefixes of \\(P\\) to the shift \\(s\\), you get the new shift \\(s^{\\prime}\\), so that \\(s^{\\prime}=s+(q-k)\\). In the best case, \\(k=0\\), so that \\(s^{\\prime}=s+q\\), immediately ruling out shifts \\(s+1,s+2,\\ldots,s+q-1\\). In any case, at the new shift \\(s^{\\prime}\\), it is redundant to compare the first \\(k\\) characters of \\(P\\) with the corresponding characters of \\(T\\), since equation (32.6) guarantees that they match.\n\nAs Figure 32.9(d) demonstrates, you can precompute the necessary information by comparing the pattern against itself. Since \\(T[s^{\\prime}+1\\,:\\,s^{\\prime}+k]\\) is part of the matched portion of the text, it is a suffix of the string \\(P[\\,:\\,q]\\). Therefore, think of equation (32.6) as asking for the greatest \\(k<q\\) such that \\(P[\\,:\\,k]\\sqsupset P[\\,:\\,q]\\). Then, the new shift \\(s^{\\prime}=s+(q-k)\\) is the next potentially valid shift. It will be convenient to store, for each value of \\(q\\), the number \\(k\\) of matching characters at the new shift \\(s^{\\prime}\\), rather than storing, say, the amount \\(s^{\\prime}-s\\) to shift by.\n\nLet's look at the precomputed information a little more formally. For a given pattern \\(P[1\\,:\\,m]\\), the _prefix function_ for \\(P\\) is the function \\(\\pi:\\{1,2,\\ldots,m\\}\\to\\{0,1,\\ldots,m-1\\}\\) such that\n\n\\[\\pi[q]=\\max\\,\\{k:k<q\\ \\mbox{and}\\ P[\\,:\\,k]\\sqsupset P[\\,:\\,q]\\}\\enspace.\\]\n\nThat is, \\(\\pi[q]\\) is the length of the longest prefix of \\(P\\) that is a proper suffix of \\(P[\\,:\\,q]\\). Here is the complete prefix function \\(\\pi\\) for the pattern ababaca:\n\n### The Knuth-Morris-Pratt algorithm\n\nThe procedure KMP-Matcher on the following page gives the Knuth-Morris-Pratt matching algorithm. The procedure follows from Finite-Automaton-Matcher for the most part. To compute \\(\\pi\\), KMP-Matcher calls the auxiliary procedure Compute-Prefix-Function. These two procedures have much in common, because both match a string against the pattern \\(P\\): KMP-Matcher matches the text \\(T\\) against \\(P\\), and Compute-Prefix-Function matches \\(P\\) against itself.\n\nNext, let's analyze the running times of these procedures. Then we'll prove them correct, which will be more complicated.\n\n##### Running-time analysis\n\nThe running time of Compute-Prefix-Function is \\(\\Theta(m)\\), which we show by using the aggregate method of amortized analysis (see Section 16.1). The only tricky part is showing that the **while** loop of lines 5-6 executes \\(O(m)\\) times alto\n\nFigure 32: The prefix function \\(\\pi\\). **(a)** The pattern \\(P=\\mathtt{ababaca}\\) aligns with a text \\(T\\) so that the first \\(q=5\\) characters match. Matching characters, in blue, are connected by blue lines. **(b)** Knowing these particular 5 matched characters (\\(P[\\,:\\,5]\\)) suffices to deduce that a shift of \\(s+1\\) is invalid, but that a shift of \\(s^{\\prime}=s+2\\) is consistent with everything known about the text and therefore is potentially valid. The prefix \\(P[\\,:\\,k]\\), where \\(k=3\\), aligns with the text seen so far. **(c)** A shift of \\(s+4\\) is also potentially valid, but it leaves only the prefix \\(P[\\,:\\,1]\\) aligned with the text seen so far. **(d)** To precompute useful information for such deductions, compare the pattern with itself. Here, the longest prefix of \\(P\\) that is also a proper suffix of \\(P[\\,:\\,5]\\) is \\(P[\\,:\\,3]\\). The array \\(\\pi\\) represents this precomputed information, so that \\(\\pi[5]=3\\). Given that \\(q\\) characters have matched successfully at shift \\(s\\), the next potentially valid shift is at \\(s^{\\prime}=s+(q-\\pi[q])\\) as shown in part (b).\n\ngether. Starting with some observations about \\(k\\), we'll show that it makes at most \\(m-1\\) iterations. First, line 3 starts \\(k\\) at \\(0\\), and the only way that \\(k\\) increases is by the increment operation in line 8, which executes at most once per iteration of the **for** loop of lines 4-9. Thus, the total increase in \\(k\\) is at most \\(m-1\\). Second, since \\(k\\,<q\\) upon entering the **for** loop and each iteration of the loop increments \\(q\\), we always have \\(k\\,<q\\). Therefore, the assignments in lines 2 and 9 ensure that \\(\\pi[q]<q\\) for all \\(q=1,2,\\ldots,m\\), which means that each iteration of the **while** loop decreases \\(k\\). Third, \\(k\\) never becomes negative. Putting these facts together, we see that the total decrease in \\(k\\) from the **while** loop is bounded from above by the total increase in \\(k\\) over all iterations of the **for** loop, which is \\(m-1\\). Thus, the **while** loop iterates at most \\(m-1\\) times in all, and Compute-Prefix-Function runs in \\(\\Theta(m)\\) time.\n\nExercise 32.4-4 asks you to show, by a similar aggregate analysis, that the matching time of KMP-Matcher is \\(\\Theta(n)\\).\n\n#### 32.4 The Knuth-Morris-Pratt algorithm\n\nCompared with Finite-Automaton-Matcher, by using \\(\\pi\\) rather than \\(\\delta\\), the KMP algorithm reduces the time for preprocessing the pattern from \\(O(m\\,|\\Sigma|)\\) to \\(\\Theta(m)\\), while keeping the actual matching time bounded by \\(\\Theta(n)\\).\n\n##### Correctness of the prefix-function computation\n\nWe'll see a little later that the prefix function \\(\\pi\\) helps to simulate the transition function \\(\\delta\\) in a string-matching automaton. But first, we need to prove that the procedure Compute-Prefix-Function does indeed compute the prefix function correctly. Doing so requires finding all prefixes \\(P[\\,:\\,k]\\) that are proper suffixes of a given prefix \\(P[\\,:\\,q]\\). The value of \\(\\pi[q]\\) gives us the length of the longest such prefix, but the following lemma, illustrated in Figure 32.10, shows that iterating the prefix function \\(\\pi\\) generates all the prefixes \\(P[\\,:\\,k]\\) that are proper suffixes of \\(P[\\,:\\,q]\\). Let\n\n\\[\\pi^{*}[q]=\\left\\{\\pi[q],\\pi^{(2)}[q],\\pi^{(3)}[q],\\ldots,\\pi^{(t)}[q]\\right\\}\\enspace,\\]\n\nwhere \\(\\pi^{(i)}[q]\\) is defined in terms of functional iteration, so that \\(\\pi^{(0)}[q]=q\\) and \\(\\pi^{(i)}[q]=\\pi[\\pi^{(i-1)}[q]]\\) for \\(i\\geq 1\\) (so that \\(\\pi[q]=\\pi^{(1)}[q]\\)), and where the sequence in \\(\\pi^{*}[q]\\) stops upon reaching \\(\\pi^{(t)}[q]=0\\) for some \\(t\\geq 1\\).\n\nFigure 32.10: An illustration of Lemma 32.5 for the pattern \\(P=\\mathtt{ababaca}\\) and \\(q=5\\). **(a)** The \\(\\pi\\) function for the given pattern. Since \\(\\pi[5]=3\\), \\(\\pi[3]=1\\), and \\(\\pi[1]=0\\), iterating \\(\\pi\\) gives \\(\\pi^{*}[5]=\\{3,1,0\\}\\). **(b)** Sliding the template containing the pattern \\(P\\) to the right and noting when some prefix \\(P[\\,:\\,k]\\) of \\(P\\) matches up with some proper suffix of \\(P[\\,:\\,5]\\). Matches occur when \\(k=3\\), \\(1\\), and \\(0\\). In the figure, the first row gives \\(P\\), and the vertical red line is drawn just after \\(P[\\,:\\,5]\\). Successive rows show all the shifts of \\(P\\) that cause some prefix \\(P[\\,:\\,k]\\) of \\(P\\) to match some suffix of \\(P[\\,:\\,5]\\). Successfully matched characters are shown in blue. Blue lines connect aligned matching characters. Thus, \\(\\{k:k<5\\text{ and }P[\\,:\\,k]\\sqsupset P[\\,:\\,5]\\}=\\{3,1,0\\}\\). Lemma 32.5 claims that \\(\\pi^{*}[q]=\\{k:k<q\\text{ and }P[\\,:\\,k]\\sqsupset P[\\,:\\,q]\\}\\) for all \\(q\\).\n\n**Lemma 32.5** (Prefix-function iteration lemma): _Let \\(P\\) be a pattern of length \\(m\\) with prefix function \\(\\pi\\). Then, for \\(q=1,2,\\ldots,m\\), we have \\(\\pi^{*}[q]=\\{k:k<q\\) and \\(P\\,[\\,\\cdot\\,k]\\sqsupset P\\,[\\,\\cdot\\,q]\\}\\)._\n\n_Proof_ We first prove that \\(\\pi^{*}[q]\\subseteq\\{k:k<q\\) and \\(P\\,[\\,\\cdot\\,k]\\sqsupset P\\,[\\,\\cdot\\,q]\\}\\) or, equivalently,\n\n\\[i\\,\\in\\pi^{*}[q]\\mbox{ implies }P\\,[\\,\\cdot\\,i]\\sqsupset P\\,[\\,\\cdot\\,q]\\;. \\tag{32.7}\\]\n\nIf \\(i\\,\\in\\pi^{*}[q]\\), then \\(i\\,=\\,\\pi^{(u)}[q]\\) for some \\(u>0\\). We prove equation (32.7) by induction on \\(u\\). For \\(u=1\\), we have \\(i\\,=\\,\\pi[q]\\), and the claim follows since \\(i<q\\) and \\(P\\,[\\,\\cdot\\,\\pi[q]]\\sqsupset P\\,[\\,\\cdot\\,q]\\) by the definition of \\(\\pi\\). Now consider some \\(u\\geq 1\\) such that both \\(\\pi^{(u)}[q]\\) and \\(\\pi^{(u+1)}[q]\\) belong to \\(\\pi^{*}[q]\\). Let \\(i\\,=\\,\\pi^{(u)}[q]\\), so that \\(\\pi[i]\\,=\\,\\pi^{(u+1)}[q]\\). The inductive hypothesis is that \\(P\\,[\\,\\cdot\\,i]\\sqsupset P\\,[\\,\\cdot\\,q]\\). Because the relations \\(<\\) and \\(\\sqsupset\\) are transitive, we have \\(\\pi[i]<i<q\\) and \\(P\\,[\\,\\cdot\\,\\pi[i]]\\sqsupset P\\,[\\,\\cdot\\,q]\\), which establishes equation (32.7) for all \\(i\\) in \\(\\pi^{*}[q]\\). Therefore, \\(\\pi^{*}[q]\\subseteq\\{k:k<q\\) and \\(P\\,[\\,\\cdot\\,k]\\sqsupset P\\,[\\,\\cdot\\,q]\\}\\).\n\nWe now prove that \\(\\{k:k<q\\) and \\(P\\,[\\,\\cdot\\,k]\\sqsupset P\\,[\\,\\cdot\\,q]\\}\\subseteq\\pi^{*}[q]\\) by contradiction. Suppose to the contrary that the set \\(\\{k:k<q\\) and \\(P\\,[\\,\\cdot\\,k]\\sqsupset P\\,[\\,\\cdot\\,q]\\}-\\pi^{*}[q]\\) is nonempty, and let \\(j\\) be the largest number in the set. Because \\(\\pi[q]\\) is the largest value in \\(\\{k:k<q\\) and \\(P\\,[\\,\\cdot\\,k]\\sqsupset P\\,[\\,\\cdot\\,q]\\}\\) and \\(\\pi[q]\\in\\pi^{*}[q]\\), it must be the case that \\(j<\\pi[q]\\). Having established that \\(\\pi^{*}[q]\\) contains at least one integer greater than \\(j\\), let \\(j^{\\prime}\\) denote the smallest such integer. (We can choose \\(j^{\\prime}=\\pi[q]\\) if no other number in \\(\\pi^{*}[q]\\) is greater than \\(j\\).) We have \\(P\\,[\\,\\cdot\\,j]\\sqsupset P\\,[\\,\\cdot\\,q]\\) because \\(j\\,\\in\\{k:k<q\\) and \\(P\\,[\\,\\cdot\\,k]\\sqsupset P\\,[\\,\\cdot\\,q]\\}\\), and from \\(j^{\\prime}\\in\\pi^{*}[q]\\) and equation (32.7), we have \\(P\\,[\\,\\cdot\\,j^{\\prime}]\\sqsupset P\\,[\\,\\cdot\\,q]\\). Thus, \\(P\\,[\\,\\cdot\\,j]\\sqsupset P\\,[\\,\\cdot\\,j^{\\prime}]\\) by Lemma 32.1, and \\(j\\) is the largest value less than \\(j^{\\prime}\\) with this property. Therefore, we must have \\(\\pi[j^{\\prime}]=j\\) and, since \\(j^{\\prime}\\in\\pi^{*}[q]\\), we must have \\(j\\,\\in\\pi^{*}[q]\\) as well. This contradiction proves the lemma.\n\nThe algorithm Compute-Prefix-Function computes \\(\\pi[q]\\), in order, for \\(q=1,2,\\ldots,m\\). Setting \\(\\pi[1]\\) to \\(0\\) in line 2 of Compute-Prefix-Function is certainly correct, since \\(\\pi[q]<q\\) for all \\(q\\). We'll use the following lemma and its corollary to prove that Compute-Prefix-Function computes \\(\\pi[q]\\) correctly for \\(q>1\\).\n\n**Lemma 32.6**: _Let \\(P\\) be a pattern of length \\(m\\), and let \\(\\pi\\) be the prefix function for \\(P\\). For \\(q=1,2,\\ldots,m\\), if \\(\\pi[q]>0\\), then \\(\\pi[q]-1\\in\\pi^{*}[q-1]\\)._\n\n_Proof_ Let \\(r\\,=\\,\\pi[q]>0\\), so that \\(r\\,<\\,q\\) and \\(P\\,[\\,\\cdot\\,r]\\sqsupset P\\,[\\,\\cdot\\,q]\\), and thus, \\(r-1<q-1\\) and \\(P\\,[\\,\\cdot\\,r-1]\\sqsupset P\\,[\\,\\cdot\\,q-1]\\) (by dropping the last character from\\(P\\left[\\,:\\,r\\right]\\) and \\(P\\left[\\,:\\,q\\right]\\), which we can do because \\(r>0\\)). By Lemma 32.5, therefore, \\(r-1\\in\\pi^{*}[q-1]\\). Thus, we have \\(\\pi[q]-1=r-1\\in\\pi^{*}[q-1]\\).\n\nFor \\(q=2,3,\\ldots,m\\), define the subset \\(E_{q-1}\\subseteq\\pi^{*}[q-1]\\) by\n\n\\[E_{q-1} = \\{k\\in\\pi^{*}[q-1]:P\\left[k+1\\right]=P\\left[q\\right]\\}\\] \\[= \\{k:k<q-1\\mbox{ and }P\\left[\\,:\\,k\\right]\\sqsupset P\\left[\\,:\\,q-1 \\right]\\mbox{ and }P\\left[k+1\\right]=P\\left[q\\right]\\}\\] \\[\\mbox{ (by Lemma \\ref{lem:P})}\\] \\[= \\{k:k<q-1\\mbox{ and }P\\left[\\,:\\,k+1\\right]\\sqsupset P\\left[\\,:\\,q \\right]\\}\\;.\\]\n\nThe set \\(E_{q-1}\\) consists of the values \\(k<q-1\\) for which \\(P\\left[\\,:\\,k\\right]\\sqsupset P\\left[\\,:\\,q-1\\right]\\) and for which, because \\(P\\left[k+1\\right]=P\\left[q\\right]\\), we have \\(P\\left[\\,:\\,k+1\\right]\\sqsupset P\\left[\\,:\\,q\\right]\\). Thus, \\(E_{q-1}\\) consists of those values \\(k\\in\\pi^{*}[q-1]\\) such that extending \\(P\\left[\\,:\\,k\\right]\\) to \\(P\\left[\\,:\\,k+1\\right]\\) produces a proper suffix of \\(P\\left[\\,:\\,q\\right]\\).\n\n**Corollary 32.7**: _Let \\(P\\) be a pattern of length \\(m\\), and let \\(\\pi\\) be the prefix function for \\(P\\). Then, for \\(q=2,3,\\ldots,m\\),_\n\n\\[\\pi[q]=\\cases{0&if $E_{q-1}=\\emptyset$,\\cr 1+\\max $E_{q-1}$}&if $E_{q-1}\\neq\\emptyset$.\\cr}\\]\n\n_Proof_ If \\(E_{q-1}\\) is empty, there is no \\(k\\in\\pi^{*}[q-1]\\) (including \\(k=0\\)) such that extending \\(P\\left[\\,:\\,k\\right]\\) to \\(P\\left[\\,:\\,k+1\\right]\\) produces a proper suffix of \\(P\\left[\\,:\\,q\\right]\\). Therefore, \\(\\pi[q]=0\\).\n\nIf, instead, \\(E_{q-1}\\) is nonempty, then for each \\(k\\in E_{q-1}\\), we have \\(k+1<q\\) and \\(P\\left[\\,:\\,k+1\\right]\\sqsupset P\\left[\\,:\\,q\\right]\\). Therefore, the definition of \\(\\pi[q]\\) gives\n\n\\[\\pi[q]\\geq 1+\\max E_{q-1}\\;. \\tag{32.8}\\]\n\nNote that \\(\\pi[q]>0\\). Let \\(r=\\pi[q]-1\\), so that \\(r+1=\\pi[q]>0\\), and therefore \\(P\\left[\\,:\\,r+1\\right]\\sqsupset P\\left[\\,:\\,q\\right]\\). If a nonempty string is a suffix of another, then the two strings must have the same last character. Since \\(r+1>0\\), the prefix \\(P\\left[\\,:\\,r+1\\right]\\) is nonempty, and so \\(P\\left[r+1\\right]=P\\left[q\\right]\\). Furthermore, \\(r\\in\\pi^{*}[q-1]\\) by Lemma 32.6. Therefore, \\(r\\in E_{q-1}\\), and so \\(\\pi[q]-1=r\\leq\\max E_{q-1}\\) or, equivalently,\n\n\\[\\pi[q]\\leq 1+\\max E_{q-1}\\;. \\tag{32.9}\\]\n\nCombining equations (32.8) and (32.9) completes the proof.\n\nWe now finish the proof that Compute-Prefix-Function computes \\(\\pi\\) correctly. The key is to combine the definition of \\(E_{q-1}\\) with the statement of Corollary 32.7, so that \\(\\pi[q]\\) equals 1 plus the greatest value of \\(k\\) in \\(\\pi^{*}[q-1]\\) such that \\(P\\left[k+1\\right]=P\\left[q\\right]\\). First, in Compute-Prefix-Function, \\(k=\\pi\\left[q-1\\right]\\) at the start of each iteration of the **for** loop of lines 4-9. This condition is enforced by lines 2 and 3 when the loop is first entered, and it remains true in each successive iteration because of line 9. Lines 5-8 adjust \\(k\\) so that it becomes the correct value of \\(\\pi\\left[q\\right]\\). The **while** loop of lines 5-6 searches through all values \\(k\\in\\pi^{*}\\left[q-1\\right]\\) in decreasing order to find the value of \\(\\pi\\left[q\\right]\\). The loop terminates either because \\(k\\) reaches 0 or \\(P\\left[k+1\\right]=P\\left[q\\right]\\). Because the \"and\" operator short-circuits, if the loop terminates because \\(P\\left[k+1\\right]=P\\left[q\\right]\\), then \\(k\\) must have also been positive, and so \\(k\\) is the greatest value in \\(E_{q-1}\\). In this case, lines 7-9 set \\(\\pi\\left[q\\right]\\) to \\(k+1\\), according to Corollary 32.7. If, instead, the **while** loop terminates because \\(k=0\\), then there are two possibilities. If \\(P\\left[1\\right]=P\\left[q\\right]\\), then \\(E_{q-1}=\\left\\{0\\right\\}\\), and lines 7-9 set both \\(k\\) and \\(\\pi\\left[q\\right]\\) to 1. If \\(k=0\\) and \\(P\\left[1\\right]\\neq P\\left[q\\right]\\), however, then \\(E_{q-1}=\\emptyset\\). In this case, line 9 sets \\(\\pi\\left[q\\right]\\) to 0, again according to Corollary 32.7, which completes the proof of the correctness of Compute-Prefix-Function.\n\n### Correctness of the Knuth-Morris-Pratt algorithm\n\nYou can think of the procedure KMP-Matcher as a reimplemented version of the procedure Finite-Automaton-Matcher, but using the prefix function \\(\\pi\\) to compute state transitions. Specifically, we'll prove that in the \\(i\\)th iteration of the **for** loops of both KMP-Matcher and Finite-Automaton-Matcher, the state \\(q\\) has the same value upon testing for equality with \\(m\\) (at line 8 in KMP-Matcher and at line 4 in Finite-Automaton-Matcher). Once we have argued that KMP-Matcher simulates the behavior of Finite-Automaton-Matcher, the correctness of KMP-Matcher follows from the correctness of Finite-Automaton-Matcher (though we'll see a little later why line 10 in KMP-Matcher is necessary).\n\nBefore formally proving that KMP-Matcher correctly simulates Finite-Automaton-Matcher, let's take a moment to understand how the prefix function \\(\\pi\\) replaces the \\(\\delta\\) transition function. Recall that when a string-matching automaton is in state \\(q\\) and it scans a character \\(a=T\\left[i\\right]\\), it moves to a new state \\(\\delta(q,a)\\). If \\(a=P\\left[q+1\\right]\\), so that \\(a\\) continues to match the pattern, then the state number is incremented: \\(\\delta(q,a)=q+1\\). Otherwise, \\(a\\neq P\\left[q+1\\right]\\), so that \\(a\\) does not continue to match the pattern, and the state number does not increase: \\(0\\leq\\delta(q,a)\\leq q\\). In the first case, when \\(a\\) continues to match, KMP-Matcher moves to state \\(q+1\\) without referring to the \\(\\pi\\) function: the **while** loop test in line 4 immediately comes up false, the test in line 6 comes up true, and line 7 increments \\(q\\).\n\nThe \\(\\pi\\) function comes into play when the character \\(a\\) does not continue to match the pattern, so that the new state \\(\\delta(q,a)\\) is either \\(q\\) or to the left of \\(q\\) along the spine of the automaton. The **while** loop of lines 4-5 in KMP-Matcher iterates through the states in \\(\\pi^{*}[q]\\), stopping either when it arrives in a state, say \\(q^{\\prime}\\), such that \\(a\\) matches \\(P\\left[q^{\\prime}+1\\right]\\) or \\(q^{\\prime}\\) has gone all the way down to 0. If \\(a\\) matches \\(P\\left[q^{\\prime}+1\\right]\\), then line 7 sets the new state to \\(q^{\\prime}+1\\), which should equal \\(\\delta(q,a)\\) for the simulation to work correctly. In other words, the new state \\(\\delta(q,a)\\) should be either state 0 or a state numbered 1 more than some state in \\(\\pi^{*}[q]\\).\n\nLet's look at the example in Figures 32.6 and 32.10, which are for the pattern \\(P=\\mathtt{ababaca}\\). Suppose that the automaton is in state \\(q=5\\), having matched \\(\\mathtt{ababa}\\). The states in \\(\\pi^{*}[5]\\) are, in descending order, 3, 1, and 0. If the next character scanned is \\(\\mathtt{c}\\), then you can see that the automaton moves to state \\(\\delta(5,\\mathtt{c})=6\\) in both Finite-Automaton-Matcher (line 3) and KMP-Matcher (line 7). Now suppose that the next character scanned is instead \\(\\mathtt{b}\\), so that the automaton should move to state \\(\\delta(5,\\mathtt{b})=4\\). The **while** loop in KMP-Matcher exits after executing line 5 once, and the automaton arrives in state \\(q^{\\prime}=\\pi[5]=3\\). Since \\(P\\left[q^{\\prime}+1\\right]=P\\left[4\\right]=\\mathtt{b}\\), the test in line 6 comes up true, and the automaton moves to the new state \\(q^{\\prime}+1=4=\\delta(5,\\mathtt{b})\\). Finally, suppose that the next character scanned is instead \\(\\mathtt{a}\\), so that the automaton should move to state \\(\\delta(5,\\mathtt{a})=1\\). The first three times that the test in line 4 executes, the test comes up true. The first time finds that \\(P\\left[6\\right]=\\mathtt{c}\\neq\\mathtt{a}\\), and the automaton moves to state \\(\\pi[5]=3\\) (the first state in \\(\\pi^{*}[5]\\)). The second time finds that \\(P\\left[4\\right]=\\mathtt{b}\\neq\\mathtt{a}\\), and the automaton moves to state \\(\\pi[3]=1\\) (the second state in \\(\\pi^{*}[5]\\)). The third time finds that \\(P\\left[2\\right]=\\mathtt{b}\\neq\\mathtt{a}\\), and the automaton moves to state \\(\\pi[1]=0\\) (the last state in \\(\\pi^{*}[5]\\)). The **while** loop exits once it arrives in state \\(q^{\\prime}=0\\). Now line 6 finds that \\(P\\left[q^{\\prime}+1\\right]=P\\left[1\\right]=\\mathtt{a}\\), and line 7 moves the automaton to the new state \\(q^{\\prime}+1=1=\\delta(5,\\mathtt{a})\\).\n\nThus, the intuition is that KMP-Matcher iterates through the states in \\(\\pi^{*}[q]\\) in decreasing order, stopping at some state \\(q^{\\prime}\\) and then possibly moving to state \\(q^{\\prime}+1\\). Although that might seem like a lot of work just to simulate computing \\(\\delta(q,a)\\), bear in mind that asymptotically, KMP-Matcher is no slower than Finite-Automaton-Matcher.\n\nWe are now ready to formally prove the correctness of the Knuth-Morris-Pratt algorithm. By Theorem 32.4, we have that \\(q=\\sigma(T[\\,:\\,i])\\) after each time line 3 of Finite-Automaton-Matcher executes. Therefore, it suffices to show that the same property holds with regard to the **for** loop in KMP-Matcher. The proof proceeds by induction on the number of loop iterations. Initially, both procedures set \\(q\\) to 0 as they enter their respective **for** loops for the first time. Consider iteration \\(i\\) of the **for** loop in KMP-Matcher. By the inductive hypothesis, the state number \\(q\\) equals \\(\\sigma(T[\\,:\\,i-1])\\) at the start of the loop iteration. We need to show that when line 8 is reached, the new value of \\(q\\) is \\(\\sigma(T[\\,:\\,i])\\). (Again, we'll handle line 10 separately.)\n\nConsidering \\(q\\) to be the state number at the start of the **for** loop iteration, when KMP-Matcher considers the character \\(T[i]\\), the longest prefix of \\(P\\) that is a suffix of \\(T[\\,:\\,i]\\) is either \\(P\\left[\\,:\\,q+1\\right]\\) (if \\(P\\left[q+1\\right]=T[i]\\)) or some prefix (notnecessarily proper, and possibly empty) of \\(P[\\,:\\,q]\\). We consider separately the three cases in which \\(\\sigma(T[\\,:\\,i])=0\\), \\(\\sigma(T[\\,:\\,i])=q\\,+\\,1\\), and \\(0<\\sigma(T[\\,:\\,i])\\leq q\\).\n* If \\(\\sigma(T[\\,:\\,i])=0\\), then \\(P[\\,:\\,0]=\\varepsilon\\) is the only prefix of \\(P\\) that is a suffix of \\(T[\\,:\\,i]\\). The **while** loop of lines 4-5 iterates through each value \\(q^{\\prime}\\) in \\(\\pi^{*}[q]\\), but although \\(P[\\,:\\,q^{\\prime}]\\sqsupset P[\\,:\\,q]\\sqsupset T[\\,:\\,i-1]\\) for every \\(q^{\\prime}\\in\\pi^{*}[q]\\) (because \\(<\\) are \\(\\sqsupset\\) are transitive relations), the loop never finds a \\(q^{\\prime}\\) such that \\(P[q^{\\prime}+1]=T[i]\\). The loop terminates when \\(q\\) reaches 0, and of course line 7 does not execute. Therefore, \\(q=0\\) at line 8, so that now \\(q=\\sigma(T[\\,:\\,i])\\).\n* If \\(\\sigma(T[\\,:\\,i])=q+1\\), then \\(P[q+1]=T[i]\\), and the **while** loop test in line 4 fails the first time through. Line 7 executes, incrementing the state number to \\(q+1\\), which equals \\(\\sigma(T[\\,:\\,i])\\).\n* If \\(0<\\sigma(T[\\,:\\,i])\\leq q^{\\prime}\\), then the **while** loop of lines 4-5 iterates at least once, checking in decreasing order each value in \\(\\pi^{*}[q]\\) until it stops at some \\(q^{\\prime}<q\\). Thus, \\(P[\\,:\\,q^{\\prime}]\\) is the longest prefix of \\(P[\\,:\\,q]\\) for which \\(P[q^{\\prime}+1]=T[i]\\), so that when the **while** loop terminates, \\(q^{\\prime}+1=\\sigma(P[\\,:\\,q]T[i])\\). Since \\(q=\\sigma(T[\\,:\\,i-1])\\), Lemma 32.3 implies that \\(\\sigma(T[\\,:\\,i-1]T[i])=\\sigma(P[\\,:\\,q]T[i])\\). Thus we have \\[q^{\\prime}+1 = \\sigma(P[\\,:\\,q]T[i])\\] \\[= \\sigma(T[\\,:\\,i-1]T[i])\\] \\[= \\sigma(T[\\,:\\,i])\\] when the **while** loop terminates. After line 7 increments \\(q\\), the new state number \\(q\\) equals \\(\\sigma(T[\\,:\\,i])\\).\n\nLine 10 is necessary in KMP-Matcher, because otherwise, line 4 might try to reference \\(P[m+1]\\) after finding an occurrence of \\(P\\). (The argument that \\(q=\\sigma(T[\\,:\\,i-1])\\) upon the next execution of line 4 remains valid by the hint given in Exercise 32.4-8: that \\(\\delta(m,a)=\\delta(\\pi[m]a)\\) or, equivalently, \\(\\sigma(Pa)=\\sigma(P[\\,:\\pi[m]]a)\\) for any \\(a\\in\\Sigma\\).) The remaining argument for the correctness of the Knuth-Morris-Pratt algorithm follows from the correctness of Finite-Automaton-Matcher, since we have shown that KMP-Matcher simulates the behavior of Finite-Automaton-Matcher.\n\n## Exercises\n\n### 32.4-1\n\nCompute the prefix function \\(\\pi\\) for the pattern \\(\\mathtt{ababbabababababababababab}\\).\n\n### 32.4-2\n\nGive an upper bound on the size of \\(\\pi^{*}[q]\\) as a function of \\(q\\). Give an example to show that your bound is tight.\n\n#### 32.4-3\n\nExplain how to determine the occurrences of pattern \\(P\\) in the text \\(T\\) by examining the \\(\\pi\\) function for the string \\(P\\,T\\) (the string of length \\(m+n\\) that is the concatenation of \\(P\\) and \\(T\\)).\n\n#### 32.4-4\n\nUse an aggregate analysis to show that the running time of KMP-Matcher is \\(\\Theta(n)\\).\n\n#### 32.4-5\n\nUse a potential function to show that the running time of KMP-Matcher is \\(\\Theta(n)\\).\n\n#### 32.4-6\n\nShow how to improve KMP-Matcher by replacing the occurrence of \\(\\pi\\) in line 5 (but not line 10) by \\(\\pi^{\\prime}\\), where \\(\\pi^{\\prime}\\) is defined recursively for \\(q=1,2,\\ldots,m-1\\) by the equation\n\n\\[\\pi^{\\prime}[q]=\\left\\{\\begin{array}{ll}0&\\mbox{if $\\pi\\,[q]=0$,}\\\\ \\pi^{\\prime}[\\pi[q]]&\\mbox{if $\\pi\\,[q]\\neq 0$ and $P\\,[\\pi[q]+1]=P\\,[q+1]$,}\\\\ \\pi[q]&\\mbox{if $\\pi\\,[q]\\neq 0$ and $P\\,[\\pi[q]+1]\\neq P\\,[q+1]$.}\\end{array}\\right.\\]\n\nExplain why the modified algorithm is correct, and explain in what sense this change constitutes an improvement.\n\n#### 32.4-7\n\nGive a linear-time algorithm to determine whether a text \\(T\\) is a cyclic rotation of another string \\(T^{\\prime}\\). For example, braze and zebra are cyclic rotations of each other.\n\n* _32.4-8_\n\nGive an \\(O(m\\,|\\Sigma|)\\)-time algorithm for computing the transition function \\(\\delta\\) for the string-matching automaton corresponding to a given pattern \\(P\\). (_Hint:_ Prove that \\(\\delta(q,a)=\\delta(\\pi[q]a)\\) if \\(q=m\\) or \\(P\\,[q+1]\\neq a\\).)\n\n### 32.5 Suffix arrays\n\nThe algorithms we have seen thus far in this chapter can efficiently find all occurrences of a pattern in a text. That is, however, all they can do. This section presents a different approach--suffix arrays--with which you can find all occurrences of a pattern in a text, but also quite a bit more. A suffix array won't find all occurrences",
        "chapter": "Part VII Selected Topics",
        "section": "32 String Matching",
        "subsection": "32.4 The Knuth-Morris-Pratt algorithm",
        "subsubsection": "N/A"
    },
    {
        "content": "#### 32.4-3\n\nExplain how to determine the occurrences of pattern \\(P\\) in the text \\(T\\) by examining the \\(\\pi\\) function for the string \\(P\\,T\\) (the string of length \\(m+n\\) that is the concatenation of \\(P\\) and \\(T\\)).\n\n#### 32.4-4\n\nUse an aggregate analysis to show that the running time of KMP-Matcher is \\(\\Theta(n)\\).\n\n#### 32.4-5\n\nUse a potential function to show that the running time of KMP-Matcher is \\(\\Theta(n)\\).\n\n#### 32.4-6\n\nShow how to improve KMP-Matcher by replacing the occurrence of \\(\\pi\\) in line 5 (but not line 10) by \\(\\pi^{\\prime}\\), where \\(\\pi^{\\prime}\\) is defined recursively for \\(q=1,2,\\ldots,m-1\\) by the equation\n\n\\[\\pi^{\\prime}[q]=\\left\\{\\begin{array}{ll}0&\\mbox{if $\\pi\\,[q]=0$,}\\\\ \\pi^{\\prime}[\\pi[q]]&\\mbox{if $\\pi\\,[q]\\neq 0$ and $P\\,[\\pi[q]+1]=P\\,[q+1]$,}\\\\ \\pi[q]&\\mbox{if $\\pi\\,[q]\\neq 0$ and $P\\,[\\pi[q]+1]\\neq P\\,[q+1]$.}\\end{array}\\right.\\]\n\nExplain why the modified algorithm is correct, and explain in what sense this change constitutes an improvement.\n\n#### 32.4-7\n\nGive a linear-time algorithm to determine whether a text \\(T\\) is a cyclic rotation of another string \\(T^{\\prime}\\). For example, braze and zebra are cyclic rotations of each other.\n\n* _32.4-8_: Give an \\(O(m\\,|\\Sigma|)\\)-time algorithm for computing the transition function \\(\\delta\\) for the string-matching automaton corresponding to a given pattern \\(P\\). (_Hint:_ Prove that \\(\\delta(q,a)=\\delta(\\pi[q]a)\\) if \\(q=m\\) or \\(P\\,[q+1]\\neq a\\).)\n\n### 32.5 Suffix arrays\n\nThe algorithms we have seen thus far in this chapter can efficiently find all occurrences of a pattern in a text. That is, however, all they can do. This section presents a different approach--suffix arrays--with which you can find all occurrences of a pattern in a text, but also quite a bit more. A suffix array won't find all occurrencesof a pattern as quickly as, say, the Knuth-Morris-Pratt algorithm, but its additional flexibility makes it well worth studying.\n\nA suffix array is simply a compact way to represent the lexicographically sorted order of all \\(n\\) suffixes of a length-\\(n\\) text. Given a text \\(T[1:n]\\), let \\(T[i:]\\) denote the suffix \\(T[i:n]\\). The _suffix array SA\\([1:n]\\)_ of \\(T\\) is defined such that if \\(\\textit{SA}[i]=j\\), then \\(T[j:]\\) is the \\(i\\)th suffix of \\(T\\) in lexicographic order.3 That is, the \\(i\\)th suffix of \\(T\\) in lexicographic order is \\(T[\\textit{SA}[i]:]\\). Along with the suffix array, another useful array is the _longest common prefix array LCP\\([1:n]\\)_. The entry _LCP\\([i]\\)_ gives the length of the longest common prefix between the \\(i\\)th and \\((i-1)\\)st suffixes in the sorted order (with _LCP\\([\\textit{SA}[1]]\\)_ defined to be \\(0\\), since there is no prefix lexicographically smaller than \\(T[\\textit{SA}[1]:]\\)). Figure 32.11 shows the suffix array and longest common prefix array for the 7-character text ratatat.\n\nFootnote 3: Informally, lexicographic order is \u201calphabetical order\u201d in the underlying character set. A more precise definition of lexicographic order appears in Problem 12-2 on page 327.\n\nGiven the suffix array for a text, you can search for a pattern via binary search on the suffix array. Each occurrence of a pattern in the text starts some suffix of the text, and because the suffix array is in lexicographically sorted order, all occurrences of a pattern will appear at the start of consecutive entries of the suffix array. For example, in Figure 32.11, the three occurrences of at in ratatat appear in entries 1 through 3 of the suffix array. If you find the length-\\(m\\) pattern in the length-\\(n\\) suffix array via binary search (taking \\(O(m\\lg n)\\) time because each comparison takes \\(O(m)\\) time), then you can find all occurrences of the pattern in the text by searching backward and forward from that spot until you find a suffix that does not start with the pattern (or you go beyond the bounds of the suffix array). If the pattern occurs \\(k\\) times, then the time to find all \\(k\\) occurrences is \\(O(m\\lg n+km)\\).\n\nFigure 32.11: The suffix array _SA_, rank array _rank_, longest common prefix array _LCP_, and lexicographically sorted suffixes of the text \\(T=\\texttt{ratatatat}\\) with length \\(n=7\\). The value of _rank\\([i]\\)_ indicates the position of the suffix \\(T[i:]\\) in the lexicographically sorted order: \\(\\textit{rank}[\\textit{SA}[i]]=i\\) for \\(i=1,2,\\ldots,n\\). The _rank_ array is used to compute the _LCP_ array.\n\n### 32.5 Suffix arrays\n\nWith the longest common prefix array, you can find a longest repeated substring, that is, the longest substring that occurs more than once in the text. If \\(LCP[i]\\) contains a maximum value in the \\(LCP\\) array, then a longest repeated substring appears in \\(T[\\mathit{SA}[i]\\!:\\!\\mathit{SA}[i]+LCP[i]-1]\\). In the example of Figure 32.11, the \\(LCP\\) array has one maximum value: \\(LCP[3]=4\\). Therefore, since \\(\\mathit{SA}[3]=2\\), the longest repeated substring is \\(T[2\\!:\\!5]=\\mathtt{atat}\\). Exercise 32.5-3 asks you to use the suffix array and longest common prefix array to find the longest common substrings between two texts. Next, we'll see how to compute the suffix array for an \\(n\\)-character text in \\(O(n\\lg n)\\) time and, given the suffix array and the text, how to compute the longest common prefix array in \\(\\Theta(n)\\) time.\n\n### Computing the suffix array\n\nThere are several algorithms to compute the suffix array of a length-\\(n\\) text. Some run in linear time, but are rather complicated. One such algorithm is given in Problem 32-2. Here we'll explore a simpler algorithm that runs in \\(\\Theta(n\\lg n)\\) time.\n\nThe idea behind the \\(O(n\\lg n)\\)-time procedure Compute-Suffix-Array on the following page is to lexicographically sort substrings of the text with increasing lengths. The procedure makes several passes over the text, with the substring length doubling each time. By the \\(\\lceil\\lg n\\rceil\\)th pass, the procedure is sorting all the suffixes, thereby gaining the information needed to construct the suffix array. The key to attaining an \\(O(n\\lg n)\\)-time algorithm will be to have each pass after the first sort in linear time, which will indeed be possible by using radix sort.\n\nLet's start with a simple observation. Consider any two strings, \\(s_{1}\\) and \\(s_{2}\\). Decompose \\(s_{1}\\) into \\(s^{\\prime}_{1}\\) and \\(s^{\\prime\\prime}_{1}\\), so that \\(s_{1}\\) is \\(s^{\\prime}_{1}\\) concatenated with \\(s^{\\prime\\prime}_{1}\\). Likewise, let \\(s_{2}\\) be \\(s^{\\prime}_{2}\\) concatenated with \\(s^{\\prime\\prime}_{2}\\). Now, suppose that \\(s^{\\prime}_{1}\\) is lexicographically smaller than \\(s^{\\prime}_{2}\\). Then, regardless of \\(s^{\\prime\\prime}_{1}\\) and \\(s^{\\prime\\prime}_{2}\\), it must be the case that \\(s_{1}\\) is lexicographically smaller than \\(s_{2}\\). For example, let \\(s_{1}=\\mathtt{aaz}\\) and \\(s_{2}=\\mathtt{aba}\\), and decompose \\(s_{1}\\) into \\(s^{\\prime}_{1}=\\mathtt{aa}\\) and \\(s^{\\prime\\prime}_{1}=\\mathtt{z}\\) and \\(s_{2}\\) into \\(s^{\\prime}_{2}=\\mathtt{ab}\\) and \\(s^{\\prime\\prime}_{2}=\\mathtt{a}\\). Because \\(s^{\\prime}_{1}\\) is lexicographically smaller than \\(s^{\\prime}_{2}\\), it follows that \\(s_{1}\\) is lexicographically smaller than \\(s_{2}\\), even though \\(s^{\\prime\\prime}_{2}\\) is lexicographically smaller than \\(s^{\\prime\\prime}_{1}\\).\n\nInstead of comparing substrings directly, Compute-Suffix-Array represents substrings of the text with integer \\(\\mathit{ranks}\\). Ranks have the simple property that one substring is lexicographically smaller then another if and only if it has a smaller rank. Identical substrings have equal ranks.\n\nWhere do these ranks come from? Initially, the substrings being considered are just single characters from the text. Assume that, as in many programming languages, there is a function, ord, that maps a character to its underlying encoding, which is a positive integer. The ord function could be the ASCII or Unicode encodings or any other function that produces a relative ordering of the characters. For example if all the characters are known to be lowercase letters, then \\(\\mathrm{ord}(\\mathtt{a})=1\\)\n\n### 32.5 Suffix arrays\n\n\\(\\mbox{ord(b)}=2\\),..., \\(\\mbox{ord(z)}=26\\) would work. Once the substrings being considered contain multiple characters, their ranks will be positive integers less than or equal to \\(n\\), coming from their relative order after being sorted. An empty substring always has rank \\(0\\), since it is lexicographically less than any nonempty substring.\n\nThe Compute-Suffix-Array procedure uses objects internally to keep track of the relative ordering of the substrings according to their ranks. When considering substrings of a given length, the procedure creates and sorts an array \\(\\mbox{\\it substr-rank}[1:n]\\) of \\(n\\) objects, each with the following attributes:\n\n* _left-rank_ contains the rank of the left part of the substring.\n* _right-rank_ contains the rank of the right part of the substring.\n* _index_ contains the index into the text \\(T\\) of where the substring starts.\n\nBefore delving into the details of how the procedure works, let's look at how it operates on the input text \\(\\mbox{\\tt ratatat}\\), with \\(n=7\\). Assuming that the ord function returns the ASCII code for a character, Figure 32.12 shows the _substr-rank_ array after the **for** loop of lines 2-7 and then after the sorting step in line 8. The _left-rank_ and _right-rank_ values after lines 2-7 are the ranks of length-1 substrings in positions \\(i\\) and \\(i+1\\), for \\(i=1,2,\\ldots,n\\). These initial ranks are the ASCII values of the characters. At this point, the _left-rank_ and _right-rank_ values give the ranks of the left and right part of each substring of length 2. Because the substring starting at index 7 consists of only one character, its right part is empty and so its _right-rank_ is \\(0\\). After the sorting step in line 8, the _substr-rank_ array gives the relative lexicographic order of all the substrings of length 2, with starting points of these substrings in the _index_ attribute. For example, the lexicographically smallest length-2 substring is at, which starts at position \\(\\mbox{\\it substr-rank}[1]\\)._index_, which equals 2. This substring also occurs at positions \\(\\mbox{\\it substr-rank}[2]\\)._index_\\(=4\\) and \\(\\mbox{\\it substr-rank}[3]\\)._index_\\(=6\\).\n\nThe procedure then enters the **while** loop of lines 10-19. The loop variable \\(l\\) gives an upper bound on the length of substrings that have been sorted thus far.\n\nFigure 32.12: The _substr-rank_ array for indices \\(i=1,2,\\ldots,7\\) after the **for** loop of lines 2\u20137 and after the sorting step in line 8 for input string \\(T=\\mbox{\\tt ratatatat}\\).\n\n. Entering the **while** loop, therefore, the substrings of length at most \\(l=2\\) are sorted. The call of Make-Ranks in line 11 gives each of these substrings its rank in the sorted order, from 1 up to the number of unique length-2 substrings, based on the values it finds in the _substr-rank_ array. With \\(l=2\\), Make-Ranks sets \\(rank[i]\\) to be the rank of the length-2 substring \\(T[i:i+1]\\). Figure 32.13 shows these new ranks, which are not necessarily unique. For example, since the length-2 substring at occurs at positions 2, 4, and 6, Make-Ranks finds that \\(substr\\)-\\(rank[1]\\), \\(substr\\)-\\(rank[2]\\), and \\(substr\\)-\\(rank[3]\\) have equal values in _left-rank_ and in _right-rank_. Since \\(substr\\)-\\(rank[1]\\). \\(index=2\\), \\(substr\\)-\\(rank[2]\\). \\(index=4\\), and \\(substr\\)-\\(rank[3]\\). \\(index=6\\), and since at is the smallest substring in lexicographic order, Make-Ranks sets \\(rank[2]=rank[4]=rank[6]=1\\).\n\nThis iteration of the **while** loop will sort the substrings of length at most 4 based on the ranks from sorting the substrings of length at most 2. The **for** loop of lines 12-17 reconstitutes the \\(substr\\)-\\(rank\\) array, with \\(substr\\)-\\(rank[i]\\). _left-rank_ based on \\(rank[i]\\) (the rank of the length-2 substring \\(T[i:i+1]\\)) and \\(substr\\)-\\(rank[i]\\). _right-rank_ based on \\(rank[i+2]\\) (the rank of the length-2 substring \\(T[i+2:i+3]\\), which is 0 if this substring starts beyond the end of the length-\\(n\\) text). Together, these two ranks give the relative rank of the length-4 substring \\(T[i:i+3]\\). Figure 32.13 shows the effect of lines 12-17. The figure also shows the result of sorting the _substr-rank_ array in line 18, based on the _left-rank_ attribute, and using the _right-rank_ attribute to break ties. Now _substr-rank_ gives the lexicographically sorted order of all substrings with length at most 4.\n\nThe next iteration of the **while** loop, with \\(l=4\\), sorts the substrings of length at most 8 based on the ranks from sorting the substrings of length at most4 4. Figure 32.14 shows the ranks of the length-4 substrings and the _substr-rank_ array\n\nFigure 32.13: The _rank_ array after line 11 and the _substr-rank_ array after lines 12\u201317 and after line 18 in the first iteration of the **while** loop of lines 10\u201319, where \\(l=2\\).\n\nbefore and after sorting. This iteration is the final one, since with the length \\(n\\) of the text equaling 7, the procedure has sorted all substrings.\n\nIn general, as the loop variable \\(l\\) increases, more and more of the right parts of the substrings are empty. Therefore, more of the _right-rank_ values are 0. Because \\(i\\) is at most \\(n\\) within the loop of lines 12-17, the left part of each substring is always nonempty, and so all _left-rank_ values are always positive.\n\nThis example illuminates why the Compute-Suffix-Array procedure works. The initial ranks established in lines 2-7 are simply the ord values of the characters in the text, and so when line 8 sorts the _substr-rank_ array, its ordering corresponds to the lexicographic ordering of the length-2 substrings. Each iteration of the **while** loop of lines 10-19 takes sorted substrings of length \\(l\\) and produces sorted substrings of length \\(2l\\). Once \\(l\\) reaches or exceeds \\(n\\), all substrings have been sorted.\n\nWithin an iteration of the **while** loop, the Make-Ranks procedure \"re-ranks\" the substrings that were sorted, either by line 8 before the first iteration or by line 18 in the previous iteration. Make-Ranks takes a _substr-rank_ array, which has been sorted, and fills in an array \\(rank[1:n]\\) so that \\(rank[i]\\) is the rank of the \\(i\\)th substring represented in the _substr-rank_ array. Each rank is a positive integer, starting from 1, and going up to the number of unique substrings of length \\(2l\\). Substrings with equal values of _left-rank_ and _right-rank_ receive the same rank. Otherwise, a substring that is lexicographically smaller than another appears earlier in the _substr-rank_ array, and it receives a smaller rank. Once the substrings of length \\(2l\\) are re-ranked, line 18 sorts them by rank, preparing for the next iteration of the **while** loop.\n\nOnce \\(l\\) reaches or exceeds \\(n\\) and all substrings are sorted, the values in the _index_ attributes give the starting positions of the sorted substrings. These indices are precisely the values that constitute the suffix array.\n\nLet's analyze the running time of Compute-Suffix-Array. Lines 1-7 take \\(\\Theta(n)\\) time. Line 8 takes \\(\\,\\mathcal{O}(n\\lg n)\\) time, using either merge sort (see Section 2.3.1) or heapsort (see Chapter 6). Because the value of \\(l\\) doubles in each iteration of\n\nFigure 32.14: The _rank_ array after line 11 and the _substr-rank_ array after lines 12\u201317 and after line 18 in the second\\(-\\)and final\\(-\\)iteration of the **while** loop of lines 10\u201319, where \\(l=4\\).\n\nthe **while** loop of lines 10-19, this loop makes \\(\\lceil\\lg n\\rceil-1\\) iterations. Within each iteration, the call of Make-Ranks takes \\(\\Theta(n)\\) time, as does the **for** loop of lines 12-17. Line 18, like line 8, takes \\(O(n\\lg n)\\) time, using either merge sort or heapsort. Finally, the **for** loop of lines 20-21 takes \\(\\Theta(n)\\) time. The total time works out to \\(O(n\\lg^{2}n)\\).\n\nA simple observation allows us to reduce the running time to \\(\\Theta(n\\lg n)\\). The values of _left-rank_ and _right-rank_ being sorted in line 18 are always integers in the range 0 to \\(n\\). Therefore, radix sort can sort the _substr-rank_ array in \\(\\Theta(n)\\) time by first running counting sort (see Chapter 8) based on _right-rank_ and then running counting sort based on _left-rank_. Now each iteration of the **while** loop of lines 10-19 takes only \\(\\Theta(n)\\) time, giving a total time of \\(\\Theta(n\\lg n)\\).\n\nExercise 32.5-2 asks you to make a simple modification to Compute-Suffix-Array that allows the **while** loop of lines 10-19 to iterate fewer than \\(\\lceil\\lg n\\rceil-1\\) times for certain inputs.\n\n### Computing the _Lcp_ array\n\nRecall that \\(LCP[i]\\) is defined as the length of the longest common prefix of the \\((i-1)\\)st and \\(i\\)th lexicographically smallest suffixes \\(T[\\mathit{SA}[i-1]\\,\\colon]\\) and \\(T[\\mathit{SA}[i]\\,\\colon]\\). Because \\(T[\\mathit{SA}[1]\\,\\colon]\\) is the lexicographically smallest suffix, we define \\(LCP[1]\\) to be 0.\n\nIn order to compute the \\(LCP\\) array, we need an array _rank_ that is the inverse of the \\(\\mathit{SA}\\) array, just like the final _rank_ array in Compute-Suffix-Array: if \\(\\mathit{SA}[i]=j\\), then \\(\\mathit{rank}[j]=i\\). That is, we have \\(\\mathit{rank}[\\mathit{SA}[i]]=i\\) for \\(i=1,2,\\ldots,n\\). For a suffix \\(T[i\\,\\colon]\\), the value of \\(\\mathit{rank}[i]\\) gives the position of this suffix in the lexicographically sorted order. Figure 32.11 includes the _rank_ array for the ratatat example. For example, the suffix \\(\\mathtt{tat}\\) is \\(T[5\\,\\colon]\\). To find this suffix's position in the sorted order, look up \\(\\mathit{rank}[5]=6\\).\n\nTo compute the \\(LCP\\) array, we will need to determine where in the lexicographically sorted order a suffix appears, but with its first character removed. The _rank_ array helps. Consider the \\(i\\)th smallest suffix, which is \\(T[\\mathit{SA}[i]\\,\\colon]\\). Dropping its first character gives the suffix \\(T[\\mathit{SA}[i]+1\\,\\colon]\\), that is, the suffix starting at position \\(\\mathit{SA}[i]+1\\) in the text. The location of this suffix in the sorted order is given by \\(\\mathit{rank}[\\mathit{SA}[i]+1]\\). For example, for the suffix \\(\\mathtt{atat}\\), let's see where to find \\(\\mathtt{tat}\\) (\\(\\mathtt{atat}\\) with its first character removed) in the lexicographically sorted order. The suffix \\(\\mathtt{atat}\\) appears in position 2 of the suffix array, and \\(\\mathit{SA}[2]=4\\). Thus, \\(\\mathit{rank}[\\mathit{SA}[2]+1]=\\mathit{rank}[5]=6\\), and sure enough the suffix \\(\\mathtt{tat}\\) appears in location 6 in the sorted order.\n\nThe procedure Compute-LCP on the next page produces the \\(LCP\\) array. The following lemma helps show that the procedure is correct.\n\n#### 32.5 Suffix arrays\n\nConsider suffixes \\(T[i-1\\,\\colon\\,]\\) and \\(T[i\\,\\colon\\,]\\), which appear at positions \\(rank[i-1]\\) and \\(rank[i]\\), respectively, in the lexicographically sorted order of suffixes. If \\(LCP[rank[i-1]]=l>1\\), then the suffix \\(T[i\\,\\colon\\,]\\), which is \\(T[i\\,-1\\,\\colon\\,]\\) with its first character removed, has \\(LCP[rank[i]]\\geq l-1\\).\n\nProofThe suffix \\(T[i-1\\,\\colon\\,]\\) appears at position \\(rank[i-1]\\) in the lexicographically sorted order. The suffix immediately preceding it in the sorted order appears at position \\(rank[i-1]-1\\) and is \\(T[\\mathit{SA}[rank[i-1]-1]\\,\\colon\\,]\\). By assumption and the definition of the \\(LCP\\) array, these two suffixes, \\(T[\\mathit{SA}[rank[i-1]-1]\\,\\colon\\,]\\) and \\(T[i-1\\,\\colon\\,]\\), have a longest common prefix of length \\(l>1\\). Removing the first character from each of these suffixes gives the suffixes \\(T[\\mathit{SA}[rank[i-1]-1]+1\\,\\colon\\,]\\) and \\(T[i\\,\\colon\\,]\\), respectively. These suffixes have a longest common prefix of length \\(l-1\\). If \\(T[\\mathit{SA}[rank[i-1]-1]+1\\,\\colon\\,]\\) immediately precedes \\(T[i\\,\\colon\\,]\\) in the lexicographically sorted order (that is, if \\(rank[\\mathit{SA}[rank[i-1]-1]+1]=rank[i]-1\\)), then the lemma is proven.\n\nSo now assume that \\(T[\\mathit{SA}[rank[i-1]-1]+1\\,\\colon\\,]\\) does not immediately precede \\(T[i\\,\\colon\\,]\\) in the sorted order. Since \\(T[\\mathit{SA}[rank[i-1]-1]\\,\\colon\\,]\\) immediately precedes \\(T[i-1\\,\\colon\\,]\\) and they have the same first \\(l>1\\) characters, \\(T[\\mathit{SA}[rank[i-1]-1]+1\\,\\colon\\,]\\) must appear in the sorted order somewhere before \\(T[i\\,\\colon\\,]\\), with one or more other suffixes intervening. Each of these suffixes must start with the same \\(l-1\\) characters as \\(T[\\mathit{SA}[rank[i-1]-1]+1\\,\\colon\\,]\\) and \\(T[i\\,\\colon\\,]\\), for otherwise it would appear either before\\(T[SA[rank[i-1]-1]+1:]\\) or after \\(T[i:]\\). Therefore, whichever suffix appears in position \\(rank[i]-1\\), immediately before \\(T[i:]\\), has at least its first \\(l-1\\) characters in common with \\(T[i:]\\). Thus, \\(LCP[rank[i]]\\geq l-1\\). \n\nThe Compute-LCP procedure works as follows. After allocating the \\(rank\\) and \\(LCP\\) arrays in line 1, lines 2-3 fill in the \\(rank\\) array and line 4 pegs \\(LCP[1]\\) to 0, per the definition of the \\(LCP\\) array.\n\nThe **for** loop of lines 6-14 fills in the rest of the \\(LCP\\) array going by decreasing-length suffixes. That is, it fills the position of the \\(LCP\\) array in the order \\(rank[1]\\), \\(rank[2]\\), \\(rank[3]\\), \\(\\ldots\\), \\(rank[n]\\), with the assignment occurring in line 12. Upon considering a suffix \\(T[i:]\\), line 8 determines the suffix \\(T[j:]\\) that immediately precedes \\(T[i:]\\) in the lexicographically sorted order. At this point, the longest common prefix of \\(T[j:]\\) and \\(T[i:]\\) has length at least \\(l\\). This property certainly holds upon the first iteration of the **for** loop, when \\(l=0\\). Assuming that line 12 sets \\(LCP[rank[i]]\\) correctly, line 14 (which decrements \\(l\\) if it is positive) and Lemma 3.2.8 maintain this property for the next iteration. The longest common prefix of \\(T[j:]\\) and \\(T[i:]\\) might be even longer than the value of \\(l\\) at the start of the iteration, however. Lines 9-11 increment \\(l\\) for each additional character the prefixes have in common so that it achieves the length of the longest common prefix. The index \\(m\\) is set in line 9 and used in the test in line 10 to make sure that the test \\(T[i+l]=T[j+l]\\) for extending the longest common prefix does not run off the end of the text \\(T\\). When the **while** loop of lines 10-11 terminates, \\(l\\) is the length of the longest common prefix of \\(T[j:]\\) and \\(T[i:]\\).\n\nAs a simple aggregate analysis shows, the Compute-LCP procedure runs in \\(\\Theta(n)\\) time. Each of the two **for** loops iterates \\(n\\) times, and so it remains only to bound the total number of iterations by the **while** loop of lines 10-11. Each iteration increases \\(l\\) by 1, and the test \\(m+l\\leq n\\) ensures that \\(l\\) is always less than \\(n\\). Because \\(l\\) has an initial value of 0 and decreases at most \\(n-1\\) times in line 14, line 11 increments \\(l\\) fewer than \\(2n\\) times. Thus, Compute-LCP takes \\(\\Theta(n)\\) time.\n\n## Exercises\n\n### 32.5-1\n\nShow the _substr-rank_ and _rank_ arrays before each iteration of the **while** loop of lines 10-19 and after the last iteration of the **while** loop, the suffix array _SA_ returned, and the sorted suffixes when Compute-Suffix-Array is run on the text hippityhoppity. Use the position of each letter in the alphabet as its ord value, so that ord(b) = 2. Then show the \\(LCP\\) array after each iteration of the **for** loop of lines 6-14 of Compute-LCP given the text hippityhoppity and its suffix array.\n\n### 32.5-2\n\nFor some inputs, the Compute-Suffix-Array procedure can produce the correct result with fewer than \\(\\lceil\\lg n\\rceil-1\\) iterations of the **while** loop of lines 10-19. Modify Compute-Suffix-Array (and, if necessary, Make-Ranks) so that the procedure can stop before making all \\(\\lceil\\lg n\\rceil-1\\) iterations in some cases. Describe an input that allows the procedure to make \\(O(1)\\) iterations. Describe an input that forces the procedure to make the maximum number of iterations.\n\n### 32.5-3\n\nGiven two texts, \\(T_{1}\\) of length \\(n_{1}\\) and \\(T_{2}\\) of length \\(n_{2}\\), show how to use the suffix array and longest common prefix array to find all of the _longest common substrings_, that is, the longest substrings that appear in both \\(T_{1}\\) and \\(T_{2}\\). Your algorithm should run in \\(O(n\\lg n+k\\,l)\\) time, where \\(n=n_{1}+n_{2}\\) and there are \\(k\\) such longest substrings, each with length \\(l\\).\n\n### 32.5-4\n\nProfessor Markram proposes the following method to find the longest palindromes in a string \\(T[1:n]\\) by using its suffix array and LCP array. (Recall from Problem 14-2 that a palindrome is a nonempty string that reads the same forward and backward.)\n\nLet \\(\\emptyset\\) be a character that does not appear in \\(T\\). Construct the text \\(T^{\\prime}\\) as the concatenation of \\(T\\), \\(\\emptyset\\), and the reverse of \\(T\\). Denote the length of \\(T^{\\prime}\\) by \\(n^{\\prime}=2n+1\\). Create the suffix array \\(SA\\) and \\(LCP\\) array \\(LCP\\) for \\(T^{\\prime}\\). Since the indices for a palindrome and its reverse appear in consecutive positions in the suffix array, find the entries with the maximum \\(LCP\\) value \\(LCP[i]\\) such that \\(SA[i-1]=n^{\\prime}-SA[i]-LCP[i]+2\\). (This constraint prevents a substring --and its reverse --from being construed as a palindrome unless it really is one.) For each such index \\(i\\), one of the longest palindromes is \\(T^{\\prime}[SA[i]:SA[i]+LCP[i]-1]\\).\n\nFor example, if the text \\(T\\) is unreferenced, with \\(n=12\\), then the text \\(T^{\\prime}\\) is unreferenced@decnreferranu, with \\(n^{\\prime}=25\\) and the following suffix array and LCP array:\n\n\\begin{tabular}{r|cAlas, this method is not foolproof. Give an input string \\(T\\) that causes this method to give results that are shorter than the longest palindrome contained within \\(T\\), and explain why your input causes the method to fail.\n\n## Problems\n\n### 32-1 String matching based on repetition factors\n\nLet \\(y^{i}\\) denote the concatenation of string \\(y\\) with itself \\(i\\) times. For example, \\((\\mathtt{ab})^{3}=\\mathtt{ababab}\\mathtt{ab}\\). We say that a string \\(x\\in\\Sigma^{*}\\) has _repetition factor_\\(r\\) if \\(x=y^{r}\\) for some string \\(y\\in\\Sigma^{*}\\) and some \\(r>0\\). Let \\(\\rho(x)\\) denote the largest \\(r\\) such that \\(x\\) has repetition factor \\(r\\).\n\n* Give an efficient algorithm that takes as input a pattern \\(P[1:m]\\) and computes the value \\(\\rho(P\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\! \\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\! \\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\! \\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\! \\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\! \\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\! \\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\! \\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\! \\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\! \\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\! \\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\! \\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\! \\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\! \\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\! \\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\! \\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\! \\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\! \\!\\!",
        "chapter": "Part VII Selected Topics",
        "section": "32 String Matching",
        "subsection": "32.5 Suffix arrays",
        "subsubsection": "N/A"
    },
    {
        "content": "Alas, this method is not foolproof. Give an input string \\(T\\) that causes this method to give results that are shorter than the longest palindrome contained within \\(T\\), and explain why your input causes the method to fail.\n\n## Problems\n\n### 32-1 String matching based on repetition factors\n\nLet \\(y^{i}\\) denote the concatenation of string \\(y\\) with itself \\(i\\) times. For example, \\((\\mathtt{ab})^{3}=\\mathtt{ababab}\\). We say that a string \\(x\\in\\Sigma^{*}\\) has _repetition factor_\\(r\\) if \\(x=y^{r}\\) for some string \\(y\\in\\Sigma^{*}\\) and some \\(r>0\\). Let \\(\\rho(x)\\) denote the largest \\(r\\) such that \\(x\\) has repetition factor \\(r\\).\n\n* Give an efficient algorithm that takes as input a pattern \\(P[1:m]\\) and computes the value \\(\\rho(P\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\! \\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\! \\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\! \\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\! \\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\! \\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\! \\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\! \\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\! \\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\! \\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\! \\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\! \\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\! \\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\! \\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\! \\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\! \\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\! \\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\! \\!\\!\n\n#### 32.2 A linear-time suffix-array algorithm\n\nIn this problem, you will develop and analyze a linear-time divide-and-conquer algorithm to compute the suffix array of a text \\(T[1:n]\\). As in Section 32.5, assume that each character in the text is represented by an underlying encoding, which is a positive integer.\n\nThe idea behind the linear-time algorithm is to compute the suffix array for the suffixes starting at \\(2/3\\) of the positions in the text, recursing as needed, use the resulting information to sort the suffixes starting at the remaining \\(1/3\\) of the positions, and then merge the sorted information in linear time to produce the full suffix array.\n\nFor \\(i=1,2,\\ldots,n\\), if \\(i\\mod 3\\) equals \\(1\\) or \\(2\\), then \\(i\\) is a _sample position_, and the suffixes starting at such positions are _sample suffixes_. Positions \\(3,6,9,\\ldots\\) are _non-sample positions_, and the suffixes starting at nonsample positions are _nonsample suffixes_.\n\nThe algorithm sorts the sample suffixes, sorts the nonsample suffixes (aided by the result of sorting the sample suffixes), and merges the sorted sample and non-sample suffixes. Using the example text \\(T=\\texttt{bipyboppityboo}\\), here is the algorithm in detail, listing substeps of each of the above steps:\n\n1. The sample suffixes comprise about \\(2/3\\) of the suffixes. Sort them by the following substeps, which work with a heavily modified version of \\(T\\) and may require recursion. In part (a) of this problem on page 999, you will show that the orders of the suffixes of \\(T\\) and the suffixes of the modified version of \\(T\\) are the same.\n2. Construct two texts \\(P_{1}\\) and \\(P_{2}\\) made up of \"metacharacters\" that are actually substrings of three consecutive characters from \\(T\\). We delimit each such metacharacter with parentheses. Construct \\(P_{1}=(T[1:3])\\)\\((T[4:6])\\)\\((T[7:9])\\cdots(T[n^{\\prime}:n^{\\prime}+2])\\), where \\(n^{\\prime}\\) is the largest integer congruent to \\(1\\), modulo \\(3\\), that is less than or equal to \\(n\\) and \\(T\\) is extended beyond position \\(n\\) with the special character \\(\\emptyset\\), with encoding \\(0\\). With the example text \\(T=\\texttt{bipyboppityboo}\\), we get that \\(P_{1}=(\\texttt{bip})\\)\\((\\texttt{pit})\\)\\((\\texttt{ybo})\\)\\((\\texttt{ppi})\\)\\((\\texttt{tvb})\\)\\((\\texttt{oo}\\emptyset)\\). Similarly, construct \\(P_{2}=(T[2:4])\\)\\((T[5:7])\\)\\((T[8:10])\\cdots(T[n^{\\prime\\prime}:n^{\\prime\\prime}+2])\\), where \\(n^{\\prime\\prime}\\) is the largest integer congruent to \\(2\\), modulo \\(3\\), that is less than or equal to \\(n\\). For our example, we have \\(P_{2}=(\\texttt{ipp})\\)\\((\\texttt{ity})\\)\\((\\texttt{bop})\\)\\((\\texttt{pit})\\)\\((\\texttt{ybo})\\)\\((\\texttt{oo}\\emptyset\\emptyset)\\).\n\nIf \\(n\\) is a multiple of 3, append the metacharacter (\\(\\emptyset\\emptyset\\emptyset\\)) to the end of \\(P_{1}\\). In this way, \\(P_{1}\\) is guaranteed to end with a metacharacter containing \\(\\emptyset\\). (This property helps in part (a) of this problem.) The text \\(P_{2}\\) may or may not end with a metacharacter containing \\(\\emptyset\\). B. Concatenate \\(P_{1}\\) and \\(P_{2}\\) to form a new text \\(P\\). Figure 32.15 shows \\(P\\) for our example, along with the corresponding positions of \\(T\\). C. Sort and rank the unique metacharacters of \\(P\\), with ranks starting from 1. In the example, \\(P\\) has 10 unique metacharacters: in sorted order, they are (bip), (bop), (ipp), (ity), (o\\(\\emptyset\\emptyset\\)), (o\\(\\emptyset\\)), (pit), (ppi), (tyb), (ybo). The metacharacters (pit) and (ybo) each appear twice. D. As Figure 32.15 shows, construct a new \"text\" \\(P^{\\prime}\\) by renaming each metacharacter in \\(P\\) by its rank. If \\(P\\) contains \\(k\\) unique metacharacters, then each \"character\" in \\(P^{\\prime}\\) is an integer from 1 to \\(k\\). The suffix arrays for \\(P\\) and \\(P^{\\prime}\\) are identical. E. Compute the suffix array \\(SA_{P^{\\prime}}\\) of \\(P^{\\prime}\\). If the characters of \\(P^{\\prime}\\) (i.e., the ranks of metacharacters in \\(P\\)) are unique, then you can compute its suffix array directly, since the ordering of the individual characters gives the suffix array. Otherwise, recurse to compute the suffix array of \\(P^{\\prime}\\), treating the ranks in \\(P^{\\prime}\\) as the input characters in the recursive call. Figure 32.15 shows the suffix array \\(SA_{P^{\\prime}}\\) for our example. Since the number of metacharacters in \\(P\\), and hence the length of \\(P^{\\prime}\\), is approximately \\(2n/3\\), this recursive subproblem is smaller than the current problem. F. From \\(SA_{P^{\\prime}}\\) and the positions in \\(T\\) corresponding to the sample positions, compute the list of positions of the sorted sample suffixes of the original text \\(T\\). Figure 32.15 shows the list of positions in \\(T\\) of the sorted sample suffixes in our example.\n2. The nonsample suffixes comprise about \\(1/3\\) of the suffixes. Using the sorted sample suffixes, sort the nonsample suffixes by the following substeps.\n\nFigure 32.15: Computed values when sorting the sample suffixes of the linear-time suffix-array algorithm for the text \\(T=\\texttt{bipipityboppityboo}\\).\n\nG. Extending the text \\(T\\) by the two special characters \\(\\varnothing\\varnothing\\), so that \\(T\\) now has \\(n+2\\) characters, consider each suffix \\(T[i:]\\) for \\(i=1,2,\\ldots,n+2\\). Assign a rank \\(r_{i}\\) to each suffix \\(T[i:]\\). For the two special characters \\(\\varnothing\\varnothing\\), set \\(r_{n+1}=r_{n+2}=0\\). For the sample positions of \\(T\\), base the rank on the list of sorted sample positions of \\(T\\). The rank is currently undefined for the nonsample positions of \\(T\\). For these positions, set \\(r_{i}=\\square\\). Figure 32.16 shows the ranks for \\(T=\\texttt{bipyboppitiyboo}\\) with \\(n=17\\). H. Sort the nonsample suffixes by comparing tuples \\((T[i],r_{i+1})\\). In our example, we get \\(T[15:]<T[12:]<T[9:]<T[3:]<T[6:]\\) because \\((\\texttt{b},6)<(\\texttt{i},10)<(\\texttt{o},9)<(\\texttt{p},8)<(\\texttt{t},12)\\).\n3. Merge the sorted sets of suffixes. From the sorted set of suffixes, determine the suffix array of \\(T\\).\n\nThis completes the description of a linear-time algorithm for computing suffix arrays. The following parts of this problem ask you to show that certain steps of this algorithm are correct and to analyze the algorithm's running time.\n\n_a._: Define a _nonempty suffix_ at position \\(i\\) of the text \\(P\\) created in substep B as all metacharacters from position \\(i\\) of \\(P\\) up to and including the first metacharacter of \\(P\\) in which \\(\\varnothing\\) appears or the end of \\(P\\). In the example shown in Figure 32.15, the nonempty suffixes of \\(P\\) starting at positions 1, 4, and 11 of \\(P\\) are \\((\\texttt{bip})\\,(\\texttt{pit})\\,(\\texttt{ybo})\\,(\\texttt{ppi})\\,(\\texttt{ tyb})\\,(\\texttt{oo}\\varnothing)\\), \\((\\texttt{ppi})\\,(\\texttt{tyb})\\,(\\texttt{oo}\\varnothing)\\), and \\((\\texttt{ybo})\\,(\\texttt{oo}\\varnothing)\\), respectively. Prove that the order of suffixes of \\(P\\) is the same as the order of its nonempty suffixes. Conclude that the order of suffixes of \\(P\\) gives the order of the sample suffixes of \\(T\\). (_Hint:_ If \\(P\\) contains duplicate metacharacters, consider separately the cases in which two suffixes both start in \\(P_{1}\\), both start in \\(P_{2}\\), and one starts in \\(P_{1}\\) and the other starts in \\(P_{2}\\). Use the property that \\(\\varnothing\\) appears in the last metacharacter of \\(P_{1}\\).) _b._: Show how to perform substep C in \\(\\Theta(n)\\) time, bearing in mind that in a recursive call, the characters in \\(T\\) are actually ranks in \\(P^{\\prime}\\) in the caller. _c._: Argue that the tuples in substep H are unique. Then show how to perform this substep in \\(\\Theta(n)\\) time.\n\nFigure 32.16: The ranks \\(r_{1}\\) through \\(r_{n+3}\\) for the text \\(T=\\texttt{bipyboppitiyboo}\\) with \\(n=17\\).\n\n* Consider two suffixes \\(T[i:]\\) and \\(T[j:]\\), where \\(T[i:]\\) is a sample suffix and \\(T[j:]\\) is a nonsample suffix. Show how to determine in \\(\\Theta(1)\\) time whether \\(T[i:]\\) is lexicographically smaller than \\(T[j:]\\). (_Hint:_ Consider separately the cases in which \\(i\\mod 3=1\\) and \\(i\\mod 3=2\\). Compare tuples whose elements are characters in \\(T\\) and ranks as shown in Figure 32.16. The number of elements per tuple may depend on whether \\(i\\mod 3\\) equals 1 or 2.) Conclude that step 3 can be performed in \\(\\Theta(n)\\) time.\n* Justify the recurrence \\(T(n)\\leq T(2n/3+2)+\\Theta(n)\\) for the running time of the full algorithm, and show that its solution is \\(O(n)\\). Conclude that the algorithm runs in \\(\\Theta(n)\\) time.\n\n### 32.3 Burrows-Wheeler transform\n\nThe _Burrows-Wheeler transform_, or _BWT_, for a text \\(T\\) is defined as follows. First, append a new character that compares as lexicographically less than every character of \\(T\\), and denote this character by \\(\\$\\) and the resulting string by \\(T^{\\prime}\\). Letting \\(n\\) be the length of \\(T^{\\prime}\\), create \\(n\\) rows of characters, where each row is one of the \\(n\\) cyclic rotations of \\(T^{\\prime}\\). Next, sort the rows lexicographically. The BWT is then the string of \\(n\\) characters in the rightmost column, read top to bottom.\n\nFor example, let \\(T=\\texttt{rutabaga}\\), so that \\(T^{\\prime}=\\texttt{rutabaga}\\$\\). The cyclic rotations are\n\n``` rutabaga$ vtabaga$r tabaga$r uabaga$rut baga$ruta aga$rutaba a$rutabag a$rutabag $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutabaga $rutab $rutabaga $rThe BWT is the rightmost column, agtbaa$ur. (The row numbering will be helpful in understanding how to compute the inverse BWT.)\n\nThe BWT has applications in bioinformatics, and it can also be a step in text compression. That is because it tends to place identical characters together, as in the BWT of rutabaga, which places two of the instances of a together. When identical characters are placed together, or even nearby, additional means of compressing become available. Following the BWT, combinations of move-to-front encoding, run-length encoding, and Huffman coding (see Section 15.3) can provide significant text compression. Compression ratios with the BWT tend improve as the text length increases.\n\n_a._ Given the suffix array for \\(T^{\\prime}\\), show how to compute the BWT in \\(\\Theta(n)\\) time.\n\nIn order to decompress, the BWT must be invertible. Assuming that the alphabet size is constant, the inverse BWT can be computed in \\(\\Theta(n)\\) time from the BWT. Let's look at the BWT of rutabaga, denoting it by \\(BWT[1:n]\\). Each character in the BWT has a unique lexicographic rank from 1 to \\(n\\). Denote the rank of \\(BWT[i]\\) by \\(rank[i]\\). If a character appears multiple times in the BWT, each instance of the character has a rank 1 greater than the previous instance of the character. Here are \\(BWT\\) and \\(rank\\) for rutabaga:\n\n\\[\\begin{array}{cccccccccccc}i&1&2&3&4&5&6&7&8&9\\\\ \\hline BWT[i]&\\mathtt{a}&\\mathtt{g}&\\mathtt{t}&\\mathtt{b}&\\mathtt{a}&\\mathtt{a }&\\mathtt{\\$}&\\mathtt{u}&\\mathtt{r}\\\\ rank[i]&2&6&8&5&3&4&1&9&7\\end{array}\\]\n\nFor example, \\(rank[1]=2\\) because \\(BWT[1]=\\mathtt{a}\\) and the only character that precedes the first a lexicographically is \\(\\$\\) (which we defined to precede all other characters, so that \\(\\$\\) has rank 1). Next, we have \\(rank[2]=6\\) because \\(BWT[2]=\\mathtt{g}\\) and five characters in the BWT precede g lexicographically: \\(\\$\\), the three instances of a, and b. Jumping ahead to \\(rank[5]=3\\), that is because \\(BWT[5]=\\mathtt{a}\\), and because this a is the second instance of a in the BWT, its \\(rank\\) value is 1 greater than the \\(rank\\) value for the previous instance of a, in position 1.\n\nThere is enough information in \\(BWT\\) and \\(rank\\) to reconstruct \\(T^{\\prime}\\) from back to front. Suppose that you know the rank \\(r\\) of a character \\(c\\) in \\(T^{\\prime}\\). Then \\(c\\) is the first character in row \\(r\\) of the sorted cyclic rotations. The last character in row \\(r\\) must be the character that precedes \\(c\\) in \\(T^{\\prime}\\). But you know which character is the last character in row \\(r\\), because it is \\(BWT[r]\\). To reconstruct \\(T^{\\prime}\\) from back to front, start with \\(\\$\\), which you can find in \\(BWT\\). Then work backward using \\(BWT\\) and \\(rank\\) to reconstruct \\(T^{\\prime}\\).\n\nLet's see how this strategy works for rutabaga. The last character of \\(T^{\\prime}\\), \\(\\$\\), appears in position 7 of \\(BWT\\). Since \\(rank[7]=1\\), row 1 of the sorted cyclic rotations of \\(T^{\\prime}\\) begins with \\(\\$\\). The character that precedes \\(\\$\\) in \\(T^{\\prime}\\) is the last character in row 1, which is \\(BWT[1]\\): \\(\\mathtt{a}\\). Now we know that the last two characters of are a$. Looking up _rank[1]_, it equals 2, so that row 2 of the sorted cyclic rotations of \\(T^{\\prime}\\) begins with a. The last character in row 2 precedes a in \\(T^{\\prime}\\), and that character is \\(BWT[2]=\\texttt{g}\\). Now we know that the last three characters of \\(T^{\\prime}\\) are ga$. Continuing on, we have \\(\\textit{rank}[2]=6\\), so that row 6 of the sorted cyclic rotations begins with g. The character preceding g in \\(T^{\\prime}\\) is \\(BWT[6]=\\texttt{a}\\), and so the last four characters of \\(T^{\\prime}\\) are aga$. Because \\(\\textit{rank}[6]=4\\), a begins row 4 of the sorted cyclic rotations of \\(T^{\\prime}\\). The character preceding a in \\(T^{\\prime}\\) is the last character in row 4, \\(BWT[4]=\\texttt{b}\\), and the last five characters of \\(T^{\\prime}\\) are baga$. And so on, until all \\(n\\) characters of \\(T^{\\prime}\\) have been identified, from back to front.\n* Given the array \\(BWT[1:n]\\), write pseudocode to compute the array \\(\\textit{rank}[1:n]\\) in \\(\\Theta(n)\\) time, assuming that the alphabet size is constant.\n* Given the arrays \\(BWT[1:n]\\) and \\(\\textit{rank}[1:n]\\), write pseudocode to compute \\(T^{\\prime}\\) in \\(\\Theta(n)\\) time.\n\n## Chapter notes\n\nThe relation of string matching to the theory of finite automata is discussed by Aho, Hopcroft, and Ullman [5]. The Knuth-Morris-Pratt algorithm [267] was invented independently by Knuth and Pratt and by Morris, but they published their work jointly. Matiyasevich [317] earlier discovered a similar algorithm, which applied only to an alphabet with two characters and was specified for a Turing machine with a two-dimensional tape. Reingold, Urban, and Gries [377] give an alternative treatment of the Knuth-Morris-Pratt algorithm. The Rabin-Karp algorithm was proposed by Karp and Rabin [250]. Galil and Seiferas [173] give an interesting deterministic linear-time string-matching algorithm that uses only \\(O(1)\\) space beyond that required to store the pattern and text.\n\nThe suffix-array algorithm in Section 32.5 is by Manber and Myers [312], who first proposed the notion of suffix arrays. The linear-time algorithm to compute the longest common prefix array presented here is by Kasai et al. [252]. Problem 32-2 is based on the DC3 algorithm by Karkkainen, Sanders, and Burkhardt [245]. For a survey of suffix-array algorithms, see the article by Puglisi, Smyth, and Turpin [370]. To learn more about the Burrows-Wheeler transform from Problem 32-3, see the articles by Burrows and Wheeler [78] and Manzini [314].",
        "chapter": "Part VII Selected Topics",
        "section": "32 String Matching",
        "subsection": "Problems",
        "subsubsection": "N/A"
    },
    {
        "content": "are a$. Looking up _rank[1]_, it equals 2, so that row 2 of the sorted cyclic rotations of \\(T^{\\prime}\\) begins with a. The last character in row 2 precedes a in \\(T^{\\prime}\\), and that character is \\(BWT[2]=\\texttt{g}\\). Now we know that the last three characters of \\(T^{\\prime}\\) are ga$. Continuing on, we have \\(\\textit{rank}[2]=6\\), so that row 6 of the sorted cyclic rotations begins with g. The character preceding g in \\(T^{\\prime}\\) is \\(BWT[6]=\\texttt{a}\\), and so the last four characters of \\(T^{\\prime}\\) are aga$. Because \\(\\textit{rank}[6]=4\\), a begins row 4 of the sorted cyclic rotations of \\(T^{\\prime}\\). The character preceding a in \\(T^{\\prime}\\) is the last character in row 4, \\(BWT[4]=\\texttt{b}\\), and the last five characters of \\(T^{\\prime}\\) are baga$. And so on, until all \\(n\\) characters of \\(T^{\\prime}\\) have been identified, from back to front.\n* Given the array \\(BWT[1:n]\\), write pseudocode to compute the array \\(\\textit{rank}[1:n]\\) in \\(\\Theta(n)\\) time, assuming that the alphabet size is constant.\n* Given the arrays \\(BWT[1:n]\\) and \\(\\textit{rank}[1:n]\\), write pseudocode to compute \\(T^{\\prime}\\) in \\(\\Theta(n)\\) time.\n\n## Chapter notes\n\nThe relation of string matching to the theory of finite automata is discussed by Aho, Hopcroft, and Ullman [5]. The Knuth-Morris-Pratt algorithm [267] was invented independently by Knuth and Pratt and by Morris, but they published their work jointly. Matiyasevich [317] earlier discovered a similar algorithm, which applied only to an alphabet with two characters and was specified for a Turing machine with a two-dimensional tape. Reingold, Urban, and Gries [377] give an alternative treatment of the Knuth-Morris-Pratt algorithm. The Rabin-Karp algorithm was proposed by Karp and Rabin [250]. Galil and Seiferas [173] give an interesting deterministic linear-time string-matching algorithm that uses only \\(O(1)\\) space beyond that required to store the pattern and text.\n\nThe suffix-array algorithm in Section 32.5 is by Manber and Myers [312], who first proposed the notion of suffix arrays. The linear-time algorithm to compute the longest common prefix array presented here is by Kasai et al. [252]. Problem 32-2 is based on the DC3 algorithm by Karkkainen, Sanders, and Burkhardt [245]. For a survey of suffix-array algorithms, see the article by Puglisi, Smyth, and Turpin [370]. To learn more about the Burrows-Wheeler transform from Problem 32-3, see the articles by Burrows and Wheeler [78] and Manzini [314].\n\nMachine learning may be viewed as a subfield of artificial intelligence. Broadly speaking, artificial intelligence aims to enable computers to carry out complex perception and information-processing tasks with human-like performance. The field of AI is vast and uses many different algorithmic methods.\n\nMachine learning is rich and fascinating, with strong ties to statistics and optimization. Technology today produces enormous amounts of data, providing myriad opportunities for machine-learning algorithms to formulate and test hypotheses about patterns within the data. These hypotheses can then be used to make predictions about the characteristics or classifications in new data. Because machine learning is particularly good with challenging tasks involving uncertainty, where observed data follows unknown rules, it has markedly transformed fields such as medicine, advertising, and speech recognition.\n\nThis chapter presents three important machine-learning algorithms: \\(k\\)-means clustering, multiplicative weights, and gradient descent. You can view each of these tasks as a learning problem, whereby an algorithm uses the data collected so far to produce a hypothesis that describes the regularities learned and/or makes predictions about new data. The boundaries of machine learning are imprecise and evolving--some might say that the \\(k\\)-means clustering algorithm should be called \"data science\" and not \"machine learning,\" and gradient descent, though an immensely important algorithm for machine learning, also has a multitude of applications outside of machine learning (most notably for optimization problems).\n\nMachine learning typically starts with a _training phase_ followed by a _prediction phase_ in which predictions are made about new data. For _online learning_, the training and prediction phases are intermingled. The training phase takes as input _training data_, where each input data point has an associated output or _label_; the label might be a category name or some real-valued attribute. It then produces as an output one or more _hypotheses_ about how the labels depend on the attributes of the input data points. Hypotheses can take many forms, typically some type of formula or algorithm. The learning algorithm used is often a form of gradient",
        "chapter": "Part VII Selected Topics",
        "section": "32 String Matching",
        "subsection": "Chapter notes",
        "subsubsection": "N/A"
    },
    {
        "content": "is often used as an initial step when working on a machine-learning problem to discover what structure exists in the data.\n\nSection 33.2 shows how to make online predictions quite accurately when you have a set of predictors, often called \"experts,\" to rely on, many of which might be poor predictors, but some of which are good predictors. At first, you do not know which predictors are poor and which are good. The goal is to make predictions on new examples that are nearly as good as the predictions made by the best predictor. We study an effective multiplicative-weights prediction method that associates a positive real weight with each predictor and multiplicatively decreases the weights associated with predictors when they make poor predictions. The model in this section is online (see Chapter 27): at each step, we do not know anything about the future examples. In addition, we are able to make predictions even in the presence of adversarial experts, who are collaborating against us, a situation that actually happens in game-playing settings.\n\nFinally, Section 33.3 introduces gradient descent, a powerful optimization technique used to find parameter settings in machine-learning models. Gradient descent also has many applications outside of machine learning. Intuitively, gradient descent finds the value that produces a local minimum for a function by \"walking downhill.\" In a learning application, a \"downhill step\" is a step that adjusts hypothesis parameters so that the hypothesis does better on the given set of labeled examples.\n\nThis chapter makes extensive use of vectors. In contrast to the rest of the book, vector names in this chapter appear in boldface, such as \\(\\mathbf{x}\\), to more clearly delineate which quantities are vectors. Components of vectors do not appear in boldface, so if vector \\(\\mathbf{x}\\) has \\(d\\) dimensions, we might write \\(\\mathbf{x}=(x_{1},x_{2},\\ldots,x_{d})\\).\n\n### Clustering\n\nSuppose that you have a large number of data points (examples), and you wish to group them into classes based on how similar they are to each other. For example, each data point might represent a celestial star, giving its temperature, size, and spectral characteristics. Or, each data point might represent a fragment of recorded speech. Grouping these speech fragments appropriately might reveal the set of accents of the fragments. Once a grouping of the training data points is found, new data can be placed into an appropriate group, facilitating star-type recognition or speech recognition.\n\nThese situations, along with many others, fall under the umbrella of clustering. The input to a _clustering_ problem is a set of \\(n\\) examples (objects) and an integer \\(k\\), with the goal of dividing the examples into at most \\(k\\) disjoint clusters such that the examples in each cluster are similar to each other. The clustering problem has several variations. For example, the integer \\(k\\) might not be given, but instead arises out of the clustering procedure. In this section we presume that \\(k\\) is given.\n\n##### Feature vectors and similarity\n\nLet's formally define the clustering problem. The input is a set of \\(n\\)_examples_. Each example has a set of _attributes_ in common with all other examples, though the attribute values may vary among examples. For example, the clustering problem shown in Figure 33.1 clusters \\(n=49\\) examples-- 48 state capitals plus the District of Columbia--into \\(k=4\\) clusters. Each example has two attributes: the latitude and longitude of the capital. In a given clustering problem, each example has \\(d\\) attributes, with an example \\(\\mathbf{x}\\) specified by a \\(d\\)-dimensional _feature vector_\n\n\\[\\mathbf{x}=(x_{1},x_{2},\\ldots,x_{d})\\.\\]\n\nHere, \\(x_{a}\\) for \\(a=1,2,\\ldots,d\\) is a real number giving the value of attribute \\(a\\) for example \\(\\mathbf{x}\\). We call \\(\\mathbf{x}\\) the _point_ in \\(\\mathbb{R}^{d}\\) representing the example. For the example in Figure 33.1, each capital \\(\\mathbf{x}\\) has its latitude in \\(x_{1}\\) and its longitude in \\(x_{2}\\).\n\nIn order to cluster similar points together, we need to define similarity. Instead, let's define the opposite: the _dissimilarity_\\(\\Delta(\\mathbf{x},\\mathbf{y})\\) of points \\(\\mathbf{x}\\) and \\(\\mathbf{y}\\) is the squared Euclidean distance between them:\n\n\\[\\Delta(\\mathbf{x},\\mathbf{y}) = \\left\\|\\mathbf{x}-\\mathbf{y}\\right\\|^{2} \\tag{33.1}\\] \\[= \\sum_{a=1}^{d}(x_{a}-y_{a})^{2}\\.\\]\n\nOf course, for \\(\\Delta(\\mathbf{x},\\mathbf{y})\\) to be well defined, all attribute values must be present. If any are missing, then you might just ignore that example, or you could fill in a missing attribute value with the median value for that attribute.\n\nThe attribute values are often \"messy\" in other ways, so that some \"data cleaning\" is necessary before the clustering algorithm is run. For example, the scale of attribute values can vary widely across attributes. In the example of Figure 33.1, the scales of the two attributes vary by a factor of 2, since latitude ranges from \\(-90\\) to \\(+90\\) degrees but longitude ranges from \\(-180\\) to \\(+180\\) degrees. You can imagine other scenarios where the differences in scales are even greater. If the examples contain information about students, one attribute might be grade-point average but another might be family income. Therefore, the attribute values are usually scaled or normalized, so that no single attribute can dominate the others when computing dissimilarities. One way to do so is by scaling attribute values with a linear transform so that the minimum value becomes 0 and the maximum value becomes 1. If the attribute values are binary values, then no scaling may be needed. Another\n\n### Clustering\n\nThe iterations of Lloyd's procedure when clustering the capitals of the lower 48 states and the District of Columbia into \\(k=4\\) clusters. Each capital has two attributes: latitude and longitude. Each iteration reduces the value \\(f\\), measuring the sum of squares of distances of all capitals to their cluster centers, until the value of \\(f\\) does not change. **(a)** The initial four clusters, with the capitals of Arkansas, Kansas, Louisiana, and Tennessee chosen as centers. **(b)-(k)** Iterations of Lloyd's procedure. **(l)** The 11th iteration results in the same value of \\(f\\) as the 10th iteration in part (k), and so the procedure terminates.\n\nFigure 33.1: The iterations of Lloyd\u2019s procedure when clustering the capitals of the lower 48 states and the District of Columbia into \\(k=4\\) clusters. Each capital has two attributes: latitude and longitude. Each iteration reduces the value \\(f\\), measuring the sum of squares of distances of all capitals to their cluster centers, until the value of \\(f\\) does not change. **(a)** The initial four clusters, with the capitals of Arkansas, Kansas, Louisiana, and Tennessee chosen as centers. **(b)-(k)** Iterations of Lloyd\u2019s procedure. **(l)** The 11th iteration results in the same value of \\(f\\) as the 10th iteration in part (k), and so the procedure terminates.\n\noption is scaling so that the values for each attribute have mean 0 and unit variance. Sometimes it makes sense to choose the same scaling rule for several related attributes (for example, if they are lengths measured to the same scale).\n\nAlso, the choice of dissimilarity measure is somewhat arbitrary. The use of the sum of squared differences as in equation (33.1) is not required, but it is a conventional choice and mathematically convenient. For the example of Figure 33.1, you might use the actual distance between capitals rather than equation (33.1).\n\n### Clusterings\n\nWith the notion of similarity (actually, _dis_similarity) defined, let's see how to define clusters of similar points. Let \\(S\\) denote the given set of \\(n\\) points in \\(\\mathbb{R}^{d}\\). In some applications the points are not necessarily distinct, so that \\(S\\) is a multiset rather than a set.\n\nBecause the goal is to create \\(k\\) clusters, we define a \\(k\\)_-clustering_ of \\(S\\) as a decomposition of \\(S\\) into a sequence \\(\\langle S^{(1)},S^{(2)},\\ldots,S^{(k)}\\rangle\\) of \\(k\\) disjoint subsets, or _clusters_, so that\n\n\\[S=S^{(1)}\\cup S^{(2)}\\cup\\cdots\\cup S^{(k)}\\.\\]\n\nA cluster may be empty, for example if \\(k>1\\) but all of the points in \\(S\\) have the same attribute values.\n\nThere are many ways to define a \\(k\\)-clustering of \\(S\\) and many ways to evaluate the quality of a given \\(k\\)-clustering. We consider here only \\(k\\)-clusterings of \\(S\\) that are defined by a sequence \\(C\\) of \\(k\\)_centers_\n\n\\[C=\\langle\\mathbf{c^{(1)}},\\mathbf{c^{(2)}},\\ldots,\\mathbf{c^{(k)}}\\rangle\\,\\]\n\nwhere each center is a point in \\(\\mathbb{R}^{d}\\), and the _nearest-center rule_ says that a point \\(\\mathbf{x}\\) may belong to cluster \\(S^{(\\ell)}\\) if the center of no other cluster is closer to \\(\\mathbf{x}\\) than the center \\(\\mathbf{c^{(\\ell)}}\\) of \\(S^{(\\ell)}\\):\n\n\\[\\mathbf{x}\\in S^{(\\ell)}\\ \\ \\mbox{only if}\\ \\ \\Delta(\\mathbf{x},\\mathbf{c^{(\\ell)} })=\\min\\left\\{\\Delta(\\mathbf{x},\\mathbf{c^{(j)}}):1\\leq j\\leq k\\right\\}\\.\\]\n\nA center can be anywhere, and not necessarily a point in \\(S\\).\n\nTies are possible and must be broken so that each point lies in exactly one cluster. In general, ties may be broken arbitrarily, although we'll need the property that we never change which cluster a point \\(\\mathbf{x}\\) is assigned to unless the distance from \\(\\mathbf{x}\\) to its new cluster center is _strictly smaller_ than the distance from \\(\\mathbf{x}\\) to its old cluster center. That is, if the current cluster has a center that is one of the closest cluster centers to \\(\\mathbf{x}\\), then don't change which cluster \\(\\mathbf{x}\\) is assigned to.\n\nThe \\(k\\)_-means problem_ is then the following: given a set \\(S\\) of \\(n\\) points and a positive integer \\(k\\), find a sequence \\(C=\\langle\\mathbf{c^{(1)}},\\mathbf{c^{(2)}},\\ldots,\\mathbf{c^{(k)}}\\rangle\\) of \\(k\\) center pointsminimizing the sum \\(f(S,C)\\) of the squared distance from each point to its nearest center, where\n\n\\[f(S,C) = \\sum_{{\\bf x}\\in S}\\min\\left\\{\\Delta({\\bf x},{\\bf c^{(\\it j)}}):1\\leq j \\leq k\\right\\} \\tag{33.2}\\] \\[= \\sum_{\\ell=1}^{k}\\sum_{{\\bf x}\\in S^{(\\ell)}}\\Delta({\\bf x},{\\bf c ^{(\\ell)}})\\.\\]\n\nIn the second line, the \\(k\\)-clustering \\(\\left\\langle S^{(1)},S^{(2)},\\ldots,S^{(k)}\\right\\rangle\\) is defined by the centers \\(C\\) and the nearest-center rule. See Exercise 33.1-1 for an alternative formulation based on pairwise interpoint distances.\n\nIs there a polynomial-time algorithm for the \\(k\\)-means problem? Probably not, because it is NP-hard [310]. As we'll see in Chapter 34, NP-hard problems have no known polynomial-time algorithm, but nobody has ever proven that polynomial-time algorithms for NP-hard problems cannot exist. Although we know of no polynomial-time algorithm that finds the global minimum over all clusterings (according to equation (33.2)), we _can_ find a local minimum.\n\nLloyd [304] proposed a simple procedure that finds a sequence \\(C\\) of \\(k\\) centers that yields a local minimum of \\(f(S,C)\\). A local minimum in the \\(k\\)-means problem satisfies two simple properties: each cluster has an optimal center (defined below), and each point is assigned to the cluster (or one of the clusters) with the closest center. Lloyd's procedure finds a good clustering--possibly optimal--that satisfies these two properties. These properties are necessary, but not sufficient, for optimality.\n\n#### Optimal center for a given cluster\n\nIn an optimal solution to the \\(k\\)-means problem, each center point must be the _centroid_, or _mean_, of the points in its cluster. The centroid is a \\(d\\)-dimensional point, where the value in each dimension is the mean of the values of all the points in the cluster in that dimension (that is, the mean of the corresponding attribute values in the cluster). That is, if \\({\\bf c^{(\\ell)}}\\) is the centroid for cluster \\(S^{(\\ell)}\\), then for attributes \\(a=1,2,\\ldots,d\\), we have\n\n\\[c_{a}^{(\\ell)}=\\frac{1}{|S^{(\\ell)}|}\\sum_{{\\bf x}\\in S^{(\\ell)}}x_{a}\\.\\]\n\nOver all attributes, we write\n\n\\[{\\bf c^{(\\ell)}}=\\frac{1}{|S^{(\\ell)}|}\\sum_{{\\bf x}\\in S^{(\\ell)}}{\\bf x}. \\tag{33.3}\\]\n\n**Theorem 33.1**: _Given a nonempty cluster \\(S^{(\\ell)}\\), its centroid (or mean) is the unique choice for the cluster center \\(\\mathbf{c^{(\\ell)}}\\in\\mathbb{R}^{d}\\) that minimizes_\n\n\\[\\sum_{\\mathbf{x}\\in S^{(\\ell)}}\\Delta(\\mathbf{x},\\mathbf{c^{(\\ell)}})\\.\\]\n\nWe wish to minimize, by choosing \\(\\mathbf{c^{(\\ell)}}\\in\\mathbb{R}^{d}\\), the sum\n\n\\[\\sum_{\\mathbf{x}\\in S^{(\\ell)}}\\Delta(\\mathbf{x},\\mathbf{c^{(\\ell) }}) = \\sum_{\\mathbf{x}\\in S^{(\\ell)}}\\sum_{a=1}^{d}(x_{a}-c_{a}^{(\\ell)}) ^{2}\\] \\[= \\sum_{a=1}^{d}\\Bigg{(}\\sum_{\\mathbf{x}\\in S^{(\\ell)}}x_{a}^{2}-2 \\left(\\sum_{\\mathbf{x}\\in S^{(\\ell)}}x_{a}\\right)c_{a}^{(\\ell)}+\\left|S^{(\\ell )}\\right|(c_{a}^{(\\ell)})^{2}\\Bigg{)}\\.\\]\n\nFor each attribute \\(a\\), the term summed is a convex quadratic function in \\(c_{a}^{(\\ell)}\\). To minimize this function, take its derivative with respect to \\(c_{a}^{(\\ell)}\\) and set it to \\(0\\):\n\n\\[-2\\sum_{\\mathbf{x}\\in S^{(\\ell)}}x_{a}+2\\left|S^{(\\ell)}\\right|c_{a}^{(\\ell)}=0\\]\n\nor, equivalently,\n\n\\[c_{a}^{(\\ell)}=\\frac{1}{|S^{(\\ell)}|}\\sum_{\\mathbf{x}\\in S^{(\\ell)}}x_{a}\\.\\]\n\nSince the minimum is obtained uniquely when each coordinate of \\(c_{a}^{(\\ell)}\\) is the average of the corresponding coordinate for \\(\\mathbf{x}\\in S^{(\\ell)}\\), the overall minimum is obtained when \\(\\mathbf{c^{(\\ell)}}\\) is the centroid of the points \\(\\mathbf{x}\\), as in equation (33.3).\n\n### Optimal clusters for given centers\n\nThe following theorem shows that the nearest-center rule--assigning each point \\(\\mathbf{x}\\) to one of the clusters whose center is nearest to \\(\\mathbf{x}\\)--yields an optimal solution to the \\(k\\)-means problem.\n\n**Theorem 33.2**: _Given a set \\(S\\) of \\(n\\) points and a sequence \\(\\langle\\mathbf{c^{(1)}},\\,\\mathbf{c^{(2)}},\\,\\ldots,\\,\\mathbf{c^{(k)}}\\rangle\\) of \\(k\\) centers, a clustering \\(\\langle S^{(1)},S^{(2)},\\ldots,S^{(k)}\\rangle\\) minimizes_\n\n\\[\\sum_{\\ell=1}^{k}\\sum_{\\mathbf{x}\\in S^{(\\ell)}}\\Delta(\\mathbf{x},\\mathbf{c^{ (\\ell)}}) \\tag{33.4}\\]\n\n_if and only if it assigns each point \\(\\mathbf{x}\\in S\\) to a cluster \\(S^{(\\ell)}\\) that minimizes \\(\\Delta(\\mathbf{x},\\mathbf{c^{(\\ell)}})\\).__Proof_ The proof is straightforward: each point \\({\\bf x}\\in S\\) contributes exactly once to the sum (33.4), and choosing to put \\({\\bf x}\\) in a cluster whose center is nearest minimizes the contribution from \\({\\bf x}\\).\n\n### Lloyd's procedure\n\nLloyd's procedure just iterates two operations--assigning points to clusters based on the nearest-center rule, followed by recomputing the centers of clusters to be their centroids--until the results converge. Here is Lloyd's procedure:\n\n**Input:** A set \\(S\\) of points in \\(\\mathbb{R}^{d}\\), and a positive integer \\(k\\).\n**Output:** A \\(k\\)-clustering \\(\\langle S^{(1)}\\), \\(S^{(2)}\\),..., \\(S^{(k)}\\rangle\\) of \\(S\\) with a sequence of centers \\(\\langle{\\bf c^{(1)}},{\\bf c^{(2)}},\\ldots,{\\bf c^{(k)}}\\rangle\\).\n\n1. **Initialize centers:** Generate an initial sequence \\(\\langle{\\bf c^{(1)}},{\\bf c^{(2)}},\\ldots,{\\bf c^{(k)}}\\rangle\\) of \\(k\\) centers by picking \\(k\\) points independently from \\(S\\) at random. (If the points are not necessarily distinct, see Exercise 33.1-3.) Assign all points to cluster \\(S^{(1)}\\) to begin.\n2. **Assign points to clusters:** Use the nearest-center rule to define the clustering \\(\\langle S^{(1)}\\), \\(S^{(2)},\\ldots,S^{(k)}\\rangle\\). That is, assign each point \\({\\bf x}\\in S\\) to a cluster \\(S^{(\\ell)}\\) having a nearest center (breaking ties arbitrarily, but not changing the assignment for a point \\({\\bf x}\\) unless the new cluster center is strictly closer to \\({\\bf x}\\) than the old one).\n3. **Stop if no change:** If step 2 did not change the assignments of any points to clusters, then stop and return the clustering \\(\\langle S^{(1)}\\), \\(S^{(2)}\\),..., \\(S^{(k)}\\rangle\\) and the associated centers \\(\\langle{\\bf c^{(1)}},{\\bf c^{(2)}},\\ldots,{\\bf c^{(k)}}\\rangle\\). Otherwise, go to step 4.\n4. **Recompute centers as centroids:** For \\(\\ell=1,2,\\ldots,k\\), compute the center \\({\\bf c^{(\\ell)}}\\) of cluster \\(S^{(\\ell)}\\) as the centroid of the points in \\(S^{(\\ell)}\\). (If \\(S^{(\\ell)}\\) is empty, let \\({\\bf c^{(\\ell)}}\\) be the zero vector.) Then go to step 2.\n\nIt is possible for some of the clusters returned to be empty, particularly if many of the input points are identical.\n\nLloyd's procedure always terminates. By Theorem 33.1, recomputing the centers of each cluster as the cluster centroid cannot increase \\(f(S,C)\\). Lloyd's procedure ensures that a point is reassigned to a different cluster only when such an operation strictly decreases \\(f(S,C)\\). Thus each iteration of Lloyd's procedure, except the last iteration, must strictly decrease \\(f(S,C)\\). Since there are only a finite number of possible \\(k\\)-clusterings of \\(S\\) (at most \\(k^{n}\\)), the procedure must terminate. Furthermore, once one iteration of Lloyd's procedure yields no decrease in \\(f\\), further iterations would not change anything, and the procedure can stop at this locally optimum assignment of points to clusters.\n\nIf Lloyd's procedure really required \\(k^{n}\\) iterations, it would be impractical. In practice, it sometimes suffices to terminate the procedure when the percentage decrease in \\(f(S,C)\\) in the latest iteration falls below a predetermined threshold. Because Lloyd's procedure is guaranteed to find only a locally optimal clustering, one approach to finding a good clustering is to run Lloyd's procedure many times with different randomly chosen initial centers, taking the best result.\n\nThe running time of Lloyd's procedure is proportional to the number \\(T\\) of iterations. In one iteration, assigning points to clusters based on the nearest-center rule requires \\(O(d\\,k\\,n)\\) time, and recomputing new centers for each cluster requires \\(O(d\\,n)\\) time (because each point is in one cluster). The overall running time of the \\(k\\)-means procedure is thus \\(O(Td\\,k\\,n)\\).\n\nLloyd's algorithm illustrates an approach common to many machine-learning algorithms:\n\n* First, define a hypothesis space in terms an appropriate sequence \\(\\theta\\) of parameters, so that each \\(\\theta\\) is associated with a specific hypothesis \\(h_{\\theta}\\). (For the \\(k\\)-means problem, \\(\\theta\\) is a \\(dk\\)-dimensional vector, equivalent to \\(C\\), containing the \\(d\\)-dimensional center of each of the \\(k\\) clusters, and \\(h_{\\theta}\\) is the hypothesis that each data point \\(\\mathbf{x}\\) should be grouped with a cluster having a center closest to \\(\\mathbf{x}\\).)\n* Second, define a measure \\(f(E,\\theta)\\) describing how poorly hypothesis \\(h_{\\theta}\\) fits the given training data \\(E\\). Smaller values of \\(f(E,\\theta)\\) are better, and a (locally) optimal solution (locally) minimizes \\(f(E,\\theta)\\). (For the \\(k\\)-means problem, \\(f(E,\\theta)\\) is just \\(f(S,C)\\).)\n* Third, given a set of training data \\(E\\), use a suitable optimization procedure to find a value of \\(\\theta^{*}\\) that minimizes \\(f(E,\\theta^{*})\\), at least locally. (For the \\(k\\)-means problem, this value of \\(\\theta^{*}\\) is the sequence \\(C\\) of \\(k\\) center points returned by Lloyd's algorithm.)\n* Return \\(\\theta^{*}\\) as the answer.\n\nIn this framework, we see that optimization becomes a powerful tool for machine learning. Using optimization in this way is flexible. For example, _regularization_ terms can be incorporated in the function to be minimized, in order to penalize hypotheses that are \"too complicated\" and that \"overfit\" the training data. (Regularization is a complex topic that isn't pursued further here.)\n\n##### Examples\n\nFigure 33.1 demonstrates Lloyd's procedure on a set of \\(n=49\\) cities: 48 U.S. state capitals and the District of Columbia. Each city has \\(d=2\\) dimensions: latitude and longitude. The initial clustering in part (a) of the figure has the initial cluster centers arbitrarily chosen as the capitals of Arkansas, Kansas, Louisiana,\n\nand Tennessee. As the procedure iterates, the value of the function \\(f\\) decreases, until the 11th iteration in part (I), where it remains the same as in the 10th iteration in part (k). Lloyd's procedure then terminates with the clusters shown in part (I).\n\nAs Figure 33.2 shows, Lloyd's procedure can also apply to \"vector quantization.\" Here, the goal is to reduce the number of distinct colors required to represent a photograph, thereby allowing the photograph to be greatly compressed (albeit in a lossy manner). In part (a) of the figure, an original photograph 700 pixels wide and 500 pixels high uses 24 bits (three bytes) per pixel to encode a triple of red, green, and blue (RGB) primary color intensities. Parts (b)-(e) of the figure show the results of using Lloyd's procedure to compress the picture from a initial space of \\(2^{24}\\) possible values per pixel to a space of only \\(k=4,k=16,k=64,\\) or \\(k=256\\) possible values per pixel; these \\(k\\) values are the cluster centers. The photograph can then be represented with only 2, 4, 6, or 8 bits per pixel, respectively, instead of the 24-bits per pixel needed by the initial photograph. An auxiliary table, the \"palette,\" accompanies the compressed image; it holds the \\(k\\) 24-bit cluster centers and is used to map each pixel value to its 24-bit cluster center when the photo is decompressed.\n\n##### Exercises\n\n_33.1-1_\n\nShow that the objective function \\(f(S,C)\\) of equation (33.2) may be alternatively written as\n\n\\[f(S,C)=\\sum_{\\ell=1}^{k}\\frac{1}{2\\left|S^{(\\ell)}\\right|}\\sum_{{\\bf x}\\in S^{ (\\ell)}}\\ \\sum_{{\\bf y}\\in S^{(\\ell)}:{\\bf x}\\neq{\\bf y}}\\Delta({\\bf x},{\\bf y})\\.\\]\n\n_33.1-2_\n\nGive an example in the plane with \\(n=4\\) points and \\(k=2\\) clusters where an iteration of Lloyd's procedure does not improve \\(f(S,C)\\), yet the \\(k\\)-clustering is not optimal.\n\n_33.1-3_\n\nWhen the input to Lloyd's procedure contains many repeated points, a different initialization procedure might be used. Describe a way to pick a number of centers at random that maximizes the number of distinct centers picked. (_Hint_: See Exercise 5.3-5.)\n\n_33.1-4_\n\nShow how to find an optimal \\(k\\)-clustering in polynomial time when there is just one attribute (\\(d=1\\)).\n\nFigure 33.2: Using Lloyd\u2019s procedure for vector quantization to compress a photo by using fewer colors. **(a)** The original photo has 350,000 pixels (\\(700\\times 500\\)), each a 24-bit RGB (red/blue/green) triple of 8-bit values; these pixels (colors) are the \u201cpoints\u201d to be clustered. Points repeat, so there are only 79,083 distinct colors (less than \\(2^{24}\\)). After compression, only \\(k\\) distinct colors are used, so each pixel is represented by only \\(\\lceil\\lg k\\rceil\\) bits instead of 24. A \u201cpalette\u201d maps these values back to 24-bit RGB values (the cluster centers). **(b)\u2013(e)** The same photo with \\(k=4\\), 16, 64, and 256 colors. (Photo from standpointpaddle, pixabay.com.)\n\n### Multiplicative-weights algorithms\n\nThis section considers problems that require you to make a series of decisions. After each decision you receive feedback as to whether your decision was correct. We will study a class of algorithms that are called _multiplicative-weights algorithms_. This class of algorithms has a wide variety of applications, including game playing in economics, approximately solving linear-programming and multicommodity-flow problems, and various applications in online machine learning. We emphasize the online nature of the problem here: you have to make a sequence of decisions, but some of the information needed to make the \\(i\\)th decision appears only after you have already made the \\((i-1)\\)st decision. In this section, we look at one particular problem, known as \"learning from experts,\" and develop an example of a multiplicative-weights algorithm, called the weighted-majority algorithm.\n\nSuppose that a series of events will occur, and you want to make predictions about these events. For example, over a series of days, you want to predict whether it is going to rain. Or perhaps you want to predict whether the price of a stock will increase or decrease. One way to approach this problem is to assemble a group of \"experts\" and use their collective wisdom in order to make good predictions. Let's denote the experts, \\(n\\) of them, by \\(E_{1}\\), \\(E_{2}\\), \\(\\ldots\\), \\(E_{n}\\), and let's say that \\(T\\) events are going to take place. Each event has an outcome of either \\(0\\) or \\(1\\), with \\(o^{(t)}\\) denoting the outcome of the \\(t\\)th event. Before event \\(t\\), each expert \\(E^{(i)}\\) makes a prediction \\(q_{i}^{(t)}\\in\\{0,1\\}\\). You, as the \"learner,\" then take the set of \\(n\\) expert predictions for event \\(t\\) and produce a single prediction \\(p^{(t)}\\in\\{0,1\\}\\) of your own. You base your prediction only on the predictions of the experts and anything you have learned about the experts from their previous predictions. You do not use any additional information about the event. Only after making your prediction do you ascertain the outcome \\(o^{(t)}\\) of event \\(t\\). If your prediction \\(p^{(t)}\\) matches \\(o^{(t)}\\), then you were correct; otherwise, you made a mistake. The goal is to minimize the total number \\(m\\) of mistakes, where \\(m=\\sum_{t=1}^{T}\\big{|}p^{(t)}-o^{(t)}\\big{|}\\). You can also keep track of the number of mistakes each expert makes: expert \\(E_{i}\\) makes \\(m_{i}\\) mistakes, where \\(m_{i}=\\sum_{t=1}^{T}\\big{|}q_{i}^{(t)}-o^{(t)}\\big{|}\\).\n\nFor example, suppose that you are following the price of a stock, and each day you decide whether to invest in it for just that day by buying it at the beginning of the day and selling it at the end of the day. If, on some day, you buy the stock and it goes up, then you made the correct decision, but if the stock goes down, then you made a mistake. Similarly, if on some day, you do not buy the stock and it goes down, then you made the correct decision, but if the stock goes up, then you made a mistake. Since you would like to make as few mistakes as possible, you use the advice of the experts to make your decisions.",
        "chapter": "Part VII Selected Topics",
        "section": "33 Machine-Learning Algorithms",
        "subsection": "33.1 Clustering",
        "subsubsection": "N/A"
    },
    {
        "content": "### Multiplicative-weights algorithms\n\nThis section considers problems that require you to make a series of decisions. After each decision you receive feedback as to whether your decision was correct. We will study a class of algorithms that are called _multiplicative-weights algorithms_. This class of algorithms has a wide variety of applications, including game playing in economics, approximately solving linear-programming and multicommodity-flow problems, and various applications in online machine learning. We emphasize the online nature of the problem here: you have to make a sequence of decisions, but some of the information needed to make the \\(i\\)th decision appears only after you have already made the \\((i-1)\\)st decision. In this section, we look at one particular problem, known as \"learning from experts,\" and develop an example of a multiplicative-weights algorithm, called the weighted-majority algorithm.\n\nSuppose that a series of events will occur, and you want to make predictions about these events. For example, over a series of days, you want to predict whether it is going to rain. Or perhaps you want to predict whether the price of a stock will increase or decrease. One way to approach this problem is to assemble a group of \"experts\" and use their collective wisdom in order to make good predictions. Let's denote the experts, \\(n\\) of them, by \\(E_{1}\\), \\(E_{2}\\), \\(\\ldots\\), \\(E_{n}\\), and let's say that \\(T\\) events are going to take place. Each event has an outcome of either \\(0\\) or \\(1\\), with \\(o^{(t)}\\) denoting the outcome of the \\(t\\)th event. Before event \\(t\\), each expert \\(E^{(i)}\\) makes a prediction \\(q_{i}^{(t)}\\in\\{0,1\\}\\). You, as the \"learner,\" then take the set of \\(n\\) expert predictions for event \\(t\\) and produce a single prediction \\(p^{(t)}\\in\\{0,1\\}\\) of your own. You base your prediction only on the predictions of the experts and anything you have learned about the experts from their previous predictions. You do not use any additional information about the event. Only after making your prediction do you ascertain the outcome \\(o^{(t)}\\) of event \\(t\\). If your prediction \\(p^{(t)}\\) matches \\(o^{(t)}\\), then you were correct; otherwise, you made a mistake. The goal is to minimize the total number \\(m\\) of mistakes, where \\(m=\\sum_{t=1}^{T}\\big{|}p^{(t)}-o^{(t)}\\big{|}\\). You can also keep track of the number of mistakes each expert makes: expert \\(E_{i}\\) makes \\(m_{i}\\) mistakes, where \\(m_{i}=\\sum_{t=1}^{T}\\big{|}q_{i}^{(t)}-o^{(t)}\\big{|}\\).\n\nFor example, suppose that you are following the price of a stock, and each day you decide whether to invest in it for just that day by buying it at the beginning of the day and selling it at the end of the day. If, on some day, you buy the stock and it goes up, then you made the correct decision, but if the stock goes down, then you made a mistake. Similarly, if on some day, you do not buy the stock and it goes down, then you made the correct decision, but if the stock goes up, then you made a mistake. Since you would like to make as few mistakes as possible, you use the advice of the experts to make your decisions.\n\nWe'll assume nothing about the movement of the stock. We'll also assume nothing about the experts: the experts' predictions could be correlated, they could be chosen to deceive you, or perhaps some are not really experts after all. What algorithm would you use?\n\nBefore designing an algorithm for this problem, we need to consider what is a fair way to evaluate our algorithm. It is reasonable to expect that our algorithm performs better when the expert predictions are better, and that it performs worse when the expert predictions are worse. The goal of the algorithm is to limit the number of mistakes you make to be close to the number of mistakes that the best of the experts makes. At first, this goal might seem impossible, because you do not know until the end which expert is best. We'll see, however, that by taking the advice provided by all the experts into account, you can achieve this goal. More formally, we use the notion of \"regret,\" which compares our algorithm to the performance of the best expert (in hindsight) over all. Letting \\(m^{*}=\\min\\left\\{m_{i}:1\\leq i\\leq n\\right\\}\\) denote the number of mistakes made by the best expert, the _regret_ is \\(m-m^{*}\\). The goal is to design an algorithm with low regret. (Regret can be negative, although it typically isn't, since it is rare that you do better than the best expert.)\n\nAs a warm-up, let's consider the case in which one of the experts makes a correct prediction each time. Even without knowing who that expert is, you can still achieve good results.\n\n_Lemma 33.3_\n\nSuppose that out of \\(n\\) experts, there is one who always makes the correct prediction for all \\(T\\) events. Then there is an algorithm that makes at most \\(\\left\\lceil\\lg n\\right\\rceil\\) mistakes.\n\nProofThe algorithm maintains a set \\(S\\) consisting of experts who have not yet made a mistake. Initially, \\(S\\) contains all \\(n\\) experts. The algorithm's prediction is always the majority vote of the predictions of the experts remaining in set \\(S\\). In case of a tie, the algorithm makes any prediction. After each outcome is learned, set \\(S\\) is updated to remove all the experts who made an incorrect prediction about that outcome.\n\nWe now analyze the algorithm. The expert who always makes the correct prediction will always be in set \\(S\\). Every time the algorithm makes a mistake, at least half of the experts who were still in \\(S\\) also make a mistake, and these experts are removed from \\(S\\). If \\(S^{\\prime}\\) is the set of experts remaining after removing those who made a mistake, we have that \\(\\left|S^{\\prime}\\right|\\leq\\left|S\\right|/2\\). The size of \\(S\\) can be halved at most \\(\\left\\lceil\\lg n\\right\\rceil\\) times until \\(\\left|S\\right|=1\\). From this point on, we know that the algorithm never makes a mistake, since the set \\(S\\) consists only of the one expert who never makes a mistake. Therefore, overall the algorithm makes at most \\(\\left\\lceil\\lg n\\right\\rceil\\) mistakes.\n\nExercise 33.2-1 asks you to generalize this result to the case when there is no expert who makes perfect predictions and show that, for any set of experts, there is an algorithm that makes at most \\(m^{*}\\left\\lceil\\lg n\\right\\rceil\\) mistakes. The generalized algorithm begins in the same way. The set \\(S\\) might become empty at some point, however. If that ever happens, reset \\(S\\) to contain all the experts and continue the algorithm.\n\nYou can substantially improve your prediction ability by not just tracking which experts have not made any mistakes, or have not made any mistakes recently, to a more nuanced evaluation of the quality of each expert. The key idea is to use the feedback you receive to update your evaluation of how much trust to put in each expert. As the experts make predictions, you observe whether they were correct and decrease your confidence in the experts who make more mistakes. In this way, you can learn over time which experts are more reliable and which are less reliable, and weight their predictions accordingly. The change in weights is accomplished via multiplication, hence the term \"multiplicative weights.\"\n\nThe algorithm appears in the procedure Weighted-Majority on the following page, which takes a set \\(E=\\{E_{1},\\,E_{2},\\ldots,E_{n}\\}\\) of experts, a number \\(T\\) of events, the number \\(n\\) of experts, and a parameter \\(0<\\gamma\\leq 1/2\\) that controls how the weights change. The algorithm maintains weights \\(w_{i}^{(t)}\\) for \\(i=1,2,\\ldots,n\\) and \\(t=1,2,\\ldots,T\\), where \\(0<w_{i}^{(t)}\\leq 1\\). The **for** loop of lines 1-2 sets the initial weights \\(w_{i}^{(1)}\\) to 1, capturing the idea that with no knowledge, you trust each expert equally. Each iteration of the main **for** loop of lines 3-18 does the following for an event \\(t=1,2,\\ldots,T\\). Each expert \\(E_{i}\\) makes a prediction for event \\(t\\) in line 4. Lines 5-8 compute \\(upweight^{(t)}\\), the sum of the weights of the experts who predict 1 for event \\(t\\), and \\(downweight^{(t)}\\), the sum of the weights of the experts who predict 0 for the event. Lines 9-11 decide the algorithm's prediction \\(p^{(t)}\\) for event \\(t\\) based on whichever weighted sum is larger (breaking ties in favor of deciding 1). The outcome of event \\(t\\) is revealed in line 12. Finally, lines 14-17 decrease the weights of the experts who made an incorrect prediction for event \\(t\\) by multiplying their weights by \\(1-\\gamma\\), leaving alone the weights of the experts who correctly predicted the event's outcome. Thus, the fewer mistakes each expert makes, the higher that expert's weight.\n\nThe Weighted-Majority procedure doesn't do much worse than any expert. In particular, it doesn't do much worse than the best expert. To quantify this claim, let \\(m^{(t)}\\) be the number of mistakes made by the procedure through event \\(t\\), and let \\(m_{i}^{(t)}\\) be the number of mistakes made by expert \\(E_{i}\\) through event \\(t\\). The following theorem is the key.\n\n**Theorem 33.4**: _When running Weighted-Majority, we have, for every expert \\(E_{i}\\) and every event \\(T^{\\prime}\\leq T\\),_\n\n\\[m^{(T^{\\prime})}\\leq 2(1+\\gamma)m_{i}^{(T^{\\prime})}+\\frac{2\\ln n}{\\gamma}. \\tag{33.5}\\]\n\n_Proof_ Every time an expert \\(E_{i}\\) makes a mistake, its weight, which is initially \\(1\\), is multiplied by \\(1-\\gamma\\), and so we have\n\n\\[w_{i}^{(t)}=(1-\\gamma)^{m_{i}^{(t)}} \\tag{33.6}\\]\n\nfor \\(t=1,2,\\ldots,T\\).\n\nWe use a potential function \\(W(t)=\\sum_{i=1}^{n}w_{i}^{(t)}\\), summing the weights for all \\(n\\) experts after iteration \\(t\\) of the **for** loop of lines 3-18. Initially, we have \\(W(0)=n\\) since all \\(n\\) weights start out with the value \\(1\\). Because each expert belongs to either the set \\(U\\) or the set \\(D\\) (defined in lines 5 and 7 of Weighted-Majority), we always have \\(W(t)=upweight^{(t)}+downweight^{(t)}\\) after each execution of line 8.\n\nConsider an iteration \\(t\\) in which the algorithm makes a mistake in its prediction, which means that either the algorithm predicts \\(1\\) and the outcome is \\(0\\) or the al gorithm predicts 0 and the outcome is 1. Without loss of generality, assume that the algorithm predicts 1 and the outcome is 0. The algorithm predicted 1 because \\(\\mathit{upweight}^{(t)}\\geq\\mathit{downweight}^{(t)}\\) in line 9, which implies that\n\n\\[\\mathit{upweight}^{(t)}\\geq W(t)/2. \\tag{33.7}\\]\n\nEach expert in \\(U\\) then has its weight multiplied by \\(1-\\gamma\\), and each expert in \\(D\\) has its weight unchanged. Thus, we have\n\n\\[W(t\\,+\\,1) = \\mathit{upweight}^{(t)}(1-\\gamma)\\,+\\mathit{downweight}^{(t)}\\] \\[= \\mathit{upweight}^{(t)}+\\mathit{downweight}^{(t)}-\\gamma\\cdot \\mathit{upweight}^{(t)}\\] \\[= W(t)-\\gamma\\cdot\\mathit{upweight}^{(t)}\\] \\[\\leq W(t)-\\gamma\\,\\frac{W(t)}{2}\\qquad\\text{(by inequality (\\ref{eq:w1}))}\\] \\[= W(t)(1-\\gamma/2)\\]\n\nTherefore, for every iteration \\(t\\) in which the algorithm makes a mistake, we have\n\n\\[W(t\\,+\\,1)\\leq(1-\\gamma/2)W(t) \\tag{33.8}\\]\n\nIn an iteration where the algorithm does not make a mistake, some of the weights decrease and some remain unchanged, so that we have\n\n\\[W(t\\,+\\,1)\\leq W(t). \\tag{33.9}\\]\n\nSince there are \\(m^{(T^{\\prime})}\\) mistakes made through iteration \\(T^{\\prime}\\), and \\(W(1)=n\\), we can repeatedly apply inequality (33.8) to iterations where the algorithm makes a mistake and inequality (33.9) to iterations where the algorithm does not make a mistake, obtaining\n\n\\[W(T^{\\prime})\\leq n(1-\\gamma/2)^{m^{(T^{\\prime})}}. \\tag{33.10}\\]\n\nBecause the function \\(W\\) is the sum of the weights and all weights are positive, its value exceeds any single weight. Therefore, using equation (33.6) we have, for any expert \\(E_{i}\\) and for any iteration \\(T^{\\prime}\\leq T\\),\n\n\\[W(T^{\\prime})\\geq w_{i}^{(T^{\\prime})}=(1-\\gamma)^{m_{i}^{(T^{\\prime})}}. \\tag{33.11}\\]\n\nCombining inequalities (33.10) and (33.11) gives\n\n\\[(1-\\gamma)^{m_{i}^{(T^{\\prime})}}\\leq n(1-\\gamma/2)^{m^{(T^{\\prime})}}\\.\\]\n\nTaking the natural logarithm of both sides yields\n\n\\[m_{i}^{(T^{\\prime})}\\ln(1-\\gamma)\\leq m^{(T^{\\prime})}\\ln(1-\\gamma/2)\\,+\\ln n. \\tag{33.12}\\]We now use the Taylor series expansion to derive upper and lower bounds on the logarithmic factors in inequality (33.12). The Taylor series for \\(\\ln(1+x)\\) is given in equation (3.22) on page 67. Substituting \\(-x\\) for \\(x\\), we have that for \\(0<x\\leq 1/2\\),\n\n\\[\\ln(1-x)=-x-\\frac{x^{2}}{2}-\\frac{x^{3}}{3}-\\frac{x^{4}}{4}-\\cdots. \\tag{33.13}\\]\n\nSince each term on the right-hand side is negative, we can drop all terms except the first and obtain an upper bound of \\(\\ln(1-x)\\leq-x\\). Since \\(0<\\gamma\\leq 1/2\\), we have\n\n\\[\\ln(1-\\gamma/2)\\leq-\\gamma/2 \\tag{33.14}\\]\n\nFor the lower bound, Exercise 33.2-2 asks you to show that \\(\\ln(1-x)\\geq-x-x^{2}\\) when \\(0<x\\leq 1/2\\), so that\n\n\\[-\\gamma-\\gamma^{2}\\leq\\ln(1-\\gamma). \\tag{33.15}\\]\n\nThus, we have\n\n\\[m_{l}^{(T^{\\prime})}(-\\gamma-\\gamma^{2}) \\leq m_{l}^{(T^{\\prime})}\\ln(1-\\gamma)\\] (by inequality (33.15)) \\[\\leq m^{(T^{\\prime})}\\ln(1-\\gamma/2)+\\ln n\\] (by inequality (33.12) \\[\\leq m^{(T^{\\prime})}(-\\gamma/2)+\\ln n\\] (by inequality (33.14)), so that \\[m_{l}^{(T^{\\prime})}(-\\gamma-\\gamma^{2})\\leq m^{(T^{\\prime})}(-\\gamma/2)+\\ln n. \\tag{33.16}\\]\n\nSubtracting \\(\\ln n\\) from both sides of inequality (33.16) and then multiplying both sides by \\(-2/\\gamma\\) yields \\(m^{(T^{\\prime})}\\leq 2(1+\\gamma)m_{l}^{(T^{\\prime})}+(2\\ln n)/\\gamma\\), thus proving the theorem.\n\nTheorem 33.4 applies to any expert and any event \\(T^{\\prime}\\leq T\\). In particular, we can compare against the best expert after all events have occurred, producing the following corollary.\n\n**Corollary 33.5**: At the end of procedure Weighted-Majority, we have\n\n\\[m^{(T)}\\leq 2(1+\\gamma)m^{*}+\\frac{2\\ln n}{\\gamma}. \\tag{33.17}\\]\n\nLet's explore this bound. Assuming that \\(\\sqrt{\\ln n/m^{*}}\\leq 1/2\\), we can choose \\(\\gamma=\\sqrt{\\ln n/m^{*}}\\) and plug into inequality (33.17) to obtain \n\n#### 33.2 Multiplicative-weights algorithms\n\n\\[m^{(T)} \\leq 2\\left(1+\\sqrt{\\frac{\\ln n}{m^{*}}}\\right)m^{*}+\\frac{2\\ln n}{ \\sqrt{\\ln n/m^{*}}}\\] \\[= 2m^{*}+2\\sqrt{m^{*}\\ln n}+2\\sqrt{m^{*}\\ln n}\\] \\[= 2m^{*}+4\\sqrt{m^{*}\\ln n}\\,\\]\n\nand so the number of errors is at most twice the number of errors made by the best expert plus a term that is often slower growing than \\(m^{*}\\). Exercise 33.2-4 shows that you can decrease the bound on the number of errors by a factor of \\(2\\) by using randomization, which leads to much stronger bounds. In particular, the upper bound on regret \\((m-m^{*})\\) is reduced from \\((1+2\\gamma)m^{*}+(2\\ln n)/\\gamma\\) to an expected value of \\(\\epsilon\\,m^{*}+(\\ln n)/\\epsilon\\), where both \\(\\gamma\\) and \\(\\epsilon\\) are at most \\(1/2\\). Numerically, we can see that if \\(\\gamma=1/2\\), Weighted-Majority makes at most \\(3\\) times the number of errors as the best expert, plus \\(4\\ln n\\) errors. As another example, suppose that \\(T=1000\\) predictions are being made by \\(n=20\\) experts, and the best expert is correct \\(95\\%\\) of the time, making \\(50\\) errors. Then Weighted-Majority makes at most \\(100(1+\\gamma)+2\\ln 20/\\gamma\\) errors. By choosing \\(\\gamma=1/4\\), Weighted-Majority makes at most \\(149\\) errors, or a success rate of at least \\(85\\%\\).\n\nMultiplicative weights methods typically refer to a broader class of algorithms that includes Weighted-Majority. The outcomes and predictions need not be only \\(0\\) or \\(1\\), but can be real numbers, and there can be a loss associated with a particular outcome and prediction. The weights can be updated by a multiplicative factor that depends on the loss, and the algorithm can, given a set of weights, treat them as a distribution on experts and use them to choose an expert to follow in each event. Even in these more general settings, bounds similar to Theorem 33.4 hold.\n\n#### Exercises\n\n#### 33.2-1\n\nThe proof of Lemma 33.3 assumes that some expert never makes a mistake. It is possible to generalize the algorithm and analysis to remove this assumption. The new algorithm begins in the same way. The set \\(S\\) might become empty at some point, however. If that ever happens, reset \\(S\\) to contain all the experts and continue the algorithm. Show that the number of mistakes that this algorithm makes is at most \\(m^{*}\\left\\lceil\\lg n\\right\\rceil\\).\n\n#### 33.2-2\n\nShow that \\(\\ln(1-x)\\geq-x-x^{2}\\) when \\(0<x\\leq 1/2\\). (_Hint:_ Start with equation (33.13), group all the terms after the first three, and use equation (A.7) on page 1142.)\n\n#### 33.2-3\n\nConsider a randomized variant of the algorithm given in the proof of Lemma 33.3, in which some expert never makes a mistake. At each step, choose an expert \\(E_{i}\\) uniformly at random from the set \\(S\\) and then make the same predication as \\(E_{i}\\). Show that the expected number of mistakes made by this algorithm is \\(\\lceil\\lg n\\rceil\\).\n\n#### 33.2-4\n\nConsider a randomized version of Weighted-Majority. The algorithm is the same, except for the prediction step, which interprets the weights as a probability distribution over the experts and chooses an expert \\(E_{i}\\) according to that distribution. It then chooses its prediction to be the same as the prediction made by expert \\(E_{i}\\). Show that, for any \\(0<\\epsilon<1/2\\), the expected number of mistakes made by this algorithm is at most \\((1+\\epsilon)m^{*}+(\\ln n)/\\epsilon\\).\n\n### Gradient descent\n\nSuppose that you have a set \\(\\{p_{1},\\,p_{2},\\ldots,p_{n}\\}\\) of points and you want to find the line that best fits these points. For any line \\(\\ell\\), there is a distance \\(d_{i}\\) between each point \\(p_{i}\\) and the line. You want to find the line that minimizes some function \\(f(d_{1},\\ldots,d_{n})\\). There are many possible choices for the definition of distance and for the function \\(f\\). For example, the distance can be the projection distance to the line and the function can be the sum of the squares of the distances. This type of problem is common in data science and machine learning--the line is the hypothesis that best describes the data--where the particular definition of best is determined by the definition of distance and the objective \\(f\\). If the definition of distance and the function \\(f\\) are linear, then we have a linear-programming problem, as discussed in Chapter 29. Although the linear-programming framework captures several important problems, many other problems, including various machine-learning problems, have objectives and constraints that are not necessarily linear. We need frameworks and algorithms to solve such problems.\n\nIn this section, we consider the problem of optimizing a continuous function and discuss one of the most popular methods to do so: gradient descent. Gradient descent is a general method for finding a local minimum of a function \\(f:\\mathbb{R}^{n}\\rightarrow\\mathbb{R}\\), where informally, a local minimum of a function \\(f\\) is a point \\(\\mathbf{x}\\) for which \\(f(\\mathbf{x})\\leq f(\\mathbf{x}^{\\prime})\\) for all \\(\\mathbf{x}^{\\prime}\\) that are \"near\" \\(\\mathbf{x}\\). When the function is convex, it can find a point near the _global minimizer_ of \\(f\\): an \\(n\\)-vector argument \\(\\mathbf{x}=(x_{1},x_{2},\\ldots,x_{n})\\) such that \\(f(\\mathbf{x})\\) is minimum. For the intuitive idea behind gradient descent, imagine being in a landscape of hills and valleys, and wanting to get to a low point as quickly as possible. You survey the terrain and choose to",
        "chapter": "Part VII Selected Topics",
        "section": "33 Machine-Learning Algorithms",
        "subsection": "33.2 Multiplicative-weights algorithms",
        "subsubsection": "N/A"
    },
    {
        "content": "#### 33.2-3\n\nConsider a randomized variant of the algorithm given in the proof of Lemma 33.3, in which some expert never makes a mistake. At each step, choose an expert \\(E_{i}\\) uniformly at random from the set \\(S\\) and then make the same predication as \\(E_{i}\\). Show that the expected number of mistakes made by this algorithm is \\(\\lceil\\lg n\\rceil\\).\n\n#### 33.2-4\n\nConsider a randomized version of Weighted-Majority. The algorithm is the same, except for the prediction step, which interprets the weights as a probability distribution over the experts and chooses an expert \\(E_{i}\\) according to that distribution. It then chooses its prediction to be the same as the prediction made by expert \\(E_{i}\\). Show that, for any \\(0<\\epsilon<1/2\\), the expected number of mistakes made by this algorithm is at most \\((1+\\epsilon)m^{*}+(\\ln n)/\\epsilon\\).\n\n### Gradient descent\n\nSuppose that you have a set \\(\\{p_{1},\\,p_{2},\\ldots,p_{n}\\}\\) of points and you want to find the line that best fits these points. For any line \\(\\ell\\), there is a distance \\(d_{i}\\) between each point \\(p_{i}\\) and the line. You want to find the line that minimizes some function \\(f(d_{1},\\ldots,d_{n})\\). There are many possible choices for the definition of distance and for the function \\(f\\). For example, the distance can be the projection distance to the line and the function can be the sum of the squares of the distances. This type of problem is common in data science and machine learning--the line is the hypothesis that best describes the data--where the particular definition of best is determined by the definition of distance and the objective \\(f\\). If the definition of distance and the function \\(f\\) are linear, then we have a linear-programming problem, as discussed in Chapter 29. Although the linear-programming framework captures several important problems, many other problems, including various machine-learning problems, have objectives and constraints that are not necessarily linear. We need frameworks and algorithms to solve such problems.\n\nIn this section, we consider the problem of optimizing a continuous function and discuss one of the most popular methods to do so: gradient descent. Gradient descent is a general method for finding a local minimum of a function \\(f:\\mathbb{R}^{n}\\rightarrow\\mathbb{R}\\), where informally, a local minimum of a function \\(f\\) is a point \\(\\mathbf{x}\\) for which \\(f(\\mathbf{x})\\leq f(\\mathbf{x}^{\\prime})\\) for all \\(\\mathbf{x}^{\\prime}\\) that are \"near\" \\(\\mathbf{x}\\). When the function is convex, it can find a point near the _global minimizer_ of \\(f\\): an \\(n\\)-vector argument \\(\\mathbf{x}=(x_{1},x_{2},\\ldots,x_{n})\\) such that \\(f(\\mathbf{x})\\) is minimum. For the intuitive idea behind gradient descent, imagine being in a landscape of hills and valleys, and wanting to get to a low point as quickly as possible. You survey the terrain and choose tomove in the direction that takes you downhill the fastest from your current position. You move in that direction, but only for a short while, because as you proceed, the terrain changes and you might need to choose a different direction. So you stop, reevaluate the possible directions and move another short distance in the steepest downhill direction, which might differ from the direction of your previous movement. You continue this process until you reach a point from which all directions lead up. Such a point is a local minimum.\n\nIn order to make this informal procedure more formal, we need to define the gradient of a function, which in the analogy above is a measure of the steepness of the various directions. Given a function \\(f:\\mathbb{R}^{n}\\to\\mathbb{R}\\), its _gradient_\\(\\nabla f\\) is a function \\(\\nabla f:\\mathbb{R}^{n}\\to\\mathbb{R}^{n}\\) comprising \\(n\\) partial derivatives: \\((\\nabla f)(\\mathbf{x})=\\left(\\frac{\\partial f}{\\partial x_{1}},\\frac{\\partial f }{\\partial x_{2}},\\ldots,\\frac{\\partial f}{\\partial x_{n}}\\right)\\). Analogous to the derivative of a function of a single variable, the gradient can be viewed as a direction in which the function value locally increases the fastest, and the rate of that increase. This view is informal; in order to make it formal we would have to define what local means and place certain conditions, such as continuity or existence of derivatives, on the function. Nevertheless, this view motivates the key step of gradient descent--move in the direction opposite to the gradient, by a distance influenced by the magnitude of the gradient.\n\nThe general procedure of gradient descent proceeds in steps. You start at some initial point \\(\\mathbf{x^{(0)}}\\), which is an \\(n\\)-vector. At each step \\(t\\), you compute the value of the gradient of \\(f\\) at point \\(\\mathbf{x^{(t)}}\\), that is, \\((\\nabla f)(\\mathbf{x^{(t)}})\\), which is also an \\(n\\)-vector. You then move in the direction opposite to the gradient in each dimension at \\(\\mathbf{x^{(t)}}\\) to arrive at the next point \\(\\mathbf{x^{(t+1)}}\\), which again is an \\(n\\)-vector. Because you moved in a monotonically decreasing direction in each dimension, you should have that \\(f(\\mathbf{x^{(t+1)}})\\leq f(\\mathbf{x^{(t)}})\\). Several details are needed to turn this idea into an actual algorithm. The two main details are that you need an initial point and that you need to decide how far to move in the direction of the negative gradient. You also need to understand when to stop and what you can conclude about the quality of the solution found. We will explore these issues further in this section, for both constrained minimization, where there are additional constraints on the points, and unconstrained minimization, where there are none.\n\n### Unconstrained gradient descent\n\nIn order to gain intuition, let's consider unconstrained gradient descent in just one dimension, that is, when \\(f\\) is a function of a scalar \\(x\\), so that \\(f:\\mathbb{R}\\to\\mathbb{R}\\). In this case, the gradient \\(\\nabla f\\) of \\(f\\) is just \\(f^{\\prime}(x)\\), the derivative of \\(f\\) with respect to \\(x\\). Consider the function \\(f\\) shown in blue in Figure 33.3, with minimizer \\(x^{*}\\) and starting point \\(x^{(0)}\\). The gradient (derivative) \\(f^{\\prime}(x^{(0)})\\), shown in orange, has a negative slope, so that a small step from \\(x^{(0)}\\) in the direction of increasing \\(x\\) results in a point \\(x^{\\prime}\\) for which \\(f(x^{\\prime})<f(x^{(0)})\\). Too large a step, however, results in a point \\(x^{\\prime\\prime}\\) for which \\(f(x^{\\prime\\prime})>f(x^{(0)})\\), so this is a bad idea. Restricting ourselves to small steps, where each one has \\(f(x^{\\prime})<f(x)\\), eventually results in getting close to point \\(\\widehat{x}\\), which gives a local minimum. By taking only small downhill steps, however, gradient descent has no chance to get to the global minimizer \\(x^{*}\\), given the starting point \\(x^{(0)}\\).\n\nWe draw two observations from this simple example. First, gradient descent converges toward a local minimum, and not necessarily a global minimum. Second, the speed at which it converges and how it behaves are related to properties of the function, to the initial point, and to the step size of the algorithm.\n\nThe procedure Gradient-Descent on the facing page takes as input a function \\(f\\), an initial point \\(\\mathbf{x^{(0)}}\\in\\mathbb{R}^{n}\\), a fixed step-size multiplier \\(\\gamma>0\\), and a number \\(T>0\\) of steps to take. Each iteration of the **for** loop of lines 2-4 performs a step by computing the \\(n\\)-dimensional gradient at point \\(\\mathbf{x^{(t)}}\\) and then moving distance \\(\\gamma\\) in the opposite direction in the \\(n\\)-dimensional space. The complexity of computing the gradient depends on the function \\(f\\) and can sometimes be expensive. Line 3 sums the points visited. After the loop terminates, line 6 returns \\(\\mathbf{x}\\)-\\(\\mathbf{avg}\\), the average of all the points visited except for the last one, \\(\\mathbf{x^{(T)}}\\). It might seem more natural to return \\(\\mathbf{x^{(T)}}\\), and in fact, in many circumstances, you might prefer to have the function return \\(\\mathbf{x^{(T)}}\\). For the version we will analyze, however, we use \\(\\mathbf{x}\\)-\\(\\mathbf{avg}\\).\n\n#### Gradient-Descent\\((f,\\mathbf{x^{(0)}},\\gamma,T)\\)\n\n\\(\\mathbf{sum}=0\\)\\(\\mathbf{//}\\)\\(n\\)-dimensional vector, initially all \\(0\\)\n\n\\(\\mathbf{sum}=\\mathbf{sum}+\\mathbf{x^{(t)}}\\)\\(\\mathbf{//}\\) add each of \\(n\\) dimensions into \\(\\mathbf{sum}\\)\\(\\mathbf{x^{(t+1)}}=\\mathbf{x^{(t)}}-\\gamma\\cdot(\\nabla f)(\\mathbf{x^{(t)}})\\)\\(\\mathbf{//}\\)\\((\\nabla f)(\\mathbf{x^{(t)}})\\)\\(\\mathbf{x^{(t+1)}}\\) are \\(n\\)-dimensional\\(\\mathbf{x}\\)-\\(\\mathbf{avg}=\\mathbf{sum}/\\,T\\)\\(\\mathbf{//}\\) divide each of \\(n\\) dimensions by \\(T\\)\n\n\\(\\mathbf{return}\\)\\(\\mathbf{x}\\)-\\(\\mathbf{avg}\\)\n\nFigure 33.4 depicts how gradient descent ideally runs on a convex 1-dimensional function.1 We'll define convexity more formally below, but the figure shows that each iteration moves in the direction opposite to the gradient, with the distance moved being proportional to the magnitude of the gradient. As the iterations proceed, the magnitude of the gradient decreases, and thus the distance moved along the horizontal axis decreases. After each iteration, the distance to the optimal point \\(\\mathbf{x^{*}}\\) decreases. This ideal behavior is not guaranteed to occur in general, but the analysis in the remainder of this section formalizes when this behavior occurs and quantifies the number of iterations needed. Gradient descent does not always work, however. We have already seen that if the function is not convex, gradient descent can converge to a local, rather than global, minimum. We have also seen that if the step size is too large, Gradient-Descent can overshoot the minimum and wind up farther away. (It is also possible to overshoot the minimum and wind up closer to the optimum.)\n\nFootnote 1: Although the curve in Figure 33.4 looks concave, according to the definition of convexity that we\u2019ll see below, the function \\(f\\) in the figure is convex.\n\n#### Analysis of unconstrained gradient descent for convex functions\n\nOur analysis of gradient descent focuses on convex functions. Inequality (C.29) on page 1194 defines a convex function of one variable, as shown in Figure 33.5. We can extend that definition to a function \\(f:\\mathbb{R}^{n}\\rightarrow\\mathbb{R}\\) and say that \\(f\\) is _convex_ if for all \\(\\mathbf{x},\\mathbf{y}\\in\\mathbb{R}^{n}\\) and for all \\(0\\leq\\lambda\\leq 1\\), we have\n\n\\[f(\\lambda\\mathbf{x}+(1-\\lambda)\\mathbf{y})\\leq\\lambda\\zeta\\ \\mathbf{x})+(1- \\lambda)\\zeta\\ \\mathbf{y}). \\tag{33.18}\\]\n\n(Inequalities (33.18) and (C.29) are the same, except for the dimensions of \\(\\mathbf{x}\\) and \\(\\mathbf{y}\\).) We also assume that our convex functions are closed2 and differentiable.\n\nFootnote 2: A function \\(f:\\mathbb{R}^{n}\\rightarrow\\mathbb{R}\\) is closed if, for each \\(\\alpha\\in\\mathbb{R}\\), the set \\(\\{\\mathbf{x}\\in\\text{dom}(f):f(\\mathbf{x})\\leq\\alpha\\}\\) is closed, where \\(\\text{dom}(f)\\) is the domain of \\(f\\).\n\nA convex function has the property that any local minimum is also a global minimum. To verify this property, consider inequality (33.18), and suppose for the purpose of contradiction that \\(\\mathbf{x}\\) is a local minimum but not a global minimum and \\(\\mathbf{y}\\neq\\mathbf{x}\\) is a global minimum, so \\(f(\\mathbf{y})<f(\\mathbf{x})\\). Then we have\n\n\\[f(\\lambda\\mathbf{x}+(1-\\lambda)\\mathbf{y}) \\leq \\lambda\\zeta\\ \\mathbf{x})+(1-\\lambda)\\zeta\\ \\mathbf{y})\\quad(\\text{by inequality (\\ref{eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq: eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eqeq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eqeq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eqeq:eq:eq:eqeq:eq:eq:eq:eq:eqeq:eq:eq:eq:eqeq:eq:eq:eq:eq:eq:eq:eq:eq:eqeq:eq:eq:eq:eq:eq:eqeq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eqeq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eq:eqeq:eq:eq:eq:eq:eq:eqeq:eq:eq:eq:eq:eq:eq:eq:eq:eqeq:eq:eq:eq:eq:eqeq:eq:eq:eqeq:eq:eq:eq:eq:eq:eq:eq:eq:eqeq:eq:eqeq:eq:eq:eq:eq:eq:eqeq:eqeq:eqeq:eq:eqeq:eq:eq:eq:eqeq:eq:eq:eq:eq:eqeq:eq:eqeq:eq:eq:eqeq:eq:eq:eq:eqeq:eq:eqeq:eq:eqeq:eq:eqeq:eq:eqeq:eq:eqeq:eqeq:eqeq:eqeq:eq:eqeq:eqeq:eqeq:eqeq:eqeq:eqeqeq:eqeq:eqeq:eqeq:eqeq:eqeq:eqeq:eqeqeq:eqeqeq:eqeqeq:eqeq:eqeqeq:eqeqeq:eqeqeq:eqeqeq:eqeqeq:eqeqeq:eqeqeq:eqeq:eqeqeqeq:eqeqeq:eqeqeq:eqeqeq:eqeqeqeq:eqeqeq:eqeqeqeq:eqeqeq:eqeqeq:eqeqeq:eqeqeq:eqeqeq:eqeqeq:eqeq:eqeqeqeq:eqeqeq:eqeqeq:eqeqeq:eqeqeqeq:eqeqeqeq:eqeq:eqeqeq:eqeqeqeq:eqeqeq:eqeqeq:eqeqeqeq:eqeqeqeq:eqeqeqeq:eqeqeqeqeq:eqeqeqeq:eqeqeqeq:eqeqeqeq:eqeqeqeq:eqeqeqeqeq:eqeqeqeqeq:eqeqeqeq:eqeqeqeqeq:eqeqeqeqeq:eqeqeqeq:eqeqeqeqeq:eqeqeqeqeq:eqeqeqeqeq:eqeqeqeqeq:eqeqeqeqeq:eqeqeqeqeq:eqeqeqeqeq:eqeqeqeqeq:eqeqeqeqeq:eqeqeqeqeq:eqeqeqeqeqeq:eqeqeqeqeqeqeq:eqeqeqeqeq:eqeqeqeqeq:eqeqeqeqeqeq:eqeqeqeqeqeq:eqeqeqeq:eqeqeqeqeqeqeqeq:eqeqeqeqeqeq:eqeqeqeqeqeqeq:eqeqeqeq:eqeqeqeqeqeqeq:eqeqeqeqeqeqeq:eqeqeqeqeqeqeq:eqeqeqeqeq:eqeqeqeqeqeqeqeq:eqeqeqeqeqeqeq:eqeqeqeqeqeq:eqeqeqeqeqeqeq:eqeqeqeqeqeqeqeq:eqeqeqeqeqeqeq:eqeqeqeqeqeqeqeqeq:eqeqeqeqeqeqeq:eqeqeqeqeqeqeqeqeq:eqeqeqeqeqeqeqeq:eqeqeqeqeqeqeq:eqeqeqeqeqeqeqeq:eqeqeqeqeqeqeq:eqeqeqeqeqeqeqeq:eqeqeqeqeqeqeqeq:eqeqeqeqeqeqeqeqeqeqeq:eqeqeqeqeqeqeqeqeq:eqeqeqeqeqeqeqeqeqeqeq:eqeqeqeqeqeqeqeqeq:eqeqeqeqeqeqeqeqeq:eqeqeqeqeqeqeqeqeqeqeq:eqeqeqeqeqeqeqeqeqeqeqeq:eqeqeqeqeqeqeqeqeqeqeqeq:eqeqeqeqeqeqeqeqeqeqeqeq:eqeqeqeqeqeqeqeq:eqeqeqeqeqeqeqeqeqeq:eqeqeqeqeqeqeqeqeq:eqeqeqeqeqeqeqeqeqeqeqeqeqeqeq:eqeqeqeqeqeqeqeqeqeq:eqeqeqeqeqeqeqeqeqeqeqeq:Thus, letting \\(\\lambda\\) approach 1, we see that there is another point near \\({\\bf x}\\), say \\({\\bf x}^{\\prime}\\), such that \\(f({\\bf x}^{\\prime})<f({\\bf x})\\), so \\({\\bf x}\\) is not a local minimum.\n\nConvex functions have several useful properties. The first property, whose proof we leave as Exercise 33.3-1, says that a convex function always lies above its tangent hyperplane. In the context of gradient descent, angle brackets denote the notation for inner product defined on page 1219 rather than denoting a sequence.\n\n**Lemma 33.6**: _For any convex differentiable function \\(f:\\mathbb{R}^{n}\\to\\mathbb{R}\\) and for all \\(x\\), \\(y\\in\\mathbb{R}^{n}\\), we have \\(f({\\bf x})\\leq f({\\bf y})+\\langle(\\nabla f)({\\bf x}),{\\bf x}-{\\bf y}\\rangle\\)._\n\nThe second property, which Exercise 33.3-2 asks you to prove, is a repeated application of the definition of convexity in inequality (33.18).\n\n**Lemma 33.7**: _For any convex function \\(f:\\mathbb{R}^{n}\\to\\mathbb{R}\\), for any integer \\(T\\geq 1\\), and for all \\({\\bf x^{(0)},\\ldots,{\\bf x^{(T-1)}}}\\in\\mathbb{R}^{n}\\), we have_\n\n\\[f\\left(\\frac{{\\bf x^{(0)}+\\cdots+x^{(T-1)}}}{T}\\right)\\leq\\frac{f({\\bf x^{(0 )}})+\\cdots+\\,f({\\bf x^{(T-1)}})}{T}. \\tag{33.19}\\]\n\nThe left-hand side of inequality (33.19) is the value of \\(f\\) at the vector \\({\\bf x}\\)-\\({\\bf avg}\\) that Gradient-Descent returns.\n\nWe now proceed to analyze Gradient-Descent. It might not return the exact global minimizer \\({\\bf x}^{*}\\). We use an error bound \\(\\epsilon\\), and we want to choose \\(T\\) so that \\(f({\\bf x}\\mbox{-}{\\bf avg})-f({\\bf x}^{*})\\leq\\epsilon\\) at termination. The value of \\(\\epsilon\\) depends on the number \\(T\\) of iterations and two additional values. First, since you expect it to be better to start close to the global minimizer, \\(\\epsilon\\) is a function of\n\n\\[R=\\|{\\bf x^{(0)}-x^{*}}\\|\\, \\tag{33.20}\\]\n\nthe euclidean norm (or distance, defined on page 1219) of the difference between \\({\\bf x^{(0)}}\\) and \\({\\bf x^{*}}\\). The error bound \\(\\epsilon\\) is also a function of a quantity we call \\(L\\), which is an upper bound on the magnitude \\(\\|(\\nabla f)({\\bf x})\\|\\) of the gradient, so that\n\n\\[\\|(\\nabla f)({\\bf x})\\|\\leq L\\, \\tag{33.21}\\]\n\nwhere \\({\\bf x}\\) ranges over all the points \\({\\bf x^{(0)},\\ldots,x^{(T-1)}}\\) whose gradients are computed by Gradient-Descent. Of course, we don't know the values of \\(L\\) and \\(R\\), but for now let's assume that we do. We'll discuss later how to remove these assumptions. The analysis of Gradient-Descent is summarized in the following theorem.\n\n**Theorem 33.8**: Let \\({\\bf x}^{*}\\in\\mathbb{R}^{n}\\) be the minimizer of a convex function \\(f\\), and suppose that an execution of Gradient-Descent\\((f,{\\bf x^{(0)}},\\gamma,T)\\) returns \\({\\bf x}\\)-avg, where \\(\\gamma=R/(L\\sqrt{T})\\) and \\(R\\) and \\(L\\) are defined in equations (33.20) and (33.21). Let \\(\\epsilon=RL/\\sqrt{T}\\). Then we have \\(f({\\bf x}\\mbox{-avg})-f({\\bf x}^{*})\\leq\\epsilon\\).\n\nWe now prove this theorem. We do not give an absolute bound on how much progress each iteration makes. Instead, we use a potential function, as in Section 16.3. Here, we define a potential \\(\\Phi(t)\\) after computing \\({\\bf x^{(t)}}\\), such that \\(\\Phi(t)\\geq 0\\) for \\(t=0,\\ldots,T\\). We define the _amortized progress_ in the iteration that computes \\({\\bf x^{(t)}}\\) as\n\n\\[p(t)=f({\\bf x^{(t)}})-f({\\bf x^{*}})+\\Phi(t+1)-\\Phi(t). \\tag{33.22}\\]\n\nAlong with including the change in potential \\((\\Phi(t+1)-\\Phi(t))\\), equation (33.22) also subtracts the minimum value \\(f({\\bf x^{*}})\\) because ultimately, you care not about the values \\(f({\\bf x^{(t)}})\\) but about how close they are to \\(f({\\bf x^{*}})\\). Suppose that we can show that \\(p(t)\\leq B\\) for some value \\(B\\) and \\(t=0,\\ldots,T-1\\). Then we can substitute for \\(p(t)\\) using equation (33.22), giving\n\n\\[f({\\bf x^{(t)}})-f({\\bf x^{*}})\\leq B-\\Phi(t+1)+\\Phi(t). \\tag{33.23}\\]\n\nSumming inequality (33.23) over \\(t=0,\\ldots,T-1\\) yields\n\n\\[\\sum_{t=0}^{T-1}(f({\\bf x^{(t)}})-f({\\bf x^{*}}))\\leq\\sum_{t=0}^{T-1}(B-\\Phi(t +1)+\\Phi(t))\\.\\]\n\nObserving that we have a telescoping series on the right and regrouping terms, we have that\n\n\\[\\left(\\sum_{t=0}^{T-1}f({\\bf x^{(t)}})\\right)-T\\cdot f({\\bf x^{*}})\\leq TB- \\Phi(T)+\\Phi(0)\\.\\]\n\nDividing by \\(T\\) and dropping the positive term \\(\\Phi(T)\\) gives\n\n\\[\\frac{\\sum_{t=0}^{T-1}f({\\bf x^{(t)}})}{T}-f({\\bf x^{*}})\\leq B\\,+\\,\\frac{\\Phi (0)}{T}\\, \\tag{33.24}\\]\n\nand thus we have\n\n\\[f({\\bf x}\\mbox{-avg})-f({\\bf x^{*}}) = f\\left(\\frac{\\sum_{t=0}^{T-1}{\\bf x^{(t)}}}{T}\\right)-f({\\bf x^ {*}})\\ \\ \\mbox{(by the definition of ${\\bf x}$-avg})\\] (33.25) \\[\\leq \\frac{\\sum_{t=0}^{T-1}f({\\bf x^{(t)}})}{T}-f({\\bf x^{*}})\\ \\ \\ \\ \\ \\mbox{(by Lemma \\ref{lem:x-avg})}\\] \\[\\leq B\\,+\\,\\frac{\\Phi(0)}{T}\\\n\n#### Gradient descent\n\nIn other words, if we can show that \\(p(t)\\leq B\\) for some value \\(B\\) and choose a potential function where \\(\\Phi(0)\\) is not too large, then inequality (33.25) tells us how close the function value \\(f(\\mathbf{x}\\mathbf{-avg})\\) is to the function value \\(f(\\mathbf{x}^{*})\\) after \\(T\\) iterations. That is, we can set the error bound \\(\\epsilon\\) to \\(B\\,+\\,\\Phi(0)/\\,T\\).\n\nIn order to bound the amortized progress, we need to come up with a concrete potential function. Define the potential function \\(\\Phi(t)\\) by\n\n\\[\\Phi(t)=\\frac{\\left\\|\\mathbf{x}^{(t)}-\\mathbf{x}^{*}\\right\\|^{2}}{2\\gamma}\\, \\tag{33.26}\\]\n\nthat is, the potential function is proportional to the square of the distance between the current point and the minimizer \\(\\mathbf{x}^{*}\\). With this potential function in hand, the next lemma provides a bound on the amortized progress made in any iteration of Gradient-Descent.\n\n**Lemma 33.9**: _Let \\(\\mathbf{x}^{*}\\in\\mathbb{R}^{n}\\) be the minimizer of a convex function \\(f\\), and consider an execution of Gradient-Descent\\((f,\\mathbf{x}^{(0)},\\gamma,T)\\). Then for each point \\(\\mathbf{x}^{(t)}\\) computed by the procedure, we have that_\n\n\\[p(t)=f(\\mathbf{x}^{(t)})-f(\\mathbf{x}^{*})+\\Phi(t+1)-\\Phi(t)\\leq\\frac{\\gamma L ^{2}}{2}\\.\\]\n\nProofWe first bound the potential change \\(\\Phi(t+1)-\\Phi(t)\\). Using the definition of \\(\\Phi(t)\\) from equation (33.26), we have\n\n\\[\\Phi(t+1)-\\Phi(t)=\\frac{1}{2\\gamma}\\left\\|\\mathbf{x}^{(t+1)}-\\mathbf{x}^{*} \\right\\|^{2}-\\frac{1}{2\\gamma}\\left\\|\\mathbf{x}^{(t)}-\\mathbf{x}^{*}\\right\\| ^{2}. \\tag{33.27}\\]\n\nFrom line 4 in Gradient-Descent, we know that\n\n\\[\\mathbf{x}^{(t+1)}-\\mathbf{x}^{(t)}=-\\gamma\\cdot(\\nabla f)(\\mathbf{x}^{(t)})\\, \\tag{33.28}\\]\n\nand so we would like to rewrite equation (33.27) to have \\(\\mathbf{x}^{(t+1)}-\\mathbf{x}^{(t)}\\) terms. As Exercise 33.3-3 asks you to prove, for any two vectors \\(\\mathbf{a},\\mathbf{b}\\in\\mathbb{R}^{n}\\), we have\n\n\\[\\left\\|\\mathbf{a}+\\mathbf{b}\\right\\|^{2}-\\left\\|\\mathbf{a}\\right\\|^{2}=2 \\langle\\mathbf{b},\\mathbf{a}\\rangle+\\left\\|\\mathbf{b}\\right\\|^{2}. \\tag{33.29}\\]\n\nLetting \\(\\mathbf{a}=\\mathbf{x}^{(t)}-\\mathbf{x}^{*}\\) and \\(\\mathbf{b}=\\mathbf{x}^{(t+1)}-\\mathbf{x}^{(t)}\\), we can write the right-hand side of equation (33.27) as \\(\\frac{1}{2\\gamma}\\left(\\left\\|\\mathbf{a}+\\mathbf{b}\\right\\|^{2}-\\left\\| \\mathbf{a}\\right\\|^{2}\\right)\\). Then we can express the potential change as\\[\\Phi(t\\,+\\,1)-\\Phi(t)\\] \\[=\\,\\frac{1}{2\\gamma}\\,\\left\\|{\\bf x^{(t+1)}-x^{*}}\\right\\|^{2}-\\frac{ 1}{2\\gamma}\\,\\left\\|{\\bf x^{(t)}-x^{*}}\\right\\|^{2}\\] (by equation (33.27)) \\[=\\,\\frac{1}{2\\gamma}\\,\\left(2\\langle{\\bf x^{(t+1)}-x^{(t)},x^{(t)} -x^{*}}\\rangle+\\left\\|{\\bf x^{(t+1)}-x^{(t)}}\\right\\|^{2}\\right)\\] (by equation (33.29)) \\[=\\,\\frac{1}{2\\gamma}\\,\\left(2\\langle-\\gamma\\cdot(\\nabla f)({\\bf x^ {(t)}}),{\\bf x^{(t)}-x^{*}}\\rangle\\,+\\left\\|-\\gamma\\cdot(\\nabla f)({\\bf x^{(t)} })\\right\\|^{2}\\right)\\] (by equation (33.28)) \\[=\\,-\\langle(\\nabla f)({\\bf x^{(t)}}),{\\bf x^{(t)}-x^{*}}\\rangle+ \\frac{\\gamma}{2}\\,\\left\\|(\\nabla f)({\\bf x^{(t)}})\\right\\|^{2}\\] (33.30) (by equation (D.3) on page 1219) \\[\\leq\\,-(f({\\bf x^{(t)}})-f({\\bf x^{*}}))+\\frac{\\gamma}{2}\\,\\left\\|( \\nabla f)({\\bf x^{(t)}})\\right\\|^{2}\\] (by Lemma 33.6), and thus we have \\[\\Phi(t\\,+\\,1)-\\Phi(t)\\leq-(f({\\bf x^{(t)}})-f({\\bf x^{*}}))+\\frac{\\gamma}{2} \\,\\left\\|(\\nabla f)({\\bf x^{(t)}})\\right\\|^{2} \\tag{33.31}\\]\n\nWe can now proceed to bound \\(p(t).\\) By the bound on the potential change from inequality (33.31), and using the definition of \\(L\\) (inequality (33.21)), we have\n\n\\[p(t) =\\,f({\\bf x^{(t)}})-f({\\bf x^{*}})+\\Phi(t\\,+\\,1)-\\Phi(t)\\] (by equation (33.22)) \\[\\leq\\,f({\\bf x^{(t)}})-f({\\bf x^{*}})-(f({\\bf x^{(t)}})-f({\\bf x^{ *}}))+\\frac{\\gamma}{2}\\,\\left\\|(\\nabla f)({\\bf x^{(t)}})\\right\\|^{2}\\] (by inequality (33.31)) \\[=\\,\\frac{\\gamma}{2}\\,\\left\\|(\\nabla f)({\\bf x^{(t)}})\\right\\|^{2}\\] (by inequality (33.21)) \\[\\leq\\,\\frac{\\gamma L^{2}}{2}\\] (by inequality (33.21)).\n\nHaving bounded the amortized progress in one step, we now analyze the entire Gradient-Descent procedure, completing the proof of Theorem 33.8.\n\nProof of Theorem 33.8.: Inequality (33.25) tells us that if we have an upper bound of \\(B\\) for \\(p(t),\\) then we also have the bound \\(f({\\bf x}\\mbox{-}{\\bf avg})-f({\\bf x^{*}})\\leq B+\\Phi(0)/T.\\) By equations (33.20) and (33.26), we have that \\(\\Phi(0)=R^{2}/(2\\gamma).\\) Lemma 33.9 gives us the upper bound of \\(B=\\gamma L^{2}/2,\\) and so we have\n\n\\[f({\\bf x}\\mbox{-}{\\bf avg})-f({\\bf x^{*}}) \\leq\\,\\,B\\,+\\frac{\\Phi(0)}{T}\\] (by inequality (33.25)) \\[=\\,\\frac{\\gamma L^{2}}{2}+\\frac{R^{2}}{2\\gamma T}\\.\\]Our choice of \\(\\gamma=R/(L\\sqrt{T})\\) in the statement of Theorem 33.8 balances the two terms, and we obtain\n\n\\[\\frac{\\gamma L^{2}}{2}+\\frac{R^{2}}{2\\gamma T} = \\frac{R}{L\\sqrt{T}}\\cdot\\frac{L^{2}}{2}+\\frac{R^{2}}{2T}\\cdot\\frac {L\\sqrt{T}}{R}\\] \\[= \\frac{RL}{2\\sqrt{T}}+\\frac{RL}{2\\sqrt{T}}\\] \\[= \\frac{RL}{\\sqrt{T}}\\.\\]\n\nSince we chose \\(\\epsilon=RL/\\sqrt{T}\\) in the theorem statement, the proof is complete.\n\nContinuing under the assumption that we know \\(R\\) (from equation (33.20)) and \\(L\\) (from inequality (33.21)), we can think of the analysis in a slightly different way. We can presume that we have a target accuracy \\(\\epsilon\\) and then compute the number of iterations needed. That is, we can solve \\(\\epsilon=RL/\\sqrt{T}\\) for \\(T\\), obtaining \\(T=R^{2}L^{2}/\\epsilon^{2}\\). The number of iterations thus depends on the square of \\(R\\) and \\(L\\) and, most importantly, on \\(1/\\epsilon^{2}\\). (The definition of \\(L\\) from inequality (33.21) depends on \\(T\\), but we may know an upper bound on \\(L\\) that doesn't depend on the particular value of \\(T\\).) Thus, if you want to halve your error bound, you need to run four times as many iterations.\n\nIt is quite possible that we don't really know \\(R\\) and \\(L\\), since you'd need to know \\(\\mathbf{x^{*}}\\) in order to know \\(R\\) (since \\(R=\\|\\mathbf{x^{(0)}}-\\mathbf{x^{*}}\\|\\)), and you might not have an explicit upper bound on the gradient, which would provide \\(L\\). You can, however, interpret the analysis of gradient descent as a proof that there is some step size for which the procedure makes progress toward the minimum. You can then compute a step size \\(\\gamma\\) for which \\(f(\\mathbf{x^{(\\prime)}})-f(\\mathbf{x^{(\\prime+1)}})\\) is large enough. In fact, not having a fixed step size multiplier can actually help in practice, as you are free to use any step size \\(s\\) that achieves sufficient decrease in the value of \\(f\\). You can search for a step size that achieves a large decrease via a binary-search-like routine, which is often called _line search_. For a given function \\(f\\) and step size \\(s\\), define the function \\(g(\\mathbf{x^{(\\prime)}},s)=f(\\mathbf{x^{(\\prime)}})-s(\\nabla f)(\\mathbf{x^{( \\prime)}})\\). Start with a small step size \\(s\\) for which \\(g(\\mathbf{x^{(\\prime)}},s)\\leq f(\\mathbf{x^{(\\prime)}})\\). Then repeatedly double \\(s\\) until \\(g(\\mathbf{x^{(\\prime)}},2s)\\geq g(\\mathbf{x^{(\\prime)}},s)\\), and then perform a binary search in the interval \\([s,2s]\\). This procedure can produce a step size that achieves a significant decrease in the objective function. In other circumstances, however, you may know good upper bounds on \\(R\\) and \\(L\\), typically from problem-specific information, which can suffice.\n\nThe dominant computational step in each iteration of the **for** loop of lines 2-4 is computing the gradient. The complexity of computing and evaluating a gradient varies widely, depending on the application at hand. We'll discuss several applications later.\n\n### Constrained gradient descent\n\nWe can adapt gradient descent for constrained minimization to minimize a closed convex function \\(f(\\mathbf{x})\\), subject to the additional requirement that \\(\\mathbf{x}\\in K\\), where \\(K\\) is a closed convex body. A _body_\\(K\\subseteq\\mathbb{R}^{n}\\) is _convex_ if for all \\(\\mathbf{x},\\mathbf{y}\\in K\\), the convex combination \\(\\lambda\\mathbf{x}+(1-\\lambda)\\mathbf{y}\\in K\\) for all \\(0\\leq\\lambda\\leq 1\\). A _closed_ convex body contains its limit points. Somewhat surprisingly, restricting to the constrained problem does not significantly increase the number of iterations of gradient descent. The idea is that you run the same algorithm, but in each iteration, check whether the current point \\(\\mathbf{x^{(t)}}\\) is still within the convex body \\(K\\). If it is not, just move to the closest point in \\(K\\). Moving to the closest point is known as _projection_. We formally define the projection \\(\\Pi_{K}(\\mathbf{x})\\) of a point \\(\\mathbf{x}\\) in \\(n\\) dimensions onto a convex body \\(K\\) as the point \\(\\mathbf{y}\\in K\\) such that \\(\\|\\mathbf{x}-\\mathbf{y}\\|=\\min\\left\\{\\|\\mathbf{x}-\\mathbf{z}\\|:z\\in K\\right\\}\\). If we have \\(\\mathbf{x}\\in K\\), then \\(\\Pi_{K}(\\mathbf{x})=\\mathbf{x}\\).\n\nThis one change yields the procedure Gradient-Descent-Constrained, in which line 4 of Gradient-Descent is replaced by two lines. It assumes that \\(\\mathbf{x^{(0)}}\\in K\\). Line 4 of Gradient-Descent-Constrained moves in the direction of the negative gradient, and line 5 projects back onto \\(K\\). The lemma that follows helps to show that when \\(\\mathbf{x}^{*}\\in K\\), if the projection step in line 5 moves from a point outside of \\(K\\) to a point in \\(K\\), it cannot be moving away from \\(\\mathbf{x}^{*}\\).\n\n```\nGradient-Descent-Constrained(\\(f,\\mathbf{x^{(0)}},\\gamma,T,K\\))\n1sum\\(=0\\)//\\(n\\)-dimensional vector, initially all 0\n2for\\(t=0\\)to\\(T-1\\)\n3sum\\(=\\)sum\\(+\\)\\(\\mathbf{x^{(t)}}\\)// add each of \\(n\\) dimensions into sum\n4\\(\\mathbf{x^{\\prime(t+1)}}=\\mathbf{x^{(t)}}-\\gamma\\cdot(\\nabla f)(\\mathbf{x^{(t)}})\\)//\\((\\nabla f)(\\mathbf{x^{(t)}}),\\mathbf{x^{\\prime(t+1)}}\\) are \\(n\\)-dimensional\n5\\(\\mathbf{x^{(t+1)}}=\\Pi_{K}(\\mathbf{x^{\\prime(t+1)}})\\)// project onto \\(K\\)\n6\\(\\mathbf{x}\\)-avg = sum\\(/T\\)// divide each of \\(n\\) dimensions by \\(T\\)\n7return\\(\\mathbf{x}\\)-avg\n```\n\n**Lemma 33.10**: _Consider a convex body \\(K\\subseteq\\mathbb{R}^{n}\\) and points \\(\\mathbf{a}\\in K\\) and \\(\\mathbf{b}^{\\prime}\\in\\mathbb{R}^{n}\\). Let \\(\\mathbf{b}=\\Pi_{K}(\\mathbf{b}^{\\prime})\\). Then \\(\\left\\|\\mathbf{b}-\\mathbf{a}\\right\\|^{2}\\leq\\left\\|\\mathbf{b}^{\\prime}- \\mathbf{a}\\right\\|^{2}\\)._\n\n_Proof_ If \\(\\mathbf{b}^{\\prime}\\in K\\), then \\(\\mathbf{b}=\\mathbf{b}^{\\prime}\\) and the claim is true. Otherwise, \\(\\mathbf{b}^{\\prime}\\neq\\mathbf{b}\\), and as Figure 33.6 shows, we can extend the line segment between \\(\\mathbf{b}\\) and \\(\\mathbf{b}^{\\prime}\\) to a line \\(\\ell\\). Let \\(\\mathbf{c}\\) be the projection of \\(\\mathbf{a}\\) onto \\(\\ell\\). Point \\(\\mathbf{c}\\) may or may not be in \\(K\\), and if \\(\\mathbf{a}\\) is on the boundary of \\(K\\), then \\(\\mathbf{c}\\) could coincide with \\(\\mathbf{b}\\). If \\(\\mathbf{c}\\) coincides with \\(\\mathbf{b}\\) (part (c) of the figure), then \\(\\mathbf{a}\\mathbf{b}\\mathbf{b}^{\\prime}\\) is a right triangle, and so \\(\\left\\|\\mathbf{b}-\\mathbf{a}\\right\\|^{2}\\leq\\left\\|\\mathbf{b}^{\\prime}- \\mathbf{a}\\right\\|^{2}\\).\n\n### 33.3 Gradient descent\n\nIf \\(\\mathbf{c}\\) does not coincide with \\(\\mathbf{b}\\) (parts (a) and (b) of the figure), then because of convexity, the angle \\(\\angle\\mathbf{a}\\mathbf{b}\\mathbf{b}^{\\prime}\\) must be obtuse. Because angle \\(\\angle\\mathbf{a}\\mathbf{b}\\mathbf{b}^{\\prime}\\) is obtuse, \\(\\mathbf{b}\\) lies between \\(\\mathbf{c}\\) and \\(\\mathbf{b}^{\\prime}\\) on \\(\\ell\\). Furthermore, because \\(\\mathbf{c}\\) is the projection of \\(\\mathbf{a}\\) onto line \\(\\ell\\), \\(\\mathbf{a}\\mathbf{c}\\mathbf{b}\\) and \\(\\mathbf{a}\\mathbf{c}\\mathbf{b}^{\\prime}\\) must be right triangles. By the Pythagorean theorem, we have that \\(\\left\\|\\mathbf{b}^{\\prime}-\\mathbf{a}\\right\\|^{2}=\\left\\|\\mathbf{a}-\\mathbf{c }\\right\\|^{2}+\\left\\|\\mathbf{c}-\\mathbf{b}^{\\prime}\\right\\|^{2}\\) and \\(\\left\\|\\mathbf{b}-\\mathbf{a}\\right\\|^{2}=\\left\\|\\mathbf{a}-\\mathbf{c}\\right\\|^ {2}+\\left\\|\\mathbf{c}-\\mathbf{b}\\right\\|^{2}\\). Subtracting these two equations gives \\(\\left\\|\\mathbf{b}^{\\prime}-\\mathbf{a}\\right\\|^{2}-\\left\\|\\mathbf{b}-\\mathbf{a }\\right\\|^{2}=\\left\\|\\mathbf{c}-\\mathbf{b}^{\\prime}\\right\\|^{2}-\\left\\| \\mathbf{c}-\\mathbf{b}\\right\\|^{2}\\). Because \\(\\mathbf{b}\\) is between \\(\\mathbf{c}\\) and \\(\\mathbf{b}^{\\prime}\\), we must have \\(\\left\\|\\mathbf{c}-\\mathbf{b}^{\\prime}\\right\\|^{2}\\geq\\left\\|\\mathbf{c}- \\mathbf{b}\\right\\|^{2}\\), and thus \\(\\left\\|\\mathbf{b}^{\\prime}-\\mathbf{a}\\right\\|^{2}-\\left\\|\\mathbf{b}-\\mathbf{ a}\\right\\|^{2}\\geq 0\\). The lemma follows.\n\nWe can now repeat the entire proof for the unconstrained case and obtain the same bounds. Lemma 33.10 with \\(\\mathbf{a}=\\mathbf{x}^{*}\\), \\(\\mathbf{b}=\\mathbf{x}^{\\boldsymbol{(t+1)}}\\), and \\(\\mathbf{b}^{\\prime}=\\mathbf{x}^{\\boldsymbol{(t+1)}}\\) tells us that \\(\\left\\|\\mathbf{x}^{\\boldsymbol{(t+1)}}-\\mathbf{x}^{*}\\right\\|^{2}\\leq\\left\\| \\mathbf{x}^{\\boldsymbol{(t+1)}}-\\mathbf{x}^{*}\\right\\|^{2}\\). We can therefore derive an upper bound that matches inequality (33.31). We continue to define \\(\\Phi(t)\\) as in equation (33.26), but noting that \\(\\mathbf{x}^{\\boldsymbol{(t+1)}}\\), computed in line 5 of Gradient-Descent-Constrained, has a different meaning here from in inequality (33.31):\n\n\\[\\Phi(t\\,+\\,1)-\\Phi(t)\\] \\[=\\,\\frac{1}{2\\gamma}\\,\\left\\|\\mathbf{x}^{\\boldsymbol{(t+1)}}- \\mathbf{x}^{*}\\right\\|^{2}-\\frac{1}{2\\gamma}\\,\\left\\|\\mathbf{x}^{\\boldsymbol{ (t)}}-\\mathbf{x}^{*}\\right\\|^{2}\\] (by equation (33.27)) \\[\\leq\\,\\frac{1}{2\\gamma}\\,\\left\\|\\mathbf{x}^{\\boldsymbol{(t+1)}}- \\mathbf{x}^{*}\\right\\|^{2}-\\frac{1}{2\\gamma}\\,\\left\\|\\mathbf{x}^{\\boldsymbol{ (t)}}-\\mathbf{x}^{*}\\right\\|^{2}\\] (by Lemma 33.10) \\[=\\,\\frac{1}{2\\gamma}\\,\\Big{(}2\\langle\\mathbf{x}^{\\boldsymbol{(t+1 )}}-\\mathbf{x}^{\\boldsymbol{(t)}},\\mathbf{x}^{\\boldsymbol{(t)}}-\\mathbf{x}^{* }\\rangle\\,+\\,\\left\\|\\mathbf{x}^{\\boldsymbol{(t+1)}}-\\mathbf{x}^{*}\\right\\|^{2 }\\Big{)}\\] (by equation (33.29)) \\[=\\,\\frac{1}{2\\gamma}\\,\\Big{(}2\\langle-\\gamma\\cdot(\\nabla f)( \\mathbf{x}^{\\boldsymbol{(t)}}),\\mathbf{x}^{\\boldsymbol{(t)}}-\\mathbf{x}^{*} \\rangle\\,+\\,\\left\\|-\\gamma\\cdot(\\nabla f)(\\mathbf{x}^{\\boldsymbol{(t)}}) \\right\\|^{2}\\Big{)}\\] (by line 4 of Gradient-Descent-Constrained) \\[=\\,-\\langle(\\nabla f)(\\mathbf{x}^{\\boldsymbol{(t)}}),\\mathbf{x}^{ \\boldsymbol{(t)}}-\\mathbf{x}^{*}\\rangle\\,+\\,\\frac{\\gamma}{2}\\,\\left\\|(\\nabla f) (\\mathbf{x}^{\\boldsymbol{(t)}})\\right\\|^{2}\\,.\\]With the same upper bound on the change in the potential function as in equation (33.30), the entire proof of Lemma 33.9 can proceed as before. We can therefore conclude that the procedure gradient-descent-constrained has the same asymptotic complexity as gradient-descent. We summarize this result in the following theorem.\n\n**Theorem 33.11**: Let \\(K\\subseteq\\mathbb{R}^{n}\\) be a convex body, \\(\\mathbf{x}^{*}\\in\\mathbb{R}^{n}\\) be the minimizer of a convex function \\(f\\) over \\(K\\), and \\(\\gamma=R/(L\\sqrt{T})\\), where \\(R\\) and \\(L\\) are defined in equations (33.20) and (33.21). Suppose that the vector \\(\\mathbf{x}\\)-\\(\\mathbf{avg}\\) is returned by an execution of Gradient-Descent-Constrained\\((f,\\mathbf{x}^{(0)},\\gamma,T,K)\\). Let \\(\\epsilon=RL/\\sqrt{T}\\). Then we have \\(f(\\mathbf{x}\\)-\\(\\mathbf{avg})-f(\\mathbf{x}^{*})\\leq\\epsilon\\).\n\n### Applications of gradient descent\n\nGradient descent has many applications to minimizing functions and is widely used in optimization and machine learning. Here we sketch how it can be used to solve linear systems. Then we discuss an application to machine learning: prediction using linear regression.\n\nIn Chapter 28, we saw how to use Gaussian elimination to solve a system of linear equations \\(A\\mathbf{x}=\\mathbf{b}\\), thereby computing \\(\\mathbf{x}=A^{-1}\\mathbf{b}\\). If \\(A\\) is an \\(n\\times n\\) matrix and \\(\\mathbf{b}\\) is a length-\\(n\\) vector, then the running time of Gaussian elimination is \\(\\Theta(n^{3})\\), which for large matrices might be prohibitively expensive. If an approximate solution is acceptable, however, you can use gradient descent.\n\nFirst, let's see how to use gradient descent as a roundabout--and admittedly inefficient--way to solve for \\(x\\) in the scalar equation \\(ax=b\\), where \\(a,x,b\\in\\mathbb{R}\\). This equation is equivalent to \\(ax-b=0\\). If \\(ax-b\\) is the derivative of a convex function \\(f(x)\\), then \\(ax-b=0\\) for the value of \\(x\\) that minimizes \\(f(x)\\). Given \\(f(x)\\), gradient descent can then determine this minimizer. Of course, \\(f(x)\\) is just the integral of \\(ax-b\\), that is, \\(f(x)=\\frac{1}{2}ax^{2}-bx\\), which is convex if \\(a\\geq 0\\). Therefore, one way to solve \\(ax=b\\) for \\(a\\geq 0\\) is to find the minimizer for \\(\\frac{1}{2}ax^{2}-bx\\) via gradient descent.\n\nWe now generalize this idea to higher dimensions, where using gradient descent may actually lead to a faster algorithm. One \\(n\\)-dimensional analog is the function \\(f(\\mathbf{x})=\\frac{1}{2}\\mathbf{x}^{\\mathrm{T}}A\\mathbf{x}-\\mathbf{b}^{ \\mathrm{T}}\\mathbf{x}\\), where \\(A\\) is an \\(n\\times n\\) matrix. The gradient of \\(f\\) with respect to \\(\\mathbf{x}\\) is the function \\(A\\mathbf{x}-\\mathbf{b}\\). To find the value of \\(\\mathbf{x}\\) that minimizes \\(f\\), we set the gradient of \\(f\\) to 0 and solve for \\(\\mathbf{x}\\). Solving \\(A\\mathbf{x}-\\mathbf{b}=0\\) for \\(\\mathbf{x}\\), we obtain \\(\\mathbf{x}=A^{-1}\\mathbf{b}\\), Thus, minimizing \\(f(\\mathbf{x})\\) is equivalent to solving \\(A\\mathbf{x}=\\mathbf{b}\\). If \\(f(\\mathbf{x})\\) is convex, then gradient descent can approximately compute this minimum.\n\nA 1-dimensional function is convex when its second derivative is positive. The equivalent definition for a multidimensional function is that it is convex when its \n\n### Gradient descent\n\nHessian matrix is positive-semidefinite (see page 1222 for a definition), where the _Hessian matrix_\\((\\nabla^{2}f)(\\mathbf{x})\\) of a function \\(f(\\mathbf{x})\\) is the matrix in which entry \\((i,j)\\) is the partial derivative of \\(f\\) with respect to \\(i\\) and \\(j\\):\n\n\\[(\\nabla^{2}f)(\\mathbf{x})\\,=\\,\\left(\\begin{array}{cccc}\\frac{\\partial^{2}f}{ \\partial x_{1}\\partial x_{1}}&\\frac{\\partial^{2}f}{\\partial x_{1}\\partial x_{ 2}}&\\cdots&\\frac{\\partial^{2}f}{\\partial x_{1}\\partial x_{n}}\\\\ \\frac{\\partial^{2}f}{\\partial x_{2}\\partial x_{1}}&\\frac{\\partial^{2}f}{ \\partial x_{2}\\partial x_{2}}&\\cdots&\\frac{\\partial^{2}f}{\\partial x_{2} \\partial x_{n}}\\\\ \\vdots&\\vdots&\\ddots&\\vdots\\\\ \\frac{\\partial^{2}f}{\\partial x_{n}\\partial x_{1}}&\\frac{\\partial^{2}f}{ \\partial x_{n}\\partial x_{2}}&\\cdots&\\frac{\\partial^{2}f}{\\partial x_{n} \\partial x_{n}}\\end{array}\\right)\\,.\\]\n\nAnalogous to the 1-dimensional case, the Hessian of \\(f\\) is just \\(A\\), and so if \\(A\\) is a positive-semidefinite matrix, then we can use gradient descent to find a point \\(\\mathbf{x}\\) where \\(A\\mathbf{x}\\approx\\mathbf{b}\\). If \\(R\\) and \\(L\\) are not too large, then this method is faster than using Gaussian elimination.\n\n### Gradient descent in machine learning\n\nAs a concrete example of supervised learning for prediction, suppose that you want to predict whether a patient will develop heart disease. For each of \\(m\\) patients, you have \\(n\\) different attributes. For example, you might have \\(n=4\\) and the four pieces of data are age, height, blood pressure, and number of close family members with heart disease. Denote the data for patient \\(i\\) as a vector \\(\\mathbf{x^{(}i)}\\in\\mathbb{R}^{n}\\), with \\(x_{j}^{(i)}\\) giving the \\(j\\)th entry in vector \\(\\mathbf{x^{(}i)}\\). The _label_ of patient \\(i\\) is denoted by a scalar \\(y^{(i)}\\in\\mathbb{R}\\), signifying the severity of the patient's heart disease. The hypothesis should capture a relationship between the \\(\\mathbf{x^{(}i)}\\) values and \\(y^{(i)}\\). For this example, we make the modeling assumption that the relationship is linear, and therefore the goal is to compute the \"best\" linear relationship between the \\(\\mathbf{x^{(}i)}\\) values and \\(y^{(i)}\\): a linear function \\(f:\\mathbb{R}^{n}\\rightarrow\\mathbb{R}\\) such that \\(f(\\mathbf{x^{(}i)})\\approx y^{(i)}\\) for each patient \\(i\\). Of course, no such function may exist, but you would like one that comes as close as possible. A linear function \\(f\\) can be defined by a vector of weights \\(\\mathbf{w}=(w_{0},w_{1},\\ldots,w_{n})\\), with\n\n\\[f(\\mathbf{x})\\,=\\,w_{0}\\,+\\sum_{j\\,=\\,1}^{n}w_{j}\\,x_{j}\\,\\,. \\tag{33.32}\\]\n\nWhen evaluating a machine-learning model, you need to measure how close each value \\(f(\\mathbf{x^{(}i)})\\) is to its corresponding label \\(y^{(i)}\\). In this example, we define the error \\(e^{(i)}\\in\\mathbb{R}\\) associated with patient \\(i\\) as \\(e^{(i)}=f(\\mathbf{x^{(}i)})-y^{(i)}\\). The objective function we choose is to minimize the sum of squares of the errors, which is\\[\\sum_{i\\,=\\,1}^{m}\\left(e^{(i)}\\right)^{2} \\,=\\,\\sum_{i\\,=\\,1}^{m}\\left(f({\\bf x^{(\\it i)}})-y^{(i)}\\right)^{2}\\] \\[\\,=\\,\\sum_{i\\,=\\,1}^{m}\\left(w_{0}+\\sum_{j\\,=\\,1}^{n}w_{j}x_{j}^{(i )}-y^{(i)}\\right)^{2}\\,. \\tag{33.33}\\]\n\nThe objective function is typically called the _loss function_, and the _least-squares error_ given by equation (33.33) is just one example of many possible loss functions. The goal is then, given the \\({\\bf x^{(\\it i)}}\\) and \\(y^{(i)}\\) values, to compute the weights \\(w_{0},w_{1},\\ldots,w_{n}\\) so as to minimize the loss function in equation (33.33). The variables here are the weights \\(w_{0},w_{1},\\ldots,w_{n}\\) and not the \\({\\bf x^{(\\it i)}}\\) or \\(y^{(i)}\\) values.\n\nThis particular objective is sometimes known as a _least-squares fit_, and the problem of finding a linear function to fit data and minimize the least-squares error is called _linear regression_. Finding a least-squares fit is also addressed in Section 28.3.\n\nWhen the function \\(f\\) is linear, the loss function defined in equation (33.33) is convex, because it is the sum of squares of linear functions, which are themselves convex. Therefore, we can apply gradient descent to compute a set of weights to approximately minimize the least-squares error. The concrete goal of learning is to be able to make predictions on new data. Informally, if the features are all reported in the same units and are from the same range (perhaps from being normalized), then the weights tend to have a natural interpretation because the features of the data that are better predictors of the label have a larger associated weight. For example, you would expect that, after normalization, the weight associated with the number of family members with heart disease would be larger than the weight associated with height.\n\nThe computed weights form a model of the data. Once you have a model, you can make predictions, so that given new data, you can predict its label. In our example, given a new patient \\({\\bf x^{\\prime}}\\) who is not part of the original training data set, you would still hope to predict the chance that the new patient develops heart disease. You can do so by computing the label \\(f({\\bf x^{\\prime}})\\), incorporating the weights computed by gradient descent.\n\nFor this linear-regression problem, the objective is to minimize the expression in equation (33.33), which is a quadratic in each of the \\(n+1\\) weights \\(w_{j}\\). Thus, entry \\(j\\) in the gradient is linear in \\(w_{j}\\). Exercise 33.3-5 asks you to explicitly compute the gradient and see that it can be computed in \\(O(n\\,m)\\) time, which is linear in the input size. Compared with the exact method of solving equation (33.33) in Chapter 28, which needs to invert a matrix, gradient descent is typically much faster.\n\nSection 33.1 briefly discussed regularization--the idea that a complicated hypothesis should be penalized in order to avoid overfitting the training data. Regularization often involves adding a term to the objective function, but it can also be achieved by adding a constraint. One way to regularize this example would be to explicitly limit the norm of the weights, adding a constraint that \\(\\|{\\bf w}\\|\\leq B\\) for some bound \\(B>0\\). (Recall again that the components of the vector \\({\\bf w}\\) are the variables in the present application.) Adding this constraint controls the complexity of the model, as the number of values \\(w_{j}\\) that can have large absolute value is now limited.\n\nIn order to run Gradient-Descent-Constrained for any problem, you need to implement the projection step, as well as to compute bounds on \\(R\\) and \\(L\\). We conclude this section by describing these calculations for gradient descent with the constraint \\(\\|{\\bf w}\\|\\leq B\\). First, consider the projection step in line 5. Suppose that the update in line 4 results in a vector \\({\\bf w}^{\\prime}\\). The projection is implemented by computing \\(\\Pi_{k}({\\bf w}^{\\prime})\\) where \\(K\\) is defined by \\(\\|{\\bf w}\\|\\leq B\\). This particular projection can be accomplished by simply scaling \\({\\bf w}^{\\prime}\\), since we know that closest point in \\(K\\) to \\({\\bf w}^{\\prime}\\) must be the point along the vector whose norm is exactly \\(B\\). The amount \\(z\\) by which we need to scale \\({\\bf w}^{\\prime}\\) to hit the boundary of \\(K\\) is the solution to the equation \\(z\\,\\|{\\bf w}^{\\prime}\\|=B\\), which is solved by \\(z=B/\\,\\|{\\bf w}^{\\prime}\\|\\). Hence line 5 is implemented by computing \\({\\bf w}={\\bf w}^{\\prime}B/\\,\\|{\\bf w}^{\\prime}\\|\\). Because we always have \\(\\|{\\bf w}\\|\\leq B\\), Exercise 33.3-6 asks you to show that the upper bound on the magnitude \\(L\\) of the gradient is \\(O(B)\\). We also get a bound on \\(R\\), as follows. By the constraint \\(\\|{\\bf w}\\|\\leq B\\), we know that both \\(\\|{\\bf w}^{({\\bf 0})}\\|\\leq B\\) and \\(\\|{\\bf w}^{*}\\|\\leq B\\), and thus \\(\\|{\\bf w}^{({\\bf 0})}-{\\bf w}^{*}\\|\\leq 2B\\). Using the definition of \\(R\\) in equation (33.20), we have \\(R=O(B)\\). The bound \\(RL/\\sqrt{T}\\) on the accuracy of the solution after \\(T\\) iterations in Theorem 33.11 becomes \\(O(B)L/\\sqrt{T}=O(B^{2}/\\sqrt{T})\\).\n\n##### Exercises\n\n##### 33.3-1\n\nProve Lemma 33.6. Start from the definition of a convex function given in equation (33.18). (_Hint:_ You can prove the statement when \\(n=1\\) first. The proof for general values of \\(n\\) is similar.)\n\n##### 33.3-2\n\nProve Lemma 33.7.\n\n##### 33.3-3\n\nProve equation (33.29). (_Hint:_ The proof for \\(n=1\\) dimension is straightforward. The proof for general values of \\(n\\) dimensions follows along similar lines.)\n\n##### 33.3-4\n\nShow that the function \\(f\\) in equation (33.32) is a convex function of the variables \\(w_{0},w_{1},\\ldots,w_{n}\\).\n\n_33.3-5_\n\nCompute the gradient of expression (33.33) and explain how to evaluate the gradient in \\(O(n\\,m)\\) time.\n\n_33.3-6_\n\nConsider the function \\(f\\) defined in equation (33.32), and suppose that you have a bound \\(\\|{\\bf w}\\,\\|\\leq\\,B\\), as is considered in the discussion on regularization. Show that \\(L\\,=\\,O(B)\\) in this case.\n\n_33.3-7_\n\nEquation (33.2) on page 1009 gives a function that, when minimized, gives an optimal solution to the \\(k\\)-means problem. Explain how to use gradient descent to solve the \\(k\\)-means problem.\n\n## Problems\n\n_33-1 Newton's method_\n\nGradient descent iteratively moves closer to a desired value (the minimum) of a function. Another algorithm in this spirit is known as _Newton's method_, which is an iterative algorithm that finds the root of a function. Here, we consider Newton's method which, given a function \\(f:\\mathbb{R}\\,\\to\\mathbb{R}\\), finds a value \\(x^{\\star}\\) such that \\(f(x^{\\star})\\,=\\,0\\). The algorithm moves through a series of points \\(x^{(0)},x^{(1)},\\ldots\\). If the algorithm is currently at a point \\(x^{(t)}\\), then to find point \\(x^{(t+1)}\\), it first takes the equation of the line tangent to the curve at \\(x\\,=\\,x^{(t)}\\),\n\n\\(y\\,=\\,f^{\\prime}(x^{(t)})(x-x^{(t)})\\,+\\,f(x^{(t)})\\).\n\nIt then uses the \\(x\\)-intercept of this line as the next point \\(x^{(t+1)}\\).\n\n_a._ Show that the algorithm described above can be summarized by the update rule\n\n\\(x^{(t+1)}\\,=\\,x^{(t)}\\,-\\,\\frac{f(x^{(t)})}{f^{\\prime}(x^{(t)})}\\).\n\nWe restrict our attention to some domain \\(I\\) and assume that \\(f^{\\prime}(x)\\,\\neq\\,0\\) for all \\(x\\,\\in\\,I\\) and that \\(f^{\\prime\\prime}(x)\\) is continuous. We also assume that the starting point \\(x^{(0)}\\) is sufficiently close to \\(x^{\\star}\\), where \"sufficiently close\" means that we can use only the first two terms of the Taylor expansion of \\(f(x^{\\star})\\) about \\(x^{(0)}\\), namely\n\n\\[f(x^{\\star})\\,=\\,f(x^{(0)})\\,+\\,f^{\\prime}(x^{(0)})(x^{\\star}-x^{(0)})\\,+\\, \\frac{1}{2}\\,f^{\\prime\\prime}(y^{(0)})(x^{\\star}-x^{(0)})^{2}\\, \\tag{33.34}\\]",
        "chapter": "Part VII Selected Topics",
        "section": "33 Machine-Learning Algorithms",
        "subsection": "33.3 Gradient descent",
        "subsubsection": "N/A"
    },
    {
        "content": "_33.3-5_\n\nCompute the gradient of expression (33.33) and explain how to evaluate the gradient in \\(O(n\\,m)\\) time.\n\n_33.3-6_\n\nConsider the function \\(f\\) defined in equation (33.32), and suppose that you have a bound \\(\\|{\\bf w}\\,\\|\\leq\\,B\\), as is considered in the discussion on regularization. Show that \\(L\\,=\\,O(B)\\) in this case.\n\n_33.3-7_\n\nEquation (33.2) on page 1009 gives a function that, when minimized, gives an optimal solution to the \\(k\\)-means problem. Explain how to use gradient descent to solve the \\(k\\)-means problem.\n\n## Problems\n\n_33-1 Newton's method_\n\nGradient descent iteratively moves closer to a desired value (the minimum) of a function. Another algorithm in this spirit is known as _Newton's method_, which is an iterative algorithm that finds the root of a function. Here, we consider Newton's method which, given a function \\(f:\\mathbb{R}\\,\\to\\mathbb{R}\\), finds a value \\(x^{\\star}\\) such that \\(f(x^{\\star})\\,=\\,0\\). The algorithm moves through a series of points \\(x^{(0)},x^{(1)},\\ldots\\). If the algorithm is currently at a point \\(x^{(t)}\\), then to find point \\(x^{(t+1)}\\), it first takes the equation of the line tangent to the curve at \\(x\\,=\\,x^{(t)}\\),\n\n\\(y\\,=\\,f^{\\prime}(x^{(t)})(x-x^{(t)})\\,+\\,f(x^{(t)})\\).\n\nIt then uses the \\(x\\)-intercept of this line as the next point \\(x^{(t+1)}\\).\n\n_a._ Show that the algorithm described above can be summarized by the update rule\n\n\\(x^{(t+1)}\\,=\\,x^{(t)}\\,-\\,\\frac{f(x^{(t)})}{f^{\\prime}(x^{(t)})}\\).\n\nWe restrict our attention to some domain \\(I\\) and assume that \\(f^{\\prime}(x)\\,\\neq\\,0\\) for all \\(x\\,\\in\\,I\\) and that \\(f^{\\prime\\prime}(x)\\) is continuous. We also assume that the starting point \\(x^{(0)}\\) is sufficiently close to \\(x^{\\star}\\), where \"sufficiently close\" means that we can use only the first two terms of the Taylor expansion of \\(f(x^{\\star})\\) about \\(x^{(0)}\\), namely\n\n\\[f(x^{\\star})\\,=\\,f(x^{(0)})\\,+\\,f^{\\prime}(x^{(0)})(x^{\\star}-x^{(0)})\\,+\\, \\frac{1}{2}\\,f^{\\prime\\prime}(y^{(0)})(x^{\\star}-x^{(0)})^{2}\\, \\tag{33.34}\\]where \\(\\gamma^{(0)}\\) is some value between \\(x^{(0)}\\) and \\(x^{\\star}\\). If the approximation in equation (33.34) holds for \\(x^{(0)}\\), it also holds for any point closer to \\(x^{\\star}\\).\n\n_b._ Assume that the function \\(f\\) has exactly one point \\(x^{\\star}\\) for which \\(f(x^{\\star})=0\\). Let \\(\\epsilon^{(t)}=\\left|x^{(t)}-x^{\\star}\\right|\\). Using the Taylor expansion in equation (33.34), show that\n\n\\[\\epsilon^{(t+1)}=\\frac{\\left|f^{\\prime\\prime}(\\gamma^{(t)})\\right|}{2\\left|f^ {\\prime}(\\gamma^{(t)})\\right|}\\epsilon^{(t)}\\,\\]\n\nwhere \\(\\gamma^{(t)}\\) is some value between \\(x^{(t)}\\) and \\(x^{\\star}\\).\n\n_c._ If\n\n\\[\\frac{\\left|f^{\\prime\\prime}(\\gamma^{(t)})\\right|}{2\\left|f^{\\prime}(\\gamma^{ (t)})\\right|}\\leq c\\]\n\nfor some constant \\(c\\) and \\(\\epsilon^{(0)}<1\\), then we say that the function \\(f\\) has _quadratic convergence_, since the error decreases quadratically. Assuming that \\(f\\) has quadratic convergence, how many iterations are needed to find a root of \\(f(x)\\) to an accuracy of \\(\\delta\\)? Your answer should include \\(\\delta\\).\n\n_d._ Suppose you wish to find a root of the function \\(f(x)=(x-3)^{2}\\), which is also the minimizer, and you start at \\(x^{(0)}=3.5\\). Compare the number of iterations needed by gradient descent to find the minimizer and Newton's method to find the root.\n\n_33-2 Hedge_\n\nAnother variant in the multiplicative-weights framework is known as Hedge. It differs from Weighted Majority in two ways. First, Hedge makes the prediction randomly--in iteration \\(t\\), it assigns a probability \\(p_{i}^{(t)}=w_{i}^{(t)}/Z^{(t)}\\) to expert \\(E_{i}\\), where \\(Z^{(t)}=\\sum_{i=1}^{n}w_{i}^{(t)}\\). It then chooses an expert \\(E_{i^{\\prime}}\\) according to this probability distribution and predicts according to \\(E_{i^{\\prime}}\\). Second, the update rule is different. If an expert makes a mistake, line 16 updates that expert's weight by the rule \\(w_{i}^{(t+1)}=w_{i}^{(t)}e^{-\\epsilon}\\), for some \\(0<\\epsilon<1\\). Show that the expected number of mistakes made by Hedge, running for \\(T\\) rounds, is at most \\(m^{\\star}+(\\ln n)/\\epsilon+\\epsilon T\\).\n\n_33-3 Nonoptimality of Lloyd's procedure in one dimension_\n\nGive an example to show that even in one dimension, Lloyd's procedure for finding clusters does not always return an optimum result. That is, Lloyd's procedure may terminate and return as a result a set \\(C\\) of clusters that does not minimize \\(f(S,C)\\), even when \\(S\\) is a set of points on a line.\n\n#### 33-4 Stochastic gradient descent\n\nConsider the problem described in Section 33.3 of fitting a line \\(f(x)=ax+b\\) to a given set of point/value pairs \\(S=\\{(x_{1},y_{1}),...,(x_{T},y_{T})\\}\\) by optimizing the choice of the parameters \\(a\\) and \\(b\\) using gradient descent to find a best least-squares fit. Here we consider the case where \\(x\\) is a real-valued variable, rather than a vector.\n\nSuppose that you are not given the point/value pairs in \\(S\\) all at once, but only one at a time in an online manner. Furthermore, the points are given in random order. That is, you know that there are \\(n\\) points, but in iteration \\(t\\) you are given only \\((x_{i},y_{i})\\) where \\(i\\) is independently and randomly chosen from \\(\\{1,\\ldots,T\\}\\).\n\nYou can use gradient descent to compute an estimate to the function. As each point \\((x_{i},y_{i})\\) is considered, you can update the current values of \\(a\\) and \\(b\\) by taking the derivative with respect to \\(a\\) and \\(b\\) of the term of the objective function depending on \\((x_{i},y_{i})\\). Doing so gives you a stochastic estimate of the gradient, and you can then take a small step in the opposite direction.\n\nGive pseudocode to implement this variant of gradient descent. What would the expected value of the error be as a function of \\(T\\), \\(L\\), and \\(R\\)? (_Hint:_ Replicate the analysis of Gradient-Descent in Section 33.3 for this variant.)\n\nThis procedure and its variants are known as _stochastic gradient descent_.\n\n## Chapter notes\n\nFor a general introduction to artificial intelligence, we recommend Russell and Norvig [391]. For a general introduction to machine learning, we recommend Murphy [340].\n\nLloyd's procedure for the \\(k\\)-means problem was first proposed by Lloyd [304] and also later by Forgy [151]. It is sometimes called \"Lloyd's algorithm\" or the \"Lloyd-Forgy algorithm.\" Although Mahajan et al. [310] showed that finding an optimal clustering is NP-hard, even in the plane, Kanungo et al. [241] have shown that there is an approximation algorithm for the \\(k\\)-means problem with approximation ratio \\(9+\\epsilon\\), for any \\(\\epsilon>0\\).\n\nThe multiplicative-weights method is surveyed by Arora, Hazan, and Kale [25]. The main idea of updating weights based on feedback has been rediscovered many times. One early use is in game theory, where Brown defined \"Fictitious Play\" [74] and conjectured its convergence to the value of a zero-sum game. The convergence properties were established by Robinson [382].\n\nIn machine learning, the first use of multiplicative weights was by Littlestone in the Winnow algorithm [300], which was later extended by Littlestone and Warmuth to the weighted-majority algorithm described in Section 33.2 [301]. This work is closely connected to the boosting algorithm, originally due to Freund and Shapire",
        "chapter": "Part VII Selected Topics",
        "section": "33 Machine-Learning Algorithms",
        "subsection": "Problems",
        "subsubsection": "N/A"
    },
    {
        "content": "#### 33-4 Stochastic gradient descent\n\nConsider the problem described in Section 33.3 of fitting a line \\(f(x)=ax+b\\) to a given set of point/value pairs \\(S=\\{(x_{1},y_{1}),...,(x_{T},y_{T})\\}\\) by optimizing the choice of the parameters \\(a\\) and \\(b\\) using gradient descent to find a best least-squares fit. Here we consider the case where \\(x\\) is a real-valued variable, rather than a vector.\n\nSuppose that you are not given the point/value pairs in \\(S\\) all at once, but only one at a time in an online manner. Furthermore, the points are given in random order. That is, you know that there are \\(n\\) points, but in iteration \\(t\\) you are given only \\((x_{i},y_{i})\\) where \\(i\\) is independently and randomly chosen from \\(\\{1,\\ldots,T\\}\\).\n\nYou can use gradient descent to compute an estimate to the function. As each point \\((x_{i},y_{i})\\) is considered, you can update the current values of \\(a\\) and \\(b\\) by taking the derivative with respect to \\(a\\) and \\(b\\) of the term of the objective function depending on \\((x_{i},y_{i})\\). Doing so gives you a stochastic estimate of the gradient, and you can then take a small step in the opposite direction.\n\nGive pseudocode to implement this variant of gradient descent. What would the expected value of the error be as a function of \\(T\\), \\(L\\), and \\(R\\)? (_Hint:_ Replicate the analysis of Gradient-Descent in Section 33.3 for this variant.)\n\nThis procedure and its variants are known as _stochastic gradient descent_.\n\n## Chapter notes\n\nFor a general introduction to artificial intelligence, we recommend Russell and Norvig [391]. For a general introduction to machine learning, we recommend Murphy [340].\n\nLloyd's procedure for the \\(k\\)-means problem was first proposed by Lloyd [304] and also later by Forgy [151]. It is sometimes called \"Lloyd's algorithm\" or the \"Lloyd-Forgy algorithm.\" Although Mahajan et al. [310] showed that finding an optimal clustering is NP-hard, even in the plane, Kanungo et al. [241] have shown that there is an approximation algorithm for the \\(k\\)-means problem with approximation ratio \\(9+\\epsilon\\), for any \\(\\epsilon>0\\).\n\nThe multiplicative-weights method is surveyed by Arora, Hazan, and Kale [25]. The main idea of updating weights based on feedback has been rediscovered many times. One early use is in game theory, where Brown defined \"Fictitious Play\" [74] and conjectured its convergence to the value of a zero-sum game. The convergence properties were established by Robinson [382].\n\nIn machine learning, the first use of multiplicative weights was by Littlestone in the Winnow algorithm [300], which was later extended by Littlestone and Warmuth to the weighted-majority algorithm described in Section 33.2 [301]. This work is closely connected to the boosting algorithm, originally due to Freund and Shapire[159]. The multiplicative-weights idea is also closely related to several more general optimization algorithms, including the perceptron algorithm [328] and algorithms for optimization problems such as packing linear programs [177, 359].\n\nThe treatment of gradient descent in this chapter draws heavily on the unpublished manuscript of Bansal and Gupta [35]. They emphasize the idea of using a potential function and using ideas from amortized analysis to explain gradient descent. Other presentations and analyses of gradient descent include works by Bubeck [75], Boyd and Vanderberghe [69], and Nesterov [343].\n\nGradient descent is known to converge faster when functions obey stronger properties than general convexity. For example, a function \\(f\\) is _\\(\\alpha\\)-strongly convex_ if \\(f(\\mathbf{y})\\geq f(\\mathbf{x})+\\langle(\\nabla f)(\\mathbf{x}),\\,(\\mathbf{y}- \\mathbf{x})\\rangle+\\alpha\\left\\|\\mathbf{y}-\\mathbf{x}\\right\\|\\) for all \\(\\mathbf{x},\\mathbf{y}\\in\\mathbb{R}^{n}\\). In this case, Gradient-Descent can use a variable step size and return \\(\\mathbf{x}^{(T)}\\). The step size at step \\(t\\) becomes \\(\\gamma_{t}=1/(\\alpha(t+1))\\), and the procedure returns a point such that \\(f(\\mathbf{x}\\mbox{-}\\mathbf{avg})-f(\\mathbf{x}^{*})\\leq L^{2}/(\\alpha(T+1))\\). This convergence is better than that of Theorem 3.8 because the number of iterations needed is linear, rather than quadratic, in the desired error parameter \\(\\epsilon\\), and because the performance is independent of the initial point.\n\nAnother case in which gradient descent can be shown to perform better than the analysis in Section 33.3 suggests is for smooth convex functions. We say that a function is _\\(\\beta\\)-smooth_ if \\(f(\\mathbf{y})\\leq f(\\mathbf{x})+\\langle(\\nabla f)(\\mathbf{x}),(\\mathbf{y}- \\mathbf{x})\\rangle+\\frac{\\beta}{2}\\left\\|\\mathbf{y}-\\mathbf{x}\\right\\|^{2}\\). This inequality goes in the opposite direction from the one for \\(\\alpha\\)-strong convexity. Better bounds on gradient descent are possible here as well.\n\n## Chapter 1 Introduction\n\nIn this chapter, we study the problem of finding a _polynomial-time algorithm_ for a given \\(n\\)-tuple of \\(n\\)-tuples of size \\(n\\). We will show that the algorithm is a polynomial-time algorithm for a given \\(n\\)-tuple of size \\(n\\).",
        "chapter": "Part VII Selected Topics",
        "section": "33 Machine-Learning Algorithms",
        "subsection": "Chapter notes",
        "subsubsection": "N/A"
    },
    {
        "content": "### 34.1 Polynomial time\n\nSince NP-completeness relies on notions of solving a problem and verifying a certificate in polynomial time, let's first examine what it means for a problem to be solvable in polynomial time.\n\nRecall that we generally regard problems that have polynomial-time solutions as tractable. Here are three reasons why:\n\n1. Although no reasonable person considers a problem that requires \\(\\Theta(n^{100})\\) time to be tractable, few practical problems require time on the order of such a high-degree polynomial. The polynomial-time computable problems encountered in practice typically require much less time. Experience has shown that once the first polynomial-time algorithm for a problem has been discovered, more efficient algorithms often follow. Even if the current best algorithm for a problem has a running time of \\(\\Theta(n^{100})\\), an algorithm with a much better running time will likely soon be discovered.\n2. For many reasonable models of computation, a problem that can be solved in polynomial time in one model can be solved in polynomial time in another. For example, the class of problems solvable in polynomial time by the serial random-access machine used throughout most of this book is the same as the class of problems solvable in polynomial time on abstract Turing machines.2 It is also the same as the class of problems solvable in polynomial time on a parallel computer when the number of processors grows polynomially with the input size. Footnote 2: See the books by Hopcroft and Ullman [228], Lewis and Papadimitriou [299], or Sipser [413] for a thorough treatment of the Turing-machine model.\n3. The class of polynomial-time solvable problems has nice closure properties, since polynomials are closed under addition, multiplication, and composition. For example, if the output of one polynomial-time algorithm is fed into the input of another, the composite algorithm is polynomial. Exercise 34.1-5 asks you to show that if an algorithm makes a constant number of calls to polynomial-time subroutines and performs an additional amount of work that also takes polynomial time, then the running time of the composite algorithm is polynomial.\n\n### Abstract problems\n\nTo understand the class of polynomial-time solvable problems, you must first have a formal notion of what a \"problem\" is. We define an _abstract problem_\\(Q\\) to be abinary relation on a set \\(I\\) of problem _instances_ and a set \\(S\\) of problem _solutions_. For example, an instance for SHORTEST-PATH is a triple consisting of a graph and two vertices. A solution is a sequence of vertices in the graph, with perhaps the empty sequence denoting that no path exists. The problem SHORTEST-PATH itself is the relation that associates each instance of a graph and two vertices with a shortest path in the graph that connects the two vertices. Since shortest paths are not necessarily unique, a given problem instance may have more than one solution.\n\nThis formulation of an abstract problem is more general than necessary for our purposes. As we saw above, the theory of NP-completeness restricts attention to _decision problems_: those having a yes/no solution. In this case, we can view an abstract decision problem as a function that maps the instance set \\(I\\) to the solution set \\(\\{0,1\\}\\). For example, a decision problem related to SHORTEST-PATH is the problem PATH that we saw earlier. If \\(i=\\langle G,\\,u,\\,v,\\,k\\rangle\\) is an instance of PATH, then PATH\\((i)=1\\) (yes) if \\(G\\) contains a path from \\(u\\) to \\(v\\) with at most \\(k\\) edges, and PATH\\((i)=0\\) (no) otherwise. Many abstract problems are not decision problems, but rather _optimization problems_, which require some value to be minimized or maximized. As we saw above, however, you can usually recast an optimization problem as a decision problem that is no harder.\n\n## Encodings\n\nIn order for a computer program to solve an abstract problem, its problem instances must appear in a way that the program understands. An _encoding_ of a set \\(S\\) of abstract objects is a mapping \\(e\\) from \\(S\\) to the set of binary strings.3 For example, we are all familiar with encoding the natural numbers \\(\\mathbb{N}=\\{0,1,2,3,4,\\dots\\}\\) as the strings \\(\\{0,1,10,11,100,\\dots\\}\\). Using this encoding, \\(e(17)=10001\\). If you have looked at computer representations of keyboard characters, you probably have seen the ASCII code, where, for example, the encoding of A is \\(01000001\\). You can encode a compound object as a binary string by combining the representations of its constituent parts. Polygons, graphs, functions, ordered pairs, programs--all can be encoded as binary strings.\n\nFootnote 3: The codomain of \\(e\\) need not be _binary_ strings: any set of strings over a finite alphabet having at least two symbols will do.\n\nThus, a computer algorithm that \"solves\" some abstract decision problem actually takes an encoding of a problem instance as input. The _size_ of an instance \\(i\\) is just the length of its string, which we denote by \\(|i\\,|\\). We call a problem whose instance set is the set of binary strings a _concrete problem_. We say that an algorithm _solves_ a concrete problem in \\(O(T(n))\\) time if, when it is provided a problem instance \\(i\\) of length \\(n=|i\\,|\\), the algorithm can produce the solution in \\(O(T(n))\\)time.4 A concrete problem is _polynomial-time solvable_, therefore, if there exists an algorithm to solve it in \\(O(n^{k})\\) time for some constant \\(k\\).\n\nFootnote 4: We assume that the algorithm\u2019s output is separate from its input. Because it takes at least one time step to produce each bit of the output and the algorithm takes \\(O(T(n))\\) time steps, the size of the output is \\(O(T(n))\\).\n\nWe can now formally define the _complexity class_\\(\\mathbf{P}\\) as the set of concrete decision problems that are polynomial-time solvable.\n\nEncodings map abstract problems to concrete problems. Given an abstract decision problem \\(Q\\) mapping an instance set \\(I\\) to \\(\\{0,1\\}\\), an encoding \\(e:I\\rightarrow\\{0,1\\}^{*}\\) can induce a related concrete decision problem, which we denote by \\(e(Q)\\).5 If the solution to an abstract-problem instance \\(i\\in I\\) is \\(Q(i)\\in\\{0,1\\}\\), then the solution to the concrete-problem instance \\(e(i)\\in\\{0,1\\}^{*}\\) is also \\(Q(i)\\). As a technicality, some binary strings might represent no meaningful abstract-problem instance. For convenience, assume that any such string maps arbitrarily to \\(0\\). Thus, the concrete problem produces the same solutions as the abstract problem on binary-string instances that represent the encodings of abstract-problem instances.\n\nFootnote 5: The notation \\(\\{0,1\\}^{*}\\) denotes the set of all strings composed of symbols from the set \\(\\{0,1\\}\\).\n\nWe would like to extend the definition of polynomial-time solvability from concrete problems to abstract problems by using encodings as the bridge, ideally with the definition independent of any particular encoding. That is, the efficiency of solving a problem should not depend on how the problem is encoded. Unfortunately, it depends quite heavily on the encoding. For example, suppose that the sole input to an algorithm is an integer \\(k\\), and suppose that the running time of the algorithm is \\(\\Theta(k)\\). If the integer \\(k\\) is provided in _unary_--a string of \\(k\\) 1s--then the running time of the algorithm is \\(O(n)\\) on length-\\(n\\) inputs, which is polynomial time. If the input \\(k\\) is provided using the more natural binary representation, however, then the input length is \\(n=\\lfloor\\lg k\\rfloor+1\\), so the size of the unary encoding is exponential in the size of the binary encoding. With the binary representation, the running time of the algorithm is \\(\\Theta(k)=\\Theta(2^{n})\\), which is exponential in the size of the input. Thus, depending on the encoding, the algorithm runs in either polynomial or superpolynomial time.\n\nThe encoding of an abstract problem matters quite a bit to how we understand polynomial time. We cannot really talk about solving an abstract problem without first specifying an encoding. Nevertheless, in practice, if we rule out \"expensive\" encodings such as unary ones, the actual encoding of a problem makes little difference to whether the problem can be solved in polynomial time. For example, representing integers in base 3 instead of binary has no effect on whether a problem is solvable in polynomial time, since we can convert an integer represented in base 3 to an integer represented in base 2 in polynomial time.\n\nWe say that a function \\(f:\\left\\{0,1\\right\\}^{*}\\rightarrow\\left\\{0,1\\right\\}^{*}\\) is _polynomial-time computable_ if there exists a polynomial-time algorithm \\(A\\) that, given any input \\(x\\in\\left\\{0,1\\right\\}^{*}\\), produces as output \\(f(x)\\). For some set \\(I\\) of problem instances, we say that two encodings \\(e_{1}\\) and \\(e_{2}\\) are _polynomially related_ if there exist two polynomial-time computable functions \\(f_{12}\\) and \\(f_{21}\\) such that for any \\(i\\in I\\), we have \\(f_{12}(e_{1}(i))=e_{2}(i)\\) and \\(f_{21}(e_{2}(i))=e_{1}(i)\\).6 That is, a polynomial-time algorithm can compute the encoding \\(e_{2}(i)\\) from the encoding \\(e_{1}(i)\\), and vice versa. If two encodings \\(e_{1}\\) and \\(e_{2}\\) of an abstract problem are polynomially related, whether the problem is polynomial-time solvable or not is independent of which encoding we use, as the following lemma shows.\n\nFootnote 6: Technically, we also require the functions \\(f_{12}\\) and \\(f_{21}\\) to \u201cmap noninstances to noninstances.\u201d A _noninstance_ of an encoding \\(e\\) is a string \\(x\\in\\left\\{0,1\\right\\}^{*}\\) such that there is no instance \\(i\\) for which \\(e(i)=x\\). We require that \\(f_{12}(x)=y\\) for every noninstance \\(x\\) of encoding \\(e_{1}\\), where \\(y\\) is some noninstance of \\(e_{2}\\), and that \\(f_{21}(x^{\\prime})=y^{\\prime}\\) for every noninstance \\(x^{\\prime}\\) of \\(e_{2}\\), where \\(y^{\\prime}\\) is some noninstance of \\(e_{1}\\).\n\n**Lemma 34.1**: _Let \\(Q\\) be an abstract decision problem on an instance set \\(I\\), and let \\(e_{1}\\) and \\(e_{2}\\) be polynomially related encodings on \\(I\\). Then, \\(e_{1}(Q)\\in\\mathrm{P}\\) if and only if \\(e_{2}(Q)\\in\\mathrm{P}\\)._\n\nWe need only prove the forward direction, since the backward direction is symmetric. Suppose, therefore, that \\(e_{1}(Q)\\) can be solved in \\(O(n^{k})\\) time for some constant \\(k\\). Furthermore, suppose that for any problem instance \\(i\\), the encoding \\(e_{1}(i)\\) can be computed from the encoding \\(e_{2}(i)\\) in \\(O(n^{c})\\) time for some constant \\(c\\), where \\(n=|e_{2}(i)|\\). To solve problem \\(e_{2}(Q)\\) on input \\(e_{2}(i)\\), first compute \\(e_{1}(i)\\) and then run the algorithm for \\(e_{1}(Q)\\) on \\(e_{1}(i)\\). How long does this procedure take? Converting encodings takes \\(O(n^{c})\\) time, and therefore \\(|e_{1}(i)|=O(n^{c})\\), since the output of a serial computer cannot be longer than its running time. Solving the problem on \\(e_{1}(i)\\) takes \\(O(|e_{1}(i)|^{k})=O(n^{ck})\\) time, which is polynomial since both \\(c\\) and \\(k\\) are constants.\n\nThus, whether an abstract problem has its instances encoded in binary or base \\(3\\) does not affect its \"complexity,\" that is, whether it is polynomial-time solvable or not. If instances are encoded in unary, however, its complexity may change. In order to be able to converse in an encoding-independent fashion, we generally assume that problem instances are encoded in any reasonable, concise fashion, unless we specifically say otherwise. To be precise, we assume that the encoding of an integer is polynomially related to its binary representation, and that the encoding of a finite set is polynomially related to its encoding as a list of its elements, enclosed in braces and separated by commas. (ASCII is one such encoding scheme.) Withsuch a \"standard\" encoding in hand, we can derive reasonable encodings of other mathematical objects, such as tuples, graphs, and formulas. To denote the standard encoding of an object, we enclose the object in angle brackets. Thus, \\(\\langle G\\rangle\\) denotes the standard encoding of a graph \\(G\\).\n\nAs long as the encoding implicitly used is polynomially related to this standard encoding, we can talk directly about abstract problems without reference to any particular encoding, knowing that the choice of encoding has no effect on whether the abstract problem is polynomial-time solvable. From now on, we will generally assume that all problem instances are binary strings encoded using the standard encoding, unless we explicitly specify the contrary. We'll also typically neglect the distinction between abstract and concrete problems. You should watch out for problems that arise in practice, however, in which a standard encoding is not obvious and the encoding does make a difference.\n\n##### A formal-language framework\n\nBy focusing on decision problems, we can take advantage of the machinery of formal-language theory. Let's review some definitions from that theory. An _alphabet_\\(\\Sigma\\) is a finite set of symbols. A _language_\\(L\\) over \\(\\Sigma\\) is any set of strings made up of symbols from \\(\\Sigma\\). For example, if \\(\\Sigma=\\{0,1\\}\\), the set \\(L=\\{10,\\allowbreak 11,101,111,1011,1101,10001,\\dots\\}\\) is the language of binary representations of prime numbers. We denote the _empty string_ by \\(\\varepsilon\\), the _empty language_ by \\(\\emptyset\\), and the language of all strings over \\(\\Sigma\\) by \\(\\Sigma^{*}\\). For example, if \\(\\Sigma=\\{0,1\\}\\), then \\(\\Sigma^{*}=\\{\\varepsilon,0,1,00,01,10,11,000,\\dots\\}\\) is the set of all binary strings. Every language \\(L\\) over \\(\\Sigma\\) is a subset of \\(\\Sigma^{*}\\).\n\nLanguages support a variety of operations. Set-theoretic operations, such as _union_ and _intersection_, follow directly from the set-theoretic definitions. We define the _complement_ of a language \\(L\\) by \\(\\overline{L}=\\Sigma^{*}-L\\). The _concatenation_\\(L_{1}L_{2}\\) of two languages \\(L_{1}\\) and \\(L_{2}\\) is the language\n\n\\[L=\\{x_{1}x_{2}:x_{1}\\in L_{1}\\text{ and }x_{2}\\in L_{2}\\}\\enspace.\\]\n\nThe _closure_ or _Kleene star_ of a language \\(L\\) is the language\n\n\\[L^{*}=\\{\\varepsilon\\}\\cup L\\cup L^{2}\\cup L^{3}\\cup\\cdots\\enspace,\\]\n\nwhere \\(L^{k}\\) is the language obtained by concatenating \\(L\\) to itself \\(k\\) times.\n\nFrom the point of view of language theory, the set of instances for any decision problem \\(Q\\) is simply the set \\(\\Sigma^{*}\\), where \\(\\Sigma=\\{0,1\\}\\). Since \\(Q\\) is entirely characterized by those problem instances that produce a 1 (yes) answer, we can view \\(Q\\) as a language \\(L\\) over \\(\\Sigma=\\{0,1\\}\\), where\n\n\\[L=\\{x\\in\\Sigma^{*}:Q(x)=1\\}\\enspace.\\]For example, the decision problem PATH has the corresponding language\n\n\\[\\text{PATH}=\\{\\langle G,u,v,k\\rangle: \\ G=(V,E)\\text{ is an undirected graph,}\\] \\[u,v\\in V,\\] \\[k\\geq 0\\text{ is an integer, and}\\] \\[G\\text{ contains a path from }u\\text{ to }v\\text{ with at most }k\\text{ edges}\\}\\text{.}\\]\n\n(Where convenient, we'll sometimes use the same name--PATH in this case--to refer to both a decision problem and its corresponding language.)\n\nThe formal-language framework allows us to express concisely the relation between decision problems and algorithms that solve them. We say that an algorithm _A accepts_ a string \\(x\\in\\{0,1\\}^{*}\\) if, given input \\(x\\), the algorithm's output \\(A(x)\\) is 1. The language _accepted_ by an algorithm \\(A\\) is the set of strings \\(L=\\{x\\in\\{0,1\\}^{*}:A(x)=1\\}\\), that is, the set of strings that the algorithm accepts. An algorithm _A rejects_ a string \\(x\\) if \\(A(x)=0\\).\n\nEven if language \\(L\\) is accepted by an algorithm \\(A\\), the algorithm does not necessarily reject a string \\(x\\notin L\\) provided as input to it. For example, the algorithm might loop forever. A language \\(L\\) is _decided_ by an algorithm \\(A\\) if every binary string in \\(L\\) is accepted by \\(A\\) and every binary string not in \\(L\\) is rejected by \\(A\\). A language \\(L\\) is _accepted in polynomial time_ by an algorithm \\(A\\) if it is accepted by \\(A\\) and if in addition there exists a constant \\(k\\) such that for any length-\\(n\\) string \\(x\\in L\\), algorithm \\(A\\) accepts \\(x\\) in \\(O(n^{k})\\) time. A language \\(L\\) is _decided in polynomial time_ by an algorithm \\(A\\) if there exists a constant \\(k\\) such that for any length-\\(n\\) string \\(x\\in\\{0,1\\}^{*}\\), the algorithm correctly decides whether \\(x\\in L\\) in \\(O(n^{k})\\) time. Thus, to accept a language, an algorithm need only produce an answer when provided a string in \\(L\\), but to decide a language, it must correctly accept or reject every string in \\(\\{0,1\\}^{*}\\).\n\nAs an example, the language PATH can be accepted in polynomial time. One polynomial-time accepting algorithm verifies that \\(G\\) encodes an undirected graph, verifies that \\(u\\) and \\(v\\) are vertices in \\(G\\), uses breadth-first search to compute a path from \\(u\\) to \\(v\\) in \\(G\\) with the fewest edges, and then compares the number of edges on the path obtained with \\(k\\). If \\(G\\) encodes an undirected graph and the path found from \\(u\\) to \\(v\\) has at most \\(k\\) edges, the algorithm outputs 1 and halts. Otherwise, the algorithm runs forever. This algorithm does not decide PATH, however, since it does not explicitly output 0 for instances in which a shortest path has more than \\(k\\) edges. A decision algorithm for PATH must explicitly reject binary strings that do not belong to PATH. For a decision problem such as PATH, such a decision algorithm is straightforward to design: instead of running forever when there is not a path from \\(u\\) to \\(v\\) with at most \\(k\\) edges, it outputs 0 and halts. (It must also output 0 and halt if the input encoding is faulty.) For other problems, such as Turing's Halting Problem, there exists an accepting algorithm, but no decision algorithm exists.\n\nWe can informally define a _complexity class_ as a set of languages, membership in which is determined by a _complexity measure_, such as running time, of an algorithm that determines whether a given string \\(x\\) belongs to language \\(L\\). The actual definition of a complexity class is somewhat more technical.7\n\nFootnote 7: For more on complexity classes, see the seminal paper by Hartmanis and Stearns [210].\n\nUsing this language-theoretic framework, we can provide an alternative definition of the complexity class P:\n\n\\[\\text{P}=\\left\\{L\\subseteq\\left\\{0,1\\right\\}^{*}:\\text{ there exists an algorithm }A\\text{ that decides }L\\right.\\] \\[\\left.\\text{ in polynomial time}\\right\\}\\,.\\]\n\nIn fact, as the following theorem shows, P is also the class of languages that can be accepted in polynomial time.\n\n**Theorem 34.2**: \\(\\text{P}=\\left\\{L:L\\text{ is accepted by a polynomial-time algorithm}\\right\\}\\,.\\)__\n\n_Proof_ Because the class of languages decided by polynomial-time algorithms is a subset of the class of languages accepted by polynomial-time algorithms, we need only show that if \\(L\\) is accepted by a polynomial-time algorithm, it is decided by a polynomial-time algorithm. Let \\(L\\) be the language accepted by some polynomial-time algorithm \\(A\\). We use a classic \"simulation\" argument to construct another polynomial-time algorithm \\(A^{\\prime}\\) that decides \\(L\\). Because \\(A\\) accepts \\(L\\) in \\(O(n^{k})\\) time for some constant \\(k\\), there also exists a constant \\(c\\) such that \\(A\\) accepts \\(L\\) in at most \\(cn^{k}\\) steps. For any input string \\(x\\), the algorithm \\(A^{\\prime}\\) simulates \\(cn^{k}\\) steps of \\(A\\). After simulating \\(cn^{k}\\) steps, algorithm \\(A^{\\prime}\\) inspects the behavior of \\(A\\). If \\(A\\) has accepted \\(x\\), then \\(A^{\\prime}\\) accepts \\(x\\) by outputting a 1. If \\(A\\) has not accepted \\(x\\), then \\(A^{\\prime}\\) rejects \\(x\\) by outputting a 0. The overhead of \\(A^{\\prime}\\) simulating \\(A\\) does not increase the running time by more than a polynomial factor, and thus \\(A^{\\prime}\\) is a polynomial-time algorithm that decides \\(L\\).\n\nThe proof of Theorem 34.2 is nonconstructive. For a given language \\(L\\in\\text{P}\\), we may not actually know a bound on the running time for the algorithm \\(A\\) that accepts \\(L\\). Nevertheless, we know that such a bound exists, and therefore, that an algorithm \\(A^{\\prime}\\) exists that can check the bound, even though we may not be able to find the algorithm \\(A^{\\prime}\\) easily.\n\n#### Exercises\n\n#### 34.1-1\n\nDefine the optimization problem LONGEST-PATH-LENGTH as the relation that associates each instance of an undirected graph and two vertices with the number of edges in a longest simple path between the two vertices. Define the decision problem LONGEST-PATH \\(=\\{\\langle G,\\,u,\\,v,\\,k\\rangle:G=(V,E)\\) is an undirected graph, \\(u,\\,v\\in V\\), \\(k\\geq 0\\) is an integer, and there exists a simple path from \\(u\\) to \\(v\\) in \\(G\\) consisting of at least \\(k\\) edges\\(\\}\\). Show that the optimization problem LONGEST-PATH-LENGTH can be solved in polynomial time if and only if LONGEST-PATH \\(\\in\\) P.\n\n#### 34.1-2\n\nGive a formal definition for the problem of finding the longest simple cycle in an undirected graph. Give a related decision problem. Give the language corresponding to the decision problem.\n\n#### 34.1-3\n\nGive a formal encoding of directed graphs as binary strings using an adjacency-matrix representation. Do the same using an adjacency-list representation. Argue that the two representations are polynomially related.\n\n#### 34.1-4\n\nIs the dynamic-programming algorithm for the 0-1 knapsack problem that is asked for in Exercise 15.2-2 a polynomial-time algorithm? Explain your answer.\n\n#### 34.1-5\n\nShow that if an algorithm makes at most a constant number of calls to polynomial-time subroutines and performs an additional amount of work that also takes polynomial time, then it runs in polynomial time. Also show that a polynomial number of calls to polynomial-time subroutines may result in an exponential-time algorithm.\n\n#### 34.1-6\n\nShow that the class P, viewed as a set of languages, is closed under union, intersection, concatenation, complement, and Kleene star. That is, if \\(L_{1},\\,L_{2}\\in\\) P, then \\(L_{1}\\cup L_{2}\\in\\) P, \\(L_{1}\\cap L_{2}\\in\\) P, \\(L_{1}\\,L_{2}\\in\\) P, \\(\\overline{L}_{1}\\in\\) P, and \\(L_{1}^{*}\\in\\) P.\n\n### 34.2 Polynomial-time verification\n\nNow, let's look at algorithms that verify membership in languages. For example, suppose that for a given instance \\(\\langle G,u,v,k\\rangle\\) of the decision problem PATH, you are also given a path \\(p\\) from \\(u\\) to \\(v\\). You can check whether \\(p\\) is a path in \\(G\\) and whether the length of \\(p\\) is at most \\(k\\), and if so, you can view \\(p\\) as a \"certificate\" that the instance indeed belongs to PATH. For the decision problem PATH, this certificate doesn't seem to buy much. After all, PATH belongs to P--in fact, you can solve PATH in linear time--and so verifying membership from a given certificate takes as long as solving the problem from scratch. Instead, let's examine a problem for which we know of no polynomial-time decision algorithm and yet, given a certificate, verification is easy.\n\n#### Hamiltonian cycles\n\nThe problem of finding a hamiltonian cycle in an undirected graph has been studied for over a hundred years. Formally, a _hamiltonian cycle_ of an undirected graph \\(G=(V,E)\\) is a simple cycle that contains each vertex in \\(V\\). A graph that contains a hamiltonian cycle is said to be _hamiltonian_, and otherwise, it is _nonhamiltonian_. The name honors W. R. Hamilton, who described a mathematical game on the dodecahedron (Figure 34.2(a)) in which one player sticks five pins in any five consecutive vertices and the other player must complete the path to form a cycle containing all the vertices.8 The dodecahedron is hamiltonian, and Figure 34.2(a) shows one hamiltonian cycle. Not all graphs are hamiltonian, however. For example, Figure 34.2(b) shows a bipartite graph with an odd number of vertices. Exercise 34.2-2 asks you to show that all such graphs are nonhamiltonian.\n\nFootnote 8: In a letter dated 17 October 1856 to his friend John T. Graves, Hamilton [206, p. 624] wrote, \u201cI have found that some young persons have been much amused by trying a new mathematical game which the Icosion furnishes, one person sticking five pins in any five consecutive points...and the other player then aiming to insert, which by the theory in this letter can always be done, fifteen other pins, in cyclical succession, so as to cover all the other points, and to end in immediate proximity to the pin wherewith his antagonist had begun.\u201d\n\nHere is how to define the _hamiltonian-cycle problem_, \"Does a graph \\(G\\) have a hamiltonian cycle?\" as a formal language:\n\n\\[\\text{HAM-CYCLE}=\\{\\langle G\\rangle:G\\text{ is a hamiltonian graph}\\}\\text{ }.\\]\n\nHow might an algorithm decide the language HAM-CYCLE? Given a problem instance \\(\\langle G\\rangle\\), one possible decision algorithm lists all permutations of the vertices of \\(G\\) and then checks each permutation to see whether it is a hamiltonian cycle.",
        "chapter": "Part VII Selected Topics",
        "section": "34 NP-Completeness",
        "subsection": "34.1 Polynomial time",
        "subsubsection": "N/A"
    },
    {
        "content": "### 34.2 Polynomial-time verification\n\nNow, let's look at algorithms that verify membership in languages. For example, suppose that for a given instance \\(\\langle G,u,v,k\\rangle\\) of the decision problem PATH, you are also given a path \\(p\\) from \\(u\\) to \\(v\\). You can check whether \\(p\\) is a path in \\(G\\) and whether the length of \\(p\\) is at most \\(k\\), and if so, you can view \\(p\\) as a \"certificate\" that the instance indeed belongs to PATH. For the decision problem PATH, this certificate doesn't seem to buy much. After all, PATH belongs to P--in fact, you can solve PATH in linear time--and so verifying membership from a given certificate takes as long as solving the problem from scratch. Instead, let's examine a problem for which we know of no polynomial-time decision algorithm and yet, given a certificate, verification is easy.\n\n#### Hamiltonian cycles\n\nThe problem of finding a hamiltonian cycle in an undirected graph has been studied for over a hundred years. Formally, a _hamiltonian cycle_ of an undirected graph \\(G=(V,E)\\) is a simple cycle that contains each vertex in \\(V\\). A graph that contains a hamiltonian cycle is said to be _hamiltonian_, and otherwise, it is _nonhamiltonian_. The name honors W. R. Hamilton, who described a mathematical game on the dodecahedron (Figure 34.2(a)) in which one player sticks five pins in any five consecutive vertices and the other player must complete the path to form a cycle containing all the vertices.8 The dodecahedron is hamiltonian, and Figure 34.2(a) shows one hamiltonian cycle. Not all graphs are hamiltonian, however. For example, Figure 34.2(b) shows a bipartite graph with an odd number of vertices. Exercise 34.2-2 asks you to show that all such graphs are nonhamiltonian.\n\nFootnote 8: In a letter dated 17 October 1856 to his friend John T. Graves, Hamilton [206, p. 624] wrote, \u201cI have found that some young persons have been much amused by trying a new mathematical game which the Icosion furnishes, one person sticking five pins in any five consecutive points...and the other player then aiming to insert, which by the theory in this letter can always be done, fifteen other pins, in cyclical succession, so as to cover all the other points, and to end in immediate proximity to the pin wherewith his antagonist had begun.\u201d\n\nHere is how to define the _hamiltonian-cycle problem_, \"Does a graph \\(G\\) have a hamiltonian cycle?\" as a formal language:\n\n\\[\\text{HAM-CYCLE}=\\{\\langle G\\rangle:G\\text{ is a hamiltonian graph}\\}\\enspace.\\]\n\nHow might an algorithm decide the language HAM-CYCLE? Given a problem instance \\(\\langle G\\rangle\\), one possible decision algorithm lists all permutations of the vertices of \\(G\\) and then checks each permutation to see whether it is a hamiltonian cycle.\n\nWhat is the running time of this algorithm? It depends on the encoding of the graph \\(G\\). Let's say that \\(G\\) is encoded as its adjacency matrix. If the adjacency matrix contains \\(n\\) entries, so that the length of the encoding of \\(G\\) equals \\(n\\), then the number \\(m\\) of vertices in the graph is \\(\\Omega(\\sqrt{n})\\). There are \\(m!\\) possible permutations of the vertices, and therefore the running time is \\(\\Omega(m!)=\\Omega(\\sqrt{n}\\!)=\\Omega(2^{\\sqrt{n}})\\), which is not \\(O(n^{k})\\) for any constant \\(k\\). Thus, this naive algorithm does not run in polynomial time. In fact, the hamiltonian-cycle problem is NP-complete, as we'll prove in Section 34.5.\n\n##### Verification algorithms\n\nConsider a slightly easier problem. Suppose that a friend tells you that a given graph \\(G\\) is hamiltonian, and then the friend offers to prove it by giving you the vertices in order along the hamiltonian cycle. It would certainly be easy enough to verify the proof: simply verify that the provided cycle is hamiltonian by checking whether it is a permutation of the vertices of \\(V\\) and whether each of the consecutive edges along the cycle actually exists in the graph. You could certainly implement this verification algorithm to run in \\(O(n^{2})\\) time, where \\(n\\) is the length of the encoding of \\(G\\). Thus, a proof that a hamiltonian cycle exists in a graph can be verified in polynomial time.\n\nFigure 34.2: **(a)** A graph representing the vertices, edges, and faces of a dodecahedron, with a hamiltonian cycle shown by edges highlighted in blue. **(b)** A bipartite graph with an odd number of vertices. Any such graph is nonhamiltonian.\n\nWe define a _verification algorithm_ as being a two-argument algorithm \\(A\\), where one argument is an ordinary input string \\(x\\) and the other is a binary string \\(y\\) called a _certificate_. A two-argument algorithm \\(A\\)_verifies_ an input string \\(x\\) if there exists a certificate \\(y\\) such that \\(A(x,y)=1\\). The _language verified_ by a verification algorithm \\(A\\) is\n\n\\[L=\\left\\{x\\in\\left\\{0,1\\right\\}^{*}:\\text{ there exists }y\\in\\left\\{0,1\\right\\}^{*} \\text{ such that }A(x,y)=1\\right\\}\\text{.}\\]\n\nThink of an algorithm \\(A\\) as verifying a language \\(L\\) if, for any string \\(x\\in L\\), there exists a certificate \\(y\\) that \\(A\\) can use to prove that \\(x\\in L\\). Moreover, for any string \\(x\\notin L\\), there must be no certificate proving that \\(x\\in L\\). For example, in the hamiltonian-cycle problem, the certificate is the list of vertices in some hamiltonian cycle. If a graph is hamiltonian, the hamiltonian cycle itself offers enough information to verify that the graph is indeed hamiltonian. Conversely, if a graph is not hamiltonian, there can be no list of vertices that fools the verification algorithm into believing that the graph is hamiltonian, since the verification algorithm carefully checks the so-called cycle to be sure.\n\n### The complexity class NP\n\nThe _complexity class_ NP is the class of languages that can be verified by a polynomial-time algorithm.9 More precisely, a language \\(L\\) belongs to NP if and only if there exist a two-input polynomial-time algorithm \\(A\\) and a constant \\(c\\) such that\n\nFootnote 9: The name \u201cNP\u201d stands for \u201cnondeterministic polynomial time.\u201d The class NP was originally studied in the context of nondeterminism, but this book uses the somewhat simpler yet equivalent notion of verification. Hopcroft and Ullman [228] give a good presentation of NP-completeness in terms of nondeterministic models of computation.\n\n\\[L=\\left\\{x\\in\\left\\{0,1\\right\\}^{*}:\\text{ there exists a certificate }y\\text{ with }|y|=O(|x|^{c})\\right.\\] \\[\\text{ such that }A(x,y)=1\\right\\}\\text{.}\\]\n\nWe say that algorithm \\(A\\)_verifies_ language \\(L\\)_in polynomial time_.\n\nFrom our earlier discussion about the hamiltonian-cycle problem, you can see that \\(\\operatorname{HAM-CYCLE}\\in\\operatorname{NP}\\). (It is always nice to know that an important set is nonempty.) Moreover, if \\(L\\in\\operatorname{P}\\), then \\(L\\in\\operatorname{NP}\\), since if there is a polynomial-time algorithm to decide \\(L\\), the algorithm can be converted to a two-argument verification algorithm that simply ignores any certificate and accepts exactly those input strings it determines to belong to \\(L\\). Thus, \\(\\operatorname{P}\\subseteq\\operatorname{NP}\\).\n\nThat leaves the question of whether \\(\\operatorname{P}=\\operatorname{NP}\\). A definitive answer is unknown, but most researchers believe that P and NP are not the same class. Think of the class P as consisting of problems that can be solved quickly and the class NP as consisting of problems for which a solution can be verified quickly. You may have learned from experience that it is often more difficult to solve a problem from scratch than to verify a clearly presented solution, especially when working under time constraints. Theoretical computer scientists generally believe that this analogy extends to the classes P and NP, and thus that NP includes languages that do not belong to P.\n\nThere is more compelling, though not conclusive, evidence that \\(\\text{P}\\neq\\text{NP}\\)--the existence of languages that are \"NP-complete.\" Section 34.3 will study this class.\n\nMany other fundamental questions beyond the \\(\\text{P}\\neq\\text{NP}\\) question remain unresolved. Figure 34.3 shows some possible scenarios. Despite much work by many researchers, no one even knows whether the class NP is closed under complement. That is, does \\(L\\in\\text{NP}\\) imply \\(\\overline{L}\\in\\text{NP}\\)? We define the _complexity class_**co-NP** as the set of languages \\(L\\) such that \\(\\overline{L}\\in\\text{NP}\\), so that the question of whether NP is closed under complement is also whether \\(\\text{NP}=\\text{co-NP}\\). Since P is closed under complement (Exercise 34.1-6), it follows from Exercise 34.2-9 (\\(\\text{P}\\subseteq\\text{co-NP}\\)) that \\(\\text{P}\\subseteq\\text{NP}\\cap\\text{co-NP}\\). Once again, however, no one knows whether \\(\\text{P}=\\text{NP}\\cap\\text{co-NP}\\) or whether there is some language in \\((\\text{NP}\\cap\\text{co-NP})-\\text{P}\\).\n\nThus our understanding of the precise relationship between P and NP is woefully incomplete. Nevertheless, even though we might not be able to prove that a particular problem is intractable, if we can prove that it is NP-complete, then we have gained valuable information about it.\n\nFigure 34.3: Four possibilities for relationships among complexity classes. In each diagram, one region enclosing another indicates a proper-subset relation. **(a)**\\(\\text{P}=\\text{NP}=\\text{co-NP}\\). Most researchers regard this possibility as the most unlikely. **(b)** If NP is closed under complement, then \\(\\text{NP}=\\text{co-NP}\\), but it need not be the case that \\(\\text{P}=\\text{NP}\\). **(c)**\\(\\text{P}=\\text{NP}\\cap\\text{co-NP}\\), but NP is not closed under complement. **(d)**\\(\\text{NP}\\neq\\text{co-NP}\\) and \\(\\text{P}\\neq\\text{NP}\\cap\\text{co-NP}\\). Most researchers regard this possibility as the most likely.\n\n### Exercises\n\n#### 34.2-1\n\nConsider the language GRAPH-ISOMORPHISM \\(=\\{\\langle G_{1},\\,G_{2}\\rangle:G_{1}\\) and \\(G_{2}\\) are isomorphic graphs\\(\\}\\). Prove that GRAPH-ISOMORPHISM \\(\\in\\) NP by describing a polynomial-time algorithm to verify the language.\n\n#### 34.2-2\n\nProve that if \\(G\\) is an undirected bipartite graph with an odd number of vertices, then \\(G\\) is nonhamiltonian.\n\n#### 34.2-3\n\nShow that if \\(\\text{HAM-CYCLE}\\in\\text{P}\\), then the problem of listing the vertices of a hamiltonian cycle, in order, is polynomial-time solvable.\n\n#### 34.2-4\n\nProve that the class NP of languages is closed under union, intersection, concatenation, and Kleene star. Discuss the closure of NP under complement.\n\n#### 34.2-5\n\nShow that any language in NP can be decided by an algorithm with a running time of \\(2^{O(n^{k})}\\) for some constant \\(k\\).\n\n#### 34.2-6\n\nA _hamiltonian path_ in a graph is a simple path that visits every vertex exactly once. Show that the language \\(\\text{HAM-PATH}=\\{\\langle G,u,\\,v\\rangle:\\) there is a hamiltonian path from \\(u\\) to \\(v\\) in graph \\(G\\}\\) belongs to NP.\n\n#### 34.2-7\n\nShow that the hamiltonian-path problem from Exercise 34.2-6 can be solved in polynomial time on directed acyclic graphs. Give an efficient algorithm for the problem.\n\n#### 34.2-8\n\nLet \\(\\phi\\) be a boolean formula constructed from the boolean input variables \\(x_{1},x_{2}\\), \\(\\ldots,x_{k}\\), negations (\\(\\neg\\)), ANDs (\\(\\wedge\\)), ORs (\\(\\vee\\)), and parentheses. The formula \\(\\phi\\) is a _tautology_ if it evaluates to 1 for every assignment of 1 and 0 to the input variables. Define TAUTOLOGY as the language of boolean formulas that are tautologies. Show that TAUTOLOGY \\(\\in\\) co-NP.\n\n#### 34.2-9\n\nProve that P \\(\\subseteq\\) co-NP.\n\n#### 34.2-10\n\nProve that if \\(\\mathrm{NP}\\neq\\mathrm{co}\\)-\\(\\mathrm{NP}\\), then \\(\\mathrm{P}\\neq\\mathrm{NP}\\).\n\n#### 34.2-11\n\nLet \\(G\\) be a connected, undirected graph with at least three vertices, and let \\(G^{3}\\) be the graph obtained by connecting all pairs of vertices that are connected by a path in \\(G\\) of length at most 3. Prove that \\(G^{3}\\) is hamiltonian. (_Hint:_ Construct a spanning tree for \\(G\\), and use an inductive argument.)\n\n### NP-completeness and reducibility\n\nPerhaps the most compelling reason why theoretical computer scientists believe that \\(\\mathrm{P}\\neq\\mathrm{NP}\\) comes from the existence of the class of \\(\\mathrm{NP}\\)-complete problems. This class has the intriguing property that if _any_\\(\\mathrm{NP}\\)-complete problem can be solved in polynomial time, then _every_ problem in \\(\\mathrm{NP}\\) has a polynomial-time solution, that is, \\(\\mathrm{P}=\\mathrm{NP}\\). Despite decades of study, though, no polynomial-time algorithm has ever been discovered for any \\(\\mathrm{NP}\\)-complete problem.\n\nThe language HAM-CYCLE is one \\(\\mathrm{NP}\\)-complete problem. If there were an algorithm to decide HAM-CYCLE in polynomial time, then every problem in \\(\\mathrm{NP}\\) could be solved in polynomial time. The \\(\\mathrm{NP}\\)-complete languages are, in a sense, the \"hardest\" languages in \\(\\mathrm{NP}\\). In fact, if \\(\\mathrm{NP}-\\mathrm{P}\\) turns out to be nonempty, we will be able to say with certainty that \\(\\mathrm{HAM}\\)-\\(\\mathrm{CYCLE}\\in\\mathrm{NP}-\\mathrm{P}\\).\n\nThis section starts by showing how to compare the relative \"hardness\" of languages using a precise notion called \"polynomial-time reducibility.\" It then formally defines the \\(\\mathrm{NP}\\)-complete languages, finishing by sketching a proof that one such language, called CIRCUIT-SAT, is \\(\\mathrm{NP}\\)-complete. Sections 34.4 and 34.5 will use the notion of reducibility to show that many other problems are \\(\\mathrm{NP}\\)-complete.\n\n### Reducibility\n\nOne way that sometimes works for solving a problem is to recast it as a different problem. We call that strategy \"reducing\" one problem to another. Think of a problem \\(Q\\) as being reducible to another problem \\(Q^{\\prime}\\) if any instance of \\(Q\\) can be recast as an instance of \\(Q^{\\prime}\\), and the solution to the instance of \\(Q^{\\prime}\\) provides a solution to the instance of \\(Q\\). For example, the problem of solving linear equations in an indeterminate \\(x\\) reduces to the problem of solving quadratic equations. Given a linear-equation instance \\(ax+b=0\\) (with solution \\(x=-b/a\\)), you can transform it to the quadratic equation \\(ax^{2}+bx+0=0\\). This quadratic equation has the solutions \\(x=(-b\\pm\\sqrt{b^{2}-4ac})/2a\\), where \\(c=0\\), so that \\(\\sqrt{b^{2}-4ac}=b\\). The",
        "chapter": "Part VII Selected Topics",
        "section": "34 NP-Completeness",
        "subsection": "34.2 Polynomial-time verification",
        "subsubsection": "N/A"
    },
    {
        "content": "#### 34.2-10\n\nProve that if \\(\\mathrm{NP}\\neq\\mathrm{co}\\)-\\(\\mathrm{NP}\\), then \\(\\mathrm{P}\\neq\\mathrm{NP}\\).\n\n#### 34.2-11\n\nLet \\(G\\) be a connected, undirected graph with at least three vertices, and let \\(G^{3}\\) be the graph obtained by connecting all pairs of vertices that are connected by a path in \\(G\\) of length at most 3. Prove that \\(G^{3}\\) is hamiltonian. (_Hint:_ Construct a spanning tree for \\(G\\), and use an inductive argument.)\n\n### NP-completeness and reducibility\n\nPerhaps the most compelling reason why theoretical computer scientists believe that \\(\\mathrm{P}\\neq\\mathrm{NP}\\) comes from the existence of the class of \\(\\mathrm{NP}\\)-complete problems. This class has the intriguing property that if _any_\\(\\mathrm{NP}\\)-complete problem can be solved in polynomial time, then _every_ problem in \\(\\mathrm{NP}\\) has a polynomial-time solution, that is, \\(\\mathrm{P}=\\mathrm{NP}\\). Despite decades of study, though, no polynomial-time algorithm has ever been discovered for any \\(\\mathrm{NP}\\)-complete problem.\n\nThe language HAM-CYCLE is one \\(\\mathrm{NP}\\)-complete problem. If there were an algorithm to decide HAM-CYCLE in polynomial time, then every problem in \\(\\mathrm{NP}\\) could be solved in polynomial time. The \\(\\mathrm{NP}\\)-complete languages are, in a sense, the \"hardest\" languages in \\(\\mathrm{NP}\\). In fact, if \\(\\mathrm{NP}-\\mathrm{P}\\) turns out to be nonempty, we will be able to say with certainty that \\(\\mathrm{HAM}\\)-CYCLE \\(\\in\\mathrm{NP}-\\mathrm{P}\\).\n\nThis section starts by showing how to compare the relative \"hardness\" of languages using a precise notion called \"polynomial-time reducibility.\" It then formally defines the \\(\\mathrm{NP}\\)-complete languages, finishing by sketching a proof that one such language, called CIRCUIT-SAT, is \\(\\mathrm{NP}\\)-complete. Sections 34.4 and 34.5 will use the notion of reducibility to show that many other problems are \\(\\mathrm{NP}\\)-complete.\n\n### Reducibility\n\nOne way that sometimes works for solving a problem is to recast it as a different problem. We call that strategy \"reducing\" one problem to another. Think of a problem \\(Q\\) as being reducible to another problem \\(Q^{\\prime}\\) if any instance of \\(Q\\) can be recast as an instance of \\(Q^{\\prime}\\), and the solution to the instance of \\(Q^{\\prime}\\) provides a solution to the instance of \\(Q\\). For example, the problem of solving linear equations in an indeterminate \\(x\\) reduces to the problem of solving quadratic equations. Given a linear-equation instance \\(ax+b=0\\) (with solution \\(x=-b/a\\)), you can transform it to the quadratic equation \\(ax^{2}+bx+0=0\\). This quadratic equation has the solutions \\(x=(-b\\pm\\sqrt{b^{2}-4ac})/2a\\), where \\(c=0\\), so that \\(\\sqrt{b^{2}-4ac}=b\\). Thesolutions are then \\(x=(-b+b)/2a=0\\) and \\(x=(-b-b)/2a=-b/a\\), thereby providing a solution to \\(ax+b=0\\). Thus, if a problem \\(Q\\) reduces to another problem \\(Q^{\\prime}\\), then \\(Q\\) is, in a sense, \"no harder to solve\" than \\(Q^{\\prime}\\).\n\nReturning to our formal-language framework for decision problems, we say that a language \\(L_{1}\\) is _polynomial-time reducible_ to a language \\(L_{2}\\), written \\(L_{1}\\leq_{\\mathrm{P}}L_{2}\\), if there exists a polynomial-time computable function \\(f:\\left\\{0,1\\right\\}^{*}\\to\\left\\{0,1\\right\\}^{*}\\) such that for all \\(x\\in\\left\\{0,1\\right\\}^{*}\\),\n\n\\[x\\in L_{1}\\text{ if and only if }\\,f(x)\\in L_{2}\\text{.} \\tag{34.1}\\]\n\nWe call the function \\(f\\) the _reduction function_, and a polynomial-time algorithm \\(F\\) that computes \\(f\\) is a _reduction algorithm_.\n\nFigure 34.4 illustrates the idea of a reduction from a language \\(L_{1}\\) to another language \\(L_{2}\\). Each language is a subset of \\(\\left\\{0,1\\right\\}^{*}\\). The reduction function \\(f\\) provides a mapping such that if \\(x\\in L_{1}\\), then \\(f(x)\\in L_{2}\\). Moreover, if \\(x\\notin L_{1}\\), then \\(f(x)\\notin L_{2}\\). Thus, the reduction function maps any instance \\(x\\) of the decision problem represented by the language \\(L_{1}\\) to an instance \\(f(x)\\) of the problem represented by \\(L_{2}\\). Providing an answer to whether \\(f(x)\\in L_{2}\\) directly provides the answer to whether \\(x\\in L_{1}\\). If, in addition, \\(f\\) can be computed in polynomial time, it is a polynomial-time reduction function.\n\nPolynomial-time reductions give us a powerful tool for proving that various languages belong to P.\n\n**Lemma 34.3**: _If \\(L_{1},L_{2}\\subseteq\\left\\{0,1\\right\\}^{*}\\) are languages such that \\(L_{1}\\leq_{\\mathrm{P}}L_{2}\\), then \\(L_{2}\\in\\mathrm{P}\\) implies \\(L_{1}\\in\\mathrm{P}\\)._\n\nFigure 34.4: A function \\(f\\) that reduces language \\(L_{1}\\) to language \\(L_{2}\\). For any input \\(x\\in\\left\\{0,1\\right\\}^{*}\\), the question of whether \\(x\\in L_{1}\\) has the same answer as the question of whether \\(f(x)\\in L_{2}\\).\n\n_Proof_ Let \\(A_{2}\\) be a polynomial-time algorithm that decides \\(L_{2}\\), and let \\(F\\) be a polynomial-time reduction algorithm that computes the reduction function \\(f\\). We show how to construct a polynomial-time algorithm \\(A_{1}\\) that decides \\(L_{1}\\).\n\nFigure 34.5 illustrates how we construct \\(A_{1}\\). For a given input \\(x\\in\\{0,1\\}^{*}\\), algorithm \\(A_{1}\\) uses \\(F\\) to transform \\(x\\) into \\(f(x)\\), and then it uses \\(A_{2}\\) to test whether \\(f(x)\\in L_{2}\\). Algorithm \\(A_{1}\\) takes the output from algorithm \\(A_{2}\\) and produces that answer as its own output.\n\nThe correctness of \\(A_{1}\\) follows from condition (34.1). The algorithm runs in polynomial time, since both \\(F\\) and \\(A_{2}\\) run in polynomial time (see Exercise 34.1-5).\n\n#### NP-completeness\n\nPolynomial-time reductions allow us to formally show that one problem is at least as hard as another, to within a polynomial-time factor. That is, if \\(L_{1}\\leq_{\\mathrm{P}}L_{2}\\), then \\(L_{1}\\) is not more than a polynomial factor harder than \\(L_{2}\\), which is why the \"less than or equal to\" notation for reduction is mnemonic. We can now define the set of NP-complete languages, which are the hardest problems in NP.\n\nA language \\(L\\subseteq\\{0,1\\}^{*}\\) is _NP-complete_ if\n\n1. \\(L\\in\\mathrm{NP}\\), and\n2. \\(L^{\\prime}\\leq_{\\mathrm{P}}L\\) for every \\(L^{\\prime}\\in\\mathrm{NP}\\).\n\nIf a language \\(L\\) satisfies property 2, but not necessarily property 1, we say that \\(L\\) is _NP-hard_. We also define \\(\\mathrm{NPC}\\) to be the class of NP-complete languages.\n\nAs the following theorem shows, NP-completeness is at the crux of deciding whether P is in fact equal to NP.\n\n_Theorem 34.4_ If any NP-complete problem is polynomial-time solvable, then \\(\\mathrm{P}=\\mathrm{NP}\\). Equivalently, if any problem in NP is not polynomial-time solvable, then no NP-complete problem is polynomial-time solvable.\n\n_Proof_ Suppose that \\(L\\in\\mathrm{P}\\) and also that \\(L\\in\\mathrm{NPC}\\). For any \\(L^{\\prime}\\in\\mathrm{NP}\\), we have \\(L^{\\prime}\\leq_{\\mathrm{P}}L\\) by property 2 of the definition of NP-completeness. Thus, by Lemma 34.3, we also have that \\(L^{\\prime}\\in\\mathrm{P}\\), which proves the first statement of the theorem.\n\nTo prove the second statement, consider the contrapositive of the first statement: if \\(\\mathrm{P}\\neq\\mathrm{NP}\\), then there does not exist an NP-complete problem that is polynomial-time solvable. But \\(\\mathrm{P}\\neq\\mathrm{NP}\\) means that there is some problem in NP that is not polynomial-time solvable, and hence the second statement is the contrapositive of the first statement.\n\nIt is for this reason that research into the \\(\\mathrm{P}\\neq\\mathrm{NP}\\) question centers around the NP-complete problems. Most theoretical computer scientists believe that \\(\\mathrm{P}\\neq\\mathrm{NP}\\), which leads to the relationships among \\(\\mathrm{P}\\), \\(\\mathrm{NP}\\), and \\(\\mathrm{NPC}\\) shown in Figure 34.6. For all we know, however, someone may yet come up with a polynomial-time algorithm for an NP-complete problem, thus proving that \\(\\mathrm{P}=\\mathrm{NP}\\). Nevertheless, since no polynomial-time algorithm for any NP-complete problem has yet been discovered, a proof that a problem is NP-complete provides excellent evidence that it is intractable.\n\n### Circuit satisfiability\n\nWe have defined the notion of an NP-complete problem, but up to this point, we have not actually proved that any problem is NP-complete. Once we prove that at least one problem is NP-complete, polynomial-time reducibility becomes a tool to prove other problems to be NP-complete. Thus, we now focus on demonstrating the existence of an NP-complete problem: the circuit-satisfiability problem.\n\nUnfortunately, the formal proof that the circuit-satisfiability problem is NP-complete requires technical detail beyond the scope of this text. Instead, we'll informally describe a proof that relies on a basic understanding of boolean combinational circuits.\n\nFigure 34: How most theoretical computer scientists view the relationships among \\(\\mathrm{P}\\), \\(\\mathrm{NP}\\), and \\(\\mathrm{NPC}\\). Both \\(\\mathrm{P}\\) and \\(\\mathrm{NPC}\\) are wholly contained within \\(\\mathrm{NP}\\), and \\(\\mathrm{P}\\cap\\mathrm{NPC}=\\emptyset\\).\n\n#### NP-completeness and reducibility\n\nBoolean combinational circuits are built from boolean combinational elements that are interconnected by wires. A _boolean combinational element_ is any circuit element that has a constant number of boolean inputs and outputs and that performs a well-defined function. Boolean values are drawn from the set \\(\\{0,1\\}\\), where \\(0\\) represents false and \\(1\\) represents true.\n\nThe boolean combinational elements appearing in the circuit-satisfiability problem compute simple boolean functions, and they are known as _logic gates_. Figure 34.7 shows the three basic logic gates used in the circuit-satisfiability problem: the _NOT gate_ (or _inverter_), the _AND gate_, and the _OR gate_. The NOT gate takes a single binary _input_\\(x\\), whose value is either \\(0\\) or \\(1\\), and produces a binary _output_\\(z\\) whose value is opposite that of the input value. Each of the other two gates takes two binary inputs \\(x\\) and \\(y\\) and produces a single binary output \\(z\\).\n\nThe operation of each gate, or of any boolean combinational element, is defined by a _truth table_, shown under each gate in Figure 34.7. A truth table gives the outputs of the combinational element for each possible setting of the inputs. For example, the truth table for the OR gate says that when the inputs are \\(x=0\\) and \\(y=1\\), the output value is \\(z=1\\). The symbol \\(\\neg\\) denotes the NOT function, \\(\\wedge\\) denotes the AND function, and \\(\\vee\\) denotes the OR function. Thus, for example, \\(0\\lor 1=1\\).\n\nAND and OR gates are not limited to just two inputs. An AND gate's output is \\(1\\) if all of its inputs are \\(1\\), and its output is \\(0\\) otherwise. An OR gate's output is \\(1\\) if any of its inputs are \\(1\\), and its output is \\(0\\) otherwise.\n\nA _boolean combinational circuit_ consists of one or more boolean combinational elements interconnected by _wires_. A wire can connect the output of one element to the input of another, so that the output value of the first element becomes an input value of the second. Figure 34.8 shows two similar boolean combinational circuits, differing in only one gate. Part (a) of the figure also shows the values on\n\nFigure 34.7: Three basic logic gates, with binary inputs and outputs. Under each gate is the truth table that describes the gate\u2019s operation. **(a)** The NOT gate. **(b)** The AND gate. **(c)** The OR gate.\n\nthe individual wires, given the input \\(\\langle x_{1}=1,\\,x_{2}=1,\\,x_{3}=0\\rangle\\). Although a single wire may have no more than one combinational-element output connected to it, it can feed several element inputs. The number of element inputs fed by a wire is called the _fan-out_ of the wire. If no element output is connected to a wire, the wire is a _circuit input_, accepting input values from an external source. If no element input is connected to a wire, the wire is a _circuit output_, providing the results of the circuit's computation to the outside world. (An internal wire can also fan out to a circuit output.) For the purpose of defining the circuit-satisfiability problem, we limit the number of circuit outputs to 1, though in actual hardware design, a boolean combinational circuit may have multiple outputs.\n\nBoolean combinational circuits contain no cycles. In other words, for a given combinational circuit, imagine a directed graph \\(G=(V,E)\\) with one vertex for each combinational element and with \\(k\\) directed edges for each wire whose fan-out is \\(k\\), where the graph contains a directed edge \\((u,v)\\) if a wire connects the output of element \\(u\\) to an input of element \\(v\\). Then \\(G\\) must be acyclic.\n\nA _truth assignment_ for a boolean combinational circuit is a set of boolean input values. We say that a 1-output boolean combinational circuit is _satisfiable_ if it has a _satisfying assignment_: a truth assignment that causes the output of the circuit to be 1. For example, the circuit in Figure 34.8(a) has the satisfying assignment \\(\\langle x_{1}=1,\\,x_{2}=1,\\,x_{3}=0\\rangle\\), and so it is satisfiable. As Exercise 34.3-1 asks you to show, no assignment of values to \\(x_{1},\\,x_{2},\\,\\text{and}\\,\\,x_{3}\\) causes the circuit in Figure 34.8(b) to produce a 1 output. Since it always produces 0, it is unsatisfiable.\n\nThe _circuit-satisfiability problem_ is, \"Given a boolean combinational circuit composed of AND, OR, and NOT gates, is it satisfiable?\" In order to pose this\n\nFigure 34.8: Two instances of the circuit-satisfiability problem. **(a)** The assignment \\(\\langle x_{1}=1,\\,x_{2}=1,\\,x_{3}=0\\rangle\\) to the inputs of this circuit causes the output of the circuit to be 1. The circuit is therefore satisfiable. **(b)** No assignment to the inputs of this circuit can cause the output of the circuit to be 1. The circuit is therefore unsatisfiable.\n\nquestion formally, however, we must agree on a standard encoding for circuits. The _size_ of a boolean combinational circuit is the number of boolean combinational elements plus the number of wires in the circuit. We could devise a graph-like encoding that maps any given circuit \\(C\\) into a binary string \\(\\langle C\\rangle\\) whose length is polynomial in the size of the circuit itself. As a formal language, we can therefore define\n\n\\[\\text{CIRCUIT-SAT}=\\{\\langle C\\rangle:C\\text{ is a satisfiable boolean combinational circuit}\\}\\enspace.\\]\n\nThe circuit-satisfiability problem arises in the area of computer-aided hardware optimization. If a subcircuit always produces \\(0\\), that subcircuit is unnecessary: the designer can replace it by a simpler subcircuit that omits all logic gates and provides the constant \\(0\\) value as its output. You can see the value in having a polynomial-time algorithm for this problem.\n\nGiven a circuit \\(C\\), you can determine whether it is satisfiable by simply checking all possible assignments to the inputs. Unfortunately, if the circuit has \\(k\\) inputs, then you would have to check up to \\(2^{k}\\) possible assignments. When the size of \\(C\\) is polynomial in \\(k\\), checking all possible assignments to the inputs takes \\(\\Omega(2^{k})\\) time, which is superpolynomial in the size of the circuit.10 In fact, as we have claimed, there is strong evidence that no polynomial-time algorithm exists that solves the circuit-satisfiability problem because circuit satisfiability is NP-complete. We break the proof of this fact into two parts, based on the two parts of the definition of NP-completeness.\n\nFootnote 10: On the other hand, if the size of the circuit \\(C\\) is \\(\\Theta(2^{k})\\), then an algorithm whose running time is \\(O(2^{k})\\) has a running time that is polynomial in the circuit size. Even if \\(\\text{P}\\neq\\text{NP}\\), this situation would not contradict the NP-completeness of the problem. The existence of a polynomial-time algorithm for a special case does not imply that there is a polynomial-time algorithm for all cases.\n\n**Lemma 34.5**: _The circuit-satisfiability problem belongs to the class NP._\n\n_Proof_ We provide a two-input, polynomial-time algorithm \\(A\\) that can verify CIRCUIT-SAT. One of the inputs to \\(A\\) is (a standard encoding of) a boolean combinational circuit \\(C\\). The other input is a certificate corresponding to an assignment of a boolean value to each of the wires in \\(C\\). (See Exercise 34.3-4 for a smaller certificate.)\n\nThe algorithm \\(A\\) works as follows. For each logic gate in the circuit, it checks that the value provided by the certificate on the output wire is correctly computed as a function of the values on the input wires. Then, if the output of the entire circuit is \\(1\\), algorithm \\(A\\) outputs \\(1\\), since the values assigned to the inputs of \\(C\\) provide a satisfying assignment. Otherwise, \\(A\\) outputs \\(0\\).\n\nWhenever a satisfiable circuit \\(C\\) is input to algorithm \\(A\\), there exists a certificate whose length is polynomial in the size of \\(C\\) and that causes \\(A\\) to output a 1. Whenever an unsatisfiable circuit is input, no certificate can fool \\(A\\) into believing that the circuit is satisfiable. Algorithm \\(A\\) runs in polynomial time, and with a good implementation, linear time suffices. Thus, CIRCUIT-SAT is verifiable in polynomial time, and CIRCUIT-\\(\\mathrm{SAT}\\in\\mathrm{NP}\\).\n\nThe second part of proving that CIRCUIT-SAT is NP-complete is to show that the language is NP-hard: that _every_ language in NP is polynomial-time reducible to CIRCUIT-SAT. The actual proof of this fact is full of technical intricacies, and so instead we'll sketch the proof based on some understanding of the workings of computer hardware.\n\nA computer program is stored in the computer's memory as a sequence of instructions. A typical instruction encodes an operation to be performed, addresses of operands in memory, and an address where the result is to be stored. A special memory location, called the _program counter_, keeps track of which instruction is to be executed next. The program counter automatically increments when each instruction is fetched, thereby causing the computer to execute instructions sequentially. Certain instructions can cause a value to be written to the program counter, however, which alters the normal sequential execution and allows the computer to loop and perform conditional branches.\n\nAt any point while a program executes, the computer's memory holds the entire state of the computation. (Consider the memory to include the program itself, the program counter, working storage, and any of the various bits of state that a computer maintains for bookkeeping.) We call any particular state of computer memory a _configuration_. When an instruction executes, it transforms the configuration. Think of an instruction as mapping one configuration to another. The computer hardware that accomplishes this mapping can be implemented as a boolean combinational circuit, which we denote by \\(M\\) in the proof of the following lemma.\n\n**Lemma 34.6**: _The circuit-satisfiability problem is NP-hard._\n\n_Proof_ Let \\(L\\) be any language in NP. We'll describe a polynomial-time algorithm \\(F\\) computing a reduction function \\(f\\) that maps every binary string \\(x\\) to a circuit \\(C=f(x)\\) such that \\(x\\in L\\) if and only if \\(C\\in\\mathrm{CIRCUIT-SAT}\\).\n\nSince \\(L\\in\\mathrm{NP}\\), there must exist an algorithm \\(A\\) that verifies \\(L\\) in polynomial time. The algorithm \\(F\\) that we construct uses the two-input algorithm \\(A\\) to compute the reduction function \\(f\\).\n\nLet \\(T(n)\\) denote the worst-case running time of algorithm \\(A\\) on length-\\(n\\) input strings, and let \\(k\\geq 1\\) be a constant such that \\(T(n)=O(n^{k})\\) and the length of the \n\n#### 34.3 NP-completeness and reducibility\n\nThe resulting \\(A\\) is a polynomial in the total input size, which includes both an input string and a certificate, but since the length of the certificate is polynomial in the length \\(n\\) of the input string, the running time is polynomial in \\(n\\).)\n\nThe basic idea of the proof is to represent the computation of \\(A\\) as a sequence of configurations. As Figure 34.9 illustrates, consider each configuration as com\n\nFigure 34.9: The sequence of configurations produced by an algorithm \\(A\\) running on an input \\(x\\) and certificate \\(y\\). Each configuration represents the state of the computer for one step of the computation and, besides \\(A\\), \\(x\\), and \\(y\\), includes the program counter (PC), auxiliary machine state, and working storage. Except for the certificate \\(y\\), the initial configuration \\(c_{\\boldsymbol{0}}\\) is constant. A boolean combinational circuit \\(M\\) maps each configuration to the next configuration. The output is a distinguished bit in the working storage.\n\nprising a few parts: the program for \\(A\\), the program counter and auxiliary machine state, the input \\(x\\), the certificate \\(y\\), and working storage. The combinational circuit \\(M\\), which implements the computer hardware, maps each configuration \\(c_{i}\\) to the next configuration \\(c_{i+1}\\), starting from the initial configuration \\(c_{0}\\). Algorithm \\(A\\) writes its output\\(-0\\) or \\(1-\\)to some designated location by the time it finishes executing. After \\(A\\) halts, the output value never changes. Thus, if the algorithm runs for at most \\(T(n)\\) steps, the output appears as one of the bits in \\(c_{T(n)}\\).\n\nThe reduction algorithm \\(F\\) constructs a single combinational circuit that computes all configurations produced by a given initial configuration. The idea is to paste together \\(T(n)\\) copies of the circuit \\(M\\). The output of the \\(i\\)th circuit, which produces configuration \\(c_{i}\\), feeds directly into the input of the \\((i+1)\\)st circuit. Thus, the configurations, rather than being stored in the computer's memory, simply reside as values on the wires connecting copies of \\(M\\).\n\nRecall what the polynomial-time reduction algorithm \\(F\\) must do. Given an input \\(x\\), it must compute a circuit \\(C=f(x)\\) that is satisfiable if and only if there exists a certificate \\(y\\) such that \\(A(x,y)=1\\). When \\(F\\) obtains an input \\(x\\), it first computes \\(n=|x|\\) and constructs a combinational circuit \\(C^{\\prime}\\) consisting of \\(T(n)\\) copies of \\(M\\). The input to \\(C^{\\prime}\\) is an initial configuration corresponding to a computation on \\(A(x,y)\\), and the output is the configuration \\(c_{T(n)}\\).\n\nAlgorithm \\(F\\) modifies circuit \\(C^{\\prime}\\) slightly to construct the circuit \\(C=f(x)\\). First, it wires the inputs to \\(C^{\\prime}\\) corresponding to the program for \\(A\\), the initial program counter, the input \\(x\\), and the initial state of memory directly to these known values. Thus, the only remaining inputs to the circuit correspond to the certificate \\(y\\). Second, it ignores all outputs from \\(C^{\\prime}\\), except for the one bit of \\(c_{T(n)}\\) corresponding to the output of \\(A\\). This circuit \\(C\\), so constructed, computes \\(C(y)=A(x,y)\\) for any input \\(y\\) of length \\(O(n^{k})\\). The reduction algorithm \\(F\\), when provided an input string \\(x\\), computes such a circuit \\(C\\) and outputs it.\n\nWe need to prove two properties. First, we must show that \\(F\\) correctly computes a reduction function \\(f\\). That is, we must show that \\(C\\) is satisfiable if and only if there exists a certificate \\(y\\) such that \\(A(x,y)=1\\). Second, we must show that \\(F\\) runs in polynomial time.\n\nTo show that \\(F\\) correctly computes a reduction function, suppose that there exists a certificate \\(y\\) of length \\(O(n^{k})\\) such that \\(A(x,y)=1\\). Then, upon applying the bits of \\(y\\) to the inputs of \\(C\\), the output of \\(C\\) is \\(C(y)=A(x,y)=1\\). Thus, if a certificate exists, then \\(C\\) is satisfiable. For the other direction, suppose that \\(C\\) is satisfiable. Hence, there exists an input \\(y\\) to \\(C\\) such that \\(C(y)=1\\), from which we conclude that \\(A(x,y)=1\\). Thus, \\(F\\) correctly computes a reduction function.\n\nTo complete the proof sketch, we need to show that \\(F\\) runs in time polynomial in \\(n=|x|\\). First, the number of bits required to represent a configuration is polynomial in \\(n\\). Why? The program for \\(A\\) itself has constant size, independent of the length of its input \\(x\\). The length of the input \\(x\\) is \\(n\\), and the length of the certificate \\(y\\) is \\(O(n^{k})\\). Since the algorithm runs for at most \\(O(n^{k})\\) steps, the amount of working storage required by \\(A\\) is polynomial in \\(n\\) as well. (We implicitly assume that this memory is contiguous. Exercise 34.3-5 asks you to extend the argument to the situation in which the locations accessed by \\(A\\) are scattered across a much larger region of memory and the particular pattern of scattering can differ for each input \\(x\\).)\n\nThe combinational circuit \\(M\\) implementing the computer hardware has size polynomial in the length of a configuration, which is \\(O(n^{k})\\), and hence, the size of \\(M\\) is polynomial in \\(n\\). (Most of this circuitry implements the logic of the memory system.) The circuit \\(C\\) consists of \\(O(n^{k})\\) copies of \\(M\\), and hence it has size polynomial in \\(n\\). The reduction algorithm \\(F\\) can construct \\(C\\) from \\(x\\) in polynomial time, since each step of the construction takes polynomial time.\n\nThe language CIRCUIT-SAT is therefore at least as hard as any language in NP, and since it belongs to NP, it is NP-complete.\n\n**Theorem 34.7**: _The circuit-satisfiability problem is NP-complete._\n\n_Proof_ Immediate from Lemmas 34.5 and 34.6 and from the definition of NP-completeness.\n\nExercises\n\n_34.3-1_\n\nVerify that the circuit in Figure 34.8(b) is unsatisfiable.\n\n_34.3-2_\n\nShow that the \\(\\leq_{\\mathrm{P}}\\) relation is a transitive relation on languages. That is, show that if \\(L_{1}\\leq_{\\mathrm{P}}L_{2}\\) and \\(L_{2}\\leq_{\\mathrm{P}}L_{3}\\), then \\(L_{1}\\leq_{\\mathrm{P}}L_{3}\\).\n\n_34.3-3_\n\nProve that \\(L\\leq_{\\mathrm{P}}\\overline{L}\\) if and only if \\(\\overline{L}\\leq_{\\mathrm{P}}L\\).\n\n_34.3-4_\n\nShow that an alternative proof of Lemma 34.5 can use a satisfying assignment as a certificate. Which certificate makes for an easier proof?\n\n_34.3-5_\n\nThe proof of Lemma 34.6 assumes that the working storage for algorithm \\(A\\) occupies a contiguous region of polynomial size. Where does the proof exploit this assumption? Argue that this assumption does not involve any loss of generality.\n\n#### 34.3-6\n\nA language \\(L\\) is _complete_ for a language class \\(C\\) with respect to polynomial-time reductions if \\(L\\in C\\) and \\(L^{\\prime}\\leq_{\\mathrm{P}}L\\) for all \\(L^{\\prime}\\in C\\). Show that \\(\\emptyset\\) and \\(\\{0,1\\}^{\\star}\\) are the only languages in P that are not complete for P with respect to polynomial-time reductions.\n\n#### 34.3-7\n\nShow that, with respect to polynomial-time reductions (see Exercise 34.3-6), \\(L\\) is complete for NP if and only if \\(\\overline{L}\\) is complete for co-NP.\n\n#### 34.3-8\n\nThe reduction algorithm \\(F\\) in the proof of Lemma 34.6 constructs the circuit \\(C=f(x)\\) based on knowledge of \\(x\\), \\(A\\), and \\(k\\). Professor Sartre observes that the string \\(x\\) is input to \\(F\\), but only the existence of \\(A\\), \\(k\\), and the constant factor implicit in the \\(O(n^{k})\\) running time is known to \\(F\\) (since the language \\(L\\) belongs to NP), not their actual values. Thus, the professor concludes that \\(F\\) cannot possibly construct the circuit \\(C\\) and that the language CIRCUIT-SAT is not necessarily NP-hard. Explain the flaw in the professor's reasoning.\n\n### 34.4 NP-completeness proofs\n\nThe proof that the circuit-satisfiability problem is NP-complete showed directly that \\(L\\leq_{\\mathrm{P}}\\) CIRCUIT-SAT for every language \\(L\\in\\mathrm{NP}\\). This section shows how to prove that languages are NP-complete without directly reducing _every_ language in NP to the given language. We'll explore examples of this methodology by proving that various formula-satisfiability problems are NP-complete. Section 34.5 provides many more examples.\n\nThe following lemma provides a foundation for showing that a given language is NP-complete.\n\n**Lemma 34.8**: _If \\(L\\) is a language such that \\(L^{\\prime}\\leq_{\\mathrm{P}}L\\) for some \\(L^{\\prime}\\in\\mathrm{NPC}\\), then \\(L\\) is NP-hard. If, in addition, we have \\(L\\in\\mathrm{NP}\\), then \\(L\\in\\mathrm{NPC}\\)._\n\n_Proof_ Since \\(L^{\\prime}\\) is NP-complete, for all \\(L^{\\prime\\prime}\\in\\mathrm{NP}\\), we have \\(L^{\\prime\\prime}\\leq_{\\mathrm{P}}L^{\\prime}\\). By supposition, we have \\(L^{\\prime}\\leq_{\\mathrm{P}}L\\), and thus by transitivity (Exercise 34.3-2), we have \\(L^{\\prime\\prime}<_{\\mathrm{P}}L\\), which shows that \\(L\\) is NP-hard. If \\(L\\in\\mathrm{NP}\\), we also have \\(L\\in\\mathrm{NPC}\\).",
        "chapter": "Part VII Selected Topics",
        "section": "34 NP-Completeness",
        "subsection": "34.3 NP-completeness and reducibility",
        "subsubsection": "N/A"
    },
    {
        "content": "#### 34.3-6\n\nA language \\(L\\) is _complete_ for a language class \\(C\\) with respect to polynomial-time reductions if \\(L\\in C\\) and \\(L^{\\prime}\\leq_{\\mathrm{P}}L\\) for all \\(L^{\\prime}\\in C\\). Show that \\(\\emptyset\\) and \\(\\{0,1\\}^{\\star}\\) are the only languages in P that are not complete for P with respect to polynomial-time reductions.\n\n#### 34.3-7\n\nShow that, with respect to polynomial-time reductions (see Exercise 34.3-6), \\(L\\) is complete for NP if and only if \\(\\overline{L}\\) is complete for co-NP.\n\n#### 34.3-8\n\nThe reduction algorithm \\(F\\) in the proof of Lemma 34.6 constructs the circuit \\(C=f(x)\\) based on knowledge of \\(x\\), \\(A\\), and \\(k\\). Professor Sartre observes that the string \\(x\\) is input to \\(F\\), but only the existence of \\(A\\), \\(k\\), and the constant factor implicit in the \\(O(n^{k})\\) running time is known to \\(F\\) (since the language \\(L\\) belongs to NP), not their actual values. Thus, the professor concludes that \\(F\\) cannot possibly construct the circuit \\(C\\) and that the language CIRCUIT-SAT is not necessarily NP-hard. Explain the flaw in the professor's reasoning.\n\n### 34.4 NP-completeness proofs\n\nThe proof that the circuit-satisfiability problem is NP-complete showed directly that \\(L\\leq_{\\mathrm{P}}\\) CIRCUIT-SAT for every language \\(L\\in\\mathrm{NP}\\). This section shows how to prove that languages are NP-complete without directly reducing _every_ language in NP to the given language. We'll explore examples of this methodology by proving that various formula-satisfiability problems are NP-complete. Section 34.5 provides many more examples.\n\nThe following lemma provides a foundation for showing that a given language is NP-complete.\n\n**Lemma 34.8**: _If \\(L\\) is a language such that \\(L^{\\prime}\\leq_{\\mathrm{P}}L\\) for some \\(L^{\\prime}\\in\\mathrm{NPC}\\), then \\(L\\) is NP-hard. If, in addition, we have \\(L\\in\\mathrm{NP}\\), then \\(L\\in\\mathrm{NPC}\\)._\n\n_Proof_ Since \\(L^{\\prime}\\) is NP-complete, for all \\(L^{\\prime\\prime}\\in\\mathrm{NP}\\), we have \\(L^{\\prime\\prime}\\leq_{\\mathrm{P}}L^{\\prime}\\). By supposition, we have \\(L^{\\prime}\\leq_{\\mathrm{P}}L\\), and thus by transitivity (Exercise 34.3-2), we have \\(L^{\\prime\\prime}<_{\\mathrm{P}}L\\), which shows that \\(L\\) is NP-hard. If \\(L\\in\\mathrm{NP}\\), we also have \\(L\\in\\mathrm{NPC}\\).\n\nIn other words, by reducing a known NP-complete language \\(L^{\\prime}\\) to \\(L\\), we implicitly reduce every language in NP to \\(L\\). Thus, Lemma 34.8 provides a method for proving that a language \\(L\\) is NP-complete:\n\n1. Prove \\(L\\in\\text{NP}\\).\n2. Prove that \\(L\\) is NP-hard: 1. Select a known NP-complete language \\(L^{\\prime}\\). 2. Describe an algorithm that computes a function \\(f\\) mapping every instance \\(x\\in\\left\\{0,1\\right\\}^{*}\\) of \\(L^{\\prime}\\) to an instance \\(f(x)\\) of \\(L\\). 3. Prove that the function \\(f\\) satisfies \\(x\\in L^{\\prime}\\) if and only if \\(f(x)\\in L\\) for all \\(x\\in\\left\\{0,1\\right\\}^{*}\\). 4. Prove that the algorithm computing \\(f\\) runs in polynomial time.\n\nThis methodology of reducing from a single known NP-complete language is far simpler than the more complicated process of showing directly how to reduce from every language in NP. Proving CIRCUIT-SAT \\(\\in\\) NPC furnishes a starting point. Knowing that the circuit-satisfiability problem is NP-complete makes it much easier to prove that other problems are NP-complete. Moreover, as the catalog of known NP-complete problems grows, so will the choices for languages from which to reduce.\n\n#### Formula satisfiability\n\nTo illustrate the reduction methodology, let's see an NP-completeness proof for the problem of determining whether a boolean _formula_, not a _circuit_, is satisfiable. This problem has the historical honor of being the first problem ever shown to be NP-complete.\n\nWe formulate the _(formula) satisfiability_ problem in terms of the language SAT as follows. An instance of SAT is a boolean formula \\(\\phi\\) composed of\n\n1. \\(n\\) boolean variables: \\(x_{1},x_{2},\\ldots,x_{n}\\);\n2. \\(m\\) boolean connectives: any boolean function with one or two inputs and one output, such as \\(\\wedge\\) (AND), \\(\\vee\\) (OR), \\(\\neg\\) (NOT), \\(\\rightarrow\\) (implication), \\(\\leftrightarrow\\) (if and only if); and\n3. parentheses. (Without loss of generality, assume that there are no redundant parentheses, i.e., a formula contains at most one pair of parentheses per boolean connective.)\n\nWe can encode a boolean formula \\(\\phi\\) in a length that is polynomial in \\(n+m\\). As in boolean combinational circuits, a _truth assignment_ for a boolean formula \\(\\phi\\)is a set of values for the variables of \\(\\phi\\), and a _satisfying assignment_ is a truth assignment that causes it to evaluate to 1. A formula with a satisfying assignment is a _satisfiable_ formula. The satisfiability problem asks whether a given boolean formula is satisfiable, which we can express in formal-language terms as\n\n\\[\\text{SAT}=\\left\\{\\langle\\phi\\rangle:\\phi\\text{ is a satisfiable boolean formula}\\right\\}\\enspace.\\]\n\nAs an example, the formula\n\n\\[\\phi=\\left((x_{1}\\to x_{2})\\vee\\neg((\\neg x_{1}\\leftrightarrow x_{3})\\lor x _{4})\\right)\\wedge\\neg x_{2}\\]\n\nhas the satisfying assignment \\(\\left\\langle x_{1}=0,x_{2}=0,x_{3}=1,x_{4}=1\\right\\rangle,\\) since\n\n\\[\\phi = \\left((0\\to 0)\\vee\\neg((\\neg 0\\leftrightarrow 1)\\lor 1)) \\wedge\\neg 0\\right.\\] \\[= \\left.(1\\vee\\neg(1\\lor 1))\\wedge 1\\right.\\] \\[= \\left.(1\\lor 0)\\wedge 1\\right.\\] \\[= \\left.1\\right.,\\]\n\nand thus this formula \\(\\phi\\) belongs to SAT.\n\nThe naive algorithm to determine whether an arbitrary boolean formula is satisfiable does not run in polynomial time. A formula with \\(n\\) variables has \\(2^{n}\\) possible assignments. If the length of \\(\\langle\\phi\\rangle\\) is polynomial in \\(n\\), then checking every assignment requires \\(\\Omega(2^{n})\\) time, which is superpolynomial in the length of \\(\\langle\\phi\\rangle\\). As the following theorem shows, a polynomial-time algorithm is unlikely to exist.\n\n**Theorem 34.9**: _Satisfiability of boolean formulas is NP-complete._\n\nProofWe start by arguing that \\(\\text{SAT}\\in\\text{NP}\\). Then we prove that SAT is NP-hard by showing that CIRCUIT-SAT \\(\\leq_{\\text{P}}\\) SAT, which by Lemma 34.8 will prove the theorem.\n\nTo show that SAT belongs to NP, we show that a certificate consisting of a satisfying assignment for an input formula \\(\\phi\\) can be verified in polynomial time. The verifying algorithm simply replaces each variable in the formula with its corresponding value and then evaluates the expression, much as we did in equation (34.2) above. This task can be done in polynomial time. If the expression evaluates to 1, then the algorithm has verified that the formula is satisfiable. Thus, SAT belongs to NP.\n\nTo prove that SAT is NP-hard, we show that CIRCUIT-SAT \\(\\leq_{\\text{P}}\\) SAT. In other words, we need to show how to reduce any instance of circuit satisfiability to an instance of formula satisfiability in polynomial time. We can use induction to express any boolean combinational circuit as a boolean formula. We simply look at the gate that produces the circuit output and inductively express each of the gate's inputs as formulas. We then obtain the formula for the circuit by writing an expression that applies the gate's function to its inputs' formulas.\n\nUnfortunately, this straightforward method does not amount to a polynomial-time reduction. As Exercise 34.4-1 asks you to show, shared subformulas -- which arise from gates whose output wires have fan-out of 2 or more--can cause the size of the generated formula to grow exponentially. Thus, the reduction algorithm must be somewhat more clever.\n\nFigure 34.10 illustrates how to overcome this problem, using as an example the circuit from Figure 34.8(a). For each wire \\(x_{i}\\) in the circuit \\(C\\), the formula \\(\\phi\\) has a variable \\(x_{i}\\). To express how each gate operates, construct a small formula involving the variables of its incident wires. The formula has the form of an \"if and only if\" (\\(\\Leftrightarrow\\)), with the variable for the gate's output on the left and on the right a logical expression encapsulating the gate's function on its inputs. For example, the operation of the output AND gate (the rightmost gate in the figure) is \\(x_{10}\\leftrightarrow(x_{7}\\wedge x_{8}\\wedge x_{9})\\). We call each of these small formulas a _clause_.\n\nThe formula \\(\\phi\\) produced by the reduction algorithm is the AND of the circuit-output variable with the conjunction of clauses describing the operation of each gate. For the circuit in the figure, the formula is\n\n\\[\\phi\\ =\\ x_{10} \\wedge\\ (x_{4}\\ \\Leftrightarrow\\ \\neg x_{3})\\] \\[\\wedge\\ (x_{5}\\ \\Leftrightarrow\\ (x_{1}\\lor x_{2}))\\] \\[\\wedge\\ (x_{6}\\ \\Leftrightarrow\\ \\neg x_{4})\\] \\[\\wedge\\ (x_{7}\\ \\Leftrightarrow\\ (x_{1}\\wedge x_{2}\\wedge x_{4}))\\] \\[\\wedge\\ (x_{8}\\ \\Leftrightarrow\\ (x_{5}\\lor x_{6}))\\] \\[\\wedge\\ (x_{9}\\ \\Leftrightarrow\\ (x_{6}\\lor x_{7}))\\] \\[\\wedge\\ (x_{10}\\ \\Leftrightarrow\\ (x_{7}\\wedge x_{8}\\wedge x_{9}))\\.\\]\n\nFigure 34.10: Reducing circuit satisfiability to formula satisfiability. The formula produced by the reduction algorithm has a variable for each wire in the circuit and a clause for each logic gate.\n\nGiven a circuit \\(C\\), it is straightforward to produce such a formula \\(\\phi\\) in polynomial time.\n\nWhy is the circuit \\(C\\) satisfiable exactly when the formula \\(\\phi\\) is satisfiable? If \\(C\\) has a satisfying assignment, then each wire of the circuit has a well-defined value, and the output of the circuit is 1. Therefore, when wire values are assigned to variables in \\(\\phi\\), each clause of \\(\\phi\\) evaluates to 1, and thus the conjunction of all evaluates to 1. Conversely, if some assignment causes \\(\\phi\\) to evaluate to 1, the circuit \\(C\\) is satisfiable by an analogous argument. Thus, we have shown that CIRCUIT-SAT \\(\\leq_{\\mathrm{P}}\\) SAT, which completes the proof.\n\n### 3-CNF satisfiability\n\nReducing from formula satisfiability gives us an avenue to prove many problems NP-complete. The reduction algorithm must handle any input formula, though, and this requirement can lead to a huge number of cases to consider. Instead, it is usually simpler to reduce from a restricted language of boolean formulas. Of course, the restricted language must not be polynomial-time solvable. One convenient language is 3-CNF satisfiability, or 3-CNF-SAT.\n\nIn order to define 3-CNF satisfiability, we first need to define a few terms. A _literal_ in a boolean formula is an occurrence of a variable (such as \\(x_{1}\\)) or its negation (\\(\\neg x_{1}\\)). A _clause_ is the OR of one or more literals, such as \\(x_{1}\\vee\\neg x_{2}\\vee\\neg x_{3}\\). A boolean formula is in _conjunctive normal form_, or _CNF_, if it is expressed as an AND of clauses, and it's in _3-conjunctive normal form_, or _3-CNF_, if each clause contains exactly three distinct literals.\n\nFor example, the boolean formula\n\n\\[(x_{1}\\vee\\neg x_{1}\\vee\\neg x_{2})\\wedge(x_{3}\\lor x_{2}\\lor x_{4})\\wedge( \\neg x_{1}\\vee\\neg x_{3}\\vee\\neg x_{4})\\]\n\nis in 3-CNF. The first of its three clauses is \\((x_{1}\\vee\\neg x_{1}\\vee\\neg x_{2})\\), which contains the three literals \\(x_{1}\\), \\(\\neg x_{1}\\), and \\(\\neg x_{2}\\).\n\nThe language 3-CNF-SAT consists of encodings of boolean formulas in 3-CNF that are satisfiable. The following theorem shows that a polynomial-time algorithm that can determine the satisfiability of boolean formulas is unlikely to exist, even when they are expressed in this simple normal form.\n\n**Theorem 34.10**: Satisfiability of boolean formulas in 3-conjunctive normal form is NP-complete.\n\nProofThe argument from the proof of Theorem 34.9 to show that \\(\\mathrm{SAT}\\in\\mathrm{NP}\\) applies equally well here to show that \\(\\mathrm{3-CNF-SAT}\\in\\mathrm{NP}\\). By Lemma 34.8, therefore, we need only show that \\(\\mathrm{SAT}\\leq_{\\mathrm{P}}3\\)-CNF-SAT.\n\n#### 34.4 NP-completeness proofs\n\nWe break the reduction algorithm into three basic steps. Each step progressively transforms the input formula \\(\\phi\\) closer to the desired 3-conjunctive normal form.\n\nThe first step is similar to the one used to prove CIRCUIT-SAT \\(\\leq_{\\rm P}\\) SAT in Theorem 34.9. First, construct a binary \"parse\" tree for the input formula \\(\\phi\\), with literals as leaves and connectives as internal nodes. Figure 34.11 shows such a parse tree for the formula\n\n\\[\\phi=((x_{1}\\to x_{2})\\vee\\neg((\\neg x_{1}\\leftrightarrow x_{3})\\lor x_{4})) \\wedge\\neg x_{2}. \\tag{34.3}\\]\n\nIf the input formula contains a clause such as the OR of several literals, use associativity to parenthesize the expression fully so that every internal node in the resulting tree has just one or two children. The binary parse tree is like a circuit for computing the function.\n\nMimicking the reduction in the proof of Theorem 34.9, introduce a variable \\(y_{i}\\) for the output of each internal node. Then rewrite the original formula \\(\\phi\\) as the AND of the variable at the root of the parse tree and a conjunction of clauses describing the operation of each node. For the formula (34.3), the resulting expression is\n\n\\[\\phi^{{}^{\\prime}}\\ =\\ y_{1} \\wedge\\ (y_{1}\\leftrightarrow(y_{2}\\wedge\\neg x_{2}))\\] \\[\\wedge\\ (y_{2}\\leftrightarrow(y_{3}\\lor y_{4}))\\] \\[\\wedge\\ (y_{3}\\leftrightarrow(x_{1}\\to x_{2}))\\] \\[\\wedge\\ (y_{4}\\leftrightarrow\\neg y_{5})\\] \\[\\wedge\\ (y_{5}\\leftrightarrow(y_{6}\\lor x_{4}))\\] \\[\\wedge\\ (y_{6}\\leftrightarrow(\\neg x_{1}\\leftrightarrow x_{3}))\\.\\]The formula \\(\\phi^{\\prime}\\) thus obtained is a conjunction of clauses \\(\\phi^{\\prime}_{i}\\), each of which has at most three literals. These clauses are not yet ORs of three literals.\n\nThe second step of the reduction converts each clause \\(\\phi^{\\prime}_{i}\\) into conjunctive normal form. Construct a truth table for \\(\\phi^{\\prime}_{i}\\) by evaluating all possible assignments to its variables. Each row of the truth table consists of a possible assignment of the variables of the clause, together with the value of the clause under that assignment. Using the truth-table entries that evaluate to 0, build a formula in _disjunctive normal form_ (or _DNF_)--an OR of ANDs--that is equivalent to \\(\\neg\\phi^{\\prime}_{i}\\). Then negate this formula and convert it into a CNF formula \\(\\phi^{\\prime\\prime}_{i}\\) by using _DeMorgan's laws_ for propositional logic,\n\n\\[\\neg(a\\wedge b)\\ =\\ \\neg a\\vee\\neg b\\,\\] \\[\\neg(a\\lor b)\\ =\\ \\neg a\\wedge\\neg b\\,\\]\n\nto complement all literals, change ORs into ANDs, and change ANDs into ORs.\n\nIn our example, the clause \\(\\phi^{\\prime}_{1}=(y_{1}\\leftrightarrow(y_{2}\\wedge\\neg x_{2}))\\) converts into CNF as follows. The truth table for \\(\\phi^{\\prime}_{1}\\) appears in Figure 34.12. The DNF formula equivalent to \\(\\neg\\phi^{\\prime}_{1}\\) is\n\n\\[(y_{1}\\wedge y_{2}\\wedge x_{2})\\vee(y_{1}\\wedge\\neg y_{2}\\wedge x_{2})\\vee(y _{1}\\wedge\\neg y_{2}\\wedge\\neg x_{2})\\vee(\\neg y_{1}\\wedge y_{2}\\wedge\\neg x _{2})\\.\\]\n\nNegating and applying DeMorgan's laws yields the CNF formula\n\n\\[\\phi^{\\prime\\prime}_{1}\\ =\\ (\\neg y_{1}\\vee\\neg y_{2}\\vee\\neg x_{2}) \\wedge(\\neg y_{1}\\lor y_{2}\\vee\\neg x_{2})\\] \\[\\ \\The third and final step of the reduction further transforms the formula so that each clause has _exactly_ three distinct literals. From the clauses of the CNF formula \\(\\phi^{\\prime\\prime}\\), construct the final 3-CNF formula \\(\\phi^{\\prime\\prime\\prime}\\). This formula also uses two auxiliary variables, \\(p\\) and \\(q\\). For each clause \\(C_{i}\\) of \\(\\phi^{\\prime\\prime}\\), include the following clauses in \\(\\phi^{\\prime\\prime\\prime}\\):\n\n* If \\(C_{i}\\) contains three distinct literals, then simply include \\(C_{i}\\) as a clause of \\(\\phi^{\\prime\\prime\\prime}\\).\n* If \\(C_{i}\\) contains exactly two distinct literals, that is, if \\(C_{i}=(l_{1}\\lor l_{2})\\), where \\(l_{1}\\) and \\(l_{2}\\) are literals, then include \\((l_{1}\\lor l_{2}\\lor p)\\wedge(l_{1}\\lor l_{2}\\vee\\neg p)\\) as clauses of \\(\\phi^{\\prime\\prime\\prime}\\). The literals \\(p\\) and \\(\\neg p\\) merely fulfill the syntactic requirement that each clause of \\(\\phi^{\\prime\\prime\\prime}\\) contain exactly three distinct literals. Whether \\(p=0\\) or \\(p=1\\), one of the clauses is equivalent to \\(l_{1}\\lor l_{2}\\), and the other evaluates to 1, which is the identity for AND.\n* If \\(C_{i}\\) contains just one distinct literal \\(l\\), then include \\((l\\lor p\\lor q)\\wedge(l\\lor p\\vee\\neg q)\\wedge(l\\vee\\neg p\\lor q)\\wedge(l\\vee \\neg p\\vee\\neg q)\\) as clauses of \\(\\phi^{\\prime\\prime\\prime}\\). Regardless of the values of \\(p\\) and \\(q\\), one of the four clauses is equivalent to \\(l\\), and the other three evaluate to 1.\n\nWe can see that the 3-CNF formula \\(\\phi^{\\prime\\prime\\prime}\\) is satisfiable if and only if \\(\\phi\\) is satisfiable by inspecting each of the three steps. Like the reduction from CIRCUIT-SAT to SAT, the construction of \\(\\phi^{\\prime}\\) from \\(\\phi\\) in the first step preserves satisfiability. The second step produces a CNF formula \\(\\phi^{\\prime\\prime}\\) that is algebraically equivalent to \\(\\phi^{\\prime}\\). Then the third step produces a 3-CNF formula \\(\\phi^{\\prime\\prime\\prime}\\) that is effectively equivalent to \\(\\phi^{\\prime\\prime}\\), since any assignment to the variables \\(p\\) and \\(q\\) produces a formula that is algebraically equivalent to \\(\\phi^{\\prime\\prime}\\).\n\nWe must also show that the reduction can be computed in polynomial time. Constructing \\(\\phi^{\\prime}\\) from \\(\\phi\\) introduces at most one variable and one clause per connective in \\(\\phi\\). Constructing \\(\\phi^{\\prime\\prime}\\) from \\(\\phi^{\\prime}\\) can introduce at most eight clauses into \\(\\phi^{\\prime\\prime}\\) for each clause from \\(\\phi^{\\prime}\\), since each clause of \\(\\phi^{\\prime}\\) contains at most three variables, and the truth table for each clause has at most \\(2^{3}=8\\) rows. The construction of \\(\\phi^{\\prime\\prime\\prime}\\) from \\(\\phi^{\\prime\\prime}\\) introduces at most four clauses into \\(\\phi^{\\prime\\prime\\prime}\\) for each clause of \\(\\phi^{\\prime\\prime}\\). Thus the size of the resulting formula \\(\\phi^{\\prime\\prime\\prime}\\) is polynomial in the length of the original formula. Each of the constructions can be accomplished in polynomial time.\n\n#### Exercises\n\n_34.4-1_\n\nConsider the straightforward (nonpolynomial-time) reduction in the proof of Theorem 34.9. Describe a circuit of size \\(n\\) that, when converted to a formula by this method, yields a formula whose size is exponential in \\(n\\).\n\n#### 34.4-2\n\nShow the 3-CNF formula that results upon using the method of Theorem 34.10 on the formula (34.3).\n\n#### 34.4-3\n\nProfessor Jagger proposes to show that \\(\\mathrm{SAT}\\leq_{\\mathrm{P}}3\\)-CNF-SAT by using only the truth-table technique in the proof of Theorem 34.10, and not the other steps. That is, the professor proposes to take the boolean formula \\(\\phi\\), form a truth table for its variables, derive from the truth table a formula in 3-DNF that is equivalent to \\(\\neg\\phi\\), and then negate and apply DeMorgan's laws to produce a 3-CNF formula equivalent to \\(\\phi\\). Show that this strategy does not yield a polynomial-time reduction.\n\n#### 34.4-4\n\nShow that the problem of determining whether a boolean formula is a tautology is complete for co-NP. (_Hint:_ See Exercise 34.3-7.)\n\n#### 34.4-5\n\nShow that the problem of determining the satisfiability of boolean formulas in disjunctive normal form is polynomial-time solvable.\n\n#### 34.4-6\n\nSomeone gives you a polynomial-time algorithm to decide formula satisfiability. Describe how to use this algorithm to find satisfying assignments in polynomial time.\n\n#### 34.4-7\n\nLet 2-CNF-SAT be the set of satisfiable boolean formulas in CNF with exactly two literals per clause. Show that 2-CNF-SAT \\(\\in\\mathrm{P}\\). Make your algorithm as efficient as possible. (_Hint:_ Observe that \\(x\\lor y\\) is equivalent to \\(\\neg x\\to y\\). Reduce 2-CNF-SAT to an efficiently solvable problem on a directed graph.)\n\n### NP-complete problems\n\nNP-complete problems arise in diverse domains: boolean logic, graphs, arithmetic, network design, sets and partitions, storage and retrieval, sequencing and scheduling, mathematical programming, algebra and number theory, games and puzzles, automata and language theory, program optimization, biology, chemistry, physics, and more. This section uses the reduction methodology to provide NP-completeness proofs for a variety of problems drawn from graph theory and set partitioning.",
        "chapter": "Part VII Selected Topics",
        "section": "34 NP-Completeness",
        "subsection": "34.4 NP-completeness proofs",
        "subsubsection": "N/A"
    },
    {
        "content": "#### 34.4-2\n\nShow the 3-CNF formula that results upon using the method of Theorem 34.10 on the formula (34.3).\n\n#### 34.4-3\n\nProfessor Jagger proposes to show that \\(\\mathrm{SAT}\\leq_{\\mathrm{P}}3\\)-CNF-SAT by using only the truth-table technique in the proof of Theorem 34.10, and not the other steps. That is, the professor proposes to take the boolean formula \\(\\phi\\), form a truth table for its variables, derive from the truth table a formula in 3-DNF that is equivalent to \\(\\neg\\phi\\), and then negate and apply DeMorgan's laws to produce a 3-CNF formula equivalent to \\(\\phi\\). Show that this strategy does not yield a polynomial-time reduction.\n\n#### 34.4-4\n\nShow that the problem of determining whether a boolean formula is a tautology is complete for co-NP. (_Hint:_ See Exercise 34.3-7.)\n\n#### 34.4-5\n\nShow that the problem of determining the satisfiability of boolean formulas in disjunctive normal form is polynomial-time solvable.\n\n#### 34.4-6\n\nSomeone gives you a polynomial-time algorithm to decide formula satisfiability. Describe how to use this algorithm to find satisfying assignments in polynomial time.\n\n#### 34.4-7\n\nLet 2-CNF-SAT be the set of satisfiable boolean formulas in CNF with exactly two literals per clause. Show that 2-CNF-SAT \\(\\in\\mathrm{P}\\). Make your algorithm as efficient as possible. (_Hint:_ Observe that \\(x\\lor y\\) is equivalent to \\(\\neg x\\to y\\). Reduce 2-CNF-SAT to an efficiently solvable problem on a directed graph.)\n\n### NP-complete problems\n\nNP-complete problems arise in diverse domains: boolean logic, graphs, arithmetic, network design, sets and partitions, storage and retrieval, sequencing and scheduling, mathematical programming, algebra and number theory, games and puzzles, automata and language theory, program optimization, biology, chemistry, physics, and more. This section uses the reduction methodology to provide NP-completeness proofs for a variety of problems drawn from graph theory and set partitioning.\n\nFigure 34.13 outlines the structure of the NP-completeness proofs in this section and Section 34.4. We prove each language in the figure to be NP-complete by reduction from the language that points to it. At the root is CIRCUIT-SAT, which we proved NP-complete in Theorem 34.7. This section concludes with a recap of reduction strategies.\n\n#### The clique problem\n\nA _clique_ in an undirected graph \\(G=(V,E)\\) is a subset \\(V^{\\prime}\\subseteq V\\) of vertices, each pair of which is connected by an edge in \\(E\\). In other words, a clique is a complete subgraph of \\(G\\). The _size_ of a clique is the number of vertices it contains. The _clique problem_ is the optimization problem of finding a clique of maximum size in a graph. The corresponding decision problem asks simply whether a clique of a given size \\(k\\) exists in the graph. The formal definition is\n\n\\[\\mathrm{CLIQUE}=\\left\\{\\left\\langle G,k\\right\\rangle:G\\text{ is a graph containing a clique of size }k\\right\\}\\text{.}\\]\n\nA naive algorithm for determining whether a graph \\(G=(V,E)\\) with \\(\\left|V\\right|\\) vertices contains a clique of size \\(k\\) lists all \\(k\\)-subsets of \\(V\\) and checks each one to see whether it forms a clique. The running time of this algorithm is \\(\\Omega(k^{2}\\binom{\\left|V\\right|}{k})\\), which is polynomial if \\(k\\) is a constant. In general, however, \\(k\\) could be near \\(\\left|V\\right|/2\\), in which case the algorithm runs in superpolynomial time. Indeed, an efficient algorithm for the clique problem is unlikely to exist.\n\nFigure 34.13: The structure of NP-completeness proofs in Sections 34.4 and 34.5. All proofs ultimately follow by reduction from the NP-completeness of CIRCUIT-SAT.\n\n**Theorem 34.11**: _The clique problem is NP-complete._\n\n_Proof_ First, we show that \\(\\mathrm{CLIQUE}\\in\\mathrm{NP}\\). For a given graph \\(G=(V,E)\\), use the set \\(V^{\\prime}\\subseteq V\\) of vertices in the clique as a certificate for \\(G\\). To check whether \\(V^{\\prime}\\) is a clique in polynomial time, check whether, for each pair \\(u,v\\in V^{\\prime}\\), the edge \\((u,v)\\) belongs to \\(E\\).\n\nWe next prove that 3-CNF-SAT \\(\\leq_{\\mathrm{P}}\\)\\(\\mathrm{CLIQUE}\\), which shows that the clique problem is NP-hard. You might be surprised that the proof reduces an instance of 3-CNF-SAT to an instance of \\(\\mathrm{CLIQUE}\\), since on the surface logical formulas seem to have little to do with graphs.\n\nThe reduction algorithm begins with an instance of 3-CNF-SAT. Let \\(\\phi=C_{1}\\wedge C_{2}\\wedge\\cdots\\wedge C_{k}\\) be a boolean formula in 3-CNF with \\(k\\) clauses. For \\(r=1,2,\\ldots,k\\), each clause \\(C_{r}\\) contains exactly three distinct literals: \\(l^{r}_{1}\\), \\(l^{r}_{2}\\), and \\(l^{r}_{3}\\). We will construct a graph \\(G\\) such that \\(\\phi\\) is satisfiable if and only if \\(G\\) contains a clique of size \\(k\\).\n\nWe construct the undirected graph \\(G=(V,E)\\) as follows. For each clause \\(C_{r}=(l^{r}_{1}\\lor l^{r}_{2}\\lor l^{r}_{3})\\) in \\(\\phi\\), place a triple of vertices \\(v^{r}_{1}\\), \\(v^{r}_{2}\\), and \\(v^{r}_{3}\\) into \\(V\\). Add edge \\((v^{r}_{i},v^{s}_{j})\\) into \\(E\\) if both of the following hold:\n\n* \\(v^{r}_{i}\\) and \\(v^{s}_{j}\\) are in different triples, that is, \\(r\\neq s\\), and\n* their corresponding literals are _consistent_, that is, \\(l^{r}_{i}\\) is not the negation of \\(l^{s}_{j}\\).\n\nWe can build this graph from \\(\\phi\\) in polynomial time. As an example of this construction, if\n\n\\[\\phi=(x_{1}\\vee\\neg x_{2}\\vee\\neg x_{3})\\wedge(\\neg x_{1}\\lor x_{2}\\lor x_{3} )\\wedge(x_{1}\\lor x_{2}\\lor x_{3})\\,\\]\n\nthen \\(G\\) is the graph shown in Figure 34.14.\n\nWe must show that this transformation of \\(\\phi\\) into \\(G\\) is a reduction. First, suppose that \\(\\phi\\) has a satisfying assignment. Then each clause \\(C_{r}\\) contains at least one literal \\(l^{r}_{i}\\) that is assigned \\(1\\), and each such literal corresponds to a vertex \\(v^{r}_{i}\\). Picking one such \"true\" literal from each clause yields a set \\(V^{\\prime}\\) of \\(k\\) vertices. We claim that \\(V^{\\prime}\\) is a clique. For any two vertices \\(v^{r}_{i},v^{s}_{j}\\in V^{\\prime}\\), where \\(r\\neq s\\), both corresponding literals \\(l^{r}_{i}\\) and \\(l^{s}_{j}\\) map to \\(1\\) by the given satisfying assignment, and thus the literals cannot be complements. Thus, by the construction of \\(G\\), the edge \\((v^{r}_{i},v^{s}_{j})\\) belongs to \\(E\\).\n\nConversely, suppose that \\(G\\) contains a clique \\(V^{\\prime}\\) of size \\(k\\). No edges in \\(G\\) connect vertices in the same triple, and so \\(V^{\\prime}\\) contains exactly one vertex per triple. If \\(v^{r}_{i}\\in V^{\\prime}\\), then assign \\(1\\) to the corresponding literal \\(l^{r}_{i}\\). Since \\(G\\) contains no edges between inconsistent literals, no literal and its complement are both assigned \\(1\\). Each clause is satisfied, and so \\(\\phi\\) is satisfied. (Any variables that do not correspond to a vertex in the clique may be set arbitrarily.)\n\n#### 34.5 NP-complete problems\n\nIn the example of Figure 34.14, a satisfying assignment of \\(\\phi\\) has \\(x_{2}=0\\) and \\(x_{3}=1\\). A corresponding clique of size \\(k=3\\) consists of the vertices corresponding to \\(\\neg x_{2}\\) from the first clause, \\(x_{3}\\) from the second clause, and \\(x_{3}\\) from the third clause. Because the clique contains no vertices corresponding to either \\(x_{1}\\) or \\(\\neg x_{1}\\), this satisfying assignment can set \\(x_{1}\\) to either 0 or 1.\n\nThe proof of Theorem 34.11 reduced an arbitrary instance of 3-CNF-SAT to an instance of CLIQUE with a particular structure. You might think that we have shown only that CLIQUE is NP-hard in graphs in which the vertices are restricted to occur in triples and in which there are no edges between vertices in the same triple. Indeed, we have shown that CLIQUE is NP-hard only in this restricted case, but this proof suffices to show that CLIQUE is NP-hard in general graphs. Why? If there were a polynomial-time algorithm that solves CLIQUE on general graphs, it would also solve CLIQUE on restricted graphs.\n\nThe opposite approach\\(--\\)reducing instances of 3-CNF-SAT with a special structure to general instances of CLIQUE\\(--\\)does not suffice, however. Why not? Perhaps the instances of 3-CNF-SAT that we choose to reduce from are \"easy,\" and so we would not have reduced an NP-hard problem to CLIQUE.\n\nMoreover, the reduction uses the instance of 3-CNF-SAT, but not the solution. We would have erred if the polynomial-time reduction had relied on knowingwhether the formula \\(\\phi\\) is satisfiable, since we do not know how to decide whether \\(\\phi\\) is satisfiable in polynomial time.\n\n#### The vertex-cover problem\n\nA _vertex cover_ of an undirected graph \\(G=(V,E)\\) is a subset \\(V^{\\prime}\\subseteq V\\) such that if \\((u,v)\\in E\\), then \\(u\\in V^{\\prime}\\) or \\(v\\in V^{\\prime}\\) (or both). That is, each vertex \"covers\" its incident edges, and a vertex cover for \\(G\\) is a set of vertices that covers all the edges in \\(E\\). The _size_ of a vertex cover is the number of vertices in it. For example, the graph in Figure 34.15(b) has a vertex cover \\(\\{w,z\\}\\) of size 2.\n\nThe _vertex-cover problem_ is to find a vertex cover of minimum size in a given graph. For this optimization problem, the corresponding decision problem asks whether a graph has a vertex cover of a given size \\(k\\). As a language, we define\n\n\\[\\mbox{VERTEX-COVER}=\\left\\{\\langle G,k\\rangle:\\mbox{graph $G$ has a vertex cover of size $k$}\\right\\}\\.\\]\n\nThe following theorem shows that this problem is NP-complete.\n\n**Theorem 34.12**: _The vertex-cover problem is NP-complete._\n\nProofWe first show that VERTEX-COVER\\(\\in\\) NP. Given a graph \\(G=(V,E)\\) and an integer \\(k\\), the certificate is the vertex cover \\(V^{\\prime}\\subseteq V\\) itself. The verification algorithm affirms that \\(|V^{\\prime}|=k\\), and then it checks, for each edge \\((u,v)\\in E\\), that \\(u\\in V^{\\prime}\\) or \\(v\\in V^{\\prime}\\). It is easy to verify the certificate in polynomial time.\n\nTo prove that the vertex-cover problem is NP-hard, we reduce from the clique problem, showing that \\(\\mbox{CLIQUE}\\leq_{\\mbox{\\tiny P}}\\mbox{VERTEX-COVER}\\). This reduction relies\n\nFigure 34.15: Reducing CLIQUE to VERTEX-COVER. **(a)** An undirected graph \\(G=(V,E)\\) with clique \\(V^{\\prime}=\\{u,v,x,y\\}\\), shown in blue. **(b)** The graph \\(\\overline{G}\\) produced by the reduction algorithm that has vertex cover \\(V-V^{\\prime}=\\{w,z\\}\\), in blue.\n\non the notion of the complement of a graph. Given an undirected graph \\(G=(V,E)\\), we define the _complement_ of \\(G\\) as a graph \\(\\overline{G}=(V,\\overline{E})\\), where \\(\\overline{E}=\\{(u,v):u,v\\in V,u\\neq v\\), and \\((u,v)\\notin E\\}\\). In other words, \\(\\overline{G}\\) is the graph containing exactly those edges that are not in \\(G\\). Figure 34.15 shows a graph and its complement and illustrates the reduction from CLIQUE to VERTEX-COVER.\n\nThe reduction algorithm takes as input an instance \\(\\langle G,k\\rangle\\) of the clique problem and computes the complement \\(\\overline{G}\\) in polynomial time. The output of the reduction algorithm is the instance \\(\\langle\\overline{G}\\,,\\,|V|-k\\rangle\\) of the vertex-cover problem. To complete the proof, we show that this transformation is indeed a reduction: the graph \\(G\\) contains a clique of size \\(k\\) if and only if the graph \\(\\overline{G}\\) has a vertex cover of size \\(|V|-k\\).\n\nSuppose that \\(G\\) contains a clique \\(V^{\\prime}\\subseteq V\\) with \\(|V^{\\prime}|=k\\). We claim that \\(V-V^{\\prime}\\) is a vertex cover in \\(\\overline{G}\\). Let \\((u,v)\\) be any edge in \\(\\overline{E}\\). Then, \\((u,v)\\notin E\\), which implies that at least one of \\(u\\) or \\(v\\) does not belong to \\(V^{\\prime}\\), since every pair of vertices in \\(V^{\\prime}\\) is connected by an edge of \\(E\\). Equivalently, at least one of \\(u\\) or \\(v\\) belongs to \\(V-V^{\\prime}\\), which means that edge \\((u,v)\\) is covered by \\(V-V^{\\prime}\\). Since \\((u,v)\\) was chosen arbitrarily from \\(\\overline{E}\\), every edge of \\(\\overline{E}\\) is covered by a vertex in \\(V-V^{\\prime}\\). Hence the set \\(V-V^{\\prime}\\), which has size \\(|V|-k\\), forms a vertex cover for \\(\\overline{G}\\).\n\nConversely, suppose that \\(\\overline{G}\\) has a vertex cover \\(V^{\\prime}\\subseteq V\\), where \\(|V^{\\prime}|=|V|-k\\). Then for all \\(u,v\\in V\\), if \\((u,v)\\in\\overline{E}\\), then \\(u\\in V^{\\prime}\\) or \\(v\\in V^{\\prime}\\) or both. The contrapositive of this implication is that for all \\(u,v\\in V\\), if \\(u\\notin V^{\\prime}\\) and \\(v\\notin V^{\\prime}\\), then \\((u,v)\\in E\\). In other words, \\(V-V^{\\prime}\\) is a clique, and it has size \\(|V|-|V^{\\prime}|=k\\).\n\nSince VERTEX-COVER is NP-complete, we don't expect to find a polynomial-time algorithm for finding a minimum-size vertex cover. Section 35.1 presents a polynomial-time \"approximation algorithm,\" however, which produces \"approximate\" solutions for the vertex-cover problem. The size of a vertex cover produced by the algorithm is at most twice the minimum size of a vertex cover.\n\nThus, you shouldn't give up hope just because a problem is NP-complete. You might be able to design a polynomial-time approximation algorithm that obtains near-optimal solutions, even though finding an optimal solution is NP-complete. Chapter 35 gives several approximation algorithms for NP-complete problems.\n\n#### The hamiltonian-cycle problem\n\nWe now return to the hamiltonian-cycle problem defined in Section 34.2.\n\n_Theorem 34.13_\n\nThe hamiltonian cycle problem is NP-complete.\n\n_Proof_ We first show that \\(\\text{HAM-CYCLE}\\in\\text{NP}\\). Given an undirected graph \\(G=(V,E)\\), the certificate is the sequence of \\(|V|\\) vertices that makes up the hamiltonian cycle. The verification algorithm checks that this sequence contains each vertex in \\(V\\) exactly once and that with the first vertex repeated at the end, it forms a cycle in \\(G\\). That is, it checks that there is an edge between each pair of consecutive vertices and between the first and last vertices. This certificate can be verified in polynomial time.\n\nWe now prove that \\(\\text{VERTEX-COVER}\\leq_{\\text{P}}\\text{HAM-CYCLE}\\), which shows that \\(\\text{HAM-CYCLE}\\) is NP-complete. Given an undirected graph \\(G=(V,E)\\) and an integer \\(k\\), we construct an undirected graph \\(G^{\\prime}=(V^{\\prime},E^{\\prime})\\) that has a hamiltonian cycle if and only if \\(G\\) has a vertex cover of size \\(k\\). We assume without loss of generality that \\(G\\) contains no isolated vertices (that is, every vertex in \\(V\\) has at least one incident edge) and that \\(k\\leq|V|\\). (If an isolated vertex belongs to a vertex cover of size \\(k\\), then there also exists a vertex cover of size \\(k-1\\), and for any graph, the entire set \\(V\\) is always a vertex cover.)\n\nOur construction uses a _gadget_, which is a piece of a graph that enforces certain properties. Figure 34.16(a) shows the gadget we use. For each edge \\((u,v)\\in E\\), the constructed graph \\(G^{\\prime}\\) contains one copy of this gadget, which we denote by \\(\\Gamma_{uv}\\). We denote each vertex in \\(\\Gamma_{uv}\\) by \\([u,v,i]\\) or \\([v,u,i]\\), where \\(1\\leq i\\leq 6\\), so that each gadget \\(\\Gamma_{uv}\\) contains 12 vertices. Gadget \\(\\Gamma_{uv}\\) also contains the 14 edges shown in Figure 34.16(a).\n\nAlong with the internal structure of the gadget, we enforce the properties we want by limiting the connections between the gadget and the remainder of the graph \\(G^{\\prime}\\) that we construct. In particular, only vertices \\([u,v,1]\\), \\([u,v,6]\\), \\([v,u,1]\\), and \\([v,u,6]\\) will have edges incident from outside \\(\\Gamma_{uv}\\). Any hamiltonian cycle\n\nFigure 34.16: The gadget used in reducing the vertex-cover problem to the hamiltonian-cycle problem. An edge \\((u,v)\\) of graph \\(G\\) corresponds to gadget \\(\\Gamma_{uv}\\) in the graph \\(G^{\\prime}\\) created in the reduction. **(a)** The gadget, with individual vertices labeled. **(b)\u2013(d)** The paths highlighted in blue are the only possible ones through the gadget that include all vertices, assuming that the only connections from the gadget to the remainder of \\(G^{\\prime}\\) are through vertices \\([u,v,1]\\), \\([u,v,6]\\), \\([v,u,1]\\), and \\([v,u,6]\\).\n\nof \\(G^{\\prime}\\) must traverse the edges of \\(\\Gamma_{uv}\\) in one of the three ways shown in Figures 34.16(b)-(d). If the cycle enters through vertex \\([u,v,1]\\), it must exit through vertex \\([u,v,6]\\), and it either visits all 12 of the gadget's vertices (Figure 34.16(b)) or the six vertices \\([u,v,1]\\) through \\([u,v,6]\\) (Figure 34.16(c)). In the latter case, the cycle will have to reenter the gadget to visit vertices \\([v,u,1]\\) through \\([v,u,6]\\). Similarly, if the cycle enters through vertex \\([v,u,1]\\), it must exit through vertex \\([v,u,6]\\), and either it visits all 12 of the gadget's vertices (Figure 34.16(d)) or it visits the six vertices \\([v,u,1]\\) through \\([v,u,6]\\) and reenters to visit \\([u,v,1]\\) through \\([u,v,6]\\) (Figure 34.16(c)). No other paths through the gadget that visit all 12 vertices are possible. In particular, it is impossible to construct two vertex-disjoint paths, one of which connects \\([u,v,1]\\) to \\([v,u,6]\\) and the other of which connects \\([v,u,1]\\) to \\([u,v,6]\\), such that the union of the two paths contains all of the gadget's vertices.\n\nThe only other vertices in \\(V^{\\prime}\\) other than those of gadgets are _selector vertices_\\(s_{1},s_{2},\\ldots,s_{k}\\). We'll use edges incident on selector vertices in \\(G^{\\prime}\\) to select the \\(k\\) vertices of the cover in \\(G\\).\n\nIn addition to the edges in gadgets, \\(E^{\\prime}\\) contains two other types of edges, which Figure 34.17 shows. First, for each vertex \\(u\\in V\\), edges join pairs of gadgets in order to form a path containing all gadgets corresponding to edges incident on \\(u\\) in \\(G\\). We arbitrarily order the vertices adjacent to each vertex \\(u\\in V\\) as \\(u^{(1)},u^{(2)},\\ldots,u^{(\\text{degree}(u))}\\), where \\(\\text{degree}(u)\\) is the number of vertices adjacent to \\(u\\). To create a path in \\(G^{\\prime}\\) through all the gadgets corresponding to edges incident on \\(u\\), \\(E^{\\prime}\\) contains the edges \\(\\{([u,u^{(i)},6],[u,u^{(i+1)},1]):1\\leq i\\leq\\text{degree}(u)-1\\}\\). In Figure 34.17, for example, we order the vertices adjacent to \\(w\\) as \\(\\langle x,\\,y,\\,z\\rangle\\), and so graph \\(G^{\\prime}\\) in part (b) of the figure includes the edges \\(([w,x,6],[w,y,1])\\) and \\(([w,y,6],[w,z,1])\\). The vertices adjacent to \\(x\\) are ordered as \\(\\langle w,\\,y\\rangle\\), so that \\(G^{\\prime}\\) includes the edge \\(([x,w,6],[x,y,1])\\). For each vertex \\(u\\in V\\), these edges in \\(G^{\\prime}\\) fill in a path containing all gadgets corresponding to edges incident on \\(u\\) in \\(G\\).\n\nThe intuition behind these edges is that if vertex \\(u\\in V\\) belongs to the vertex cover of \\(G\\), then \\(G^{\\prime}\\) contains a path from \\([u,u^{(1)},1]\\) to \\([u,u^{(\\text{degree}(u))},6]\\) that \"covers\" all gadgets corresponding to edges incident on \\(u\\). That is, for each of these gadgets, say \\(\\Gamma_{u,u^{(i)}}\\), the path either includes all 12 vertices (if \\(u\\) belongs to the vertex cover but \\(u^{(i)}\\) does not) or just the six vertices \\([u,u^{(i)},1]\\) through \\([u,u^{(i)},6]\\) (if both \\(u\\) and \\(u^{(i)}\\) belong to the vertex cover).\n\nThe final type of edge in \\(E^{\\prime}\\) joins the first vertex \\([u,u^{(1)},1]\\) and the last vertex \\([u,u^{(\\text{degree}(u))},6]\\) of each of these paths to each of the selector vertices. That is, \\(E^{\\prime}\\) includes the edges\n\n\\[\\{(s_{j},[u,u^{(1)},1]):u\\in V\\text{ and }1\\leq j\\leq k\\}\\] \\[\\cup\\{(s_{j},[u,u^{(\\text{degree}(u))},6]):u\\in V\\text{ and }1\\leq j\\leq k\\}\\.\\]Next we show that the size of \\(G^{\\prime}\\) is polynomial in the size of \\(G\\), and hence it takes time polynomial in the size of \\(G\\) to construct \\(G^{\\prime}\\). The vertices of \\(G^{\\prime}\\) are those in the gadgets, plus the selector vertices. With 12 vertices per gadget, plus \\(k\\leq|V|\\) selector vertices, \\(G^{\\prime}\\) contains a total of\n\n\\[|V^{\\prime}| = 12\\ |E|+k\\] \\[\\leq 12\\ |E|+|V|\\]\n\nvertices. The edges of \\(G^{\\prime}\\) are those in the gadgets, those that go between gadgets, and those connecting selector vertices to gadgets. Each gadget contains 14 edges, totaling 14 \\(|E|\\) in all gadgets. For each vertex \\(u\\in V\\), graph \\(G^{\\prime}\\) has degree\\((u)-1\\) edges going between gadgets, so that summed over all vertices in \\(V\\),\n\nFigure 34.17: Reducing an instance of the vertex-cover problem to an instance of the hamiltonian-cycle problem. **(a)** An undirected graph \\(G\\) with a vertex cover of size 2, consisting of the blue vertices \\(w\\) and \\(y\\). **(b)** The undirected graph \\(G^{\\prime}\\) produced by the reduction, with the hamiltonian cycle corresponding to the vertex cover highlighted in blue. The vertex cover \\(\\{w\\), \\(y\\}\\) corresponds to edges \\((s_{1},[w,x,1])\\) and \\((s_{2},[y,x,1])\\) appearing in the hamiltonian cycle.\n\n\\[\\sum_{u\\in V}(\\text{degree}(u)-1)=2\\ |E|-|V|\\]\n\nedges go between gadgets. Finally, \\(G^{\\prime}\\) has two edges for each pair consisting of a selector vertex and a vertex of \\(V\\), totaling \\(2k\\ |V|\\) such edges. The total number of edges of \\(G^{\\prime}\\) is therefore\n\n\\[|E^{\\prime}| =\\ (14\\ |E|)+(2\\ |E|-|V|)+(2k\\ |V|)\\] \\[=\\ 16\\ |E|+(2k-1)\\ |V|\\] \\[\\leq\\ 16\\ |E|+(2\\ |V|-1)\\ |V|\\enspace.\\]\n\nNow we show that the transformation from graph \\(G\\) to \\(G^{\\prime}\\) is a reduction. That is, we must show that \\(G\\) has a vertex cover of size \\(k\\) if and only if \\(G^{\\prime}\\) has a hamiltonian cycle.\n\nSuppose that \\(G=(V,E)\\) has a vertex cover \\(V^{*}\\subseteq V\\), where \\(|V^{*}|=k\\). Let \\(V^{*}=\\{u_{1},u_{2},\\ldots,u_{k}\\}\\). As Figure 34.17 shows, we can construct a hamiltonian cycle in \\(G^{\\prime}\\) by including the following edges11 for each vertex \\(u_{j}\\in V^{*}\\). Start by including edges \\(\\big{\\{}([u_{j},u_{j}^{(i)},6],[u_{j},u_{j}^{(i+1)},1]):1\\leq i\\leq\\text{ degree}(u_{j})-1\\big{\\}}\\), which connect all gadgets corresponding to edges incident on \\(u_{j}\\). Also include the edges within these gadgets as Figures 34.16(b)-(d) show, depending on whether the edge is covered by one or two vertices in \\(V^{*}\\). The hamiltonian cycle also includes the edges\n\nFootnote 11: Technically, a cycle is defined as a sequence of vertices rather than edges (see Section B.4). In the interest of clarity, we abuse notation here and define the hamiltonian cycle by its edges.\n\n\\[\\{(s_{j},[u_{j},u_{j}^{(1)},1]):1\\leq j\\ \\leq k\\}\\] \\[\\quad\\cup\\ \\{(s_{j+1},[u_{j},u_{j}^{(\\text{degree}(u_{j}))},6]):1 \\leq j\\ \\leq k-1\\}\\] \\[\\quad\\cup\\ \\{(s_{1},[u_{k},u_{k}^{(\\text{degree}(u_{k}))},6])\\}\\enspace.\\]\n\nBy inspecting Figure 34.17, you can verify that these edges form a cycle, where \\(u_{1}=w\\) and \\(u_{2}=y\\). The cycle starts at \\(s_{1}\\), visits all gadgets corresponding to edges incident on \\(u_{1}\\), then visits \\(s_{2}\\), visits all gadgets corresponding to edges incident on \\(u_{2}\\), and so on, until it returns to \\(s_{1}\\). The cycle visits each gadget either once or twice, depending on whether one or two vertices of \\(V^{*}\\) cover its corresponding edge. Because \\(V^{*}\\) is a vertex cover for \\(G\\), each edge in \\(E\\) is incident on some vertex in \\(V^{*}\\), and so the cycle visits each vertex in each gadget of \\(G^{\\prime}\\). Because the cycle also visits every selector vertex, it is hamiltonian.\n\nConversely, suppose that \\(G^{\\prime}=(V^{\\prime},E^{\\prime})\\) contains a hamiltonian cycle \\(C\\subseteq E^{\\prime}\\). We claim that the set\n\n\\[V^{*}=\\{u\\in V:(s_{j},[u,u^{(1)},1])\\in C\\text{ for some }1\\leq j\\ \\leq k\\} \\tag{34.4}\\]is a vertex cover for \\(G\\).\n\nWe first argue that the set \\(V^{*}\\) is well defined, that is, for each selector vertex \\(s_{j}\\), exactly one of the incident edges in the hamiltonian cycle \\(C\\) is of the form \\((s_{j},[u,u^{(1)},1])\\) for some vertex \\(u\\in V\\). To see why, partition the hamiltonian cycle \\(C\\) into maximal paths that start at some selector vertex \\(s_{i}\\), visit one or more gadgets, and end at some selector vertex \\(s_{j}\\) without passing through any other selector vertex. Let's call each of these maximal paths a \"cover path.\" Let \\(P\\) be one such cover path, and orient it going from \\(s_{i}\\) to \\(s_{j}\\). If \\(P\\) contains the edge \\((s_{i},[u,u^{(1)},1])\\) for some vertex \\(u\\in V\\), then we have shown that one edge incident on \\(s_{i}\\) has the required form. Assume, then, that \\(P\\) contains the edge \\((s_{i},[v,v^{(\\deg(v))},6])\\) for some vertex \\(v\\in V\\). This path enters a gadget from the bottom, as drawn in Figures 34.16 and 34.17, and it leaves from the top. It might go through several gadgets, but it always enters from the bottom of a gadget and leaves from the top. The only edges incident on vertices at the top of a gadget either go to the bottoms of other gadgets or to selector vertices. Therefore, after the last gadget in the series of gadgets visited by \\(P\\), the edge taken must go to a selector vertex \\(s_{j}\\), so that \\(P\\) contains an edge of the form \\((s_{j},[u,u^{(1)},1])\\), where \\([u,u^{(1)},1]\\) is a vertex at the top of some gadget. To see that not both edges incident on \\(s_{j}\\) have this form, simply reverse the direction of traversing \\(P\\) in the above argument.\n\nHaving established that the set \\(V^{*}\\) is well defined, let's see why it is a vertex cover for \\(G\\). We have already established that each cover path starts at some \\(s_{i}\\), takes the edge \\((s_{i},[u,u^{(1)},1])\\) for some vertex \\(u\\in V\\), passes through all the gadgets corresponding to edges in \\(E\\) incident on \\(u\\), and then ends at some selector vertex \\(s_{j}\\). (This orientation is the reverse of the orientation in the paragraph above.) Let's call this cover path \\(P_{u}\\), and by equation (34.4), the vertex cover \\(V^{*}\\) includes \\(u\\). Each gadget visited by \\(P_{u}\\) must be \\(\\Gamma_{uv}\\) or \\(\\Gamma_{vu}\\) for some \\(v\\in V\\). For each gadget visited by \\(P_{u}\\), its vertices are visited by either one or two cover paths. If they are visited by one cover path, then edge \\((u,v)\\in E\\) is covered in \\(G\\) by vertex \\(u\\). If two cover paths visit the gadget, then the other cover path must be \\(P_{v}\\), which implies that \\(v\\in V^{*}\\), and edge \\((u,v)\\in E\\) is covered by both \\(u\\) and \\(v\\). Because each vertex in each gadget is visited by some cover path, we see that each edge in \\(E\\) is covered by some vertex in \\(V^{*}\\). \n\n#### The traveling-salesperson problem\n\nIn the _traveling-salesperson problem_, which is closely related to the hamiltonian-cycle problem, a salesperson must visit \\(n\\) cities. Let's model the problem as a complete graph with \\(n\\) vertices, so that the salesperson wishes to make a _tour_, or hamiltonian cycle, visiting each city exactly once and finishing at the starting city. The salesperson incurs a nonnegative integer cost \\(c(i,j)\\) to travel from city to city \\(j\\). In the optimization version of the problem, the salesperson wishes to make the tour whose total cost is minimum, where the total cost is the sum of the individual costs along the edges of the tour. For example, in Figure 34.18, a minimum-cost tour is \\(\\langle u,\\,w,\\,v,\\,x,\\,u\\rangle\\), with cost 7. The formal language for the corresponding decision problem is\n\n\\[\\mathrm{TSP}=\\{\\langle G,c,k\\rangle: \\;G=(V,E)\\text{ is a complete graph,}\\] \\[c\\text{ is a function from }V\\times V\\to\\mathbb{N}\\,,\\] \\[k\\in\\mathbb{N}\\,,\\text{and}\\] \\[G\\text{ has a traveling-salesperson tour with cost at most }k\\}\\.\\]\n\nThe following theorem shows that a fast algorithm for the traveling-salesperson problem is unlikely to exist.\n\n**Theorem 34.14**: _The traveling-salesperson problem is NP-complete._\n\nProofWe first show that \\(\\mathrm{TSP}\\in\\mathrm{NP}\\). Given an instance of the problem, the certificate is the sequence of \\(n\\) vertices in the tour. The verification algorithm checks that this sequence contains each vertex exactly once, sums up the edge costs, and checks that the sum is at most \\(k\\). This process can certainly be done in polynomial time.\n\nTo prove that TSP is NP-hard, we show that \\(\\mathrm{HAM}\\text{-}\\mathrm{CYCLE}\\leq_{\\mathrm{P}}\\mathrm{TSP}\\). Given an instance \\(G=(V,E)\\) of \\(\\mathrm{HAM}\\text{-}\\mathrm{CYCLE}\\), construct an instance of TSP by forming the complete graph \\(G^{\\prime}=(V,E^{\\prime})\\), where \\(E^{\\prime}=\\{(i,j):i,j\\in V\\text{ and }i\\neq j\\}\\), with the cost function \\(c\\) defined as\n\n\\[c(i,j)=\\left\\{\\begin{array}{ll}0&\\text{if }(i,j)\\in E\\,\\\\ 1&\\text{if }(i,j)\\notin E\\.\\end{array}\\right.\\]\n\n(Because \\(G\\) is undirected, it contains no self-loops, and so \\(c(v,v)=1\\) for all vertices \\(v\\in V\\).) The instance of TSP is then \\(\\langle G^{\\prime},c,0\\rangle\\), which can be created in polynomial time.\n\nFigure 34.18: An instance of the traveling-salesperson problem. Edges highlighted in blue represent a minimum-cost tour, with cost 7.\n\nWe now show that graph \\(G\\) has a hamiltonian cycle if and only if graph \\(G^{\\prime}\\) has a tour of cost at most 0. Suppose that graph \\(G\\) has a hamiltonian cycle \\(H\\). Each edge in \\(H\\) belongs to \\(E\\) and thus has cost 0 in \\(G^{\\prime}\\). Thus, \\(H\\) is a tour in \\(G^{\\prime}\\) with cost 0. Conversely, suppose that graph \\(G^{\\prime}\\) has a tour \\(H^{\\prime}\\) of cost at most 0. Since the costs of the edges in \\(E^{\\prime}\\) are 0 and 1, the cost of tour \\(H^{\\prime}\\) is exactly 0 and each edge on the tour must have cost 0. Therefore, \\(H^{\\prime}\\) contains only edges in \\(E\\). We conclude that \\(H^{\\prime}\\) is a hamiltonian cycle in graph \\(G\\).\n\n#### 34.5.5 The subset-sum problem\n\nWe next consider an arithmetic NP-complete problem. The _subset-sum problem_ takes as inputs a finite set \\(S\\) of positive integers and an integer _target_\\(t>0\\). It asks whether there exists a subset \\(S^{\\prime}\\subseteq S\\) whose elements sum to exactly \\(t\\). For example, if \\(S=\\{1,2,7,14,49,98,343,686,2409,2793,16808,17206,117705,\\)\\(117993\\}\\) and \\(t=138457\\), then the subset \\(S^{\\prime}=\\{1,2,7,98,343,686,2409,17206,\\)\\(117705\\}\\) is a solution.\n\nAs usual, we express the problem as a language:\n\n\\[\\text{SUBSET-SUM}=\\left\\{\\left\\langle S,t\\right\\rangle\\right\\}:\\text{there exists a subset $S^{\\prime}\\subseteq S$ such that }t=\\sum_{s\\in S^{\\prime}}s\\right\\}\\.\\]\n\nAs with any arithmetic problem, it is important to recall that our standard encoding assumes that the input integers are coded in binary. With this assumption in mind, we can show that the subset-sum problem is unlikely to have a fast algorithm.\n\n**Theorem 34.15**: _The subset-sum problem is NP-complete._\n\n_Proof_ To show that \\(\\text{SUBSET-SUM}\\in\\text{NP}\\), for an instance \\(\\left\\langle S,t\\right\\rangle\\) of the problem, let the subset \\(S^{\\prime}\\) be the certificate. A verification algorithm can check whether \\(t=\\sum_{s\\in S^{\\prime}}s\\) in polynomial time.\n\nWe now show that 3-CNF-SAT \\(\\leq_{\\text{P}}\\) SUBSET-SUM. Given a 3-CNF formula \\(\\phi\\) over variables \\(x_{1},x_{2},\\ldots,x_{n}\\) with clauses \\(C_{1},C_{2},\\ldots,C_{k}\\), each containing exactly three distinct literals, the reduction algorithm constructs an instance \\(\\left\\langle S,t\\right\\rangle\\) of the subset-sum problem such that \\(\\phi\\) is satisfiable if and only if there exists a subset of \\(S\\) whose sum is exactly \\(t\\). Without loss of generality, we make two simplifying assumptions about the formula \\(\\phi\\). First, no clause contains both a variable and its negation, for such a clause is automatically satisfied by any assignment of values to the variables. Second, each variable appears in at least one clause, because it does not matter what value is assigned to a variable that appears in no clauses.\n\nThe reduction creates two numbers in set \\(S\\) for each variable \\(x_{i}\\) and two numbers in \\(S\\) for each clause \\(C_{j}\\). The numbers will be represented in base 10, with each number containing \\(n+k\\) digits and each digit corresponding to either one variable \n\n#### 34.5 NP-complete problems\n\nor one clause. Base 10 (and other bases, as we shall see) has the property we need of preventing carries from lower digits to higher digits.\n\nAs Figure 34.19 shows, we construct set \\(S\\) and target \\(t\\) as follows. Label each digit position by either a variable or a clause. The least significant \\(k\\) digits are labeled by the clauses, and the most significant \\(n\\) digits are labeled by variables.\n\n* The target \\(t\\) has a 1 in each digit labeled by a variable and a 4 in each digit labeled by a clause.\n* For each variable \\(x_{i}\\), set \\(S\\) contains two integers \\(v_{i}\\) and \\(v^{\\prime}_{i}\\). Each of \\(v_{i}\\) and \\(v^{\\prime}_{i}\\) has a 1 in the digit labeled by \\(x_{i}\\) and 0s in the other variable digits. If literal \\(x_{i}\\) appears in clause \\(C_{j}\\), then the digit labeled by \\(C_{j}\\) in \\(v_{i}\\) contains a 1. If literal \\(\\neg x_{i}\\) appears in clause \\(C_{j}\\), then the digit labeled by \\(C_{j}\\) in \\(v^{\\prime}_{i}\\) contains a 1. All other digits labeled by clauses in \\(v_{i}\\) and \\(v^{\\prime}_{i}\\) are 0.\n\nAll \\(v_{i}\\) and \\(v^{\\prime}_{i}\\) values in set \\(S\\) are unique. Why? For \\(\\ell\\neq i\\), no \\(v_{\\ell}\\) or \\(v^{\\prime}_{\\ell}\\) values can equal \\(v_{i}\\) and \\(v^{\\prime}_{i}\\) in the most significant \\(n\\) digits. Furthermore, by our simplifying assumptions above, no \\(v_{i}\\) and \\(v^{\\prime}_{i}\\) can be equal in all \\(k\\) least significant digits. If \\(v_{i}\\) and \\(v^{\\prime}_{i}\\) were equal, then \\(x_{i}\\) and \\(\\neg x_{i}\\) would have to appear in exactly the same set of clauses. But we assume that no clause contains both \\(x_{i}\\) and \\(\\neg x_{i}\\) and that either \\(x_{i}\\) or \\(\\neg x_{i}\\) appears in some clause, and so there must be some clause \\(C_{j}\\) for which \\(v_{i}\\) and \\(v^{\\prime}_{i}\\) differ.\n* For each clause \\(C_{j}\\), set \\(S\\) contains two integers \\(s_{j}\\) and \\(s^{\\prime}_{j}\\). Each of \\(s_{j}\\) and \\(s^{\\prime}_{j}\\) has 0s in all digits other than the one labeled by \\(C_{j}\\). For \\(s_{j}\\), there is a 1 in the \\(C_{j}\\) digit, and \\(s^{\\prime}_{j}\\) has a 2 in this digit. These integers are \"slack variables,\" which we use to get each clause-labeled digit position to add to the target value of 4. Simple inspection of Figure 34.19 demonstrates that all \\(s_{j}\\) and \\(s^{\\prime}_{j}\\) values in \\(S\\) are unique in set \\(S\\).\n\nThe greatest sum of digits in any one digit position is 6, which occurs in the digits labeled by clauses (three 1s from the \\(v_{i}\\) and \\(v^{\\prime}_{i}\\) values, plus 1 and 2 from the \\(s_{j}\\) and \\(s^{\\prime}_{j}\\) values). Interpreting these numbers in base 10, therefore, no carries can occur from lower digits to higher digits.12\n\nFootnote 12: In fact, any base \\(b\\geq 7\\) works. The instance at the beginning of this subsection is the set \\(S\\) and target \\(t\\) in Figure 34.19 interpreted in base 7, with \\(S\\) listed in sorted order.\n\nThe reduction can be performed in polynomial time. The set \\(S\\) consists of \\(2n+2k\\) values, each of which has \\(n+k\\) digits, and the time to produce each digit is polynomial in \\(n+k\\). The target \\(t\\) has \\(n+k\\) digits, and the reduction produces each in constant time.\n\nLet's now show that the 3-CNF formula \\(\\phi\\) is satisfiable if and only if there exists a subset \\(S^{\\prime}\\subseteq S\\) whose sum is \\(t\\). First, suppose that \\(\\phi\\) has a satisfying assignment. For \\(i=1,2,\\ldots,n\\), if \\(x_{i}=1\\) in this assignment, then include \\(v_{i}\\) in \\(S^{\\prime}\\). Otherwise, include \\(v^{\\prime}_{i}\\). In other words, \\(S^{\\prime}\\) includes exactly the \\(v_{i}\\) and \\(v^{\\prime}_{i}\\) values that correspond to literals with the value 1 in the satisfying assignment. Having included either \\(v_{i}\\) or \\(v^{\\prime}_{i}\\), but not both, for all \\(i\\), and having put 0 in the digits labeled by variables in all \\(s_{j}\\) and \\(s^{\\prime}_{j}\\), we see that for each variable-labeled digit, the sum of the values of \\(S^{\\prime}\\) must be 1, which matches those digits of the target \\(t\\). Because each clause is satisfied, the clause contains some literal with the value 1. Therefore, each digit labeled by a clause has at least one 1 contributed to its sum by a \\(v_{i}\\) or \\(v^{\\prime}_{i}\\) value in \\(S^{\\prime}\\). In fact, one, two, or three literals may be 1 in each clause, and so each clause-labeled digit has a sum of 1, 2, or 3 from the \\(v_{i}\\) and \\(v^{\\prime}_{i}\\) values in \\(S^{\\prime}\\). In Figure 34.19 for example, literals \\(\\neg x_{1}\\), \\(\\neg x_{2}\\), and \\(x_{3}\\) have the value 1 in a satisfying assignment. Each of clauses \\(C_{1}\\) and \\(C_{4}\\) contains exactly one of these literals, and so together \\(v^{\\prime}_{1}\\), \\(v^{\\prime}_{2}\\), and \\(v_{3}\\) contribute 1 to the sum in the digits for \\(C_{1}\\) and \\(C_{4}\\)Clause \\(C_{2}\\) contains two of these literals, and \\(v^{\\prime}_{1}\\), \\(v^{\\prime}_{2}\\), and \\(v_{3}\\) contribute 2 to the sum in the digit for \\(C_{2}\\). Clause \\(C_{3}\\) contains all three of these literals, and \\(v^{\\prime}_{1}\\), \\(v^{\\prime}_{2}\\), and \\(v_{3}\\) contribute 3 to the sum in the digit for \\(C_{3}\\). To achieve the target of 4 in each digit labeled by clause \\(C_{j}\\), include in \\(S^{\\prime}\\) the appropriate nonempty subset of slack variables \\(\\{s_{j},s^{\\prime}_{j}\\}\\). In Figure 34.19, \\(S^{\\prime}\\) includes \\(s_{1}\\), \\(s^{\\prime}_{1}\\), \\(s^{\\prime}_{2}\\), \\(s_{3}\\), \\(s_{4}\\), and \\(s^{\\prime}_{4}\\). Since \\(S^{\\prime}\\) matches the target in all digits of the sum, and no carries can occur, the values of \\(S^{\\prime}\\) sum to \\(t\\).\n\nNow suppose that some subset \\(S^{\\prime}\\subseteq S\\) sums to \\(t\\). The subset \\(S^{\\prime}\\) must include exactly one of \\(v_{i}\\) and \\(v^{\\prime}_{i}\\) for each \\(i=1,2,\\ldots,n\\), for otherwise the digits labeled by variables would not sum to 1. If \\(v_{i}\\in S^{\\prime}\\), then set \\(x_{i}=1\\). Otherwise, \\(v^{\\prime}_{i}\\in S^{\\prime}\\), and set \\(x_{i}=0\\). We claim that every clause \\(C_{j}\\), for \\(j=1,2,\\ldots,k\\), is satisfied by this assignment. To prove this claim, note that to achieve a sum of 4 in the digit labeled by \\(C_{j}\\), the subset \\(S^{\\prime}\\) must include at least one \\(v_{i}\\) or \\(v^{\\prime}_{i}\\) value that has a 1 in the digit labeled by \\(C_{j}\\), since the contributions of the slack variables \\(s_{j}\\) and \\(s^{\\prime}_{j}\\) together sum to at most 3. If \\(S^{\\prime}\\) includes a \\(v_{i}\\) that has a 1 in \\(C_{j}\\)'s position, then the literal \\(x_{i}\\) appears in clause \\(C_{j}\\). Since \\(x_{i}=1\\) when \\(v_{i}\\in S^{\\prime}\\), clause \\(C_{j}\\) is satisfied. If \\(S^{\\prime}\\) includes a \\(v^{\\prime}_{i}\\) that has a 1 in that position, then the literal \\(\\neg x_{i}\\) appears in \\(C_{j}\\). Since \\(x_{i}=0\\) when \\(v^{\\prime}_{i}\\in S^{\\prime}\\), clause \\(C_{j}\\) is again satisfied. Thus, all clauses of \\(\\phi\\) are satisfied, which completes the proof.\n\n#### 34.5.6 Reduction strategies\n\nFrom the reductions in this section, you can see that no single strategy applies to all NP-complete problems. Some reductions are straightforward, such as reducing the hamiltonian-cycle problem to the traveling-salesperson problem. Others are considerably more complicated. Here are a few things to keep in mind and some strategies that you can often bring to bear.\n\n##### Pitfalls\n\nMake sure that you don't get the reduction backward. That is, in trying to show that problem \\(Y\\) is NP-complete, you might take a known NP-complete problem \\(X\\) and give a polynomial-time reduction from \\(Y\\) to \\(X\\). That is the wrong direction. The reduction should be from \\(X\\) to \\(Y\\), so that a solution to \\(Y\\) gives a solution to \\(X\\).\n\nRemember also that reducing a known NP-complete problem \\(X\\) to a problem \\(Y\\) does not in itself prove that \\(Y\\) is NP-complete. It proves that \\(Y\\) is NP-hard. In order to show that \\(Y\\) is NP-complete, you additionally need to prove that it's in NP by showing how to verify a certificate for \\(Y\\) in polynomial time.\n\n### Go from general to specific\n\nWhen reducing problem \\(X\\) to problem \\(Y\\), you always have to start with an arbitrary input to problem \\(X\\). But you are allowed to restrict the input to problem \\(Y\\) as much as you like. For example, when reducing 3-CNF satisfiability to the subset-sum problem, the reduction had to be able to handle _any_ 3-CNF formula as its input, but the input to the subset-sum problem that it produced had a particular structure: \\(2n+2k\\) integers in the set, and each integer was formed in a particular way. The reduction did not need to produce _every_ possible input to the subset-sum problem. The point is that one way to solve the 3-CNF satisfiability problem transforms the input into an input to the subset-sum problem and then uses the answer to the subset-sum problem as the answer to the 3-CNF satisfiability problem.\n\n### Take advantage of structure in the problem you are reducing from\n\nWhen you are choosing a problem to reduce from, you might consider two problems in the same domain, but one problem has more structure than the other. For example, it's almost always much easier to reduce from 3-CNF satisfiability than to reduce from formula satisfiability. Boolean formulas can be arbitrarily complicated, but you can exploit the structure of 3-CNF formulas when reducing.\n\nLikewise, it is usually more straightforward to reduce from the hamiltonian-cycle problem than from the traveling-salesperson problem, even though they are so similar. That's because you can view the hamiltonian-cycle problem as taking a complete graph but with edge weights of just 0 or 1, as they would appear in the adjacency matrix. In that sense, the hamiltonian-cycle problem has more structure than the traveling-salesperson problem, in which edge weights are unrestricted.\n\n### Look for special cases\n\nSeveral NP-complete problems are just special cases of other NP-complete problems. For example, consider the decision version of the 0-1 knapsack problem: given a set of \\(n\\) items, each with a weight and a value, does there exist a subset of items whose total weight is at most a given weight \\(W\\) and whose total value is at least a given value \\(V\\)? You can view the set-partition problem in Exercise 34.5-5 as a special case of the 0-1 knapsack problem: let the value of each item equal its weight, and set both \\(W\\) and \\(V\\) to half the total weight. If problem \\(X\\) is NP-hard and it is a special case of problem \\(Y\\), then problem \\(Y\\) must be NP-hard as well. That is because a polynomial-time solution for problem \\(Y\\) automatically gives a polynomial-time solution for problem \\(X\\). More intuitively, problem \\(Y\\), being more general than problem \\(X\\), is at least as hard.\n\n#### Select an appropriate problem to reduce from\n\nIt's often a good strategy to reduce from a problem in a domain that is the same as, or at least related to, the domain of the problem that you're trying to prove NP-complete. For example, we saw that the vertex-cover problem-- a graph problem-- was NP-hard by reducing from the clique problem-- also a graph problem. From the vertex-cover problem, we reduced to the hamiltonian-cycle problem, and from the hamiltonian-cycle problem, we reduced to the traveling-salesperson problem. All of these problems take undirected graphs as inputs.\n\nSometimes, however, you will find that is it better to cross over from one domain to another, such as when we reduced from 3-CNF satisfiability to the clique problem or to the subset-sum problem. 3-CNF satisfiability often turns out to be a good choice as a problem to reduce from when crossing domains.\n\nWithin graph problems, if you need to select a portion of the graph, without regard to ordering, then the vertex-cover problem is often a good place to start. If ordering matters, then consider starting from the hamiltonian-cycle or hamiltonian-path problem (see Exercise 34.5-6).\n\n#### Make big rewards and big penalties\n\nThe strategy for reducing the hamiltonian-cycle problem with a graph \\(G\\) to the traveling-salesperson problem encouraged using edges present in \\(G\\) when choosing edges for the traveling-salesperson tour. The reduction did so by giving these edges a low weight: 0. In other words, we gave a big reward for using these edges.\n\nAlternatively, the reduction could have given the edges in \\(G\\) a finite weight and given edges not in \\(G\\) infinite weight, thereby exacting a hefty penalty for using edges not in \\(G\\). With this approach, if each edge in \\(G\\) has weight \\(W\\), then the target weight of the traveling-salesperson tour becomes \\(W\\cdot|V|\\). You can sometimes think of the penalties as a way to enforce requirements. For example, if the traveling-salesperson tour includes an edge with infinite weight, then it violates the requirement that the tour should include only edges belonging to \\(G\\).\n\n#### Design gadgets\n\nThe reduction from the vertex-cover problem to the hamiltonian-cycle problem uses the gadget shown in Figure 34.16. This gadget is a subgraph that is connected to other parts of the constructed graph in order to restrict the ways that a cycle can visit each vertex in the gadget once. More generally, a gadget is a component that enforces certain properties. Gadgets can be complicated, as in the reduction to the hamiltonian-cycle problem. Or they can be simple: in the reduction of 3-CNF satisfiability to the subset-sum problem, you can view the slack variables \\(s_{j}\\) andas gadgets enabling each clause-labeled digit position to achieve the target value of 4.\n\n### Exercises\n\n#### 34.5-1\n\nThe _subgraph-isomorphism problem_ takes two undirected graphs \\(G_{1}\\) and \\(G_{2}\\), and asks whether \\(G_{1}\\) is isomorphic to a subgraph of \\(G_{2}\\). Show that the subgraph-isomorphism problem is NP-complete.\n\n#### 34.5-2\n\nGiven an integer \\(m\\times n\\) matrix \\(A\\) and an integer \\(m\\)-vector \\(b\\), the _0-1 integer-programming problem_ asks whether there exists an integer \\(n\\)-vector \\(x\\) with elements in the set \\(\\{0,1\\}\\) such that \\(Ax\\leq b\\). Prove that 0-1 integer programming is NP-complete. (_Hint:_ Reduce from 3-CNF-SAT.)\n\n#### 34.5-3\n\nThe _integer linear-programming problem_ is like the 0-1 integer-programming problem given in Exercise 34.5-2, except that the values of the vector \\(x\\) may be any integers rather than just 0 or 1. Assuming that the 0-1 integer-programming problem is NP-hard, show that the integer linear-programming problem is NP-complete.\n\n#### 34.5-4\n\nShow how to solve the subset-sum problem in polynomial time if the target value \\(t\\) is expressed in unary.\n\n#### 34.5-5\n\nThe _set-partition problem_ takes as input a set \\(S\\) of numbers. The question is whether the numbers can be partitioned into two sets \\(A\\) and \\(\\overline{A}=S-A\\) such that \\(\\sum_{x\\in A}x=\\sum_{x\\in\\overline{A}}x\\). Show that the set-partition problem is NP-complete.\n\n#### 34.5-6\n\nShow that the hamiltonian-path problem is NP-complete.\n\n#### 34.5-7\n\nThe _longest-simple-cycle problem_ is the problem of determining a simple cycle (no repeated vertices) of maximum length in a graph. Formulate a related decision problem, and show that the decision problem is NP-complete.\n\n#### 34.5-8\n\nIn the _half 3-CNF satisfiability_ problem, the input is a 3-CNF formula \\(\\phi\\) with \\(n\\) variables and \\(m\\) clauses, where \\(m\\) is even. The question is whether there exists a truth assignment to the variables of \\(\\phi\\) such that exactly half the clauses evaluate to 0 and exactly half the clauses evaluate to 1. Prove that the half 3-CNF satisfiability problem is NP-complete.\n\n#### 34.5-9\n\nThe proof that VERTEX-COVER \\(\\leq_{\\mathrm{P}}\\) HAM-CYCLE assumes that the graph \\(G\\) given as input to the vertex-cover problem has no isolated vertices. Show how the reduction in the proof can break down if \\(G\\) has an isolated vertex.\n\n## Problems\n\n### 34-1 Independent set\n\nAn _independent set_ of a graph \\(G=(V,E)\\) is a subset \\(V^{\\prime}\\subseteq V\\) of vertices such that each edge in \\(E\\) is incident on at most one vertex in \\(V^{\\prime}\\). The _independent-set problem_ is to find a maximum-size independent set in \\(G\\).\n\n* Formulate a related decision problem for the independent-set problem, and prove that it is NP-complete. (_Hint:_ Reduce from the clique problem.)\n* You are given a \"black-box\" subroutine to solve the decision problem you defined in part (a). Give an algorithm to find an independent set of maximum size. The running time of your algorithm should be polynomial in \\(|V|\\) and \\(|E|\\), counting queries to the black box as a single step.\n\nAlthough the independent-set decision problem is NP-complete, certain special cases are polynomial-time solvable.\n\n* Give an efficient algorithm to solve the independent-set problem when each vertex in \\(G\\) has degree 2. Analyze the running time, and prove that your algorithm works correctly.\n* Give an efficient algorithm to solve the independent-set problem when \\(G\\) is bipartite. Analyze the running time, and prove that your algorithm works correctly. (_Hint:_ First prove that in a bipartite graph, the size of the maximimum independent set plus the size of the maximum matching is equal to \\(|V|\\). Then use a maximum-matching algorithm (see Section 25.1) as a first step in an algorithm to find an independent set.)",
        "chapter": "Part VII Selected Topics",
        "section": "34 NP-Completeness",
        "subsection": "34.5 NP-complete problems",
        "subsubsection": "N/A"
    },
    {
        "content": "#### 34.5-8\n\nIn the _half 3-CNF satisfiability_ problem, the input is a 3-CNF formula \\(\\phi\\) with \\(n\\) variables and \\(m\\) clauses, where \\(m\\) is even. The question is whether there exists a truth assignment to the variables of \\(\\phi\\) such that exactly half the clauses evaluate to 0 and exactly half the clauses evaluate to 1. Prove that the half 3-CNF satisfiability problem is NP-complete.\n\n#### 34.5-9\n\nThe proof that VERTEX-COVER \\(\\leq_{\\mathrm{P}}\\) HAM-CYCLE assumes that the graph \\(G\\) given as input to the vertex-cover problem has no isolated vertices. Show how the reduction in the proof can break down if \\(G\\) has an isolated vertex.\n\n## Problems\n\n### 34-1 Independent set\n\nAn _independent set_ of a graph \\(G=(V,E)\\) is a subset \\(V^{\\prime}\\subseteq V\\) of vertices such that each edge in \\(E\\) is incident on at most one vertex in \\(V^{\\prime}\\). The _independent-set problem_ is to find a maximum-size independent set in \\(G\\).\n\n* Formulate a related decision problem for the independent-set problem, and prove that it is NP-complete. (_Hint:_ Reduce from the clique problem.)\n* You are given a \"black-box\" subroutine to solve the decision problem you defined in part (a). Give an algorithm to find an independent set of maximum size. The running time of your algorithm should be polynomial in \\(|V|\\) and \\(|E|\\), counting queries to the black box as a single step.\n\nAlthough the independent-set decision problem is NP-complete, certain special cases are polynomial-time solvable.\n\n* Give an efficient algorithm to solve the independent-set problem when each vertex in \\(G\\) has degree 2. Analyze the running time, and prove that your algorithm works correctly.\n* Give an efficient algorithm to solve the independent-set problem when \\(G\\) is bipartite. Analyze the running time, and prove that your algorithm works correctly. (_Hint:_ First prove that in a bipartite graph, the size of the maximimum independent set plus the size of the maximum matching is equal to \\(|V|\\). Then use a maximum-matching algorithm (see Section 25.1) as a first step in an algorithm to find an independent set.)_34-2 Bonnie and Clyde_\n\nBonnie and Clyde have just robbed a bank. They have a bag of money and want to divide it up. For each of the following scenarios, either give a polynomial-time algorithm to divide the money or prove that the problem of dividing the money in the manner described is NP-complete. The input in each case is a list of the \\(n\\) items in the bag, along with the value of each.\n\n* The bag contains \\(n\\) coins, but only two different denominations: some coins are worth \\(x\\) dollars, and some are worth \\(y\\) dollars. Bonnie and Clyde wish to divide the money exactly evenly.\n* The bag contains \\(n\\) coins, with an arbitrary number of different denominations, but each denomination is a nonnegative exact power of 2, so that the possible denominations are 1 dollar, 2 dollars, 4 dollars, etc. Bonnie and Clyde wish to divide the money exactly evenly.\n* The bag contains \\(n\\) checks, which are, in an amazing coincidence, made out to \"Bonnie or Clyde.\" They wish to divide the checks so that they each get the exact same amount of money.\n* The bag contains \\(n\\) checks as in part (c), but this time Bonnie and Clyde are willing to accept a split in which the difference is no larger than 100 dollars.\n\n_34-3 Graph coloring_\n\nMapmakers try to use as few colors as possible when coloring countries on a map, subject to the restriction that if two countries share a border, they must have different colors. You can model this problem with an undirected graph \\(G=(V,E)\\) in which each vertex represents a country and vertices whose respective countries share a border are adjacent. Then, a \\(k\\)_-coloring_ is a function \\(c:V\\rightarrow\\{1,2,\\ldots,k\\}\\) such that \\(c(u)\\neq c(v)\\) for every edge \\((u,v)\\in E\\). In other words, the numbers \\(1,2,\\ldots,k\\) represent the \\(k\\) colors, and adjacent vertices must have different colors. The _graph-coloring problem_ is to determine the minimum number of colors needed to color a given graph.\n\n* Give an efficient algorithm to determine a 2-coloring of a graph, if one exists.\n* Cast the graph-coloring problem as a decision problem. Show that your decision problem is solvable in polynomial time if and only if the graph-coloring problem is solvable in polynomial time.\n* Let the language 3-COLOR be the set of graphs that can be 3-colored. Show that if 3-COLOR is NP-complete, then your decision problem from part (b) is NP-complete.\n\nTo prove that 3-COLOR is NP-complete, you can reduce from 3-CNF-SAT. Given a formula \\(\\phi\\) of \\(m\\) clauses on \\(n\\) variables \\(x_{1},x_{2},\\ldots,x_{n}\\), construct a graph \\(G=(V,E)\\) as follows. The set \\(V\\) consists of a vertex for each variable, a vertex for the negation of each variable, five vertices for each clause, and three special vertices: true, false, and red. The edges of the graph are of two types: \"literal\" edges that are independent of the clauses and \"clause\" edges that depend on the clauses. As Figure 34.20 shows, the literal edges form a triangle on the three special vertices true, false, and red, and they also form a triangle on \\(x_{i}\\), \\(\\neg x_{i}\\), and red for \\(i=1,2,\\ldots,n\\).\n\n_e._ Argue that if each of \\(x\\), \\(y\\), and \\(z\\) is colored \\(c\\)(true) or \\(c\\)(false), then the gadget is 3-colorable if and only if at least one of \\(x\\), \\(y\\), or \\(z\\) is colored \\(c\\)(true). _f._ Complete the proof that 3-COLOR is NP-complete.\n\n_34-4 Scheduling with profits and deadlines_ You have one computer and a set of \\(n\\) tasks \\(\\{a_{1},a_{2},\\ldots,a_{n}\\}\\) requiring time on the computer. Each task \\(a_{j}\\) requires \\(t_{j}\\) time units on the computer (its processing time), yields a profit of \\(p_{j}\\), and has a deadline \\(d_{j}\\). The computer can process only one task at a time, and task \\(a_{j}\\) must run without interruption for \\(t_{j}\\) consecutive time units. If task \\(a_{j}\\) completes by its deadline \\(d_{j}\\), you receive a profit \\(p_{j}\\). If instead task \\(a_{j}\\) completes after its deadline, you receive no profit. As an optimization problem, given the processing times, profits, and deadlines for a set of \\(n\\) tasks, you wish to find a schedule that completes all the tasks and returns the greatest amount of profit. The processing times, profits, and deadlines are all nonnegative numbers.\n\n_a._ State this problem as a decision problem.\n\n_b._ Show that the decision problem is NP-complete.\n\n_c._ Give a polynomial-time algorithm for the decision problem, assuming that all processing times are integers from 1 to \\(n\\). (_Hint:_ Use dynamic programming.)\n\n_d._ Give a polynomial-time algorithm for the optimization problem, assuming that all processing times are integers from 1 to \\(n\\).\n\n## Chapter notes\n\nThe book by Garey and Johnson [176] provides a wonderful guide to NP-completeness, discussing the theory at length and providing a catalogue of many problems that were known to be NP-complete in 1979. The proof of Theorem 3.13 is adapted from their book, and the list of NP-complete problem domains at the beginning of Section 34.5 is drawn from their table of contents. Johnson wrote a series of 23 columns in the _Journal of Algorithms_ between 1981 and 1992 reporting new developments in NP-completeness. Fortnow's book [152] gives a history of NP-completeness, along with societal implications. Hopcroft, Motwani, and Ullman [225], Lewis and Papadimitriou [299], Papadimitriou [352], and Sipser [413] have good treatments of NP-completeness in the context of complexity theory. NP-completeness and several reductions also appear in books by Aho, Hopcroft, and Ullman [5], Dasgupta, Papadimitriou, and Vazirani [107], Johnsonbaugh and",
        "chapter": "Part VII Selected Topics",
        "section": "34 NP-Completeness",
        "subsection": "Problems",
        "subsubsection": "N/A"
    },
    {
        "content": "_e._ Argue that if each of \\(x\\), \\(y\\), and \\(z\\) is colored \\(c\\)(true) or \\(c\\)(false), then the gadget is 3-colorable if and only if at least one of \\(x\\), \\(y\\), or \\(z\\) is colored \\(c\\)(true). _f._ Complete the proof that 3-COLOR is NP-complete.\n\n_34-4 Scheduling with profits and deadlines_ You have one computer and a set of \\(n\\) tasks \\(\\{a_{1},a_{2},\\ldots,a_{n}\\}\\) requiring time on the computer. Each task \\(a_{j}\\) requires \\(t_{j}\\) time units on the computer (its processing time), yields a profit of \\(p_{j}\\), and has a deadline \\(d_{j}\\). The computer can process only one task at a time, and task \\(a_{j}\\) must run without interruption for \\(t_{j}\\) consecutive time units. If task \\(a_{j}\\) completes by its deadline \\(d_{j}\\), you receive a profit \\(p_{j}\\). If instead task \\(a_{j}\\) completes after its deadline, you receive no profit. As an optimization problem, given the processing times, profits, and deadlines for a set of \\(n\\) tasks, you wish to find a schedule that completes all the tasks and returns the greatest amount of profit. The processing times, profits, and deadlines are all nonnegative numbers.\n\n_a._ State this problem as a decision problem.\n\n_b._ Show that the decision problem is NP-complete.\n\n_c._ Give a polynomial-time algorithm for the decision problem, assuming that all processing times are integers from 1 to \\(n\\). (_Hint:_ Use dynamic programming.)\n\n_d._ Give a polynomial-time algorithm for the optimization problem, assuming that all processing times are integers from 1 to \\(n\\).\n\n## Chapter notes\n\nThe book by Garey and Johnson [176] provides a wonderful guide to NP-completeness, discussing the theory at length and providing a catalogue of many problems that were known to be NP-complete in 1979. The proof of Theorem 3.13 is adapted from their book, and the list of NP-complete problem domains at the beginning of Section 34.5 is drawn from their table of contents. Johnson wrote a series of 23 columns in the _Journal of Algorithms_ between 1981 and 1992 reporting new developments in NP-completeness. Fortnow's book [152] gives a history of NP-completeness, along with societal implications. Hopcroft, Motwani, and Ullman [225], Lewis and Papadimitriou [299], Papadimitriou [352], and Sipser [413] have good treatments of NP-completeness in the context of complexity theory. NP-completeness and several reductions also appear in books by Aho, Hopcroft, and Ullman [5], Dasgupta, Papadimitriou, and Vazirani [107], Johnsonbaugh and Schaefer [239], and Kleinberg and Tardos [257]. The book by Hromkovic [229] studies various methods for solving hard problems.\n\nThe class P was introduced in 1964 by Cobham [96] and, independently, in 1965 by Edmonds [130], who also introduced the class NP and conjectured that P \\(\\neq\\) NP. The notion of NP-completeness was proposed in 1971 by Cook [100], who gave the first NP-completeness proofs for formula satisfiability and 3-CNF satisfiability. Levin [297] independently discovered the notion, giving an NP-completeness proof for a tiling problem. Karp [248] introduced the methodology of reductions in 1972 and demonstrated the rich variety of NP-complete problems. Karp's paper included the original NP-completeness proofs of the clique, vertex-cover, and hamiltonian-cycle problems. Since then, thousands of problems have been proven to be NP-complete by many researchers.\n\nWork in complexity theory has shed light on the complexity of computing approximate solutions. This work gives a new definition of NP using \"probabilistically checkable proofs.\" This new definition implies that for problems such as clique, vertex cover, the traveling-salesperson problem with the triangle inequality, and many others, computing good approximate solutions (see Chapter 35) is NP-hard and hence no easier than computing optimal solutions. An introduction to this area can be found in Arora's thesis [21], a chapter by Arora and Lund in Hochbaum [221], a survey article by Arora [22], a book edited by Mayr, Promel, and Steger [319], a survey article by Johnson [237], and a chapter in the textbook by Arora and Barak [24].\n\n## Chapter 3 Approximation Algorithms\n\nMany problems of practical significance are NP-complete, yet they are too important to abandon merely because nobody knows how to find an optimal solution in polynomial time. Even if a problem is NP-complete, there may be hope. You have at least three options to get around NP-completeness. First, if the actual inputs are small, an algorithm with exponential running time might be fast enough. Second, you might be able to isolate important special cases that you can solve in polynomial time. Third, you can try to devise an approach to find a _near-optimal_ solution in polynomial time (either in the worst case or the expected case). In practice, near-optimality is often good enough. We call an algorithm that returns near-optimal solutions an _approximation algorithm_. This chapter presents polynomial-time approximation algorithms for several NP-complete problems.\n\n### Performance ratios for approximation algorithms\n\nSuppose that you are working on an optimization problem in which each potential solution has a positive cost, and you want to find a near-optimal solution. Depending on the problem, you could define an optimal solution as one with maximum possible cost or as one with minimum possible cost, which is to say that the problem might be either a maximization or a minimization problem.\n\nWe say that an algorithm for a problem has an _approximation ratio_ of \\(\\rho(n)\\) if, for any input of size \\(n\\), the cost \\(C\\) of the solution produced by the algorithm is within a factor of \\(\\rho(n)\\) of the cost \\(C^{*}\\) of an optimal solution:\n\n\\[\\max\\left\\{\\frac{C}{C^{*}},\\frac{C^{*}}{C}\\right\\}\\leq\\rho(n) \\tag{35.1}\\]\n\nIf an algorithm achieves an approximation ratio of \\(\\rho(n)\\), we call it a _\\(\\rho(n)\\)-approximation algorithm_. The definitions of approximation ratio and \\(\\rho(n)\\)-approximation algorithm apply to both minimization and maximization problems. For a maximization problem, \\(0<C\\leq C^{*}\\), and the ratio \\(C^{*}/C\\) gives the factor by which",
        "chapter": "Part VII Selected Topics",
        "section": "34 NP-Completeness",
        "subsection": "Chapter notes",
        "subsubsection": "N/A"
    },
    {
        "content": "### Chapter outline\n\nThe first four sections of this chapter present some examples of polynomial-time approximation algorithms for NP-complete problems, and the fifth section gives a fully polynomial-time approximation scheme. We begin in Section 35.1 with a study of the vertex-cover problem, an NP-complete minimization problem that has an approximation algorithm with an approximation ratio of 2. Section 35.2 looks at a version of the traveling-salesperson problem in which the cost function satisfies the triangle inequality and presents an approximation algorithm with an approximation ratio of 2. The section also shows that without the triangle inequality, for any constant \\(\\rho\\geq 1\\), a \\(\\rho\\)-approximation algorithm cannot exist unless \\(\\mathrm{P}=\\mathrm{NP}\\). Section 35.3 applies a greedy method as an effective approximation algorithm for the set-covering problem, obtaining a covering whose cost is at worst a logarithmic factor larger than the optimal cost. Section 35.4 uses randomization and linear programming to develop two more approximation algorithms. The section first defines the optimization version of 3-CNF satisfiability and gives a simple randomized algorithm that produces a solution with an expected approximation ratio of \\(8/7\\). Then Section 35.4 examines a weighted variant of the vertex-cover problem and exhibits how to use linear programming to develop a 2-approximation algorithm. Finally, Section 35.5 presents a fully polynomial-time approximation scheme for the subset-sum problem.\n\n### 35.1 The vertex-cover problem\n\nSection 34.5.2 defined the vertex-cover problem and proved it NP-complete. Recall that a _vertex cover_ of an undirected graph \\(G=(V,E)\\) is a subset \\(V^{\\prime}\\subseteq V\\) such that if \\((u,v)\\) is an edge of \\(G\\), then either \\(u\\in V^{\\prime}\\) or \\(v\\in V^{\\prime}\\) (or both). The size of a vertex cover is the number of vertices in it.\n\nThe _vertex-cover problem_ is to find a vertex cover of minimum size in a given undirected graph. We call such a vertex cover an _optimal vertex cover_. This problem is the optimization version of an NP-complete decision problem.\n\nEven though nobody knows how to find an optimal vertex cover in a graph \\(G\\) in polynomial time, there is an efficient algorithm to find a vertex cover that is near-optimal. The approximation algorithm Approx-Vertex-Cover on the facing page takes as input an undirected graph \\(G\\) and returns a vertex cover whose size is guaranteed to be no more than twice the size of an optimal vertex cover.\n\nFigure 35.1 illustrates how Approx-Vertex-Cover operates on an example graph. The variable \\(C\\) contains the vertex cover being constructed. Line 1 initializes \\(C\\) to the empty set. Line 2 sets \\(E^{\\prime}\\) to be a copy of the edge set \\(G.E\\) of the graph. The **while** loop of lines 3-6 repeatedly picks an edge \\((u,v)\\) from \\(E^{\\prime}\\), adds\n\n### 35.1 The vertex-cover problem\n\nApprox-Vertex-Cover(\\(G\\))\n\n\\(C\\,=\\,\\emptyset\\)\n\n\\(E^{\\prime}\\,=\\,G.E\\)\n\n**while**\\(E^{\\prime}\\neq\\emptyset\\)\n\n let \\((u,v)\\) be an arbitrary edge of \\(E^{\\prime}\\)\n\n\\(C\\,=\\,C\\,\\cup\\,\\{u,v\\}\\)\n\n remove from \\(E^{\\prime}\\) edge \\((u,v)\\) and every edge incident on either \\(u\\) or \\(v\\)\n\n**return**\\(C\\)\n\n**in**\\(E^{\\prime}\\)**.\n\n**Theorem 35.1**: Approx-Vertex-Cover is a polynomial-time 2-approximation algorithm.\n\n_Proof_ We have already shown that Approx-Vertex-Cover runs in polynomial time.\n\nThe set \\(C\\) of vertices that is returned by Approx-Vertex-Cover is a vertex cover, since the algorithm loops until every edge in \\(G.E\\) has been covered by some vertex in \\(C\\).\n\nTo see that Approx-Vertex-Cover returns a vertex cover that is at most twice the size of an optimal cover, let \\(A\\) denote the set of edges that line 4 of Approx-Vertex-Cover picked. In order to cover the edges in \\(A\\), any vertex cover--in particular, an optimal cover \\(C^{\\,*}\\,\\)--must include at least one endpoint of each edge in \\(A\\). No two edges in \\(A\\) share an endpoint, since once an edge is picked in line 4, all other edges that are incident on its endpoints are deleted from \\(E^{\\prime}\\) in line 6. Thus, no two edges in \\(A\\) are covered by the same vertex from \\(C^{\\,*}\\), meaning that for every vertex in \\(C^{\\,*}\\), there is at most one edge in \\(A\\), giving the lower bound\n\n\\[|C^{\\,*}|\\geq|A| \\tag{35.2}\\]\n\non the size of an optimal vertex cover. Each execution of line 4 picks an edge for which neither of its endpoints is already in \\(C\\), yielding an upper bound (an exact upper bound, in fact) on the size of the vertex cover returned:\n\n\\[|C|\\,=\\,2\\,|A|\\enspace. \\tag{35.3}\\]\n\nCombining equations (35.2) and (35.3) yields\n\n\\[|C| \\,=\\,2\\,|A|\\] \\[\\,\\leq\\,2\\,|C^{\\,*}|\\enspace,\\]\n\nthereby proving the theorem.\n\nLet us reflect on this proof. At first, you might wonder how you can possibly prove that the size of the vertex cover returned by Approx-Vertex-Cover is at most twice the size of an optimal vertex cover, when you don't even know the size of an optimal vertex cover. Instead of requiring that you know the exact size of an optimal vertex cover, you find a lower bound on the size. As Exercise 35.1-2 asks you to show, the set \\(A\\) of edges that line 4 of Approx-Vertex-Cover selects is actually a maximal matching in the graph \\(G\\). (A _maximal matching_ is a matching to which no edges can be added and still have a matching.) The size of a maximal matching is, as we argued in the proof of Theorem 35.1, a lower bound on the size of an optimal vertex cover. The algorithm returns a vertex cover whose size is at most twice the size of the maximal matching \\(A\\). The approximation ratio comes from relating the size of the solution returned to the lower bound. We will use this methodology in later sections as well.\n\nFigure 35: The operation of Approx-Vertex-Cover. **(a)** The input graph \\(G\\), which has 7 vertices and 8 edges. **(b)** The highlighted edge \\((b,c)\\) is the first edge chosen by Approx-Vertex-Cover. Vertices \\(b\\) and \\(c\\), in blue, are added to the set \\(C\\) containing the vertex cover being created. Dashed edges \\((a,b)\\), \\((c,e)\\), and \\((c,d)\\) are removed since they are now covered by some vertex in \\(C\\). **(c)** Edge \\((e,f)\\) is chosen, and vertices \\(e\\) and \\(f\\) are added to \\(C\\). **(d)** Edge \\((d,g)\\) is chosen, and vertices \\(d\\) and \\(g\\) are added to \\(C\\). **(e)** The set \\(C\\), which is the vertex cover produced by Approx-Vertex-Cover,contains the six vertices \\(b,c,d,e\\), \\(f,g\\). **(f)** The optimal vertex cover for this problem contains only three vertices: \\(b,d\\), and \\(e\\).\n\n### Exercises\n\n#### 35.1-1\n\nGive an example of a graph for which Approx-Vertex-Cover always yields a suboptimal solution.\n\n#### 35.1-2\n\nProve that the set of edges picked in line 4 of Approx-Vertex-Cover forms a maximal matching in the graph \\(G\\).\n* _35.1-3_ Consider the following heuristic to solve the vertex-cover problem. Repeatedly select a vertex of highest degree, and remove all of its incident edges. Give an example to show that this heuristic does not provide an approximation ratio of 2. (_Hint_: Try a bipartite graph with vertices of uniform degree on the left and vertices of varying degree on the right.)\n\n#### 35.1-4\n\nGive an efficient greedy algorithm that finds an optimal vertex cover for a tree in linear time.\n\n#### 35.1-5\n\nThe proof of Theorem 34.12 on page 1084 illustrates that the vertex-cover problem and the NP-complete clique problem are complementary in the sense that an optimal vertex cover is the complement of a maximum-size clique in the complement graph. Does this relationship imply that there is a polynomial-time approximation algorithm with a constant approximation ratio for the clique problem? Justify your answer.\n\n### The traveling-salesperson problem\n\nThe input to the traveling-salesperson problem, introduced in Section 34.5.4, is a complete undirected graph \\(G=(V,E)\\) that has a nonnegative integer cost \\(c(u,v)\\) associated with each edge \\((u,v)\\in E\\). The goal is to find a hamiltonian cycle (a tour) of \\(G\\) with minimum cost. As an extension of our notation, let \\(c(A)\\) denote the total cost of the edges in the subset \\(A\\subseteq E\\):\n\n\\[c(A)=\\sum_{(u,v)\\in A}c(u,v)\\.\\]",
        "chapter": "Part VII Selected Topics",
        "section": "35 Approximation Algorithms",
        "subsection": "35.1 The vertex-cover problem",
        "subsubsection": "N/A"
    },
    {
        "content": "### Exercises\n\n#### 35.1-1\n\nGive an example of a graph for which Approx-Vertex-Cover always yields a suboptimal solution.\n\n#### 35.1-2\n\nProve that the set of edges picked in line 4 of Approx-Vertex-Cover forms a maximal matching in the graph \\(G\\).\n* _35.1-3_ Consider the following heuristic to solve the vertex-cover problem. Repeatedly select a vertex of highest degree, and remove all of its incident edges. Give an example to show that this heuristic does not provide an approximation ratio of 2. (_Hint_: Try a bipartite graph with vertices of uniform degree on the left and vertices of varying degree on the right.)\n\n#### 35.1-4\n\nGive an efficient greedy algorithm that finds an optimal vertex cover for a tree in linear time.\n\n#### 35.1-5\n\nThe proof of Theorem 34.12 on page 1084 illustrates that the vertex-cover problem and the NP-complete clique problem are complementary in the sense that an optimal vertex cover is the complement of a maximum-size clique in the complement graph. Does this relationship imply that there is a polynomial-time approximation algorithm with a constant approximation ratio for the clique problem? Justify your answer.\n\n### The traveling-salesperson problem\n\nThe input to the traveling-salesperson problem, introduced in Section 34.5.4, is a complete undirected graph \\(G=(V,E)\\) that has a nonnegative integer cost \\(c(u,v)\\) associated with each edge \\((u,v)\\in E\\). The goal is to find a hamiltonian cycle (a tour) of \\(G\\) with minimum cost. As an extension of our notation, let \\(c(A)\\) denote the total cost of the edges in the subset \\(A\\subseteq E\\):\n\n\\[c(A)=\\sum_{(u,v)\\in A}c(u,v)\\.\\]In many practical situations, the least costly way to go from a place \\(u\\) to a place \\(w\\) is to go directly, with no intermediate steps. Put another way, cutting out an intermediate stop never increases the cost. Such a cost function \\(c\\) satisfies the _triangle inequality_: for all vertices \\(u\\), \\(v\\), \\(w\\in V\\),\n\n\\(c(u,w)\\leq c(u,v)+c(v,w)\\).\n\nThe triangle inequality seems as though it should naturally hold, and it is automatically satisfied in several applications. For example, if the vertices of the graph are points in the plane and the cost of traveling between two vertices is the ordinary euclidean distance between them, then the triangle inequality is satisfied. Furthermore, many cost functions other than euclidean distance satisfy the triangle inequality.\n\nAs Exercise 35.2-2 shows, the traveling-salesperson problem is NP-complete even if you require the cost function to satisfy the triangle inequality. Thus, you should not expect to find a polynomial-time algorithm for solving this problem exactly. Your time would be better spent looking for good approximation algorithms.\n\nIn Section 35.2.1, we examine a 2-approximation algorithm for the traveling-salesperson problem with the triangle inequality. In Section 35.2.2, we show that without the triangle inequality, a polynomial-time approximation algorithm with a constant approximation ratio does not exist unless \\(P=NP\\).\n\n#### The traveling-salesperson problem with the triangle inequality\n\nApplying the methodology of the previous section, start by computing a structure -- a minimum spanning tree-- whose weight gives a lower bound on the length of an optimal traveling-salesperson tour. Then use the minimum spanning tree to create a tour whose cost is no more than twice that of the minimum spanning tree's weight, as long as the cost function satisfies the triangle inequality. The procedure Approx-TSP-Tour on the next page implements this approach, calling the minimum-spanning-tree algorithm MST-Prim on page 596 as a subroutine. The parameter \\(G\\) is a complete undirected graph, and the cost function \\(c\\) satisfies the triangle inequality.\n\nRecall from Section 12.1 that a preorder tree walk recursively visits every vertex in the tree, listing a vertex when it is first encountered, before visiting any of its children.\n\nFigure 35.2 illustrates the operation of Approx-TSP-Tour. Part (a) of the figure shows a complete undirected graph, and part (b) shows the minimum spanning tree \\(T\\) grown from root vertex \\(a\\) by MST-Prim. Part (c) shows how a preorder walk of \\(T\\) visits the vertices, and part (d) displays the corresponding tour, which is the tour returned by Approx-TSP-Tour. Part (e) displays an optimal tour, which is about 23% shorter.\n\n#### 35.2 The traveling-salesperson problem\n\n##### 35.2.1 The operation of Approx-TSP-Tour.\n\n**(a)** A complete undirected graph. Vertices lie on intersections of integer grid lines. For example, \\(f\\) is one unit to the right and two units up from \\(h\\). The cost function between two points is the ordinary euclidean distance. **(b)** A minimum spanning tree \\(T\\) of the complete graph, as computed by MST-Prim. Vertex \\(a\\) is the root vertex. Only edges in the minimum spanning tree are shown. The vertices happen to be labeled in such a way that they are added to the main tree by MST-Prim in alphabetical order. **(c)** A walk of \\(T\\), starting at \\(a\\). A full walk of the tree visits the vertices in the order \\(a,b,c,b,h,b,a,d,e,\\)\\(f,e,g,e,d,a\\). A preorder walk of \\(T\\) lists a vertex just when it is first encountered, as indicated by the dot next to each vertex, yielding the ordering \\(a,b,c,h,d,e,f,g\\). **(d)** A tour obtained by visiting the vertices in the order given by the preorder walk, which is the tour \\(H\\) returned by Approx-TSP-Tour. Its total cost is approximately 19.074. **(e)** An optimal tour \\(H^{*}\\) for the original complete graph. Its total cost is approximately 14.715.\n\n##### 35.2.2 Approx-TSP-Tour(\\(G,c\\))\n\n1 select a vertex \\(r\\in G.V\\) to be a \"root\" vertex\n\n2 compute a minimum spanning tree \\(T\\) for \\(G\\) from root \\(r\\)\n\nusing MST-Prim(\\(G,c,r\\))\n\n3 let \\(H\\) be a list of vertices, ordered according to when they are first visited\n\nin a preorder tree walk of \\(T\\)\n\n4\n\n**return** the hamiltonian cycle \\(H\\)\n\nFigure 35.2: The operation of Approx-TSP-Tour. **(a)** A complete undirected graph. Vertices lie on intersections of integer grid lines. For example, \\(f\\) is one unit to the right and two units up from \\(h\\). The cost function between two points is the ordinary euclidean distance. **(b)** A minimum spanning tree \\(T\\) of the complete graph, as computed by MST-Prim. Vertex \\(a\\) is the root vertex. Only edges in the minimum spanning tree are shown. The vertices happen to be labeled in such a way that they are added to the main tree by MST-Prim in alphabetical order. **(c)** A walk of \\(T\\), starting at \\(a\\). A full walk of the tree visits the vertices in the order \\(a,b,c,b,h,b,a,d,e,\\)\\(f,e,g,e,d,a\\). A preorder walk of \\(T\\) lists a vertex just when it is first encountered, as indicated by the dot next to each vertex, yielding the ordering \\(a,b,c,h,d,e,f,g\\). **(d)** A tour obtained by visiting the vertices in the order given by the preorder walk, which is the tour \\(H\\) returned by Approx-TSP-Tour. Its total cost is approximately 19.074. **(e)** An optimal tour \\(H^{*}\\) for the original complete graph. Its total cost is approximately 14.715.\n\nBy Exercise 21.2-2, even with a simple implementation of MST-Prim, the running time of Approx-TSP-Tour is \\(\\Theta(V^{2})\\). We now show that if the cost function for an instance of the traveling-salesperson problem satisfies the triangle inequality, then Approx-TSP-Tour returns a tour whose cost is at most twice the cost of an optimal tour.\n\n**Theorem 35.2**: _When the triangle inequality holds, Approx-TSP-Tour is a polynomial-time 2-approximation algorithm for the traveling-salesperson problem._\n\n_Proof_ We have already seen that Approx-TSP-Tour runs in polynomial time.\n\nLet \\(H^{*}\\) denote an optimal tour for the given set of vertices. Deleting any edge from a tour yields a spanning tree, and each edge cost is nonnegative. Therefore, the weight of the minimum spanning tree \\(T\\) computed in line 2 of Approx-TSP-Tour provides a lower bound on the cost of an optimal tour:\n\n\\[c\\left(T\\right)\\leq c\\left(H^{*}\\right)\\,. \\tag{35.4}\\]\n\nA _full walk_ of \\(T\\) lists the vertices when they are first visited and also whenever they are returned to after a visit to a subtree. Let's call this full walk \\(W\\). The full walk of our example gives the order\n\n\\[a,b,c,b,h,b,a,d,e,f,e,g,e,d,a\\,\\,.\\]\n\nSince the full walk traverses every edge of \\(T\\) exactly twice, by extending the definition of the cost \\(c\\) in the natural manner to handle multisets of edges, we have\n\n\\[c\\left(W\\right)=2c\\left(T\\right)\\,. \\tag{35.5}\\]\n\nInequality (35.4) and equation (35.5) imply that\n\n\\[c\\left(W\\right)\\leq 2c\\left(H^{*}\\right)\\,, \\tag{35.6}\\]\n\nand so the cost of \\(W\\) is within a factor of 2 of the cost of an optimal tour.\n\nOf course, the full walk \\(W\\) is not a tour, since it visits some vertices more than once. By the triangle inequality, however, deleting a visit to any vertex from \\(W\\) does not increase the cost. (When a vertex \\(v\\) is deleted from \\(W\\) between visits to \\(u\\) and \\(w\\), the resulting ordering specifies going directly from \\(u\\) to \\(w\\).) Repeatedly apply this operation on each visit to a vertex after the first time it's visited in \\(W\\), so that \\(W\\) is left with only the first visit to each vertex. In our example, this process leaves the ordering\n\n\\[a,b,c,h,d,e,f,g\\,\\,.\\]\n\nThis ordering is the same as that obtained by a preorder walk of the tree \\(T\\). Let \\(H\\) be the cycle corresponding to this preorder walk. It is a hamiltonian cycle, since every vertex is visited exactly once, and in fact it is the cycle computed by Appro-TSP-Tour. Since \\(H\\) is obtained by deleting vertices from the full walk \\(W\\), we have\n\n\\[c(H)\\leq c(W). \\tag{35.7}\\]\n\nCombining inequalities (35.6) and (35.7) gives \\(c(H)\\leq 2c(H^{*})\\), which completes the proof.\n\nDespite the small approximation ratio provided by Theorem 35.2, Appro-TSP-Tour is usually not the best practical choice for this problem. There are other approximation algorithms that typically perform much better in practice. (See the references at the end of this chapter.)\n\n#### 35.2.2 The general traveling-salesperson problem\n\nWhen the cost function \\(c\\) does not satisfy the triangle inequality, there is no way to find good approximate tours in polynomial time unless \\(\\mathrm{P}=\\mathrm{NP}\\).\n\n_Theorem 35.3_\n\nIf \\(\\mathrm{P}\\neq\\mathrm{NP}\\), then for any constant \\(\\rho\\geq 1\\), there is no polynomial-time approximation algorithm with approximation ratio \\(\\rho\\) for the general traveling-salesperson problem.\n\n_Proof_ The proof is by contradiction. Suppose to the contrary that for some number \\(\\rho\\geq 1\\), there is a polynomial-time approximation algorithm \\(A\\) with approximation ratio \\(\\rho\\). Without loss of generality, assume that \\(\\rho\\) is an integer, by rounding it up if necessary. We will show how to use \\(A\\) to solve instances of the hamiltonian-cycle problem (defined in Section 34.2) in polynomial time. Since Theorem 34.13 on page 34.4 on page 34.4 implies that if it has a polynomial-time algorithm, then \\(\\mathrm{P}=\\mathrm{NP}\\).\n\nLet \\(G=(V,E)\\) be an instance of the hamiltonian-cycle problem. We will show how to determine efficiently whether \\(G\\) contains a hamiltonian cycle by making use of the hypothesized approximation algorithm \\(A\\). Convert \\(G\\) into an instance of the traveling-salesperson problem as follows. Let \\(G^{\\prime}=(V,E^{\\prime})\\) be the complete graph on \\(V\\), that is,\n\n\\[E^{\\prime}=\\left\\{(u,v):u,v\\in V\\text{ and }u\\neq v\\right\\}\\.\\]\n\nAssign an integer cost to each edge in \\(E^{\\prime}\\) as follows:\n\n\\[c(u,v)=\\left\\{\\begin{array}{ll}1&\\text{if }(u,v)\\in E\\,\\\\ \\rho\\left|V\\right|+1&\\text{otherwise }.\\end{array}\\right.\\]Given a representation of \\(G\\), it takes time polynomial in \\(|V|\\) and \\(|E|\\) to create representations of \\(G^{\\prime}\\) and \\(c\\).\n\nNow consider the traveling-salesperson problem \\((G^{\\prime},c)\\). If the original graph \\(G\\) has a hamiltonian cycle \\(H\\), then the cost function \\(c\\) assigns to each edge of \\(H\\) a cost of \\(1\\), and so \\((G^{\\prime},c)\\) contains a tour of cost \\(|V|\\). On the other hand, if \\(G\\) does not contain a hamiltonian cycle, then any tour of \\(G^{\\prime}\\) must use some edge not in \\(E\\). But any tour that uses an edge not in \\(E\\) has a cost of at least\n\n\\[(\\rho\\,|V|+1)+(|V|-1) = \\rho\\,|V|+|V|\\] \\[> \\rho\\,|V|\\enspace.\\]\n\nBecause edges not in \\(G\\) are so costly, there is a gap of at least \\(\\rho\\,|V|\\) between the cost of a tour that is a hamiltonian cycle in \\(G\\) (cost \\(|V|\\)) and the cost of any other tour (cost at least \\(\\rho\\,|V|+|V|\\)). Therefore, the cost of a tour that is not a hamiltonian cycle in \\(G\\) is at least a factor of \\(\\rho+1\\) greater than the cost of a tour that is a hamiltonian cycle in \\(G\\).\n\nWhat happens upon applying the approximation algorithm \\(A\\) to the traveling-salesperson problem \\((G^{\\prime},c)\\)? Because \\(A\\) is guaranteed to return a tour of cost no more than \\(\\rho\\) times the cost of an optimal tour, if \\(G\\) contains a hamiltonian cycle, then \\(A\\) must return it. If \\(G\\) has no hamiltonian cycle, then \\(A\\) returns a tour of cost more than \\(\\rho\\,|V|\\). Therefore, using \\(A\\) solves the hamiltonian-cycle problem in polynomial time.\n\nThe proof of Theorem 35.3 serves as an example of a general technique to prove that no good approximation algorithm exists for a particular problem. Given an NP-hard decision problem \\(X\\), produce in polynomial time a minimization problem \\(Y\\) such that \"yes\" instances of \\(X\\) correspond to instances of \\(Y\\) with value at most \\(k\\) (for some \\(k\\)), but that \"no\" instances of \\(X\\) correspond to instances of \\(Y\\) with value greater than \\(\\rho k\\). This technique shows that, unless \\(\\mathrm{P}=\\mathrm{NP}\\), there is no polynomial-time \\(\\rho\\)-approximation algorithm for problem \\(Y\\).\n\n#### Exercises\n\n##### 35.2-1\n\nLet \\(G=(V,E)\\) be a complete undirected graph containing at least \\(3\\) vertices, and let \\(c\\) be a cost function that satisfies the triangle inequality. Prove that \\(c(u,v)\\geq 0\\) for all \\(u,v\\in V\\).\n\n##### 35.2-2\n\nShow how in polynomial time to transform one instance of the traveling-salesperson problem into another instance whose cost function satisfies the triangle inequality. The two instances must have the same set of optimal tours. Explain why such a polynomial-time transformation does not contradict Theorem 35.3, assuming that \\(\\mathrm{P}\\neq\\mathrm{NP}\\).\n\n#### 35.2-3\n\nConsider the following _closest-point heuristic_ for building an approximate traveling-salesperson tour whose cost function satisfies the triangle inequality. Begin with a trivial cycle consisting of a single arbitrarily chosen vertex. At each step, identify the vertex \\(u\\) that is not on the cycle but whose distance to any vertex on the cycle is minimum. Suppose that the vertex on the cycle that is nearest \\(u\\) is vertex \\(v\\). Extend the cycle to include \\(u\\) by inserting \\(u\\) just after \\(v\\). Repeat until all vertices are on the cycle. Prove that this heuristic returns a tour whose total cost is not more than twice the cost of an optimal tour.\n\n#### 35.2-4\n\nA solution to the _bottleneck traveling-salesperson problem_ is the hamiltonian cycle that minimizes the cost of the most costly edge in the cycle. Assuming that the cost function satisfies the triangle inequality, show that there exists a polynomial-time approximation algorithm with approximation ratio 3 for this problem. (_Hint:_ Show recursively how to visit all the nodes in a bottleneck spanning tree, as discussed in Problem 21-4 on page 601, exactly once by taking a full walk of the tree and skipping nodes, but without skipping more than two consecutive intermediate nodes. Show that the costliest edge in a bottleneck spanning tree has a cost bounded from above by the cost of the costliest edge in a bottleneck hamiltonian cycle.)\n\n#### 35.2-5\n\nSuppose that the vertices for an instance of the traveling-salesperson problem are points in the plane and that the cost \\(c(u,v)\\) is the euclidean distance between points \\(u\\) and \\(v\\). Show that an optimal tour never crosses itself.\n\n#### 35.2-6\n\nAdapt the proof of Theorem 35.3 to show that for any constant \\(c\\geq 0\\), there is no polynomial-time approximation algorithm with approximation ratio \\(\\left|V\\right|^{c}\\) for the general traveling-salesperson problem.\n\n### The set-covering problem\n\nThe set-covering problem is an optimization problem that models many problems that require resources to be allocated. Its corresponding decision problem generalizes the NP-complete vertex-cover problem and is therefore also NP-hard. The",
        "chapter": "Part VII Selected Topics",
        "section": "35 Approximation Algorithms",
        "subsection": "35.2 The traveling-salesperson problem",
        "subsubsection": "N/A"
    },
    {
        "content": "such a polynomial-time transformation does not contradict Theorem 35.3, assuming that \\(\\mathrm{P}\\neq\\mathrm{NP}\\).\n\n#### 35.2-3\n\nConsider the following _closest-point heuristic_ for building an approximate traveling-salesperson tour whose cost function satisfies the triangle inequality. Begin with a trivial cycle consisting of a single arbitrarily chosen vertex. At each step, identify the vertex \\(u\\) that is not on the cycle but whose distance to any vertex on the cycle is minimum. Suppose that the vertex on the cycle that is nearest \\(u\\) is vertex \\(v\\). Extend the cycle to include \\(u\\) by inserting \\(u\\) just after \\(v\\). Repeat until all vertices are on the cycle. Prove that this heuristic returns a tour whose total cost is not more than twice the cost of an optimal tour.\n\n#### 35.2-4\n\nA solution to the _bottleneck traveling-salesperson problem_ is the hamiltonian cycle that minimizes the cost of the most costly edge in the cycle. Assuming that the cost function satisfies the triangle inequality, show that there exists a polynomial-time approximation algorithm with approximation ratio 3 for this problem. (_Hint:_ Show recursively how to visit all the nodes in a bottleneck spanning tree, as discussed in Problem 21-4 on page 601, exactly once by taking a full walk of the tree and skipping nodes, but without skipping more than two consecutive intermediate nodes. Show that the costliest edge in a bottleneck spanning tree has a cost bounded from above by the cost of the costliest edge in a bottleneck hamiltonian cycle.)\n\n#### 35.2-5\n\nSuppose that the vertices for an instance of the traveling-salesperson problem are points in the plane and that the cost \\(c(u,v)\\) is the euclidean distance between points \\(u\\) and \\(v\\). Show that an optimal tour never crosses itself.\n\n#### 35.2-6\n\nAdapt the proof of Theorem 35.3 to show that for any constant \\(c\\geq 0\\), there is no polynomial-time approximation algorithm with approximation ratio \\(\\left|V\\right|^{c}\\) for the general traveling-salesperson problem.\n\n### The set-covering problem\n\nThe set-covering problem is an optimization problem that models many problems that require resources to be allocated. Its corresponding decision problem generalizes the NP-complete vertex-cover problem and is therefore also NP-hard. The approximation algorithm developed to handle the vertex-cover problem doesn't apply here, however. Instead, this section investigates a simple greedy heuristic with a logarithmic approximation ratio. That is, as the size of the instance gets larger, the size of the approximate solution may grow, relative to the size of an optimal solution. Because the logarithm function grows rather slowly, however, this approximation algorithm may nonetheless give useful results.\n\nAn instance \\((X,\\mathcal{F})\\) of the _set-covering problem_ consists of a finite set \\(X\\) and a family \\(\\mathcal{F}\\) of subsets of \\(X\\), such that every element of \\(X\\) belongs to at least one subset in \\(\\mathcal{F}\\):\n\n\\(X=\\bigcup_{S\\in\\mathcal{F}}S\\).\n\nWe say that a subfamily \\(\\mathcal{C}\\subseteq\\mathcal{F}\\)_covers_ a set of elements \\(U\\) if\n\n\\(U\\subseteq\\bigcup_{S\\in\\mathcal{C}}S\\).\n\nThe problem is to find a minimum-size subfamily \\(\\mathcal{C}\\subseteq\\mathcal{F}\\) whose members cover all of \\(X\\):\n\n\\(X=\\bigcup_{S\\in\\mathcal{C}}S\\).\n\nFigure 35.3 illustrates the set-covering problem. The size of \\(\\mathcal{C}\\) is the number of sets it contains, rather than the number of individual elements in these sets, since every subfamily \\(\\mathcal{C}\\) that covers \\(X\\) must contain all \\(|X|\\) individual elements. In Figure 35.3, the minimum set cover has size 3.\n\nThe set-covering problem abstracts many commonly arising combinatorial problems. As a simple example, suppose that \\(X\\) represents a set of skills that are needed to solve a problem and that you have a given set of people available to work on the problem. You wish to form a committee, containing as few people as possible, such that for every requisite skill in \\(X\\), at least one member of the committee has that skill. The decision version of the set-covering problem asks whether a covering exists with size at most \\(k\\), where \\(k\\) is an additional parameter specified in the problem instance. The decision version of the problem is NP-complete, as Exercise 35.3-2 asks you to show.\n\n### A greedy approximation algorithm\n\nThe greedy method in the procedure Greedy-Set-Cover on the facing page works by picking, at each stage, the set \\(S\\) that covers the greatest number of remaining elements that are uncovered. In the example of Figure 35.3, Greedy-Set-Cover adds to \\(\\mathcal{C}\\), in order, the sets \\(S_{1}\\), \\(S_{4}\\), and \\(S_{5}\\), followed by either \\(S_{3}\\) or \\(S_{6}\\).\n\n### The set-covering problem\n\nThe greedy algorithm works as follows. At the start of each iteration, \\(U_{i}\\) is a subset of \\(X\\) containing the remaining uncovered elements, with the initial subset \\(U_{0}\\) containing all the elements in \\(X\\). The set \\(\\mathcal{C}\\) contains the subfamily being constructed. Line 5 is the greedy decision-making step, choosing a subset \\(S\\) that covers as many uncovered elements as possible (breaking ties arbitrarily). After \\(S\\) is selected, line 6 updates the set of remaining uncovered elements, denoting it by \\(U_{i+1}\\), and line 7 places \\(S\\) into \\(\\mathcal{C}\\). When the algorithm terminates, \\(\\mathcal{C}\\) is a subfamily of \\(\\mathcal{F}\\) that covers \\(X\\).\n\n#### Analysis\n\nWe now show that the greedy algorithm returns a set cover that is not too much larger than an optimal set cover.\n\n**Theorem 35.4**: _The procedure Greedy-Set-Cover run on a set \\(X\\) and family of subsets \\({\\cal F}\\) is a polynomial-time \\(O(\\lg\\,X)\\)-approximation algorithm._\n\n_Proof_ Let's first show that the algorithm runs in time that is polynomial in \\(|X|\\) and \\(|{\\cal F}|\\). The number of iterations of the loop in lines 4-7 is bounded above by \\(\\min\\,\\{|X|\\,,|{\\cal F}|\\}=O(|X|+|{\\cal F}|)\\). The loop body can be implemented to run in \\(O(|X|\\cdot|{\\cal F}|)\\) time. Thus the algorithm runs in \\(O(|X|\\cdot|{\\cal F}|\\cdot(|X|+|{\\cal F}|))\\) time, which is polynomial in the input size. (Exercise 35.3-3 asks for a linear-time algorithm.)\n\nTo prove the approximation bound, let \\({\\cal C}^{*}\\) be an optimal set cover for the original instance (\\(X\\), \\({\\cal F}\\)), and let \\(k=|{\\cal C}^{*}|\\). Since \\({\\cal C}^{*}\\) is also a set cover of each subset \\(U_{i}\\) of \\(X\\) constructed by the algorithm, we know that any subset \\(U_{i}\\) constructed by the algorithm can be covered by \\(k\\) sets. Therefore, if \\((U_{i},{\\cal F})\\) is an instance of the set-covering problem, its optimal set cover has size at most \\(k\\).\n\nIf an optimal set cover for an instance \\((U_{i},{\\cal F})\\) has size at most \\(k\\), at least one of the sets in \\({\\cal C}\\) covers at least \\(|U_{i}|\\,/\\,k\\) new elements. Thus, line 5 of Greedy-Set-Cover, which chooses a set with the maximum number of uncovered elements, must choose a set in which the number of newly covered elements is at least \\(|U_{i}|\\,/\\,k\\). These elements are removed when constructing \\(U_{i\\,+1}\\), giving\n\n\\[|U_{i\\,+1}| \\leq |U_{i}|-|U_{i}|\\,/\\,k\\] (35.8) \\[= |U_{i}|\\,(1-1/k)\\.\\] Iterating inequality (35.8) gives \\[|U_{0}| = |X|\\,\\] \\[|U_{1}| \\leq |U_{0}|\\,(1-1/k)\\,\\] \\[|U_{2}| \\leq |U_{1}|\\,(1-1/k)=|U|\\,(1-1/k)^{2}\\,\\] and in general \\[|U_{i}|\\leq|U_{0}|\\,(1-1/k)^{i}\\,=|X|\\,(1-1/k)^{i}\\.\\] (35.9) The algorithm stops when \\(U_{i}=\\emptyset\\), which means that \\(|U_{i}|<1\\). Thus an upper bound on the number of iterations of the algorithm is the smallest value of \\(i\\) for which \\(|U_{i}|<1\\).\n\nSince \\(1+x\\leq e^{x}\\) for all real \\(x\\) (see inequality (3.14) on page 3.4), by letting \\(x=-1/k\\), we have \\(1-1/k\\leq e^{-1/k}\\), so that \\((1-1/k)^{k}\\leq(e^{-1/k})^{k}=1/e\\). Denoting the number \\(i\\) of iterations by \\(ck\\) for some nonnegative integer \\(c\\), we want \\(c\\) such that\n\n\\[|X|\\,(1-1/k)^{ck}\\leq|X|\\,e^{-c}\\,<1. \\tag{35.10}\\]\n\nMultiplying both sides by \\(e^{c}\\) and then taking the natural logarithm of both sides gives \\(c\\,\\geq\\,\\ln|X|\\), so we can choose for \\(c\\) any integer that is at least \\(\\ln|X|\\). Wechoose \\(c=\\lceil\\ln|X|\\rceil\\). Since \\(i=ck\\) is an upper bound on the number of iterations, which equals the size of \\(\\mathcal{C}\\), and \\(k=|\\mathcal{C}^{*}|\\), we have \\(|\\mathcal{C}|\\leq i=ck=c\\ |\\mathcal{C}^{*}|=|\\mathcal{C}^{*}|\\ |\\ln|X|\\rceil\\), and the theorem follows.\n\n#### Exercises\n\n_35.3-1_\n\nConsider each of the following words as a set of letters: \\(\\{\\mathtt{arid},\\mathtt{dash},\\mathtt{drain},\\) heard, \\(\\mathtt{lost},\\mathtt{nose},\\mathtt{shun},\\mathtt{slate},\\mathtt{snare}, \\mathtt{thread}\\}\\). Show which set cover Greedy-Set-Cover produces when you break ties in favor of the word that appears first in the dictionary.\n\n_35.3-2_\n\nShow that the decision version of the set-covering problem is NP-complete by reducing the vertex-cover problem to it.\n\n_35.3-3_\n\nShow how to implement Greedy-Set-Cover to run in \\(O\\Big{(}\\sum_{S\\in\\mathcal{F}}|S|\\Big{)}\\) time.\n\n_35.3-4_\n\nThe proof of Theorem 35.4 says that when Greedy-Set-Cover, run on the instance \\((X,\\mathcal{F})\\), returns the subfamily \\(\\mathcal{C}\\), then \\(|\\mathcal{C}|\\leq|\\mathcal{C}^{*}|\\ \\lceil\\ln X\\rceil\\). Show that the following weaker bound is trivially true:\n\n\\[|\\mathcal{C}|\\leq|\\mathcal{C}^{*}|\\max\\left\\{|S|:S\\in\\mathcal{F}\\right\\}\\.\\]\n\n_35.3-5_\n\nGreedy-Set-Cover can return a number of different solutions, depending on how it breaks ties in line 5. Give a procedure Bad-Set-Cover-Instance\\((n)\\) that returns an \\(n\\)-element instance of the set-covering problem for which, depending on how line 5 breaks ties, Greedy-Set-Cover can return a number of different solutions that is exponential in \\(n\\).\n\n### Randomization and linear programming\n\nThis section studies two useful techniques for designing approximation algorithms: randomization and linear programming. It starts with a simple randomized algorithm for an optimization version of 3-CNF satisfiability, and then it shows how to design an approximation algorithm for a weighted version of the vertex-cover problem based on linear programming. This section only scratches the surface of",
        "chapter": "Part VII Selected Topics",
        "section": "35 Approximation Algorithms",
        "subsection": "35.3 The set-covering problem",
        "subsubsection": "N/A"
    },
    {
        "content": "choose \\(c=\\lceil\\ln|X|\\rceil\\). Since \\(i=ck\\) is an upper bound on the number of iterations, which equals the size of \\(\\mathcal{C}\\), and \\(k=|\\mathcal{C}^{*}|\\), we have \\(|\\mathcal{C}|\\leq i=ck=c\\ |\\mathcal{C}^{*}|=|\\mathcal{C}^{*}|\\ |\\ln|X|\\rceil\\), and the theorem follows.\n\n#### Exercises\n\n_35.3-1_\n\nConsider each of the following words as a set of letters: \\(\\{\\mathtt{arid},\\mathtt{dash},\\mathtt{drain},\\) heard, \\(\\mathtt{lost},\\mathtt{nose},\\mathtt{shun},\\mathtt{slate},\\mathtt{snare}, \\mathtt{thread}\\}\\). Show which set cover Greedy-Set-Cover produces when you break ties in favor of the word that appears first in the dictionary.\n\n_35.3-2_\n\nShow that the decision version of the set-covering problem is NP-complete by reducing the vertex-cover problem to it.\n\n_35.3-3_\n\nShow how to implement Greedy-Set-Cover to run in \\(O\\Big{(}\\sum_{S\\in\\mathcal{F}}|S|\\Big{)}\\) time.\n\n_35.3-4_\n\nThe proof of Theorem 35.4 says that when Greedy-Set-Cover, run on the instance \\((X,\\mathcal{F})\\), returns the subfamily \\(\\mathcal{C}\\), then \\(|\\mathcal{C}|\\leq|\\mathcal{C}^{*}|\\ \\lceil\\ln X\\rceil\\). Show that the following weaker bound is trivially true:\n\n\\[|\\mathcal{C}|\\leq|\\mathcal{C}^{*}|\\max\\left\\{|S|:S\\in\\mathcal{F}\\right\\}\\.\\]\n\n_35.3-5_\n\nGreedy-Set-Cover can return a number of different solutions, depending on how it breaks ties in line 5. Give a procedure Bad-Set-Cover-Instance\\((n)\\) that returns an \\(n\\)-element instance of the set-covering problem for which, depending on how line 5 breaks ties, Greedy-Set-Cover can return a number of different solutions that is exponential in \\(n\\).\n\n### Randomization and linear programming\n\nThis section studies two useful techniques for designing approximation algorithms: randomization and linear programming. It starts with a simple randomized algorithm for an optimization version of 3-CNF satisfiability, and then it shows how to design an approximation algorithm for a weighted version of the vertex-cover problem based on linear programming. This section only scratches the surface of these two powerful techniques. The chapter notes give references for further study of these areas.\n\n### A randomized approximation algorithm for MAX-3-CNF satisfiability\n\nJust as some randomized algorithms compute exact solutions, some randomized algorithms compute approximate solutions. We say that a randomized algorithm for a problem has an _approximation ratio_ of \\(\\rho(n)\\) if, for any input of size \\(n\\), the _expected_ cost \\(C\\) of the solution produced by the randomized algorithm is within a factor of \\(\\rho(n)\\) of the cost \\(C^{*}\\) of an optimal solution:\n\n\\[\\max\\left\\{\\frac{C}{C^{*}},\\frac{C^{*}}{C}\\right\\}\\leq\\rho(n) \\tag{35.11}\\]\n\nWe call a randomized algorithm that achieves an approximation ratio of \\(\\rho(n)\\) a _randomized \\(\\rho(n)\\)-approximation algorithm_. In other words, a randomized approximation algorithm is like a deterministic approximation algorithm, except that the approximation ratio is for an expected cost.\n\nA particular instance of 3-CNF satisfiability, as defined in Section 34.4, may or may not be satisfiable. In order to be satisfiable, there must exist an assignment of the variables so that every clause evaluates to 1. If an instance is not satisfiable, you might instead want to know how \"close\" to satisfiable it is, that is, find an assignment of the variables that satisfies as many clauses as possible. We call the resulting maximization problem _MAX-3-CNF satisfiability_. The input to MAX-3-CNF satisfiability is the same as for 3-CNF satisfiability, and the goal is to return an assignment of the variables that maximizes the number of clauses evaluating to 1. You might be surprised that randomly setting each variable to 1 with probability \\(1/2\\) and to 0 with probability \\(1/2\\) yields a randomized \\(8/7\\)-approximation algorithm, but we're about to see why. Recall that the definition of 3-CNF satisfiability from Section 34.4 requires each clause to consist of exactly three distinct literals. We now further assume that no clause contains both a variable and its negation. Exercise 35.4-1 asks you to remove this last assumption.\n\n**Theorem 35.5**: _Given an instance of MAX-3-CNF satisfiability with \\(n\\) variables \\(x_{1},x_{2},\\ldots,x_{n}\\) and \\(m\\) clauses, the randomized algorithm that independently sets each variable to 1 with probability \\(1/2\\) and to 0 with probability \\(1/2\\) is a randomized \\(8/7\\)-approximation algorithm._\n\n_Proof_ Suppose that each variable is independently set to 1 with probability \\(1/2\\) and to 0 with probability \\(1/2\\). Define, for \\(i=1,2,\\ldots,m\\), the indicator random variable \\(Y_{i}=\\mathrm{I}\\left\\{\\text{clause $i$ is satisfied}\\right\\}\\,\\)\n\nso that \\(Y_{i}=1\\) as long as at least one of the literals in the \\(i\\)th clause is set to 1. Since no literal appears more than once in the same clause, and since we assume that no variable and its negation appear in the same clause, the settings of the three literals in each clause are independent. A clause is not satisfied only if all three of its literals are set to 0, and so \\(\\Pr\\left\\{\\text{clause $i$ is not satisfied}\\right\\}=(1/2)^{3}=1/8\\). Thus, we have \\(\\Pr\\left\\{\\text{clause $i$ is satisfied}\\right\\}=1-1/8=7/8\\), and Lemma 5.1 on page 130 gives \\(\\mathrm{E}\\left[Y_{i}\\right]=7/8\\). Let \\(Y\\) be the number of satisfied clauses overall, so that \\(Y=Y_{1}+Y_{2}+\\cdots+Y_{m}\\). Then, we have\n\n\\[\\mathrm{E}\\left[Y\\right] = \\mathrm{E}\\left[\\sum_{i=1}^{m}Y_{i}\\right]\\] \\[= \\sum_{i=1}^{m}\\mathrm{E}\\left[Y_{i}\\right]\\qquad\\text{(by linearity of expectation)}\\] \\[= \\sum_{i=1}^{m}7/8\\] \\[= 7m/8\\.\\]\n\nSince \\(m\\) is an upper bound on the number of satisfied clauses, the approximation ratio is at most \\(m/(7m/8)=8/7\\).\n\n#### Approximating weighted vertex cover using linear programming\n\nThe _minimum-weight vertex-cover problem_ takes as input an undirected graph \\(G=(V,E)\\) in which each vertex \\(v\\in V\\) has an associated positive weight \\(w(v)\\). The weight \\(w(V^{\\prime})\\) of a vertex cover \\(V^{\\prime}\\subseteq V\\) is the sum of the weights of its vertices: \\(w(V^{\\prime})=\\sum_{v\\in V^{\\prime}}w(v)\\). The goal is to find a vertex cover of minimum weight.\n\nThe approximation algorithm for unweighted vertex cover from Section 35.1 won't work here, because the solution it returns could be far from optimal for the weighted problem. Instead, we'll first compute a lower bound on the weight of the minimum-weight vertex cover, by using a linear program. Then we'll \"round\" this solution and use it to obtain a vertex cover.\n\nStart by associating a variable \\(x(v)\\) with each vertex \\(v\\in V\\), and require that \\(x(v)\\) equals either 0 or 1 for each \\(v\\in V\\). The vertex cover includes \\(v\\) if and only if \\(x(v)=1\\). Then the constraint that for any edge \\((u,v)\\), at least one of \\(u\\) and \\(v\\) must belong to the vertex cover can be expressed as \\(x(u)+x(v)\\geq 1\\). This view gives rise to the following _0-1 integer program_ for finding a minimum-weight vertex cover:minimize \\[\\sum_{v\\in V}w(v)\\;x(v)\\] (35.12) subject to \\[x(u)+x(v) \\geq 1\\qquad\\text{ for each }(u,v)\\in E\\] (35.13) \\[x(v) \\in \\{0,1\\}\\;\\text{ for each }v\\in V\\;.\\] (35.14)\n\nIn the special case in which all the weights \\(w(v)\\) equal 1, this formulation is the optimization version of the NP-hard vertex-cover problem. Let's remove the constraint that \\(x(v)\\in\\{0,1\\}\\) and replace it by \\(0\\leq x(v)\\leq 1\\), resulting in the following linear program:\n\nminimize \\[\\sum_{v\\in V}w(v)\\;x(v)\\] (35.15) subject to \\[x(u)+x(v) \\geq 1\\;\\text{ for each }(u,v)\\in E\\] (35.16) \\[x(v) \\leq 1\\;\\text{ for each }v\\in V\\] (35.17) \\[x(v) \\geq 0\\;\\text{ for each }v\\in V\\;.\\] (35.18)\n\nWe refer to this linear program as the _linear-programming relaxation_. Any feasible solution to the 0-1 integer program in lines (35.12)-(35.14) is also a feasible solution to its linear-programming relaxation in lines (35.15)-(35.18). Therefore, the value of an optimal solution to the linear-programming relaxation provides a lower bound on the value of an optimal solution to the 0-1 integer program, and hence a lower bound on the optimal weight in the minimum-weight vertex-cover problem.\n\nThe procedure Approx-Min-Weight-VC on the facing page starts with a solution to the linear-programming relaxation and uses it to construct an approximate solution to the minimum-weight vertex-cover problem. The procedure works as follows. Line 1 initializes the vertex cover to be empty. Line 2 formulates the linear-programming relaxation in lines (35.15)-(35.18) and then solves this linear program. An optimal solution gives each vertex \\(v\\) an associated value \\(\\tilde{x}(v)\\), where \\(0\\leq\\tilde{x}(v)\\leq 1\\). The procedure uses this value to guide the choice of which vertices to add to the vertex cover \\(C\\) in lines 3-5: the vertex cover \\(C\\) includes vertex \\(v\\) if and only if \\(\\tilde{x}(v)\\geq 1/2\\). In effect, the procedure \"rounds\" each fractional variable in the solution to the linear-programming relaxation to either 0 or 1 in order to obtain a solution to the 0-1 integer program in lines (35.12)-(35.14). Finally, line 6 returns the vertex cover \\(C\\).\n\n_Theorem 35.6_: Algorithm Approx-Min-Weight-VC is a polynomial-time2-approximation algorithm for the minimum-weight vertex-cover problem.\n\n#### 35.4 Randomization and linear programming\n\nApprox-Min-Weight-VC (\\(G\\), \\(w\\))\n\n\\(C\\ =\\ \\emptyset\\)\n\ncompute \\(\\tilde{x}\\), an optimal solution to the linear-programming relaxation\n\nin lines (35.15)-(35.18)\n\n**for** each vertex \\(v\\in V\\)\n\n**if**\\(\\tilde{x}(v)\\geq 1/2\\)\n\n\\(C\\ =\\ C\\ \\cup\\ \\{v\\}\\)\n\n**return**\\(C\\)\n\n_Proof_ Because there is a polynomial-time algorithm to solve the linear program in line 2, and because the **for** loop of lines 3-5 runs in polynomial time, Approx-Min-Weight-VC is a polynomial-time algorithm.\n\nIt remains to show that Approx-Min-Weight-VC is a2-approximation algorithm. Let \\(C^{*}\\) be an optimal solution to the minimum-weight vertex-cover problem, and let \\(z^{*}\\) be the value of an optimal solution to the linear-programming relaxation in lines (35.15)-(35.18). Since an optimal vertex cover is a feasible solution to the linear-programming relaxation, \\(z^{*}\\) must be a lower bound on \\(w(C^{*})\\), that is, \\(z^{*}\\leq w(C^{*})\\).\n\nNext, we claim that rounding the fractional values of the variables \\(\\tilde{x}(v)\\) in lines 3-5 produces a set \\(C\\) that is a vertex cover and satisfies \\(w(C)\\leq 2z^{*}\\). To see that \\(C\\) is a vertex cover, consider any edge \\((u,v)\\in E\\). By constraint (35.16), we know that \\(x(u)+x(v)\\geq 1\\), which implies that at least one of \\(\\tilde{x}(u)\\) and \\(\\tilde{x}(v)\\) is at least \\(1/2\\). Therefore, at least one of \\(u\\) and \\(v\\) is included in the vertex cover, and so every edge is covered.\n\nNow we consider the weight of the cover. We have\n\n\\[z^{*} =\\ \\sum_{v\\in V}w(v)\\ \\tilde{x}(v)\\] \\[\\geq\\ \\sum_{v\\in V:\\,\\tilde{x}(v)\\geq\\,1/2}\\!\\!\\!\\!\\!\\!\\!\\!w(v)\\ \\tilde{x}(v)\\] \\[\\geq\\ \\sum_{v\\in V:\\,\\tilde{x}(v)\\geq\\,1/2}\\!\\!\\!\\!\\!\\!\\!\\!\\!w(v) \\cdot\\frac{1}{2}\\] \\[=\\ \\sum_{v\\in C}w(v)\\cdot\\frac{1}{2}\\] \\[=\\ \\frac{1}{2}\\sum_{v\\in C}w(v)\\] \\[=\\ \\frac{1}{2}w(C). \\tag{35.20}\\]Combining inequalities (35.19) and (35.20) gives\n\n\\[w(C)\\leq 2z^{*}\\leq 2w(C^{*})\\,\\]\n\nand hence Approx-Min-Weight-VC is a2-approximation algorithm.\n\n### Exercises\n\n#### 35.4-1\n\nShow that even if a clause is allowed to contain both a variable and its negation, randomly setting each variable to 1 with probability \\(1/2\\) and to 0 with probability \\(1/2\\) still yields a randomized \\(8/7\\)-approximation algorithm.\n\n#### 35.4-2\n\nThe _MAX-CNF satisfiability problem_ is like the MAX-3-CNF satisfiability problem, except that it does not restrict each clause to have exactly three literals. Give a randomized 2-approximation algorithm for the MAX-CNF satisfiability problem.\n\n#### 35.4-3\n\nIn the MAX-CUT problem, the input is an unweighted undirected graph \\(G=(V,E)\\). We define a cut \\((S,V-S)\\) as in Chapter 21 and the _weight_ of a cut as the number of edges crossing the cut. The goal is to find a cut of maximum weight. Suppose that each vertex \\(v\\) is randomly and independently placed into \\(S\\) with probability \\(1/2\\) and into \\(V-S\\) with probability \\(1/2\\). Show that this algorithm is a randomized 2-approximation algorithm.\n\n#### 35.4-4\n\nShow that the constraints in line (35.17) are redundant in the sense that removing them from the linear-programming relaxation in lines (35.15)-(35.18) yields a linear program for which any optimal solution \\(x\\) must satisfy \\(x(v)\\leq 1\\) for each \\(v\\in V\\).\n\n### The subset-sum problem\n\nRecall from Section 34.5.5 that an instance of the subset-sum problem is given by a pair \\((S,t)\\), where \\(S\\) is a set \\(\\{x_{1},x_{2},\\ldots,x_{n}\\}\\) of positive integers and \\(t\\) is a positive integer. This decision problem asks whether there exists a subset of \\(S\\) that adds up exactly to the target value \\(t\\). As we saw in Section 34.5.5, this problem is NP-complete.\n\nThe optimization problem associated with this decision problem arises in practical applications. The optimization problem seeks a subset of",
        "chapter": "Part VII Selected Topics",
        "section": "35 Approximation Algorithms",
        "subsection": "35.4 Randomization and linear programming",
        "subsubsection": "N/A"
    },
    {
        "content": "Combining inequalities (35.19) and (35.20) gives\n\n\\[w(C)\\leq 2z^{*}\\leq 2w(C^{*})\\,\\]\n\nand hence Approx-Min-Weight-VC is a2-approximation algorithm.\n\n### Exercises\n\n#### 35.4-1\n\nShow that even if a clause is allowed to contain both a variable and its negation, randomly setting each variable to 1 with probability \\(1/2\\) and to 0 with probability \\(1/2\\) still yields a randomized \\(8/7\\)-approximation algorithm.\n\n#### 35.4-2\n\nThe _MAX-CNF satisfiability problem_ is like the MAX-3-CNF satisfiability problem, except that it does not restrict each clause to have exactly three literals. Give a randomized 2-approximation algorithm for the MAX-CNF satisfiability problem.\n\n#### 35.4-3\n\nIn the MAX-CUT problem, the input is an unweighted undirected graph \\(G=(V,E)\\). We define a cut \\((S,V-S)\\) as in Chapter 21 and the _weight_ of a cut as the number of edges crossing the cut. The goal is to find a cut of maximum weight. Suppose that each vertex \\(v\\) is randomly and independently placed into \\(S\\) with probability \\(1/2\\) and into \\(V-S\\) with probability \\(1/2\\). Show that this algorithm is a randomized 2-approximation algorithm.\n\n#### 35.4-4\n\nShow that the constraints in line (35.17) are redundant in the sense that removing them from the linear-programming relaxation in lines (35.15)-(35.18) yields a linear program for which any optimal solution \\(x\\) must satisfy \\(x(v)\\leq 1\\) for each \\(v\\in V\\).\n\n### The subset-sum problem\n\nRecall from Section 34.5.5 that an instance of the subset-sum problem is given by a pair \\((S,t)\\), where \\(S\\) is a set \\(\\{x_{1},x_{2},\\ldots,x_{n}\\}\\) of positive integers and \\(t\\) is a positive integer. This decision problem asks whether there exists a subset of \\(S\\) that adds up exactly to the target value \\(t\\). As we saw in Section 34.5.5, this problem is NP-complete.\n\nThe optimization problem associated with this decision problem arises in practical applications. The optimization problem seeks a subset of whose sum is as large as possible but not larger than \\(t\\). For example, consider a truck that can carry no more than \\(t\\) pounds, which is to be loaded with up to \\(n\\) different boxes, the \\(i\\)th of which weighs \\(x_{i}\\) pounds. How heavy a load can the truck take without exceeding the \\(t\\)-pound weight limit?\n\nWe start this section with an exponential-time algorithm to compute the optimal value for this optimization problem. Then we show how to modify the algorithm so that it becomes a fully polynomial-time approximation scheme. (Recall that a fully polynomial-time approximation scheme has a running time that is polynomial in \\(1/\\epsilon\\) as well as in the size of the input.)\n\n##### An exponential-time exact algorithm\n\nSuppose that you compute, for each subset \\(S^{\\prime}\\) of \\(S\\), the sum of the elements in \\(S^{\\prime}\\), and then you select, among the subsets whose sum does not exceed \\(t\\), the one whose sum is closest to \\(t\\). This algorithm returns the optimal solution, but it might take exponential time. To implement this algorithm, you can use an iterative procedure that, in iteration \\(i\\), computes the sums of all subsets of \\(\\{x_{1},x_{2},\\ldots,x_{i}\\}\\), using as a starting point the sums of all subsets of \\(\\{x_{1},x_{2},\\ldots,x_{i-1}\\}\\). In doing so, you would realize that once a particular subset \\(S^{\\prime}\\) has a sum exceeding \\(t\\), there is no reason to maintain it, since no superset of \\(S^{\\prime}\\) can be an optimal solution. Let's see how to implement this strategy.\n\nThe procedure Exact-Subset-Sum takes an input set \\(S=\\{x_{1},x_{2},\\ldots,x_{n}\\}\\), the size \\(n=|S|\\), and a target value \\(t\\). This procedure iteratively computes \\(L_{i}\\), the list of sums of all subsets of \\(\\{x_{1},\\ldots,x_{i}\\}\\) that do not exceed \\(t\\), and then it returns the maximum value in \\(L_{n}\\).\n\nIf \\(L\\) is a list of positive integers and \\(x\\) is another positive integer, then let \\(L+x\\) denote the list of integers derived from \\(L\\) by increasing each element of \\(L\\) by \\(x\\). For example, if \\(L=\\langle 1,\\,2,\\,3,\\,5,\\,9\\rangle\\), then \\(L+2=\\langle 3,\\,4,\\,5,\\,7,\\,11\\rangle\\). This notation extends to sets, so that\n\n\\(S+x=\\{s+x:s\\in S\\}\\).\n\nExact-Subset-Sum(\\(S,n,t\\))\n\n```\n1\\(L_{0}=\\langle 0\\rangle\\)\n2for\\(i=1\\)to\\(n\\)\n3\\(L_{j}=\\)Merge-Lists(\\(L_{i-1},L_{i-1}+x_{i}\\))\n4 remove from \\(L_{i}\\) every element that is greater than \\(t\\)\n5return the largest element in \\(L_{n}\\)\n```\n\nExact-Subset-Sum invokes an auxiliary procedure Merge-Lists(\\(L,L^{\\prime}\\)), which returns the sorted list that is the merge of its two sorted input lists \\(L\\) and \\(L^{\\prime}\\)with duplicate values removed. Like the Merge procedure we used in merge sort on page 36, Merge-Lists runs in \\({\\cal O}(|L|+|L^{\\prime}|)\\) time. We omit the pseudocode for Merge-Lists.\n\nTo see how Exact-Subset-Sum works, let \\(P_{i}\\) denote the set of values obtained by selecting each (possibly empty) subset of \\(\\{x_{1},x_{2},\\ldots,x_{i}\\}\\) and summing its members. For example, if \\(S=\\{1,4,5\\}\\), then\n\n\\[P_{1} = \\{0,1\\}\\enspace,\\] \\[P_{2} = \\{0,1,4,5\\}\\enspace,\\] \\[P_{3} = \\{0,1,4,5,6,9,10\\}\\enspace.\\] Given the identity \\[P_{i} = P_{i-1}\\cup(P_{i-1}+x_{i})\\enspace,\\] (35.21) you can prove by induction on \\(i\\) (see Exercise 35.5-1) that the list \\(L_{i}\\) is a sorted list containing every element of \\(P_{i}\\) whose value is not more than \\(t\\). Since the length of \\(L_{i}\\) can be as much as \\(2^{i}\\), Exact-Subset-Sum is an exponential-time algorithm in general, although it is a polynomial-time algorithm in the special cases in which \\(t\\) is polynomial in \\(|S|\\) or all the numbers in \\(S\\) are bounded by a polynomial in \\(|S|\\).\n\n##### A fully polynomial-time approximation scheme\n\nThe key to devising a fully polynomial-time approximation scheme for the subset-sum problem is to \"trim\" each list \\(L_{i}\\) after it is created. Here's the idea behind trimming: if two values in \\(L\\) are close to each other, then since the goal is just an approximate solution, there is no need to maintain both of them explicitly. More precisely, use a trimming parameter \\(\\delta\\) such that \\(0<\\delta<1\\). When _trimming_ a list \\(L\\) by \\(\\delta\\), remove as many elements from \\(L\\) as possible, in such a way that if \\(L^{\\prime}\\) is the result of trimming \\(L\\), then for every element \\(y\\) that was removed from \\(L\\), some element \\(z\\) still in \\(L^{\\prime}\\) approximates \\(y\\). For \\(z\\) to approximate \\(y\\), it must be no greater than \\(y\\) and also within a factor of \\(1+\\delta\\) of \\(y\\), so that\n\n\\[\\frac{y}{1+\\delta}\\leq z\\leq y\\enspace. \\tag{35.22}\\]\n\nYou can think of such a \\(z\\) as \"representing\" \\(y\\) in the new list \\(L^{\\prime}\\). Each removed element \\(y\\) is represented by a remaining element \\(z\\) satisfying inequality (35.22). For example, suppose that \\(\\delta=0.1\\) and\n\n\\[L=\\langle 10,11,12,15,20,21,22,23,24,29\\rangle\\enspace.\\] Then trimming \\(L\\) results in\n\n\\[L^{\\prime}=\\langle 10,12,15,20,23,29\\rangle\\enspace,\\]where the deleted value 11 is represented by 10, the deleted values 21 and 22 are represented by 20, and the deleted value 24 is represented by 23. Because every element of the trimmed version of the list is also an element of the original version of the list, trimming can dramatically decrease the number of elements kept while keeping a close (and slightly smaller) representative value in the list for each deleted element.\n\nThe procedure Trim trims list \\(L=\\langle y_{1},y_{2},\\ldots,y_{m}\\rangle\\) in \\(\\Theta(m)\\) time, given \\(L\\) and the trimming parameter \\(\\delta\\). It assumes that \\(L\\) is sorted into monotonically increasing order. The output of the procedure is a trimmed, sorted list. The procedure scans the elements of \\(L\\) in monotonically increasing order. A number is appended onto the returned list \\(L^{\\prime}\\) only if it is the first element of \\(L\\) or if it cannot be represented by the most recent number placed into \\(L^{\\prime}\\).\n\n```\nTrim(\\(L,\\delta\\))\n1 let \\(m\\) be the length of \\(L\\)\n2\\(L^{\\prime}=\\langle y_{1}\\rangle\\)\n3\\(last=y_{1}\\)\n4for\\(i=2\\)to\\(m\\)\n5if\\(y_{i}>last\\cdot(1+\\delta)\\)//\\(y_{i}\\geq last\\) because \\(L\\) is sorted\n6 append \\(y_{i}\\) onto the end of \\(L^{\\prime}\\)\n7\\(last=y_{i}\\)\n8return\\(L^{\\prime}\\)\n```\n\nGiven the procedure Trim, the procedure Approx-Subset-Sum on the following page implements the approximation scheme. This procedure takes as input a set \\(S=\\{x_{1},x_{2},\\ldots,x_{n}\\}\\) of \\(n\\) integers (in arbitrary order), the size \\(n=|S|\\), the target integer \\(t\\), and an approximation parameter \\(\\epsilon\\), where\n\n\\[0<\\epsilon<1. \\tag{35.23}\\]\n\nIt returns a value \\(z^{*}\\) whose value is within a factor of \\(1+\\epsilon\\) of the optimal solution.\n\nThe Approx-Subset-Sum procedure works as follows. Line 1 initializes the list \\(L_{0}\\) to be the list containing just the element 0. The **for** loop in lines 2-5 computes \\(L_{i}\\) as a sorted list containing a suitably trimmed version of the set \\(P_{i}\\), with all elements larger than \\(t\\) removed. Since the procedure creates \\(L_{i}\\) from \\(L_{i-1}\\), it must ensure that the repeated trimming doesn't introduce too much compounded inaccuracy. That's why instead of the trimming parameter being \\(\\epsilon\\) in the call to Trim, it has the smaller value \\(\\epsilon/2n\\). We'll soon see that Approx-Subset-Sum returns a correct approximation if one exists.\n\n\\(\\Box\\)\n\nAs an example, suppose that Approx-Subset-Sum is given\n\n\\(S=\\langle 104,102,201,101\\rangle\\)\n\nwith \\(t=308\\) and \\(\\epsilon=0.40\\). The trimming parameter \\(\\delta\\) is \\(\\epsilon/2n=0.40/8=0.05\\). The procedure computes the following values on the indicated lines:\n\n[MISSING_PAGE_POST]\n\nThe procedure returns \\(z^{*}=302\\) as its answer, which is well within \\(\\epsilon=40\\%\\) of the optimal answer \\(307=104+102+101\\). In fact, it is within \\(2\\%\\).\n\n**Theorem 35.7**: Approx-Subset-Sum _is a fully polynomial-time approximation scheme for the subset-sum problem.__Proof_ The operations of trimming \\(L_{i}\\) in line 4 and removing from \\(L_{i}\\) every element that is greater than \\(t\\) maintain the property that every element of \\(L_{i}\\) is also a member of \\(P_{i}\\). Therefore, the value \\(z^{*}\\) returned in line 7 is indeed the sum of some subset of \\(S\\), that is, \\(z^{*}\\in P_{n}\\). Let \\(y^{*}\\in P_{n}\\) denote an optimal solution to the subset-sum problem, so that it is the greatest value in \\(P_{n}\\) that is less than or equal to \\(t\\). Because line 5 ensures that \\(z^{*}\\leq t\\), we know that \\(z^{*}\\leq y^{*}\\). By inequality (35.1), we need to show that \\(y^{*}/z^{*}\\leq 1+\\epsilon\\). We must also show that the running time of this algorithm is polynomial in both \\(1/\\epsilon\\) and the size of the input.\n\nAs Exercise 35.5-2 asks you to show, for every element \\(y\\) in \\(P_{i}\\) that is at most \\(t\\), there exists an element \\(z\\in L_{i}\\) such that\n\n\\[\\frac{y}{(1+\\epsilon/2n)^{i}}\\leq z\\leq y. \\tag{35.24}\\]\n\nInequality (35.24) must hold for \\(y^{*}\\in P_{n}\\), and therefore there exists an element \\(z\\in L_{n}\\) such that\n\n\\[\\frac{y^{*}}{(1+\\epsilon/2n)^{n}}\\leq z\\leq y^{*}\\,\\]\n\nand thus\n\n\\[\\frac{y^{*}}{z}\\leq\\left(1+\\frac{\\epsilon}{2n}\\right)^{n}. \\tag{35.25}\\]\n\nSince there exists an element \\(z\\in L_{n}\\) fulfilling inequality (35.25), the inequality must hold for \\(z^{*}\\), which is the largest value in \\(L_{n}\\), which is to say\n\n\\[\\frac{y^{*}}{z^{*}}\\leq\\left(1+\\frac{\\epsilon}{2n}\\right)^{n}. \\tag{35.26}\\]\n\nNow we show that \\(y^{*}/z^{*}\\leq 1+\\epsilon\\). We do so by showing that \\((1+\\epsilon/2n)^{n}\\leq 1+\\epsilon\\). First, inequality (35.23), \\(0<\\epsilon<1\\), implies that\n\n\\[(\\epsilon/2)^{2}\\leq\\epsilon/2 \\tag{35.27}\\]\n\nNext, from equation (3.16) on page 66, we have \\(\\lim_{n\\to\\infty}(1+\\epsilon/2n)^{n}=e^{\\epsilon/2}\\). Exercise 35.5-3 asks you to show that\n\n\\[\\frac{d}{dn}\\left(1+\\frac{\\epsilon}{2n}\\right)^{n}>0. \\tag{35.28}\\]\n\nTherefore, the function \\((1+\\epsilon/2n)^{n}\\) increases with \\(n\\) as it approaches its limit of \\(e^{\\epsilon/2}\\), and we have\n\n\\[\\left(1+\\frac{\\epsilon}{2n}\\right)^{n} \\leq e^{\\epsilon/2}\\] (35.29) \\[\\leq 1+\\epsilon/2+(\\epsilon/2)^{2}\\] (by inequality (3.15) on page 66) \\[\\leq 1+\\epsilon\\] (by inequality (35.27)). (35.29)Combining inequalities (35.26) and (35.29) completes the analysis of the approximation ratio.\n\nTo show that Approx-Subset-Sum is a fully polynomial-time approximation scheme, we derive a bound on the length of. After trimming, successive elements and of must have the relationship. That is, they must differ by a factor of at least. Each list, therefore, contains the value, possibly the value, and up to additional values. The number of elements in each list is at most\n\nThis bound is polynomial in the size of the input -- which is the number of bits, needed to represent plus the number of bits needed to represent the set, which in turn is polynomial in -- and in. Since the running time of Approx-Subset-Sum is polynomial in the lengths of the lists, we conclude that Approx-Subset-Sum is a fully polynomial-time approximation scheme.\n\n##### Exercises\n\nProve equation (35.21). Then show that after executing line 4 of Exact-Subset-Sum,  is a sorted list containing every element of whose value is not more than.\n\nUsing induction on, prove inequality (35.24).\n\nProve inequality (35.28).\n\nHow can you modify the approximation scheme presented in this section to find a good approximation to the smallest value not less than that is a sum of some subset of the given input list?\n\nModify the Approx-Subset-Sum procedure to also return the subset of that sums to the value.\n\n## Problems\n\n### 35-1 Bin packing\n\nYou are given a set of \\(n\\) objects, where the size \\(s_{i}\\) of the \\(i\\)th object satisfies \\(0<s_{i}<1\\). Your goal is to pack all the objects into the minimum number of unit-size bins. Each bin can hold any subset of the objects whose total size does not exceed 1.\n\n**a.**: Prove that the problem of determining the minimum number of bins required is NP-hard. (_Hint:_ Reduce from the subset-sum problem.)\n\nThe _first-fit_ heuristic takes each object in turn and places it into the first bin that can accommodate it, as follows. It maintains an ordered list of bins. Let \\(b\\) denote the number of bins in the list, where \\(b\\) increases over the course of the algorithm, and let \\(\\langle B_{1},\\,\\ldots,\\,B_{b}\\rangle\\) be the list of bins. Initially \\(b=0\\) and the list is empty. The algorithm takes each object \\(i\\) in turn and places it in the lowest-numbered bin that can still accommodate it. If no bin can accommodate object \\(i\\), then \\(b\\) is incremented and a new bin \\(B_{b}\\) is opened, containing object \\(i\\). Let \\(S=\\sum_{i=1}^{n}s_{i}\\).\n**b.**: Argue that the optimal number of bins required is at least \\(\\lceil S\\rceil\\).\n**c.**: Argue that the first-fit heuristic leaves at most one bin at most half full.\n**d.**: Prove that the number of bins used by the first-fit heuristic never exceeds \\(\\lceil 2S\\rceil\\).\n**e.**: Prove an approximation ratio of 2 for the first-fit heuristic.\n**f.**: Give an efficient implementation of the first-fit heuristic, and analyze its running time.\n\n### 35-2 Approximating the size of a maximum clique\n\nLet \\(G=(V,E)\\) be an undirected graph. For any \\(k\\geq 1\\), define \\(G^{(k)}\\) to be the undirected graph \\((V^{(k)},E^{(k)})\\), where \\(V^{(k)}\\) is the set of all ordered \\(k\\)-tuples of vertices from \\(V\\) and \\(E^{(k)}\\) is defined so that \\((v_{1},v_{2},\\ldots,v_{k})\\) is adjacent to \\((w_{1},w_{2},\\ldots,w_{k})\\) if and only if for \\(i=1,2,\\ldots,k\\), either vertex \\(v_{i}\\) is adjacent to \\(w_{i}\\) in \\(G\\), or else \\(v_{i}=w_{i}\\).\n**a.**: Prove that the size of the maximum clique in \\(G^{(k)}\\) is equal to the \\(k\\)th power of the size of the maximum clique in \\(G\\).\n**b.**: Argue that if there is an approximation algorithm that has a constant approximation ratio for finding a maximum-size clique, then there is a polynomial-time approximation scheme for the problem.",
        "chapter": "Part VII Selected Topics",
        "section": "35 Approximation Algorithms",
        "subsection": "35.5 The subset-sum problem",
        "subsubsection": "N/A"
    },
    {
        "content": "## Problems\n\n### 35-1 Bin packing\n\nYou are given a set of \\(n\\) objects, where the size \\(s_{i}\\) of the \\(i\\)th object satisfies \\(0<s_{i}<1\\). Your goal is to pack all the objects into the minimum number of unit-size bins. Each bin can hold any subset of the objects whose total size does not exceed 1.\n\n**a.** Prove that the problem of determining the minimum number of bins required is NP-hard. (_Hint:_ Reduce from the subset-sum problem.)\n\nThe _first-fit_ heuristic takes each object in turn and places it into the first bin that can accommodate it, as follows. It maintains an ordered list of bins. Let \\(b\\) denote the number of bins in the list, where \\(b\\) increases over the course of the algorithm, and let \\(\\langle B_{1},\\,\\ldots,\\,B_{b}\\rangle\\) be the list of bins. Initially \\(b=0\\) and the list is empty. The algorithm takes each object \\(i\\) in turn and places it in the lowest-numbered bin that can still accommodate it. If no bin can accommodate object \\(i\\), then \\(b\\) is incremented and a new bin \\(B_{b}\\) is opened, containing object \\(i\\). Let \\(S=\\sum_{i=1}^{n}s_{i}\\).\n\n**b.** Argue that the optimal number of bins required is at least \\(\\lceil S\\rceil\\).\n\n**c.** Argue that the first-fit heuristic leaves at most one bin at most half full.\n\n**d.** Prove that the number of bins used by the first-fit heuristic never exceeds \\(\\lceil 2S\\rceil\\).\n\n**e.** Prove an approximation ratio of 2 for the first-fit heuristic.\n\n**f.** Give an efficient implementation of the first-fit heuristic, and analyze its running time.\n\n### 35-2 Approximating the size of a maximum clique\n\nLet \\(G=(V,E)\\) be an undirected graph. For any \\(k\\geq 1\\), define \\(G^{(k)}\\) to be the undirected graph \\((V^{(k)},E^{(k)})\\), where \\(V^{(k)}\\) is the set of all ordered \\(k\\)-tuples of vertices from \\(V\\) and \\(E^{(k)}\\) is defined so that \\((v_{1},v_{2},\\ldots,v_{k})\\) is adjacent to \\((w_{1},w_{2},\\ldots,w_{k})\\) if and only if for \\(i=1,2,\\ldots,k\\), either vertex \\(v_{i}\\) is adjacent to \\(w_{i}\\) in \\(G\\), or else \\(v_{i}=w_{i}\\).\n\n**a.** Prove that the size of the maximum clique in \\(G^{(k)}\\) is equal to the \\(k\\)th power of the size of the maximum clique in \\(G\\).\n\n**b.** Argue that if there is an approximation algorithm that has a constant approximation ratio for finding a maximum-size clique, then there is a polynomial-time approximation scheme for the problem.\n\n_35-3 Weighted set-covering problem_\n\nSuppose that sets have weights in the set-covering problem, so that each set \\(S_{i}\\) in the family \\(\\mathcal{F}\\) has an associated weight \\(w_{i}\\). The weight of a cover \\(\\mathcal{C}\\) is \\(\\sum_{S_{i}\\in\\mathcal{C}}w_{i}\\). The goal is wish to determine a minimum-weight cover. (Section 35.3 handles the case in which \\(w_{i}=1\\) for all \\(i\\).)\n\nShow how to generalize the greedy set-covering heuristic in a natural manner to provide an approximate solution for any instance of the weighted set-covering problem. Letting \\(d\\) be the maximum size of any set \\(S_{i}\\), show that your heuristic has an approximation ratio of \\(H(d)=\\sum_{i=1}^{d}1/i\\).\n\n_35-4 Maximum matching_\n\nRecall that for an undirected graph \\(G\\), a matching is a set of edges such that no two edges in the set are incident on the same vertex. Section 25.1 showed how to find a maximum matching in a bipartite graph, that is, a matching such that no other matching in \\(G\\) contains more edges. This problem examines matchings in undirected graphs that are not required to be bipartite.\n\n_a._: Show that a maximal matching need not be a maximum matching by exhibiting an undirected graph \\(G\\) and a maximal matching \\(M\\) in \\(G\\) that is not a maximum matching. (_Hint:_ You can find such a graph with only four vertices.)\n\n_b._: Consider a connected, undirected graph \\(G=(V,E)\\). Give an \\(O(E)\\)-time greedy algorithm to find a maximal matching in \\(G\\).\n\nThis problem concentrates on a polynomial-time approximation algorithm for maximum matching. Whereas the fastest known algorithm for maximum matching takes superlinear (but polynomial) time, the approximation algorithm here will run in linear time. You will show that the linear-time greedy algorithm for maximal matching in part (b) is a 2-approximation algorithm for maximum matching.\n\n_c._: Show that the size of a maximum matching in \\(G\\) is a lower bound on the size of any vertex cover for \\(G\\).\n\n_d._: Consider a maximal matching \\(M\\) in \\(G=(V,E)\\). Let \\(T=\\{v\\in V\\colon\\text{some edge in }M\\text{ is incident on }v\\}\\). What can you say about the subgraph of \\(G\\) induced by the vertices of \\(G\\) that are not in \\(T\\)?\n\n_e._: Conclude from part (d) that \\(2\\,|\\,M\\,|\\) is the size of a vertex cover for \\(G\\).\n\n_f._: Using parts (c) and (e), prove that the greedy algorithm in part (b) is a 2-approximation algorithm for maximum matching.\n\n_35-5 Parallel machine scheduling_\n\nIn the _parallel-machine-scheduling problem_, the input has two parts: \\(n\\) jobs, \\(J_{1},\\,J_{2},\\ldots,J_{n}\\), where each job \\(J_{k}\\) has an associated nonnegative processing time of \\(p_{k}\\), and \\(m\\) identical machines, \\(M_{1},\\,M_{2},\\ldots,M_{m}\\). Any job can run on any machine. A _schedule_ specifies, for each job \\(J_{k}\\), the machine on which it runs and the time period during which it runs. Each job \\(J_{k}\\) must run on some machine \\(M_{i}\\) for \\(p_{k}\\) consecutive time units, and during that time period no other job may run on \\(M_{i}\\). Let \\(C_{k}\\) denote the _completion time_ of job \\(J_{k}\\), that is, the time at which job \\(J_{k}\\) completes processing. Given a schedule, define \\(C_{\\max}=\\max\\left\\{C_{j}:1\\leq j\\leq n\\right\\}\\) to be the _makespan_ of the schedule. The goal is to find a schedule whose makespan is minimum.\n\nFor example, consider an input with two machines \\(M_{1}\\) and \\(M_{2}\\), and four jobs \\(J_{1}\\), \\(J_{2}\\), \\(J_{3}\\), and \\(J_{4}\\) with \\(p_{1}=2\\), \\(p_{2}=12\\), \\(p_{3}=4\\), and \\(p_{4}=5\\). Then one possible schedule runs, on machine \\(M_{1}\\), job \\(J_{1}\\) followed by job \\(J_{2}\\), and on machine \\(M_{2}\\), job \\(J_{4}\\) followed by job \\(J_{3}\\). For this schedule, \\(C_{1}=2\\), \\(C_{2}=14\\), \\(C_{3}=9\\), \\(C_{4}=5\\), and \\(C_{\\max}=14\\). An optimal schedule runs job \\(J_{2}\\) on machine \\(M_{1}\\) and jobs \\(J_{1}\\), \\(J_{3}\\), and \\(J_{4}\\) on machine \\(M_{2}\\). For this schedule, we have \\(C_{1}=2\\), \\(C_{2}=12\\), \\(C_{3}=6\\), and \\(C_{4}=11\\), and so \\(C_{\\max}=12\\).\n\nGiven the input to a parallel-machine-scheduling problem, let \\(C_{\\max}^{*}\\) denote the makespan of an optimal schedule.\n\n_a._: Show that the optimal makespan is at least as large as the greatest processing time, that is,\n\n\\[C_{\\max}^{*}\\geq\\max\\left\\{p_{k}:1\\leq k\\leq n\\right\\}\\.\\]\n\n_b._: Show that the optimal makespan is at least as large as the average machine load, that is,\n\n\\[C_{\\max}^{*}\\geq\\frac{1}{m}\\sum_{k=1}^{n}p_{k}\\.\\]\n\nConsider the following greedy algorithm for parallel machine scheduling: whenever a machine is idle, schedule any job that has not yet been scheduled.\n\n_c._: Write pseudocode to implement this greedy algorithm. What is the running time of your algorithm?\n\n_d._: For the schedule returned by the greedy algorithm, show that\n\n\\[C_{\\max}\\leq\\frac{1}{m}\\sum_{k=1}^{n}p_{k}\\,+\\max\\left\\{p_{k}:1\\leq k\\leq n \\right\\}\\.\\]\n\nConclude that this algorithm is a polynomial-time 2-approximation algorithm.\n\n#### 35-6 Approximating a maximum spanning tree\n\nLet \\(G=(V,E)\\) be an undirected graph with distinct edge weights \\(w(u,v)\\) on each edge \\((u,v)\\in E\\). For each vertex \\(v\\in V\\), denote by \\(\\max(v)\\) the maximum-weight edge incident on that vertex. Let \\(S_{G}=\\{\\max(v):v\\in V\\}\\) be the set of maximum-weight edges incident on each vertex, and let \\(T_{G}\\) be the maximum-weight spanning tree of \\(G\\), that is, the spanning tree of maximum total weight. For any subset of edges \\(E^{\\prime}\\subseteq E\\), define \\(w(E^{\\prime})=\\sum_{(u,v)\\in E^{\\prime}}w(u,v)\\).\n\n**a.**: Give an example of a graph with at least 4 vertices for which \\(S_{G}=T_{G}\\).\n**b.**: Give an example of a graph with at least 4 vertices for which \\(S_{G}\\neq T_{G}\\).\n**c.**: Prove that \\(S_{G}\\subseteq T_{G}\\) for any graph \\(G\\).\n**d.**: Prove that \\(w(S_{G})\\geq w(T_{G})/2\\) for any graph \\(G\\).\n**e.**: Give an \\(O(V+E)\\)-time algorithm to compute a 2-approximation to the maximum spanning tree.\n\n#### 35-7 An approximation algorithm for the 0-1 knapsack problem\n\nRecall the knapsack problem from Section 15.2. The input includes \\(n\\) items, where the \\(i\\)th item is worth \\(v_{i}\\) dollars and weighs \\(w_{i}\\) pounds. The input also includes the capacity of a knapsack, which is \\(W\\) pounds. Here, we add the further assumptions that each weight \\(w_{i}\\) is at most \\(W\\) and that the items are indexed in monotonically decreasing order of their values: \\(v_{1}\\geq v_{2}\\geq\\cdots\\geq v_{n}\\).\n\nIn the 0-1 knapsack problem, the goal is to find a subset of the items whose total weight is at most \\(W\\) and whose total value is maximum. The fractional knapsack problem is like the 0-1 knapsack problem, except that a fraction of each item may be put into the knapsack, rather than either all or none of each item. If a fraction \\(x_{i}\\) of item \\(i\\) goes into the knapsack, where \\(0\\leq x_{i}\\leq 1\\), it contributes \\(x_{i}\\,w_{i}\\) to the weight of the knapsack and adds value \\(x_{i}\\,v_{i}\\). The goal of this problem is to develop a polynomial-time 2-approximation algorithm for the 0-1 knapsack problem.\n\nIn order to design a polynomial-time algorithm, let's consider restricted instances of the 0-1 knapsack problem. Given an instance \\(I\\) of the knapsack problem, form restricted instances \\(I_{j}\\), for \\(j=1,2,\\ldots,n\\), by removing items \\(1,2,\\ldots,j-1\\) and requiring the solution to include item \\(j\\) (all of item \\(j\\) in both the fractional and 0-1 knapsack problems). No items are removed in instance \\(I_{1}\\). For instance \\(I_{j}\\), let \\(P_{j}\\) denote an optimal solution to the 0-1 problem and \\(Q_{j}\\) denote an optimal solution to the fractional problem.\n\n**a.**: Argue that an optimal solution to instance \\(I\\) of the 0-1 knapsack problem is one of \\(\\{P_{1},P_{2},\\ldots,P_{n}\\}\\).\n\n* Prove that to find an optimal solution \\(Q_{j}\\) to the fractional problem for instance \\(I_{j}\\), you can include item \\(j\\) and then use the greedy algorithm in which each step takes as much as possible of the unchosen item with the maximum value per bound \\(v_{i}/w_{i}\\) in the set \\(\\{j\\,+\\,1,\\,j\\,+\\,2,\\ldots,n\\}\\).\n* Prove that there is always an optimal solution \\(Q_{j}\\) to the fractional problem for instance \\(I_{j}\\) that includes at most one item fractionally. That is, for all items except possibly one, either all of the item or none of the item goes into the knapsack.\n* Given an optimal solution \\(Q_{j}\\) to the fractional problem for instance \\(I_{j}\\), form solution \\(R_{j}\\) from \\(Q_{j}\\) by deleting any fractional items from \\(Q_{j}\\). Let \\(v(S)\\) denote the total value of items taken in a solution \\(S\\). Prove that \\(v(R_{j})\\geq v(Q_{j})/2\\geq v(P_{j})/2\\).\n* Give a polynomial-time algorithm that returns a maximum-value solution from the set \\(\\{R_{1},\\,R_{2},\\ldots,\\,R_{n}\\}\\), and prove that your algorithm is a polynomial-time 2-approximation algorithm for the 0-1 knapsack problem.\n\n## Chapter notes\n\nAlthough methods that do not necessarily compute exact solutions have been known for thousands of years (for example, methods to approximate the value of \\(\\pi\\)), the notion of an approximation algorithm is much more recent. Hochbaum [221] credits Garey, Graham, and Ullman [175] and Johnson [236] with formalizing the concept of a polynomial-time approximation algorithm. The first such algorithm is often credited to Graham [197].\n\nSince this early work, thousands of approximation algorithms have been designed for a wide range of problems, and there is a wealth of literature on this field. Texts by Ausiello et al. [29], Hochbaum [221], Vazirani [446], and Williamson and Shmoys [459] deal exclusively with approximation algorithms, as do surveys by Shmoys [409] and Klein and Young [256]. Several other texts, such as Garey and Johnson [176] and Papadimitriou and Steiglitz [353], have significant coverage of approximation algorithms as well. Books edited by Lawler, Lenstra, Rinnooy Kan, and Shmoys [277] and by Gutin and Punnen [204] provide extensive treatments of approximation algorithms and heuristics for the traveling-salesperson problem.\n\nPapadimitriou and Steiglitz attribute the algorithm Approx-Vertex-Cover to F. Gavril and M. Yannakakis. The vertex-cover problem has been studied extensively (Hochbaum [221] lists 16 different approximation algorithms for this problem), but all the approximation ratios are at least \\(2-o(1)\\).",
        "chapter": "Part VII Selected Topics",
        "section": "35 Approximation Algorithms",
        "subsection": "Problems",
        "subsubsection": "N/A"
    },
    {
        "content": "* Prove that to find an optimal solution \\(Q_{j}\\) to the fractional problem for instance \\(I_{j}\\), you can include item \\(j\\) and then use the greedy algorithm in which each step takes as much as possible of the unchosen item with the maximum value per bound \\(v_{i}/w_{i}\\) in the set \\(\\{j\\,+\\,1,\\,j\\,+\\,2,\\ldots,n\\}\\).\n* Prove that there is always an optimal solution \\(Q_{j}\\) to the fractional problem for instance \\(I_{j}\\) that includes at most one item fractionally. That is, for all items except possibly one, either all of the item or none of the item goes into the knapsack.\n* Given an optimal solution \\(Q_{j}\\) to the fractional problem for instance \\(I_{j}\\), form solution \\(R_{j}\\) from \\(Q_{j}\\) by deleting any fractional items from \\(Q_{j}\\). Let \\(v(S)\\) denote the total value of items taken in a solution \\(S\\). Prove that \\(v(R_{j})\\geq v(Q_{j})/2\\geq v(P_{j})/2\\).\n* Give a polynomial-time algorithm that returns a maximum-value solution from the set \\(\\{R_{1},\\,R_{2},\\ldots,\\,R_{n}\\}\\), and prove that your algorithm is a polynomial-time 2-approximation algorithm for the 0-1 knapsack problem.\n\n## Chapter notes\n\nAlthough methods that do not necessarily compute exact solutions have been known for thousands of years (for example, methods to approximate the value of \\(\\pi\\)), the notion of an approximation algorithm is much more recent. Hochbaum [221] credits Garey, Graham, and Ullman [175] and Johnson [236] with formalizing the concept of a polynomial-time approximation algorithm. The first such algorithm is often credited to Graham [197].\n\nSince this early work, thousands of approximation algorithms have been designed for a wide range of problems, and there is a wealth of literature on this field. Texts by Ausiello et al. [29], Hochbaum [221], Vazirani [446], and Williamson and Shmoys [459] deal exclusively with approximation algorithms, as do surveys by Shmoys [409] and Klein and Young [256]. Several other texts, such as Garey and Johnson [176] and Papadimitriou and Steiglitz [353], have significant coverage of approximation algorithms as well. Books edited by Lawler, Lenstra, Rinnooy Kan, and Shmoys [277] and by Gutin and Punnen [204] provide extensive treatments of approximation algorithms and heuristics for the traveling-salesperson problem.\n\nPapadimitriou and Steiglitz attribute the algorithm Approx-Vertex-Cover to F. Gavril and M. Yannakakis. The vertex-cover problem has been studied extensively (Hochbaum [221] lists 16 different approximation algorithms for this problem), but all the approximation ratios are at least \\(2-o(1)\\).\n\nThe algorithm Approx-TSP-Tour appears in a paper by Rosenkrantz, Stearns, and Lewis [384]. Christofides improved on this algorithm and gave a \\(3/2\\)-approximation algorithm for the traveling-salesperson problem with the triangle inequality. Arora [23] and Mitchell [330] have shown that if the points lie in the euclidean plane, there is a polynomial-time approximation scheme. Theorem 35.3 is due to Sahni and Gonzalez [392].\n\nThe algorithm Approx-Subset-Sum and its analysis are loosely modeled after related approximation algorithms for the knapsack and subset-sum problems by Ibarra and Kim [234].\n\nProblem 35-7 is a combinatorial version of a more general result on approximating knapsack-type integer programs by Bienstock and McClosky [55].\n\nThe randomized algorithm for MAX-3-CNF satisfiability is implicit in the work of Johnson [236]. The weighted vertex-cover algorithm is by Hochbaum [220]. Section 35.4 only touches on the power of randomization and linear programming in the design of approximation algorithms. A combination of these two ideas yields a technique called \"randomized rounding,\" which formulates a problem as an integer linear program, solves the linear-programming relaxation, and interprets the variables in the solution as probabilities. These probabilities then help guide the solution of the original problem. This technique was first used by Raghavan and Thompson [374], and it has had many subsequent uses. (See Motwani, Naor, and Raghavan [335] for a survey.) Several other notable ideas in the field of approximation algorithms include the primal-dual method (see Goemans and Williamson [184] for a survey), finding sparse cuts for use in divide-and-conquer algorithms [288], and the use of semidefinite programming [183].\n\nAs mentioned in the chapter notes for Chapter 34, results in probabilistically checkable proofs have led to lower bounds on the approximability of many problems, including several in this chapter. In addition to the references there, the chapter by Arora and Lund [26] contains a good description of the relationship between probabilistically checkable proofs and the hardness of approximating various problems.\n\n[MISSING_PAGE_EMPTY:3]",
        "chapter": "Part VII Selected Topics",
        "section": "35 Approximation Algorithms",
        "subsection": "Chapter notes",
        "subsubsection": "N/A"
    },
    {
        "content": "## Introduction\n\nWhen you analyze algorithms, you often need to draw upon a body of mathematical tools. Some of these tools are as simple as high-school algebra, but others may be new to you. In Part I, we saw how to manipulate asymptotic notations and solve recurrences. This appendix comprises a compendium of several other concepts and methods used in analyzing algorithms. As noted in the introduction to Part I, you may have seen much of the material in this appendix before having read this book, although some of the specific notational conventions appearing here might differ from those you have seen elsewhere. Hence, you should treat this appendix as reference material. As in the rest of this book, however, we have included exercises and problems, in order for you to improve your skills in these areas.\n\nAppendix A offers methods for evaluating and bounding summations, which occur frequently in the analysis of algorithms. Many of the formulas here appear in any calculus text, but you will find it convenient to have these methods compiled in one place.\n\nAppendix B contains basic definitions and notations for sets, relations, functions, graphs, and trees. It also gives some basic properties of these mathematical objects.\n\nAppendix C begins with elementary principles of counting: permutations, combinations, and the like. The remainder contains definitions and properties of basic probability. Most of the algorithms in this book require no probability for their analysis, and thus you can easily omit the latter sections of the chapter on a first reading, even without skimming them. Later, when you encounter a probabilistic analysis that you want to understand better, you will find Appendix C well organized for reference purposes.\n\nAppendix D defines matrices, their operations, and some of their basic properties. You have probably seen most of this material already if you have taken a course in linear algebra. But you might find it helpful to have one place to look for notations and definitions.\n\n## Appendix A Summations\n\nWhen an algorithm contains an iterative control construct such as a **while** or **for** loop, you can express its running time as the sum of the times spent on each execution of the body of the loop. For example, Section 2.2 argued that the \\(i\\)th iteration of insertion sort took time proportional to \\(i\\) in the worst case. Adding up the time spent on each iteration produced the summation (or series) \\(\\sum_{i=2}^{n}i\\). Evaluating this summation resulted in a bound of \\(\\Theta(n^{2})\\) on the worst-case running time of the algorithm. This example illustrates why you should know how to manipulate and bound summations.\n\nSection A.1 lists several basic formulas involving summations. Section A.2 offers useful techniques for bounding summations. The formulas in Section A.1 appear without proof, though proofs for some of them appear in Section A.2 to illustrate the methods of that section. You can find most of the other proofs in any calculus text.\n\n### Summation formulas and properties\n\nGiven a sequence \\(a_{1},a_{2},\\ldots,a_{n}\\) of numbers, where \\(n\\) is a nonnegative integer, the finite sum \\(a_{1}+a_{2}+\\cdots+a_{n}\\) can be expressed as \\(\\sum_{k=1}^{n}a_{k}\\). If \\(n=0\\), the value of the summation is defined to be \\(0\\). The value of a finite series is always well defined, and the order in which its terms are added does not matter.\n\nGiven an infinite sequence \\(a_{1},a_{2},\\ldots\\) of numbers, we can write their infinite sum \\(a_{1}+a_{2}+\\cdots\\) as \\(\\sum_{k=1}^{\\infty}a_{k}\\), which means \\(\\lim_{n\\to\\infty}\\sum_{k=1}^{n}a_{k}\\). If the limit does not exist, the series _diverges_, and otherwise, it _converges_. The terms of a convergent series cannot always be added in any order. You can, however, rearrange the terms of an _absolutely convergent series_, that is, a series \\(\\sum_{k=1}^{\\infty}a_{k}\\) for which the series \\(\\sum_{k=1}^{\\infty}|a_{k}|\\) also converges.",
        "chapter": "Part VIII Appendix: Mathematical Background",
        "section": "Introduction",
        "subsection": "N/A",
        "subsubsection": "N/A"
    },
    {
        "content": "## Appendix A Summations\n\nWhen an algorithm contains an iterative control construct such as a **while** or **for** loop, you can express its running time as the sum of the times spent on each execution of the body of the loop. For example, Section 2.2 argued that the \\(i\\)th iteration of insertion sort took time proportional to \\(i\\) in the worst case. Adding up the time spent on each iteration produced the summation (or series) \\(\\sum_{i=2}^{n}i\\). Evaluating this summation resulted in a bound of \\(\\Theta(n^{2})\\) on the worst-case running time of the algorithm. This example illustrates why you should know how to manipulate and bound summations.\n\nSection A.1 lists several basic formulas involving summations. Section A.2 offers useful techniques for bounding summations. The formulas in Section A.1 appear without proof, though proofs for some of them appear in Section A.2 to illustrate the methods of that section. You can find most of the other proofs in any calculus text.\n\n### Summation formulas and properties\n\nGiven a sequence \\(a_{1},a_{2},\\ldots,a_{n}\\) of numbers, where \\(n\\) is a nonnegative integer, the finite sum \\(a_{1}+a_{2}+\\cdots+a_{n}\\) can be expressed as \\(\\sum_{k=1}^{n}a_{k}\\). If \\(n=0\\), the value of the summation is defined to be \\(0\\). The value of a finite series is always well defined, and the order in which its terms are added does not matter.\n\nGiven an infinite sequence \\(a_{1},a_{2},\\ldots\\) of numbers, we can write their infinite sum \\(a_{1}+a_{2}+\\cdots\\) as \\(\\sum_{k=1}^{\\infty}a_{k}\\), which means \\(\\lim_{n\\to\\infty}\\sum_{k=1}^{n}a_{k}\\). If the limit does not exist, the series _diverges_, and otherwise, it _converges_. The terms of a convergent series cannot always be added in any order. You can, however, rearrange the terms of an _absolutely convergent series_, that is, a series \\(\\sum_{k=1}^{\\infty}a_{k}\\) for which the series \\(\\sum_{k=1}^{\\infty}|a_{k}|\\) also converges.\n\n### _Summation formulas and properties_\n\n#### Linearity\n\nFor any real number \\(c\\) and any finite sequences \\(a_{1},a_{2},\\ldots,a_{n}\\) and \\(b_{1},b_{2},\\ldots,b_{n}\\),\n\n\\[\\sum_{k=1}^{n}(ca_{k}+b_{k})=c\\sum_{k=1}^{n}a_{k}+\\sum_{k=1}^{n}b_{k}\\.\\]\n\nThe linearity property also applies to infinite convergent series.\n\nThe linearity property applies to summations incorporating asymptotic notation. For example,\n\n\\[\\sum_{k=1}^{n}\\Theta(f(k))=\\Theta\\left(\\sum_{k=1}^{n}f(k)\\right)\\.\\]\n\nIn this equation, the \\(\\Theta\\)-notation on the left-hand side applies to the variable \\(k\\), but on the right-hand side, it applies to \\(n\\). Such manipulations also apply to infinite convergent series.\n\n#### Arithmetic series\n\nThe summation\n\n\\[\\sum_{k=1}^{n}k=1+2+\\cdots+n\\,\\]\n\nis an _arithmetic series_ and has the value\n\n\\[\\sum_{k=1}^{n}k = \\frac{n(n+1)}{2}\\] (A.1) \\[= \\Theta(n^{2})\\.\\] (A.2)\n\nA _general arithmetic series_ includes an additive constant \\(a\\geq 0\\) and a constant coefficient \\(b>0\\) in each term, but has the same total asymptotically:\n\n\\[\\sum_{k=1}^{n}(a+bk)=\\Theta(n^{2})\\.\\] (A.3)\n\n#### Sums of squares and cubes\n\nThe following formulas apply to summations of squares and cubes:\n\n\\[\\sum_{k=0}^{n}k^{\\,2} = \\frac{n(n+1)(2n+1)}{6}\\,\\] (A.4) \\[\\sum_{k=0}^{n}k^{\\,3} = \\frac{n^{2}(n+1)^{2}}{4}\\.\\] (A.5)\n\n**Geometric series**\n\nFor real \\(x\\neq 1\\), the summation\n\n\\[\\sum_{k=0}^{n}x^{k}\\,=\\,1\\,+\\,x\\,+\\,x^{2}\\,+\\cdots\\,+\\,x^{n}\\]\n\nis a _geometric series_ and has the value\n\n\\[\\sum_{k=0}^{n}x^{k}\\,=\\,\\frac{x^{n+1}-1}{x-1}\\.\\] (A.6)\n\nThe infinite decreasing geometric series occurs when the summation is infinite and \\(|x|<1\\):\n\n\\[\\sum_{k=0}^{\\infty}x^{k}\\,=\\,\\frac{1}{1-x}\\.\\] (A.7)\n\nIf we assume that \\(0^{0}=1\\), these formulas apply even when \\(x=0\\).\n\n**Harmonic series**\n\nFor positive integers \\(n\\), the \\(n\\)th _harmonic number_ is\n\n\\[H_{n} \\,=\\,\\,1\\,+\\,\\frac{1}{2}\\,+\\,\\frac{1}{3}\\,+\\,\\frac{1}{4}\\,+\\cdots +\\,\\frac{1}{n}\\] \\[\\,=\\,\\sum_{k=1}^{n}\\frac{1}{k}\\] (A.8) \\[\\,=\\,\\ln n\\,+\\,O(1)\\.\\] (A.9)\n\nInequalities (A.20) and (A.21) on page 1150 provide the stronger bounds\n\n\\[\\ln(n\\,+\\,1)\\,\\leq\\,H_{n}\\,\\leq\\,\\ln n\\,+\\,1\\.\\] (A.10)\n\n**Integrating and differentiating series**\n\nIntegrating or differentiating the formulas above yields additional formulas. For example, differentiating both sides of the infinite geometric series (A.7) and multiplying by \\(x\\) gives\n\n\\[\\sum_{k=0}^{\\infty}kx^{k}\\,=\\,\\frac{x}{(1-x)^{2}}\\] (A.11)\n\nfor \\(|x|<1\\).\n\n### Summation formulas and properties\n\n#### Telescoping series\n\nFor any sequence \\(a_{0},a_{1},\\ldots,a_{n}\\),\n\n\\[\\sum_{k=1}^{n}(a_{k}-a_{k-1})=a_{n}-a_{0}\\,\\] (A.12)\n\nsince each of the terms \\(a_{1},a_{2},\\ldots,a_{n-1}\\) is added in exactly once and subtracted out exactly once. We say that the sum _telescopes_. Similarly,\n\n\\[\\sum_{k=0}^{n-1}(a_{k}-a_{k+1})=a_{0}-a_{n}\\.\\]\n\nAs an example of a telescoping sum, consider the series\n\n\\[\\sum_{k=1}^{n-1}\\frac{1}{k(k+1)}\\.\\]\n\nRewriting each term as\n\n\\[\\frac{1}{k(k+1)}=\\frac{1}{k}-\\frac{1}{k+1}\\,\\]\n\ngives\n\n\\[\\sum_{k=1}^{n-1}\\frac{1}{k(k+1)} = \\sum_{k=1}^{n-1}\\left(\\frac{1}{k}-\\frac{1}{k+1}\\right)\\] \\[= 1-\\frac{1}{n}\\.\\]\n\n#### Reindexing summations\n\nA series can sometimes be simplified by changing its index, often reversing the order of summation. Consider the series \\(\\sum_{k=0}^{n}a_{n-k}\\). Because the terms in this summation are \\(a_{n},a_{n-1},\\ldots,a_{0}\\), we can reverse the order of indices by letting \\(j=n-k\\) and rewrite this summation as\n\n\\[\\sum_{k=0}^{n}a_{n-k}=\\sum_{j=0}^{n}a_{j}\\.\\] (A.13)\n\nGenerally, if the summation index appears in the body of the sum with a minus sign, it's worth thinking about reindexing.\n\nAs an example, consider the summation\\[\\sum_{k=1}^{n}\\frac{1}{n-k+1}\\.\\] The index \\(k\\) appears with a negative sign in \\(1/(n-k+1)\\). And indeed, we can simplify this summation, this time setting \\(j=n-k+1\\), yielding \\[\\sum_{k=1}^{n}\\frac{1}{n-k+1}=\\sum_{j=1}^{n}\\frac{1}{j}\\,\\] (A.14) which is just the harmonic series (A.8).\n\n**Products**\n\nThe finite product \\(a_{1}a_{2}\\cdots a_{n}\\) can be expressed as\n\n\\[\\prod_{k=1}^{n}a_{k}\\.\\] If \\(n=0\\), the value of the product is defined to be 1. You can convert a formula with a product to a formula with a summation by using the identity \\[\\lg\\left(\\prod_{k=1}^{n}a_{k}\\right)=\\sum_{k=1}^{n}\\lg a_{k}\\.\\]\n\n**Exercises**\n\n_A.1-1_\n\nProve that \\(\\sum_{k=1}^{n}O(f_{k}(i))=O\\big{(}\\sum_{k=1}^{n}f_{k}(i)\\big{)}\\) by using the linearity property of summations.\n\n_A.1-2_\n\nFind a simple formula for \\(\\sum_{k=1}^{n}(2k-1)\\).\n\n_A.1-3_\n\nInterpret the decimal number 111,111,111 in light of equation (A.6).\n\n_A.1-4_\n\nEvaluate the infinite series \\(1-\\frac{1}{2}+\\frac{1}{4}-\\frac{1}{8}+\\frac{1}{16}-\\cdots\\).\n\n_A.1-5_\n\nLet \\(c\\geq 0\\) be a constant. Show that \\(\\sum_{k=1}^{n}k^{c}=\\Theta(n^{c+1})\\).\n\n_A.1-6_\n\nShow that \\(\\sum_{k=0}^{\\infty}k^{2}x^{k}=x(1+x)/(1-x)^{3}\\) for \\(|x|<1\\).\n\n### Bounding summations\n\nYou can choose from several techniques to bound the summations that describe the running times of algorithms. Here are some of the most frequently used methods.\n\n**Mathematical induction**\n\nThe most basic way to evaluate a series is to use mathematical induction. As an example, let's prove that the arithmetic series \\(\\sum_{k=1}^{n}k\\) evaluates to \\(n(n+1)/2\\). For \\(n=1\\), we have that \\(n(n+1)/2=1\\cdot 2/2=1\\), which equals \\(\\sum_{k=1}^{1}k\\). With the inductive assumption that it holds for \\(n\\), we prove that it holds for \\(n+1\\). We have\n\n\\[\\sum_{k=1}^{n+1}k = \\sum_{k=1}^{n}k\\ +\\ (n+1)\\] \\[= \\frac{n(n+1)}{2}+(n+1)\\] \\[= \\frac{n^{2}+n+2n+2}{2}\\] \\[= \\frac{(n+1)(n+2)}{2}\\.\\]\n\nYou don't always need to guess the exact value of a summation in order to use mathematical induction. Instead, you can use induction to prove an upper or lower",
        "chapter": "Part VIII Appendix: Mathematical Background",
        "section": "A Summations",
        "subsection": "A.1 Summation formulas and properties",
        "subsubsection": "N/A"
    },
    {
        "content": "### Bounding summations\n\nYou can choose from several techniques to bound the summations that describe the running times of algorithms. Here are some of the most frequently used methods.\n\n**Mathematical induction**\n\nThe most basic way to evaluate a series is to use mathematical induction. As an example, let's prove that the arithmetic series \\(\\sum_{k=1}^{n}k\\) evaluates to \\(n(n+1)/2\\). For \\(n=1\\), we have that \\(n(n+1)/2=1\\cdot 2/2=1\\), which equals \\(\\sum_{k=1}^{1}k\\). With the inductive assumption that it holds for \\(n\\), we prove that it holds for \\(n+1\\). We have\n\n\\[\\sum_{k=1}^{n+1}k = \\sum_{k=1}^{n}k\\ +\\ (n+1)\\] \\[= \\frac{n(n+1)}{2}+(n+1)\\] \\[= \\frac{n^{2}+n+2n+2}{2}\\] \\[= \\frac{(n+1)(n+2)}{2}\\.\\]\n\nYou don't always need to guess the exact value of a summation in order to use mathematical induction. Instead, you can use induction to prove an upper or lowerbound on a summation. As an example, let's prove the asymptotic upper bound \\(\\sum_{k=0}^{n}3^{k}\\,=\\,O(3^{n})\\). More specifically, we'll prove that \\(\\sum_{k=0}^{n}3^{k}\\,\\leq\\,c\\,3^{n}\\) for some constant \\(c\\). For the initial condition \\(n\\,=\\,0\\), we have \\(\\sum_{k\\,=\\,0}^{0}3^{k}\\,=\\,1\\,\\leq\\,c\\cdot 1\\) as long as \\(c\\,\\geq\\,1\\). Assuming that the bound holds for \\(n\\), we prove that it holds for \\(n\\,+\\,1\\). We have\n\n\\[\\sum_{k\\,=\\,0}^{n\\,+\\,1}3^{k} \\,=\\,\\sum_{k\\,=\\,0}^{n}3^{k}\\,+\\,3^{n+1}\\] \\[\\,\\leq\\,c\\,3^{n}\\,+\\,3^{n+1}\\qquad\\qquad\\mbox{(by the inductive hypothesis)}\\] \\[\\,=\\,\\left(\\frac{1}{3}\\,+\\,\\frac{1}{c}\\right)c\\,3^{n+1}\\] \\[\\,\\leq\\,c\\,3^{n+1}\\]\n\nas long as \\((1/3\\,+\\,1/c)\\,\\leq\\,1\\) or, equivalently, \\(c\\,\\geq\\,3/2\\). Thus, \\(\\sum_{k\\,=\\,0}^{n}3^{k}\\,=\\,O(3^{n})\\), as we wished to show.\n\nYou need to take care when using asymptotic notation to prove bounds by induction. Consider the following fallacious proof that \\(\\sum_{k\\,=\\,1}^{n}k\\,=\\,O(n)\\). Certainly, \\(\\sum_{k\\,=\\,1}^{1}k\\,=\\,O(1)\\). Assuming that the bound holds for \\(n\\), we now prove it for \\(n\\,+\\,1\\):\n\n\\[\\sum_{k\\,=\\,1}^{n\\,+\\,1}k \\,=\\,\\sum_{k\\,=\\,1}^{n}k\\,+\\,(n\\,+\\,1)\\] \\[\\,=\\,O(n)\\,+\\,(n\\,+\\,1)\\qquad\\quad\\Longleftrightarrow\\mbox{wrong!}\\] \\[\\,=\\,O(n\\,+\\,1)\\,\\,.\\]\n\nThe bug in the argument is that the \"constant\" hidden by the \"big-oh\" grows with \\(n\\) and thus is not constant. We have not shown that the same constant works for _all_\\(n\\).\n\n#### Bounding the terms\n\nYou can sometimes obtain a good upper bound on a series by bounding each term of the series, and it often suffices to use the largest term to bound the others. For example, a quick upper bound on the arithmetic series (A.1) is\n\n\\[\\sum_{k\\,=\\,1}^{n}k \\,\\leq\\,\\sum_{k\\,=\\,1}^{n}n\\] \\[\\,=\\,n^{2}\\,\\,.\\]\n\nIn general, for a series \\(\\sum_{k\\,=\\,1}^{n}a_{k}\\), if we let \\(a_{\\max}=\\max\\,\\{a_{k}\\,:\\,1\\,\\leq\\,k\\,\\leq\\,n\\}\\), then\n\n\\[\\sum_{k\\,=\\,1}^{n}a_{k}\\,\\leq n\\cdot a_{\\max}\\,\\,.\\]\n\n### Bounding summations\n\nThe technique of bounding each term in a series by the largest term is a weak method when the series can in fact be bounded by a geometric series. Given the series \\(\\sum_{k=0}^{n}a_{k}\\), suppose that \\(a_{k+1}/a_{k}\\leq r\\) for all \\(k\\geq 0\\), where \\(0<r<1\\) is a constant. You can bound the sum by an infinite decreasing geometric series, since \\(a_{k}\\leq a_{0}r^{k}\\), and thus\n\n\\[\\sum_{k=0}^{n}a_{k} \\leq \\sum_{k=0}^{\\infty}a_{0}r^{k} \\tag{103}\\] \\[= a_{0}\\sum_{k=0}^{\\infty}r^{k}\\] \\[= a_{0}\\,\\frac{1}{1-r}\\.\\]\n\nYou can apply this method to bound the summation \\(\\sum_{k=1}^{\\infty}(k/3^{k})\\). In order to start the summation at \\(k=0\\), rewrite it as \\(\\sum_{k=0}^{\\infty}((k+1)/3^{k+1})\\). The first term (\\(a_{0}\\)) is \\(1/3\\), and the ratio (\\(r\\)) of consecutive terms is\n\n\\[\\frac{(k+2)/3^{k+2}}{(k+1)/3^{k+1}} = \\frac{1}{3}\\cdot\\frac{k+2}{k+1}\\] \\[\\leq \\frac{2}{3}\\]\n\nfor all \\(k\\geq 0\\). Thus, we have\n\n\\[\\sum_{k=1}^{\\infty}\\frac{k}{3^{k}} = \\sum_{k=0}^{\\infty}\\frac{k+1}{3^{k+1}}\\] \\[\\leq \\frac{1}{3}\\cdot\\frac{1}{1-2/3}\\] \\[= 1\\.\\]\n\nA common bug in applying this method is to show that the ratio of consecutive terms is less than 1 and then to assume that the summation is bounded by a geometric series. An example is the infinite harmonic series, which diverges since\n\n\\[\\sum_{k=1}^{\\infty}\\frac{1}{k} = \\lim_{n\\to\\infty}\\sum_{k=1}^{n}\\frac{1}{k}\\] \\[= \\lim_{n\\to\\infty}\\Theta(\\lg n)\\] \\[= \\infty\\.\\]\n\nThe ratio of the (\\(k+1\\))st and \\(k\\)th terms in this series is \\(k/(k+1)<1\\), but the series is not bounded by a decreasing geometric series. To bound a series by a geometricseries, you need to show that there is an \\(r<1\\), which is a _constant_, such that the ratio of all pairs of consecutive terms never exceeds \\(r\\). In the harmonic series, no such \\(r\\) exists because the ratio becomes arbitrarily close to \\(1\\).\n\n### Splitting summations\n\nOne way to obtain bounds on a difficult summation is to express the series as the sum of two or more series by partitioning the range of the index and then to bound each of the resulting series. For example, let's find a lower bound on the arithmetic series \\(\\sum_{k=1}^{n}k\\), which we have already seen has an upper bound of \\(n^{2}\\). You might attempt to bound each term in the summation by the smallest term, but since that term is \\(1\\), you would get a lower bound of \\(n\\) for the summation--far off from the upper bound of \\(n^{2}\\).\n\nYou can obtain a better lower bound by first splitting the summation. Assume for convenience that \\(n\\) is even, so that\n\n\\[\\sum_{k=1}^{n}k = \\sum_{k=1}^{n/2}k\\,+\\,\\sum_{k=n/2+1}^{n}k\\] \\[\\geq \\sum_{k=1}^{n/2}0\\,+\\,\\sum_{k=n/2+1}^{n}\\frac{n}{2}\\] \\[= \\left(\\frac{n}{2}\\right)^{2}\\] \\[= \\Omega(n^{2})\\,\\]\n\nwhich is an asymptotically tight bound, since \\(\\sum_{k=1}^{n}k\\,=\\,O(n^{2})\\).\n\nFor a summation arising from the analysis of an algorithm, you can sometimes split the summation and ignore a constant number of the initial terms. Generally, this technique applies when each term \\(a_{k}\\) in a summation \\(\\sum_{k=0}^{n}a_{k}\\) is independent of \\(n\\). Then for any constant \\(k_{0}>0\\), you can write\n\n\\[\\sum_{k=0}^{n}a_{k} = \\sum_{k=0}^{k_{0}-1}a_{k}\\,+\\,\\sum_{k=k_{0}}^{n}a_{k}\\] \\[= \\Theta(1)\\,+\\,\\sum_{k=k_{0}}^{n}a_{k}\\,\\]\n\nsince the initial terms of the summation are all constant and there are a constant number of them. You can then use other methods to bound \\(\\sum_{k=k_{0}}^{n}a_{k}\\). This technique applies to infinite summations as well. For example, let's find an asymptotic upper bound on \\(\\sum_{k=0}^{\\infty}k^{2}/2^{k}\\). The ratio of consecutive terms is \n\n### Bounding summations\n\n\\[\\frac{(k\\,+\\,1)^{2}/2^{k\\,+\\,1}}{k^{\\,2}/2^{k}} \\,=\\,\\,\\frac{(k\\,+\\,1)^{2}}{2k^{\\,2}}\\] \\[\\,\\leq\\,\\,8/9\\]\n\nif \\(k\\,\\geq\\,3\\). Thus, you can split the summation into\n\n\\[\\sum_{k=0}^{\\infty}\\frac{k^{\\,2}}{2^{k}} \\,=\\,\\,\\sum_{k\\,=\\,0}^{2}\\frac{k^{\\,2}}{2^{k}}\\,+\\,\\sum_{k\\,=\\,3} ^{\\infty}\\frac{k^{\\,2}}{2^{k}}\\] \\[\\,=\\,\\sum_{k\\,=\\,0}^{2}\\frac{k^{\\,2}}{2^{k}}\\,+\\,\\sum_{k\\,=\\,0}^ {\\infty}\\frac{(k\\,+\\,3)^{2}}{2^{k\\,+\\,3}}\\qquad\\mbox{(by reindexing)}\\] \\[\\,\\leq\\,\\sum_{k\\,=\\,0}^{2}\\frac{k^{\\,2}}{2^{k}}\\,+\\,\\frac{9}{8} \\sum_{k\\,=\\,0}^{\\infty}\\left(\\frac{8}{9}\\right)^{k}\\qquad\\mbox{(by inequality (A.15))}\\] \\[\\,=\\,\\,(0\\,+\\,1/2\\,+\\,1)\\,+\\,\\frac{9/8}{1-8/9}\\quad\\mbox{(by equation (A.16))}\\] \\[\\,=\\,\\,O(1)\\,\\,.\\]\n\nThe technique of splitting summations can help determine asymptotic bounds in much more difficult situations. For example, here is one way to obtain a bound of \\(\\,O(\\lg n)\\) on the harmonic series (A.9):\n\n\\[H_{n}\\,=\\,\\sum_{k\\,=\\,1}^{n}\\frac{1}{k}\\,\\,.\\]\n\nThe idea is to split the range \\(1\\) to \\(n\\) into \\(\\lfloor\\lg n\\rfloor\\,+\\,1\\) pieces and upper-bound the contribution of each piece by \\(1\\). For \\(i\\,=\\,0,1,\\ldots,\\,\\lfloor\\lg n\\rfloor\\,\\), the \\(i\\,\\)th piece consists of the terms starting at \\(1/2^{i}\\) and going up to but not including \\(\\,1/2^{i\\,+\\,1}\\). The last piece might contain terms not in the original harmonic series, giving\n\n\\[\\sum_{k\\,=\\,1}^{n}\\frac{1}{k} \\,\\leq\\,\\sum_{i\\,=\\,0}^{\\lfloor\\lg n\\rfloor}\\sum_{j\\,=\\,0}^{2^{ i}-1}\\frac{1}{2^{i}\\,+\\,j}\\] \\[\\,\\leq\\,\\sum_{i\\,=\\,0}^{\\lfloor\\lg n\\rfloor}\\sum_{j\\,=\\,0}^{2^{ i}-1}\\frac{1}{2^{i}}\\] \\[\\,=\\,\\sum_{i\\,=\\,0}^{\\lfloor\\lg n\\rfloor}\\left(2^{i}\\cdot\\frac{1 }{2^{i}}\\right)\\] \\[\\,=\\,\\sum_{i\\,=\\,0}^{\\lfloor\\lg n\\rfloor}1\\] \\[\\,\\leq\\,\\lg n\\,+\\,1\\,\\,.\\] (A.17)\n\n## Appendix A Summations\n\n### Approximation by integrals\n\nWhen a summation has the form \\(\\sum_{k=m}^{n}f(k)\\), where \\(f(k)\\) is a monotonically increasing function, you can approximate it by integrals:\n\n\\[\\int_{m-1}^{n}f(x)\\,dx\\leq\\sum_{k=m}^{n}f(k)\\leq\\int_{m}^{n+1}f(x)\\,dx. \\tag{111}\\]\n\nFigure A.1 justifies this approximation. The summation is represented as the area of the rectangles in the figure, and the integral is the blue region under the curve. When \\(f(k)\\) is a monotonically decreasing function, you can use a similar method to provide the bounds\n\n\\[\\int_{m}^{n+1}f(x)\\,dx\\leq\\sum_{k=m}^{n}f(k)\\leq\\int_{m-1}^{n}f(x)\\,dx. \\tag{112}\\]\n\nThe integral approximation (112) can be used to prove the tight bounds in inequality (111) for the \\(n\\)th harmonic number. The lower bound is\n\n\\[\\sum_{k=1}^{n}\\frac{1}{k} \\geq \\int_{1}^{n+1}\\frac{dx}{x} \\tag{113}\\] \\[= \\ln(n\\,+\\,1)\\,\\]\n\nFor the upper bound, the integral approximation gives\n\n\\[\\sum_{k=1}^{n}\\frac{1}{k} = \\sum_{k=2}^{n}\\frac{1}{k}\\,+\\,1 \\tag{114}\\] \\[\\leq \\int_{1}^{n}\\frac{dx}{x}\\,+\\,1\\] \\[= \\ln n\\,+\\,1\\.\\]\n\n### Exercises\n\n#### a.2-1\n\nShow that \\(\\sum_{k=1}^{n}1/k^{\\,2}\\) is bounded above by a constant.\n\n#### a.2-2\n\nFind an asymptotic upper bound on the summation\n\n\\[\\sum_{k=0}^{\\lfloor\\lg n\\rfloor}\\left\\lceil n/2^{k}\\right\\rceil\\.\\]\n\n### Bounding summations\n\nFigure A.1: Approximation of \\(\\sum_{k=m}^{n}f(k)\\) by integrals. The area of each rectangle is shown within the rectangle, and the total rectangle area represents the value of the summation. The integral is represented by the blue area under the curve. Comparing areas in **(a)** gives the lower bound \\(\\int_{m-1}^{n}f(x)\\,dx\\leq\\sum_{k=m}^{n}f(k)\\). Shifting the rectangles one unit to the right gives the upper bound \\(\\sum_{k=m}^{n}f(k)\\leq\\int_{m}^{n+1}f(x)\\,dx\\) in **(b)**.\n\n_A.2-3_\n\nShow that the \\(n\\)th harmonic number is \\(\\Omega(\\lg n)\\) by splitting the summation.\n\n_A.2-4_\n\nApproximate \\(\\sum_{k=1}^{n}k^{\\,3}\\) with an integral.\n\n_A.2-5_\n\nWhy can't you use the integral approximation (A.19) directly on \\(\\sum_{k=1}^{n}1/k\\) to obtain an upper bound on the \\(n\\)th harmonic number?\n\n## Problems\n\n_A-1 Bounding summations_\n\nGive asymptotically tight bounds on the following summations. Assume that \\(r\\geq 0\\) and \\(s\\geq 0\\) are constants.\n\n_a._\\(\\sum_{k=1}^{n}k^{\\,r}\\).\n\n_b._\\(\\sum_{k=1}^{n}\\lg^{s}k\\).\n\n_c._\\(\\sum_{k=1}^{n}k^{\\,r}\\lg^{s}k\\).\n\n## Appendix notes\n\nKnuth [259] provides an excellent reference for the material presented here. You can find basic properties of series in any good calculus book, such as Apostol [19], or Thomas et al. [433].",
        "chapter": "Part VIII Appendix: Mathematical Background",
        "section": "A Summations",
        "subsection": "A.2 Bounding summations",
        "subsubsection": "N/A"
    },
    {
        "content": "_A.2-3_\n\nShow that the \\(n\\)th harmonic number is \\(\\Omega(\\lg n)\\) by splitting the summation.\n\n_A.2-4_\n\nApproximate \\(\\sum_{k=1}^{n}k^{\\,3}\\) with an integral.\n\n_A.2-5_\n\nWhy can't you use the integral approximation (A.19) directly on \\(\\sum_{k=1}^{n}1/k\\) to obtain an upper bound on the \\(n\\)th harmonic number?\n\n## Problems\n\n_A-1 Bounding summations_\n\nGive asymptotically tight bounds on the following summations. Assume that \\(r\\geq 0\\) and \\(s\\geq 0\\) are constants.\n\n_a._\\(\\sum_{k=1}^{n}k^{\\,r}\\).\n\n_b._\\(\\sum_{k=1}^{n}\\lg^{s}k\\).\n\n_c._\\(\\sum_{k=1}^{n}k^{\\,r}\\lg^{s}k\\).\n\n## Appendix notes\n\nKnuth [259] provides an excellent reference for the material presented here. You can find basic properties of series in any good calculus book, such as Apostol [19], or Thomas et al. [433].",
        "chapter": "Part VIII Appendix: Mathematical Background",
        "section": "A Summations",
        "subsection": "Problems",
        "subsubsection": "N/A"
    },
    {
        "content": "_A.2-3_\n\nShow that the \\(n\\)th harmonic number is \\(\\Omega(\\lg n)\\) by splitting the summation.\n\n_A.2-4_\n\nApproximate \\(\\sum_{k=1}^{n}k^{\\,3}\\) with an integral.\n\n_A.2-5_\n\nWhy can't you use the integral approximation (A.19) directly on \\(\\sum_{k=1}^{n}1/k\\) to obtain an upper bound on the \\(n\\)th harmonic number?\n\n## Problems\n\n_A-1 Bounding summations_\n\nGive asymptotically tight bounds on the following summations. Assume that \\(r\\geq 0\\) and \\(s\\geq 0\\) are constants.\n\n_a._\\(\\sum_{k=1}^{n}k^{\\,r}\\).\n\n_b._\\(\\sum_{k=1}^{n}\\lg^{s}k\\).\n\n_c._\\(\\sum_{k=1}^{n}k^{\\,r}\\lg^{s}k\\).\n\n## Appendix notes\n\nKnuth [259] provides an excellent reference for the material presented here. You can find basic properties of series in any good calculus book, such as Apostol [19], or Thomas et al. [433].\n\n## Appendix B Sets, Etc.\n\nMany chapters of this book touch on the elements of discrete mathematics. This appendix reviews the notations, definitions, and elementary properties of sets, relations, functions, graphs, and trees. If you are already well versed in this material, you can probably just skim this chapter.\n\n### Sets\n\nA _set_ is a collection of distinguishable objects, called its _members_ or _elements_. If an object \\(x\\) is a member of a set \\(S\\), we write \\(x\\in S\\) (read \"\\(x\\) is a member of \\(S\\)\" or, more briefly, \"\\(x\\) belongs to \\(S\\)\"). If \\(x\\) is not a member of \\(S\\), we write \\(x\\notin S\\). To describe a set explicitly, write its members as a list inside braces. For example, to define a set \\(S\\) to contain precisely the numbers \\(1\\), \\(2\\), and \\(3\\), write \\(S=\\{1,2,3\\}\\). Since \\(2\\) belongs to the set \\(S\\), we can write \\(2\\in S\\), and since \\(4\\) is not a member, we can write \\(4\\notin S\\). A set cannot contain the same object more than once,1 and its elements are not ordered. Two sets \\(A\\) and \\(B\\) are _equal_, written \\(A=B\\), if they contain the same elements. For example, \\(\\{1,2,3,1\\}=\\{1,2,3\\}=\\{3,2,1\\}\\).\n\nFootnote 1: A variation of a set, which can contain the same object more than once, is called a _multiset_.\n\nWe adopt special notations for frequently encountered sets:\n\n* \\(\\emptyset\\) denotes the _empty set_, that is, the set containing no members.\n* \\(\\mathbb{Z}\\) denotes the set of _integers_, that is, the set \\(\\{\\ldots,-2,-1,0,1,2,\\ldots\\}\\).\n* \\(\\mathbb{R}\\) denotes the set of _real numbers_.\n* \\(\\mathbb{N}\\) denotes the set of _natural numbers_, that is, the set \\(\\{0,1,2,\\ldots\\}\\).2",
        "chapter": "Part VIII Appendix: Mathematical Background",
        "section": "A Summations",
        "subsection": "Appendix notes",
        "subsubsection": "N/A"
    },
    {
        "content": "## Appendix B Sets, Etc.\n\nMany chapters of this book touch on the elements of discrete mathematics. This appendix reviews the notations, definitions, and elementary properties of sets, relations, functions, graphs, and trees. If you are already well versed in this material, you can probably just skim this chapter.\n\n### Sets\n\nA _set_ is a collection of distinguishable objects, called its _members_ or _elements_. If an object \\(x\\) is a member of a set \\(S\\), we write \\(x\\in S\\) (read \"\\(x\\) is a member of \\(S\\)\" or, more briefly, \"\\(x\\) belongs to \\(S\\)\"). If \\(x\\) is not a member of \\(S\\), we write \\(x\\notin S\\). To describe a set explicitly, write its members as a list inside braces. For example, to define a set \\(S\\) to contain precisely the numbers \\(1\\), \\(2\\), and \\(3\\), write \\(S=\\{1,2,3\\}\\). Since \\(2\\) belongs to the set \\(S\\), we can write \\(2\\in S\\), and since \\(4\\) is not a member, we can write \\(4\\notin S\\). A set cannot contain the same object more than once,1 and its elements are not ordered. Two sets \\(A\\) and \\(B\\) are _equal_, written \\(A=B\\), if they contain the same elements. For example, \\(\\{1,2,3,1\\}=\\{1,2,3\\}=\\{3,2,1\\}\\).\n\nFootnote 1: A variation of a set, which can contain the same object more than once, is called a _multiset_.\n\nWe adopt special notations for frequently encountered sets:\n\n* \\(\\emptyset\\) denotes the _empty set_, that is, the set containing no members.\n* \\(\\mathbb{Z}\\) denotes the set of _integers_, that is, the set \\(\\{\\ldots,-2,-1,0,1,2,\\ldots\\}\\).\n* \\(\\mathbb{R}\\) denotes the set of _real numbers_.\n* \\(\\mathbb{N}\\) denotes the set of _natural numbers_, that is, the set \\(\\{0,1,2,\\ldots\\}\\).2If all the elements of a set \\(A\\) are contained in a set \\(B\\), that is, if \\(x\\in A\\) implies \\(x\\in B\\), then we write \\(A\\subseteq B\\) and say that \\(A\\) is a _subset_ of \\(B\\). A set \\(A\\) is a _proper subset_ of set \\(B\\), written \\(A\\subset B\\), if \\(A\\subseteq B\\) but \\(A\\neq B\\). (Some authors use the symbol \"\\(\\subset\\)\" to denote the ordinary subset relation, rather than the proper-subset relation.) Every set is a subset of itself: \\(A\\subseteq A\\) for any set \\(A\\). For two sets \\(A\\) and \\(B\\), we have \\(A=B\\) if and only if \\(A\\subseteq B\\) and \\(B\\subseteq A\\). The subset relation is transitive (see page 1159): for any three sets \\(A\\), \\(B\\), and \\(C\\), if \\(A\\subseteq B\\) and \\(B\\subseteq C\\), then \\(A\\subseteq C\\). The proper-subset relation is transitive as well. The empty set is a subset of all sets: for any set \\(A\\), we have \\(\\emptyset\\subseteq A\\).\n\nSets can be specified in terms of other sets. Given a set \\(A\\), a set \\(B\\subseteq A\\) can be defined by stating a property that distinguishes the elements of \\(B\\). For example, one way to define the set of even integers is \\(\\{x:x\\in\\mathbb{Z}\\) and \\(x/2\\) is an integer\\(\\}\\). The colon in this notation is read \"such that.\" (Some authors use a vertical bar in place of the colon.)\n\nGiven two sets \\(A\\) and \\(B\\), _set operations_ define new sets:\n\n* The _intersection_ of sets \\(A\\) and \\(B\\) is the set \\(A\\cap B=\\{x:x\\in A\\text{ and }x\\in B\\}\\).\n* The _union_ of sets \\(A\\) and \\(B\\) is the set \\(A\\cup B=\\{x:x\\in A\\text{ or }x\\in B\\}\\).\n* The _difference_ between two sets \\(A\\) and \\(B\\) is the set \\(A-B=\\{x:x\\in A\\text{ and }x\\notin B\\}\\).\n\nSet operations obey the following laws:\n\n**Empty set laws:**\n\n\\(A\\cap\\emptyset\\ =\\ \\emptyset\\),\n\n\\(A\\cup\\emptyset\\ =\\ A\\).\n\n**Idempotency laws:**\n\n\\(A\\cap A\\ =\\ A\\),\n\n\\(A\\cup A\\ =\\ A\\).\n\n**Commutative laws:**\n\n\\(A\\cap B\\ =\\ B\\ \\cap A\\),\n\n\\(A\\cup B\\ =\\ B\\ \\cup A\\).\n\n### Sets\n\n**Associative laws:**\n\n\\[\\begin{array}{l}A\\cap(B\\cap C)\\ =\\ (A\\cap B)\\cap C\\,\\\\ A\\cup(B\\cup C)\\ =\\ (A\\cup B)\\cup C\\.\\end{array}\\]\n\n**Distributive laws:**\n\n\\[\\begin{array}{l}A\\cap(B\\cup C)\\ =\\ (A\\cap B)\\cup(A\\cap C)\\,\\\\ A\\cup(B\\cap C)\\ =\\ (A\\cup B)\\cap(A\\cup C)\\.\\end{array} \\tag{1}\\]\n\n**Absorption laws:**\n\n\\[\\begin{array}{l}A\\cap(A\\cup B)\\ =\\ A\\,\\\\ A\\cup(A\\cap B)\\ =\\ A\\.\\end{array}\\]\n\n**DeMorgan's laws:**\n\n\\[\\begin{array}{l}A-(B\\cap C)\\ =\\ (A-B)\\cup(A-C)\\,\\\\ A-(B\\cup C)\\ =\\ (A-B)\\cap(A-C)\\.\\end{array} \\tag{2}\\]\n\nFigure 1 illustrates the first of DeMorgan's laws, using a _Venn diagram_: a graphical picture in which sets are represented as regions of the plane.\n\nOften, all the sets under consideration are subsets of some larger set \\(U\\) called the _universe_. For example, when considering various sets made up only of integers, the set \\(\\mathbb{Z}\\) of integers is an appropriate universe. Given a universe \\(U\\), we define the _complement_ of a set \\(A\\) as \\(\\overline{A}=U-A=\\{x:x\\in U\\) and \\(x\\notin A\\}\\). For any set \\(A\\subseteq U\\), we have the following laws:\n\n\\[\\overline{\\overline{A}}\\ =\\ A\\,\\]\n\n\\[\\begin{array}{l}A\\cap\\overline{A}\\ =\\ \\emptyset\\,\\\\ A\\cup\\overline{A}\\ =\\ U\\.\\end{array}\\]\n\nFigure 1: A Venn diagram illustrating the first of DeMorgan\u2019s laws (2). Each of the sets \\(A\\), \\(B\\), and \\(C\\) is represented as a circle.\n\nAn equivalent way to express DeMorgan's laws (B.2) uses set complements. For any two sets \\(B,C\\subseteq U\\), we have\n\n\\[\\overline{B\\,\\cap\\,C}\\ =\\ \\overline{B}\\,\\cup\\,\\overline{C}\\,\\] \\[\\overline{B\\,\\cup\\,C}\\ =\\ \\overline{B}\\,\\cap\\,\\overline{C}\\.\\]\n\nTwo sets \\(A\\) and \\(B\\) are _disjoint_ if they have no elements in common, that is, if \\(A\\cap B=\\emptyset\\). A _collection_ of sets \\(S_{1},S_{2},\\ldots,\\) either finite or infinite, is a set of sets, in which each member is a set \\(S_{i}\\). A collection \\(\\delta=\\{S_{i}\\}\\) of nonempty sets forms a _partition_ of a set \\(S\\) if\n\n* the sets are _pairwise disjoint_, that is, \\(S_{i},S_{j}\\in\\delta\\) and \\(i\\neq j\\) imply \\(S_{i}\\cap S_{j}=\\emptyset\\), and\n* their union is \\(S\\), that is, \\[S=\\bigcup_{S_{i}\\,\\in\\,\\delta}S_{i}\\.\\] In other words, \\(\\delta\\) forms a partition of \\(S\\) if each element of \\(S\\) appears in exactly one set \\(S_{i}\\,\\in\\,\\delta\\).\n\nThe number of elements in a set is the _cardinality_ (or _size_) of the set, denoted \\(|S|\\). Two sets have the same cardinality if their elements can be put into a one-to-one correspondence. The cardinality of the empty set is \\(|\\emptyset|=0\\). If the cardinality of a set is a natural number, the set is _finite_, and otherwise, it is _infinite_. An infinite set that can be put into a one-to-one correspondence with the natural numbers \\(\\mathbb{N}\\) is _countably infinite_, and otherwise, it is _uncountable_. For example, the integers \\(\\mathbb{Z}\\) are countable, but the reals \\(\\mathbb{R}\\) are uncountable.\n\nFor any two finite sets \\(A\\) and \\(B\\), we have the identity\n\n\\[|A\\,\\cup\\,B|\\,=\\,|A|\\,+\\,|B|\\,-\\,|A\\,\\cap\\,B|\\,\\] (B.3)\n\nfrom which we can conclude that\n\n\\[|A\\,\\cup\\,B|\\,\\leq\\,|A|\\,+\\,|B|\\.\\]\n\nIf \\(A\\) and \\(B\\) are disjoint, then \\(|A\\cap B|=0\\) and thus \\(|A\\cup B|=|A|+|B|\\). If \\(A\\subseteq B\\), then \\(|A|\\leq|B|\\).\n\nA finite set of \\(n\\) elements is sometimes called an _n-set_. A 1-set is called a _singleton_. A subset of \\(k\\) elements of a set is sometimes called a _k-subset_.\n\nWe denote the set of all subsets of a set \\(S\\), including the empty set and \\(S\\) itself, by \\(2^{S}\\), called the _power set_ of \\(S\\). For example, \\(2^{\\{a,b\\}}=\\{\\emptyset,\\{a\\}\\,,\\{b\\}\\,,\\{a,b\\}\\}\\). The power set of a finite set \\(S\\) has cardinality \\(2^{|S|}\\) (see Exercise B.1-5).\n\nWe sometimes care about seltike structures in which the elements are ordered. An _ordered pair_ of two elements \\(a\\) and \\(b\\) is denoted \\((a,b)\\) and is defined formally as the set \\((a,b)=\\{a,\\{a,b\\}\\}\\). Thus, the ordered pair \\((a,b)\\) is _not_ the same as the ordered pair \\((b,a)\\).\n\nThe _Cartesian product_ of two sets \\(A\\) and \\(B\\), denoted \\(A\\times B\\), is the set of all ordered pairs such that the first element of the pair is an element of \\(A\\) and the second is an element of \\(B\\). More formally,\n\n\\[A\\times B=\\{(a,b):a\\in A\\text{ and }b\\in B\\}\\enspace.\\]\n\nFor example, \\(\\{a,b\\}\\times\\{a,b,c\\}=\\{(a,a),(a,b),(a,c),(b,a),(b,b),(b,c)\\}\\). When \\(A\\) and \\(B\\) are finite sets, the cardinality of their Cartesian product is\n\n\\[|A\\times B|=|A|\\cdot|B|\\enspace.\\] (B.4)\n\nThe Cartesian product of \\(n\\) sets \\(A_{1}\\), \\(A_{2},\\ldots,A_{n}\\) is the set of _n-tuples_\n\n\\(A_{1}\\times A_{2}\\times\\cdots\\times A_{n}=\\{(a_{1},a_{2},\\ldots,a_{n}):a_{i} \\in A_{i}\\text{ for }i=1,2,\\ldots,n\\}\\enspace,\\)\n\nwhose cardinality is\n\n\\[|A_{1}\\times A_{2}\\times\\cdots\\times A_{n}|=|A_{1}|\\cdot|A_{2}|\\cdots|A_{n}|\\]\n\nif all sets \\(A_{i}\\) are finite. We denote an \\(n\\)-fold Cartesian product over a single set \\(A\\) by the set\n\n\\[A^{n}=\\underbrace{A\\times A\\times\\cdots\\times A}_{n\\text{ times}}\\enspace,\\]\n\nwhose cardinality is \\(|A^{n}|=|A|^{n}\\) if \\(A\\) is finite. We can also view an \\(n\\)-tuple as a finite sequence of length \\(n\\) (see page 1162).\n\nIntervals are continuous sets of real numbers. We denote them with parentheses and/or brackets. Given real numbers \\(a\\) and \\(b\\), the _closed interval_\\([a,b]\\) is the set \\(\\{x\\in\\mathbb{R}:a\\leq x\\leq b\\}\\) of reals between \\(a\\) and \\(b\\), including both \\(a\\) and \\(b\\). (If \\(a>b\\), this definition implies that \\([a,b]=\\emptyset\\).) The _open interval_\\((a,b)=\\{x\\in\\mathbb{R}:a<x<b\\}\\) omits both of the endpoints from the set. There are two _half-open intervals_\\([a,b)=\\{x\\in\\mathbb{R}:a\\leq x<b\\}\\) and \\((a,b]=\\{x\\in\\mathbb{R}:a<x\\leq b\\}\\), each of which excludes one endpoint.\n\nIntervals can also be defined on the integers by replacing \\(\\mathbb{R}\\) in the these definitions by \\(\\mathbb{Z}\\). Whether the interval is defined over the reals or integers can usually be inferred from context.\n\nExercises\n\n_B.1-1_\n\nDraw Venn diagrams that illustrate the first of the distributive laws (B.1).\n\n### _B.1-2_\n\nProve the generalization of DeMorgan's laws to any finite collection of sets:\n\n\\[\\begin{array}{l}\\overline{A_{1}\\cap A_{2}\\cap\\cdots\\cap A_{n}}\\ =\\ \\overline{A_{1}}\\cup\\overline{A_{2}}\\cup\\cdots\\cup\\overline{A_{n}}\\,\\\\ \\overline{A_{1}}\\cap\\overline{A_{2}}\\cap\\cdots\\cap\\overline{A_{n}}\\.\\end{array}\\]\n\n* _B.1-3_ Prove the generalization of equation (B.3), which is called the _principle of inclusion and exclusion_: \\[\\begin{array}{l}|A_{1}\\cup A_{2}\\cup\\cdots\\cup A_{n}|=\\\\",
        "chapter": "Part VIII Appendix: Mathematical Background",
        "section": "B Sets, Etc.",
        "subsection": "B.1 Sets",
        "subsubsection": "N/A"
    },
    {
        "content": "### _B.1-2_\n\nProve the generalization of DeMorgan's laws to any finite collection of sets:\n\n\\[\\begin{array}{l}\\overline{A_{1}\\cap A_{2}\\cap\\cdots\\cap A_{n}}\\ =\\ \\overline{A_{1}}\\cup\\overline{A_{2}}\\cup\\cdots\\cup\\overline{A_{n}}\\,\\\\ \\overline{A_{1}}\\cap\\overline{A_{2}}\\cap\\cdots\\cap\\overline{A_{n}}\\.\\end{array}\\]\n\n* _B.1-3_ Prove the generalization of equation (B.3), which is called the _principle of inclusion and exclusion_: \\[\\begin{array}{l}|A_{1}\\cup A_{2}\\cup\\cdots\\cup A_{n}|=\\\\for all \\(a\\in A\\). For example, \"\\(=\\)\" and \"\\(\\leq\\)\" are reflexive relations on \\(\\mathbb{N}\\), but \"\\(<\\)\" is not. The relation \\(R\\) is _symmetric_ if\n\n\\(a\\ R\\ b\\) implies \\(b\\ R\\ a\\)\n\nfor all \\(a,b\\in A\\). For example, \"\\(=\\)\" is symmetric, but \"\\(<\\)\" and \"\\(\\leq\\)\" are not. The relation \\(R\\) is _transitive_ if\n\n\\(a\\ R\\ b\\) and \\(b\\ R\\ c\\) imply \\(a\\ R\\ c\\)\n\nfor all \\(a,b,c\\in A\\). For example, the relations \"\\(<\\),\" \"\\(\\leq\\),\" and \"\\(=\\)\" are transitive, but the relation \\(R=\\{(a,b):a,b\\in\\mathbb{N}\\) and \\(a=b-1\\}\\) is not, since \\(3\\ R\\ 4\\) and \\(4\\ R\\ 5\\) do not imply \\(3\\ R\\ 5\\).\n\nA relation that is reflexive, symmetric, and transitive is an _equivalence relation_. For example, \"\\(=\\)\" is an equivalence relation on the natural numbers, but \"\\(<\\)\" is not. If \\(R\\) is an equivalence relation on a set \\(A\\), then for \\(a\\in A\\), the _equivalence class_ of \\(a\\) is the set \\([a]=\\{b\\in A:a\\ R\\ b\\}\\), that is, the set of all elements equivalent to \\(a\\). For example, if we define \\(R=\\{(a,b):a,b\\in\\mathbb{N}\\) and \\(a+b\\) is an even number\\(\\}\\), then \\(R\\) is an equivalence relation, since \\(a+a\\) is even (reflexive), \\(a+b\\) is even implies \\(b+a\\) is even (symmetric), and \\(a+b\\) is even and \\(b+c\\) is even imply \\(a+c\\) is even (transitive). The equivalence class of \\(4\\) is \\([4]=\\{0,2,4,6,\\ldots\\}\\), and the equivalence class of \\(3\\) is \\([3]=\\{1,3,5,7,\\ldots\\}\\). A basic theorem of equivalence classes is the following.\n\n_Theorem B.1 (An equivalence relation is the same as a partition)_\n\nThe equivalence classes of any equivalence relation \\(R\\) on a set \\(A\\) form a partition of \\(A\\), and any partition of \\(A\\) determines an equivalence relation on \\(A\\) for which the sets in the partition are the equivalence classes.\n\n_Proof_ For the first part of the proof, we must show that the equivalence classes of \\(R\\) are nonempty, pairwise-disjoint sets whose union is \\(A\\). Because \\(R\\) is reflexive, \\(a\\in[a]\\), and so the equivalence classes are nonempty. Moreover, since every element \\(a\\in A\\) belongs to the equivalence class \\([a]\\), the union of the equivalence classes is \\(A\\). It remains to show that the equivalence classes are pairwise disjoint, that is, if two equivalence classes \\([a]\\) and \\([b]\\) have an element \\(c\\) in common, then they are in fact the same set. Suppose that \\(a\\ R\\ c\\) and \\(b\\ R\\ c\\). Symmetry gives that \\(c\\ R\\ b\\) and, by transitivity, \\(a\\ R\\ b\\). Thus, we have \\(x\\ R\\ a\\) for any arbitrary element \\(x\\in[a]\\) and, by transitivity, \\(x\\ R\\ b\\), and thus \\([a]\\subseteq[b]\\). Similarly, \\([b]\\subseteq[a]\\), and thus \\([a]=[b]\\).\n\nFor the second part of the proof, let \\(\\mathcal{A}=\\{A_{i}\\}\\) be a partition of \\(A\\), and define \\(R=\\{(a,b):\\) there exists \\(i\\) such that \\(a\\in A_{i}\\) and \\(b\\in A_{i}\\}\\). We claim that \\(R\\) is an equivalence relation on \\(A\\). Reflexivity holds, since \\(a\\in A_{i}\\) implies \\(a\\ R\\ a\\). Symmetry holds, because if \\(a\\ R\\ b\\), then \\(a\\) and \\(b\\) belong to the same set \\(A_{i}\\), and hence \\(b\\ R\\ a\\). If \\(a\\ R\\ b\\) and \\(b\\ R\\ c\\), then all three elements are in the same set \\(A_{i}\\), and thus \\(a\\ R\\ c\\) and transitivity holds. To see that the sets in the partition are the equivalence classes of \\(R\\), observe that if \\(a\\in A_{i}\\), then \\(x\\in[a]\\) implies \\(x\\in A_{i}\\), and \\(x\\in A_{i}\\) implies \\(x\\in[a]\\).\n\nA binary relation \\(R\\) on a set \\(A\\) is _antisymmetric_ if\n\n\\(a\\ R\\ b\\) and \\(b\\ R\\ a\\) imply \\(a=b\\).\n\nFor example, the \"\\(\\leq\\)\" relation on the natural numbers is antisymmetric, since \\(a\\leq b\\) and \\(b\\leq a\\) imply \\(a=b\\). A relation that is reflexive, antisymmetric, and transitive is a _partial order_, and we call a set on which a partial order is defined a _partially ordered set_. For example, the relation \"is a descendant of\" is a partial order on the set of all people (if we view individuals as being their own descendants).\n\nIn a partially ordered set \\(A\\), there may be no single \"maximum\" element \\(a\\) such that \\(b\\ R\\ a\\) for all \\(b\\in A\\). Instead, the set may contain several _maximal_ elements \\(a\\) such that for no \\(b\\in A\\), where \\(b\\neq a\\), is it the case that \\(a\\ R\\ b\\). For example, a collection of different-sized boxes may contain several maximal boxes that don't fit inside any other box, yet it has no single \"maximum\" box into which any other box will fit.3\n\nFootnote 3: To be precise, in order for the \u201cfit inside\u201d relation to be a partial order, we need to view a box as fitting inside itself.\n\nA relation \\(R\\) on a set \\(A\\) is a _total relation_ if for all \\(a,b\\in A\\), we have \\(a\\ R\\ b\\) or \\(b\\ R\\ a\\) (or both), that is, if every pairing of elements of \\(A\\) is related by \\(R\\). A partial order that is also a total relation is a _total order_ or _linear order_. For example, the relation \"\\(\\leq\\)\" is a total order on the natural numbers, but the \"is a descendant of\" relation is not a total order on the set of all people, since there are individuals neither of whom is descended from the other. A total relation that is transitive, but not necessarily either symmetric or antisymmetric, is a _total preorder_.\n\n## Exercises\n\n### _B.2-1_\n\nProve that the subset relation \"\\(\\subseteq\\)\" on all subsets of \\(\\mathbb{Z}\\) is a partial order but not a total order.\n\n### _B.2-2_\n\nShow that for any positive integer \\(n\\), the relation \"equivalent modulo \\(n\\)\" is an equivalence relation on the integers. (We say that \\(a=b\\pmod{n}\\) if there exists an integer \\(q\\) such that \\(a-b=qn\\).) Into what equivalence classes does this relation partition the integers?\n\n### Functions\n\n_B.2-3_\n\nGive examples of relations that are\n\n_a._ reflexive and symmetric but not transitive,\n\n_b._ reflexive and transitive but not symmetric,\n\n_c._ symmetric and transitive but not reflexive.\n\n_B.2-4_\n\nLet \\(S\\) be a finite set, and let \\(R\\) be an equivalence relation on \\(S\\times S\\). Show that if in addition \\(R\\) is antisymmetric, then the equivalence classes of \\(S\\) with respect to \\(R\\) are singletons.\n\n_B.2-5_\n\nProfessor Narcissus claims that if a relation \\(R\\) is symmetric and transitive, then it is also reflexive. He offers the following proof. By symmetry, \\(a\\)\\(R\\)\\(b\\) implies \\(b\\)\\(R\\)\\(a\\). Transitivity, therefore, implies \\(a\\)\\(R\\)\\(a\\). Is the professor correct?\n\n### Functions\n\nGiven two sets \\(A\\) and \\(B\\), a _function_\\(f\\) is a binary relation on \\(A\\) and \\(B\\) such that for all \\(a\\in A\\), there exists precisely one \\(b\\in B\\) such that \\((a,b)\\in f\\). The set \\(A\\) is called the _domain_ of \\(f\\), and the set \\(B\\) is called the _codomain_ of \\(f\\). We sometimes write \\(f:A\\to B\\), and if \\((a,b)\\in f\\), we write \\(b\\,=\\,f(a)\\), since the choice of \\(a\\) uniquely determines \\(b\\).\n\nIntuitively, the function \\(f\\) assigns an element of \\(B\\) to each element of \\(A\\). No element of \\(A\\) is assigned two different elements of \\(B\\), but the same element of \\(B\\) can be assigned to two different elements of \\(A\\). For example, the binary relation\n\n\\(f=\\{(a,b):a,b\\in\\mathbb{N}\\) and \\(b\\)\\(=\\)\\(a\\) mod 2\\(\\}\\)\n\nis a function \\(f:\\mathbb{N}\\,\\rightarrow\\{0,1\\}\\), since for each natural number \\(a\\), there is exactly one value \\(b\\) in \\(\\{0,1\\}\\) such that \\(b\\,=\\)\\(a\\) mod 2. For this example, \\(0\\,=\\,f(0)\\), \\(1\\,=\\,f(1)\\), \\(0\\,=\\,f(2)\\), \\(1\\,=\\,f(3)\\), etc. In contrast, the binary relation\n\n\\(g=\\{(a,b):a,b\\in\\mathbb{N}\\) and \\(a\\,+\\,b\\) is even\\(\\}\\)\n\nis not a function, since \\((1,3)\\) and \\((1,5)\\) are both in \\(g\\), and thus for the choice \\(a\\,=\\,1\\), there is not precisely one \\(b\\) such that \\((a,b)\\in g\\).\n\nGiven a function \\(f:A\\,\\rightarrow\\,B\\), if \\(b\\,=\\,f(a)\\), we say that \\(a\\) is the _argument_ of \\(f\\) and that \\(b\\) is the _value_ of \\(f\\) at \\(a\\). We can define a function by stating its value for",
        "chapter": "Part VIII Appendix: Mathematical Background",
        "section": "B Sets, Etc.",
        "subsection": "B.2 Relations",
        "subsubsection": "N/A"
    },
    {
        "content": "### Functions\n\n_B.2-3_\n\nGive examples of relations that are\n\n_a._ reflexive and symmetric but not transitive,\n\n_b._ reflexive and transitive but not symmetric,\n\n_c._ symmetric and transitive but not reflexive.\n\n_B.2-4_\n\nLet \\(S\\) be a finite set, and let \\(R\\) be an equivalence relation on \\(S\\times S\\). Show that if in addition \\(R\\) is antisymmetric, then the equivalence classes of \\(S\\) with respect to \\(R\\) are singletons.\n\n_B.2-5_\n\nProfessor Narcissus claims that if a relation \\(R\\) is symmetric and transitive, then it is also reflexive. He offers the following proof. By symmetry, \\(a\\)\\(R\\)\\(b\\) implies \\(b\\)\\(R\\)\\(a\\). Transitivity, therefore, implies \\(a\\)\\(R\\)\\(a\\). Is the professor correct?\n\n### Functions\n\nGiven two sets \\(A\\) and \\(B\\), a _function_\\(f\\) is a binary relation on \\(A\\) and \\(B\\) such that for all \\(a\\in A\\), there exists precisely one \\(b\\in B\\) such that \\((a,b)\\in f\\). The set \\(A\\) is called the _domain_ of \\(f\\), and the set \\(B\\) is called the _codomain_ of \\(f\\). We sometimes write \\(f:A\\to B\\), and if \\((a,b)\\in f\\), we write \\(b\\,=\\,f(a)\\), since the choice of \\(a\\) uniquely determines \\(b\\).\n\nIntuitively, the function \\(f\\) assigns an element of \\(B\\) to each element of \\(A\\). No element of \\(A\\) is assigned two different elements of \\(B\\), but the same element of \\(B\\) can be assigned to two different elements of \\(A\\). For example, the binary relation\n\n\\(f=\\{(a,b):a,b\\in\\mathbb{N}\\) and \\(b\\)\\(=\\)\\(a\\) mod 2\\(\\}\\)\n\nis a function \\(f:\\mathbb{N}\\,\\rightarrow\\{0,1\\}\\), since for each natural number \\(a\\), there is exactly one value \\(b\\) in \\(\\{0,1\\}\\) such that \\(b\\,=\\)\\(a\\) mod 2. For this example, \\(0\\,=\\,f(0)\\), \\(1\\,=\\,f(1)\\), \\(0\\,=\\,f(2)\\), \\(1\\,=\\,f(3)\\), etc. In contrast, the binary relation\n\n\\(g=\\{(a,b):a,b\\in\\mathbb{N}\\) and \\(a\\,+\\,b\\) is even\\(\\}\\)\n\nis not a function, since \\((1,3)\\) and \\((1,5)\\) are both in \\(g\\), and thus for the choice \\(a\\,=\\,1\\), there is not precisely one \\(b\\) such that \\((a,b)\\in g\\).\n\nGiven a function \\(f:A\\,\\rightarrow\\,B\\), if \\(b\\,=\\,f(a)\\), we say that \\(a\\) is the _argument_ of \\(f\\) and that \\(b\\) is the _value_ of \\(f\\) at \\(a\\). We can define a function by stating its value forevery element of its domain. For example, we might define \\(f(n)=2n\\) for \\(n\\in\\mathbb{N}\\), which means \\(f=\\{(n,2n):n\\in\\mathbb{N}\\}\\). Two functions \\(f\\) and \\(g\\) are _equal_ if they have the same domain and codomain and if \\(f(a)=g(a)\\) for all \\(a\\) in the domain.\n\nA _finite sequence_ of length \\(n\\) is a function \\(f\\) whose domain is the set of \\(n\\) integers \\(\\{0,1,\\ldots,n-1\\}\\). We often denote a finite sequence by listing its values in angle brackets: \\(\\langle f(0),\\,f(1),\\ldots,\\,f(n-1)\\rangle\\). An _infinite sequence_ is a function whose domain is the set \\(\\mathbb{N}\\) of natural numbers. For example, the Fibonacci sequence, defined by recurrence (3.31), is the infinite sequence \\(\\langle 0,1,1,2,3,5,8,13,21,\\ldots\\rangle\\).\n\nWhen the domain of a function \\(f\\) is a Cartesian product, we often omit the extra parentheses surrounding the argument of \\(f\\). For example, if we have a function \\(f:A_{1}\\times A_{2}\\times\\cdots\\times A_{n}\\to B\\), we write \\(b=f(a_{1},a_{2},\\ldots,a_{n})\\) instead of writing \\(b=f((a_{1},a_{2},\\ldots,a_{n}))\\). We also call each \\(a_{i}\\) an _argument_ to the function \\(f\\), though technically \\(f\\) has just a single argument, which is the \\(n\\)-tuple \\((a_{1},a_{2},\\ldots,a_{n})\\).\n\nIf \\(f:A\\to B\\) is a function and \\(b=f(a)\\), then we sometimes say that \\(b\\) is the _image_ of \\(a\\) under \\(f\\). The image of a set \\(A^{\\prime}\\subseteq A\\) under \\(f\\) is defined by\n\n\\[f(A^{\\prime})=\\{b\\in B:b=f(a)\\mbox{ for some }a\\in A^{\\prime}\\}\\enspace.\\]\n\nThe _range_ of \\(f\\) is the image of its domain, that is, \\(f(A)\\). For example, the range of the function \\(f:\\mathbb{N}\\to\\mathbb{N}\\) defined by \\(f(n)=2n\\) is \\(f(\\mathbb{N})=\\{m:m=2n\\) for some \\(n\\in\\mathbb{N}\\}\\), in other words, the set of nonnegative even integers.\n\nA function is a _surjection_ if its range is its codomain. For example, the function \\(f(n)=\\lfloor n/2\\rfloor\\) is a surjective function from \\(\\mathbb{N}\\) to \\(\\mathbb{N}\\), since every element in \\(\\mathbb{N}\\) appears as the value of \\(f\\) for some argument. In contrast, the function \\(f(n)=2n\\) is not a surjective function from \\(\\mathbb{N}\\) to \\(\\mathbb{N}\\), since no argument to \\(f\\) can produce any odd natural number as a value. The function \\(f(n)=2n\\) is, however, a surjective function from the natural numbers to the even numbers. A surjection \\(f:A\\to B\\) is sometimes described as mapping \\(A\\)_onto_\\(B\\). When we say that \\(f\\) is onto, we mean that it is surjective.\n\nA function \\(f:A\\to B\\) is an _injection_ if distinct arguments to \\(f\\) produce distinct values, that is, if \\(a\\neq a^{\\prime}\\) implies \\(f(a)\\neq f(a^{\\prime})\\). For example, the function \\(f(n)=2n\\) is an injective function from \\(\\mathbb{N}\\) to \\(\\mathbb{N}\\), since each even number \\(b\\) is the image under \\(f\\) of at most one element of the domain, namely \\(b/2\\). The function \\(f(n)=\\lfloor n/2\\rfloor\\) is not injective, since the value \\(1\\) is produced by two arguments: \\(f(2)=1\\) and \\(f(3)=1\\). An injection is sometimes called a _one-to-one_ function.\n\nA function \\(f:A\\to B\\) is a _bijection_ if it is injective and surjective. For example, the function \\(f(n)=(-1)^{n}\\lceil n/2\\rceil\\) is a bijection from \\(\\mathbb{N}\\) to \\(\\mathbb{Z}\\):\n\n### Functions\n\n\\[\\begin{array}{ll}0&\\to&0\\,\\\\ 1&\\to&-1\\,\\\\ 2&\\to&1\\,\\\\ 3&\\to&-2\\,\\\\ 4&\\to&2\\,\\\\ &\\vdots\\end{array}\\]\n\nThe function is injective, since no element of \\(\\mathbb{Z}\\) is the image of more than one element of \\(\\mathbb{N}\\). It is surjective, since every element of \\(\\mathbb{Z}\\) appears as the image of some element of \\(\\mathbb{N}\\). Hence, the function is bijective. A bijection is sometimes called a _one-to-one correspondence_, since it pairs elements in the domain and codomain. A bijection from a set \\(A\\) to itself is sometimes called a _permutation_.\n\nWhen a function \\(f\\) is bijective, we define its _inverse_\\(f^{-1}\\) as\n\n\\[f^{-1}(b)=a\\ \\mbox{if and only if}\\ f(a)=b\\.\\]\n\nFor example, the inverse of the function \\(f(n)=(-1)^{n}\\left\\lceil n/2\\right\\rceil\\) is\n\n\\[f^{-1}(m)=\\left\\{\\begin{array}{ll}2m&\\mbox{if}\\ m\\geq 0\\,\\\\ -2m-1&\\mbox{if}\\ m<0\\.\\end{array}\\right.\\]\n\n**Exercises**\n\n_B.3-1_\n\nLet \\(A\\) and \\(B\\) be finite sets, and let \\(f:A\\to B\\) be a function. Show the following:\n\n_a._ If \\(f\\) is injective, then \\(|A|\\leq|B|\\).\n\n_b._ If \\(f\\) is surjective, then \\(|A|\\geq|B|\\).\n\n_B.3-2_\n\nIs the function \\(f(x)=x+1\\) bijective when the domain and the codomain are the set \\(\\mathbb{N}\\)? Is it bijective when the domain and the codomain are the set \\(\\mathbb{Z}\\)?\n\n_B.3-3_\n\nGive a natural definition for the inverse of a binary relation such that if a relation is in fact a bijective function, its relational inverse is its functional inverse.\n\n_B.3-4_\n\nGive a bijection from \\(\\mathbb{Z}\\) to \\(\\mathbb{Z}\\times\\mathbb{Z}\\).\n\n### Graphs\n\nThis section presents two kinds of graphs: directed and undirected. Certain definitions in the literature differ from those given here, but for the most part, the differences are slight. Section 20.1 shows how to represent graphs in computer memory.\n\nA _directed graph_ (or _digraph_) \\(G\\) is a pair \\((V,E)\\), where \\(V\\) is a finite set and \\(E\\) is a binary relation on \\(V\\). The set \\(V\\) is called the _vertex set_ of \\(G\\), and its elements are called _vertices_ (singular: _vertex_). The set \\(E\\) is called the _edge set_ of \\(G\\), and its elements are called _edges_. Figure B.2(a) is a pictorial representation of a directed graph on the vertex set \\(\\{1,2,3,4,5,6\\}\\). Vertices are represented by circles in the figure, and edges are represented by arrows. _Self-loops_--edges from a vertex to itself -- are possible.\n\nIn an _undirected graph_\\(G=(V,E)\\), the edge set \\(E\\) consists of _unordered_ pairs of vertices, rather than ordered pairs. That is, an edge is a set \\(\\{u,v\\}\\), where \\(u,v\\in V\\) and \\(u\\neq v\\). By convention, we use the notation \\((u,v)\\) for an edge, rather than the set notation \\(\\{u,v\\}\\), and we consider \\((u,v)\\) and \\((v,u)\\) to be the same edge. In an undirected graph, self-loops are forbidden, so that every edge consists of two distinct vertices. Figure B.2(b) shows an undirected graph on the vertex set \\(\\{1,2,3,4,5,6\\}\\).\n\nMany definitions for directed and undirected graphs are the same, although certain terms have slightly different meanings in the two contexts. If \\((u,v)\\) is an edge in a directed graph \\(G=(V,E)\\), we say that \\((u,v)\\) is _incident from_ or _leaves_ vertex \\(u\\) and is _incident to_ or _enters_ vertex \\(v\\). For example, the edges leaving vertex 2",
        "chapter": "Part VIII Appendix: Mathematical Background",
        "section": "B Sets, Etc.",
        "subsection": "B.3 Functions",
        "subsubsection": "N/A"
    },
    {
        "content": "### Graphs\n\nThis section presents two kinds of graphs: directed and undirected. Certain definitions in the literature differ from those given here, but for the most part, the differences are slight. Section 20.1 shows how to represent graphs in computer memory.\n\nA _directed graph_ (or _digraph_) \\(G\\) is a pair \\((V,E)\\), where \\(V\\) is a finite set and \\(E\\) is a binary relation on \\(V\\). The set \\(V\\) is called the _vertex set_ of \\(G\\), and its elements are called _vertices_ (singular: _vertex_). The set \\(E\\) is called the _edge set_ of \\(G\\), and its elements are called _edges_. Figure B.2(a) is a pictorial representation of a directed graph on the vertex set \\(\\{1,2,3,4,5,6\\}\\). Vertices are represented by circles in the figure, and edges are represented by arrows. _Self-loops_--edges from a vertex to itself -- are possible.\n\nIn an _undirected graph_\\(G=(V,E)\\), the edge set \\(E\\) consists of _unordered_ pairs of vertices, rather than ordered pairs. That is, an edge is a set \\(\\{u,v\\}\\), where \\(u,v\\in V\\) and \\(u\\neq v\\). By convention, we use the notation \\((u,v)\\) for an edge, rather than the set notation \\(\\{u,v\\}\\), and we consider \\((u,v)\\) and \\((v,u)\\) to be the same edge. In an undirected graph, self-loops are forbidden, so that every edge consists of two distinct vertices. Figure B.2(b) shows an undirected graph on the vertex set \\(\\{1,2,3,4,5,6\\}\\).\n\nMany definitions for directed and undirected graphs are the same, although certain terms have slightly different meanings in the two contexts. If \\((u,v)\\) is an edge in a directed graph \\(G=(V,E)\\), we say that \\((u,v)\\) is _incident from_ or _leaves_ vertex \\(u\\) and is _incident to_ or _enters_ vertex \\(v\\). For example, the edges leaving vertex 2in Figure B.2(a) are \\((2,2)\\), \\((2,4)\\), and \\((2,5)\\). The edges entering vertex \\(2\\) are \\((1,2)\\) and \\((2,2)\\). If \\((u,v)\\) is an edge in an undirected graph \\(G=(V,E)\\), we say that \\((u,v)\\) is _incident on_ vertices \\(u\\) and \\(v\\). In Figure B.2(b), the edges incident on vertex \\(2\\) are \\((1,2)\\) and \\((2,5)\\).\n\nIf \\((u,v)\\) is an edge in a graph \\(G=(V,E)\\), we say that vertex \\(v\\) is _adjacent_ to vertex \\(u\\). When the graph is undirected, the adjacency relation is symmetric. When the graph is directed, the adjacency relation is not necessarily symmetric. If \\(v\\) is adjacent to \\(u\\) in a directed graph, we can write \\(u\\to v\\). In parts (a) and (b) of Figure B.2, vertex \\(2\\) is adjacent to vertex \\(1\\), since the edge \\((1,2)\\) belongs to both graphs. Vertex \\(1\\) is _not_ adjacent to vertex \\(2\\) in Figure B.2(a), since the edge \\((2,1)\\) is absent.\n\nThe _degree_ of a vertex in an undirected graph is the number of edges incident on it. For example, vertex \\(2\\) in Figure B.2(b) has degree \\(2\\). A vertex whose degree is \\(0\\), such as vertex \\(4\\) in Figure B.2(b), is _isolated_. In a directed graph, the _out-degree_ of a vertex is the number of edges leaving it, and the _in-degree_ of a vertex is the number of edges entering it. The _degree_ of a vertex in a directed graph is its indegree plus its out-degree. Vertex \\(2\\) in Figure B.2(a) has in-degree \\(2\\), out-degree \\(3\\), and degree \\(5\\).\n\nA _path_ of _length_\\(k\\) from a vertex \\(u\\) to a vertex \\(u^{\\prime}\\) in a graph \\(G=(V,E)\\) is a sequence \\(\\langle v_{0},\\,v_{1},\\,v_{2},\\,\\ldots,\\,v_{k}\\rangle\\) of vertices such that \\(u=v_{0}\\), \\(u^{\\prime}=v_{k}\\), and \\((v_{i-1},v_{i})\\in E\\) for \\(i=1,2,\\ldots,k\\). The length of the path is the number of edges in the path, which is \\(1\\) less than the number of vertices in the path. The path _contains_ the vertices \\(v_{0},v_{1},\\ldots,v_{k}\\) and the edges \\((v_{0},v_{1}),(v_{1},v_{2}),\\ldots,(v_{k-1},v_{k})\\). (There is always a \\(0\\)-length path from \\(u\\) to \\(u\\).) If there is a path \\(p\\) from \\(u\\) to \\(u^{\\prime}\\), we say that \\(u^{\\prime}\\) is _reachable_ from \\(u\\) via \\(p\\), which we can write as \\(u\\mathrel{\\mathop{\\kern 0.0pt\\sim}\\limits^{p}}u^{\\prime}\\). A path is _simple_4 if all vertices in the path are distinct. In Figure B.2(a), the path \\(\\langle 1,\\,2,\\,5,\\,4\\rangle\\) is a simple path of length \\(3\\). The path \\(\\langle 2,\\,5,\\,4,\\,5\\rangle\\) is not simple. A _subpath_ of path \\(p=\\langle v_{0},\\,v_{1},\\ldots,v_{k}\\rangle\\) is a contiguous subsequence of its vertices. That is, for any \\(0\\leq i\\leq j\\leq k\\), the subsequence of vertices \\(\\langle v_{i},v_{i+1},\\ldots,v_{j}\\rangle\\) is a subpath of \\(p\\).\n\nFootnote 4: Some authors refer to what we call a path as a \u201cwalk\u201d and to what we call a simple path as just a \u201cpath.\u201d\n\nIn a directed graph, a path \\(\\langle v_{0},\\,v_{1},\\,\\ldots,\\,v_{k}\\rangle\\) forms a _cycle_ if \\(v_{0}=v_{k}\\) and the path contains at least one edge. The cycle is _simple_ if, in addition, \\(v_{1},v_{2},\\ldots,v_{k}\\) are distinct. A cycle consisting of \\(k\\) vertices has _length_\\(k\\). A self-loop is a cycle of length \\(1\\). Two paths \\(\\langle v_{0},\\,v_{1},\\,v_{2},\\,\\ldots,\\,v_{k-1},\\,v_{0}\\rangle\\) and \\(\\langle v_{0}^{\\prime},\\,v_{1}^{\\prime},\\,v_{2}^{\\prime},\\,\\ldots,\\,v_{k-1}^{ \\prime},\\,v_{0}^{\\prime}\\rangle\\) form the same cycle if there exists an integer \\(j\\) such that \\(v_{i}^{\\prime}=v_{(i+j)\\bmod k}\\) for \\(i=0,1,\\ldots,k-1\\). In Figure B.2(a), the path \\(\\langle 1,2,4,1\\rangle\\) forms the same cycle as the paths \\(\\langle 2,4,1,2\\rangle\\) and \\(\\langle 4,1,2,4\\rangle\\). This cycle is simple, but the cycle \\(\\langle 1,2,4,5,4,1\\rangle\\) is not. The cycle \\(\\langle 2,\\,2\\rangle\\) formed by the edge \\((2,2)\\) is a self-loop. A directed graph with no self-loops is _simple_. In an undirected graph, a path \\(\\langle v_{0},v_{1},\\ldots,v_{k}\\rangle\\) forms a _cycle_ if \\(k>0\\), \\(v_{0}=v_{k}\\), and all edges on the path are distinct. The cycle is _simple_ if \\(v_{1},v_{2},\\ldots,v_{k}\\) are distinct. For example, in Figure B.2(b), the path \\(\\langle 1,2,5,1\\rangle\\) is a simple cycle. A graph with no simple cycles is _acyclic_.\n\nAn undirected graph is _connected_ if every vertex is reachable from all other vertices. The _connected components_ of an undirected graph are the equivalence classes of vertices under the \"is reachable from\" relation. The graph shown in Figure B.2(b) has three connected components: \\(\\{1,2,5\\}\\), \\(\\{3,6\\}\\), and \\(\\{4\\}\\). Every vertex in the connected component \\(\\{1,2,5\\}\\) is reachable from every other vertex in \\(\\{1,2,5\\}\\). An undirected graph is connected if it has exactly one connected component. The edges of a connected component are those that are incident on only the vertices of the component. In other words, edge \\((u,v)\\) is an edge of a connected component only if both \\(u\\) and \\(v\\) are vertices of the component.\n\nA directed graph is _strongly connected_ if every two vertices are reachable from each other. The _strongly connected components_ of a directed graph are the equivalence classes of vertices under the \"are mutually reachable\" relation. A directed graph is strongly connected if it has only one strongly connected component. The graph in Figure B.2(a) has three strongly connected components: \\(\\{1,2,4,5\\}\\), \\(\\{3\\}\\), and \\(\\{6\\}\\). All pairs of vertices in \\(\\{1,2,4,5\\}\\) are mutually reachable. The vertices \\(\\{3,6\\}\\) do not form a strongly connected component, since vertex \\(6\\) cannot be reached from vertex \\(3\\).\n\nTwo graphs \\(G=(V,E)\\) and \\(G^{\\prime}=(V^{\\prime},E^{\\prime})\\) are _isomorphic_ if there exists a bijection \\(f:V\\to V^{\\prime}\\) such that \\((u,v)\\in E\\) if and only if \\((f(u),f(v))\\in E^{\\prime}\\). In other words, \\(G\\) and \\(G^{\\prime}\\) are isomorphic if the vertices of \\(G\\) can be relabeled to be vertices of \\(G^{\\prime}\\), maintaining the corresponding edges in \\(G\\) and \\(G^{\\prime}\\). Figure B.3(a) shows a pair of isomorphic graphs \\(G\\) and \\(G^{\\prime}\\) with respective vertex sets \\(V=\\{1,2,3,4,5,6\\}\\) and \\(V^{\\prime}=\\{u,v,w,x,y,z\\}\\). The mapping from \\(V\\) to \\(V^{\\prime}\\) given by \\(f(1)=u,f(2)=v,f(3)=w,f(4)=x,f(5)=y,f(6)=z\\) provides the required bijective function. The graphs in Figure B.3(b) are not isomorphic. Although both graphs have \\(5\\) vertices and \\(7\\) edges, the top graph has a vertex of degree \\(4\\) and the bottom graph does not.\n\nWe say that a graph \\(G^{\\prime}=(V^{\\prime},E^{\\prime})\\) is a _subgraph_ of \\(G=(V,E)\\) if \\(V^{\\prime}\\subseteq V\\) and \\(E^{\\prime}\\subseteq E\\). Given a set \\(V^{\\prime}\\subseteq V\\), the subgraph of \\(G\\)_induced_ by \\(V^{\\prime}\\) is the graph \\(G^{\\prime}=(V^{\\prime},E^{\\prime})\\), where\n\n\\[E^{\\prime}=\\{(u,v)\\in E:u,v\\in V^{\\prime}\\}\\enspace.\\]\n\nThe subgraph induced by the vertex set \\(\\{1,2,3,6\\}\\) in Figure B.2(a) appears in Figure B.2(c) and has the edge set \\(\\{(1,2),(2,2),(6,3)\\}\\).\n\nGiven an undirected graph \\(G=(V,E)\\), the _directed version_ of \\(G\\) is the directed graph \\(G^{\\prime}=(V,E^{\\prime})\\), where \\((u,v)\\in E^{\\prime}\\) if and only if \\((u,v)\\in E\\). That is, each undirected edge \\((u,v)\\) in \\(G\\) turns into two directed edges, \\((u,v)\\) and \\((v,u)\\), in the \n\n### Graphsconnects an arbitrary subset of vertices. Many algorithms written for ordinary directed and undirected graphs can be adapted to run on these graphlike structures.\n\nThe _contraction_ of an undirected graph \\(G=(V,E)\\) by an edge \\(e=(u,v)\\) is a graph \\(G^{\\prime}=(V^{\\prime},E^{\\prime})\\), where \\(V^{\\prime}=V-\\{u,v\\}\\cup\\{x\\}\\) and \\(x\\) is a new vertex. The set of edges \\(E^{\\prime}\\) is formed from \\(E\\) by deleting the edge \\((u,v)\\) and, for each vertex \\(w\\) adjacent to \\(u\\) or \\(v\\), deleting whichever of \\((u,w)\\) and \\((v,w)\\) belongs to \\(E\\) and adding the new edge \\((x,w)\\). In effect, \\(u\\) and \\(v\\) are \"contracted\" into a single vertex.\n\n## Exercises\n\n#### B.4-1\n\nAttendees of a faculty party shake hands to greet each other, with every pair of professors shaking hands one time. Each professor remembers the number of times he or she shook hands. At the end of the party, the department head asks the professors for their totals and adds them all up. Show that the result is even by proving the _handshaking lemma_: if \\(G=(V,E)\\) is an undirected graph, then\n\n\\[\\sum_{v\\in V}\\text{degree}(v)=2\\left|E\\right|\\.\\]\n\n#### B.4-2\n\nShow that if a directed or undirected graph contains a path between two vertices \\(u\\) and \\(v\\), then it contains a simple path between \\(u\\) and \\(v\\). Show that if a directed graph contains a cycle, then it contains a simple cycle.\n\n#### B.4-3\n\nShow that any connected, undirected graph \\(G=(V,E)\\) satisfies \\(\\left|E\\right|\\geq\\left|V\\right|-1\\).\n\n#### B.4-4\n\nVerify that in an undirected graph, the \"is reachable from\" relation is an equivalence relation on the vertices of the graph. Which of the three properties of an equivalence relation hold in general for the \"is reachable from\" relation on the vertices of a directed graph?\n\n#### B.4-5\n\nWhat is the undirected version of the directed graph in Figure 2(a)? What is the directed version of the undirected graph in Figure 2(b)?\n\n#### B.4-6\n\nShow how a bipartite graph can represent a hypergraph by letting incidence in the hypergraph correspond to adjacency in the bipartite graph. (_Hint:_ Let one set of vertices in the bipartite graph correspond to vertices of the hypergraph, and let the other set of vertices of the bipartite graph correspond to hyperedges.)\n\n### Trees\n\nAs with graphs, there are many related, but slightly different, notions of trees. This section presents definitions and mathematical properties of several kinds of trees. Sections 10.3 and 20.1 describe how to represent trees in computer memory.\n\n#### b.5.1 Free trees\n\nAs defined in Section B.4, a _free tree_ is a connected, acyclic, undirected graph. We often omit the adjective \"free\" when we say that a graph is a tree. If an undirected graph is acyclic but possibly disconnected, it is a _forest_. Many algorithms that work for trees also work for forests. Figure B.4(a) shows a free tree, and Figure B.4(b) shows a forest. The forest in Figure B.4(b) is not a tree because it is not connected. The graph in Figure B.4(c) is connected but neither a tree nor a forest, because it contains a cycle.\n\nThe following theorem captures many important facts about free trees.\n\n**Theorem B.2** (Properties of free trees): Let \\(G=(V,E)\\) be an undirected graph. The following statements are equivalent.\n\n1. \\(G\\) is a free tree.\n2. Any two vertices in \\(G\\) are connected by a unique simple path.\n3. \\(G\\) is connected, but if any edge is removed from \\(E\\), the resulting graph is disconnected.\n\nFigure B.4: **(a)** A free tree. **(b)** A forest. **(c)** A graph that contains a cycle and is therefore neither a tree nor a forest.",
        "chapter": "Part VIII Appendix: Mathematical Background",
        "section": "B Sets, Etc.",
        "subsection": "B.4 Graphs",
        "subsubsection": "N/A"
    },
    {
        "content": "vertices in the bipartite graph correspond to vertices of the hypergraph, and let the other set of vertices of the bipartite graph correspond to hyperedges.)\n\n### Trees\n\nAs with graphs, there are many related, but slightly different, notions of trees. This section presents definitions and mathematical properties of several kinds of trees. Sections 10.3 and 20.1 describe how to represent trees in computer memory.\n\n#### b.5.1 Free trees\n\nAs defined in Section B.4, a _free tree_ is a connected, acyclic, undirected graph. We often omit the adjective \"free\" when we say that a graph is a tree. If an undirected graph is acyclic but possibly disconnected, it is a _forest_. Many algorithms that work for trees also work for forests. Figure B.4(a) shows a free tree, and Figure B.4(b) shows a forest. The forest in Figure B.4(b) is not a tree because it is not connected. The graph in Figure B.4(c) is connected but neither a tree nor a forest, because it contains a cycle.\n\nThe following theorem captures many important facts about free trees.\n\n**Theorem B.2** (Properties of free trees): Let \\(G=(V,E)\\) be an undirected graph. The following statements are equivalent.\n\n1. \\(G\\) is a free tree.\n2. Any two vertices in \\(G\\) are connected by a unique simple path.\n3. \\(G\\) is connected, but if any edge is removed from \\(E\\), the resulting graph is disconnected.\n\nFigure B.4: **(a)** A free tree. **(b)** A forest. **(c)** A graph that contains a cycle and is therefore neither a tree nor a forest.\n\n4. \\(G\\) is connected, and \\(|E|=|V|-1\\).\n5. \\(G\\) is acyclic, and \\(|E|=|V|-1\\).\n6. \\(G\\) is acyclic, but if any edge is added to \\(E\\), the resulting graph contains a cycle.\n\n_Proof_ (1) \\(\\Rightarrow\\) (2): Since a tree is connected, any two vertices in \\(G\\) are connected by at least one simple path. Suppose for the sake of contradiction that vertices \\(u\\) and \\(v\\) are connected by two distinct simple paths as shown in Figure B.5. Let \\(w\\) be the vertex at which the paths first diverge. That is, if we call the paths \\(p_{1}\\) and \\(p_{2}\\), then \\(w\\) is the first vertex on both \\(p_{1}\\) and \\(p_{2}\\) whose successor on \\(p_{1}\\) is \\(x\\) and whose successor on \\(p_{2}\\) is \\(y\\), where \\(x\\neq y\\). Let \\(z\\) be the first vertex at which the paths reconverge, that is, \\(z\\) is the first vertex following \\(w\\) on \\(p_{1}\\) that is also on \\(p_{2}\\). Let \\(p^{\\prime}=w\\to x\\leadsto z\\) be the subpath of \\(p_{1}\\) from \\(w\\) through \\(x\\) to \\(z\\), so that \\(p_{1}=u\\leadsto w\\stackrel{{ p^{\\prime}}}{{\\leadsto}}z\\leadsto v\\), and let \\(p^{\\prime\\prime}=w\\to y\\leadsto z\\) be the subpath of \\(p_{2}\\) from \\(w\\) through \\(y\\) to \\(z\\), so that \\(p_{2}=u\\leadsto w\\stackrel{{ p^{\\prime\\prime}}}{{\\leadsto}}z \\leadsto v\\). Paths \\(p^{\\prime}\\) and \\(p^{\\prime\\prime}\\) share no vertices except their endpoints. Then, as Figure B.5 shows, the path obtained by concatenating \\(p^{\\prime}\\) and the reverse of \\(p^{\\prime\\prime}\\) is a cycle, which contradicts our assumption that \\(G\\) is a tree. Thus, if \\(G\\) is a tree, there can be at most one simple path between two vertices.\n\n(2) \\(\\Rightarrow\\) (3): If any two vertices in \\(G\\) are connected by a unique simple path, then \\(G\\) is connected. Let \\((u,v)\\) be any edge in \\(E\\). This edge is a path from \\(u\\) to \\(v\\), and so it must be the unique path from \\(u\\) to \\(v\\). If \\((u,v)\\) were to be removed from \\(G\\), there would be no path from \\(u\\) to \\(v\\), and \\(G\\) would be disconnected.\n\n(3) \\(\\Rightarrow\\) (4): By assumption, the graph \\(G\\) is connected, so Exercise B.4-3 gives that \\(|E|\\geq|V|-1\\). We prove \\(|E|\\leq|V|-1\\) by induction on \\(|V|\\). The base cases are when \\(|V|=1\\) or \\(|V|=2\\), and in either case, \\(|E|=|V|-1\\). For the inductive step, suppose that \\(|V|\\geq 3\\) for graph \\(G\\) and that any graph \\(G^{\\prime}=(V^{\\prime},E^{\\prime})\\), where \\(E^{\\prime}\\) is a cycle. Then, as Figure B.5 shows, the path obtained by concatenating \\(p^{\\prime}\\) and the reverse of \\(p^{\\prime\\prime}\\) is a cycle, which contradicts our assumption that \\(G\\) is a tree. Thus, if \\(G\\) is a tree, there can be at most one simple path between two vertices.\n\n(2) \\(\\Rightarrow\\) (3): If any two vertices in \\(G\\) are connected by a unique simple path, then \\(G\\) is connected. Let \\((u,v)\\) be any edge in \\(E\\). This edge is a path from \\(u\\) to \\(v\\), and so it must be the unique path from \\(u\\) to \\(v\\). If \\((u,v)\\) were to be removed from \\(G\\), there would be no path from \\(u\\) to \\(v\\), and \\(G\\) would be disconnected.\n\n(3) \\(\\Rightarrow\\) (4): By assumption, the graph \\(G\\) is connected, so Exercise B.4-3 gives that \\(|E|\\geq|V|-1\\). We prove \\(|E|\\leq|V|-1\\) by induction on \\(|V|\\). The base cases are when \\(|V|=1\\) or \\(|V|=2\\), and in either case, \\(|E|=|V|-1\\). For the inductive step, suppose that \\(|V|\\geq 3\\) for graph \\(G\\) and that any graph \\(G^{\\prime}=(V^{\\prime},E^{\\prime})\\), where \\(E^{\\prime}\\) is a cycle. Then, as Figure B.5 shows, the path obtained by concatenating \\(p^{\\prime}\\) and the reverse of \\(p^{\\prime\\prime}\\) is a cycle, which contradicts our assumption that \\(G\\) is a tree. Thus, if \\(G\\) is a tree, there can be at most one simple path between two vertices.\n\n(2) \\(\\Rightarrow\\) (3): If any two vertices in \\(G\\) are connected by a unique simple path, then \\(G\\) is connected. Let \\((u,v)\\) be any edge in \\(E\\). This edge is a path from \\(u\\) to \\(v\\), and so it must be the unique path from \\(u\\) to \\(v\\). If \\((u,v)\\) were to be removed from \\(G\\), there would be no path from \\(u\\) to \\(v\\), and \\(G\\) would be disconnected.\n\n(3) \\(\\Rightarrow\\) (4): By assumption, the graph \\(G\\) is connected, so Exercise B.4-3 gives that \\(|E|\\geq|V|-1\\). We prove \\(|E|\\leq|V|-1\\) by induction on \\(|V|\\). The base cases are when \\(|V|=1\\) or \\(|V|=2\\), and in either case, \\(|E|=|V|-1\\). For the inductive step, suppose that \\(|V|\\geq 3\\) for graph \\(G\\) and that any graph \\(G^{\\prime}=(V^{\\prime},E^{\\prime})\\), where \\(E^{\\prime}\\) is a cycle. Then, as Figure B.5 shows, the path obtained by concatenating \\(p^{\\prime}\\) and the reverse of \\(p^{\\prime\\prime}\\) is a cycle, which contradicts our assumption that \\(G\\) is a tree. Thus, if \\(G\\) is a tree, there can be at most one simple path between two vertices.\n\n(2) \\(\\Rightarrow\\) (3): If any two vertices in \\(G\\) are connected by a unique simple path, then \\(G\\) is connected. Let \\((u,v)\\) be any edge in \\(E\\). This edge is a path from \\(u\\) to \\(v\\), and so it must be the unique path from \\(u\\) to \\(v\\). If \\((u,v)\\) were to be removed from \\(G\\), there would be no path from \\(u\\) to \\(v\\), and \\(G\\) would be disconnected.\n\n(3) \\(\\Rightarrow\\) (4): By assumption, the graph \\(G\\) is connected, so Exercise B.4-3 gives that \\(|E|\\geq|V|-1\\). We prove \\(|E|\\leq|V|-1\\) by induction on \\(|V|\\). The base cases are when \\(|V|=1\\) or \\(|V|=2\\), and in either case, \\(|E|=|V|-1\\). For the inductive step, suppose that \\(|V|\\geq 3\\) for graph \\(G\\) and that any graph \\(G^{\\prime}=(V^{\\prime},E^{\\prime})\\), where \\(E^{\\prime}\\) is a cycle. Then, as Figure B.5 shows, the path obtained by concatenating \\(p^{\\prime}\\) and the reverse of \\(p^{\\prime\\prime}\\) is a cycle, which contradicts our assumption that \\(G\\) is a tree. Thus, if \\(G\\) is a tree, there can be at most one simple path between two vertices.\n\n(2) \\(\\Rightarrow\\) (3): If any two vertices in \\(G\\) are connected by a unique simple path, then \\(G\\) is connected. Let \\((u,v)\\) be any edge in \\(E\\). This edge is a path from \\(u\\) to \\(v\\), and so it must be the unique path from \\(u\\) to \\(v\\). If \\((u,v)\\) were to be removed from \\(G\\), there would be no path from \\(u\\) to \\(v\\), and \\(G\\) would be disconnected.\n\n(3) \\(\\Rightarrow\\) (4): By assumption, the graph \\(G\\) is connected, so Exercise B.4-3 gives that \\(|E|\\geq|V|-1\\). We prove \\(|E|\\leq|V|-1\\) by induction on \\(|V|\\). The base cases are when \\(|V|=1\\) or \\(|V|=2\\), and in either case, \\(|E|=|V|-1\\). For the inductive step, suppose that \\(|V|\\geq 3\\) for graph \\(G\\) and that any graph \\(G^{\\prime}=(V^{\\prime},E^{\\prime})\\), where \\(E^{\\prime}\\) is a cycle. Then, as Figure B.5 shows, the path obtained by concatenating \\(p^{\\prime}\\) and the reverse of \\(p^{\\prime\\prime}\\) is a cycle, which contradicts our assumption that \\(G\\) is a tree. Thus, if \\(G\\) is a tree, there can be at most one simple path between two vertices.\n\n(2) \\(\\Rightarrow\\) (3): If any two vertices in \\(G\\) are connected by a unique simple path, then \\(G\\) is connected. Let \\((u,v)\\) be any edge in \\(E\\). This edge is a path from \\(u\\) to \\(v\\), and so it must be the unique path from \\(u\\) to \\(v\\). If \\((u,v)\\) were to be removed from \\(G\\), there would be no path from \\(u\\) to \\(v\\), and so it must be disconnected.\n\n(3) \\(\\Rightarrow\\) (4): By assumption, the graph \\(G\\) is connected, so Exercise B.4-3 gives that \\(|E|\\geq|V|-1\\). We prove \\(|E|\\leq|V|-1\\) by induction on \\(|V|\\). The base cases are when \\(|V|=1\\) or \\(|V|=2\\), and in either case, \\(|E|=|V|-1\\). For the inductive step, suppose that \\(|V|\\geq 3\\) for graph \\(G\\) and that any graph \\(G^{\\prime}=(V^{\\prime},E^{\\prime})\\), where \\(E^{\\prime}\\) is a cycle. Then, as Figure B.5 shows, the path obtained by concatenating \\(p^{\\prime}\\) and the reverse of \\(p^{\\prime\\prime}\\) is a cycle, which contradicts our assumption that \\(G\\) is a tree. Thus, if \\(G\\) is a tree, there can be at most one simple path between two vertices.\n\n(4) \\(\\Rightarrow\\) (5): If any two vertices in \\(G\\) are connected by a unique simple path, then \\(G\\) is connected, so Exercise B.4-3 gives that \\(|E|\\geq|V|-1\\). We prove \\(|E|\\leq|V|-1\\) by induction on \\(|V|\\). The base cases are when \\(|V|=1\\) or \\(|V|=2\\), and in either case, \\(\\(|V^{\\prime}|<|V|\\), that satisfies (3) also satisfies \\(|E^{\\prime}|\\leq|V^{\\prime}|-1\\). Removing an arbitrary edge from \\(G\\) separates the graph into \\(k\\geq 2\\) connected components (actually \\(k=2\\)). Each component satisfies (3), or else \\(G\\) would not satisfy (3). Consider each connected component \\(V_{i}\\), with edge set \\(E_{i}\\), as a separate free tree. Then, because each connected component has fewer than \\(|V|\\) vertices, the inductive hypothesis implies that \\(|E_{i}|\\leq|V_{i}|-1\\). Thus, the number of edges in all \\(k\\) connected components combined is at most \\(|V|-k\\leq|V|-2\\). Adding in the removed edge yields \\(|E|\\leq|V|-1\\).\n\n(4) \\(\\Rightarrow\\) (5): Suppose that \\(G\\) is connected and that \\(|E|=|V|-1\\). We must show that \\(G\\) is acyclic. Suppose that \\(G\\) has a cycle containing \\(k\\) vertices \\(v_{1}\\), \\(v_{2},\\ldots,v_{k}\\), and without loss of generality assume that this cycle is simple. Let \\(G_{k}=(V_{k},E_{k})\\) be the subgraph of \\(G\\) consisting of the cycle, so that \\(|V_{k}|=|E_{k}|=k\\). If \\(k<|V|\\), then because \\(G\\) is connected, there must be a vertex \\(v_{k+1}\\in V-V_{k}\\) that is adjacent to some vertex \\(v_{i}\\in V_{k}\\). Define \\(G_{k+1}=(V_{k+1},E_{k+1})\\) to be the subgraph of \\(G\\) with \\(V_{k+1}=V_{k}\\cup\\{v_{k+1}\\}\\) and \\(E_{k+1}=E_{k}\\cup\\{(v_{i},v_{k+1})\\}\\). Note that \\(|V_{k+1}|=|E_{k+1}|=k+1\\). If \\(k+1<|V|\\), then continue, defining \\(G_{k+2}\\) in the same manner, and so forth, until we obtain \\(G_{n}=(V_{n},E_{n})\\), where \\(n=|V|\\), \\(V_{n}=V\\), and \\(|E_{n}|=|V_{n}|=|V|\\). Since \\(G_{n}\\) is a subgraph of \\(G\\), we have \\(E_{n}\\subseteq E\\), and hence \\(|E|\\geq|E_{n}|=|V_{n}|=|V|\\), which contradicts the assumption that \\(|E|=|V|-1\\). Thus, \\(G\\) is acyclic.\n\n(5) \\(\\Rightarrow\\) (6): Suppose that \\(G\\) is acyclic and that \\(|E|=|V|-1\\). Let \\(k\\) be the number of connected components of \\(G\\). Each connected component is a free tree by definition, and since (1) implies (5), the sum of all edges in all connected components of \\(G\\) is \\(|V|-k\\). Consequently, \\(k\\) must equal \\(1\\), and \\(G\\) is in fact a tree. Since (1) implies (2), any two vertices in \\(G\\) are connected by a unique simple path. Thus, adding any edge to \\(G\\) creates a cycle.\n\n(6) \\(\\Rightarrow\\) (1): Suppose that \\(G\\) is acyclic but that adding any edge to \\(E\\) creates a cycle. We must show that \\(G\\) is connected. Let \\(u\\) and \\(v\\) be arbitrary vertices in \\(G\\). If \\(u\\) and \\(v\\) are not already adjacent, adding the edge \\((u,v)\\) creates a cycle in which all edges but \\((u,v)\\) belong to \\(G\\). Thus, the cycle minus edge \\((u,v)\\) must contain a path from \\(u\\) to \\(v\\), and since \\(u\\) and \\(v\\) were chosen arbitrarily, \\(G\\) is connected.\n\n#### b.5.2 Rooted and ordered trees\n\nA _rooted tree_ is a free tree in which one of the vertices is distinguished from the others. We call the distinguished vertex the _root_ of the tree. We often refer to a vertex of a rooted tree as a _node5_ of the tree. Figure B.6(a) shows a rooted tree on a set of 12 nodes with root 7.\n\nFootnote 5: The term \u201cnode\u201d is often used in the graph theory literature as a synonym for \u201cvertex.\u201d We reserve the term \u201cnode\u201d to mean a vertex of a rooted tree.\n\nConsider a node \\(x\\) in a rooted tree \\(T\\) with root \\(r\\). We call any node \\(y\\) on the unique simple path from \\(r\\) to \\(x\\) an _ancestor_ of \\(x\\). If \\(y\\) is an ancestor of \\(x\\), then \\(x\\) is a _descendant_ of \\(y\\). (Every node is both an ancestor and a descendant of itself.) If \\(y\\) is an ancestor of \\(x\\) and \\(x\\neq y\\), then \\(y\\) is a _proper ancestor_ of \\(x\\) and \\(x\\) is a _proper descendant_ of \\(y\\). The _subtree rooted at \\(x\\)_ is the tree induced by descendants of \\(x\\), rooted at \\(x\\). For example, the subtree rooted at node 8 in Figure B.6(a) contains nodes 8, 6, 5, and 9.\n\nIf the last edge on the simple path from the root \\(r\\) of a tree \\(T\\) to a node \\(x\\) is \\((y,x)\\), then \\(y\\) is the _parent_ of \\(x\\), and \\(x\\) is a _child_ of \\(y\\). The root is the only node in \\(T\\) with no parent. If two nodes have the same parent, they are _siblings_. A node with no children is a _leaf_ or _external node_. A nonleaf node is an _internal node_.\n\nFigure B.6: Rooted and ordered trees. **(a)** A rooted tree with height 4. The tree is drawn in a standard way: the root (node 7) is at the top, its children (nodes with depth 1) are beneath it, their children (nodes with depth 2) are beneath them, and so forth. If the tree is ordered, the relative left-to-right order of the children of a node matters; otherwise, it doesn\u2019t. **(b)** Another rooted tree. As a rooted tree, it is identical to the tree in (a), but as an ordered tree it is different, since the children of node 3 appear in a different order.\n\n### Trees\n\nThe number of children of a node \\(x\\) in a rooted tree \\(T\\) is the _degree_ of \\(x\\).6 The length of the simple path from the root \\(r\\) to a node \\(x\\) is the _depth_ of \\(x\\) in \\(T\\). A _level_ of a tree consists of all nodes at the same depth. The _height_ of a node in a tree is the number of edges on the longest simple downward path from the node to a leaf, and the height of a tree is the height of its root. The height of a tree is also equal to the largest depth of any node in the tree.\n\nFootnote 6: The degree of a node depends on whether we consider \\(T\\) to be a rooted tree or a free tree. The degree of a vertex in a free tree is, as in any undirected graph, the number of adjacent vertices. In a rooted tree, however, the degree is the number of children\u2014 the parent of a node does not count toward its degree.\n\nAn _ordered tree_ is a rooted tree in which the children of each node are ordered. That is, if a node has \\(k\\) children, then there is a first child, a second child, and so on, up to and including a \\(k\\)th child. The two trees in Figure 6 are different when considered to be ordered trees, but the same when considered to be just rooted trees.\n\n#### b.5.3 Binary and positional trees\n\nWe define binary trees recursively. A _binary tree_\\(T\\) is a structure defined on a finite set of nodes that either\n\n* contains no nodes, or\n* is composed of three disjoint sets of nodes: a _root_ node, a binary tree called its _left subtree_, and a binary tree called its _right subtree_.\n\nThe binary tree that contains no nodes is called the _empty tree_ or _null tree_, sometimes denoted nil. If the left subtree is nonempty, its root is called the _left child_ of the root of the entire tree. Likewise, the root of a nonnull right subtree is the _right child_ of the root of the entire tree. If a subtree is the null tree nil, we say that the child is _absent_ or _missing_. Figure 7(a) shows a binary tree.\n\nA binary tree is not simply an ordered tree in which each node has degree at most 2. For example, in a binary tree, if a node has just one child, the position of the child--whether it is the _left child_ or the _right child_--matters. In an ordered tree, there is no distinguishing a sole child as being either left or right. Figure 7(b) shows a binary tree that differs from the tree in Figure 7(a) because of the position of one node. Considered as ordered trees, however, the two trees are identical.\n\nOne way to represent the positioning information in a binary tree is by the internal nodes of an ordered tree, as shown in Figure 7(c). The idea is to replace each missing child in the binary tree with a node having no children. These leaf nodesare drawn as squares in the figure. The tree that results is a _full binary tree_: each node is either a leaf or has degree exactly 2. No nodes have degree 1. Consequently, the order of the children of a node preserves the position information.\n\nThe positioning information that distinguishes binary trees from ordered trees extends to trees with more than two children per node. In a _positional tree_, the children of a node are labeled with distinct positive integers. The _i_th child of a node is _absent_ if no child is labeled with integer \\(i\\). A _k-ary_ tree is a positional tree in which for every node, all children with labels greater than \\(k\\) are missing. Thus, a binary tree is a \\(k\\)-ary tree with \\(k=2\\).\n\nA _complete \\(k\\)-ary tree_ is a \\(k\\)-ary tree in which all leaves have the same depth and all internal nodes have degree \\(k\\). Figure B.8 shows a complete binary tree of height \\(3\\). How many leaves does a complete \\(k\\)-ary tree of height \\(h\\) have? The root has \\(k\\) children at depth 1, each of which has \\(k\\) children at depth 2, etc. Thus, the number of nodes at depth \\(d\\) is \\(k^{d}\\). In a complete \\(k\\)-ary tree with height \\(h\\), the leaves are at depth \\(h\\), so that there are \\(k^{h}\\) leaves. Consequently, the height of a complete \\(k\\)-ary tree with \\(n\\) leaves is \\(\\log_{k}n\\). A complete \\(k\\)-ary tree of height \\(h\\) has\n\n\\[1+k+k^{2}+\\cdots+k^{h-1} = \\sum_{d\\,=\\,0}^{h-1}k^{d}\\] \\[= \\frac{k^{h}-1}{k-1}\\quad\\text{(by equation (A.6) on page 1142)}\\] internal nodes. Thus, a complete binary tree has \\(2^{h}-1\\) internal nodes.\n\nFigure B.7: Binary trees. **(a)** A binary tree drawn in a standard way. The left child of a node is drawn beneath the node and to the left. The right child is drawn beneath and to the right. **(b)** A binary tree different from the one in (a). In (a), the left child of node 7 is 5 and the right child is absent. In (b), the left child of node 7 is absent and the right child is 5. As ordered trees, these trees are the same, but as binary trees, they are distinct. **(c)** The binary tree in (a) represented by the internal nodes of a full binary tree: an ordered tree in which each internal node has degree 2. The leaves in the tree are shown as squares.\n\n### _Trees_\n\n**Exercises**\n\n_B.5-1_\n\nDraw all the free trees composed of the three vertices \\(x\\), \\(y\\), and \\(z\\). Draw all the rooted trees with nodes \\(x\\), \\(y\\), and \\(z\\) with \\(x\\) as the root. Draw all the ordered trees with nodes \\(x\\), \\(y\\), and \\(z\\) with \\(x\\) as the root. Draw all the binary trees with nodes \\(x\\), \\(y\\), and \\(z\\) with \\(x\\) as the root.\n\n_B.5-2_\n\nLet \\(G=(V,E)\\) be a directed acyclic graph in which there is a vertex \\(v_{0}\\in V\\) such that there exists a unique path from \\(v_{0}\\) to every vertex \\(v\\in V\\). Prove that the undirected version of \\(G\\) forms a tree.\n\n_B.5-3_\n\nShow by induction that the number of degree-2 nodes in any nonempty binary tree is one less than the number of leaves. Conclude that the number of internal nodes in a full binary tree is one less than the number of leaves.\n\n_B.5-4_\n\nProve that for any integer \\(k\\geq 1\\), there is a full binary tree with \\(k\\) leaves.\n\n_B.5-5_\n\nUse induction to show that a nonempty binary tree with \\(n\\) nodes has height at least \\(\\lfloor\\lg n\\rfloor\\).\n\n_B.5-6_\n\nThe _internal path length_ of a full binary tree is the sum, taken over all internal nodes of the tree, of the depth of each node. Likewise, the _external path length_ is the sum, taken over all leaves of the tree, of the depth of each leaf. Consider a full binary tree with \\(n\\) internal nodes, internal path length \\(i\\), and external path length \\(e\\). Prove that \\(e=i\\,+2n\\).\n\nFigure B.8: A complete binary tree of height 3 with 8 leaves and 7 internal nodes.\n\n* _B.5-7_ Associate a \"weight\" \\(w(x)=2^{-d}\\) with each leaf \\(x\\) of depth \\(d\\) in a binary tree \\(T\\), and let \\(L\\) be the set of leaves of \\(T\\). Prove the _Kraft inequality_: \\(\\sum_{x\\in L}w(x)\\leq 1\\).\n* _B.5-8_ Show that if \\(L\\geq 2\\), then every binary tree with \\(L\\) leaves contains a subtree having between \\(L/3\\) and \\(2L/3\\) leaves, inclusive.\n\n## Problems\n\n* _B-1 Graph coloring_ A _k-coloring_ of undirected graph \\(G=(V,E)\\) is a function \\(c:V\\to\\{1,2,\\ldots,k\\}\\) such that \\(c(u)\\neq c(v)\\) for every edge \\((u,v)\\in E\\). In other words, the numbers \\(1,2,\\ldots,k\\) represent the \\(k\\) colors, and adjacent vertices must have different colors.\n* Show that any tree is 2-colorable.\n* Show that the following are equivalent:\n* \\(G\\) is bipartite.\n* \\(G\\) is 2-colorable.\n* \\(G\\) has no cycles of odd length.\n* Let \\(d\\) be the maximum degree of any vertex in a graph \\(G\\). Prove that \\(G\\) can be colored with \\(d\\,+1\\) colors.\n* Show that if \\(G\\) has \\(O(|V|)\\) edges, then \\(G\\) can be colored with \\(O(\\sqrt{|V|})\\) colors.\n\n### _B-2 Friendly graphs_\n\nReword each of the following statements as a theorem about undirected graphs, and then prove it. Assume that friendship is symmetric but not reflexive.\n\n* Any group of at least two people contains at least two people with the same number of friends in the group.\n* Every group of six people contains either at least three mutual friends or at least three mutual strangers.\n* Any group of people can be partitioned into two subgroups such that at least half the friends of each person belong to the subgroup of which that person is _not_ a member.",
        "chapter": "Part VIII Appendix: Mathematical Background",
        "section": "B Sets, Etc.",
        "subsection": "B.5 Trees",
        "subsubsection": "N/A"
    },
    {
        "content": "* _B.5-7_ Associate a \"weight\" \\(w(x)=2^{-d}\\) with each leaf \\(x\\) of depth \\(d\\) in a binary tree \\(T\\), and let \\(L\\) be the set of leaves of \\(T\\). Prove the _Kraft inequality_: \\(\\sum_{x\\in L}w(x)\\leq 1\\).\n* _B.5-8_ Show that if \\(L\\geq 2\\), then every binary tree with \\(L\\) leaves contains a subtree having between \\(L/3\\) and \\(2L/3\\) leaves, inclusive.\n\n## Problems\n\n* _B-1 Graph coloring_ A _k-coloring_ of undirected graph \\(G=(V,E)\\) is a function \\(c:V\\rightarrow\\{1,2,\\ldots,k\\}\\) such that \\(c(u)\\neq c(v)\\) for every edge \\((u,v)\\in E\\). In other words, the numbers \\(1,2,\\ldots,k\\) represent the \\(k\\) colors, and adjacent vertices must have different colors.\n* Show that any tree is 2-colorable.\n* Show that the following are equivalent:\n* \\(G\\) is bipartite.\n* \\(G\\) is 2-colorable.\n* \\(G\\) has no cycles of odd length.\n* Let \\(d\\) be the maximum degree of any vertex in a graph \\(G\\). Prove that \\(G\\) can be colored with \\(d\\,+1\\) colors.\n* Show that if \\(G\\) has \\(O(|V|)\\) edges, then \\(G\\) can be colored with \\(O(\\sqrt{|V|})\\) colors.\n\n### _B-2 Friendly graphs_\n\nReword each of the following statements as a theorem about undirected graphs, and then prove it. Assume that friendship is symmetric but not reflexive.\n\n* Any group of at least two people contains at least two people with the same number of friends in the group.\n* Every group of six people contains either at least three mutual friends or at least three mutual strangers.\n* Any group of people can be partitioned into two subgroups such that at least half the friends of each person belong to the subgroup of which that person is _not_ a member.\n_d._: If everyone in a group is the friend of at least half the people in the group, then the group can be seated around a table in such a way that everyone is seated between two friends.\n\n#### B-3 Bisecting trees\n\nMany divide-and-conquer algorithms that operate on graphs require that the graph be bisected into two nearly equal-sized subgraphs, which are induced by a partition of the vertices. This problem investigates bisections of trees formed by removing a small number of edges. We require that whenever two vertices end up in the same subtree after removing edges, then they must belong to the same partition.\n\n_a._: Show that the vertices of any \\(n\\)-vertex binary tree can be partitioned into two sets \\(A\\) and \\(B\\), such that \\(|A|\\leq 3n/4\\) and \\(|B|\\leq 3n/4\\), by removing a single edge.\n\n_b._: Show that the constant \\(3/4\\) in part (a) is optimal in the worst case by giving an example of a simple binary tree whose most evenly balanced partition upon removal of a single edge has \\(|A|=3n/4\\).\n\n_c._: Show that by removing at most \\(O(\\lg n)\\) edges, we can partition the vertices of any \\(n\\)-vertex binary tree into two sets \\(A\\) and \\(B\\) such that \\(|A|=\\lfloor n/2\\rfloor\\) and \\(|B|=\\lceil n/2\\rceil\\).\n\n## Appendix notes\n\nG. Boole pioneered the development of symbolic logic, and he introduced many of the basic set notations in a book published in 1854. Modern set theory was created by G. Cantor during the period 1874-1895. Cantor focused primarily on sets of infinite cardinality. The term \"function\" is attributed to G. W. Leibniz, who used it to refer to several kinds of mathematical formulas. His limited definition has been generalized many times. Graph theory originated in 1736, when L. Euler proved that it was impossible to cross each of the seven bridges in the city of Konigsberg exactly once and return to the starting point.\n\nThe book by Harary [208] provides a useful compendium of many definitions and results from graph theory.",
        "chapter": "Part VIII Appendix: Mathematical Background",
        "section": "B Sets, Etc.",
        "subsection": "Problems",
        "subsubsection": "N/A"
    },
    {
        "content": "_d._: If everyone in a group is the friend of at least half the people in the group, then the group can be seated around a table in such a way that everyone is seated between two friends.\n\n#### B-3 Bisecting trees\n\nMany divide-and-conquer algorithms that operate on graphs require that the graph be bisected into two nearly equal-sized subgraphs, which are induced by a partition of the vertices. This problem investigates bisections of trees formed by removing a small number of edges. We require that whenever two vertices end up in the same subtree after removing edges, then they must belong to the same partition.\n\n_a._: Show that the vertices of any \\(n\\)-vertex binary tree can be partitioned into two sets \\(A\\) and \\(B\\), such that \\(|A|\\leq 3n/4\\) and \\(|B|\\leq 3n/4\\), by removing a single edge.\n\n_b._: Show that the constant \\(3/4\\) in part (a) is optimal in the worst case by giving an example of a simple binary tree whose most evenly balanced partition upon removal of a single edge has \\(|A|=3n/4\\).\n\n_c._: Show that by removing at most \\(O(\\lg n)\\) edges, we can partition the vertices of any \\(n\\)-vertex binary tree into two sets \\(A\\) and \\(B\\) such that \\(|A|=\\lfloor n/2\\rfloor\\) and \\(|B|=\\lceil n/2\\rceil\\).\n\n## Appendix notes\n\nG. Boole pioneered the development of symbolic logic, and he introduced many of the basic set notations in a book published in 1854. Modern set theory was created by G. Cantor during the period 1874-1895. Cantor focused primarily on sets of infinite cardinality. The term \"function\" is attributed to G. W. Leibniz, who used it to refer to several kinds of mathematical formulas. His limited definition has been generalized many times. Graph theory originated in 1736, when L. Euler proved that it was impossible to cross each of the seven bridges in the city of Konigsberg exactly once and return to the starting point.\n\nThe book by Harary [208] provides a useful compendium of many definitions and results from graph theory.\n\nCounting and Probability\n\nThis appendix reviews elementary combinatorics and probability theory. If you have a good background in these areas, you may want to skim the beginning of this appendix lightly and concentrate on the later sections. Most of this book's chapters do not require probability, but for some chapters it is essential.\n\nSection C.1 reviews elementary results in counting theory, including standard formulas for counting permutations and combinations. The axioms of probability and basic facts concerning probability distributions form Section C.2. Random variables are introduced in Section C.3, along with the properties of expectation and variance. Section C.4 investigates the geometric and binomial distributions that arise from studying Bernoulli trials. The study of the binomial distribution continues in Section C.5, an advanced discussion of the \"tails\" of the distribution.\n\n### Counting\n\nCounting theory tries to answer the question \"How many?\" without actually enumerating all the choices. For example, you might ask, \"How many different \\(n\\)-bit numbers are there?\" or \"How many orderings of \\(n\\) distinct elements are there?\" This section reviews the elements of counting theory. Since some of the material assumes a basic understanding of sets, you might wish to start by reviewing the material in Section B.1.\n\n#### Rules of sum and product\n\nWe can sometimes express a set of items that we wish to count as a union of disjoint sets or as a Cartesian product of sets.\n\nThe _rule of sum_ says that the number of ways to choose one element from one of two _disjoint_ sets is the sum of the cardinalities of the sets. That is, if \\(A\\) and \\(B\\) are two finite sets with no members in common, then \\(|A\\cup B|=|A|+|B|\\), which",
        "chapter": "Part VIII Appendix: Mathematical Background",
        "section": "B Sets, Etc.",
        "subsection": "Appendix notes",
        "subsubsection": "N/A"
    },
    {
        "content": "Counting and Probability\n\nThis appendix reviews elementary combinatorics and probability theory. If you have a good background in these areas, you may want to skim the beginning of this appendix lightly and concentrate on the later sections. Most of this book's chapters do not require probability, but for some chapters it is essential.\n\nSection C.1 reviews elementary results in counting theory, including standard formulas for counting permutations and combinations. The axioms of probability and basic facts concerning probability distributions form Section C.2. Random variables are introduced in Section C.3, along with the properties of expectation and variance. Section C.4 investigates the geometric and binomial distributions that arise from studying Bernoulli trials. The study of the binomial distribution continues in Section C.5, an advanced discussion of the \"tails\" of the distribution.\n\n### Counting\n\nCounting theory tries to answer the question \"How many?\" without actually enumerating all the choices. For example, you might ask, \"How many different \\(n\\)-bit numbers are there?\" or \"How many orderings of \\(n\\) distinct elements are there?\" This section reviews the elements of counting theory. Since some of the material assumes a basic understanding of sets, you might wish to start by reviewing the material in Section B.1.\n\n#### Rules of sum and product\n\nWe can sometimes express a set of items that we wish to count as a union of disjoint sets or as a Cartesian product of sets.\n\nThe _rule of sum_ says that the number of ways to choose one element from one of two _disjoint_ sets is the sum of the cardinalities of the sets. That is, if \\(A\\) and \\(B\\) are two finite sets with no members in common, then \\(|A\\cup B|=|A|+|B|\\), which follows from equation (B.3) on page 1156. For example, if each position on a car's license plate is a letter or a digit, then the number of possibilities for each position is \\(26\\)\\(+\\)\\(10\\)\\(=\\)\\(36\\), since there are \\(26\\) choices if it is a letter and \\(10\\) choices if it is a digit.\n\nThe _rule of product_ says that the number of ways to choose an ordered pair is the number of ways to choose the first element times the number of ways to choose the second element. That is, if \\(A\\) and \\(B\\) are two finite sets, then \\(|A\\times B|=|A|\\cdot|B|\\), which is simply equation (B.4) on page 1157. For example, if an ice-cream parlor offers \\(28\\) flavors of ice cream and four toppings, the number of possible sundaes with one scoop of ice cream and one topping is \\(28\\cdot 4\\)\\(=\\)\\(112\\).\n\n#### Strings\n\nA _string_ over a finite set \\(S\\) is a sequence of elements of \\(S\\). For example, there are eight binary strings of length \\(3\\):\n\n\\(000,001,010,011,100,101,110,111\\).\n\n(Here we use the shorthand of omitting the angle brackets when denoting a sequence.) We sometimes call a string of length \\(k\\) a _\\(k\\)-string_. A _substring_\\(s^{\\prime}\\) of a string \\(s\\) is an ordered sequence of consecutive elements of \\(s\\). A _\\(k\\)-substring_ of a string is a substring of length \\(k\\). For example, \\(010\\) is a \\(3\\)-substring of \\(01101001\\) (the \\(3\\)-substring that begins in position \\(4\\)), but \\(111\\) is not a substring of \\(01101001\\).\n\nWe can view a \\(k\\)-string over a set \\(S\\) as an element of the Cartesian product \\(S^{k}\\) of \\(k\\)-tuples, which means that there are \\(|S|^{k}\\) strings of length \\(k\\). For example, the number of binary \\(k\\)-strings is \\(2^{k}\\). Intuitively, to construct a \\(k\\)-string over an \\(n\\)-set, there are \\(n\\) ways to pick the first element; for each of these choices, there are \\(n\\) ways to pick the second element; and so forth \\(k\\) times. This construction leads to the \\(k\\)-fold product \\(\\underbrace{n\\cdot n\\cdots n}_{n\\text{ times}}=n^{k}\\) as the number of \\(k\\)-strings.\n\n#### Permutations\n\nA _permutation_ of a finite set \\(S\\) is an ordered sequence of all the elements of \\(S\\), with each element appearing exactly once. For example, if \\(S=\\{a,b,c\\}\\), then \\(S\\) has \\(6\\) permutations:\n\n\\(abc,acb,bac,bca,cab,cba\\).\n\n(Again, we use the shorthand of omitting the angle brackets when denoting a sequence.) There are \\(n!\\) permutations of a set of \\(n\\) elements, since there are \\(n\\) ways to choose the first element of the sequence, \\(n-1\\) ways for the second element, \\(n-2\\) ways for the third, and so on.\n\nA _\\(k\\)-permutation_ of \\(S\\) is an ordered sequence of \\(k\\) elements of \\(S\\), with no element appearing more than once in the sequence. (Thus, an ordinary permutation is an \\(n\\)-permutation of an \\(n\\)-set.) Here are the 2-permutations of the set \\(\\{a,b,c,d\\}\\):\n\n\\(ab,ac,ad,ba,bc,bd,ca,cb,cd,da,db,dc\\) .\n\nThe number of \\(k\\)-permutations of an \\(n\\)-set is\n\n\\(n(n-1)(n-2)\\cdots(n-k+1)=\\frac{n!}{(n-k)!}\\) ,\n\nsince there are \\(n\\) ways to choose the first element, \\(n-1\\) ways to choose the second element, and so on, until \\(k\\) elements are chosen, with the last element chosen from the remaining \\(n-k+1\\) elements. For the above example, with \\(n=4\\) and \\(k=2\\), the formula (C.1) evaluates to \\(4!/2!=12\\), matching the number of 2-permutations listed.\n\n### Combinations\n\nA _\\(k\\)-combination_ of an \\(n\\)-set \\(S\\) is simply a \\(k\\)-subset of \\(S\\). For example, the 4-set \\(\\{a,b,c,d\\}\\) has six 2-combinations:\n\n\\(ab,ac,ad,bc,bd,cd\\) .\n\n(Here we use the shorthand of omitting the braces around each subset.) To construct a \\(k\\)-combination of an \\(n\\)-set, choose \\(k\\) distinct (different) elements from the \\(n\\)-set. The order of selecting the elements does not matter.\n\nWe can express the number of \\(k\\)-combinations of an \\(n\\)-set in terms of the number of \\(k\\)-permutations of an \\(n\\)-set. Every \\(k\\)-combination has exactly \\(k!\\) permutations of its elements, each of which is a distinct \\(k\\)-permutation of the \\(n\\)-set. Thus the number of \\(k\\)-combinations of an \\(n\\)-set is the number of \\(k\\)-permutations divided by \\(k!\\). From equation (C.1), this quantity is\n\n\\[\\frac{n!}{k!(n-k)!}\\.\\] (C.2)\n\nFor \\(k=0\\), this formula tells us that the number of ways to choose \\(0\\) elements from an \\(n\\)-set is 1 (not 0), since \\(0!=1\\).\n\n### Binomial coefficients\n\nThe notation \\(\\binom{n}{k}\\) (read \"\\(n\\) choose \\(k\\)\") denotes the number of \\(k\\)-combinations of an \\(n\\)-set. Equation (C.2) gives\n\n\\[\\binom{n}{k}=\\frac{n!}{k!(n-k)!}\\.\\]\n\n### Counting\n\nThis formula is symmetric in \\(k\\) and \\(n-k\\):\n\n\\[\\binom{n}{k}=\\binom{n}{n-k}\\.\\] (C.3)\n\nThese numbers are also known as _binomial coefficients_, due to their appearance in the _binomial theorem_:\n\n\\[(x+y)^{n}=\\sum_{k=0}^{n}\\binom{n}{k}x^{k}y^{n-k}\\,\\] (C.4)\n\nwhere \\(n\\in\\mathbb{N}\\) and \\(x,y\\in\\mathbb{R}\\). The right-hand side of equation (C.4) is called the _binomial expansion_ of the left-hand side. A special case of the binomial theorem occurs when \\(x=y=1\\):\n\n\\[2^{n}=\\sum_{k=0}^{n}\\binom{n}{k}\\.\\]\n\nThis formula corresponds to counting the \\(2^{n}\\) binary \\(n\\)-strings by the number of 1s they contain: \\(\\binom{n}{k}\\) binary \\(n\\)-strings contain exactly \\(k\\) 1s, since there are \\(\\binom{n}{k}\\) ways to choose \\(k\\) out of the \\(n\\) positions in which to place the 1s.\n\nMany identities involve binomial coefficients. The exercises at the end of this section give you the opportunity to prove a few.\n\n#### Binomial bounds\n\nYou sometimes need to bound the size of a binomial coefficient. For \\(1\\leq k\\leq n\\), we have the lower bound\n\n\\[\\binom{n}{k} = \\frac{n(n-1)\\cdots(n-k+1)}{k(k-1)\\cdots 1}\\] (C.5) \\[= \\left(\\frac{n}{k}\\right)\\left(\\frac{n-1}{k-1}\\right)\\cdots\\left( \\frac{n-k+1}{1}\\right)\\] \\[\\geq \\left(\\frac{n}{k}\\right)^{k}\\.\\]\n\nTaking advantage of the inequality \\(k!\\geq(k/e)^{k}\\) derived from Stirling's approximation (3.25) on page 3.2, we obtain the upper bounds\n\n\\[\\binom{n}{k} = \\frac{n(n-1)\\cdots(n-k+1)}{k(k-1)\\cdots 1}\\] (C.6) \\[\\leq \\frac{n^{k}}{k!}\\] \\[\\leq \\left(\\frac{e\\,n}{k}\\right)^{k}\\.\\]For all integers \\(k\\) such that \\(0\\leq k\\leq n\\), you can use induction (see Exercise C.1-12) to prove the bound\n\n\\[\\binom{n}{k}\\leq\\frac{n^{n}}{k^{\\,k}(n-k)^{n-k}}\\,\\] (C.7)\n\nwhere for convenience we assume that \\(0^{0}=1\\). For \\(k=\\lambda n\\), where \\(0\\leq\\lambda\\leq 1\\), we can rewrite this bound as\n\n\\[\\binom{n}{\\lambda n} \\leq \\frac{n^{n}}{(\\lambda n)^{\\lambda n}((1-\\lambda)n)^{(1-\\lambda)n}}\\] (C.8) \\[= \\left(\\left(\\frac{1}{\\lambda}\\right)^{\\lambda}\\left(\\frac{1}{1- \\lambda}\\right)^{1-\\lambda}\\right)^{n}\\] \\[= 2^{n\\,H(\\lambda)}\\,\\]\n\nwhere\n\n\\[H(\\lambda)=-\\lambda\\lg\\lambda-(1-\\lambda)\\lg(1-\\lambda)\\] (C.9)\n\nis the _(binary) entropy function_ and where, for convenience, we assume that \\(0\\lg 0=0\\), so that \\(H(0)=H(1)=0\\).\n\n### Exercises\n\n#### C.1-1\n\nHow many \\(k\\)-substrings does an \\(n\\)-string have? (Consider identical \\(k\\)-substrings at different positions to be different.) How many substrings does an \\(n\\)-string have in total?\n\n#### C.1-2\n\nAn \\(n\\)-input, \\(m\\)-output _boolean function_ is a function from \\(\\left\\{0,1\\right\\}^{n}\\) to \\(\\left\\{0,1\\right\\}^{m}\\). How many \\(n\\)-input, \\(1\\)-output boolean functions are there? How many \\(n\\)-input, \\(m\\)-output boolean functions are there?\n\n#### C.1-3\n\nIn how many ways can \\(n\\) professors sit around a circular conference table? Consider two seatings to be the same if one can be rotated to form the other.\n\n#### C.1-4\n\nIn how many ways is it possible to choose three distinct numbers from the set \\(\\left\\{1,2,\\ldots,99\\right\\}\\) so that their sum is even?\n\n### Counting\n\n_C.1-5_\n\nProve the identity\n\n\\[\\binom{n}{k}=\\frac{n}{k}\\binom{n-1}{k-1}\\] (C.9)\n\nfor \\(0<k\\leq n\\).\n\n_C.1-6_\n\nProve the identity\n\n\\[\\binom{n}{k}=\\frac{n}{n-k}\\binom{n-1}{k}\\]\n\nfor \\(0\\leq k<n\\).\n\n_C.1-7_\n\nTo choose \\(k\\) objects from \\(n\\), you can make one of the objects distinguished and consider whether the distinguished object is chosen. Use this approach to prove that\n\n\\[\\binom{n}{k}=\\binom{n-1}{k}+\\binom{n-1}{k-1}\\,.\\]\n\n_C.1-8_\n\nUsing the result of Exercise C.1-7, make a table for \\(n=0,1,\\ldots,6\\) and \\(0\\leq k\\leq n\\) of the binomial coefficients \\(\\binom{n}{k}\\) with \\(\\binom{0}{0}\\) at the top, \\(\\binom{1}{0}\\) and \\(\\binom{1}{1}\\) on the next line, then \\(\\binom{2}{0}\\), \\(\\binom{2}{1}\\), and \\(\\binom{2}{2}\\), and so forth. Such a table of binomial coefficients is called _Pascal's triangle_.\n\n_C.1-9_\n\nProve that\n\n\\[\\sum_{i=1}^{n}i=\\binom{n+1}{2}\\,.\\]\n\n_C.1-10_\n\nShow that for any integers \\(n\\geq 0\\) and \\(0\\leq k\\leq n\\), the expression \\(\\binom{n}{k}\\) achieves its maximum value when \\(k=\\lfloor n/2\\rfloor\\) or \\(k=\\lceil n/2\\rceil\\).\n\n* _C.1-11_  Argue that for any integers \\(n\\geq 0\\), \\(j\\geq 0\\), \\(k\\geq 0\\), and \\(j\\,+k\\leq n\\), \\[\\begin{pmatrix}n\\\\ j\\,+k\\end{pmatrix}\\leq\\begin{pmatrix}n\\\\ j\\end{pmatrix}\\begin{pmatrix}n-j\\\\ k\\end{pmatrix}.\\] (C.10) Provide both an algebraic proof and an argument based on a method for choosing \\(j\\,+k\\) items out of \\(n\\). Give an example in which equality does not hold.\n* _C.1-12_  Use induction on all integers \\(k\\) such that \\(0\\leq k\\leq n/2\\) to prove inequality (C.7), and use equation (C.3) to extend it to all integers \\(k\\) such that \\(0\\leq k\\,\\leq n\\).\n* _C.1-13_  Use Stirling's approximation to prove that \\[\\begin{pmatrix}2n\\\\ n\\end{pmatrix}=\\,\\frac{2^{2n}}{\\sqrt{\\pi\\,n}}(1\\,+\\,O(1/n))\\.\\]\n* _C.1-14_  By differentiating the entropy function \\(H(\\lambda)\\), show that it achieves its maximum value at \\(\\lambda=1/2\\). What is \\(H(1/2)\\)?\n* _C.1-15_  Show that for any integer \\(n\\geq 0\\), \\[\\sum_{k=0}^{n}\\begin{pmatrix}n\\\\ k\\end{pmatrix}k\\,=n\\;2^{n-1}\\.\\] (C.12)\n* _C.1-16_  Inequality (C.5) provides a lower bound on the binomial coefficient \\(\\binom{n}{k}\\). For small values of \\(k\\), a stronger bound holds. Prove that \\[\\begin{pmatrix}n\\\\ k\\end{pmatrix}\\geq\\,\\frac{n^{k}}{4k!}\\] (C.13) for \\(k\\,\\leq\\sqrt{n}\\).\n\n### Probability\n\nProbability is an essential tool for the design and analysis of probabilistic and randomized algorithms. This section reviews basic probability theory.",
        "chapter": "Part VIII Appendix: Mathematical Background",
        "section": "C Counting and Probability",
        "subsection": "C.1 Counting",
        "subsubsection": "N/A"
    },
    {
        "content": "* _C.1-11_  Argue that for any integers \\(n\\geq 0\\), \\(j\\geq 0\\), \\(k\\geq 0\\), and \\(j\\,+k\\leq n\\), \\[\\begin{pmatrix}n\\\\ j\\,+k\\end{pmatrix}\\leq\\begin{pmatrix}n\\\\ j\\end{pmatrix}\\begin{pmatrix}n-j\\\\ k\\end{pmatrix}.\\] (C.10) Provide both an algebraic proof and an argument based on a method for choosing \\(j\\,+k\\) items out of \\(n\\). Give an example in which equality does not hold.\n* _C.1-12_  Use induction on all integers \\(k\\) such that \\(0\\leq k\\leq n/2\\) to prove inequality (C.7), and use equation (C.3) to extend it to all integers \\(k\\) such that \\(0\\leq k\\,\\leq n\\).\n* _C.1-13_  Use Stirling's approximation to prove that \\[\\begin{pmatrix}2n\\\\ n\\end{pmatrix}=\\,\\frac{2^{2n}}{\\sqrt{\\pi\\,n}}(1\\,+\\,O(1/n))\\.\\]\n* _C.1-14_  By differentiating the entropy function \\(H(\\lambda)\\), show that it achieves its maximum value at \\(\\lambda=1/2\\). What is \\(H(1/2)\\)?\n* _C.1-15_  Show that for any integer \\(n\\geq 0\\), \\[\\sum_{k=0}^{n}\\begin{pmatrix}n\\\\ k\\end{pmatrix}k\\,=n\\;2^{n-1}\\.\\] (C.12)\n* _C.1-16_  Inequality (C.5) provides a lower bound on the binomial coefficient \\(\\binom{n}{k}\\). For small values of \\(k\\), a stronger bound holds. Prove that \\[\\begin{pmatrix}n\\\\ k\\end{pmatrix}\\geq\\,\\frac{n^{k}}{4k!}\\] (C.13) for \\(k\\,\\leq\\sqrt{n}\\).\n\n### Probability\n\nProbability is an essential tool for the design and analysis of probabilistic and randomized algorithms. This section reviews basic probability theory.\n\n### Probability\n\nWe define probability in terms of a _sample space_\\(S\\), which is a set whose elements are called _outcomes_ or _elementary events_. Think of each outcome as a possible result of an experiment. For the experiment of flipping two distinguishable coins, with each individual flip resulting in a head (h) or a tail (t), you can view the sample space \\(S\\) as consisting of the set of all possible 2-strings over {h,t}:\n\n\\(S=\\left\\{\\textsc{hh},\\textsc{ht},\\textsc{th},\\textsc{tt},\\textsc{tt}\\right\\}\\) .\n\nAn _event_ is a subset1 of the sample space \\(S\\). For example, in the experiment of flipping two coins, the event of obtaining one head and one tail is {ht,th}. The event \\(S\\) is called the _certain event_, and the event \\(\\emptyset\\) is called the _null event_. We say that two events \\(A\\) and \\(B\\) are _mutually exclusive_ if \\(A\\cap B=\\emptyset\\). An outcome \\(s\\) also defines the event \\(\\left\\{s\\right\\}\\), which we sometimes write as just \\(s\\). By definition, all outcomes are mutually exclusive.\n\nFootnote 1: For a general probability distribution, there may be some subsets of the sample space \\(S\\) that are not considered to be events. This situation usually arises when the sample space is uncountably infinite. The main requirement for what subsets are events is that the set of events of a sample space must be closed under the operations of taking the complement of an event, forming the union of a finite or countable number of events, and taking the intersection of a finite or countable number of events. Most of the probability distributions we see in this book are over finite or countable sample spaces, and we generally consider all subsets of a sample space to be events. A notable exception is the continuous uniform probability distribution, which we\u2019ll see shortly.\n\n#### Axioms of probability\n\nA _probability distribution_\\(\\Pr\\left\\{\\right\\}\\) on a sample space \\(S\\) is a mapping from events of \\(S\\) to real numbers satisfying the following _probability axioms_:\n\n1. \\(\\Pr\\left\\{A\\right\\}\\geq 0\\) for any event \\(A\\).\n2. \\(\\Pr\\left\\{S\\right\\}=1\\).\n3. \\(\\Pr\\left\\{A\\cup B\\right\\}=\\Pr\\left\\{A\\right\\}+\\Pr\\left\\{B\\right\\}\\) for any two mutually exclusive events \\(A\\) and \\(B\\). More generally, for any sequence of events \\(A_{1}\\), \\(A_{2}\\),...(finite or countably infinite) that are pairwise mutually exclusive,\n\n\\[\\Pr\\left\\{\\bigcup_{i}A_{i}\\right\\}=\\sum_{i}\\Pr\\left\\{A_{i}\\right\\}\\.\\]\n\nWe call \\(\\Pr\\left\\{A\\right\\}\\) the _probability_ of the event \\(A\\). Axiom 2 is simply a normalization requirement: there is really nothing fundamental about choosing 1 as the probability of the certain event, except that it is natural and convenient.\n\nSeveral results follow immediately from these axioms and basic set theory (see Section B.1). The null event \\(\\emptyset\\) has probability \\(\\Pr\\left\\{\\emptyset\\right\\}=\\quad 0\\). If \\(A\\subseteq B\\), then\\(\\Pr\\left\\{A\\right\\}\\leq\\Pr\\left\\{B\\right\\}\\). Using \\(\\overline{A}\\) to denote the event \\(S-A\\) (the _complement_ of \\(A\\)), we have \\(\\Pr\\left\\{\\overline{A}\\right\\}=1-\\Pr\\left\\{A\\right\\}\\). For any two events \\(A\\) and \\(B\\),\n\n\\[\\Pr\\left\\{A\\cup B\\right\\} = \\Pr\\left\\{A\\right\\}+\\Pr\\left\\{B\\right\\}-\\Pr\\left\\{A\\cap B\\right\\}\\] (C.14) \\[\\leq \\Pr\\left\\{A\\right\\}+\\Pr\\left\\{B\\right\\}\\.\\] (C.15)\n\nIn our coin-flipping example, suppose that each of the four outcomes has probability \\(1/4\\). Then the probability of getting at least one head is\n\n\\[\\Pr\\left\\{\\textsc{th},\\textsc{ht},\\textsc{th}\\right\\} = \\Pr\\left\\{\\textsc{th}\\right\\}+\\Pr\\left\\{\\textsc{ht}\\right\\}+\\Pr \\left\\{\\textsc{th}\\right\\}\\] \\[= 3/4\\.\\]\n\nAnother way to obtain the same result is to observe that since the probability of getting strictly less than one head is \\(\\Pr\\left\\{\\textsc{tt}\\right\\}=1/4\\), the probability of getting at least one head is \\(1-1/4=3/4\\).\n\n##### Discrete probability distributions\n\nA probability distribution is _discrete_ if it is defined over a finite or countably infinite sample space. Let \\(S\\) be the sample space. Then for any event \\(A\\),\n\n\\[\\Pr\\left\\{A\\right\\}=\\sum_{s\\in A}\\Pr\\left\\{s\\right\\}\\,\\]\n\nsince outcomes, specifically those in \\(A\\), are mutually exclusive. If \\(S\\) is finite and every outcome \\(s\\in S\\) has probability \\(\\Pr\\left\\{s\\right\\}=1/\\left|S\\right|\\), then we have the _uniform probability distribution_ on \\(S\\). In such a case the experiment is often described as \"picking an element of \\(S\\) at random.\"\n\nAs an example, consider the process of flipping a _fair coin_, one for which the probability of obtaining a head is the same as the probability of obtaining a tail, that is, \\(1/2\\). Flipping the coin \\(n\\) times gives the uniform probability distribution defined on the sample space \\(S=\\left\\{\\textsc{h},\\textsc{t}\\right\\}^{n}\\), a set of size \\(2^{n}\\). We can represent each outcome in \\(S\\) as a string of length \\(n\\) over \\(\\left\\{\\textsc{h},\\textsc{t}\\right\\}\\), with each string occurring with probability \\(1/2^{n}\\). The event \\(A=\\left\\{\\text{exactly }k\\text{ heads and exactly }n-k\\text{ tails occur}\\right\\}\\) is a subset of \\(S\\) of size \\(\\left|A\\right|=\\binom{n}{k}\\), since \\(\\binom{n}{k}\\) strings of length \\(n\\) over \\(\\left\\{\\textsc{h},\\textsc{t}\\right\\}\\) contain exactly \\(k\\) h's. The probability of event \\(A\\) is thus \\(\\Pr\\left\\{A\\right\\}=\\binom{n}{k}/2^{n}\\).\n\n##### Continuous uniform probability distribution\n\nThe continuous uniform probability distribution is an example of a probability distribution in which not all subsets of the sample space are considered to be events. The continuous uniform probability distribution is defined over a closed interval \\([a,b]\\) of the reals, where \\(a<b\\). The intuition is that each point in the interval \\([a,b]\\) should be \"equally likely.\" Because there are an uncountable number of points, however, if all points had the same finite, positive probability, axioms 2 and 3 would not be simultaneously satisfied. For this reason, we'd like to associate a probability only with _some_ of the subsets of \\(S\\) in such a way that the axioms are satisfied for these events.\n\nFor any closed interval \\([c,d]\\), where \\(a\\leq c\\leq d\\leq b\\), the _continuous uniform probability distribution_ defines the probability of the event \\([c,d]\\) to be\n\n\\[\\Pr\\left\\{[c,d]\\right\\}=\\frac{d-c}{b-a}\\.\\]\n\nLetting \\(c=d\\) gives that the probability of a single point is 0. Removing the endpoints \\([c,c]\\) and \\([d,d]\\) of an interval \\([c,d]\\) results in the open interval \\((c,d)\\). Since \\([c,d]=[c,c]\\cup(c,d)\\cup[d,d]\\), axiom 3 gives \\(\\Pr\\left\\{[c,d]\\right\\}=\\Pr\\left\\{(c,d)\\right\\}\\). Generally, the set of events for the continuous uniform probability distribution contains any subset of the sample space \\([a,b]\\) that can be obtained by a finite or countable union of open and closed intervals, as well as certain more complicated sets.\n\n##### Conditional probability and independence\n\nSometimes you have some prior partial knowledge about the outcome of an experiment. For example, suppose that a friend has flipped two fair coins and has told you that at least one of the coins showed a head. What is the probability that both coins are heads? The information given eliminates the possibility of two tails. The three remaining outcomes are equally likely, and so you infer that each occurs with probability \\(1/3\\). Since only one of these outcomes shows two heads, the answer is \\(1/3\\).\n\nConditional probability formalizes the notion of having prior partial knowledge of the outcome of an experiment. The _conditional probability_ of an event \\(A\\) given that another event \\(B\\) occurs is defined to be\n\n\\[\\Pr\\left\\{A\\ |\\ B\\right\\}=\\frac{\\Pr\\left\\{A\\cap B\\right\\}}{\\Pr\\left\\{B\\right\\}}\\] (C.16)\n\nwhenever \\(\\Pr\\left\\{B\\right\\}\\neq 0\\). (Read \"\\(\\Pr\\left\\{A\\ |\\ B\\right\\}\\)\" as \"the probability of \\(A\\) given \\(B\\).\") The idea behind equation (C.16) is that since we are given that event \\(B\\) occurs, the event that \\(A\\) also occurs is \\(A\\cap B\\). That is, \\(A\\cap B\\) is the set of outcomes in which both \\(A\\) and \\(B\\) occur. Because the outcome is one of the elementary events in \\(B\\), we normalize the probabilities of all the elementary events in \\(B\\) by dividing them by \\(\\Pr\\left\\{B\\right\\}\\), so that they sum to 1. The conditional probability of \\(A\\) given \\(B\\) is, therefore, the ratio of the probability of event \\(A\\cap B\\) to the probability of event \\(B\\). In the example above, \\(A\\) is the event that both coins are heads, and \\(B\\) is the event that at least one coin is a head. Thus, \\(\\Pr\\left\\{A\\ |\\ B\\right\\}=(1/4)/(3/4)=1/3\\).\n\nTwo events are _independent_ if\n\n\\[\\Pr\\left\\{A\\,\\cap\\,B\\right\\}=\\Pr\\left\\{A\\right\\}\\Pr\\left\\{B\\right\\}\\,\\] (C.17)\n\nwhich is equivalent, if \\(\\Pr\\left\\{B\\right\\}\\neq 0\\), to the condition\n\n\\[\\Pr\\left\\{A\\mid B\\right\\}=\\Pr\\left\\{A\\right\\}\\.\\]\n\nFor example, suppose that you flip two fair coins and that the outcomes are independent. Then the probability of two heads is \\((1/2)(1/2)=1/4\\). Now suppose that one event is that the first coin comes up heads and the other event is that the coins come up differently. Each of these events occurs with probability \\(1/2\\), and the probability that both events occur is \\(1/4\\). Thus, according to the definition of independence, the events are independent--even though you might think that both events depend on the first coin. Finally, suppose that the coins are welded together so that they both fall heads or both fall tails and that the two possibilities are equally likely. Then the probability that each coin comes up heads is \\(1/2\\), but the probability that they both come up heads is \\(1/2\\neq(1/2)(1/2)\\). Consequently, the event that one comes up heads and the event that the other comes up heads are not independent.\n\nA collection \\(A_{1},A_{2},\\ldots,A_{n}\\) of events is said to be _pairwise independent_ if\n\n\\[\\Pr\\left\\{A_{i}\\,\\cap\\,A_{j}\\right\\}=\\Pr\\left\\{A_{i}\\right\\}\\Pr\\left\\{A_{j}\\right\\}\\]\n\nfor all \\(1\\leq i<j\\leq n\\). We say that the events of the collection are _(mutually) independent_ if every \\(k\\)-subset \\(A_{i_{1}},A_{i_{2}},\\ldots,A_{i_{k}}\\) of the collection, where \\(2\\leq k\\leq n\\) and \\(1\\leq i_{1}<i_{2}<\\cdots<i_{k}\\leq n\\), satisfies\n\n\\[\\Pr\\left\\{A_{i_{1}}\\,\\cap\\,A_{i_{2}}\\,\\cap\\,\\cdots\\,A_{i_{k}}\\right\\}=\\Pr \\left\\{A_{i_{1}}\\right\\}\\Pr\\left\\{A_{i_{2}}\\right\\}\\cdots\\Pr\\left\\{A_{i_{k}} \\right\\}\\.\\]\n\nFor example, suppose that you flip two fair coins. Let \\(A_{1}\\) be the event that the first coin is heads, let \\(A_{2}\\) be the event that the second coin is heads, and let \\(A_{3}\\) be the event that the two coins are different. Then,\n\n\\[\\Pr\\left\\{A_{1}\\right\\} = 1/2\\,\\] \\[\\Pr\\left\\{A_{2}\\right\\} = 1/2\\,\\] \\[\\Pr\\left\\{A_{3}\\right\\} = 1/2\\,\\] \\[\\Pr\\left\\{A_{1}\\,\\cap\\,A_{2}\\right\\} = 1/4\\,\\] \\[\\Pr\\left\\{A_{1}\\,\\cap\\,A_{3}\\right\\} = 1/4\\,\\] \\[\\Pr\\left\\{A_{2}\\,\\cap\\,A_{3}\\right\\} = 1/4\\,\\] \\[\\Pr\\left\\{A_{1}\\,\\cap\\,A_{2}\\,\\cap\\,A_{3}\\right\\} = \\ \\ \\ 0\\.\\]\n\nSince for \\(1\\leq i<j\\leq 3\\), we have \\(\\Pr\\left\\{A_{i}\\,\\cap\\,A_{j}\\right\\}=\\Pr\\left\\{A_{i}\\right\\}\\Pr\\left\\{A_{j} \\right\\}=1/4\\), the events \\(A_{1}\\), \\(A_{2}\\), and \\(A_{3}\\) are pairwise independent. The events are not mutually independent, however, because \\(\\Pr\\left\\{A_{1}\\,\\cap\\,A_{2}\\,\\cap\\,A_{3}\\right\\}=0\\) and \\(\\Pr\\left\\{A_{1}\\right\\}\\Pr\\left\\{A_{2}\\right\\}\\Pr\\left\\{A_{3}\\right\\}=1/8\\neq 0\\).\n\n### Probability\n\n#### Bayes's theorem\n\nFrom the definition (C.16) of conditional probability and the commutative law \\(A\\cap B=B\\cap A\\), it follows that for two events \\(A\\) and \\(B\\), each with nonzero probability,\n\n\\[\\Pr\\left\\{A\\cap B\\right\\} = \\Pr\\left\\{B\\right\\}\\Pr\\left\\{A\\ \\mid\\ B\\right\\}\\] \\[= \\Pr\\left\\{A\\right\\}\\Pr\\left\\{B\\ \\mid\\ A\\right\\}\\.\\]\n\nSolving for \\(\\Pr\\left\\{A\\ \\mid\\ B\\right\\}\\), we obtain\n\n\\[\\Pr\\left\\{A\\ \\mid\\ B\\right\\}=\\frac{\\Pr\\left\\{A\\right\\}\\Pr\\left\\{B\\ \\mid\\ A\\right\\}}{\\Pr\\left\\{B\\right\\}}\\,\\] (C.19)\n\nwhich is known as _Bayes's theorem_. The denominator \\(\\Pr\\left\\{B\\right\\}\\) is a normalizing constant, which we can reformulate as follows. Since \\(B=(B\\cap A)\\cup(B\\cap\\overline{A})\\), and since \\(B\\cap A\\) and \\(B\\cap\\overline{A}\\) are mutually exclusive events,\n\n\\[\\Pr\\left\\{B\\right\\} = \\Pr\\left\\{B\\cap A\\right\\}+\\Pr\\left\\{B\\cap\\overline{A}\\right\\}\\] \\[= \\Pr\\left\\{A\\right\\}\\Pr\\left\\{B\\ \\mid\\ A\\right\\}+\\Pr\\left\\{ \\overline{A}\\right\\}\\Pr\\left\\{B\\ \\mid\\overline{A}\\right\\}\\.\\]\n\nSubstituting into equation (C.19) produces an equivalent form of Bayes's theorem:\n\n\\[\\Pr\\left\\{A\\ \\mid\\ B\\right\\}=\\frac{\\Pr\\left\\{A\\right\\}\\Pr\\left\\{B\\ \\mid\\ A\\right\\}}{\\Pr\\left\\{A\\right\\}\\Pr\\left\\{B\\ \\mid\\ A\\right\\}+\\Pr\\left\\{\\overline{A}\\right\\}\\Pr\\left\\{B\\ \\mid\\overline{A}\\right\\}}\\.\\] (C.20)\n\nBayes's theorem can simplify the computing of conditional probabilities. For example, suppose that you have a fair coin and a biased coin that always comes up heads. Run an experiment consisting of three independent events: choose one of the two coins at random, flip that coin once, and then flip it again. Suppose that the coin you have chosen comes up heads both times. What is the probability that it's the biased coin?\n\nBayes's theorem solves this problem. Let \\(A\\) be the event that you choose the biased coin, and let \\(B\\) be the event that the chosen coin comes up heads both times. We wish to determine \\(\\Pr\\left\\{A\\ \\mid\\ B\\right\\}\\), knowing that \\(\\Pr\\left\\{A\\right\\}=1/2\\), \\(\\Pr\\left\\{B\\ \\mid\\ A\\right\\}=1\\), \\(\\Pr\\left\\{\\overline{A}\\right\\}=1/2\\), and \\(\\Pr\\left\\{B\\ \\mid\\ \\overline{A}\\right\\}=1/4\\). Thus we have\n\n\\[\\Pr\\left\\{A\\ \\mid\\ B\\right\\} = \\frac{(1/2)\\cdot 1}{(1/2)\\cdot 1+(1/2)\\cdot(1/4)}\\] \\[= 4/5\\.\\]\n\n## Exercises\n\n### \\(C.2\\)-I\n\nProfessor Rosencrantz flips a fair coin twice. Professor Guildenstern flips a fair coin once. What is the probability that Professor Rosencrantz obtains strictly more heads than Professor Guildenstern?\n\n### \\(C.2\\)-2\n\nProve _Boole's inequality_: For any finite or countably infinite sequence of events \\(A_{1},A_{2},\\ldots\\),\n\n\\[\\Pr\\left\\{A_{1}\\cup A_{2}\\cup\\cdots\\right\\}\\leq\\Pr\\left\\{A_{1}\\right\\}+\\Pr \\left\\{A_{2}\\right\\}+\\cdots\\.\\] (C.21)\n\n### \\(C.2\\)-3\n\nYou shuffle a deck of 10 cards, each bearing a distinct number from 1 to 10, in order to mix the cards thoroughly. You then remove three cards, one at a time, from the deck. What is the probability that the three cards you select are in sorted (increasing) order?\n\n### \\(C.2\\)-4\n\nProve that\n\n\\[\\Pr\\left\\{A\\ |\\ B\\right\\}+\\Pr\\left\\{\\overline{A}\\ |\\ B\\right\\}=1\\.\\] \\[C.2\\] \\[\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad \\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad \\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad \\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad \\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad \\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad \\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad \\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad \\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad \\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad \\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad \\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad \\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad \\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad \\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad \\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad \\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad \\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad \\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad \\them will pass the course and the other two will fail. Carmine asks Professor Gore privately which of Jeff and Tim will fail, arguing that since he already knows at least one of them will fail, the professor won't be revealing any information about Carmine's outcome. In a breach of privacy law, Professor Gore tells Carmine that Jeff will fail. Carmine feels somewhat relieved now, figuring that either he or Tim will pass, so that his probability of passing is now \\(1/2\\). Is Carmine correct, or is his chance of passing still \\(1/3\\)? Explain.\n\n### Discrete random variables\n\nA _(discrete) random variable_\\(X\\) is a function from a finite or countably infinite sample space \\(S\\) to the real numbers. It associates a real number with each possible outcome of an experiment, which allows us to work with the probability distribution induced on the resulting set of numbers. Random variables can also be defined for uncountably infinite sample spaces, but they raise technical issues that are unnecessary to address for our purposes. Therefore we'll assume that random variables are discrete.\n\nFor a random variable \\(X\\) and a real number \\(x\\), we define the event \\(X=x\\) to be \\(\\{s\\in S:X(s)=x\\}\\), and thus\n\n\\[\\Pr\\left\\{X=x\\right\\}=\\hskip-28.452756pt\\sum_{s\\in S:X(s)=x}\\hskip-28.452756pt \\Pr\\left\\{s\\right\\}\\enspace.\\]\n\nThe function\n\n\\[f(x)=\\Pr\\left\\{X=x\\right\\}\\]\n\nis the _probability density function_ of the random variable \\(X\\). From the probability axioms, \\(\\Pr\\left\\{X=x\\right\\}\\geq 0\\) and \\(\\sum_{x}\\Pr\\left\\{X=x\\right\\}=1\\).\n\nAs an example, consider the experiment of rolling a pair of ordinary, 6-sided dice. There are 36 possible outcomes in the sample space. Assume that the probability distribution is uniform, so that each outcome \\(s\\in S\\) is equally likely: \\(\\Pr\\left\\{s\\right\\}=1/36\\). Define the random variable \\(X\\) to be the _maximum_ of the two values showing on the dice. We have \\(\\Pr\\left\\{X=3\\right\\}=5/36\\), since \\(X\\) assigns a value of 3 to 5 of the 36 possible outcomes, namely, \\((1,3)\\), \\((2,3)\\), \\((3,3)\\), \\((3,2)\\), and \\((3,1)\\).\n\nWe can define several random variables on the same sample space. If \\(X\\) and \\(Y\\) are random variables, the function\n\n\\[f(x,y)=\\Pr\\left\\{X=x\\text{ and }Y=y\\right\\}\\]\n\nis the _joint probability density function_ of \\(X\\) and \\(Y\\). For a fixed value \\(y\\)",
        "chapter": "Part VIII Appendix: Mathematical Background",
        "section": "C Counting and Probability",
        "subsection": "C.2 Probability",
        "subsubsection": "N/A"
    },
    {
        "content": "them will pass the course and the other two will fail. Carmine asks Professor Gore privately which of Jeff and Tim will fail, arguing that since he already knows at least one of them will fail, the professor won't be revealing any information about Carmine's outcome. In a breach of privacy law, Professor Gore tells Carmine that Jeff will fail. Carmine feels somewhat relieved now, figuring that either he or Tim will pass, so that his probability of passing is now \\(1/2\\). Is Carmine correct, or is his chance of passing still \\(1/3\\)? Explain.\n\n### Discrete random variables\n\nA _(discrete) random variable_\\(X\\) is a function from a finite or countably infinite sample space \\(S\\) to the real numbers. It associates a real number with each possible outcome of an experiment, which allows us to work with the probability distribution induced on the resulting set of numbers. Random variables can also be defined for uncountably infinite sample spaces, but they raise technical issues that are unnecessary to address for our purposes. Therefore we'll assume that random variables are discrete.\n\nFor a random variable \\(X\\) and a real number \\(x\\), we define the event \\(X=x\\) to be \\(\\{s\\in S:X(s)=x\\}\\), and thus\n\n\\[\\Pr\\left\\{X=x\\right\\}=\\hskip-28.452756pt\\sum_{s\\in S:X(s)=x}\\hskip-28.452756pt \\Pr\\left\\{s\\right\\}\\.\\]\n\nThe function\n\n\\[f(x)=\\Pr\\left\\{X=x\\right\\}\\]\n\nis the _probability density function_ of the random variable \\(X\\). From the probability axioms, \\(\\Pr\\left\\{X=x\\right\\}\\geq 0\\) and \\(\\sum_{x}\\Pr\\left\\{X=x\\right\\}=1\\).\n\nAs an example, consider the experiment of rolling a pair of ordinary, 6-sided dice. There are 36 possible outcomes in the sample space. Assume that the probability distribution is uniform, so that each outcome \\(s\\in S\\) is equally likely: \\(\\Pr\\left\\{s\\right\\}=1/36\\). Define the random variable \\(X\\) to be the _maximum_ of the two values showing on the dice. We have \\(\\Pr\\left\\{X=3\\right\\}=5/36\\), since \\(X\\) assigns a value of 3 to 5 of the 36 possible outcomes, namely, \\((1,3)\\), \\((2,3)\\), \\((3,3)\\), \\((3,2)\\), and \\((3,1)\\).\n\nWe can define several random variables on the same sample space. If \\(X\\) and \\(Y\\) are random variables, the function\n\n\\[f(x,y)=\\Pr\\left\\{X=x\\text{ and }Y=y\\right\\}\\]\n\nis the _joint probability density function_ of \\(X\\) and \\(Y\\). For a fixed value \\(y\\)\\[\\Pr\\left\\{Y\\,=\\,y\\right\\}=\\sum_{x}\\Pr\\left\\{X\\,=\\,x\\text{ and }Y\\,=\\,y\\right\\}\\;,\\] and similarly, for a fixed value \\(x\\), \\[\\Pr\\left\\{X\\,=\\,x\\right\\}=\\sum_{y}\\Pr\\left\\{X\\,=\\,x\\text{ and }Y\\,=\\,y\\right\\}\\;.\\] Using the definition (C.16) of conditional probability on page 1187, we have \\[\\Pr\\left\\{X\\,=\\,x\\,\\mid\\,Y\\,=\\,y\\right\\}=\\frac{\\Pr\\left\\{X\\,=\\,x\\text{ and }Y\\,=\\,y\\right\\}}{\\Pr\\left\\{Y\\,=\\,y\\right\\}}\\;.\\] We define two random variables \\(X\\) and \\(Y\\) to be _independent_ if for all \\(x\\) and \\(y\\), the events \\(X=x\\) and \\(Y=y\\) are independent or, equivalently, if for all \\(x\\) and \\(y\\), we have \\(\\Pr\\left\\{X\\,=\\,x\\text{ and }Y\\,=\\,y\\right\\}=\\Pr\\left\\{X\\,=\\,x\\right\\}\\Pr \\left\\{Y\\,=\\,y\\right\\}\\).\n\nGiven a set of random variables defined over the same sample space, we can define new random variables as sums, products, or other functions of the original variables.\n\n##### Expected value of a random variable\n\nThe simplest, and often the most useful, summary of the distribution of a random variable is the \"average\" of the values it takes on. The _expected value_ (or, synonymously, _expectation_ or _mean_) of a discrete random variable \\(X\\) is\n\n\\[\\operatorname{E}\\left[X\\right]=\\sum_{x}x\\,\\cdot\\Pr\\left\\{X\\,=\\,x\\right\\}\\;,\\] (C.23)\n\nwhich is well defined if the sum is finite or converges absolutely. Sometimes the expectation of \\(X\\) is denoted by \\(\\mu_{X}\\) or, when the random variable is apparent from context, simply by \\(\\mu\\).\n\nConsider a game in which you flip two fair coins. You earn $3 for each head but lose $2 for each tail. The expected value of the random variable \\(X\\) representing your earnings is\n\n\\[\\operatorname{E}\\left[X\\right] =\\;6\\cdot\\Pr\\left\\{2\\text{ h's}\\right\\}\\,+\\,1\\cdot\\Pr\\left\\{1\\text{ h},1\\text{ t}\\right\\}-4\\cdot\\Pr\\left\\{2\\text{ t's}\\right\\}\\] \\[=\\;6\\cdot(1/4)\\,+\\,1\\cdot(1/2)-4\\cdot(1/4)\\] \\[=\\;1\\;.\\]\n\n##### Linearity of expectation\n\n_s_ays that the expectation of the sum of two random variables is the sum of their expectations, that is,\n\n\\[\\operatorname{E}\\left[X\\,+\\,Y\\right]=\\operatorname{E}\\left[X\\right]+ \\operatorname{E}\\left[Y\\right]\\;,\\] (C.24)whenever \\(\\mathrm{E}\\left[X\\right]\\) and \\(\\mathrm{E}\\left[Y\\right]\\) are defined. Linearity of expectation applies to a broad range of situations, holding even when \\(X\\) and \\(Y\\) are not independent. It also extends to finite and absolutely convergent summations of expectations. Linearity of expectation is the key property that enables us to perform probabilistic analyses by using indicator random variables (see Section 5.2).\n\nIf \\(X\\) is any random variable, any function \\(g(x)\\) defines a new random variable \\(g(X).\\) If the expectation of \\(g(X)\\) is defined, then\n\n\\[\\mathrm{E}\\left[g(X)\\right]=\\sum_{x}g(x)\\cdot\\Pr\\left\\{X\\,=\\,x\\right\\}\\.\\]\n\nLetting \\(g(x)=ax,\\) we have for any constant \\(a,\\)\n\n\\[\\mathrm{E}\\left[a\\,X\\right]=a\\mathrm{E}\\left[X\\right]\\.\\] (C.25)\n\nConsequently, expectations are linear: for any two random variables \\(X\\) and \\(Y\\) and any constant \\(a\\),\n\n\\[\\mathrm{E}\\left[a\\,X\\,+\\,Y\\right]=a\\mathrm{E}\\left[X\\right]+\\mathrm{E}\\left[Y \\right]\\.\\] (C.26)\n\nWhen two random variables \\(X\\) and \\(Y\\) are independent and each has a defined expectation,\n\n\\[\\mathrm{E}\\left[XY\\right] = \\sum_{x}\\sum_{y}xy\\cdot\\Pr\\left\\{X\\,=\\,x\\text{ and }Y\\,=\\,y\\right\\}\\] \\[= \\sum_{x}\\sum_{y}xy\\cdot\\Pr\\left\\{X\\,=\\,x\\right\\}\\Pr\\left\\{Y\\,=\\, y\\right\\}\\quad\\text{(by independence of $X$ and $Y$)}\\] \\[= \\left(\\sum_{x}x\\cdot\\Pr\\left\\{X\\,=\\,x\\right\\}\\right)\\left(\\sum_{ y}y\\cdot\\Pr\\left\\{Y\\,=\\,y\\right\\}\\right)\\] \\[= \\mathrm{E}\\left[X\\right]\\mathrm{E}\\left[Y\\right]\\qquad\\qquad \\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad \\since each term \\(\\Pr\\left\\{X\\geq i\\right\\}\\) is added in \\(i\\) times and subtracted out \\(i-1\\) times (except \\(\\Pr\\left\\{X\\geq 0\\right\\}\\), which is added in \\(0\\) times and not subtracted out at all).\n\nA function \\(f(x)\\) is _convex_ if\n\n\\[f(\\lambda x+(1-\\lambda)y)\\leq\\lambda f(x)\\ \\ +(1-\\lambda)f(y)\\] (C.29)\n\nfor all \\(x\\) and \\(y\\) and for all \\(0\\leq\\lambda\\leq 1\\). _Jensen's inequality_ says that when a convex function \\(f(x)\\) is applied to a random variable \\(X\\),\n\n\\[\\mathrm{E}\\left[f(X)\\right]\\geq\\,f(\\mathrm{E}\\left[X\\right])\\,\\] (C.30)\n\nprovided that the expectations exist and are finite.\n\n### Variance and standard deviation\n\nThe expected value of a random variable does not express how \"spread out\" the variable's values are. For example, consider random variables \\(X\\) and \\(Y\\) for which \\(\\Pr\\left\\{X=1/4\\right\\}=\\Pr\\left\\{X=3/4\\right\\}=1/2\\) and \\(\\Pr\\left\\{Y=0\\right\\}=\\Pr\\left\\{Y=1\\right\\}=1/2\\). Then both \\(\\mathrm{E}\\left[X\\right]\\) and \\(\\mathrm{E}\\left[Y\\right]\\) are \\(1/2\\), yet the actual values taken on by \\(Y\\) are further from the mean than the actual values taken on by \\(X\\).\n\nThe notion of variance mathematically expresses how far from the mean a random variable's values are likely to be. The _variance_ of a random variable \\(X\\) with mean \\(\\mathrm{E}\\left[X\\right]\\) is\n\n\\[\\mathrm{Var}\\left[X\\right] = \\mathrm{E}\\left[(X-\\mathrm{E}\\left[X\\right])^{2}\\right]\\] (C.31) \\[= \\mathrm{E}\\left[X^{2}-2X\\mathrm{E}\\left[X\\right]+\\mathrm{E}^{2} \\left[X\\right]\\right]\\] \\[= \\mathrm{E}\\left[X^{2}\\right]-2\\mathrm{E}\\left[X\\mathrm{E}\\left[X \\right]\\right]+\\mathrm{E}^{2}\\left[X\\right]\\] \\[= \\mathrm{E}\\left[X^{2}\\right]-2\\mathrm{E}^{2}\\left[X\\right]+ \\mathrm{E}^{2}\\left[X\\right]\\] \\[= \\mathrm{E}\\left[X^{2}\\right]-\\mathrm{E}^{2}\\left[X\\right]\\.\\]\n\nTo justify the equation \\(\\mathrm{E}\\left[\\mathrm{E}^{2}\\left[X\\right]\\right]=\\mathrm{E}^{2}\\left[X\\right]\\), note that because \\(\\mathrm{E}\\left[X\\right]\\) is a real number and not a random variable, so is \\(\\mathrm{E}^{2}\\left[X\\right]\\). The equation \\(\\mathrm{E}\\left[X\\mathrm{E}\\left[X\\right]\\right]=\\mathrm{E}^{2}\\left[X\\right]\\) follows from equation (C.25), with \\(a\\,=\\mathrm{E}\\left[X\\right]\\). Rewriting equation (C.31) yields an expression for the expectation of the square of a random variable:\n\n\\[\\mathrm{E}\\left[X^{2}\\right]=\\mathrm{Var}\\left[X\\right]+\\mathrm{E}^{2}\\left[X \\right]\\.\\] (C.32)\n\nThe variance of a random variable \\(X\\) and the variance of \\(a\\,X\\) are related (see Exercise C.3-10):\n\n\\[\\mathrm{Var}\\left[a\\,X\\right]=a^{2}\\mathrm{Var}\\left[X\\right]\\.\\]\n\nWhen \\(X\\) and \\(Y\\) are independent random variables,\n\n\\[\\mathrm{Var}\\left[X\\,+\\,Y\\right]=\\mathrm{Var}\\left[X\\right]+\\mathrm{Var}\\left[Y \\right]\\.\\]\n\n### Discrete random variables\n\nIn general, if \\(n\\) random variables \\(X_{1}\\), \\(X_{2},\\ldots,X_{n}\\) are pairwise independent, then\n\n\\[\\mbox{Var}\\left[\\sum_{i\\,=\\,1}^{n}X_{i}\\right]=\\,\\sum_{i\\,=\\,1}^{n}\\mbox{Var} \\left[X_{i}\\right]\\enspace.\\] (C.33)\n\nThe _standard deviation_ of a random variable \\(X\\) is the nonnegative square root of the variance of \\(X\\). The standard deviation of a random variable \\(X\\) is sometimes denoted \\(\\sigma_{X}\\) or simply \\(\\sigma\\) when the random variable \\(X\\) is understood from context. With this notation, the variance of \\(X\\) is denoted \\(\\sigma^{2}\\).\n\n**Exercises**:\n\n_C.3-1_\n\nYou roll two ordinary, 6-sided dice. What is the expectation of the sum of the two values showing? What is the expectation of the maximum of the two values showing?\n\n_C.3-2_\n\nAn array \\(A[1:n]\\) contains \\(n\\) distinct numbers that are randomly ordered, with each permutation of the \\(n\\) numbers being equally likely. What is the expectation of the index of the maximum element in the array? What is the expectation of the index of the minimum element in the array?\n\n_C.3-3_\n\nA carnival game consists of three dice in a cage. A player can bet a dollar on any of the numbers 1 through 6. The cage is shaken, and the payoff is as follows. If the player's number doesn't appear on any of the dice, the player loses the dollar. Otherwise, if the player's number appears on exactly \\(k\\) of the three dice, for \\(k=1,2,3\\), the player keeps the dollar and wins \\(k\\) more dollars. What is the expected gain from playing the carnival game once?\n\n_C.3-4_\n\nArgue that if \\(X\\) and \\(Y\\) are nonnegative random variables, then\n\n\\[\\mbox{E}\\left[\\max\\left\\{X,Y\\right\\}\\right]\\leq\\mbox{E}\\left[X\\right]+\\mbox{E} \\left[Y\\right]\\enspace.\\]\n\n_C.3-5_\n\nLet \\(X\\) and \\(Y\\) be independent random variables. Prove that \\(f(X)\\) and \\(g(Y)\\) are independent for any choice of functions \\(f\\) and \\(g\\).\n\n* _C3-6_ Let \\(X\\) be a nonnegative random variable, and suppose that \\(\\mathrm{E}\\left[X\\right]\\) is well defined. Prove _Markov's inequality_: \\[\\Pr\\left\\{X\\geq t\\right\\}\\leq\\mathrm{E}\\left[X\\right]/t\\] (C.34) for all \\(t>0\\).\n* _C3-7_ Let \\(S\\) be a sample space, and let \\(X\\) and \\(X^{\\prime}\\) be random variables such that \\(X(s)\\geq X^{\\prime}(s)\\) for all \\(s\\in S\\). Prove that for any real constant \\(t\\), \\[\\Pr\\left\\{X\\geq t\\right\\}\\geq\\Pr\\left\\{X^{\\prime}\\geq t\\right\\}\\.\\] _C3-8_ Which is larger: the expectation of the square of a random variable, or the square of its expectation? _C3-9_ Show that for any random variable \\(X\\) that takes on only the values \\(0\\) and \\(1\\), we have \\(\\mathrm{Var}\\left[X\\right]=\\mathrm{E}\\left[X\\right]\\mathrm{E}\\left[1-X\\right]\\). _C3-10_ Prove that \\(\\mathrm{Var}\\left[aX\\right]=a^{2}\\mathrm{Var}\\left[X\\right]\\) from the definition (C.31) of variance.\n\n### The geometric and binomial distributions\n\nA _Bernoulli trial_ is an experiment with only two possible outcomes: _success_, which occurs with probability \\(p\\), and _failure_, which occurs with probability \\(q=1-p\\). A coin flip serves as an example where, depending on your point of view, heads equates to success and tails to failure. When we speak of _Bernoulli trials_ collectively, we mean that the trials are mutually independent and, unless we specifically say otherwise, that each has the same probability \\(p\\) for success. Two important distributions arise from Bernoulli trials: the geometric distribution and the binomial distribution.\n\n### The geometric distribution\n\nConsider a sequence of Bernoulli trials, each with a probability \\(p\\) of success and a probability \\(q=1-p\\) of failure. How many trials occur before a success? Define the random variable \\(X\\) to be the number of trials needed to obtain a success. Then \\(X\\) has values in the range \\(\\left\\{1,2,\\ldots\\right\\}\\), and for \\(k\\geq 1\\),",
        "chapter": "Part VIII Appendix: Mathematical Background",
        "section": "C Counting and Probability",
        "subsection": "C.3 Discrete random variables",
        "subsubsection": "N/A"
    },
    {
        "content": "* _C3-6_ Let \\(X\\) be a nonnegative random variable, and suppose that \\(\\mathrm{E}\\left[X\\right]\\) is well defined. Prove _Markov's inequality_: \\[\\Pr\\left\\{X\\geq t\\right\\}\\leq\\mathrm{E}\\left[X\\right]/t\\] (C.34) for all \\(t>0\\).\n* _C3-7_ Let \\(S\\) be a sample space, and let \\(X\\) and \\(X^{\\prime}\\) be random variables such that \\(X(s)\\geq X^{\\prime}(s)\\) for all \\(s\\in S\\). Prove that for any real constant \\(t\\), \\[\\Pr\\left\\{X\\geq t\\right\\}\\geq\\Pr\\left\\{X^{\\prime}\\geq t\\right\\}\\enspace.\\] _C3-8_ Which is larger: the expectation of the square of a random variable, or the square of its expectation? _C3-9_ Show that for any random variable \\(X\\) that takes on only the values \\(0\\) and \\(1\\), we have \\(\\mathrm{Var}\\left[X\\right]=\\mathrm{E}\\left[X\\right]\\mathrm{E}\\left[1-X\\right]\\). _C3-10_ Prove that \\(\\mathrm{Var}\\left[aX\\right]=a^{2}\\mathrm{Var}\\left[X\\right]\\) from the definition (C.31) of variance.\n\n### The geometric and binomial distributions\n\nA _Bernoulli trial_ is an experiment with only two possible outcomes: _success_, which occurs with probability \\(p\\), and _failure_, which occurs with probability \\(q=1-p\\). A coin flip serves as an example where, depending on your point of view, heads equates to success and tails to failure. When we speak of _Bernoulli trials_ collectively, we mean that the trials are mutually independent and, unless we specifically say otherwise, that each has the same probability \\(p\\) for success. Two important distributions arise from Bernoulli trials: the geometric distribution and the binomial distribution.\n\n### The geometric distribution\n\nConsider a sequence of Bernoulli trials, each with a probability \\(p\\) of success and a probability \\(q=1-p\\) of failure. How many trials occur before a success? Define the random variable \\(X\\) to be the number of trials needed to obtain a success. Then \\(X\\) has values in the range \\(\\left\\{1,2,\\ldots\\right\\}\\), and for \\(k\\geq 1\\),\n\n### The geometric and binomial distributions\n\n\\[\\Pr\\left\\{X=k\\right\\}=q^{k-1}\\,p\\,\\] (C.35)\n\nsince \\(k-1\\) failures occur before the first success. A probability distribution satisfying equation (C.35) is said to be a _geometric distribution_. Figure C.1 illustrates such a distribution.\n\nAssuming that \\(q<1\\), we can calculate the expectation of a geometric distribution:\n\n\\[\\mathrm{E}\\left[X\\right] = \\sum_{k=1}^{\\infty}kq^{k-1}\\,p\\] (C.36) \\[= \\frac{p}{q}\\sum_{k=0}^{\\infty}kq^{k}\\] \\[= \\frac{p}{q}\\cdot\\frac{q}{(1-q)^{2}}\\quad\\text{(by equation (A.11) on page 1142)}\\] \\[= \\frac{p}{q}\\cdot\\frac{q}{p^{2}}\\] \\[= 1/p\\]\n\nFigure C.1: A geometric distribution with probability \\(p=1/3\\) of success and a probability \\(q=1-p\\) of failure. The expectation of the distribution is \\(1/p=3\\).\n\nThus, on average, it takes \\(1/p\\) trials before a success occurs, an intuitive result. As Exercise C.4-3 asks you to show, the variance is\n\n\\[\\operatorname{Var}\\left[X\\right]=q/p^{2}\\.\\] (C.37)\n\nAs an example, suppose that you repeatedly roll two dice until you obtain either a seven or an eleven. Of the 36 possible outcomes, 6 yield a seven and 2 yield an eleven. Thus, the probability of success is \\(p=8/36=2/9\\), and you'd have to roll \\(1/p=9/2=4.5\\) times on average to obtain a seven or eleven.\n\n##### The binomial distribution\n\nHow many successes occur during \\(n\\) Bernoulli trials, where a success occurs with probability \\(p\\) and a failure with probability \\(q=1-p\\)? Define the random variable \\(X\\) to be the number of successes in \\(n\\) trials. Then \\(X\\) has values in the range \\(\\{0,1,\\ldots,n\\}\\), and for \\(k=0,1,\\ldots,n\\),\n\n\\[\\operatorname{Pr}\\left\\{X=k\\right\\}=\\binom{n}{k}p^{k}q^{n-k}\\,\\] (C.38)\n\nsince there are \\(\\binom{n}{k}\\) ways to pick which \\(k\\) of the \\(n\\) trials are successes, and the probability that each occurs is \\(p^{k}q^{n-k}\\). A probability distribution satisfying equation (C.38) is said to be a _binomial distribution_. For convenience, we define the family of binomial distributions using the notation\n\n\\[b(k;n\\,,\\,p)=\\binom{n}{k}p^{k}(1-p)^{n-k}\\.\\] (C.39)\n\nFigure C.2 illustrates a binomial distribution. The name \"binomial\" comes from the right-hand side of equation (C.38) being the \\(k\\)th term of the expansion of \\((p+q)^{n}\\). Consequently, since \\(p+q=1\\), equation (C.4) on page 1181 gives\n\n\\[\\sum_{k=0}^{n}b(k;n\\,,\\,p)=1\\,\\] (C.40)\n\nas axiom 2 of the probability axioms requires.\n\nWe can compute the expectation of a random variable having a binomial distribution from equations (C.9) and (C.40). Let \\(X\\) be a random variable that follows the binomial distribution \\(b(k;n\\,,\\,p)\\), and let \\(q=1-p\\). The definition of expectation gives\n\n### The geometric and binomial distributions\n\nLinearity of expectation produces the same result with substantially less algebra. Let \\(X_{i}\\) be the random variable describing the number of successes in the \\(i\\)th trial. Then \\(\\mbox{E}\\left[X_{i}\\right]=\\,p\\cdot 1+q\\cdot 0=\\,p\\), and the expected number of successes for \\(n\\) trials is\n\nFigure C.2: The binomial distribution \\(b(k;15,1/3)\\) resulting from \\(n=15\\) Bernoulli trials, each with probability \\(\\,p=1/3\\) of success. The expectation of the distribution is \\(np=5\\).\n\n\\[\\mathrm{E}\\left[X\\right] = \\mathrm{E}\\left[\\sum_{i=1}^{n}X_{i}\\right]\\] (C.42) \\[= \\sum_{i\\,=\\,1}^{n}\\mathrm{E}\\left[X_{i}\\right]\\quad\\text{ (by equation (C.24) on page 1192)}\\] \\[= \\sum_{i\\,=\\,1}^{n}p\\] \\[= np\\]\n\nWe can use the same approach to calculate the variance of the distribution. By equation (C.31), \\(\\mathrm{Var}\\left[X_{i}\\right]=\\mathrm{E}\\left[X_{i}^{2}\\right]-\\mathrm{E}^{2 }\\left[X_{i}\\right]\\). Since \\(X_{i}\\) takes on only the values \\(0\\) and \\(1\\), we have \\(X_{i}^{2}=X_{i}\\), which implies \\(\\mathrm{E}\\left[X_{i}^{2}\\right]=\\mathrm{E}\\left[X_{i}\\right]=p\\). Hence,\n\n\\[\\mathrm{Var}\\left[X_{i}\\right]=p-p^{2}=p(1-p)=pq\\.\\] (C.43)\n\nTo compute the variance of \\(X\\), we take advantage of the independence of the \\(n\\) trials. By equation (C.33), we have\n\n\\[\\mathrm{Var}\\left[X\\right] = \\mathrm{Var}\\left[\\sum_{i\\,=\\,1}^{n}X_{i}\\right]\\] (C.44) \\[= \\sum_{i\\,=\\,1}^{n}\\mathrm{Var}\\left[X_{i}\\right]\\] \\[= \\sum_{i\\,=\\,1}^{n}pq\\] \\[= npq\\.\\]\n\nAs Figure C.2 shows, the binomial distribution \\(b(k;n\\,,\\,p)\\) increases with \\(k\\) until it reaches the mean \\(np\\), and then it decreases. To prove that the distribution always behaves in this manner, examine the ratio of successive terms:\n\n\\[\\frac{b(k;n\\,,\\,p)}{b(k-1;n\\,,\\,p)} = \\frac{\\binom{n}{k}p^{k}q^{n-k}}{\\binom{n}{k-1}p^{k-1}q^{n-k+1}}\\] (C.45) \\[= \\frac{n!\\,(k-1)!\\,(n-k+1)!\\,p}{k!\\,(n-k)!\\,n!\\,q}\\] \\[= \\frac{(n-k+1)p}{kq}\\] \\[= 1+\\frac{(n-k+1)p-kq}{kq}\\] \\[= 1+\\frac{(n-k+1)p-k(1-p)}{kq}\\]\n\n### The geometric and binomial distributions\n\n\\[=\\ 1\\,+\\,\\frac{(n\\,+\\,1)\\,p-k}{kq}\\.\\]\n\nThis ratio is greater than 1 precisely when \\((n\\,+\\,1)\\,p-k\\) is positive. Consequently, \\(b(k;n,\\,p)\\!>\\!b(k\\quad-\\,1;n,\\,p)\\) for \\(k\\!<\\!(n\\quad+\\,1)\\,p\\) (the distribution increases), and \\(b(k;n,\\,p)\\!<\\!b(k\\quad-\\,1;n,\\,p)\\) for \\(k\\!>\\!(n\\quad+\\,1)\\,p\\) (the distribution decreases). If \\((n\\,+\\,1)\\,p\\) is an integer, then for \\(k\\,=\\,(n\\,+\\,1)\\,p\\), the ratio \\(b(k;n,\\,p)/b(k\\,-\\,1;n,\\,p)\\) equals 1, so that \\(b(k;n,\\,p)\\,=\\,b(k\\,-\\,1;n,\\,p)\\). In this case, the distribution has two maxima: at \\(k\\,=\\,(n\\,+\\,1)\\,p\\) and at \\(k\\,-\\,1\\,=\\,(n\\,+\\,1)\\,p\\,-\\,1\\,=\\,np\\,-q\\). Otherwise, it attains a maximum at the unique integer \\(k\\) that lies in the range \\(np\\,-\\,q\\,<\\,k\\,<\\,(n\\,+\\,1)\\,p\\).\n\nThe following lemma provides an upper bound on the binomial distribution.\n\n**Lemma C.1**: _Let \\(n\\,\\geq\\,0\\), let \\(0\\,<\\,p\\,<\\,1\\), let \\(q\\,=\\,1\\,-\\,p\\), and let \\(0\\,\\leq\\,k\\,\\leq\\,n\\). Then_\n\n\\[b(k;n,\\,p)\\,\\leq\\,\\left(\\frac{np}{k}\\right)^{k}\\,\\left(\\frac{n\\,q}{n-k}\\right) ^{n-k}\\.\\]\n\n_Proof_ We have\n\n\\[b(k;n,\\,p) = \\binom{n}{k}p^{k}q^{n-k}\\] \\[\\leq \\left(\\frac{n}{k}\\right)^{k}\\,\\left(\\frac{n}{n-k}\\right)^{n-k}\\,p ^{k}q^{n-k}\\quad\\mbox{(by inequality (C.7) on page 1182)}\\] \\[= \\left(\\frac{np}{k}\\right)^{k}\\,\\left(\\frac{n\\,q}{n-k}\\right)^{n-k}\\.\\]\n\n**Exercises**\n\n### C.4-1\n\n_Verify axiom 2 of the probability axioms for the geometric distribution._\n\n### C.4-2\n\n_How many times on average do you need to flip six fair coins before obtaining three heads and three tails?_\n\n### C.4-3\n\n_Show that the variance of the geometric distribution is_ \\(q/\\,p^{2}\\)_. (_Hint:_ Use Exercise A.1-6 on page 1144.)_\n\n### C.4-4\n\n_Show that_ \\(b(k;n,\\,p)\\,=\\,b(n-k;n,q)\\)_, where_ \\(q\\,=\\,1\\,-\\,p\\)_.__C.4-5_ Show that the value of the maximum of the binomial distribution \\(b(k;n,\\,p)\\) is approximately \\(1/\\sqrt{2\\pi\\,npq}\\), where \\(q=1-p\\).\n* _C.4-6_ Show that the probability of no successes in \\(n\\) Bernoulli trials, each with probability \\(p=1/n\\) of success, is approximately \\(1/e\\). Show that the probability of exactly one success is also approximately \\(1/e\\).\n* _C.4-7_ Professor Rosencrantz flips a fair coin \\(n\\) times, and so does Professor Guildenern. Show that the probability that they get the same number of heads is \\(\\binom{2n}{n}/4^{n}\\). (_Hint:_ For Professor Rosencrantz, call a head a success, and for Professor Guildenern, call a tail a success.) Use your argument to verify the identity \\[\\sum_{k=0}^{n}\\binom{n}{k}^{2}=\\binom{2n}{n}\\.\\]\n* _C.4-8_ Show that for \\(0\\leq k\\leq n\\), \\(b(k;n,1/2)\\leq 2^{n\\,H(k/n)-n}\\), where \\(H(x)\\) is the entropy function (C.8) on page 1182.\n* _C.4-9_ Consider \\(n\\) Bernoulli trials, where for \\(i=1,2,\\ldots,n\\), the \\(i\\)th trial has probability \\(p_{i}\\) of success, and let \\(X\\) be the random variable denoting the total number of successes. Let \\(p\\geq p_{i}\\) for all \\(i=1,2,\\ldots,n\\). Prove that for \\(1\\leq k\\leq n\\), \\(\\Pr\\left\\{X<k\\right\\}\\geq\\sum_{i=0}^{k-1}b(i;n,\\,p)\\).\n* _C.4-10_ Let \\(X\\) be the random variable for the total number of successes in a set \\(A\\) of \\(n\\) Bernoulli trials, where the \\(i\\)th trial has a probability \\(p_{i}\\) of success, and let \\(X^{\\prime}\\) be the random variable for the total number of successes in a second set \\(A^{\\prime}\\) of \\(n\\) Bernoulli trials, where the \\(i\\)th trial has a probability \\(p_{i}^{\\prime}\\geq p_{i}\\) of success. Prove that for \\(0\\leq k\\leq n\\), \\(\\Pr\\left\\{X^{\\prime}\\geq k\\right\\}\\geq\\Pr\\left\\{X\\geq k\\right\\}\\). (_Hint:_ Show how to obtain the Bernoulli trials in \\(A^{\\prime}\\) by an experiment involving the trials of \\(A\\), and use the result of Exercise C.3-7.)\n\n### The tails of the binomial distribution\n\nThe probability of having at least, or at most, \\(k\\) successes in \\(n\\) Bernoulli trials, each with probability \\(p\\) of success, is often of more interest than the probability of having exactly \\(k\\) successes. In this section, we investigate the _tails_ of the binomial distribution: the two regions of the distribution \\(b(k;n,\\,p)\\) that are far from the mean \\(np\\). We'll prove several important bounds on (the sum of all terms in) a tail.\n\nWe first provide a bound on the right tail of the distribution \\(b(k;n,\\,p)\\). To determine bounds on the left tail, simply invert the roles of successes and failures.\n\n**Theorem C.2**: _Consider a sequence of \\(n\\) Bernoulli trials, where success occurs with probability \\(p\\). Let \\(X\\) be the random variable denoting the total number of successes. Then for \\(0\\leq k\\leq n\\), the probability of at least \\(k\\) successes is_\n\n\\[\\Pr\\left\\{X\\geq k\\right\\} = \\sum_{i=k}^{n}b(i;n,\\,p)\\] \\[\\leq \\binom{n}{k}p^{k}\\.\\]\n\n**Proof** For \\(S\\subseteq\\{1,2,\\ldots,n\\}\\), let \\(A_{S}\\) denote the event that the \\(i\\)th trial is a success for every \\(i\\in S\\). Since \\(\\Pr\\left\\{A_{S}\\right\\}=p^{k}\\), where \\(|S|=k\\), we have\n\n\\[\\Pr\\left\\{X\\geq k\\right\\} = \\Pr\\left\\{\\text{there exists $S\\subseteq\\{1,2,\\ldots,n\\}:|S|=k$ and $A_{S}$}\\right\\}\\] \\[= \\Pr\\left\\{\\bigcup_{S\\subseteq\\{1,2,\\ldots,n\\}:|S|=k}A_{S}\\right\\}\\] \\[\\leq \\sum_{S\\subseteq\\{1,2,\\ldots,n\\}:|S|=k}\\Pr\\left\\{A_{S}\\right\\} \\quad\\text{ (by inequality (C.21) on page 1190)}\\] \\[= \\binom{n}{k}p^{k}\\.\\]\n\nThe following corollary restates the theorem for the left tail of the binomial distribution. In general, we'll leave it to you to adapt the proofs from one tail to the other.\n\n**Corollary C.3**: _Consider a sequence of \\(n\\) Bernoulli trials, where success occurs with probability \\(p\\). If \\(X\\) is the random variable denoting the total number of successes, then for \\(0\\leq k\\leq n\\), the probability of at most \\(k\\) successes is_",
        "chapter": "Part VIII Appendix: Mathematical Background",
        "section": "C Counting and Probability",
        "subsection": "C.4 The geometric and binomial distributions",
        "subsubsection": "N/A"
    },
    {
        "content": "### The tails of the binomial distribution\n\nThe probability of having at least, or at most, \\(k\\) successes in \\(n\\) Bernoulli trials, each with probability \\(p\\) of success, is often of more interest than the probability of having exactly \\(k\\) successes. In this section, we investigate the _tails_ of the binomial distribution: the two regions of the distribution \\(b(k;n,\\,p)\\) that are far from the mean \\(np\\). We'll prove several important bounds on (the sum of all terms in) a tail.\n\nWe first provide a bound on the right tail of the distribution \\(b(k;n,\\,p)\\). To determine bounds on the left tail, simply invert the roles of successes and failures.\n\n**Theorem C.2**: _Consider a sequence of \\(n\\) Bernoulli trials, where success occurs with probability \\(p\\). Let \\(X\\) be the random variable denoting the total number of successes. Then for \\(0\\leq k\\leq n\\), the probability of at least \\(k\\) successes is_\n\n\\[\\Pr\\left\\{X\\geq k\\right\\} = \\sum_{i=k}^{n}b(i;n,\\,p)\\] \\[\\leq \\binom{n}{k}p^{k}\\.\\]\n\n**Proof** For \\(S\\subseteq\\{1,2,\\ldots,n\\}\\), let \\(A_{S}\\) denote the event that the \\(i\\)th trial is a success for every \\(i\\in S\\). Since \\(\\Pr\\left\\{A_{S}\\right\\}=p^{k}\\), where \\(|S|=k\\), we have\n\n\\[\\Pr\\left\\{X\\geq k\\right\\} = \\Pr\\left\\{\\text{there exists $S\\subseteq\\{1,2,\\ldots,n\\}:|S|=k$ and $A_{S}$}\\right\\}\\] \\[= \\Pr\\left\\{\\bigcup_{S\\subseteq\\{1,2,\\ldots,n\\}:|S|=k}A_{S}\\right\\}\\] \\[\\leq \\sum_{S\\subseteq\\{1,2,\\ldots,n\\}:|S|=k}\\Pr\\left\\{A_{S}\\right\\} \\qquad\\text{(by inequality (C.21) on page 1190)}\\] \\[= \\binom{n}{k}p^{k}\\.\\]\n\nThe following corollary restates the theorem for the left tail of the binomial distribution. In general, we'll leave it to you to adapt the proofs from one tail to the other.\n\n**Corollary C.3**: _Consider a sequence of \\(n\\) Bernoulli trials, where success occurs with probability \\(p\\). If \\(X\\) is the random variable denoting the total number of successes, then for \\(0\\leq k\\leq n\\), the probability of at most \\(k\\) successes is_\\[\\Pr\\left\\{X\\leq k\\right\\} = \\sum_{i=0}^{k}b(i\\,;n\\,,\\,p)\\] \\[\\leq \\binom{n}{n-k}(1-p)^{n-k}\\] \\[= \\binom{n}{k}(1-p)^{n-k}\\.\\]\n\nOur next bound concerns the left tail of the binomial distribution. Its corollary shows that, far from the mean, the left tail diminishes exponentially.\n\n**Theorem C.4**: _Consider a sequence of \\(n\\) Bernoulli trials, where success occurs with probability \\(p\\) and failure with probability \\(q=1-p\\). Let \\(X\\) be the random variable denoting the total number of successes. Then for \\(0\\)\\(<\\)\\(k\\)\\(<\\)\\(np\\), the probability of fewer than \\(k\\) successes is_\n\n\\[\\Pr\\left\\{X<k\\right\\} = \\sum_{i=0}^{k-1}b(i\\,;n\\,,\\,p)\\] \\[< \\frac{kq}{np-k}\\ b(k\\,;n\\,,\\,p)\\.\\]\n\nWe bound the series \\(\\sum_{i=0}^{k-1}b(i\\,;n\\,,\\,p)\\) by a geometric series using the technique from Section A.2, page 1147. For \\(i\\,=1,2,\\ldots,k\\), equation (C.45) gives\n\n\\[\\frac{b(i-1;n\\,,\\,p)}{b(i\\,;n\\,,\\,p)} = \\frac{iq}{(n-i\\,+\\,1)p}\\] \\[< \\frac{iq}{(n-i\\,)p}\\] \\[\\leq \\frac{kq}{(n-k)\\,p}\\.\\]\n\nIf we let\n\n\\[x = \\frac{kq}{(n-k)\\,p}\\] \\[< \\frac{kq}{(n-np)\\,p}\\] \\[= \\frac{kq}{np}\\]\n\n### The tails of the binomial distribution\n\n\\[= \\frac{k}{np}\\] \\[< 1\\,\\]\n\nit follows that\n\n\\(b(i-1;n,\\,p)<x\\,b(i;n,\\,p)\\)\n\nfor \\(0<i\\,\\leq k\\). Iteratively applying this inequality \\(k-i\\) times gives\n\n\\(b(i;n,\\,p)<x^{k-i}\\,b(k;n,\\,p)\\)\n\nfor \\(0\\leq i\\,<k\\), and hence\n\n\\[\\sum_{i=0}^{k-1}b(i;n,\\,p) < \\sum_{i=0}^{k-1}x^{k-i}b(k;n,\\,p)\\] \\[< b(k\\ \\ ;n,\\,p)\\sum_{i=1}^{\\infty}x^{i}\\] \\[= \\frac{x}{1-x}\\ b(k;n,\\,p)\\] \\[= \\frac{kq/((n-k)p)}{((n-k)p-kq)/((n-k)p)}\\ b(k;n,\\,p)\\] \\[= \\frac{kq}{np-kp-kq}\\ b(k;n,\\,p)\\] \\[= \\frac{kq}{np-k}\\ b(k;n,\\,p)\\.\\]\n\n**Corollary C.5**: _Consider a sequence of \\(n\\) Bernoulli trials, where success occurs with probability \\(p\\) and failure with probability \\(q=1-p\\). Then for \\(0<k\\,\\leq np/2\\), the probability of fewer than \\(k\\) successes is less than half the probability of fewer than \\(k+1\\) successes._\n\n_Proof_ Because \\(k\\,\\leq np/2\\), we have\n\n\\[\\frac{kq}{np-k} \\leq \\frac{(np/2)q}{np-(np/2)}\\] (C.46) \\[= \\frac{(np/2)q}{np/2}\\] \\[\\leq 1\\,\\]\n\nsince \\(q\\leq 1\\). Letting \\(X\\) be the random variable denoting the number of successes, Theorem C.4 and inequality (C.46) imply that the probability of fewer than \\(k\\) successes is\\[\\Pr\\left\\{X<k\\right\\}=\\sum_{i=0}^{k-1}b(i\\,;n\\,,\\,p)<b(k\\,;n\\,,\\,p)\\.\\]\n\nThus we have\n\n\\[\\frac{\\Pr\\left\\{X<k\\right\\}}{\\Pr\\left\\{X<k\\right.+1\\}} = \\frac{\\sum_{i=0}^{k-1}b(i\\,;n\\,,\\,p)}{\\sum_{i=0}^{k}b(i\\,;n\\,,\\,p)}\\] \\[= \\frac{\\sum_{i=0}^{k-1}b(i\\,;n\\,,\\,p)}{\\sum_{i=0}^{k-1}b(i\\,;n\\,,\\,p )+b(k\\,;n\\,,\\,p)}\\] \\[< 1/2,\\]\n\nsince \\(\\sum_{i=0}^{k-1}b(i\\,;n\\,,\\,p)<b(k\\,;n\\,,\\,p)\\). \n\nBounds on the right tail follow similarly. Exercise C.5-2 asks you to prove them.\n\n_Corollary C.6_\n\nConsider a sequence of \\(n\\) Bernoulli trials, where success occurs with probability \\(p\\). Let \\(X\\) be the random variable denoting the total number of successes. Then for \\(np<k<n\\), the probability of more than \\(k\\) successes is\n\n\\[\\Pr\\left\\{X>k\\right\\} = \\sum_{i=k+1}^{n}b(i\\,;n\\,,\\,p)\\] \\[< \\frac{(n-k)\\,p}{k-np}\\ b(k\\,;n\\,,\\,p)\\.\\]\n\n_Corollary C.7_\n\nConsider a sequence of \\(n\\) Bernoulli trials, where success occurs with probability \\(p\\) and failure with probability \\(q=1-p\\). Then for \\((np+n)/2\\,{<}k\\,{<}n\\), the probability of more than \\(k\\) successes is less than half the probability of more than \\(k-1\\) successes. \n\nThe next theorem considers \\(n\\) Bernoulli trials, each with a probability \\(p_{i}\\) of success, for \\(i=1,2,\\ldots,n\\). As the subsequent corollary shows, we can use the theorem to provide a bound on the right tail of the binomial distribution by setting \\(p_{i}=p\\) for each trial.\n\n_Theorem C.8_\n\nConsider a sequence of \\(n\\) Bernoulli trials, where in the \\(i\\)th trial, for \\(i=1,2,\\ldots,n\\), success occurs with probability \\(p_{i}\\) and failure occurs with probability \\(q_{i}=1-p_{i}\\). Let \\(X\\) be the random variable describing the total number of successes, and let \\(\\mu=\\operatorname{E}\\left[X\\right]\\). Then for \\(r>\\mu\\),\n\n### The tails of the binomial distribution\n\n\\[\\Pr\\left\\{X-\\mu\\geq r\\right\\}\\leq\\left(\\frac{\\mu e}{r}\\right)^{r}\\.\\]\n\n_Proof_ Since for any \\(\\alpha>0\\), the function \\(e^{\\alpha x}\\) strictly increases in \\(x\\),\n\n\\[\\Pr\\left\\{X-\\mu\\geq r\\right\\}=\\Pr\\left\\{e^{\\alpha(X-\\mu)}\\geq e^{\\alpha r} \\right\\}\\,\\] (C.47)\n\nwhere we will determine \\(\\alpha\\) later. Using Markov's inequality (C.34), we obtain\n\n\\[\\Pr\\left\\{e^{\\alpha(X-\\mu)}\\geq e^{\\alpha r}\\right\\}\\leq\\mathrm{E}\\left[e^{ \\alpha(X-\\mu)}\\right]e^{-\\alpha r}\\.\\] (C.48)\n\nThe bulk of the proof consists of bounding \\(\\mathrm{E}\\left[e^{\\alpha(X-\\mu)}\\right]\\) and substituting a suitable value for \\(\\alpha\\) in inequality (C.48). First, we evaluate \\(\\mathrm{E}\\left[e^{\\alpha(X-\\mu)}\\right]\\). Using the technique of indicator random variables (see Section 5.2), let \\(X_{i}=\\mathrm{I}\\left\\{\\text{the }i\\text{th Bernoulli trial is a success}\\right\\}\\) for \\(i=1,2,\\ldots,n\\). That is, \\(X_{i}\\) is the random variable that is \\(1\\) if the \\(i\\)th Bernoulli trial is a success and \\(0\\) if it is a failure. Thus, we have\n\n\\[X=\\sum_{i=1}^{n}X_{i}\\,\\]\n\nand by linearity of expectation,\n\n\\[\\mu=\\mathrm{E}\\left[X\\right]=\\mathrm{E}\\left[\\sum_{i=1}^{n}X_{i}\\,\\right]= \\sum_{i=1}^{n}\\mathrm{E}\\left[X_{i}\\right]=\\sum_{i=1}^{n}p_{i}\\,\\]\n\nwhich implies\n\n\\[X-\\mu=\\sum_{i=1}^{n}(X_{i}-p_{i})\\.\\]\n\nTo evaluate \\(\\mathrm{E}\\left[e^{\\alpha(X-\\mu)}\\right]\\), we substitute for \\(X-\\mu\\), obtaining\n\n\\[\\mathrm{E}\\left[e^{\\alpha(X-\\mu)}\\right] = \\mathrm{E}\\left[e^{\\alpha\\sum_{i=1}^{n}(X_{i}-p_{i})}\\right]\\] \\[= \\mathrm{E}\\left[\\prod_{i=1}^{n}e^{\\alpha(X_{i}-p_{i})}\\right]\\] \\[= \\prod_{i=1}^{n}\\mathrm{E}\\left[e^{\\alpha(X_{i}-p_{i})}\\right]\\,\\]\n\nwhich follows from equation (C.27), since the mutual independence of the random variables \\(X_{i}\\) implies the mutual independence of the random variables \\(e^{\\alpha(X_{i}-p_{i})}\\) (see Exercise C.3-5). By the definition of expectation,\\[\\mathrm{E}\\left[e^{\\alpha(X_{i}-p_{i})}\\right] = e^{\\alpha(1-p_{i})}\\,p_{i}\\,+\\,e^{\\alpha(0-p_{i})}q_{i}\\] (C.49) \\[= p_{i}\\,e^{\\alpha q_{i}}\\,+\\,q_{i}\\,e^{-\\alpha p_{i}}\\] \\[\\leq p_{i}\\,e^{\\alpha}\\,+\\,1\\] \\[\\leq \\exp(p_{i}e^{\\alpha})\\,\\]\n\nwhere \\(\\exp(x)\\) denotes the exponential function: \\(\\exp(x)=e^{x}\\). (Inequality (C.49) follows from the inequalities \\(\\alpha>0\\), \\(q_{i}\\leq 1\\), \\(e^{\\alpha q_{i}}\\leq e^{\\alpha}\\), and \\(e^{-\\alpha p_{i}}\\leq 1\\). The last line follows from inequality (3.14) on page 6.) Consequently,\n\n\\[\\mathrm{E}\\left[e^{\\alpha(X-\\mu)}\\right] = \\prod_{i=1}^{n}\\mathrm{E}\\left[e^{\\alpha(X_{i}-p_{i})}\\right]\\] (C.50) \\[\\leq \\prod_{i=1}^{n}\\exp(p_{i}e^{\\alpha})\\] \\[= \\exp\\left(\\,\\sum_{i=1}^{n}\\,p_{i}\\,e^{\\alpha}\\right)\\] \\[= \\exp(\\mu e^{\\alpha})\\,\\]\n\nsince \\(\\mu=\\sum_{i=1}^{n}\\,p_{i}\\,\\). Therefore, from equation (C.47) and inequalities (C.48) and (C.50), it follows that\n\n\\[\\mathrm{Pr}\\left\\{X-\\mu\\geq r\\right\\}\\leq\\exp(\\mu e^{\\alpha}- \\alpha r)\\.\\] (C.51)\n\nChoosing \\(\\alpha=\\ln(r/\\mu)\\) (see Exercise C.5-7), we obtain\n\n\\[\\mathrm{Pr}\\left\\{X-\\mu\\geq r\\right\\} \\leq \\exp(\\mu e^{\\ln(r/\\mu)}-r\\ln(r/\\mu))\\] \\[= \\exp(r-r\\ln(r/\\mu))\\] \\[= \\frac{e^{r}}{(r/\\mu)^{r}}\\] \\[= \\left(\\frac{\\mu e}{r}\\right)^{r}\\.\\]\n\nWhen applied to Bernoulli trials in which each trial has the same probability of success, Theorem C.8 yields the following corollary bounding the right tail of a binomial distribution.\n\n**Corollary C.9**: _Consider a sequence of \\(n\\) Bernoulli trials, where in each trial success occurs with probability \\(p\\) and failure occurs with probability \\(q=1-p\\). Then for \\(r{\\gg}np\\)\n\n#### c.5 The tails of the binomial distribution\n\n\\[\\Pr\\left\\{X-np\\geq r\\right\\} = \\sum_{k=\\lceil np+r\\rceil}^{n}b(k;n,\\,p)\\] \\[\\leq \\left(\\frac{npe}{r}\\right)^{r}\\enspace.\\]\n\nBy equation (C.41), we have \\(\\mu=\\operatorname{E}\\left[X\\right]=np\\).\n\n**Exercises**\n\n\\(\\boldsymbol{\\bigstar}\\) _C.5-1_\n\nWhich is more likely: getting exactly \\(n\\) heads in \\(2n\\) flips of a fair coin, or \\(n\\) heads in \\(n\\) flips of a fair coin?\n\n\\(\\boldsymbol{\\bigstar}\\) _C.5-2_\n\nProve Corollaries C.6 and C.7.\n\n\\(\\boldsymbol{\\bigstar}\\) _C.5-3_\n\nShow that\n\n\\[\\sum_{i=0}^{k-1}\\binom{n}{i}a^{i}<(a+1)^{n}\\ \\frac{k}{na-k(a+1)}\\ b(k;n,a/(a+1))\\]\n\nfor all \\(a>0\\) and all \\(k\\) such that \\(0<k<n\\,a/(a+1)\\).\n\n\\(\\boldsymbol{\\bigstar}\\) _C.5-4_\n\nProve that if \\(0<k<np\\), where \\(0<p<1\\) and \\(q=1-p\\), then\n\n\\[\\sum_{i=0}^{k-1}p^{i}q^{n-i}<\\frac{kq}{np-k}\\left(\\frac{np}{k}\\right)^{k}\\left( \\frac{nq}{n-k}\\right)^{n-k}\\enspace.\\]\n\n\\(\\boldsymbol{\\bigstar}\\) _C.5-5_\n\nUse Theorem C.8 to show that\n\n\\[\\Pr\\left\\{\\mu-X\\geq r\\right\\}\\leq\\left(\\frac{(n-\\mu)e}{r}\\right)^{r}\\]\n\nfor \\(r>n-\\mu\\). Similarly, use Corollary C.9 to show that\n\n\\[\\Pr\\left\\{np-X\\geq r\\right\\}\\leq\\left(\\frac{nqe}{r}\\right)^{r}\\]\n\nfor \\(r>n-np\\).\n\n* _C.5-6_ Consider a sequence of \\(n\\) Bernoulli trials, where in the \\(i\\)th trial, for \\(i=1,2,\\ldots,n\\), success occurs with probability \\(p_{i}\\) and failure occurs with probability \\(q_{i}=1-p_{i}\\). Let \\(X\\) be the random variable describing the total number of successes, and let \\(\\mu=\\operatorname{E}\\left[X\\right]\\). Show that for \\(r\\geq 0\\), \\[\\Pr\\left\\{X-\\mu\\geq r\\right\\}\\leq e^{-r^{2}/2n}\\.\\] (_Hint:_ Prove that \\(p_{i}e^{\\alpha q_{i}}+q_{i}e^{-\\alpha p_{i}}\\leq e^{\\alpha^{2}/2}\\). Then follow the outline of the proof of Theorem C.8, using this inequality in place of inequality (C.49).)\n* _C.5-7_ Show that choosing \\(\\alpha=\\ln(r/\\mu)\\) minimizes the right-hand side of inequality (C.51).",
        "chapter": "Part VIII Appendix: Mathematical Background",
        "section": "C Counting and Probability",
        "subsection": "C.5 The tails of the binomial distribution",
        "subsubsection": "N/A"
    },
    {
        "content": "* _C.5-6_ Consider a sequence of \\(n\\) Bernoulli trials, where in the \\(i\\)th trial, for \\(i\\,=\\,1,2,\\ldots,n\\), success occurs with probability \\(\\,p_{i}\\) and failure occurs with probability \\(q_{i}\\,=\\,1-p_{i}\\). Let \\(X\\) be the random variable describing the total number of successes, and let \\(\\mu\\,=\\,\\mathrm{E}\\left[X\\right]\\). Show that for \\(r\\,\\geq\\,0\\), \\[\\Pr\\left\\{X-\\mu\\,\\geq\\,r\\right\\}\\leq e^{-r^{2}/2\\,n}\\.\\] (_Hint:_ Prove that \\(\\,p_{i}e^{\\alpha q_{i}}\\,+\\,q_{i}\\,e^{-\\alpha p_{i}}\\,\\leq\\,e^{\\alpha^{2}/2}\\). Then follow the outline of the proof of Theorem C.8, using this inequality in place of inequality (C.49).)\n* _C.5-7_ Show that choosing \\(\\alpha\\,=\\,\\ln(r/\\mu)\\) minimizes the right-hand side of inequality (C.51).\nfact, in the real game show, after a contestant picked a door, Monty sometimes simply asked Carol to open the door that the contestant had chosen.\n\nLet's model the interactions between you and Monty as a probabilistic experiment, where you both employ randomized strategies. Specifically, after you pick a door, Monty offers you the opportunity to switch with probability \\(p_{\\mathrm{right}}\\) if you picked the right door and with probability \\(p_{\\mathrm{wrong}}\\) if you picked the wrong door. Given the opportunity to switch, you randomly choose to switch with probability \\(p_{\\mathrm{switch}}\\). For example, if Monty always offers you the opportunity to switch, then his strategy is given by \\(p_{\\mathrm{right}}=p_{\\mathrm{wrong}}=1\\). If you always switch, then your strategy is given by \\(p_{\\mathrm{switch}}=1\\).\n\nThe game can now be viewed as an experiment consisting of five steps:\n\n1. You pick a door at random, choosing the automobile (right) with probability \\(1/3\\) or a goat (wrong) with probability \\(2/3\\).\n2. Carol opens one of the two closed doors, revealing a goat.\n3. Monty offers you the opportunity to switch with probability \\(p_{\\mathrm{right}}\\) if your choice is right and with probability \\(p_{\\mathrm{wrong}}\\) if your choice is wrong.\n4. If Monty makes you an offer in step 3, you switch with probability \\(p_{\\mathrm{switch}}\\).\n5. Carol opens the door you've chosen, revealing either an automobile (you win) or a goat (you lose).\n\nLet's now analyze this game and understand how the choices of \\(p_{\\mathrm{right}}\\), \\(p_{\\mathrm{wrong}}\\), and \\(p_{\\mathrm{switch}}\\) influence the probability of winning.\n\n_b._: What are the six outcomes in the sample space for this game? Which outcomes correspond to you winning the automobile? What are the probabilities in terms of \\(p_{\\mathrm{right}}\\), \\(p_{\\mathrm{wrong}}\\), and \\(p_{\\mathrm{switch}}\\) of each outcome? Organize your answers into a table.\n\n_c._: Use the results of your table (or other means) to prove that the probability of winning the automobile is\n\n\\[\\frac{1}{3}(2p_{\\mathrm{wrong}}p_{\\mathrm{switch}}-p_{\\mathrm{right}}p_{ \\mathrm{switch}}+1)\\.\\]\n\nSuppose that Monty knows the probability \\(p_{\\mathrm{switch}}\\) that you switch, and his goal is to minimize your chance of winning.\n\n_d._: If \\(p_{\\mathrm{switch}}>0\\) (you switch with a positive probability), what is Monty's best strategy, that is, his best choice for \\(p_{\\mathrm{right}}\\) and \\(p_{\\mathrm{wrong}}\\)?\n\n_e._: If \\(p_{\\mathrm{switch}}=0\\) (you always stick), argue that all of Monty's possible strategies are optimal for him.\n\nSuppose that now Monty's strategy is fixed, with particular values for \\(p_{\\rm right}\\) and \\(p_{\\rm wrong}\\). \\(f\\)**.**: If you know \\(p_{\\rm right}\\) and \\(p_{\\rm wrong}\\), what is your best strategy for choosing your probability \\(p_{\\rm switch}\\) of switching as a function of \\(p_{\\rm right}\\) and \\(p_{\\rm wrong}\\)? \\(g\\)**.**: If you don't know \\(p_{\\rm right}\\) and \\(p_{\\rm wrong}\\), what choice of \\(p_{\\rm switch}\\) maximizes the minimum probability of winning over all the choices of \\(p_{\\rm right}\\) and \\(p_{\\rm wrong}\\)?\n\nLet's return to the original problem as stated, where Monty has given you the option of switching, but you have no knowledge of Monty's possible motivations or strategies. \\(h\\)**.**: Argue that the conditional probability of winning the automobile given that Monty offers you the opportunity to switch is\n\n\\[\\frac{p_{\\rm right}-p_{\\rm right}p_{\\rm switch}+2p_{\\rm wrong}p_{\\rm switch }}{p_{\\rm right}+2p_{\\rm wrong}}\\.\\] (C.52)\n\nExplain why \\(p_{\\rm right}+2p_{\\rm wrong}\\neq 0\\). \\(i\\)**.**: What is the value of expression (C.52) when \\(p_{\\rm switch}=1/2\\)? Show that choosing \\(p_{\\rm switch}<1/2\\) or \\(p_{\\rm switch}>1/2\\) allows Monty to select values for \\(p_{\\rm right}\\) and \\(p_{\\rm wrong}\\) that yield a lower value for expression (C.52) than choosing \\(p_{\\rm switch}=1/2\\). \\(j\\)**.**: Suppose that you don't know Monty's strategy. Explain why choosing to switch with probability \\(1/2\\) is a good strategy for the original problem as stated. Summarize what you have learned overall from this problem.\n\n#### C-2 Balls and bins\n\nThis problem investigates the effect of various assumptions on the number of ways of placing \\(n\\) balls into \\(b\\) distinct bins.\n\n* Suppose that the \\(n\\) balls are distinct and that their order within a bin does not matter. Argue that the number of ways of placing the balls in the bins is \\(b^{n}\\).\n* Suppose that the balls are distinct and that the balls in each bin are ordered. Prove that there are exactly \\((b+n-1)!/(b-1)!\\) ways to place the balls in the bins. (_Hint:_ Consider the number of ways of arranging \\(n\\) distinct balls and \\(b-1\\) indistinguishable sticks in a row.)\n* Suppose that the balls are identical, and hence their order within a bin does not matter. Show that the number of ways of placing the balls in the bins is \\({b+n-1\\choose n}\\). (_Hint:_ Of the arrangements in part (b), how many are repeated if the balls are made identical?)_d._ Suppose that the balls are identical and that no bin may contain more than one ball, so that \\(n\\leq b\\). Show that the number of ways of placing the balls is \\(\\binom{b}{n}\\). _e._ Suppose that the balls are identical and that no bin may be left empty. Assuming that \\(n\\geq b\\), show that the number of ways of placing the balls is \\(\\binom{n-1}{b-1}\\).\n\n## Appendix notes\n\nThe first general methods for solving probability problems were discussed in a famous correspondence between B. Pascal and P. de Fermat, which began in 1654, and in a book by C. Huygens in 1657. Rigorous probability theory began with the work of J. Bernoulli in 1713 and A. De Moivre in 1730. Further developments of the theory were provided by P.-S. Laplace, S.-D. Poisson, and C. F. Gauss.\n\nSums of random variables were originally studied by P. L. Chebyshev and A. A. Markov. A. N. Kolmogorov axiomatized probability theory in 1933. Chernoff [91] and Hoeffding [222] provided bounds on the tails of distributions. Seminal work in random combinatorial structures was done by P. Erdos.\n\nKnuth [259] and Liu [302] are good references for elementary combinatorics and counting. Standard textbooks such as Billingsley [56], Chung [93], Drake [125], Feller [139], and Rozanov [390] offer comprehensive introductions to probability.",
        "chapter": "Part VIII Appendix: Mathematical Background",
        "section": "C Counting and Probability",
        "subsection": "Problems",
        "subsubsection": "N/A"
    },
    {
        "content": "_d._ Suppose that the balls are identical and that no bin may contain more than one ball, so that \\(n\\leq b\\). Show that the number of ways of placing the balls is \\(\\binom{b}{n}\\). _e._ Suppose that the balls are identical and that no bin may be left empty. Assuming that \\(n\\geq b\\), show that the number of ways of placing the balls is \\(\\binom{n-1}{b-1}\\).\n\n## Appendix notes\n\nThe first general methods for solving probability problems were discussed in a famous correspondence between B. Pascal and P. de Fermat, which began in 1654, and in a book by C. Huygens in 1657. Rigorous probability theory began with the work of J. Bernoulli in 1713 and A. De Moivre in 1730. Further developments of the theory were provided by P.-S. Laplace, S.-D. Poisson, and C. F. Gauss.\n\nSums of random variables were originally studied by P. L. Chebyshev and A. A. Markov. A. N. Kolmogorov axiomatized probability theory in 1933. Chernoff [91] and Hoeffding [222] provided bounds on the tails of distributions. Seminal work in random combinatorial structures was done by P. Erdos.\n\nKnuth [259] and Liu [302] are good references for elementary combinatorics and counting. Standard textbooks such as Billingsley [56], Chung [93], Drake [125], Feller [139], and Rozanov [390] offer comprehensive introductions to probability.\n\nMatrices\n\nMatrices arise in numerous applications, including, but by no means limited to, scientific computing. If you have seen matrices before, much of the material in this appendix will be familiar to you, but some of it might be new. Section D.1 covers basic matrix definitions and operations, and Section D.2 presents some basic matrix properties.\n\n### Matrices and matrix operations\n\nThis section reviews some basic concepts of matrix theory and some fundamental properties of matrices.\n\n#### Matrices and vectors\n\nA _matrix_ is a rectangular array of numbers. For example,\n\n\\[A = \\left(\\begin{array}{cc}a_{11}&a_{12}&a_{13}\\\\ a_{21}&a_{22}&a_{23}\\end{array}\\right)\\] (D.1) \\[= \\left(\\begin{array}{ccc}1&2&3\\\\ 4&5&6\\end{array}\\right)\\]\n\nis a \\(2\\times 3\\) matrix \\(A=(a_{ij})\\), where for \\(i=1,2\\) and \\(j=1,2,3\\), the element of the matrix in row \\(i\\) and column \\(j\\) is denoted by \\(a_{ij}\\). By convention, uppercase letters denote matrices and corresponding subscripted lowercase letters denote their elements. We denote the set of all \\(m\\times n\\) matrices with real-valued entries by \\(\\mathbb{R}^{m\\times n}\\) and, in general, the set of \\(m\\times n\\) matrices with entries drawn from a set \\(S\\) by \\(S^{m\\times n}\\).\n\nThe _transpose_ of a matrix \\(A\\) is the matrix \\(A^{\\rm T}\\) obtained by exchanging the rows and columns of \\(A\\). For the matrix \\(A\\) of equation (D.1),",
        "chapter": "Part VIII Appendix: Mathematical Background",
        "section": "C Counting and Probability",
        "subsection": "Appendix notes",
        "subsubsection": "N/A"
    },
    {
        "content": "Matrices\n\nMatrices arise in numerous applications, including, but by no means limited to, scientific computing. If you have seen matrices before, much of the material in this appendix will be familiar to you, but some of it might be new. Section D.1 covers basic matrix definitions and operations, and Section D.2 presents some basic matrix properties.\n\n### Matrices and matrix operations\n\nThis section reviews some basic concepts of matrix theory and some fundamental properties of matrices.\n\n#### Matrices and vectors\n\nA _matrix_ is a rectangular array of numbers. For example,\n\n\\[A = \\left(\\begin{array}{cc}a_{11}&a_{12}&a_{13}\\\\ a_{21}&a_{22}&a_{23}\\end{array}\\right)\\] (D.1) \\[= \\left(\\begin{array}{ccc}1&2&3\\\\ 4&5&6\\end{array}\\right)\\]\n\nis a \\(2\\times 3\\) matrix \\(A=(a_{ij})\\), where for \\(i=1,2\\) and \\(j=1,2,3\\), the element of the matrix in row \\(i\\) and column \\(j\\) is denoted by \\(a_{ij}\\). By convention, uppercase letters denote matrices and corresponding subscripted lowercase letters denote their elements. We denote the set of all \\(m\\times n\\) matrices with real-valued entries by \\(\\mathbb{R}^{m\\times n}\\) and, in general, the set of \\(m\\times n\\) matrices with entries drawn from a set \\(S\\) by \\(S^{m\\times n}\\).\n\nThe _transpose_ of a matrix \\(A\\) is the matrix \\(A^{\\rm T}\\) obtained by exchanging the rows and columns of \\(A\\). For the matrix \\(A\\) of equation (D.1),\n\n### Matrices and matrix operations\n\n\\(A^{\\rm T}=\\left(\\begin{array}{cc}1&4\\\\ 2&5\\\\ 3&6\\end{array}\\right).\\)\n\nA _vector_ is a one-dimensional array of numbers. For example,\n\n\\(x=\\left(\\begin{array}{c}2\\\\ 3\\\\ 5\\end{array}\\right)\\)\n\nis a vector of size 3. We sometimes call a vector of length \\(n\\) an _n-vector_. By convention, lowercase letters denote vectors, and the \\(i\\)th element of a size-\\(n\\) vector \\(x\\) is denoted by \\(x_{i}\\), for \\(i=1,2,\\ldots,n\\). We take the standard form of a vector to be as a _column vector_ equivalent to an \\(n\\times 1\\) matrix, whereas the corresponding _row vector_ is obtained by taking the transpose:\n\n\\(x^{\\rm T}=\\left(\\begin{array}{cc}2&3&5\\end{array}\\right).\\)\n\nThe _unit vector_\\(e_{i}\\) is the vector whose \\(i\\)th element is 1 and all of whose other elements are 0. Usually, the context makes the size of a unit vector clear.\n\nA _zero matrix_ is a matrix all of whose entries are 0. Such a matrix is often denoted 0, since the ambiguity between the number 0 and a matrix of 0s can usually be resolved from context. If a matrix of 0s is intended, then the size of the matrix also needs to be derived from the context.\n\n#### Square matrices\n\n_Square_\\(n\\times n\\) matrices arise frequently. Several special cases of square matrices are of particular interest:\n\n1. A _diagonal matrix_ has \\(a_{ij}=0\\) whenever \\(i\\neq j\\). Because all of the off-diagonal elements are 0, a succinct way to specify the matrix lists only the elements along the diagonal: \\[{\\rm diag}(a_{11},a_{22},\\ldots,a_{nn})=\\left(\\begin{array}{cccc}a_{11}&0& \\ldots&0\\\\ 0&a_{22}&\\ldots&0\\\\ \\vdots&\\vdots&\\ddots&\\vdots\\\\ 0&0&\\ldots&a&{}_{nn}\\end{array}\\right).\\]\n2. The \\(n\\times n\\) _identity matrix_\\(I_{n}\\) is a diagonal matrix with 1s along the diagonal: \\(I_{n}\\) = diag(1,1,...,1) \\(=\\)When \\(I\\) appears without a subscript, its size derives from the context. The \\(i\\)th column of an identity matrix is the unit vector \\(e_{i}\\).\n3. A _tridiagonal matrix_\\(T\\) is one for which \\(t_{ij}=0\\) if \\(|i-j|>1\\). Nonzero entries appear only on the main diagonal, immediately above the main diagonal (\\(t_{i,\\,i+1}\\), for \\(i=1,2,\\ldots,n-1\\)), or immediately below the main diagonal (\\(t_{i+1,i}\\) for \\(i=1,2,\\ldots,n-1\\)): \\[T\\,=\\,\\left(\\begin{array}{cccccccc}t_{11}&t_{12}&0&0&\\ldots&0&0&0\\\\ t_{21}&t_{22}&t_{23}&0&\\ldots&0&0&0\\\\ 0&t_{32}&t_{33}&t_{34}&\\ldots&0&0&0\\\\ \\vdots&\\vdots&\\vdots&\\vdots&\\ddots&\\vdots&\\vdots&\\vdots\\\\ 0&0&0&0&\\ldots&t&\\begin{array}{cccccccc}n-2,n-2&t_{n-2,n-1}&0\\\\ n-1,n-2&t_{n-1,n-1}&t_{n-1,n}\\\\ 0&0&0&0&\\ldots&0&t_{n,n-1}&t_{nn}\\end{array}\\end{array}\\right)\\.\\]\n4. An _upper-triangular matrix_\\(U\\) is one for which \\(u_{ij}=0\\) if \\(i>j\\). All entries below the diagonal are 0: \\[U\\,=\\,\\left(\\begin{array}{cccc}u_{11}&u_{12}&\\ldots&u_{1n}\\\\ 0&u_{22}&\\ldots&u_{2n}\\\\ \\vdots&\\vdots&\\ddots&\\vdots\\\\ 0&0&\\ldots&u&\\begin{array}{c}nn\\end{array}\\end{array}\\right)\\,.\\] An upper-triangular matrix is _unit upper-triangular_ if it has all 1s along the diagonal.\n5. A _lower-triangular matrix_\\(L\\) is one for which \\(l_{ij}=0\\) if \\(i<j\\). All entries above the diagonal are 0: \\[L\\,=\\,\\left(\\begin{array}{cccc}l_{11}&0&\\ldots&0\\\\ l_{21}&l_{22}&\\ldots&0\\\\ \\vdots&\\vdots&\\ddots&\\vdots\\\\ l_{n1}&l_{n2}&\\ldots&l&nn\\end{array}\\right)\\,.\\] A lower-triangular matrix is _unit lower-triangular_ if it has all 1s along the diagonal.\n\n6. A _permutation matrix_\\(P\\) has exactly one 1 in each row or column, and 0s elsewhere. An example of a permutation matrix is \\[P\\,=\\,\\left(\\begin{array}{cccccc}0&1&0&0&0\\\\ 0&0&0&1&0\\\\ 1&0&0&0&0\\\\ 0&0&0&0&1\\\\ 0&0&1&0&0\\end{array}\\right)\\,.\\] Such a matrix is called a permutation matrix because multiplying a vector \\(x\\) by a permutation matrix has the effect of permuting (rearranging) the elements of \\(x\\). Exercise D.1-4 explores additional properties of permutation matrices.\n7. A _symmetric matrix_\\(A\\) satisfies the condition \\(A=A^{\\rm T}\\). For example, \\[\\left(\\begin{array}{ccc}1&2&3\\\\ 2&6&4\\\\ 3&4&5\\end{array}\\right)\\] is a symmetric matrix.\n\n#### Basic matrix operations\n\nThe elements of a matrix or vector are _scalar numbers_ from a number system, such as the real numbers, the complex numbers, or integers modulo a prime. The number system defines how to add and multiply scalars. These definitions extend to encompass addition and multiplication of matrices.\n\nWe define _matrix addition_ as follows. If \\(A=(a_{ij})\\) and \\(B=(b_{ij})\\) are \\(m\\times n\\) matrices, then their matrix sum \\(C\\,=\\,(c_{ij})\\,=\\,A+B\\) is the \\(m\\times n\\) matrix defined by \\(c_{ij}\\,=\\,a_{ij}\\,+\\,b_{ij}\\)\n\nfor \\(i\\,=\\,1,2,\\ldots,m\\) and \\(j\\,=\\,1,2,\\ldots,n\\,\\). That is, matrix addition is performed componentwise. A zero matrix is the identity for matrix addition:\n\n\\(A\\,+\\,0\\,=\\,A\\,=\\,0\\,+\\,A\\,\\).\n\nIf \\(\\lambda\\) is a scalar number and \\(A\\,=\\,(a_{ij})\\) is a matrix, then \\(\\lambda A\\,=\\,(\\lambda a_{ij})\\) is the _scalar multiple_ of \\(A\\) obtained by multiplying each of its elements by \\(\\lambda\\). As a special case, we define the _negative_ of a matrix \\(A\\,=\\,(a_{ij})\\) to be \\(-1\\cdot A\\,=\\,-A\\), so that the \\(ij\\,\\)th entry of \\(-A\\) is \\(-a_{ij}\\). Thus,\n\n\\(A\\,+\\,(-A)\\,=\\,0\\,=\\,(-A)\\,+\\,A\\,\\).\n\nThe negative of a matrix defines _matrix subtraction_: \\(A-B=A+(-B)\\).\n\nWe define _matrix multiplication_ as follows. Start with two matrices \\(A\\) and \\(B\\) that are _compatible_ in the sense that the number of columns of \\(A\\) equals the number of rows of \\(B\\). (In general, an expression containing a matrix product \\(AB\\) is always assumed to imply that matrices \\(A\\) and \\(B\\) are compatible.) If \\(A=(a_{i\\,k})\\) is a \\(p\\times q\\) matrix and \\(B=(b_{kj})\\) is a \\(q\\times r\\) matrix, then their matrix product \\(C=AB\\) is the \\(p\\times r\\) matrix \\(C=(c_{ij})\\), where\n\n\\[c_{ij}=\\sum_{k=1}^{q}a_{i\\,k}b_{kj}\\] (D.2)\n\nfor \\(i=1,2,\\ldots,m\\) and \\(j=1,2,\\ldots,p\\). The procedure Rectangular-Matrix-Multiply on page 374 implements matrix multiplication in the straightforward manner based on equation (D.2), assuming that \\(C\\) is initialized to \\(0\\), using \\(pqr\\) multiplications and \\(p(q-1)r\\) additions for a running time of \\(\\Theta(pqr)\\). If the matrices are \\(n\\times n\\) square matrices, so that \\(n=p=q=r\\), the pseudocode reduces to Matrix-Multiply on page 81, whose running time is \\(\\Theta(n^{3})\\). (Section 4.2 describes an asymptotically faster \\(\\Theta(n^{\\lg 7})\\)-time algorithm due to V. Strassen.)\n\nMatrices have many (but not all) of the algebraic properties typical of numbers. Identity matrices are identities for matrix multiplication:\n\n\\(I_{m}A=AI_{n}=A\\)\n\nfor any \\(m\\times n\\) matrix \\(A\\). Multiplying by a zero matrix gives a zero matrix:\n\n\\(A\\cdot 0=0\\).\n\nMatrix multiplication is associative:\n\n\\(A(BC)=(AB)C\\)\n\nfor compatible matrices \\(A\\), \\(B\\), and \\(C\\). Matrix multiplication distributes over addition:\n\n\\(A(B+C)=AB+AC\\),\n\n\\((B+C)D=BD+CD\\).\n\nFor \\(n>1\\), multiplication of \\(n\\times n\\) matrices is not commutative. For example, if \\(A=\\left(\\begin{array}{cc}0&1\\\\ 0&0\\end{array}\\right)\\) and \\(B=\\left(\\begin{array}{cc}0&0\\\\ 1&0\\end{array}\\right)\\), then \\(AB=\\left(\\begin{array}{cc}1&0\\\\ 0&0\\end{array}\\right)\\) and \\(BA=\\left(\\begin{array}{cc}0&0\\\\ 0&1\\end{array}\\right)\\).\n\nWe define matrix-vector products or vector-vector products as if the vector were the equivalent \\(n\\times 1\\) matrix (or a \\(1\\times n\\) matrix, in the case of a row vector). Thus, if \\(A\\) is an \\(m\\times n\\) matrix and \\(x\\) is an \\(n\\)-vector, then \\(Ax\\) is an \\(m\\)-vector. If \\(x\\) and \\(y\\) are \\(n\\)-vectors, then \\[x^{\\rm T}y=\\sum_{i=1}^{n}x_{i}y_{i}\\]\n\nis a scalar number (actually a \\(1\\times 1\\) matrix) called the _inner product_ of \\(x\\) and \\(y\\). We also use the notation \\(\\langle x,y\\rangle\\) to denote \\(x^{\\rm T}y\\). The inner-product operator is commutative: \\(\\langle x,\\,y\\rangle=\\langle y,x\\rangle\\). The matrix \\(xy^{\\rm T}\\) is an \\(n\\times n\\) matrix \\(Z\\) called the _outer product_ of \\(x\\) and \\(y\\), where \\(z_{ij}=x_{i}y_{j}\\). The _(euclidean) norm_\\(\\|x\\|\\) of an \\(n\\)-vector \\(x\\) is defined by\n\n\\[\\|x\\| = (x_{1}^{2}+x_{2}^{2}+\\cdots+x_{n}^{2})^{1/2}\\] \\[= (x^{\\rm T}x)^{1/2}\\.\\]\n\nThus, the norm of \\(x\\) is its length in \\(n\\)-dimensional euclidean space. A useful fact, which follows from the equality\n\n\\[\\left((ax_{1})^{2}+(ax_{2})^{2}+\\cdots+(ax_{n})^{2}\\right)^{1/2}=|a|\\,(x_{1}^{ 2}+x_{2}^{2}+\\cdots+x_{n}^{2})^{1/2}\\]\n\nis that for any real number \\(a\\) and \\(n\\)-vector \\(x\\),\n\n\\[\\|ax\\|=|a|\\,\\|x\\|\\.\\] (D.3)\n\n**Exercises**\n\n_D.1-1_\n\nShow that if \\(A\\) and \\(B\\) are symmetric \\(n\\times n\\) matrices, then so are \\(A+B\\) and \\(A-B\\).\n\n_D.1-2_\n\nProve that \\((AB)^{\\rm T}=B^{\\rm T}A^{\\rm T}\\) and that \\(A^{\\rm T}A\\) is always a symmetric matrix.\n\n_D.1-3_\n\nProve that the product of two lower-triangular matrices is lower-triangular.\n\n_D.1-4_\n\nProve that if \\(P\\) is an \\(n\\times n\\) permutation matrix and \\(A\\) is an \\(n\\times n\\) matrix, then the matrix product \\(PA\\) is \\(A\\) with its rows permuted, and the matrix product \\(AP\\) is \\(A\\) with its columns permuted. Prove that the product of two permutation matrices is a permutation matrix.\n\n### Basic matrix properties\n\nWe now define some basic properties pertaining to matrices: inverses, linear dependence and independence, rank, and determinants. We also define the class of positive-definite matrices.",
        "chapter": "Part VIII Appendix: Mathematical Background",
        "section": "D Matrices",
        "subsection": "D.1 Matrices and matrix operations",
        "subsubsection": "N/A"
    },
    {
        "content": "\\[x^{\\rm T}y=\\sum_{i=1}^{n}x_{i}y_{i}\\]\n\nis a scalar number (actually a \\(1\\times 1\\) matrix) called the _inner product_ of \\(x\\) and \\(y\\). We also use the notation \\(\\langle x,y\\rangle\\) to denote \\(x^{\\rm T}y\\). The inner-product operator is commutative: \\(\\langle x,\\,y\\rangle=\\langle y,x\\rangle\\). The matrix \\(xy^{\\rm T}\\) is an \\(n\\times n\\) matrix \\(Z\\) called the _outer product_ of \\(x\\) and \\(y\\), where \\(z_{ij}=x_{i}y_{j}\\). The _(euclidean) norm_\\(\\|x\\|\\) of an \\(n\\)-vector \\(x\\) is defined by\n\n\\[\\|x\\| = (x_{1}^{2}+x_{2}^{2}+\\cdots+x_{n}^{2})^{1/2}\\] \\[= (x^{\\rm T}x)^{1/2}\\.\\]\n\nThus, the norm of \\(x\\) is its length in \\(n\\)-dimensional euclidean space. A useful fact, which follows from the equality\n\n\\[\\left((ax_{1})^{2}+(ax_{2})^{2}+\\cdots+(ax_{n})^{2}\\right)^{1/2}=|a|\\,(x_{1}^{ 2}+x_{2}^{2}+\\cdots+x_{n}^{2})^{1/2}\\]\n\nis that for any real number \\(a\\) and \\(n\\)-vector \\(x\\),\n\n\\[\\|ax\\|=|a|\\,\\|x\\|\\.\\] (D.3)\n\n**Exercises**\n\n_D.1-1_\n\nShow that if \\(A\\) and \\(B\\) are symmetric \\(n\\times n\\) matrices, then so are \\(A+B\\) and \\(A-B\\).\n\n_D.1-2_\n\nProve that \\((AB)^{\\rm T}=B^{\\rm T}A^{\\rm T}\\) and that \\(A^{\\rm T}A\\) is always a symmetric matrix.\n\n_D.1-3_\n\nProve that the product of two lower-triangular matrices is lower-triangular.\n\n_D.1-4_\n\nProve that if \\(P\\) is an \\(n\\times n\\) permutation matrix and \\(A\\) is an \\(n\\times n\\) matrix, then the matrix product \\(PA\\) is \\(A\\) with its rows permuted, and the matrix product \\(AP\\) is \\(A\\) with its columns permuted. Prove that the product of two permutation matrices is a permutation matrix.\n\n### Basic matrix properties\n\nWe now define some basic properties pertaining to matrices: inverses, linear dependence and independence, rank, and determinants. We also define the class of positive-definite matrices.\n\n**Matrix inverses, ranks, and determinants**\n\nThe _inverse_ of an \\(n\\times n\\) matrix \\(A\\) is the \\(n\\times n\\) matrix, denoted \\(A^{-1}\\) (if it exists), such that \\(AA^{-1}=I_{n}=A^{-1}A\\). For example,\n\n\\[\\left(\\begin{array}{cc}1&1\\\\ 1&0\\end{array}\\right)^{-1}=\\left(\\begin{array}{cc}0&1\\\\ 1&-1\\end{array}\\right).\\]\n\nMany nonzero \\(n\\times n\\) matrices do not have inverses. A matrix without an inverse is called _noninvertible_, or _singular_. An example of a nonzero singular matrix is\n\n\\[\\left(\\begin{array}{cc}1&0\\\\ 1&0\\end{array}\\right).\\]\n\nIf a matrix has an inverse, it is called _invertible_, or _nonsingular_. Matrix inverses, when they exist, are unique. (See Exercise D.2-1.) If \\(A\\) and \\(B\\) are nonsingular \\(n\\times n\\) matrices, then\n\n\\[(BA)^{-1}=A^{-1}B^{-1}\\.\\]\n\nThe inverse operation commutes with the transpose operation:\n\n\\[(A^{-1})^{\\rm T}=(A^{\\rm T})^{-1}\\.\\]\n\nThe vectors \\(x_{1},x_{2},\\ldots,x_{n}\\) are _linearly dependent_ if there exist coefficients \\(c_{1},c_{2},\\ldots,c_{n}\\), not all of which are \\(0\\), such that \\(c_{1}x_{1}+c_{2}x_{2}+\\cdots+c_{n}x_{n}=0\\). The row vectors \\(x_{1}=(\\begin{array}{cc}1&2&3\\end{array})\\), \\(x_{2}=(\\begin{array}{cc}2&6&4\\end{array})\\), and \\(x_{3}=(\\begin{array}{cc}4&11&9\\end{array})\\) are linearly dependent, for example, since \\(2x_{1}+3x_{2}-2x_{3}=0\\). If vectors are not linearly dependent, they are _linearly independent_. For example, the columns of an identity matrix are linearly independent.\n\nThe _column rank_ of a nonzero \\(m\\times n\\) matrix \\(A\\) is the size of the largest set of linearly independent columns of \\(A\\). Similarly, the _row rank_ of \\(A\\) is the size of the largest set of linearly independent rows of \\(A\\). A fundamental property of any matrix \\(A\\) is that its row rank always equals its column rank, so that we can simply refer to the _rank_ of \\(A\\). The rank of an \\(m\\times n\\) matrix is an integer between \\(0\\) and \\(\\min\\left\\{m,n\\right\\}\\), inclusive. (The rank of a zero matrix is \\(0\\), and the rank of an \\(n\\times n\\) identity matrix is \\(n\\).) An alternate, but equivalent and often more useful, definition is that the rank of a nonzero \\(m\\times n\\) matrix \\(A\\) is the smallest number \\(r\\) such that there exist matrices \\(B\\) and \\(C\\) of respective sizes \\(m\\times r\\) and \\(r\\times n\\) such that \\(A=BC\\). A square \\(n\\times n\\) matrix has _full rank_ if its rank is \\(n\\). An \\(m\\times n\\) matrix has _full column rank_ if its rank is \\(n\\). The following theorem gives a fundamental property of ranks.\n\n**Theorem D.1**\n\nA square matrix has full rank if and only if it is nonsingular.\n\n### Basic matrix properties\n\nA _null vector_ for a matrix \\(A\\) is a nonzero vector \\(x\\) such that \\(Ax=0\\). The following theorem (whose proof is left as Exercise D.2-7) and its corollary relate the notions of column rank and singularity to null vectors.\n\n**Theorem D.2**: A matrix has full column rank if and only if it does not have a null vector.\n\n**Corollary D.3**: A square matrix is singular if and only if it has a null vector.\n\nThe _ij_th _minor_ of an \\(n\\times n\\) matrix \\(A\\), for \\(n>1\\), is the \\((n-1)\\times(n-1)\\) matrix \\(A_{[ij]}\\) obtained by deleting the _i_th row and _j_th column of \\(A\\). The _determinant_ of an \\(n\\times n\\) matrix \\(A\\) is defined recursively in terms of its minors by\n\n\\[\\det(A)=\\left\\{\\begin{array}{ll}a_{11}&\\mbox{if $n=1$,}\\\\ \\sum_{j=1}^{n}(-1)^{1+j}a_{1j}\\det(A_{[1j]})&\\mbox{if $n>1$.}\\end{array}\\right.\\]\n\nThe term \\((-1)^{i+j}\\det(A_{[ij]})\\) is known as the _cofactor_ of the element \\(a_{ij}\\).\n\nThe following theorems, whose proofs are omitted, express fundamental properties of the determinant.\n\n**Theorem D.4** (Determinant properties): The determinant of a square matrix \\(A\\) has the following properties:\n\n* If any row or any column of \\(A\\) is zero, then \\(\\det(A)=0\\).\n* The determinant of \\(A\\) is multiplied by \\(\\lambda\\) if the entries of any one row (or any one column) of \\(A\\) are all multiplied by \\(\\lambda\\).\n* The determinant of \\(A\\) is unchanged if the entries in one row (respectively, column) are added to those in another row (respectively, column).\n* The determinant of \\(A\\) equals the determinant of \\(A^{\\rm T}\\).\n* The determinant of \\(A\\) is multiplied by \\(-1\\) if any two rows (or any two columns) are exchanged.\n\nAlso, for any square matrices \\(A\\) and \\(B\\), we have \\(\\det(A\\,B)=\\det(A)\\det(B)\\).\n\n**Theorem D.5**: An \\(n\\times n\\) matrix \\(A\\) is singular if and only if \\(\\det(A)=0\\).\n\n### Positive-definite matrices\n\nPositive-definite matrices play an important role in many applications. An \\(n\\times n\\) matrix \\(A\\) is _positive-definite_ if \\(x^{\\mathrm{T}}Ax>0\\) for all \\(n\\)-vectors \\(x\\neq 0\\). For example, the identity matrix is positive-definite, since if \\(x=(\\ x_{1}\\ x_{2}\\ \\cdots\\ x_{n}\\ )^{\\mathrm{T}}\\) is a nonzero vector, then\n\n\\[x^{\\mathrm{T}}I_{n}x = x^{\\mathrm{T}}x\\] \\[= \\sum_{i=1}^{n}x_{i}^{2}\\] \\[> 0\\.\\]\n\nMatrices that arise in applications are often positive-definite due to the following theorem.\n\n**Theorem D.6**: For any matrix \\(A\\) with full column rank, the matrix \\(A^{\\mathrm{T}}A\\) is positive-definite.\n\nProofWe must show that \\(x^{\\mathrm{T}}(A^{\\mathrm{T}}A)x{>}0\\) for any nonzero vector \\(x\\). For any vector \\(x\\),\n\n\\[x^{\\mathrm{T}}(A^{\\mathrm{T}}A)x = (Ax)^{\\mathrm{T}}(Ax)\\quad\\text{(by Exercise D.1-2)}\\] \\[= \\left\\|Ax\\right\\|^{2}\\.\\]\n\nThe value \\(\\left\\|Ax\\right\\|^{2}\\) is just the sum of the squares of the elements of the vector \\(Ax\\). Therefore, \\(\\left\\|Ax\\right\\|^{2}\\geq 0\\). We'll show by contradiction that \\(\\left\\|Ax\\right\\|^{2}>0\\). Suppose that \\(\\left\\|Ax\\right\\|^{2}=0\\). Then, every element of \\(Ax\\) is 0, which is to say \\(Ax=0\\). Since \\(A\\) has full column rank, Theorem D.2 says that \\(x=0\\), which contradicts the requirement that \\(x\\) is nonzero. Hence, \\(A^{\\mathrm{T}}A\\) is positive-definite.\n\nSection 28.3 explores other properties of positive-definite matrices. Section 33.3 uses a similar condition, known as positive-semidefinite. An \\(n\\times n\\) matrix \\(A\\) is _positive-semidefinite_ if \\(x^{\\mathrm{T}}Ax\\geq 0\\) for all \\(n\\)-vectors \\(x\\neq 0\\).\n\n### Exercises\n\n#### D.2-1\n\nProve that matrix inverses are unique, that is, if \\(B\\) and \\(C\\) are inverses of \\(A\\), then \\(B=C\\).\n\n_D.2-2_\n\nProve that the determinant of a lower-triangular or upper-triangular matrix is equal to the product of its diagonal elements. Prove that the inverse of a lower-triangular matrix, if it exists, is lower-triangular.\n\n_D.2-3_\n\nProve that if \\(P\\) is a permutation matrix, then \\(P\\) is invertible, its inverse is \\(P^{\\rm T}\\), and \\(P^{\\rm T}\\) is a permutation matrix.\n\n_D.2-4_\n\nLet \\(A\\) and \\(B\\) be \\(n\\times n\\) matrices such that \\(AB=I\\). Prove that if \\(A^{\\prime}\\) is obtained from \\(A\\) by adding row \\(j\\) into row \\(i\\), where \\(i\\neq j\\), then subtracting column \\(i\\) from column \\(j\\) of \\(B\\) yields the inverse \\(B^{\\prime}\\) of \\(A^{\\prime}\\).\n\n_D.2-5_\n\nLet \\(A\\) be a nonsingular \\(n\\times n\\) matrix with complex entries. Show that every entry of \\(A^{-1}\\) is real if and only if every entry of \\(A\\) is real.\n\n_D.2-6_\n\nShow that if \\(A\\) is a nonsingular, symmetric, \\(n\\times n\\) matrix, then \\(A^{-1}\\) is symmetric. Show that if \\(B\\) is an arbitrary \\(m\\times n\\) matrix, then the \\(m\\times m\\) matrix given by the product \\(BAB^{\\rm T}\\) is symmetric.\n\n_D.2-7_\n\nProve Theorem D.2. That is, show that a matrix \\(A\\) has full column rank if and only if \\(Ax=0\\) implies \\(x=0\\). (_Hint:_ Express the linear dependence of one column on the others as a matrix-vector equation.)\n\n_D.2-8_\n\nProve that for any two compatible matrices \\(A\\) and \\(B\\),\n\n\\[{\\rm rank}(AB)\\leq\\min\\left\\{{\\rm rank}(A),{\\rm rank}(B)\\right\\}\\,\\]\n\nwhere equality holds if either \\(A\\) or \\(B\\) is a nonsingular square matrix. (_Hint:_ Use the alternate definition of the rank of a matrix.)\n\n**Problems**\n\n_D-1 Vandermonde matrix_\n\nGiven numbers \\(x_{0},x_{1},\\ldots,x_{n-1}\\), prove that the determinant of the _Vandermonde matrix_",
        "chapter": "Part VIII Appendix: Mathematical Background",
        "section": "D Matrices",
        "subsection": "D.2 Basic matrix properties",
        "subsubsection": "N/A"
    }
]