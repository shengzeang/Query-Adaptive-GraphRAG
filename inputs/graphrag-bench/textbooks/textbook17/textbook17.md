# 1 Introduction

# 1.1 What is machine learning?

A popular definition of machine learning or ML, due to Tom Mitchell [Mit97], is as follows:

A computer program is said to learn from experience E with respect to some class of tasks T, and performance measure P, if its performance at tasks in T, as measured by $\mathrm { P }$ , improves with experience E.

Thus there are many different kinds of machine learning, depending on the nature of the tasks $T$ we wish the system to learn, the nature of the performance measure $P$ we use to evaluate the system, and the nature of the training signal or experience $E$ we give it.

In this book, we will cover the most common types of ML, but from a probabilistic perspective. Roughly speaking, this means that we treat all unknown quantities (e.g., predictions about the future value of some quantity of interest, such as tomorrow’s temperature, or the parameters of some model) as random variables, that are endowed with probability distributions which describe a weighted set of possible values the variable may have. (See Chapter 2 for a quick refresher on the basics of probability, if necessary.)

There are two main reasons we adopt a probabilistic approach. First, it is the optimal approach to decision making under uncertainty, as we explain in Section 5.1. Second, probabilistic modeling is the language used by most other areas of science and engineering, and thus provides a unifying framework between these fields. As Shakir Mohamed, a researcher at DeepMind, put it:1

Almost all of machine learning can be viewed in probabilistic terms, making probabilistic thinking fundamental. It is, of course, not the only view. But it is through this view that we can connect what we do in machine learning to every other computational science, whether that be in stochastic optimisation, control theory, operations research, econometrics, information theory, statistical physics or bio-statistics. For this reason alone, mastery of probabilistic thinking is essential.

# 1.2 Supervised learning

The most common form of ML is supervised learning. In this problem, the task $T$ is to learn a mapping $f$ from inputs $\mathbf { \boldsymbol { x } } \in \mathcal { X }$ to outputs $\pmb { y } \in \mathcal { V }$ . The inputs $_ { x }$ are also called the features,

![](images/345e7f814bb96a86d2c1b4a3fab45669a1ba9e38326de809e4021d574b2360f0.jpg)  
Figure 1.1: Three types of Iris flowers: Setosa, Versicolor and Virginica. Used with kind permission of Dennis Kramb and SIGNA.

<html><body><table><tr><td>index</td><td>sl</td><td>SW</td><td>pl</td><td>pw</td><td>label</td></tr><tr><td>0</td><td>5.1</td><td>3.5</td><td>1.4</td><td>0.2</td><td>Setosa</td></tr><tr><td>1</td><td>4.9</td><td>3.0</td><td>1.4</td><td>0.2</td><td>Setosa</td></tr><tr><td>50</td><td>7.0</td><td>3.2</td><td>4.7</td><td>1.4</td><td>Versicolor</td></tr><tr><td>149</td><td>： 5.9</td><td>3.0</td><td>5.1</td><td>1.8</td><td>Virginica</td></tr></table></body></html>

Table 1.1: A subset of the Iris design matrix. The features are: sepal length, sepal width, petal length, petal width. There are 50 examples of each class.

covariates, or predictors; this is often a fixed-dimensional vector of numbers, such as the height and weight of a person, or the pixels in an image. In this case, $\boldsymbol { \mathcal { X } } = \mathbb { R } ^ { D }$ , where $D$ is the dimensionality response.2 The experience of the vector (i.e., the number of input features). The output $E$ is given in the form of a set of $N$ $\mathbf { \nabla } _ { \mathbf { \boldsymbol { y } } }$ input-output pairs is also known as the label, target, or $\mathcal { D } = \{ ( \boldsymbol { x } _ { n } , \boldsymbol { y } _ { n } ) \} _ { n = 1 } ^ { N }$ known as the training set. ( $N$ is called the sample size.) The performance measure $P$ depends on the type of output we are predicting, as we discuss below.

# 1.2.1 Classification

In classification problems, the output space is a set of $C$ unordered and mutually exclusive labels known as classes, $\mathcal { V } = \{ 1 , 2 , \ldots , C \}$ . The problem of predicting the class label given an input is also called pattern recognition. (If there are just two classes, often denoted by $y \in \{ 0 , 1 \}$ or $y \in \{ - 1 , + 1 \}$ , it is called binary classification.)

# 1.2.1.1 Example: classifying Iris flowers

As an example, consider the problem of classifying Iris flowers into their 3 subspecies, Setosa, Versicolor and Virginica. Figure 1.1 shows one example of each of these classes.

![](images/b9c3487395cd217a45af8d70bb85072a469dd2feb958c1df17da69df14905de9.jpg)  
Figure 1.2: Illustration of the image classification problem. From https: // cs231n. github. io/ . Used with kind permission of Andrej Karpathy.

In image classification, the input space $\mathcal { X }$ is the set of images, which is a very high-dimensional space: for a color image with $C = 3$ channels (e.g., RGB) and $D _ { 1 } \times D _ { 2 }$ pixels, we have $\boldsymbol { \mathcal { X } } = \mathbb { R } ^ { D }$ , where $D = C \times D _ { 1 } \times D _ { 2 }$ . (In practice we represent each pixel intensity with an integer, typically from the range $\{ 0 , 1 , \ldots , 2 5 5 \}$ , but we assume real valued inputs for notational simplicity.) Learning a mapping $f : \mathcal { X }  \mathcal { Y }$ from images to labels is quite challenging, as illustrated in Figure 1.2. However, it can be tackled using certain kinds of functions, such as a convolutional neural network or CNN, which we discuss in Section 14.1.

Fortunately for us, some botanists have already identified 4 simple, but highly informative, numeric features — sepal length, sepal width, petal length, petal width — which can be used to distinguish the three kinds of Iris flowers. In this section, we will use this much lower-dimensional input space, $\mathcal { X } = \mathbb { R } ^ { 4 }$ , for simplicity. The Iris dataset is a collection of 150 labeled examples of Iris flowers, 50 of each type, described by these 4 features. It is widely used as an example, because it is small and simple to understand. (We will discuss larger and more complex datasets later in the book.)

When we have small datasets of features, it is common to store them in an $N \times D$ matrix, in which each row represents an example, and each column represents a feature. This is known as a design matrix; see Table 1.1 for an example.3

The Iris dataset is an example of tabular data. When the inputs are of variable size (e.g., sequences of words, or social networks), rather than fixed-length vectors, the data is usually stored in some other format rather than in a design matrix. However, such data is often converted to a fixed-sized feature representation (a process known as featurization), thus implicitly creating a design matrix for further processing. We give an example of this in Section 1.5.4.1, where we discuss the “bag of words” representation for sequence data.

![](images/4c6b8763356406d76e56ad1f017c6bb4fa9b6a615b0f568cc09ecc6514402ca6.jpg)  
Figure 1.3: Visualization of the Iris data as a pairwise scatter plot. On the diagonal we plot the marginal distribution of each feature for each class. The off-diagonals contain scatterplots of all possible pairs of features. Generated by iris_plot.ipynb

# 1.2.1.2 Exploratory data analysis

Before tackling a problem with ML, it is usually a good idea to perform exploratory data analysis, to see if there are any obvious patterns (which might give hints on what method to choose), or any obvious problems with the data (e.g., label noise or outliers).

For tabular data with a small number of features, it is common to make a pair plot, in which panel $( i , j )$ shows a scatter plot of variables $i$ and $j$ , and the diagonal entries $( i , i )$ show the marginal density of variable $i$ ; all plots are optionally color coded by class label — see Figure 1.3 for an example.

For higher-dimensional data, it is common to first perform dimensionality reduction, and then

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022 to visualize the data in 2d or 3d. We discuss methods for dimensionality reduction in Chapter 20.

![](images/00f94a81c714a31b1b851975a7b4a8e179aea72d735908fa5df4c5a51f886890.jpg)  
Figure 1.4: Example of a decision tree of depth 2 applied to the Iris data, using just the petal length and petal width features. Leaf nodes are color coded according to the predicted class. The number of training samples that pass from the root to a node is shown inside each box; we show how many values of each class fall into this node. This vector of counts can be normalized to get a distribution over class labels for each node. We can then pick the majority class. Adapted from Figures 6.1 and 6.2 of [Gér19]. Generated by iris_dtree.ipynb.

# 1.2.1.3 Learning a classifier

From Figure 1.3, we can see that the Setosa class is easy to distinguish from the other two classes. For example, suppose we create the following decision rule:

This is a very simple example of a classifier, in which we have partitioned the input space into two regions, defined by the one-dimensional (1d) decision boundary at $x _ { \mathrm { p e t a l ~ l e n g t h } } = 2 . 4 5$ . Points lying to the left of this boundary are classified as Setosa; points to the right are either Versicolor or Virginica.

We see that this rule perfectly classifies the Setosa examples, but not the Virginica and Versicolor ones. To improve performance, we can recursively partition the space, by splitting regions in which the classifier makes errors. For example, we can add another decision rule, to be applied to inputs that fail the first test, to check if the petal width is below 1.75cm (in which case we predict Versicolor) or above (in which case we predict Virginica). We can arrange these nested rules into a tree structure,

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license called a decision tree, as shown in Figure 1.4a This induces the 2d decision surface shown in Figure 1.4b.

Table 1.2: Hypothetical asymmetric loss matrix for Iris classification.   

<html><body><table><tr><td></td><td colspan="4">Estimate</td></tr><tr><td rowspan="4">Truth</td><td></td><td>Setosa</td><td>Versicolor</td><td>Virginica</td></tr><tr><td>Setosa</td><td>0</td><td>1</td><td>1</td></tr><tr><td>Versicolor</td><td>1</td><td>0</td><td>1</td></tr><tr><td>Virginica</td><td>10</td><td>10</td><td>0</td></tr></table></body></html>

We can represent the tree by storing, for each internal node, the feature index that is used, as well as the corresponding threshold value. We denote all these parameters by $\pmb \theta$ . We discuss how to learn these parameters in Section 18.1.

# 1.2.1.4 Empirical risk minimization

The goal of supervised learning is to automatically come up with classification models such as the one shown in Figure 1.4a, so as to reliably predict the labels for any given input. A common way to measure performance on this task is in terms of the misclassification rate on the training set:

$$
\mathcal { L } ( \pmb { \theta } ) \triangleq \frac { 1 } { N } \sum _ { n = 1 } ^ { N } \mathbb { I } \left( y _ { n } \neq f ( \pmb { x } _ { n } ; \pmb { \theta } ) \right)
$$

where $\mathbb { I } \left( e \right)$ is the binary indicator function, which returns 1 iff (if and only if) the condition $e$ is true, and returns 0 otherwise, i.e.,

$$
\mathbb { I } \left( e \right) = \left\{ \begin{array} { l l } { 1 } & { \mathrm { ~ i f ~ } e \mathrm { ~ i s ~ t r u e } } \\ { 0 } & { \mathrm { ~ i f ~ } e \mathrm { ~ i s ~ f a l s e } } \end{array} \right.
$$

This assumes all errors are equal. However it may be the case that some errors are more costly than others. For example, suppose we are foraging in the wilderness and we find some Iris flowers. Furthermore, suppose that Setosa and Versicolor are tasty, but Virginica is poisonous. In this case, we might use the asymmetric loss function $\ell ( y , \hat { y } )$ shown in Table 1.2.

We can then define empirical risk to be the average loss of the predictor on the training set:

$$
\mathcal { L } ( \pmb { \theta } ) \triangleq \frac { 1 } { N } \sum _ { n = 1 } ^ { N } \ell ( y _ { n } , f ( \pmb { x } _ { n } ; \pmb { \theta } ) )
$$

We see that the misclassification rate Equation (1.2) is equal to the empirical risk when we use zero-one loss for comparing the true label with the prediction:

$$
\ell _ { 0 1 } ( y , \hat { y } ) = \mathbb { I } \left( y \neq \hat { y } \right)
$$

See Section 5.1 for more details.

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

One way to define the problem of model fitting or training is to find a setting of the parameters that minimizes the empirical risk on the training set:

$$
\hat { \pmb { \theta } } = \underset { \pmb { \theta } } { \mathrm { a r g m i n } } \mathcal { L } ( \pmb { \theta } ) = \underset { \pmb { \theta } } { \mathrm { a r g m i n } } \frac { 1 } { N } \sum _ { n = 1 } ^ { N } \ell ( y _ { n } , f ( \pmb { x } _ { n } ; \pmb { \theta } ) )
$$

This is called empirical risk minimization.

However, our true goal is to minimize the expected loss on future data that we have not yet seen. That is, we want to generalize, rather than just do well on the training set. We discuss this important point in Section 1.2.3.

# 1.2.1.5 Uncertainty

[We must avoid] false confidence bred from an ignorance of the probabilistic nature of the world, from a desire to see black and white where we should rightly see gray. — Immanuel Kant, as paraphrased by Maria Konnikova [Kon20].

In many cases, we will not be able to perfectly predict the exact output given the input, due to lack of knowledge of the input-output mapping (this is called epistemic uncertainty or model uncertainty), and/or due to intrinsic (irreducible) stochasticity in the mapping (this is called aleatoric uncertainty or data uncertainty).

Representing uncertainty in our prediction can be important for various applications. For example, let us return to our poisonous flower example, whose loss matrix is shown in Table 1.2. If we predict the flower is Virginica with high probability, then we should not eat the flower. Alternatively, we may be able to perform an information gathering action, such as performing a diagnostic test, to reduce our uncertainty. For more information about how to make optimal decisions in the presence of uncertainty, see Section 5.1.

We can capture our uncertainty using the following conditional probability distribution:

$$
p ( y = c | \mathbf { r } ; \pmb { \theta } ) = f _ { c } ( \mathbf { r } ; \pmb { \theta } )
$$

where $f : \mathcal { X }  [ 0 , 1 ] ^ { C }$ maps inputs to a probability distribution over the $C$ possible output labels. Since $f _ { c } ( { \pmb x } ; { \pmb \theta } )$ returns the probability of class label $c$ , we require $0 \leq f _ { c } \leq 1$ for each $c$ , and $\textstyle \sum _ { c = 1 } ^ { C } f _ { c } = 1$ To avoid this restriction, it is common to instead require the model to return unnormalized logprobabilities. We can then convert these to probabilities using the softmax function, which is defined as follows

$$
\mathrm { s o f t m a x } ( a ) \triangleq \left[ { \frac { e ^ { a _ { 1 } } } { \sum _ { c ^ { \prime } = 1 } ^ { C } e ^ { a _ { c ^ { \prime } } } } } , . . . , { \frac { e ^ { a _ { C } } } { \sum _ { c ^ { \prime } = 1 } ^ { C } e ^ { a _ { c ^ { \prime } } } } } \right]
$$

This maps $\mathbb { R } ^ { C }$ to $[ 0 , 1 ] ^ { C }$ , and satisfies the constraints that $0 \leq \mathrm { s o f t m a x } ( \pmb { a } ) _ { c } \leq 1$ and $\textstyle \sum _ { c = 1 } ^ { C }$ $\mathrm { s o f t m a x } ( a ) _ { c } =$ 1. The inputs to the softmax, $\pmb { a } = f ( \pmb { x } ; \pmb { \theta } )$ , are called logits. See Section 2.5.2 for details. We thus define the overall model as follows:

$$
p ( y = c | \pmb { x } ; \pmb { \theta } ) = \mathrm { s o f t m a x } _ { c } \big ( f ( \pmb { x } ; \pmb { \theta } ) \big )
$$

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

A common special case of this arises when $f$ is an affine function of the form

$$
f ( { \pmb x } ; { \pmb \theta } ) = b + { \pmb w } ^ { \mathsf { T } } { \pmb x } = b + w _ { 1 } x _ { 1 } + w _ { 2 } x _ { 2 } + \cdot \cdot \cdot + w _ { D } x _ { D }
$$

where $\pmb \theta = ( b , \pmb w )$ are the parameters of the model. This model is called logistic regression, and will be discussed in more detail in Chapter 10.

In statistics, the $\mathbf { \boldsymbol { w } }$ parameters are usually called regression coefficients (and are typically denoted by $\beta$ ) and $b$ is called the intercept. In ML, the parameters $\mathbf { \boldsymbol { w } }$ are called the weights and $b$ is called the bias. This terminology arises from electrical engineering, where we view the function $f$ as a circuit which takes in $_ { x }$ and returns $f ( { \pmb x } )$ . Each input is fed to the circuit on “wires”, which have weights $\mathbf { \boldsymbol { w } }$ . The circuit computes the weighted sum of its inputs, and adds a constant bias or offset term $b$ . (This use of the term “bias” should not be confused with the statistical concept of bias discussed in Section 4.7.6.1.)

To reduce notational clutter, it is common to absorb the bias term $b$ into the weights $\mathbf { \boldsymbol { w } }$ by defining $\tilde { \pmb { w } } = [ b , w _ { 1 } , \dotsc , w _ { D } ]$ and defining $\tilde { \boldsymbol { x } } = [ 1 , x _ { 1 } , \dots , x _ { D } ]$ , so that

$$
\tilde { \mathbf { \Gamma } } \tilde { \mathbf { \mathbf { w } } } ^ { \mathsf { T } } \tilde { \mathbf { x } } = \boldsymbol { b } + \mathbf { w } ^ { \mathsf { T } } \mathbf { x }
$$

This converts the affine function into a linear function. We will usually assume that this has been done, so we can just write the prediction function as follows:

$$
f ( \mathbf { x } ; \pmb { w } ) = \pmb { w } ^ { \top } \pmb { x }
$$

# 1.2.1.6 Maximum likelihood estimation

When fitting probabilistic models, it is common to use the negative log probability as our loss function:

$$
\ell ( y , f ( x ; \pmb \theta ) ) = - \log p ( y | f ( \pmb x ; \pmb \theta ) )
$$

The reasons for this are explained in Section 5.1.6.1, but the intuition is that a good model (with low loss) is one that assigns a high probability to the true output $y$ for each corresponding input $_ { x }$ . The average negative log probability of the training set is given by

$$
\mathrm { N L L } ( \pmb \theta ) = - \frac { 1 } { N } \sum _ { n = 1 } ^ { N } \log p ( y _ { n } | f ( \pmb x _ { n } ; \pmb \theta ) )
$$

This is called the negative log likelihood. If we minimize this, we can compute the maximum likelihood estimate or MLE:

$$
\hat { \pmb { \theta } } _ { \mathrm { m l e } } = \mathop { \mathrm { a r g m i n } } _ { \pmb { \theta } } \mathrm { N L L } ( \pmb { \theta } )
$$

This is a very common way to fit models to data, as we will see.

# 1.2.2 Regression

Now suppose that we want to predict a real-valued quantity $y \in \mathbb { R }$ instead of a class label $y \in$ $\{ 1 , \ldots , C \}$ ; this is known as regression. For example, in the case of Iris flowers, $y$ might be the degree of toxicity if the flower is eaten, or the average height of the plant.

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

Regression is very similar to classification. However, since the output is real-valued, we need to use a different loss function. For regression, the most common choice is to use quadratic loss, or $\ell _ { 2 }$ loss:

$$
\ell _ { 2 } ( y , \hat { y } ) = ( y - \hat { y } ) ^ { 2 }
$$

This penalizes large residuals $y - { \hat { y } }$ more than small ones.4 The empirical risk when using quadratic loss is equal to the mean squared error or MSE:

$$
\operatorname { M S E } ( \pmb { \theta } ) = \frac { 1 } { N } \sum _ { n = 1 } ^ { N } ( y _ { n } - f ( \pmb { x } _ { n } ; \pmb { \theta } ) ) ^ { 2 }
$$

Based on the discussion in Section 1.2.1.5, we should also model the uncertainty in our prediction. In regression problems, it is common to assume the output distribution is a Gaussian or normal. As we explain in Section 2.6, this distribution is defined by

$$
\mathcal { N } ( y | \mu , \sigma ^ { 2 } ) \triangleq \frac { 1 } { \sqrt { 2 \pi \sigma ^ { 2 } } } e ^ { - \frac { 1 } { 2 \sigma ^ { 2 } } ( y - \mu ) ^ { 2 } }
$$

where $\mu$ is the mean, $\sigma ^ { 2 }$ is the variance, and $\scriptstyle { \sqrt { 2 \pi \sigma ^ { 2 } } }$ is the normalization constant needed to ensure the density integrates to 1. In the context of regression, we can make the mean depend on the inputs by defining $\mu = f ( \pmb { x } _ { n } ; \pmb { \theta } )$ . We therefore get the following conditional probability distribution:

$$
p ( \boldsymbol { y } | \mathbf { x } ; \pmb { \theta } ) = \mathcal { N } ( \boldsymbol { y } | f ( \mathbf { x } ; \pmb { \theta } ) , \sigma ^ { 2 } )
$$

If we assume that the variance $\sigma ^ { 2 }$ is fixed (for simplicity), the corresponding negative log likelihood becomes

$$
{ \begin{array} { r l } & { { \mathrm { N L L } } ( \pmb { \theta } ) = - { \frac { 1 } { N } } \displaystyle \sum _ { n = 1 } ^ { N _ { D } } \log \left[ \left( { \frac { 1 } { 2 \pi \sigma ^ { 2 } } } \right) ^ { \frac { 1 } { 2 } } \exp \left( - { \frac { 1 } { 2 \sigma ^ { 2 } } } ( y _ { n } - f ( \mathbf { \boldsymbol { x } } _ { n } ; \pmb { \theta } ) ) ^ { 2 } \right) \right] } \\ & { \quad \quad \quad = { \frac { 1 } { 2 \sigma ^ { 2 } } } { \mathrm { M S E } } ( \pmb { \theta } ) + { \mathrm { c o n s t } } } \end{array} }
$$

We see that the NLL is proportional to the MSE. Hence computing the maximum likelihood estimate of the parameters will result in minimizing the squared error, which seems like a sensible approach to model fitting.

# 1.2.2.1 Linear regression

As an example of a regression model, consider the 1d data in Figure 1.5a. We can fit this data using a simple linear regression model of the form

$$
f ( x ; \pmb \theta ) = b + w x
$$

![](images/6728a1422245046f048306d2194a98d2f455d1f636f6af27f8d5e2b1f2c6a460.jpg)  
Figure 1.5: (a) Linear regression on some 1d data. (b) The vertical lines denote the residuals between the observed output value for each input (blue circle) and its predicted value (red cross). The goal of least squares regression is to pick a line that minimizes the sum of squared residuals. Generated by linreg_residuals_plot.ipynb.

where $w$ is the slope, $b$ is the offset, and $\pmb \theta = ( w , b )$ are all the parameters of the model. By adjusting $\pmb \theta$ , we can minimize the sum of squared errors, shown by the vertical lines in Figure 1.5b. until we find the least squares solution

$$
\hat { \pmb { \theta } } = \mathop { \mathrm { a r g m i n } } _ { \pmb { \theta } } \mathrm { M S E } ( \pmb { \theta } )
$$

See Section 11.2.2.1 for details.

If we have multiple input features, we can write

$$
f ( \pmb { x } ; \pmb { \theta } ) = b + w _ { 1 } x _ { 1 } + \cdot \cdot \cdot + w _ { D } x _ { D } = b + \pmb { w } ^ { \top } \pmb { x }
$$

where $\pmb \theta = ( \pmb w , b )$ . This is called multiple linear regression.

For example, consider the task of predicting temperature as a function of 2d location in a room. Figure 1.6(a) plots the results of a linear model of the following form:

$$
f ( \pmb { x } ; \pmb { \theta } ) = b + w _ { 1 } x _ { 1 } + w _ { 2 } x _ { 2 }
$$

We can extend this model to use $D > 2$ input features (such as time of day), but then it becomes harder to visualize.

# 1.2.2.2 Polynomial regression

The linear model in Figure 1.5a is obviously not a very good fit to the data. We can improve the fit by using a polynomial regression model of degree $D$ . This has the form $f ( x ; { \pmb w } ) = { \pmb w } ^ { 1 } \phi ( x )$ , where $\phi ( x )$ is a feature vector derived from the input, which has the following form:

$$
\phi ( x ) = [ 1 , x , x ^ { 2 } , . . . , x ^ { D } ]
$$

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

![](images/3d6ea4918b3ddfa1df652c8f6744fe1d7afa6034c1cc3cf44047733d0cd7e331.jpg)  
Figure 1.6: Linear and polynomial regression applied to 2d data. Vertical axis is temperature, horizontal axes are location within a room. Data was collected by some remote sensing motes at Intel’s lab in Berkeley, CA (data courtesy of Romain Thibaux). (a) The fitted plane has the form $\hat { f } ( \pmb { x } ) = w _ { 0 } + w _ { 1 } x _ { 1 } + w _ { 2 } x _ { 2 }$ . $( b )$ Temperature data is fitted with a quadratic of the form $\hat { f } ( \pmb { x } ) = w _ { 0 } + w _ { 1 } x _ { 1 } + w _ { 2 } x _ { 2 } + w _ { 3 } x _ { 1 } ^ { 2 } + w _ { 4 } x _ { 2 } ^ { 2 }$ . Generated by linreg_2d_surface_demo.ipynb.

This is a simple example of feature preprocessing, also called feature engineering.

In Figure 1.7a, we see that using $D = 2$ results in a much better fit. We can keep increasing $D$ , and hence the number of parameters in the model, until $D = N - 1$ ; in this case, we have one parameter per data point, so we can perfectly interpolate the data. The resulting model will have 0 MSE, as shown in Figure 1.7c. However, intuitively the resulting function will not be a good predictor for future inputs, since it is too “wiggly”. We discuss this in more detail in Section 1.2.3.

We can also apply polynomial regression to multi-dimensional inputs. For example, Figure 1.6(b) plots the predictions for the temperature model after performing a quadratic expansion of the inputs

$$
f ( \pmb { x } ; \pmb { w } ) = w _ { 0 } + w _ { 1 } x _ { 1 } + w _ { 2 } x _ { 2 } + w _ { 3 } x _ { 1 } ^ { 2 } + w _ { 4 } x _ { 2 } ^ { 2 }
$$

The quadratic shape is a better fit to the data than the linear model in Figure 1.6(a), since it captures the fact that the middle of the room is hotter. We can also add cross terms, such as $x _ { 1 } x _ { 2 }$ , to capture interaction effects. See Section 1.5.3.2 for details.

Note that the above models still use a prediction function that is a linear function of the parameters $\mathbf { \boldsymbol { w } }$ , even though it is a nonlinear function of the original input $_ { x }$ . The reason this is important is that a linear model induces an MSE loss function MSE(θ) that has a unique global optimum, as we explain in Section 11.2.2.1.

# 1.2.2.3 Deep neural networks

In Section 1.2.2.2, we manually specified the transformation of the input features, namely polynomial expansion, $\phi ( \pmb { x } ) = [ 1 , x _ { 1 } , x _ { 2 } , x _ { 1 } ^ { 2 } , x _ { 2 } ^ { 2 } , . . . ]$ . We can create much more powerful models by learning to do such nonlinear feature extraction automatically. If we let $\phi ( { \pmb x } )$ have its own set of parameters, say $\mathbf { V }$ , then the overall model has the form

$$
f ( \mathbf { x } ; \mathbf { w } , \mathbf { V } ) = \mathbf { w } ^ { \top } \phi ( \mathbf { x } ; \mathbf { V } )
$$

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

![](images/caf902f3b533aede90e3408aaf7548ee868710dc83a3ae3927c8a6bb33a14477.jpg)  
Figure 1.7: (a-c) Polynomials of degrees 2, 14 and 20 fit to 21 datapoints (the same data as in Figure 1.5). (d) MSE vs degree. Generated by linreg_poly_vs_degree.ipynb.

We can recursively decompose the feature extractor $\phi ( \pmb { x } ; \mathbf { V } )$ into a composition of simpler functions. The resulting model then becomes a stack of $L$ nested functions:

$$
f ( \pmb { x } ; \pmb { \theta } ) = f _ { L } \big ( f _ { L - 1 } \big ( \cdot \cdot \cdot ( f _ { 1 } ( \pmb { x } ) ) \cdot \cdot \cdot \big ) \big )
$$

where $f _ { \ell } ( { \pmb x } ) ~ = ~ f ( { \pmb x } ; { \pmb \theta } _ { \ell } )$ is the function at layer $\ell$ . The final layer is linear and has the form $f _ { L } ( \pmb { x } ) = \pmb { w } ^ { \mathsf { T } } f _ { 1 : L - 1 } ( \pmb { x } )$ , where $f _ { 1 : L - 1 } ( { \pmb x } )$ is the learned feature extractor. This is the key idea behind deep neural networks or DNNs, which includes common variants such as convolutional neural networks (CNNs) for images, and recurrent neural networks (RNNs) for sequences. See Part III for details.

# 1.2.3 Overfitting and generalization

We can rewrite the empirical risk in Equation (1.4) in the following equivalent way:

$$
\mathcal { L } ( \pmb { \theta } ; \mathcal { D } _ { \mathrm { t r a i n } } ) = \frac { 1 } { | \mathcal { D } _ { \mathrm { t r a i n } } | } \sum _ { ( \pmb { x } , \pmb { y } ) \in \mathcal { D } _ { \mathrm { t r a i n } } } \ell ( \pmb { y } , f ( \pmb { x ; \theta } ) )
$$

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022 where $| \mathcal { D } _ { \mathrm { t r a i n } } |$ is the size of the training set $\mathscr { D } _ { \mathrm { t r a i n } }$ . This formulation is useful because it makes explicit which dataset the loss is being evaluated on.

With a suitably flexible model, we can drive the training loss to zero (assuming no label noise), by simply memorizing the correct output for each input. For example, Figure 1.7(c) perfectly interpolates the training data (modulo the last point on the right). But what we care about is prediction accuracy on new data, which may not be part of the training set. A model that perfectly fits the training data, but which is too complex, is said to suffer from overfitting.

To detect if a model is overfitting, let us assume (for now) that we have access to the true (but unknown) distribution $p ^ { * } ( { \pmb x } , { \pmb y } )$ used to generate the training set. Then, instead of computing the empirical risk we compute the theoretical expected loss or population risk

$$
\mathcal { L } ( \pmb { \theta } ; p ^ { * } ) \triangleq \mathbb { E } _ { p ^ { * } ( \pmb { x } , \pmb { y } ) } \left[ \ell ( \pmb { y } , f ( \pmb { x } ; \pmb { \theta } ) ) \right]
$$

The difference $\mathcal { L } ( \pmb { \theta } ; p ^ { * } ) - \mathcal { L } ( \pmb { \theta } ; \mathcal { D } _ { \mathrm { t r a i n } } )$ is called the generalization gap. If a model has a large generalization gap (i.e., low empirical risk but high population risk), it is a sign that it is overfitting. In practice we don’t know $p ^ { * }$ . However, we can partition the data we do have into two subsets, known as the training set and the test set. Then we can approximate the population risk using the test risk:

$$
\mathcal { L } ( \pmb { \theta } ; \mathcal { D } _ { \mathrm { t e s t } } ) \triangleq \frac { 1 } { | \mathcal { D } _ { \mathrm { t e s t } } | } \sum _ { ( \pmb { x } , \pmb { y } ) \in \mathcal { D } _ { \mathrm { t e s t } } } \ell ( \pmb { y } , f ( \pmb { x } ; \pmb { \theta } ) )
$$

As an example, in Figure 1.7d, we plot the training error and test error for polynomial regression as a function of degree $D$ . We see that the training error goes to 0 as the model becomes more complex. However, the test error has a characteristic U-shaped curve: on the left, where $D = 1$ , the model is underfitting; on the right, where $D \gg 1$ , the model is overfitting; and when $D = 2$ , the model complexity is “just right”.

How can we pick a model of the right complexity? If we use the training set to evaluate different models, we will always pick the most complex model, since that will have the most degrees of freedom, and hence will have minimum loss. So instead we should pick the model with minimum test loss.

In practice, we need to partition the data into three sets, namely the training set, the test set and a validation set; the latter is used for model selection, and we just use the test set to estimate future performance (the population risk), i.e., the test set is not used for model fitting or model selection. See Section 4.5.4 for further details.

# 1.2.4 No free lunch theorem

All models are wrong, but some models are useful. — George Box [BD87, p424].5

Given the large variety of models in the literature, it is natural to wonder which one is best. Unfortunately, there is no single best model that works optimally for all kinds of problems — this is sometimes called the no free lunch theorem [Wol96]. The reason is that a set of assumptions (also called inductive bias) that works well in one domain may work poorly in another. The best way to pick a suitable model is based on domain knowledge, and/or trial and error (i.e., using model selection techniques such as cross validation (Section 4.5.4) or Bayesian methods (Section 5.2.2 and Section 5.2.6). For this reason, it is important to have many models and algorithmic techniques in one’s toolbox to choose from.

# 1.3 Unsupervised learning

In supervised learning, we assume that each input example $_ { x }$ in the training set has an associated set of output targets $\pmb { y }$ , and our goal is to learn the input-output mapping. Although this is useful, and can be difficult, supervised learning is essentially just “glorified curve fitting” [Pea18].

An arguably much more interesting task is to try to “make sense of” data, as opposed to just learning a mapping. That is, we just get observed “inputs” $\mathcal { D } = \{ \pmb { x } _ { n } : n = 1 : N \}$ without any corresponding “outputs” ${ \bf { y } } _ { n }$ . This is called unsupervised learning.

From a probabilistic perspective, we can view the task of unsupervised learning as fitting an unconditional model of the form $p ( { \pmb x } )$ , which can generate new data $_ { x }$ , whereas supervised learning involves fitting a conditional model, $p ( \pmb { y } | \pmb { x } )$ , which specifies (a distribution over) outputs given inputs.6

Unsupervised learning avoids the need to collect large labeled datasets for training, which can often be time consuming and expensive (think of asking doctors to label medical images).

Unsupervised learning also avoids the need to learn how to partition the world into often arbitrary categories. For example, consider the task of labeling when an action, such as “drinking” or “sipping”, occurs in a video. Is it when the person picks up the glass, or when the glass first touches the mouth, or when the liquid pours out? What if they pour out some liquid, then pause, then pour again — is that two actions or one? Humans will often disagree on such issues [Idr+17], which means the task is not well defined. It is therefore not reasonable to expect machines to learn such mappings.7

Finally, unsupervised learning forces the model to “explain” the high-dimensional inputs, rather than just the low-dimensional outputs. This allows us to learn richer models of “how the world works”. As Geoff Hinton, who is a famous professor of ML at the University of Toronto, has said:

When we’re learning to see, nobody’s telling us what the right answers are — we just look. Every so often, your mother says “that’s a dog”, but that’s very little information. You’d be lucky if you got a few bits of information — even one bit per second — that way. The brain’s visual system has $1 0 ^ { 1 4 }$ neural connections. And you only live for $1 0 ^ { 9 }$ seconds. So it’s no use learning one bit per second. You need more like $1 0 ^ { 5 }$ bits per second. And there’s only one place you can get that much information: from the input itself. — Geoffrey Hinton, 1996 (quoted in [Gor06]).

# 1.3.1 Clustering

A simple example of unsupervised learning is the problem of finding clusters in data. The goal is to partition the input into regions that contain “similar” points. As an example, consider a 2d version of the Iris dataset. In Figure 1.8a, we show the points without any class labels. Intuitively there are at least two clusters in the data, one in the bottom left and one in the top right. Furthermore, if we assume that a “good” set of clusters should be fairly compact, then we might want to split the top right into (at least) two subclusters. The resulting partition into three clusters is shown in Figure 1.8b. (Note that there is no correct number of clusters; instead, we need to consider the tradeoff between model complexity and fit to the data. We discuss ways to make this tradeoff in Section 21.3.7.)

![](images/b29996fd3aaaf75ff1daed1fce451819ca7af2f7f2acb2ac4f82b24adb1fc327.jpg)  
Figure 1.8: (a) $A$ scatterplot of the petal features from the iris dataset. (b) The result of unsupervised clustering using $K = 3$ . Generated by iris_kmeans.ipynb.

![](images/1accd153245e149a23441c7e5c3df75479200b843fb0b9202e436ddd0c61ea46.jpg)  
Figure 1.9: (a) Scatterplot of iris data (first 3 features). Points are color coded by class. (b) We fit a 2d linear subspace to the 3d data using PCA. The class labels are ignored. Red dots are the original data, black dots are points generated from the model using $\hat { \pmb { x } } = \mathbf { W } \pmb { z } + \pmb { \mu }$ , where $z$ are latent points on the underlying inferred 2d linear manifold. Generated by iris_pca.ipynb.

# 1.3.2 Discovering latent “factors of variation”

When dealing with high-dimensional data, it is often useful to reduce the dimensionality by projecting it to a lower dimensional subspace which captures the “essence” of the data. One approach to this problem is to assume that each observed high-dimensional output $\pmb { x } _ { n } \in \mathbb { R } ^ { D }$ was generated by a set

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license of hidden or unobserved low-dimensional latent factors $z _ { n } \in \mathbb { R } ^ { K }$ . We can represent the model diagrammatically as follows: $z _ { n } \to x _ { n }$ , where the arrow represents causation. Since we don’t know the latent factors $z _ { n }$ , we often assume a simple prior probability model for $p ( z _ { n } )$ such as a Gaussian, which says that each factor is a random $K$ -dimensional vector. If the data is real-valued, we can use a Gaussian likelihood as well.

The simplest example is when we use a linear model, $p ( \pmb { x } _ { n } | \mathbf { \tilde { z } } _ { n } ; \pmb { \theta } ) = \mathcal { N } ( \pmb { x } _ { n } | \mathbf { W } \boldsymbol { z } _ { n } + \pmb { \mu } , \pmb { \Sigma } )$ . The resulting model is called factor analysis (FA). It is similar to linear regression, except we only observe the outputs ${ \boldsymbol { \mathbf { \mathit { x } } } } _ { n }$ , and not the inputs $z _ { n }$ . In the special case that $\pmb { \Sigma } = \sigma ^ { 2 } \pmb { \mathrm { I } }$ , this reduces to a model called probabilistic principal components analysis (PCA), which we will explain in Section 20.1. In Figure 1.9, we give an illustration of how this method can find a 2d linear subspace when applied to some simple 3d data.

Of course, assuming a linear mapping from $z _ { n }$ to ${ \boldsymbol { \mathbf { \mathit { x } } } } _ { n }$ is very restrictive. However, we can create nonlinear extensions by defining $p ( \pmb { x } _ { n } | \mathbf { \boldsymbol { z } } _ { n } ; \pmb { \theta } ) = \mathcal { N } ( \pmb { x } _ { n } | f ( \mathbf { \boldsymbol { z } } _ { n } ; \pmb { \theta } ) , \sigma ^ { 2 } \mathbf { I } )$ , where $f ( z ; \theta )$ is a nonlinear model, such as a deep neural network. It becomes much harder to fit such a model (i.e., to estimate the parameters $\pmb \theta$ ), because the inputs to the neural net have to be inferred, as well as the parameters of the model. However, there are various approximate methods, such as the variational autoencoder which can be applied (see Section 20.3.5).

# 1.3.3 Self-supervised learning

A recently popular approach to unsupervised learning is known as self-supervised learning. In this approach, we create proxy supervised tasks from unlabeled data. For example, we might try to learn to predict a color image from a grayscale image, or to mask out words in a sentence and then try to predict them given the surrounding context. The hope is that the resulting predictor $\hat { \pmb x } _ { 1 } = f ( \pmb x _ { 2 } ; \pmb \theta )$ , where $\mathbf { \boldsymbol { x } } _ { 2 }$ is the observed input and $\scriptstyle { \hat { \mathbf { x } } } _ { 1 }$ is the predicted output, will learn useful features from the data, that can then be used in standard, downstream supervised tasks. This avoids the hard problem of trying to infer the “true latent factors” $\mathscr { z }$ behind the observed data, and instead relies on standard supervised learning methods. We discuss this approach in more detail in Section 19.2.

# 1.3.4 Evaluating unsupervised learning

Although unsupervised learning is appealing, it is very hard to evaluate the quality of the output of an unsupervised learning method, because there is no ground truth to compare to [TOB16].

A common method for evaluating unsupervised models is to measure the probability assigned by the model to unseen test examples. We can do this by computing the (unconditional) negative log likelihood of the data:

$$
\mathcal { L } ( \pmb { \theta } ; \mathcal { D } ) = - \frac { 1 } { | \mathcal { D } | } \sum _ { \pmb { x } \in \mathcal { D } } \log p ( \pmb { x } | \pmb { \theta } )
$$

This treats the problem of unsupervised learning as one of density estimation. The idea is that a good model will not be “surprised” by actual data samples (i.e., will assign them high probability). Furthermore, since probabilities must sum to 1.0, if the model assigns high probability to regions of data space where the data samples come from, it implicitly assigns low probability to the regions where the data does not come from. Thus the model has learned to capture the typical patterns in the data. This can be used inside of a data compression algorithm.

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

![](images/1de9c581ac6704b47e5061727c621f1154d05c108c2a22d4924a4bc0b5ff0bd2.jpg)  
Figure 1.10: Examples of some control problems. (a) Space Invaders Atari game. From https: // gym. openai. com/ envs/ SpaceInvaders-v0/ . (b) Controlling a humanoid robot in the MuJuCo simulator so it walks as fast as possible without falling over. From https: // gym. openai. com/ envs/ Humanoid-v2/ .

Unfortunately, density estimation is difficult, especially in high dimensions. Furthermore, a model that assigns high probability to the data may not have learned useful high-level patterns (after all, the model could just memorize all the training examples).

An alternative evaluation metric is to use the learned unsupervised representation as features or input to a downstream supervised learning method. If the unsupervised method has discovered useful patterns, then it should be possible to use these patterns to perform supervised learning using much less labeled data than when working with the original features. For example, in Section 1.2.1.1, we saw how the 4 manually defined features of iris flowers contained most of the information needed to perform classification. We were thus able to train a classifier with nearly perfect performance using just 150 examples. If the input was raw pixels, we would need many more examples to achieve comparable performance (see Section 14.1). That is, we can increase the sample efficiency of learning (i.e., reduce the number of labeled examples needed to get good performance) by first learning a good representation.

Increased sample efficiency is a useful evaluation metric, but in many applications, especially in science, the goal of unsupervised learning is to gain understanding, not to improve performance on some prediction task. This requires the use of models that are interpretable, but which can also generate or “explain” most of the observed patterns in the data. To paraphrase Plato, the goal is to discover how to “carve nature at its joints”. Of course, evaluating whether we have successfully discovered the true underlying structure behind some dataset often requires performing experiments and thus interacting with the world. We discuss this topic further in Section 1.4.

# 1.4 Reinforcement learning

In addition to supervised and unsupervised learning, there is a third kind of ML known as reinforcement learning (RL). In this class of problems, the system or agent has to learn how to interact with its environment. This can be encoded by means of a policy $\pmb { a } = \pi ( \pmb { x } )$ , which specifies which action to take in response to each possible input $_ { x }$ (derived from the environment state).

For example, consider an agent that learns to play a video game, such as Atari Space Invaders (see

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

"Pure" Reinforcement Learning (cherry) >The machine predicts a scalar reward given once ina while A fewbits forsome samples   
Supervised Learning (icing) The machine predicts a category orafewnumbers foreach input ■Predicting human-supplied data >10→10,000 bits per sample   
Unsupervised/Predictive Learning (cake) $\blacktriangleright$ The machine predicts any part of its input for any observed part. H ?Predicts future frames in videos Millionsofbits persample

Figure 1.10a). In this case, the input $_ { x }$ is the image (or sequence of past images), and the output $\textbf { \em a }$ is the direction to move in (left or right) and whether to fire a missile or not. As a more complex example, consider the problem of a robot learning to walk (see Figure 1.10b). In this case, the input $_ { x }$ is the set of joint positions and angles for all the limbs, and the output $\textbf { \em a }$ is a set of actuation or motor control signals.

The difference from supervised learning (SL) is that the system is not told which action is the best one to take (i.e., which output to produce for a given input). Instead, the system just receives an occasional reward (or punishment) signal in response to the actions that it takes. This is like learning with a critic, who gives an occasional thumbs up or thumbs down, as opposed to learning with a teacher, who tells you what to do at each step.

RL has grown in popularity recently, due to its broad applicability (since the reward signal that the agent is trying to optimize can be any metric of interest). However, it can be harder to make RL work than it is for supervised or unsupervised learning, for a variety of reasons. A key difficulty is that the reward signal may only be given occasionally (e.g., if the agent eventually reaches a desired state), and even then it may be unclear to the agent which of its many actions were responsible for getting the reward. (Think of playing a game like chess, where there is a single win or lose signal at the end of the game.)

To compensate for the minimal amount of information coming from the reward signal, it is common to use other information sources, such as expert demonstrations, which can be used in a supervised way, or unlabeled data, which can be used by an unsupervised learning system to discover the underlying structure of the environment. This can make it feasible to learn from a limited number of trials (interactions with the environment). As Yann LeCun put it, in an invited talk at the NIPS8 conference in 2016: “If intelligence was a cake, unsupervised learning would be the chocolate sponge, supervised learning would be the icing, and reinforcement learning would be the cherry.” This is illustrated in Figure 1.11.

![](images/d116e6074b9f73264279bece02e607adba139c75ddf357c54e007f51574fe3ed.jpg)  
Figure 1.12: (a) Visualization of the MNIST dataset. Each image is $2 8 \times 2 8$ . There are 60k training examples and 10k test examples. We show the first 25 images from the training set. Generated by mnist_viz_tf.ipynb. (b) Visualization of the EMNIST dataset. There are 697,932 training examples, and 116,323 test examples, each of size $2 8 \times 2 8$ . There are 62 classes (a-z, A-Z, 0-9). We show the first 25 images from the training set. Generated by emnist_viz_jax.ipynb.

More information on RL can be found in the sequel to this book, [Mur23].

# 1.5 Data

Machine learning is concerned with fitting models to data using various algorithms. Although we focus on the modeling and algorithm aspects, it is important to mention that the nature and quality of the training data also plays a vital role in the success of any learned model.

In this section, we briefly describe some common image and text datasets that we will use in this book. We also briefly discuss the topic of data preprocessing.

# 1.5.1 Some common image datasets

In this section, we briefly discuss some image datasets that we will use in this book.

# 1.5.1.1 Small image datasets

One of the simplest and most widely used is known as MNIST [LeC+98; YB19].9 This is a dataset of 60k training images and 10k test images, each of size $2 8 \times 2 8$ (grayscale), illustrating handwritten digits from 10 categories. Each pixel is an integer in the range $\{ 0 , 1 , \ldots , 2 5 5 \}$ ; these are usually rescaled to $[ 0 , 1 ]$ , to represent pixel intensity. We can optionally convert this to a binary image by thresholding. See Figure 1.12a for an illustration.

![](images/7adf00811b1aae1f9fdcd2d3be8502778a275a31c9369a166adc882f144bd1ae.jpg)  
Figure 1.13: (a) Visualization of the Fashion-MNIST dataset [XRV17]. The dataset has the same size as MNIST, but is harder to classify. There are 10 classes: T-shirt/top, Trouser, Pullover, Dress, Coat, Sandal, Shirt, Sneaker, Bag, Ankle-boot. We show the first 25 images from the training set. Generated by fashion_viz_tf.ipynb. (b) Some images from the CIFAR-10 dataset [KH09]. Each image is $3 2 \times 3 2 \times 3$ , where the final dimension of size 3 refers to RGB. There are 50k training examples and 10k test examples. There are 10 classes: plane, car, bird, cat, deer, dog, frog, horse, ship, and truck. We show the first 25 images from the training set. Generated by cifar_viz_tf.ipynb.

MNIST is so widely used in the ML community that Geoff Hinton, a famous ML researcher, has called it the “drosophila of machine learning”, since if we cannot make a method work well on MNIST, it will likely not work well on harder datasets. However, nowadays MNIST classification is considered “too easy”, since it is possible to distinguish most pairs of digits by looking at just a single pixel. Various extensions have been proposed.

In [Coh+17], they proposed EMNIST (extended MNIST), that also includes lower and upper case letters. See Figure 1.12b for a visualization. This dataset is much harder than MNIST, since there are 62 classes, several of which are quite ambiguous (e.g., the digit 1 vs the lower case letter l).

In [XRV17], they proposed Fashion-MNIST, which has exactly the same size and shape as MNIST, but where each image is the picture of a piece of clothing instead of a handwritten digit. See Figure 1.13a for a visualization.

For small color images, the most common dataset is CIFAR [KH09].10 This is a dataset of $6 0 k$ images, each of size $3 2 \times 3 2 \times 3$ , representing everyday objects from 10 or 100 classes; see Figure 1.13b for an illustration.11

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

![](images/46ec436c176dd2a1196116620a0e5d0d29ea5526987257399fcd4b7daf05e233.jpg)  
Figure 1.14: (a) Sample images from the ImageNet dataset [Rus+15]. This subset consists of 1.3M color training images, each of which is $2 5 6 \times 2 5 6$ pixels in size. There are 1000 possible labels, one per image, and the task is to minimize the top-5 error rate, i.e., to ensure the correct label is within the 5 most probable predictions. Below each image we show the true label, and a distribution over the top 5 predicted labels. If the true label is in the top 5, its probability bar is colored red. Predictions are generated by a convolutional neural network (CNN) called “AlexNet” (Section 14.3.2). From Figure 4 of [KSH12]. Used with kind permission of Alex Krizhevsky. (b) Misclassification rate (top 5) on the ImageNet competition over time. Used with kind permission of Andrej Karpathy.

# 1.5.1.2 ImageNet

Small datasets are useful for prototyping ideas, but it is also important to test methods on larger datasets, both in terms of image size and number of labeled examples. The most widely used dataset of this type is called ImageNet [Rus+15]. This is a dataset of $\sim 1 4 M$ images of size $2 5 6 \times 2 5 6 \times 3$ illustrating various objects from 20,000 classes; see Figure 1.14a for some examples.

The ImageNet dataset was used as the basis of the ImageNet Large Scale Visual Recognition Challenge (ILSVRC), which ran from 2010 to 2018. This used a subset of 1.3M images from 1000 classes. During the course of the competition, significant progress was made by the community, as shown in Figure 1.14b. In particular, 2015 marked the first year in which CNNs could outperform humans (or at least one human, namely Andrej Karpathy) at the task of classifying images from ImageNet. Note that this does not mean that CNNs are better at vision than humans (see e.g., [YL21] for some common failure modes). Instead, it mostly likely reflects the fact that the dataset makes many fine-grained classification distinctions — such as between a “tiger” and a “tiger cat” — that humans find difficult to understand; by contrast, sufficiently flexible CNNs can learn arbitrary patterns, including random labels [Zha+17a].

<html><body><table><tr><td>1.this film wasjust briliant casting locationscenerystory directioneveryone'sreallysuited thepartthey played robert <UNK> isanamazing actor...</td></tr><tr><td>2.big hairbig boobs bad musicandagiantsafetypintheseare the wordsto bestdescribethis terible movieilovecheesy</td></tr><tr><td>horror movies and i've seen hundreds...</td></tr></table></body></html>

Table 1.3: We show snippets of the first two sentences from the IMDB movie review dataset. The first example is labeled positive and the second negative. (<UNK> refers to an unknown token.)

Although ImageNet is much harder than MNIST and CIFAR as a classification benchmark, it too is almost “saturated” [Bey+20]. Nevertheless, relative performance of methods on ImageNet is often a surprisingly good predictor of performance on other, unrelated image classification tasks (see e.g., [Rec+19]), so it remains very widely used.

# 1.5.2 Some common text datasets

Machine learning is often applied to text to solve a variety of tasks. This is known as natural language processing or NLP (see e.g., [JM20] for details). Below we briefly mention a few text datasets that we will use in this book.

# 1.5.2.1 Text classification

A simple NLP task is text classification, which can be used for email spam classification, sentiment analysis (e.g., is a movie or product review positive or negative), etc. A common dataset for evaluating such methods is the IMDB movie review dataset from [Maa+11]. (IMDB stands for “Internet Movie Database”.) This contains 25k labeled examples for training, and 25k for testing. Each example has a binary label, representing a positive or negative rating. See Table 1.3 for some example sentences.

# 1.5.2.2 Machine translation

A more difficult NLP task is to learn to map a sentence $_ { x }$ in one language to a “semantically equivalent” sentence $\textbf {  { y } }$ in another language; this is called machine translation. Training such models requires aligned $( { \pmb x } , { \pmb y } )$ pairs. Fortunately, several such datasets exist, e.g., from the Canadian parliament (English-French pairs), and the European Union (Europarl). A subset of the latter, known as the WMT dataset (Workshop on Machine Translation), consists of English-German pairs, and is widely used as a benchmark dataset.

# 1.5.2.3 Other seq2seq tasks

A generalization of machine translation is to learn a mapping from one sequence $_ { x }$ to any other sequence $\mathbf { \Delta } _ { \mathbf { \mathcal { S } } }$ . This is called a seq2seq model, and can be viewed as a form of high-dimensional classification (see Section 15.2.3 for details). This framing of the problem is very general, and includes many tasks, such as document summarization, question answering, etc. For example, Table 1.4 shows how to formulate question answering as a seq2seq problem: the input is the text T

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

T: In meteorology, precipitation is any product of the condensation of atmospheric water vapor that falls under gravity. The main forms of precipitation include drizzle, rain, sleet, snow, graupel and hail... Precipitation forms as smaller droplets coalesce via collision with other rain drops or ice crystals within a cloud. Short, intense periods of rain in scattered locations are called “showers”.

Q1: What causes precipitation to fall? A1: gravity Q2: What is another main form of precipitation besides drizzle, rain, snow, sleet and hail? A2: graupel Q3: Where do water droplets collide with ice crystals to form precipitation? A3: within a cloud

Table 1.4: Question-answer pairs for a sample passage in the SQuAD dataset. Each of the answers is a segment of text from the passage. This can be solved using sentence pair tagging. The input is the paragraph text $T$ and the question Q. The output is a tagging of the relevant words in T that answer the question in $Q$ . From Figure 1 of [Raj+16]. Used with kind permission of Percy Liang.

and question Q, and the output is the answer A, which is a set of words, possibly extracted from the input.

# 1.5.2.4 Language modeling

The rather grandiose term “language modeling” refers to the task of creating unconditional generative models of text sequences, $p ( x _ { 1 } , \dots , x _ { T } )$ . This only requires input sentences $_ { x }$ , without any corresponding “labels” $\pmb { y }$ . We can therefore think of this as a form of unsupervised learning, which we discuss in Section 1.3. If the language model generates output in response to an input, as in seq2seq, we can regard it as a conditional generative model.

# 1.5.3 Preprocessing discrete input data

Many ML models assume that the data consists of real-valued feature vectors, $\pmb { x } \in \mathbb { R } ^ { D }$ . However, sometimes the input may have discrete input features, such as categorical variables like race and gender, or words from some vocabulary. In the sections below, we discuss some ways to preprocess such data to convert it to vector form. This is a common operation that is used for many different kinds of models.

# 1.5.3.1 One-hot encoding

When we have categorical features, we need to convert them to a numerical scale, so that computing weighted combinations of the inputs makes sense. The standard way to preprocess such categorical variables is to use a one-hot encoding, also called a dummy encoding. If a variable $x$ has $K$ values, we will denote its dummy encoding as follows: o $\operatorname { n e - h o t } ( x ) = [ \mathbb { I } \left( x = 1 \right) , \dots , \mathbb { I } \left( x = K \right) ]$ . For example, if there are 3 colors (say red, green and blue), the corresponding one-hot vectors will be one- $\mathrm { h o t } ( \mathrm { r e d } ) = [ 1 , 0 , 0 ]$ , one- $\mathrm { h o t } ( \mathrm { g r e e n } ) = [ 0 , 1 , 0 ]$ , and one- $\mathrm { h o t } ( \mathrm { b l u e } ) = [ 0 , 0 , 1 ]$ .

# 1.5.3.2 Feature crosses

A linear model using a dummy encoding for each categorical variable can capture the main effects of each variable, but cannot capture interaction effects between them. For example, suppose we

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

want to predict the fuel efficiency of a vehicle given two categorical input variables: the type (say SUV, Truck, or Family car), and the country of origin (say USA or Japan). If we concatenate the one-hot encodings for the ternary and binary features, we get the following input encoding:

$$
{ \phi } ( { \pmb x } ) = \left[ 1 , \mathbb { I } \left( { \boldsymbol x } _ { 1 } = { \boldsymbol S } \right) , \mathbb { I } \left( { \boldsymbol x } _ { 1 } = T \right) , \mathbb { I } \left( { \boldsymbol x } _ { 1 } = { \boldsymbol F } \right) , \mathbb { I } \left( { \boldsymbol x } _ { 2 } = U \right) , \mathbb { I } \left( { \boldsymbol x } _ { 2 } = J \right) \right]
$$

where $x _ { 1 }$ is the type and $x _ { 2 }$ is the country of origin.

This model cannot capture dependencies between the features. For example, we expect trucks to be less fuel efficient, but perhaps trucks from the USA are even less efficient than trucks from Japan. This cannot be captured using the linear model in Equation (1.34) since the contribution from the country of origin is independent of the car type.

We can fix this by computing explicit feature crosses. For example, we can define a new composite feature with $3 \times 2$ possible values, to capture the interaction of type and country of origin. The new model becomes

$$
{ \begin{array} { r l } & { x ; w ) = w ^ { \mathsf { T } } \phi ( x ) } \\ & { \qquad = w _ { 0 } + w _ { 1 } \mathbb { I } \left( x _ { 1 } = S \right) + w _ { 2 } \mathbb { I } \left( x _ { 1 } = T \right) + w _ { 3 } \mathbb { I } \left( x _ { 1 } = F \right) } \\ & { \qquad + w _ { 4 } \mathbb { I } \left( x _ { 2 } = U \right) + w _ { 5 } \mathbb { I } \left( x _ { 2 } = J \right) } \\ & { \qquad + w _ { 6 } \mathbb { I } \left( x _ { 1 } = S , x _ { 2 } = U \right) + w _ { 7 } \mathbb { I } \left( x _ { 1 } = T , x _ { 2 } = U \right) + w _ { 8 } \mathbb { I } \left( x _ { 1 } = F , x _ { 2 } = U \right) } \\ & { \qquad + w _ { 9 } \mathbb { I } \left( x _ { 1 } = S , x _ { 2 } = J \right) + w _ { 1 0 } \mathbb { I } \left( x _ { 1 } = T , x _ { 2 } = J \right) + w _ { 1 1 } \mathbb { I } \left( x _ { 1 } = F , x _ { 2 } = J \right) } \end{array} }
$$

We can see that the use of feature crosses converts the original dataset into a wide format, with many more columns.

# 1.5.4 Preprocessing text data

In Section 1.5.2, we briefly discussed text classification and other NLP tasks. To feed text data into a classifier, we need to tackle various issues. First, documents have a variable length, and are thus not fixed-length feature vectors, as assumed by many kinds of models. Second, words are categorical variables with many possible values (equal to the size of the vocabulary), so the corresponding one-hot encodings will be very high-dimensional, with no natural notion of similarity. Third, we may encounter words at test time that have not been seen during training (so-called out-of-vocabulary or OOV words). We discuss some solutions to these problems below. More details can be found in e.g., [BKL10; MRS08; JM20].

# 1.5.4.1 Bag of words model

A simple approach to dealing with variable-length text documents is to interpret them as a bag of words, in which we ignore word order. To convert this to a vector from a fixed input space, we first map each word to a token from some vocabulary.

To reduce the number of tokens, we often use various pre-processing techniques such as the following: dropping punctuation, converting all words to lower case; dropping common but uninformative words, such as “and” and “the” (this is called stop word removal); replacing words with their base form, such as replacing “running” and “runs” with “run” (this is called word stemming); etc. For details, see e.g., [BL12], and for some sample code, see text_preproc_jax.ipynb.

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

![](images/084834a731c451a7030347eda840b88c95a43b448a33945a38923238443008a3.jpg)  
Figure 1.15: Example of a term-document matrix, where raw counts have been replaced by their TF-IDF values (see Section 1.5.4.2). Darker cells are larger values. From https: // bit. ly/ 2kByLQI . Used with kind permission of Christoph Carl Kling.

Let $x _ { n t }$ be the token at location $t$ in the $n$ ’th document. If there are $D$ unique tokens in the vocabulary, then we can represent the $n$ ’th document as a $D$ -dimensional vector $\scriptstyle { \dot { \mathbf { x } } } _ { n }$ , where $\widetilde { x } _ { n v }$ is the number of times that word $v$ occurs in document $n$ :

$$
\tilde { x } _ { n v } = \sum _ { t = 1 } ^ { T } \mathbb { I } \left( x _ { n t } = v \right)
$$

where $T$ is the length of document $n$ . We can now interpret documents as vectors in $\mathbb { R } ^ { D }$ . This is called the vector space model of text [SWY75; TP10].

We traditionally store input data in an $N \times D$ design matrix denoted by $\mathbf { X }$ , where $D$ is the number of features. In the context of vector space models, it is more common to represent the input data as a $D \times N$ term frequency matrix, where $\mathrm { T F } _ { i j }$ is the frequency of term $i$ in document $j$ . See Figure 1.15 for an illustration.

# 1.5.4.2 TF-IDF

One problem with representing documents as word count vectors is that frequent words may have undue influence, just because the magnitude of their word count is higher, even if they do not carry much semantic content. A common solution to this is to transform the counts by taking logs, which reduces the impact of words that occur many times within a single document.

To reduce the impact of words that occur many times in general (across all documents), we compute a quantity called the inverse document frequency, defined as follows: $\begin{array} { r } { { \mathrm { I D F } } _ { i } \triangleq \log \frac { N } { 1 + { \mathrm { D F } } _ { i } } } \end{array}$ , where DF is the number of documents with term $i$ . We can combine these transformations to compute the $_ i$ TF-IDF matrix as follows:

$$
\mathrm { T F I D F } _ { i j } = \log ( \mathrm { T F } _ { i j } + 1 ) \times \mathrm { I D F } _ { i }
$$

(We often normalize each row as well.) This provides a more meaningful representation of documents, and can be used as input to many ML algorithms. See tfidf_demo.ipynb for an example.

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

# 1.5.4.3 Word embeddings

Although the TF-IDF transformation improves on raw count vectors by placing more weight on “informative” words and less on “uninformative” words, it does not solve the fundamental problem with the one-hot encoding (from which count vectors are derived), which is that that semantically similar words, such as “man” and “woman”, may be not be any closer (in vector space) than semantically dissimilar words, such as “man” and “banana”. Thus the assumption that points that are close in input space should have similar outputs, which is implicitly made by most prediction models, is invalid.

The standard way to solve this problem is to use word embeddings, in which we map each sparse one-hot vector, ${ \pmb x } _ { n t } \in \{ 0 , 1 \} ^ { V }$ , to a lower-dimensional dense vector, $\boldsymbol { e } _ { n t } \in \mathbb { R } ^ { K }$ using $e _ { n t } = \mathbf { E } x _ { n t }$ , where $\mathbf { E } \in \mathbb { R } ^ { K \times V }$ is learned such that semantically similar words are placed close by. There are many ways to learn such embeddings, as we discuss in Section 20.5.

Once we have an embedding matrix, we can represent a variable-length text document as a bag of word embeddings. We can then convert this to a fixed length vector by summing (or averaging) the embeddings:

$$
\overline { { \boldsymbol { e } } } _ { n } = \sum _ { t = 1 } ^ { T } \boldsymbol { e } _ { n t } = \mathbf { E } \tilde { \boldsymbol { x } } _ { n }
$$

where $\tilde { \mathbf { x } } _ { n }$ is the bag of words representation from Equation (1.37). We can then use this inside of a logistic regression classifier, which we briefly introduced in Section 1.2.1.5. The overall model has the form

$$
p ( y = c | \pmb { x } _ { n } , \pmb { \theta } ) = \mathrm { s o f t m a x } _ { c } ( \mathbf { W } \mathbf { E } \tilde { \pmb { x } } _ { n } )
$$

We often use a pre-trained word embedding matrix $\mathbf { E }$ , in which case the model is linear in $\mathbf { W }$ , which simplifies parameter estimation (see Chapter 10). See also Section 15.7 for a discussion of contextual word embeddings.

# 1.5.4.4 Dealing with novel words

At test time, the model may encounter a completely novel word that it has not seen before. This is known as the out of vocabulary or OOV problem. Such novel words are bound to occur, because the set of words is an open class. For example, the set of proper nouns (names of people and places) is unbounded.

A standard heuristic to solve this problem is to replace all novel words with the special symbol UNK, which stands for “unknown”. However, this loses information. For example, if we encounter the word “athazagoraphobia”, we may guess it means “fear of something”, since phobia is a common suffix in English (derived from Greek) to mean “fear of”. (It turns out that athazagoraphobia means “fear of being forgotten about or ignored”.)

We could work at the character level, but this would require the model to learn how to group common letter combinations together into words. It is better to leverage the fact that words have substructure, and then to take as input subword units or wordpieces [SHB16; Wu+16]; these are often created using a method called byte-pair encoding [Gag94], which is a form of data compression that creates new symbols to represent common substrings.

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

# 1.5.5 Handling missing data

Sometimes we may have missing data, in which parts of the input $_ { x }$ or output $y$ may be unknown. If the output is unknown during training, the example is unlabeled; we consider such semi-supervised learning scenarios in Section 19.3. We therefore focus on the case where some of the input features may be missing, either at training or testing time, or both.

To model this, let M be an $N \times D$ matrix of binary variables, where $M _ { n d } = 1$ if feature $d$ in example $n$ is missing, and $M _ { n d } = 0$ otherwise. Let $\mathbf { X } _ { v }$ be the visible parts of the input feature matrix, corresponding to $M _ { n d } = 0$ , and $\mathbf { X } _ { h }$ be the missing parts, corresponding to $M _ { n d } = 1$ . Let $\mathbf { Y }$ be the output label matrix, which we assume is fully observed. If we assume $p ( \mathbf { M } | \mathbf { X } _ { v } , \mathbf { X } _ { h } , \mathbf { Y } ) = p ( \mathbf { M } )$ , we say the data is missing completely at random or MCAR, since the missingness does not depend on the hidden or observed features. If we assume $p ( \mathbf { M } | \mathbf { X } _ { v } , \mathbf { X } _ { h } , \mathbf { Y } ) = p ( \mathbf { M } | \mathbf { X } _ { v } , \mathbf { Y } )$ , we say the data is missing at random or MAR, since the missingness does not depend on the hidden features, but may depend on the visible features. If neither of these assumptions hold, we say the data is not missing at random or NMAR.

In the MCAR and MAR cases, we can ignore the missingness mechanism, since it tells us nothing about the hidden features. However, in the NMAR case, we need to model the missing data mechanism, since the lack of information may be informative. For example, the fact that someone did not fill out an answer to a sensitive question on a survey (e.g., “Do you have COVID?”) could be informative about the underlying value. See e.g., [LR87; Mar08] for more information on missing data models.

In this book, we will always make the MAR assumption. However, even with this assumption, we cannot directly use a discriminative model, such as a DNN, when we have missing input features, since the input $_ { x }$ will have some unknown values.

A common heuristic is called mean value imputation, in which missing values are replaced by their empirical mean. More generally, we can fit a generative model to the input, and use that to fill in the missing values. We briefly discuss some suitable generative models for this task in Chapter 20, and in more detail in the sequel to this book, [Mur23].

# 1.6 Discussion

In this section, we situate ML and this book into a larger context.

# 1.6.1 The relationship between ML and other fields

There are several subcommunities that work on ML-related topics, each of which have different names. The field of predictive analytics is similar to supervised learning (in particular, classification and regression), but focuses more on business applications. Data mining covers both supervised and unsupervised machine learning, but focuses more on structured data, usually stored in large commercial databases. Data science uses techniques from machine learning and statistics, but also emphasizes other topics, such as data integration, data visualization, and working with domain experts, often in an iterative feedback loop (see e.g., [BS17]). The difference between these areas is often just one of terminology.12

ML is also very closely related to the field of statistics. Indeed, Jerry Friedman, a famous statistics professor at Stanford, said $^ { 1 3 }$

[If the statistics field had] incorporated computing methodology from its inception as a fundamental tool, as opposed to simply a convenient way to apply our existing tools, many of the other data related fields [such as ML] would not have needed to exist — they would have been part of statistics. — Jerry Friedman [Fri97b]

Machine learning is also related to artificial intelligence (AI). Historically, the field of AI assumed that we could program “intelligence” by hand (see e.g., [RN10; PM17]), but this approach has largely failed to live up to expectations, mostly because it proved to be too hard to explicitly encode all the knowledge such systems need. Consequently, there is renewed interest in using ML to help an AI system acquire its own knowledge. (Indeed the connections are so close that sometimes the terms “ML” and “AI” are used interchangeably, although this is arguably misleading [Pre21].)

# 1.6.2 Structure of the book

We have seen that ML is closely related to many other subjects in mathematics, statistics, computer science, etc. It can be hard to know where to start.

In this book, we take one particular path through this interconnected landscape, using probability theory as our unifying lens. We cover statistical foundations in Part I, supervised learning in Part II–Part IV, and unsupervised learning in Part V. For more information on these (and other) topics, please see the sequel to this book, [Mur23],

In addition to the book, you may find the online Python notebooks that accompany this book helpful. See probml.github.io/book1 for details.

# 1.6.3 Caveats

In this book, we will see how machine learning can be used to create systems that can (attempt to) predict outputs given inputs. These predictions can then be used to choose actions so as to minimize expected loss. When designing such systems, it can be hard to design a loss function that correctly specifies all of our preferences; this can result in “reward hacking” in which the machine optimizes the reward function we give it, but then we realize that the function did not capture various constraints or preferences that we forgot to specify [Wei76; Amo+16; D’A+20]. (This is particularly important when tradeoffs need to be made between multiple objectives.)

Reward hacking is an example of a larger problem known as the “alignment problem” [Chr20], which refers to the potential discrepancy between what we ask our algorithms to optimize and what we actually want them to do for us; this has raised various concerns in the context of AI ethics and AI safety (see e.g., [KR19; Lia20]). Russell [Rus19] proposes to solve this problem by not explicitly specifying a reward function, but instead forcing the machine to infer the reward by observing human behavior, an approach known as inverse reinforcement learning. However, emulating current or past human behavior too closely may be undesirable, and can be biased by the data that is available for training (see e.g., [Pau+20]).

The above view of AI, in which an “intelligent” system makes decisions on its own, without a human in the loop, is believed by many to be the path towards “artificial general intelligence”

or AGI. An alternative approach is to view AI as “augmented intelligence” (sometimes called intelligence augmentation or IA). In this paradigm, AI is a process for creating “smart tools”, like adaptive cruise control or auto-complete in search engines; such tools maintain a human in the decision-making loop. In this framing, systems which have AI/ML components in them are not that different from other complex, semi-autonomous human artefacts, such as aeroplanes with autopilot, online trading platforms or medical diagnostic systems (c.f. [Jor19; Ace]). Of course, as the AI tools becomes more powerful, they can end up doing more and more on their own, making this approach similar to AGI. However, in augmented intelligence, the goal is not to emulate or exceed human behavior at certain tasks, but instead to help humans get stuff done more easily; this is how we treat most other technologies [Kap16].

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

# Part I

# Foundations

# 2 Probability: Univariate Models

# 2.1 Introduction

In this chapter, we give a brief introduction to the basics of probability theory. There are many good books that go into more detail, e.g., [GS97; BT08].

# 2.1.1 What is probability?

Probability theory is nothing but common sense reduced to calculation. — Pierre Laplace, 1812

We are all comfortable saying that the probability that a (fair) coin will land heads is $5 0 \%$ . But what does this mean? There are actually two different interpretations of probability. One is called the frequentist interpretation. In this view, probabilities represent long run frequencies of events that can happen multiple times. For example, the above statement means that, if we flip the coin many times, we expect it to land heads about half the time.1

The other interpretation is called the Bayesian interpretation of probability. In this view, probability is used to quantify our uncertainty or ignorance about something; hence it is fundamentally related to information rather than repeated trials [Jay03; Lin06]. In the Bayesian view, the above statement means we believe the coin is equally likely to land heads or tails on the next toss.

One big advantage of the Bayesian interpretation is that it can be used to model our uncertainty about one-off events that do not have long term frequencies. For example, we might want to compute the probability that the polar ice cap will melt by 2030 CE. This event will happen zero or one times, but cannot happen repeatedly. Nevertheless, we ought to be able to quantify our uncertainty about this event; based on how probable we think this event is, we can decide how to take the optimal action, as discussed in Chapter 5. We shall therefore adopt the Bayesian interpretation in this book. Fortunately, the basic rules of probability theory are the same, no matter which interpretation is adopted.

# 2.1.2 Types of uncertainty

The uncertainty in our predictions can arise for two fundamentally different reasons. The first is due to our ignorance of the underlying hidden causes or mechanism generating our data. This is called epistemic uncertainty, since epistemology is the philosophical term used to describe the study of knowledge. However, a simpler term for this is model uncertainty. The second kind of uncertainty arises from intrinsic variability, which cannot be reduced even if we collect more data. This is sometimes called aleatoric uncertainty [Hac75; KD09], derived from the Latin word for “dice”, although a simpler term would be data uncertainty. As a concrete example, consider tossing a fair coin. We might know for sure that the probability of heads is $p = 0 . 5$ , so there is no epistemic uncertainty, but we still cannot perfectly predict the outcome.

This distinction can be important for applications such as active learning. A typical strategy is to query examples for which $\mathbb { H } ( p ( \boldsymbol { y } | \boldsymbol { x } , \mathcal { D } ) )$ is large (where $\mathbb H ( p )$ is the entropy, discussed in Section 6.1). However, this could be due to uncertainty about the parameters, i.e., large $\mathbb { H } ( p ( \pmb { \theta } | \mathcal { D } ) )$ , or just due to inherent variability of the outcome, corresponding to large entropy of $p ( \boldsymbol { y } | \boldsymbol { \mathbf { x } } , \boldsymbol { \theta } )$ . In the latter case, there would not be much use collecting more samples, since our epistemic uncertainty would not be reduced. See [Osb16] for further discussion of this point.

# 2.1.3 Probability as an extension of logic

In this section, we review the basic rules of probability, following the presentation of [Jay03], in which we view probability as an extension of Boolean logic.

# 2.1.3.1 Probability of an event

We define an event, denoted by the binary variable $A$ , as some state of the world that either holds or does not hold. For example, $A$ might be event “it will rain tomorrow”, or “it rained yesterday”, or “the label is $y = 1 ^ { \gamma }$ , or “the parameter $\theta$ is between 1.5 and 2.0”, etc. The expression $\operatorname* { P r } ( A )$ denotes the probability with which you believe event $A$ is true (or the long run fraction of times that $A$ will occur). We require that $0 \leq \operatorname* { P r } ( A ) \leq 1$ , where $\operatorname* { P r } ( A ) = 0$ means the event definitely will not happen, and $\operatorname* { P r } ( A ) = 1$ means the event definitely will happen. We write $\operatorname* { P r } ( { \overline { { A } } } )$ to denote the probability of event $A$ not happening; this is defined to be $\operatorname* { P r } ( \ b { A } ) = 1 - \operatorname* { P r } ( \ b { A } )$ .

# 2.1.3.2 Probability of a conjunction of two events

We denote the joint probability of events $A$ and $B$ both happening as follows:

$$
\operatorname* { P r } ( A \land B ) = \operatorname* { P r } ( A , B )
$$

If $A$ and $B$ are independent events, we have

$$
\operatorname* { P r } ( A , B ) = \operatorname* { P r } ( A ) \operatorname* { P r } ( B )
$$

For example, suppose $X$ and $Y$ are chosen uniformly at random from the set $\mathcal { X } = \{ 1 , 2 , 3 , 4 \}$ . Let $A$ be the event that $X \in \{ 1 , 2 \}$ , and $B$ be the event that $Y \in \{ 3 \}$ . Then we have $\operatorname* { P r } ( A , B ) =$ $\operatorname* { P r } ( A ) \operatorname* { P r } ( B ) = { \frac { 1 } { 2 } } \cdot { \frac { 1 } { 4 } } $ .

# 2.1.3.3 Probability of a union of two events

The probability of event $A$ or $B$ happening is given by

$$
\operatorname* { P r } ( A \lor B ) = \operatorname* { P r } ( A ) + \operatorname* { P r } ( B ) - \operatorname* { P r } ( A \land B )
$$

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

If the events are mutually exclusive (so they cannot happen at the same time), we get

$$
\operatorname* { P r } ( A \lor B ) = \operatorname* { P r } ( A ) + \operatorname* { P r } ( B )
$$

For example, suppose $X$ is chosen uniformly at random from the set $\mathcal { X } = \{ 1 , 2 , 3 , 4 \}$ . Let $A$ be the event that $X \in \{ 1 , 2 \}$ and $B$ be the event that $X \in \{ 3 \}$ . Then we have $\textstyle \operatorname* { P r } ( A \vee B ) = { \frac { 2 } { 4 } } + { \frac { 1 } { 4 } }$ .

2.1.3.4 Conditional probability of one event given another

We define the conditional probability of event $B$ happening given that $A$ has occurred as follows:

$$
\operatorname* { P r } ( B | A ) \triangleq { \frac { \operatorname* { P r } ( A , B ) } { \operatorname* { P r } ( A ) } }
$$

This is not defined if $\Pr ( A ) = 0$ , since we cannot condition on an impossible event.

# 2.1.3.5 Independence of events

We say that event $A$ is independent of event $B$ if

$$
\operatorname* { P r } ( A , B ) = \operatorname* { P r } ( A ) \operatorname* { P r } ( B )
$$

# 2.1.3.6 Conditional independence of events

We say that events $A$ and $B$ are conditionally independent given event $C$ if

$$
\operatorname* { P r } ( A , B | C ) = \operatorname* { P r } ( A | C ) \operatorname* { P r } ( B | C )
$$

This is written as $A \perp B | C$ . Events are often dependent on each other, but may be rendered independent if we condition on the relevant intermediate variables, as we discuss in more detail later in this chapter.

# 2.2 Random variables

Suppose $X$ represents some unknown quantity of interest, such as which way a dice will land when we roll it, or the temperature outside your house at the current time. If the value of $X$ is unknown and/or could change, we call it a random variable or rv. The set of possible values, denoted $\mathcal { X }$ , is known as the sample space or state space. An event is a set of outcomes from a given sample space. For example, if $X$ represents the face of a dice that is rolled, so $\mathcal { X } = \{ 1 , 2 , \ldots , 6 \}$ , the event of “seeing a $1 ^ { \circ }$ is denoted $X = 1$ , the event of “seeing an odd number” is denoted $X \in \{ 1 , 3 , 5 \}$ , the event of “seeing a number between 1 and $3 ^ { \circ }$ is denoted $1 \leq X \leq 3$ , etc.

# 2.2.1 Discrete random variables

If the sample space $\mathcal { X }$ is finite or countably infinite, then $X$ is called a discrete random variable. In this case, we denote the probability of the event that $X$ has value $x$ by $\operatorname* { P r } ( X = x )$ . We define the

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

![](images/67ddd30917017417596e59ae32dd6dbf19072b4c87bb22f788fbeb4e2fccf318.jpg)  
Figure 2.1: Some discrete distributions on the state space $\mathcal { X } = \{ 1 , 2 , 3 , 4 \}$ . (a) $A$ uniform distribution with $p ( x = k ) = 1 / 4$ . (b) $A$ degenerate distribution (delta function) that puts all its mass on $x = 1$ . Generated by discrete_prob_dist_plot.ipynb.

probability mass function or pmf as a function which computes the probability of events which correspond to setting the rv to each possible value:

$$
p ( x ) \triangleq \operatorname* { P r } ( X = x )
$$

The pmf satisfies the properties $0 \leq p ( x ) \leq 1$ and $\begin{array} { r } { \sum _ { x \in \mathcal { X } } p ( x ) = 1 } \end{array}$ .

If $X$ has a finite number of values, say $K$ , the pmf can be represented as a list of $K$ numbers, which we can plot as a histogram. For example, Figure 2.1 shows two pmf’s defined on $\mathcal { X } = \{ 1 , 2 , 3 , 4 \}$ . On the left we have a uniform distribution, $p ( x ) = 1 / 4$ , and on the right, we have a degenerate distribution, $p ( x ) = \mathbb { I } \left( x = 1 \right)$ , where $\mathbb { I } \left( \right)$ is the binary indicator function. Thus the distribution in Figure 2.1(b) represents the fact that $X$ is always equal to the value 1. (Thus we see that random variables can also be constant.)

# 2.2.2 Continuous random variables

If $X \in \mathbb R$ is a real-valued quantity, it is called a continuous random variable. In this case, we can no longer create a finite (or countable) set of distinct possible values it can take on. However, there are a countable number of intervals which we can partition the real line into. If we associate events with $X$ being in each one of these intervals, we can use the methods discussed above for discrete random variables. Informally speaking, we can represent the probability of $X$ taking on a specific real value by allowing the size of the intervals to shrink to zero, as we show below.

# 2.2.2.1 Cumulative distribution function (cdf)

Define the events $A = ( X \leq a )$ , $B = ( X \leq b )$ and $C = ( a < X \leq b )$ , where $a < b$ . We have that $B = A \lor C$ , and since $A$ and $C$ are mutually exclusive, the sum rules gives

$$
\operatorname* { P r } ( B ) = \operatorname* { P r } ( A ) + \operatorname* { P r } ( C )
$$

and hence the probability of being in interval $C$ is given by

$$
\operatorname* { P r } ( C ) = \operatorname* { P r } ( B ) - \operatorname* { P r } ( A )
$$

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

![](images/b2bfe2bd2d7310330ef19a2db0a94b444712634b296c7c1c0b5d462d5b141303.jpg)  
Figure 2.2: (a) Plot of the cdf for the standard normal, $\mathcal { N } ( 0 , 1 )$ . Generated by gauss_plot.ipynb. (b) Corresponding pdf. The shaded regions each contain $\alpha / 2$ of the probability mass. Therefore the nonshaded region contains $1 - \alpha$ of the probability mass. The leftmost cutoff point is $\Phi ^ { - 1 } ( \alpha / 2 )$ , where $\Phi$ is the cdf of the Gaussian. By symmetry, the rightmost cutoff point is $\Phi ^ { - 1 } ( 1 - \alpha / 2 ) = - \Phi ^ { - 1 } ( \alpha / 2 ) \nonumber$ . Generated by quantile_plot.ipynb.

In general, we define the cumulative distribution function or cdf of the rv $X$ as follows:

$$
P ( x ) \triangleq \operatorname* { P r } ( X \leq x )
$$

(Note that we use a capital $P$ to represent the cdf.) Using this, we can compute the probability of being in any interval as follows:

$$
\operatorname* { P r } ( a < X \leq b ) = P ( b ) - P ( a )
$$

Cdf’s are monotonically non-decreasing functions. See Figure 2.2a for an example, where we illustrate the cdf of a standard normal distribution, $\mathcal { N } ( x | 0 , 1 )$ ; see Section 2.6 for details.

# 2.2.2.2 Probability density function (pdf)

We define the probability density function or pdf as the derivative of the cdf:

$$
p ( x ) \triangleq { \frac { d } { d x } } P ( x )
$$

(Note that this derivative does not always exist, in which case the pdf is not defined.) See Figure 2.2b for an example, where we illustrate the pdf of a univariate Gaussian (see Section 2.6 for details).

Given a pdf, we can compute the probability of a continuous variable being in a finite interval as follows:

$$
\operatorname* { P r } ( a < X \leq b ) = \int _ { a } ^ { b } p ( x ) d x = P ( b ) - P ( a )
$$

As the size of the interval gets smaller, we can write

$$
\operatorname* { P r } ( x < X \leq x + d x ) \approx p ( x ) d x
$$

Intuitively, this says the probability of $X$ being in a small interval around $x$ is the density at $x$ times the width of the interval.

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

# 2.2.2.3 Quantiles

If the cdf $P$ is strictly monotonically increasing, it has an inverse, called the inverse cdf, or percent point function $\mathbf { \Pi } ( \mathbf { p p f } )$ , or quantile function.

If $P$ is the cdf of $X$ , then $P ^ { - 1 } ( q )$ is the value $x _ { q }$ such that $\Pr ( X \leq x _ { q } ) = q$ ; this is called the $q$ ’th quantile of $P$ . The value $P ^ { - 1 } ( 0 . 5 )$ is the median of the distribution, with half of the probability mass on the left, and half on the right. The values $P ^ { - 1 } ( 0 . 2 5 )$ and $P ^ { - 1 } ( 0 . 7 5 )$ are the lower and upper quartiles.

For example, let $\Phi$ be the cdf of the Gaussian distribution $\mathcal { N } ( 0 , 1 )$ , and $\Phi ^ { - 1 }$ be the inverse cdf. Then points to the left of $\Phi ^ { - 1 } ( \alpha / 2 )$ contain $\alpha / 2$ of the probability mass, as illustrated in Figure 2.2b. By symmetry, points to the right of $\Phi ^ { - 1 } ( 1 - \alpha / 2 )$ also contain $\alpha / 2$ of the mass. Hence the central interval $( \Phi ^ { - 1 } ( \alpha / 2 ) , \Phi ^ { - 1 } ( 1 - \alpha / 2 ) )$ contains $1 - \alpha$ of the mass. If we set $\alpha = 0 . 0 5$ , the central $9 5 \%$ interval is covered by the range

$$
( \Phi ^ { - 1 } ( 0 . 0 2 5 ) , \Phi ^ { - 1 } ( 0 . 9 7 5 ) ) = ( - 1 . 9 6 , 1 . 9 6 )
$$

If the distribution is ${ \mathcal { N } } ( \mu , \sigma ^ { 2 } )$ , then the $9 5 \%$ interval becomes $( \mu - 1 . 9 6 \sigma , \mu + 1 . 9 6 \sigma )$ . This is often approximated by writing $\mu \pm 2 \sigma$ .

# 2.2.3 Sets of related random variables

In this section, we discuss distributions over sets of related random variables.

Suppose, to start, that we have two random variables, $X$ and $Y$ . We can define the joint distribution of two random variables using $p ( x , y ) = p ( X = x , Y = y )$ for all possible values of $X$ and $Y$ . If both variables have finite cardinality, we can represent the joint distribution as a 2d table, all of whose entries sum to one. For example, consider the following example with two binary variables:

$$
\left. { \begin{array} { l } { p ( X , Y ) \ } \\ { X = 0 } \\ { X = 1 } \end{array} } \right| \ { \begin{array} { l } { Y = 0 \quad Y = 1 } \\ { 0 . 2 } \\ { 0 . 3 } \end{array} } \qquad { 0 . 3 }
$$

If two variables are independent, we can represent the joint as the product of the two marginals. If both variables have finite cardinality, we can factorize the 2d joint table into a product of two 1d vectors, as shown in Figure 2.3.

Given a joint distribution, we define the marginal distribution of an rv as follows:

$$
p ( X = x ) = \sum _ { y } p ( X = x , Y = y )
$$

where we are summing over all possible states of $Y$ . This is sometimes called the sum rule or the rule of total probability. We define $p ( Y = y )$ similarly. For example, from the above 2d table, we see $p ( X = 0 ) = 0 . 2 + 0 . 3 = 0 . 5$ and $p ( Y = 0 ) = 0 . 2 + 0 . 3 = 0 . 5$ . (The term “marginal” comes from the accounting practice of writing the sums of rows and columns on the side, or margin, of a table.) We define the conditional distribution of an rv using

$$
p ( Y = y | X = x ) = \frac { p ( X = x , Y = y ) } { p ( X = x ) }
$$

We can rearrange this equation to get

$$
p ( x , y ) = p ( x ) p ( y | x )
$$

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

![](images/43929bdfab8b4b10d174eb00fd394f76c511dc28917644b7116ced4db3793f1d.jpg)  
Figure 2.3: Computing $p ( x , y ) = p ( x ) p ( y )$ , where $X \perp Y$ . Here $X$ and $Y$ are discrete random variables; $X$ has 6 possible states (values) and $Y$ has $\it 5$ possible states. $A$ general joint distribution on two such variables would require $( 6 \times 5 ) - 1 = 2 9$ parameters to define it (we subtract $\boldsymbol { \mathit { 1 } }$ because of the sum-to-one constraint). By assuming (unconditional) independence, we only need $( 6 - 1 ) + ( 5 - 1 ) = 9$ parameters to define $p ( x , y )$ .

This is called the product rule. By extending the product rule to $D$ variables, we get the chain rule of probability:

$$
p ( { \pmb x } _ { 1 : D } ) = p ( { \pmb x } _ { 1 } ) p ( { \pmb x } _ { 2 } | { \pmb x } _ { 1 } ) p ( { \pmb x } _ { 3 } | { \pmb x } _ { 1 } , { \pmb x } _ { 2 } ) p ( { \pmb x } _ { 4 } | { \pmb x } _ { 1 } , { \pmb x } _ { 2 } , { \pmb x } _ { 3 } ) \dots p ( { \pmb x } _ { D } | { \pmb x } _ { 1 : D - 1 } )
$$

This provides a way to create a high dimensional joint distribution from a set of conditional distributions. We discuss this in more detail in Section 3.6.

# 2.2.4 Independence and conditional independence

We say $X$ and $Y$ are unconditionally independent or marginally independent, denoted $X \perp Y$ , if we can represent the joint as the product of the two marginals (see Figure 2.3), i.e.,

$$
X \perp Y \iff p ( X , Y ) = p ( X ) p ( Y )
$$

In general, we say a set of variables $X _ { 1 } , \ldots , X _ { n }$ is (mutually) independent if the joint can be written as a product of marginals for all subsets $\{ X _ { 1 } , \ldots , X _ { m } \} \subseteq \{ X _ { 1 } , \ldots , X _ { n } \}$ : i.e.,

$$
p ( X _ { 1 } , \ldots , X _ { m } ) = \prod _ { i = 1 } ^ { m } p ( X _ { i } )
$$

For example, we say $X _ { 1 } , X _ { 2 } , X _ { 3 }$ are mutually independent if the following conditions hold: $p ( X _ { 1 } , X _ { 2 } , X _ { 3 } ) =$ $p ( X _ { 1 } ) p ( X _ { 2 } ) p ( X _ { 3 } ) , p ( X _ { 1 } , X _ { 2 } ) = p ( X _ { 1 } ) p ( X _ { 2 } ) , p ( X _ { 2 } , X _ { 3 } ) = p ( X _ { 2 } ) p ( X _ { 3 } )$ , and $p ( X _ { 1 } , X _ { 3 } ) = p ( X _ { 1 } ) p ( X _ { 3 } )$ .2

Unfortunately, unconditional independence is rare, because most variables can influence most other variables. However, usually this influence is mediated via other variables rather than being direct. We therefore say $X$ and $Y$ are conditionally independent (CI) given $Z$ iff the conditional joint can be written as a product of conditional marginals:

$$
X \perp Y \mid Z \iff p ( X , Y | Z ) = p ( X | Z ) p ( Y | Z )
$$

We can write this assumption as a graph $X \mathrm { ~ - ~ } Z \mathrm { ~ - ~ } Y$ , which captures the intuition that all the dependencies between $X$ and $Y$ are mediated via $Z$ . By using larger graphs, we can define complex joint distributions; these are known as graphical models, and are discussed in Section 3.6.

# 2.2.5 Moments of a distribution

In this section, we describe various summary statistics that can be derived from a probability distribution (either a pdf or pmf).

# 2.2.5.1 Mean of a distribution

The most familiar property of a distribution is its mean, or expected value, often denoted by $\mu$ . For continuous rv’s, the mean is defined as follows:

$$
\mathbb { E } \left[ X \right] \triangleq \int _ { \mathcal { X } } { x p ( x ) d x }
$$

If the integral is not finite, the mean is not defined; we will see some examples of this later. For discrete rv’s, the mean is defined as follows:

$$
\mathbb { E } \left[ X \right] \triangleq \sum _ { x \in \mathcal { X } } x p ( x )
$$

However, this is only meaningful if the values of $x$ are ordered in some way (e.g., if they represent integer counts).

Since the mean is a linear operator, we have

$$
\mathbb { E } \left[ a X + b \right] = a \mathbb { E } \left[ X \right] + b
$$

This is called the linearity of expectation.

For a set of $n$ random variables, one can show that the expectation of their sum is as follows:

$$
\mathbb { E } \left[ \sum _ { i = 1 } ^ { n } X _ { i } \right] = \sum _ { i = 1 } ^ { n } \mathbb { E } \left[ X _ { i } \right]
$$

If they are independent, the expectation of their product is given by

$$
\mathbb { E } \left[ \prod _ { i = 1 } ^ { n } X _ { i } \right] = \prod _ { i = 1 } ^ { n } \mathbb { E } \left[ X _ { i } \right]
$$

# 2.2.5.2 Variance of a distribution

The variance is a measure of the “spread” of a distribution, often denoted by $\sigma ^ { 2 }$ . This is defined as follows:

$$
\begin{array} { l } { \displaystyle \Psi \left[ X \right] \triangleq \mathbb { E } \left[ ( X - \mu ) ^ { 2 } \right] = \int ( x - \mu ) ^ { 2 } p ( x ) d x } \\ { \displaystyle \qquad = \int x ^ { 2 } p ( x ) d x + \mu ^ { 2 } \int p ( x ) d x - 2 \mu \int x p ( x ) d x = \mathbb { E } \left[ X ^ { 2 } \right] - \mu ^ { 2 } } \end{array}
$$

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

from which we derive the useful result

$$
\mathbb { E } \left[ X ^ { 2 } \right] = \sigma ^ { 2 } + \mu ^ { 2 }
$$

The standard deviation is defined as

$$
\operatorname { s t d } \left[ X \right] \triangleq { \sqrt { \mathbb { V } \left[ X \right] } } = \sigma
$$

This is useful since it has the same units as $X$ itself.

The variance of a shifted and scaled version of a random variable is given by

$$
\mathbb { V } \left[ a X + b \right] = a ^ { 2 } \mathbb { V } \left[ X \right]
$$

If we have a set of $n$ independent random variables, the variance of their sum is given by the sum of their variances:

$$
\mathbb { V } \left[ \sum _ { i = 1 } ^ { n } X _ { i } \right] = \sum _ { i = 1 } ^ { n } \mathbb { V } \left[ X _ { i } \right]
$$

The variance of their product can also be derived, as follows:

$$
\begin{array} { r l } { \displaystyle \mathbb { V } \left[ \displaystyle \prod _ { i = 1 } ^ { n } X _ { i } \right] = \mathbb { E } \left[ ( \prod _ { i } X _ { i } ) ^ { 2 } \right] - ( \mathbb { E } \left[ \prod _ { i } X _ { i } \right] ) ^ { 2 } } & { } \\ { \displaystyle } & { = \mathbb { E } \left[ \prod _ { i } X _ { i } ^ { 2 } \right] - ( \prod _ { i } \mathbb { E } [ X _ { i } ] ) ^ { 2 } } \\ & { = \prod _ { i } \mathbb { E } \left[ X _ { i } ^ { 2 } \right] - \prod _ { i } ( \mathbb { E } [ X _ { i } ] ) ^ { 2 } } \\ & { = \displaystyle \prod _ { i } ( \mathbb { V } [ X _ { i } ] + ( \mathbb { E } [ X _ { i } ] ) ^ { 2 } ) - \prod _ { i } ( \mathbb { E } [ X _ { i } ] ) ^ { 2 } } \\ & { = \displaystyle \prod _ { i } ( \sigma _ { i } ^ { 2 } + \mu _ { i } ^ { 2 } ) - \prod _ { i } \mu _ { i } ^ { 2 } } \end{array}
$$

# 2.2.5.3 Mode of a distribution

The mode of a distribution is the value with the highest probability mass or probability density:

$$
\pmb { x } ^ { * } = \operatorname * { a r g m a x } _ { \pmb { x } } p ( \pmb { x } )
$$

If the distribution is multimodal, this may not be unique, as illustrated in Figure 2.4. Furthermore, even if there is a unique mode, this point may not be a good summary of the distribution.

# 2.2.5.4 Conditional moments

When we have two or more dependent random variables, we can compute the moments of one given knowledge of the other. For example, the law of iterated expectations, also called the law of total expectation, tells us that

$$
\mathbb { E } \left[ X \right] = \mathbb { E } _ { Y } \left[ \mathbb { E } \left[ X | Y \right] \right]
$$

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

![](images/59c590508bbf3022192a04c83cdcd48262ef6a23382ffeb0e7a4cef7bd70bdd9.jpg)  
Figure 2.4: Illustration of a mixture of two 1d Gaussians, $p ( x ) = 0 . 5 \mathcal { N } ( x | 0 , 0 . 5 ) + 0 . 5 \mathcal { N } ( x | 2 , 0 . 5 )$ . Generated by bimodal_dist_plot.ipynb.

To prove this, let us suppose, for simplicity, that $X$ and $Y$ are both discrete rv’s. Then we have

$$
{ \begin{array} { r l } & { { \boldsymbol { \Sigma } } [ X | Y ] ] = \mathbb { E } _ { Y } \left[ \sum _ { x } x \ p ( X = x | Y ) \right] } \\ & { \qquad = \sum _ { y } \left[ \sum _ { x } x \ p ( X = x | Y = y ) \right] \ p ( Y = y ) = \sum _ { x , y } x p ( X = x , Y = y ) = \sum _ { y } { \mathrm { ( f o r ~ } } x { \mathrm { ) } } [ ( \sum _ { x = x + y + y ) } ] } \end{array} }
$$

To give a more intuitive explanation, consider the following simple example.3 Let $X$ be the lifetime duration of a lightbulb, and let $Y$ be the factory the lightbulb was produced in. Suppose $\mathbb { E } \left[ X | Y = 1 \right] = 5 0 0 0$ and $\mathbb { E } \left[ X | Y = 2 \right] = 4 0 0 0$ , indicating that factory 1 produces longer lasting bulbs. Suppose factory 1 supplies $6 0 \%$ of the lightbulbs, so $p ( Y = 1 ) = 0 . 6$ and $p ( Y = 2 ) = 0 . 4$ . Then the expected duration of a random lightbulb is given by

$$
\operatorname { \mathbb { E } } \left[ X \right] = \operatorname { \mathbb { E } } \left[ X \vert Y = 1 \right] p ( Y = 1 ) + \operatorname { \mathbb { E } } \left[ X \vert Y = 2 \right] p ( Y = 2 ) = 5 0 0 0 \times 0 . 6 + 4 0 0 0 \times
$$

There is a similar formula for the variance. In particular, the law of total variance, also called the conditional variance formula, tells us that

$$
\mathbb { V } \left[ X \right] = \mathbb { E } _ { Y } \left[ \mathbb { V } \left[ X | Y \right] \right] + \mathbb { V } _ { Y } \left[ \mathbb { E } \left[ X | Y \right] \right]
$$

To see this, let us define the conditional moments, $\mu _ { X | Y } = \operatorname { \mathbb { E } } \left[ X | Y \right]$ , $s _ { X | Y } = \mathbb { E } \left\lfloor X ^ { 2 } | Y \right\rfloor$ , and $\sigma _ { X | Y } ^ { 2 } = \Psi \left[ X | Y \right] = s _ { X | Y } - \mu _ { X | Y } ^ { 2 }$ , which are functions of $Y$ (and therefore are random quantities). Then we have

$$
{ \begin{array} { r l } & { \mathbb { V } \left[ X \right] = \operatorname { \mathbb { E } } \left[ X ^ { 2 } \right] - ( \operatorname { \mathbb { E } } \left[ X \right] ) ^ { 2 } = \operatorname { \mathbb { E } } _ { Y } \left[ s _ { X \mid Y } \right] - \left( \operatorname { \mathbb { E } } _ { Y } \left[ \mu _ { X \mid Y } \right] \right) ^ { 2 } } \\ & { \qquad = \operatorname { \mathbb { E } } _ { Y } \left[ \sigma _ { X \mid Y } ^ { 2 } \right] + \operatorname { \mathbb { E } } _ { Y } \left[ \mu _ { X \mid Y } ^ { 2 } \right] - \left( \operatorname { \mathbb { E } } _ { Y } \left[ \mu _ { X \mid Y } \right] \right) ^ { 2 } } \\ & { \qquad = E _ { Y } [ \mathbb { V } \left[ X \mid Y \right] ] + \mathbb { V } _ { Y } [ \mu _ { X \mid Y } ] } \end{array} }
$$

To get some intuition for these formulas, consider a mixture of $K$ univariate Gaussians. Let $Y$ be the hidden indicator variable that specifies which mixture component we are using, and let

![](images/24645a35f5b03912a0ab6d196b6b9997a059fd51da8975d4784d901ffb3e6ca4.jpg)  
Figure 2.5: Illustration of Anscombe’s quartet. All of these datasets have the same low order summary statistics. Generated by anscombes_quartet.ipynb.

$\begin{array} { r } { X = \sum _ { y = 1 } ^ { K } \pi _ { y } \mathcal { N } ( X | \mu _ { y } , \sigma _ { y } ) } \end{array}$ . In Figure 2.4, we have $\pi _ { 1 } = \pi _ { 2 } = 0 . 5$ , $\mu _ { 1 } = 0$ , $\mu _ { 2 } = 2$ , $\sigma _ { 1 } = \sigma _ { 2 } = 0 . 5$ . Thus

$$
\begin{array} { r l } & { \mathbb { E } \left[ \mathbb { V } \left[ X | Y \right] \right] = \pi _ { 1 } \sigma _ { 1 } ^ { 2 } + \pi _ { 2 } \sigma _ { 2 } ^ { 2 } = 0 . 2 5 } \\ & { \mathbb { V } \left[ \mathbb { E } \left[ X | Y \right] \right] = \pi _ { 1 } ( \mu _ { 1 } - \overline { { \mu } } ) ^ { 2 } + \pi _ { 2 } ( \mu _ { 2 } - \overline { { \mu } } ) ^ { 2 } = 0 . 5 ( 0 - 1 ) ^ { 2 } + 0 . 5 ( 2 - 1 ) ^ { 2 } = 0 . 5 + } \end{array}
$$

So we get the intuitive result that the variance of $X$ is dominated by which centroid it is drawn from (i.e., difference in the means), rather than the local variance around each centroid.

# 2.2.6 Limitations of summary statistics \*

Although it is common to summarize a probability distribution (or points sampled from a distribution) using simple statistics such as the mean and variance, this can lose a lot of information. A striking example of this is known as Anscombe’s quartet [Ans73], which is illustrated in Figure 2.5. This shows 4 different datasets of $( x , y )$ pairs, all of which have identical mean, variance and correlation coefficient $\rho$ (defined in Section 3.1.2): $\mathbb { E } \left[ x \right] = 9$ , $\mathbb { V } \left[ x \right] = 1 1 , \mathbb { E } \left[ y \right] = 7 . 5 0 , \mathbb { V } \left[ y \right] = 4 . 1 2$ , and $\rho = 0 . 8 1 6$ .4 However, the joint distributions $p ( x , y )$ from which these points were sampled are clearly very different. Anscombe invented these datasets, each consisting of 10 data points, to counter the impression among statisticians that numerical summaries are superior to data visualization [Ans73].

An even more striking example of this phenomenon is shown in Figure 2.6. This consists of a dataset that looks like a dinosaur5, plus 11 other datasets, all of which have identical low order statistics. This collection of datasets is called the Datasaurus Dozen [MF17]. The exact values of the $( x , y )$ points are available online.6 They were computed using simulated annealing, a derivative free optimization method which we discuss in the sequel to this book, [Mur23]. (The objective function being optimized measures deviation from the target summary statistics of the original dinosaur, plus distance from a particular target shape.)

![](images/0426ddb3d9eec37a85e0762880a2ea087e28e94a7e2046363ea74d3541875d97.jpg)  
Figure 2.6: Illustration of the Datasaurus Dozen. All of these datasets have the same low order summary statistics. Adapted from Figure 1 of [MF17]. Generated by datasaurus_dozen.ipynb.

The same simulated annealing approach can be applied to 1d datasets, as shown in Figure 2.7. We see that all the datasets are quite different, but they all have the same median and inter-quartile range as shown by the central shaded part of the box plots in the middle. A better visualization is known as a violin plot, shown on the right. This shows (two copies of) the 1d kernel density estimate (Section 16.3) of the distribution on the vertical axis, in addition to the median and IQR markers. This visualization is better able to distinguish differences in the distributions. However, the technique is limited to 1d data.

# 2.3 Bayes’ rule

Bayes’s theorem is to the theory of probability what Pythagoras’s theorem is to geometry. Sir Harold Jeffreys, 1973 [Jef73].

In this section, we discuss the basics of Bayesian inference. According to the Merriam-Webster dictionary, the term “inference” means “the act of passing from sample data to generalizations, usually with calculated degrees of certainty”. The term “Bayesian” is used to refer to inference methods

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

![](images/bf0de1e3e6ff2379699fae80cecda101266780f03ac76bdd3031b95217d33079.jpg)  
Figure 2.7: Illustration of 7 different datasets (left), the corresponding box plots (middle) and violin box plots (right). From Figure $\boldsymbol { \vartheta }$ of https: // www. autodesk. com/ research/ publications/ same-stats-different-graphs . Used with kind permission of Justin Matejka.

that represent “degrees of certainty” using probability theory, and which leverage Bayes’ rule $^ { 7 }$ , to update the degree of certainty given data.

Bayes’ rule itself is very simple: it is just a formula for computing the probability distribution over possible values of an unknown (or hidden) quantity $H$ given some observed data $Y = y$ :

$$
p ( H = h | Y = y ) = { \frac { p ( H = h ) p ( Y = y | H = h ) } { p ( Y = y ) } }
$$

This follows automatically from the identity

$$
p ( h | y ) p ( y ) = p ( h ) p ( y | h ) = p ( h , y )
$$

which itself follows from the product rule of probability.

In Equation (2.51), the term $p ( H )$ represents what we know about possible values of $H$ before we see any data; this is called the prior distribution. (If $H$ has $K$ possible values, then $p ( H )$ is a vector of $K$ probabilities, that sum to 1.) The term $p ( Y | H = h )$ represents the distribution over the possible outcomes $Y$ we expect to see if $H = h$ ; this is called the observation distribution. When we evaluate this at a point corresponding to the actual observations, $y$ , we get the function $p ( Y = y | H = h )$ , which is called the likelihood. (Note that this is a function of $h$ , since $y$ is fixed, but it is not a probability distribution, since it does not sum to one.) Multiplying the prior distribution $p ( H = h )$ by the likelihood function $p ( Y = y | H = h )$ for each $h$ gives the unnormalized joint distribution $p ( H = h , Y = y )$ . We can convert this into a normalized distribution by dividing by $p ( Y = y )$ , which is known as the marginal likelihood, since it is computed by marginalizing over the unknown $H$ :

$$
p ( Y = y ) = \sum _ { h ^ { \prime } \in \mathcal { H } } p ( H = h ^ { \prime } ) p ( Y = y | H = h ^ { \prime } ) = \sum _ { h ^ { \prime } \in \mathcal { H } } p ( H = h ^ { \prime } , Y = y )
$$

Table 2.1: Likelihood function $p ( Y | H )$ for a binary observation $Y$ given two possible hidden states $H$ . Each row sums to one. Abbreviations: TNR is true negative rate, TPR is true positive rate, FNR is false negative rate, FPR is false positive rate.   

<html><body><table><tr><td></td><td colspan="2">Observation</td></tr><tr><td rowspan="2">0 Truth 1</td><td>0</td><td>1 FPR=1-TNR=0.025</td></tr><tr><td>TNR=Specificity=0.975 FNR=1-TPR=0.125</td><td>TPR=Sensitivity=0.875</td></tr></table></body></html>

Normalizing the joint distribution by computing $p ( H = h , Y = y ) / p ( Y = y )$ for each $h$ gives the posterior distribution $p ( H = h | Y = y ) $ ; this represents our new belief state about the possible values of $H$ .

We can summarize Bayes rule in words as follows:

posterior $\propto$ prior $\times$ likelihood

Here we use the symbol $\propto$ to denote “proportional to”, since we are ignoring the denominator, which is just a constant, independent of $H$ . Using Bayes rule to update a distribution over unknown values of some quantity of interest, given relevant observed data, is called Bayesian inference, or posterior inference. It can also just be called probabilistic inference.

Below we give some simple examples of Bayesian inference in action. We will see many more interesting examples later in this book.

# 2.3.1 Example: Testing for COVID-19

Suppose you think you may have contracted COVID-19, which is an infectious disease caused by the SARS-CoV-2 virus. You decide to take a diagnostic test, and you want to use its result to determine if you are infected or not.

Let $H = 1$ be the event that you are infected, and $H = 0$ be the event you are not infected. Let $Y = 1$ if the test is positive, and $Y = 0$ if the test is negative. We want to compute $p ( H = h | Y = y ,$ ), for $h \in \{ 0 , 1 \}$ , where $y$ is the observed test outcome. (We will write the distribution of values, $[ p ( H = 0 | Y = y ) , p ( H = 1 | Y = y ) ]$ ] as $p ( H | y )$ , for brevity.) We can think of this as a form of binary classification, where $H$ is the unknown class label, and $y$ is the feature vector.

First we must specify the likelihood. This quantity obviously depends on how reliable the test is. There are two key parameters. The sensitivity (aka true positive rate) is defined as $p ( Y = 1 | H = 1 )$ , i.e., the probability of a positive test given that the truth is positive. The false negative rate is defined as one minus the sensitivity. The specificity (aka true negative rate) is defined as $p ( Y = 0 | H = 0 )$ , i.e., the probability of a negative test given that the truth is negative. The false positive rate is defined as one minus the specificity. We summarize all these quantities in Table 2.1. (See Section 5.1.3.1 for more details.) Following https://nyti.ms/31MTZgV, we set the sensitivity to $8 7 . 5 \%$ and the specificity to $9 7 . 5 \%$ .

Next we must specify the prior. The quantity $p ( H = 1 )$ represents the prevalence of the disease in the area in which you live. We set this to $p ( H = 1 ) = 0 . 1$ (i.e., $1 0 \%$ ), which was the prevalence in New York City in Spring 2020. (This example was chosen to match the numbers in https://nyti.ms/31MTZgV.)

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

Now suppose you test positive. We have

$$
\begin{array} { r l } & { p ( H = 1 | Y = 1 ) = \frac { p ( Y = 1 | H = 1 ) p ( H = 1 ) } { p ( Y = 1 | H = 1 ) p ( H = 1 ) + p ( Y = 1 | H = 0 ) p ( H = 0 ) } } \\ & { \qquad = \frac { \mathrm { T P R } \times \mathrm { p r i o r } } { \mathrm { T P R } \times \mathrm { p r i o r } + \mathrm { F P R } \times ( 1 - \mathrm { p r i o r } ) } } \\ & { \qquad = \frac { 0 . 8 7 5 \times 0 . 1 } { 0 . 8 7 5 \times 0 . 1 + 0 . 0 2 5 \times 0 . 9 } = 0 . 7 9 5 \times 0 . 1 } \end{array}
$$

So there is a $7 9 . 5 \%$ chance you are infected.

Now suppose you test negative. The probability you are infected is given by

$$
\begin{array} { r l } & { p ( H = 1 | Y = 0 ) = \frac { p ( Y = 0 | H = 1 ) p ( H = 1 ) } { p ( Y = 0 | H = 1 ) p ( H = 1 ) + p ( Y = 0 | H = 0 ) p ( H = 0 ) } } \\ & { \qquad = \frac { \mathrm { F N R } \times \mathrm { p r i o r } } { \mathrm { F N R } \times \mathrm { p r i o r } + \mathrm { T N R } \times ( 1 - \mathrm { p r i o r } ) } } \\ & { \qquad = \frac { 0 . 1 2 5 \times 0 . 1 } { 0 . 1 2 5 \times 0 . 1 + 0 . 9 7 5 \times 0 . 9 } = 0 . 0 1 4 \qquad } \end{array}
$$

So there is just a $1 . 4 \%$ chance you are infected.

Nowadays COVID-19 prevalence is much lower. Suppose we repeat these calculations using a base rate of $1 \%$ ; now the posteriors reduce to $2 6 \%$ and $0 . 1 3 \%$ respectively.

The fact that you only have a $2 6 \%$ chance of being infected with COVID-19, even after a positive test, is very counter-intuitive. The reason is that a single positive test is more likely to be a false positive than due to the disease, since the disease is rare. To see this, suppose we have a population of 100,000 people, of whom 1000 are infected. Of those who are infected, $8 7 5 = 0 . 8 7 5 \times 1 0 0 0$ test positive, and of those who are uninfected, $2 4 7 5 = 0 . 0 2 5 \times 9 9 , 0 0 0$ test positive. Thus the total number of positives is $3 3 5 0 = 8 7 5 + 2 4 7 5$ , so the posterior probability of being infected given a positive test is $8 7 5 / 3 3 5 0 = 0 . 2 6$ .

Of course, the above calculations assume we know the sensitivity and specificity of the test. See [GC20] for how to apply Bayes rule for diagnostic testing when there is uncertainty about these parameters.

# 2.3.2 Example: The Monty Hall problem

In this section, we consider a more “frivolous” application of Bayes rule. In particular, we apply it to the famous Monty Hall problem.

Imagine a game show with the following rules: There are three doors, labeled 1, 2, 3. A single prize (e.g., a car) has been hidden behind one of them. You get to select one door. Then the gameshow host opens one of the other two doors (not the one you picked), in such a way as to not reveal the prize location. At this point, you will be given a fresh choice of door: you can either stick with your first choice, or you can switch to the other closed door. All the doors will then be opened and you will receive whatever is behind your final choice of door.

For example, suppose you choose door 1, and the gameshow host opens door 3, revealing nothing behind the door, as promised. Should you (a) stick with door 1, or (b) switch to door 2, or (c) does it make no difference?

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

<html><body><table><tr><td>Door 1</td><td>Door 2</td><td>Door 3</td><td>Switch</td><td>Stay</td></tr><tr><td>Car</td><td>1</td><td>-</td><td>Lose</td><td>Win</td></tr><tr><td>-</td><td>Car</td><td>1</td><td>Win</td><td>Lose</td></tr><tr><td>1</td><td>1</td><td>Car</td><td>Win</td><td>Lose</td></tr></table></body></html>

Table 2.2: 3 possible states for the Monty Hall game, showing that switching doors is two times better (on average) than staying with your original choice. Adapted from Table 6.1 of [PM18].

Intuitively, it seems it should make no difference, since your initial choice of door cannot influence the location of the prize. However, the fact that the host opened door 3 tells us something about the location of the prize, since he made his choice conditioned on the knowledge of the true location and on your choice. As we show below, you are in fact twice as likely to win the prize if you switch to door 2.

To show this, we will use Bayes’ rule. Let $H _ { i }$ denote the hypothesis that the prize is behind door $i$ . We make the following assumptions: the three hypotheses $H _ { 1 }$ , $H _ { 2 }$ and $H _ { 3 }$ are equiprobable a priori, i.e.,

$$
P ( H _ { 1 } ) = P ( H _ { 2 } ) = P ( H _ { 3 } ) = \frac { 1 } { 3 } .
$$

The datum we receive, after choosing door 1, is either $Y = 3$ and $Y = 2$ (meaning door 3 or 2 is opened, respectively). We assume that these two possible outcomes have the following probabilities. If the prize is behind door 1, then the host selects at random between $Y = 2$ and $Y = 3$ . Otherwise the choice of the host is forced and the probabilities are 0 and $^ { 1 }$ .

$$
| \begin{array} { c } { P ( Y = 2 | H _ { 1 } ) = \frac { 1 } { 2 } } \\ { P ( Y = 3 | H _ { 1 } ) = \frac { 1 } { 2 } } \end{array} | \begin{array} { c } { P ( Y = 2 | H _ { 2 } ) = 0 } \\ { P ( Y = 3 | H _ { 2 } ) = 1 } \end{array} | \begin{array} { c } { P ( Y = 2 | H _ { 3 } ) = 1 } \\ { P ( Y = 3 | H _ { 3 } ) = 0 } \end{array} |
$$

Now, using Bayes’ theorem, we evaluate the posterior probabilities of the hypotheses:

$$
\begin{array} { l } { P ( H _ { i } | Y = 3 ) = \displaystyle \frac { P ( Y = 3 | H _ { i } ) P ( H _ { i } ) } { P ( Y = 3 ) } } \\ { P ( H _ { 1 } | Y = 3 ) = \displaystyle \frac { ( 1 / 2 ) ( 1 / 3 ) } { P ( Y = 3 ) } \ \Big | \ P ( H _ { 2 } | Y = 3 ) = \displaystyle \frac { ( 1 ) ( 1 / 3 ) } { P ( Y = 3 ) } \ \Big | \ P ( H _ { 3 } | Y = 3 ) = \frac { ( 0 ) ( 1 / 3 ) } { P ( Y = 3 ) } } \end{array}
$$

The denominator $P ( Y = 3 )$ is $\begin{array} { r } { P ( Y = 3 ) = \frac { 1 } { 6 } + \frac { 1 } { 3 } = \frac { 1 } { 2 } } \end{array}$ . So

$$
\left| ~ P ( H _ { 1 } | Y = 3 ) ~ = ~ \frac { 1 } { 3 } ~ \right| ~ P ( H _ { 2 } | Y = 3 ) ~ = ~ \frac { 2 } { 3 } ~ \Big | ~ P ( H _ { 3 } | Y = 3 ) ~ = ~ 0 . \ \Big | ~
$$

So the contestant should switch to door 2 in order to have the biggest chance of getting the prize.   
See Table 2.2 for a worked example.

Many people find this outcome surprising. One way to make it more intuitive is to perform a thought experiment in which the game is played with a million doors. The rules are now that the contestant chooses one door, then the game show host opens 999,998 doors in such a way as not to reveal the prize, leaving the contestant’s selected door and one other door closed. The contestant may now stick or switch. Imagine the contestant confronted by a million doors, of which doors 1 and 234,598 have not been opened, door 1 having been the contestant’s initial guess. Where do you think the prize is?

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

![](images/d15bc715613d369fc5502f517a662ed77bc0a8fb1508845da8d4270224933698.jpg)  
Figure 2.8: Any planar line-drawing is geometrically consistent with infinitely many 3-D structures. From Figure 11 of [SA93]. Used with kind permission of Pawan Sinha.

# 2.3.3 Inverse problems \*

Probability theory is concerned with predicting a distribution over outcomes $y$ given knowledge (or assumptions) about the state of the world, $h$ . By contrast, inverse probability is concerned with inferring the state of the world from observations of outcomes. We can think of this as inverting the $h  y$ mapping.

For example, consider trying to infer a 3d shape $h$ from a 2d image $y$ , which is a classic problem in visual scene understanding. Unfortunately, this is a fundamentally ill-posed problem, as illustrated in Figure 2.8, since there are multiple possible hidden $h$ ’s consistent with the same observed $y$ (see e.g., [Piz01]). Similarly, we can view natural language understanding as an ill-posed problem, in which the listener must infer the intention $h$ from the (often ambiguous) words spoken by the speaker (see e.g., [Sab21]).

To tackle such inverse problems, we can use Bayes’ rule to compute the posterior, $p ( h | y )$ , which gives a distribution over possible states of the world. This requires specifying the forwards model, $p ( y | h )$ , as well as a prior $p ( h )$ , which can be used to rule out (or downweight) implausible world states. We discuss this topic in more detail in the sequel to this book, [Mur23].

# 2.4 Bernoulli and binomial distributions

Perhaps the simplest probability distribution is the Bernoulli distribution, which can be used to model binary events, as we discuss below.

# 2.4.1 Definition

Consider tossing a coin, where the probability of event that it lands heads is given by $0 \leq \theta \leq 1$ . Let $Y = 1$ denote this event, and let $Y = 0$ denote the event that the coin lands tails. Thus we are assuming that $p ( Y = 1 ) = \theta$ and $p ( Y = 0 ) = 1 - \theta$ . This is called the Bernoulli distribution, and can be written as follows

$Y \sim \operatorname { B e r } ( \theta )$

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license where the symbol $\sim$ means “is sampled from” or “is distributed as”, and Ber refers to Bernoulli. The probability mass function (pmf) of this distribution is defined as follows:

![](images/f3292afbb5e8145eea825dc393f3316a3dcccd17dc3306f04617beaaa3cb113f.jpg)  
Figure 2.9: Illustration of the binomial distribution with $N = 1 0$ and (a) $\theta = 0 . 2 5$ and $( b ,$ $\theta = 0 . 9$ . Generated by binom_dist_plot.ipynb.

$$
\operatorname { B e r } ( y | \theta ) = { \left\{ \begin{array} { l l } { 1 - \theta } & { { \mathrm { i f ~ } } y = 0 } \\ { \theta } & { { \mathrm { i f ~ } } y = 1 } \end{array} \right. }
$$

(See Section 2.2.1 for details on pmf’s.) We can write this in a more concise manner as follows:

$$
\operatorname { B e r } ( y | \theta ) \triangleq \theta ^ { y } ( 1 - \theta ) ^ { 1 - y }
$$

The Bernoulli distribution is a special case of the binomial distribution. To explain this, suppose we observe a set of $N$ Bernoulli trials, denoted $y _ { n } \sim \mathrm { B e r } ( \cdot | \theta )$ , for $n = 1 : N$ . Concretely, think of tossing a coin $N$ times. Let us define $s$ to be the total number of heads, $\begin{array} { r } { s \triangleq \sum _ { n = 1 } ^ { N } \mathbb { I } \left( y _ { n } = 1 \right) } \end{array}$ . The distribution of $s$ is given by the binomial distribution:

$$
\mathrm { B i n } ( s | N , \theta ) \triangleq \binom { N } { s } \theta ^ { s } ( 1 - \theta ) ^ { N - s }
$$

where

$$
{ \binom { N } { k } } \triangleq { \frac { N ! } { ( N - k ) ! k ! } }
$$

is the number of ways to choose $k$ items from $N$ (this is known as the binomial coefficient, and is pronounced “N choose k”). See Figure 2.9 for some examples of the binomial distribution. If $N = 1$ , the binomial distribution reduces to the Bernoulli distribution.

# 2.4.2 Sigmoid (logistic) function

When we want to predict a binary variable $y \in \{ 0 , 1 \}$ given some inputs $\pmb { x } \in \mathcal { X }$ , we need to use a conditional probability distribution of the form

$$
p ( y | \boldsymbol { x } , \pmb \theta ) = \mathrm { B e r } ( y | f ( \boldsymbol { x } ; \pmb \theta ) )
$$

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

![](images/8bc463c95ff4b59ff049ca4ad6c1e7121910041de6aab043674944f10af0a04f.jpg)  
Figure 2.10: (a) The sigmoid (logistic) function $\sigma ( a ) = ( 1 + e ^ { - a } ) ^ { - 1 }$ . (b) The Heaviside function $\mathbb { I } \left( a > 0 \right)$ . Generated by activation_fun_plot.ipynb.

$$
\sigma ( x ) \triangleq { \frac { 1 } { 1 + e ^ { - x } } } = { \frac { e ^ { x } } { 1 + e ^ { x } } }
$$

$$
{ \frac { d } { d x } } \sigma ( x ) = \sigma ( x ) ( 1 - \sigma ( x ) )
$$

$$
1 - \sigma ( x ) = \sigma ( - x )
$$

$$
\sigma ^ { - 1 } ( p ) = \log \left( { \frac { p } { 1 - p } } \right) \triangleq \log \mathrm { i t } ( p )
$$

$$
\sigma _ { + } ( x ) \triangleq \log ( 1 + e ^ { x } ) \triangleq \mathrm { s o f t p l u s } ( x )
$$

$$
{ \frac { d } { d x } } \sigma _ { + } ( x ) = \sigma ( x )
$$

Table 2.3: Some useful properties of the sigmoid (logistic) and related functions. Note that the logit function is the inverse of the sigmoid function, and has a domain of [0, 1].

where $f ( { \pmb x } ; { \pmb \theta } )$ is some function that predicts the mean parameter of the output distribution. We will consider many different kinds of function $f$ in Part II–Part IV.

To avoid the requirement that $0 \leq f ( \pmb { x } ; \pmb { \theta } ) \leq 1$ , we can let $f$ be an unconstrained function, and use the following model:

$$
p ( y | \pmb { x } , \pmb { \theta } ) = \mathrm { B e r } ( y | \sigma ( f ( \pmb { x } ; \pmb { \theta } ) ) )
$$

Here $\sigma ( )$ is the sigmoid or logistic function, defined as follows:

$$
\sigma ( a ) \triangleq { \frac { 1 } { 1 + e ^ { - a } } }
$$

where $a = f ( \pmb { x } ; \pmb { \theta } )$ . The term “sigmoid” means S-shaped: see Figure 2.10a for a plot. We see that it

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

![](images/36f4d573f761978887e5cad6c57e14a34ae19de35bf3097b8d2f18ceccf4fc01.jpg)  
Figure 2.11: Logistic regression applied to a 1-dimensional, 2-class version of the Iris dataset. Generated by iris_logreg.ipynb. Adapted from Figure 4.23 of [Gér19].

maps the whole real line to $[ 0 , 1 ]$ , which is necessary for the output to be interpreted as a probability (and hence a valid value for the Bernoulli parameter $\theta$ ). The sigmoid function can be thought of as a “soft” version of the heaviside step function, defined by

$$
H ( a ) \triangleq \mathbb { I } \left( a > 0 \right)
$$

as shown in Figure 2.10b.

Plugging the definition of the sigmoid function into Equation (2.78) we get

$$
\begin{array} { l } { \displaystyle p ( y = 1 | x , \theta ) = \frac { 1 } { 1 + e ^ { - a } } = \frac { e ^ { a } } { 1 + e ^ { a } } = \sigma ( a ) } \\ { \displaystyle p ( y = 0 | x , \theta ) = 1 - \frac { 1 } { 1 + e ^ { - a } } = \frac { e ^ { - a } } { 1 + e ^ { - a } } = \frac { 1 } { 1 + e ^ { a } } = \sigma ( - a ) } \end{array}
$$

The quantity $a$ is equal to the log odds, $\textstyle \log ( { \frac { p } { 1 - p } } )$ , where $p = p ( y = 1 | \mathbf { x } ; \pmb { \theta } )$ . To see this, note that

$$
\log \left( { \frac { p } { 1 - p } } \right) = \log \left( { \frac { e ^ { a } } { 1 + e ^ { a } } } { \frac { 1 + e ^ { a } } { 1 } } \right) = \log ( e ^ { a } ) = a
$$

The logistic function or sigmoid function maps the log-odds $a$ to $p$ :

$$
p = { \mathrm { l o g i s t i c } } ( a ) = \sigma ( a ) \triangleq { \frac { 1 } { 1 + e ^ { - a } } } = { \frac { e ^ { a } } { 1 + e ^ { a } } }
$$

The inverse of this is called the logit function, and maps $p$ to the log-odds $a$ :

$$
a = \mathrm { l o g i t } ( p ) = \sigma ^ { - 1 } ( p ) \triangleq \log \left( { \frac { p } { 1 - p } } \right)
$$

See Table 2.3 for some useful properties of these functions.

# 2.4.3 Binary logistic regression

In this section, we use a conditional Bernoulli model, where we use a linear predictor of the form $f ( \pmb { x } ; \pmb { \theta } ) = \pmb { w } ^ { 1 } \pmb { x } + b$ . Thus the model has the form

$$
p ( \boldsymbol { y } | \mathbf { \boldsymbol { x } } ; \mathbf { \boldsymbol { \theta } } ) = \mathrm { B e r } ( \boldsymbol { y } | \sigma ( \mathbf { \boldsymbol { w } } ^ { \top } \mathbf { \boldsymbol { x } } + b ) )
$$

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

In other words,

$$
p ( y = 1 | \mathbf { \boldsymbol { x } } ; \mathbf { \boldsymbol { \theta } } ) = \sigma ( \mathbf { \boldsymbol { w } } ^ { \mathsf { T } } \mathbf { \boldsymbol { x } } + b ) = \frac { 1 } { 1 + e ^ { - ( \mathbf { \boldsymbol { w } } ^ { \mathsf { T } } \mathbf { \boldsymbol { x } } + b ) } }
$$

This is called logistic regression.

For example consider a 1-dimensional, 2-class version of the iris dataset, where the positive class is “Virginica” and the negative class is “not Virginica”, and the feature $x$ we use is the petal width. We fit a logistic regression model to this and show the results in Figure 2.11. The decision boundary corresponds to the value $x ^ { * }$ where $p ( y = 1 | x = x ^ { * } , \pmb { \theta } ) = 0 . 5$ . We see that, in this example, $x ^ { * } \approx 1 . 7$ . As $x$ moves away from this boundary, the classifier becomes more confident in its prediction about the class label.

It should be clear from this example why it would be inappropriate to use linear regression for a (binary) classification problem. In such a model, the probabilities would increase above 1 as we move far enough to the right, and below 0 as we move far enough to the left.

For more detail on logistic regression, see Chapter 10.

# 2.5 Categorical and multinomial distributions

To represent a distribution over a finite set of labels, $y \in \{ 1 , \ldots , C \}$ , we can use the categorical distribution, which generalizes the Bernoulli to $C > 2$ values.

# 2.5.1 Definition

The categorical distribution is a discrete probability distribution with one parameter per class:

$$
\mathrm { C a t } ( y | \pmb \theta ) \triangleq \prod _ { c = 1 } ^ { C } \theta _ { c } ^ { \mathbb I ( y = c ) }
$$

In other words, $p ( y = c | \pmb { \theta } ) = \theta _ { c }$ . Note that the parameters are constrained so that $0 \leq \theta _ { c } \leq 1$ and $\textstyle \sum _ { c = 1 } ^ { C } \theta _ { c } = 1$ ; thus there are only $C - 1$ independent parameters.

We can write the categorical distribution in another way by converting the discrete variable $y$ into a one-hot vector with $C$ elements, all of which are 0 except for the entry corresponding to the class label. (The term “one-hot” arises from electrical engineering, where binary vectors are encoded as electrical current on a set of wires, which can be active (“hot”) or not (“cold”).) For example, if $C = 3$ , we encode the classes 1, 2 and 3 as $( 1 , 0 , 0 )$ , $( 0 , 1 , 0 )$ , and $( 0 , 0 , 1 )$ . More generally, we can encode the classes using unit vectors, where $e _ { c }$ is all 0s except for dimension $c$ . (This is also called a dummy encoding.) Using one-hot encodings, we can write the categorical distribution as follows:

$$
\mathrm { C a t } ( { \pmb y } | \pmb \theta ) \triangleq \prod _ { c = 1 } ^ { C } \theta _ { c } ^ { y _ { c } }
$$

The categorical distribution is a special case of the multinomial distribution. To explain this, suppose we observe $N$ categorical trials, $y _ { n } \sim \operatorname { C a t } ( \cdot | \pmb \theta )$ , for $n = 1 : N$ . Concretely, think of rolling a $C$ -sided dice $N$ times. Let us define $\pmb { y }$ to be a vector that counts the number of times each face

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

![](images/ccf00b8fbbac8098a6bf48c37f40b237129786202e0154b944775855aff6be39.jpg)  
Figure 2.12: Softmax distribution softmax $( { \pmb a } / T )$ , where $\pmb { a } = ( 3 , 0 , 1 )$ , at temperatures of $T = 1 0 0$ , $T = 2$ and $T = 1$ . When the temperature is high (left), the distribution is uniform, whereas when the temperature is low (right), the distribution is “spiky”, with most of its mass on the largest element. Generated by softmax_plot.ipynb.

shows up, i.e., $\begin{array} { r } { y _ { c } = N _ { c } \triangleq \sum _ { n = 1 } ^ { N } \mathbb { I } \left( y _ { n } = c \right) } \end{array}$ . Now $\textbf {  { y } }$ is no longer one-hot, but is “multi-hot”, since it has a non-zero entry for every value of $c$ that was observed across all $N$ trials. The distribution of $\mathbf { \nabla } _ { \mathbf { \boldsymbol { y } } }$ is given by the multinomial distribution:

$$
\mathcal { M } ( { \pmb y } | N , \pmb \theta ) \triangleq \binom { N } { y _ { 1 } \dots y _ { C } } \prod _ { c = 1 } ^ { C } \theta _ { c } ^ { y _ { c } } = \binom { N } { N _ { 1 } \dots N _ { C } } \prod _ { c = 1 } ^ { C } \theta _ { c } ^ { N _ { c } }
$$

where $\theta _ { c }$ is the probability that side $c$ shows up, and

$$
\binom { N } { N _ { 1 } . . . N _ { C } } \triangleq \frac { N ! } { N _ { 1 } ! N _ { 2 } ! \cdot \cdot \cdot N _ { C } ! }
$$

is the multinomial coefficient, which is the number of ways to divide a set of size $\begin{array} { r } { N = \sum _ { c = 1 } ^ { C } N _ { c } } \end{array}$ into subsets with sizes $N _ { 1 }$ up to $N _ { C }$ . If $N = 1$ , the multinomial distribution becomes the categorical distribution.

# 2.5.2 Softmax function

In the conditional case, we can define

$$
p ( y | \mathbf { \boldsymbol { x } } , \pmb { \theta } ) = \mathrm { C a t } ( y | f ( \mathbf { \boldsymbol { x } } ; \pmb { \theta } ) )
$$

which we can also write as

$$
p ( \boldsymbol { y } | \mathbf { x } , \pmb { \theta } ) = \mathcal { M } ( \pmb { y } | 1 , f ( \mathbf { x } ; \pmb { \theta } ) )
$$

We require that $0 \leq f _ { c } ( \boldsymbol { x } ; \boldsymbol { \theta } ) \leq 1$ and $\begin{array} { r } { \sum _ { c = 1 } ^ { C } f _ { c } ( { \pmb x } ; { \pmb \theta } ) = 1 } \end{array}$ .

To avoid the requirement that $f$ directly predict a probability vector, it is common to pass the output from $f$ into the softmax function [Bri90], also called the multinomial logit. This is defined as follows:

$$
\mathrm { s o f t m a x } ( a ) \triangleq \left[ { \frac { e ^ { a _ { 1 } } } { \sum _ { c ^ { \prime } = 1 } ^ { C } e ^ { a _ { c ^ { \prime } } } } } , . . . , { \frac { e ^ { a _ { C } } } { \sum _ { c ^ { \prime } = 1 } ^ { C } e ^ { a _ { c ^ { \prime } } } } } \right]
$$

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

![](images/f8b3a3b906bb50f0ecad3f5a14656a55f71cf57093995f4dcceb5cbd71ee698e.jpg)  
Figure 2.13: Logistic regression on the 3-class, 2-feature version of the Iris dataset. Adapted from Figure of 4.25 [Gér19]. Generated by iris_logreg.ipynb.

This maps $\mathbb { R } ^ { C }$ to $[ 0 , 1 ] ^ { C }$ , and satisfies the constraints that $0 \leq \mathrm { s o f t m a x } ( \pmb { a } ) _ { c } \leq 1$ and $\textstyle \sum _ { c = 1 } ^ { C }$ $\mathrm { s o f t m a x } ( \pmb { a } ) _ { c } =$ 1. The inputs to the softmax, $\pmb { a } = f ( \pmb { x } ; \pmb { \theta } )$ , are called logits, and are a generalization of the log odds. The softmax function is so-called since it acts a bit like the argmax function. To see this, let us divide each $\boldsymbol { a } _ { c }$ by a constant $T$ called the temperature.8 Then as $T  0$ , we find

$$
\operatorname { s o f t m a x } ( { \pmb a } / T ) _ { c } = { \left\{ \begin{array} { l l } { 1 . 0 } & { { \mathrm { i f ~ } } c = \operatorname { a r g m a x } _ { c ^ { \prime } } a _ { c ^ { \prime } } } \\ { 0 . 0 } & { { \mathrm { o t h e r w i s e } } } \end{array} \right. }
$$

In other words, at low temperatures, the distribution puts most of its probability mass in the most probable state (this is called winner takes all), whereas at high temperatures, it spreads the mass uniformly. See Figure 2.12 for an illustration.

# 2.5.3 Multiclass logistic regression

If we use a linear predictor of the form $f ( { \pmb x } ; { \pmb \theta } ) = \mathbf { W } { \pmb x } + { \pmb b }$ , where $\mathbf { W }$ is a $C \times D$ matrix, and $^ { b }$ is a $C$ -dimensional bias vector, the final model becomes

$$
p ( y | \mathbf { \boldsymbol { x } } ; \theta ) = \mathrm { C a t } ( y | \mathrm { s o f t m a x } ( \mathbf { W } \mathbf { \boldsymbol { x } } + b ) )
$$

Let $\pmb { a } = \mathbf { W } \pmb { x } + \pmb { b }$ be the $C$ -dimensional vector of logits. Then we can rewrite the above as follows:

$$
p ( y = c | \mathbf { \boldsymbol { x } } ; \mathbf { \boldsymbol { \theta } } ) = \frac { e ^ { a _ { c } } } { \sum _ { c ^ { \prime } = 1 } ^ { C } e ^ { a _ { c ^ { \prime } } } }
$$

This is known as multinomial logistic regression.

If we have just two classes, this reduces to binary logistic regression. To see this, note that

$$
\operatorname { s o f t m a x } ( a ) _ { 0 } = { \frac { e ^ { a _ { 0 } } } { e ^ { a _ { 0 } } + e ^ { a _ { 1 } } } } = { \frac { 1 } { 1 + e ^ { a _ { 1 } - a _ { 0 } } } } = \sigma ( a _ { 0 } - a _ { 1 } )
$$

so we can just train the model to predict $a = a _ { 1 } - a _ { 0 }$ . This can be done with a single weight vector $\pmb { w }$ ; if we use the multi-class formulation, we will have two weight vectors, ${ \pmb w } _ { 0 }$ and ${ \pmb w } _ { 1 }$ . Such a model is over-parameterized, which can hurt interpretability, but the predictions will be the same.

We discuss this in more detail in Section 10.3. For now, we just give an example. Figure 2.13 shows what happens when we fit this model to the 3-class iris dataset, using just 2 features. We see that the decision boundaries between each class are linear. We can create nonlinear boundaries by transforming the features (e.g., using polynomials), as we discuss in Section 10.3.1.

# 2.5.4 Log-sum-exp trick

In this section, we discuss one important practical detail to pay attention to when working with the softmax distribution. Suppose we want to compute the normalized probability $p _ { c } = p ( y = c | \mathbf { x } )$ , which is given by

$$
p _ { c } = { \frac { e ^ { a _ { c } } } { Z ( { \bf a } ) } } = { \frac { e ^ { a _ { c } } } { \sum _ { c ^ { \prime } = 1 } ^ { C } e ^ { a _ { c ^ { \prime } } } } }
$$

where $\pmb { a } = f ( \pmb { x } ; \pmb { \theta } )$ are the logits. We might encounter numerical problems when computing the partition function $Z$ . For example, suppose we have 3 classes, with logits ${ \pmb a } = ( 0 , 1 , 0 )$ . Then we find $Z = e ^ { 0 } + e ^ { 1 } + e ^ { 0 } = 4 . 7 1$ . But now suppose $\pmb { a } = ( 1 0 0 0 , 1 0 0 1 , 1 0 0 0 )$ ; we find $Z = \infty$ , since on a computer, even using 64 bit precision, $\mathtt { n p . e x p ( 1 0 0 0 ) = i n f }$ . Similarly, suppose $\pmb { a } = ( - 1 0 0 0 , - 9 9 9 , - 1 0 0 0 )$ ; now we find $Z = 0$ , since $\mathtt { n p . e x p } ( - 1 0 0 0 ) { = } 0$ . To avoid numerical problems, we can use the following identity:

$$
\log \sum _ { c = 1 } ^ { C } \exp ( a _ { c } ) = m + \log \sum _ { c = 1 } ^ { C } \exp ( a _ { c } - m )
$$

This holds for any $m$ . It is common to use $m = \operatorname* { m a x } _ { c } a _ { c }$ which ensures that the largest value you exponentiate will be zero, so you will definitely not overflow, and even if you underflow, the answer will be sensible. This is known as the log-sum-exp trick. We use this trick when implementing the lse function:

$$
\mathrm { l s e } ( { \pmb a } ) \triangleq \mathrm { l o g } \sum _ { c = 1 } ^ { C } \mathrm { e x p } ( a _ { c } )
$$

We can use this to compute the probabilities from the logits:

$$
p ( y = c | \pmb { x } ) = \exp ( a _ { c } - \mathrm { l s e } ( \pmb { a } ) )
$$

We can then pass this to the cross-entropy loss, defined in Equation (5.41).

However, to save computational effort, and for numerical stability, it is quite common to modify the cross-entropy loss so that it takes the logits $\textbf { \em a }$ as inputs, instead of the probability vector $\mathbf { \nabla } _ { \mathbf { p } }$ . For example, consider the binary case. The CE loss for one example is

$$
\mathcal { L } = - \left[ \mathbb { I } \left( y = 0 \right) \log p _ { 0 } + \mathbb { I } \left( y = 1 \right) \log p _ { 1 } \right]
$$

where

$$
\begin{array} { r l } & { \log p _ { 1 } = \log \left( \displaystyle \frac { 1 } { 1 + \exp ( - a ) } \right) = \log ( 1 ) - \log ( 1 + \exp ( - a ) ) = 0 - \log ( [ 0 , - a ] ) } \\ & { \log p _ { 0 } = 0 - \mathrm { l s e } ( [ 0 , + a ] ) } \end{array}
$$

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

# 2.6 Univariate Gaussian (normal) distribution

The most widely used distribution of real-valued random variables $y \in \mathbb { R }$ is the Gaussian distribution, also called the normal distribution (see Section 2.6.4 for a discussion of these names).

# 2.6.1 Cumulative distribution function

We define the cumulative distribution function or cdf of a continuous random variable $Y$ as follows:

$$
P ( y ) \triangleq \operatorname* { P r } ( Y \leq y )
$$

(Note that we use a capital $P$ to represent the cdf.) Using this, we can compute the probability of being in any interval as follows:

$$
\operatorname* { P r } ( a < Y \leq b ) = P ( b ) - P ( a )
$$

Cdf’s are monotonically non-decreasing functions.

The cdf of the Gaussian is defined by

$$
\Phi ( y ; \mu , \sigma ^ { 2 } ) \triangleq \int _ { - \infty } ^ { y } \mathcal { N } ( z | \mu , \sigma ^ { 2 } ) d z
$$

See Figure 2.2a for a plot. Note that the cdf of the Gaussian is often implemented using $\Phi ( y ; \mu , \sigma ^ { 2 } ) =$ ${ \textstyle \frac { 1 } { 2 } } [ 1 + \mathrm { e r f } ( z / \sqrt { 2 } ) ]$ , where $z = ( y - \mu ) / \sigma$ and $\mathrm { e r f } ( u )$ is the error function, defined as

$$
\operatorname { e r f } ( u ) \triangleq { \frac { 2 } { \sqrt { \pi } } } \int _ { 0 } ^ { u } e ^ { - t ^ { 2 } } d t
$$

The parameter $\mu$ encodes the mean of the distribution, which is the same as the mode, since the distribution is unimodal. The parameter $\sigma ^ { 2 }$ encodes the variance. (Sometimes we talk about the precision of a Gaussian, which is the inverse variance, denoted $\lambda = 1 / \sigma ^ { 2 }$ .) When $\mu = 0$ and $\sigma = 1$ , the Gaussian is called the standard normal distribution.

If $P$ is the cdf of $Y$ , then $P ^ { - 1 } ( q )$ is the value such that $p ( Y \leq y _ { q } ) = q$ ; this is called the ’th $y _ { q }$ $q$ quantile of $P$ . The value $P ^ { - 1 } ( 0 . 5 )$ is the median of the distribution, with half of the probability mass on the left, and half on the right. The values $P ^ { - 1 } ( 0 . 2 5 )$ and $P ^ { - 1 } ( 0 . 7 5 )$ are the lower and upper quartiles.

For example, let $\Phi$ be the cdf of the Gaussian distribution $\mathcal { N } ( 0 , 1 )$ , and $\Phi ^ { - 1 }$ be the inverse cdf (also known as the probit function). Then points to the left of $\Phi ^ { - 1 } ( \alpha / 2 )$ contain $\alpha / 2$ of the probability mass, as illustrated in Figure 2.2b. By symmetry, points to the right of $\Phi ^ { - 1 } ( 1 - \alpha / 2 )$ also contain $\alpha / 2$ of the mass. Hence the central interval $( \Phi ^ { - 1 } ( \alpha / 2 ) , \Phi ^ { - 1 } ( 1 - \alpha / 2 ) )$ contains $1 - \alpha$ of the mass. If we set $\alpha = 0 . 0 5$ , the central $9 5 \%$ interval is covered by the range

$$
( \Phi ^ { - 1 } ( 0 . 0 2 5 ) , \Phi ^ { - 1 } ( 0 . 9 7 5 ) ) = ( - 1 . 9 6 , 1 . 9 6 )
$$

If the distribution is ${ \mathcal { N } } ( \mu , \sigma ^ { 2 } )$ , then the $9 5 \%$ interval becomes $( \mu - 1 . 9 6 \sigma , \mu + 1 . 9 6 \sigma )$ . This is often approximated by writing $\mu \pm 2 \sigma$ .

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

# 2.6.2 Probability density function

We define the probability density function or pdf as the derivative of the cdf:

$$
p ( y ) \triangleq { \frac { d } { d y } } P ( y )
$$

The pdf of the Gaussian is given by

$$
\mathcal { N } ( y | \mu , \sigma ^ { 2 } ) \triangleq \frac { 1 } { \sqrt { 2 \pi \sigma ^ { 2 } } } e ^ { - \frac { 1 } { 2 \sigma ^ { 2 } } ( y - \mu ) ^ { 2 } }
$$

where $\scriptstyle { \sqrt { 2 \pi \sigma ^ { 2 } } }$ is the normalization constant needed to ensure the density integrates to 1 (see Exercise 2.12). See Figure 2.2b for a plot.

Given a pdf, we can compute the probability of a continuous variable being in a finite interval as follows:

$$
\operatorname* { P r } ( a < Y \leq b ) = \int _ { a } ^ { b } p ( y ) d y = P ( b ) - P ( a )
$$

As the size of the interval gets smaller, we can write

$$
\operatorname* { P r } ( y \leq Y \leq y + d y ) \approx p ( y ) d y
$$

Intuitively, this says the probability of $Y$ being in a small interval around $y$ is the density at $y$ times the width of the interval. One important consequence of the above result is that the pdf at a point can be larger than 1. For example, $\mathcal { N } ( 0 | 0 , 0 . 1 ) = 3 . 9 9$ .

We can use the pdf to compute the mean, or expected value, of the distribution:

$$
\mathbb { E } \left[ Y \right] \triangleq \int _ { y } y p ( y ) d y
$$

For a Gaussian, we have the familiar result that $\mathbb { E } \left[ \mathcal { N } ( \cdot | \mu , \sigma ^ { 2 } ) \right] = \mu$ . (Note, however, that for some distributions, this integral is not finite, so the mean is not defined.)

We can also use the pdf to compute the variance of a distribution. This is a measure of the “spread”, and is often denoted by $\sigma ^ { 2 }$ . The variance is defined as follows:

$$
\begin{array} { l } { \displaystyle \mathbb { V } \left[ Y \right] \triangleq \mathbb { E } \left[ ( Y - \mu ) ^ { 2 } \right] = \int ( y - \mu ) ^ { 2 } p ( y ) d y } \\ { \displaystyle = \int y ^ { 2 } p ( y ) d y + \mu ^ { 2 } \int p ( y ) d y - 2 \mu \int y p ( y ) d y = \mathbb { E } \left[ Y ^ { 2 } \right] - \mu ^ { 2 } } \end{array}
$$

from which we derive the useful result

$$
\mathbb { E } \left[ Y ^ { 2 } \right] = \sigma ^ { 2 } + \mu ^ { 2 }
$$

The standard deviation is defined as

$$
\operatorname { s t d } \left[ Y \right] \triangleq { \sqrt { \mathbb { V } \left[ Y \right] } } = \sigma
$$

(The standard deviation can be more intepretable than the variance since it has the same units as $Y$ itself.) For a Gaussian, we have the familiar result that std $\left\lfloor \mathcal { N } ( \cdot | \mu , \sigma ^ { 2 } ) \right\rfloor = \sigma$ .

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

![](images/eb9c98c2785f268df5f4801efd28af1bf527b8ed74b1b325d6a8010c65d1cf59.jpg)  
Figure 2.14: Linear regression using Gaussian output with mean $\mu ( x ) \ = \ b + w x$ and (a) fixed variance $\sigma ^ { 2 }$ (homoskedastic) or (b) input-dependent variance $\sigma ( x ) ^ { 2 }$ (heteroscedastic). Generated by linreg_1d_hetero_tfp.ipynb.

# 2.6.3 Regression

So far we have been considering the unconditional Gaussian distribution. In some cases, it is helpful to make the parameters of the Gaussian be functions of some input variables, i.e., we want to create a conditional density model of the form

$$
p ( \boldsymbol { y } | \mathbf { x } ; \boldsymbol { \theta } ) = \mathcal { N } ( \boldsymbol { y } | f _ { \mu } ( \mathbf { x } ; \boldsymbol { \theta } ) , f _ { \sigma } ( \mathbf { x } ; \boldsymbol { \theta } ) ^ { 2 } )
$$

where $f _ { \mu } ( \pmb { x } ; \pmb { \theta } ) \in \mathbb { R }$ predicts the mean, and $f _ { \sigma } ( \pmb { x } ; \pmb { \theta } ) ^ { 2 } \in \mathbb { R } _ { + }$ predicts the variance.

It is common to assume that the variance is fixed, and is independent of the input. This is called homoscedastic regression. Furthermore it is common to assume the mean is a linear function of the input. The resulting model is called linear regression:

$$
p ( \boldsymbol { y } | \mathbf { \boldsymbol { x } } ; \mathbf { \boldsymbol { \theta } } ) = \mathcal { N } ( \boldsymbol { y } | \mathbf { \boldsymbol { w } } ^ { \top } \mathbf { \boldsymbol { x } } + b , \sigma ^ { 2 } )
$$

where $\pmb \theta = ( \pmb w , b , \sigma ^ { 2 } )$ . See Figure 2.14(a) for an illustration of this model in 1d. and Section 11.2 for more details on this model.

However, we can also make the variance depend on the input; this is called heteroskedastic regression. In the linear regression setting, we have

$$
p ( y | \mathbf { x } ; \pmb { \theta } ) = \mathcal { N } ( y | \pmb { w } _ { \mu } ^ { \top } \pmb { x } + b , \sigma _ { + } ( \pmb { w } _ { \sigma } ^ { \top } \pmb { x } ) )
$$

where $\pmb \theta = ( \pmb w _ { \mu } , \pmb w _ { \sigma } )$ are the two forms of regression weights, and

$$
\sigma _ { + } ( a ) = \log ( 1 + e ^ { a } )
$$

is the softplus function, that maps from $\mathbb { R }$ to $\mathbb { R } _ { + }$ , to ensure the predicted standard deviation is non-negative. See Figure 2.14(b) for an illustration of this model in 1d.

Note that Figure 2.14 plots the $9 5 \%$ predictive interval, $[ \mu ( x ) - 2 \sigma ( x ) , \mu ( x ) + 2 \sigma ( x ) ]$ . This is the uncertainty in the predicted observation $y$ given $_ { x }$ , and captures the variability in the blue dots. By contrast, the uncertainty in the underlying (noise-free) function is represented by $\sqrt { \mathbb { V } \left[ f _ { \mu } ( \pmb { x } ; \pmb { \theta } ) \right] }$ , which does not involve the $\sigma$ term; now the uncertainty is over the parameters $\pmb \theta$ , rather than the output $y$ . See Section 11.7 for details on how to model parameter uncertainty.

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

# 2.6.4 Why is the Gaussian distribution so widely used?

The Gaussian distribution is the most widely used distribution in statistics and machine learning. There are several reasons for this. First, it has two parameters which are easy to interpret, and which capture some of the most basic properties of a distribution, namely its mean and variance. Second, the central limit theorem (Section 2.8.6) tells us that sums of independent random variables have an approximately Gaussian distribution, making it a good choice for modeling residual errors or “noise”. Third, the Gaussian distribution makes the least number of assumptions (has maximum entropy), subject to the constraint of having a specified mean and variance, as we show in Section 3.4.4; this makes it a good default choice in many cases. Finally, it has a simple mathematical form, which results in easy to implement, but often highly effective, methods, as we will see in Section 3.2.

From a historical perspective, it’s worth remarking that the term “Gaussian distribution” is a bit misleading, since, as Jaynes [Jay03, p241] notes: “The fundamental nature of this distribution and its main properties were noted by Laplace when Gauss was six years old; and the distribution itself had been found by de Moivre before Laplace was born”. However, Gauss popularized the use of the distribution in the 1800s, and the term “Gaussian” is now widely used in science and engineering.

The name “normal distribution” seems to have arisen in connection with the normal equations in linear regression (see Section 11.2.2.2). However, we prefer to avoid the term “normal”, since it suggests other distributions are “abnormal”, whereas, as Jaynes [Jay03] points out, it is the Gaussian that is abnormal in the sense that it has many special properties that are untypical of general distributions.

# 2.6.5 Dirac delta function as a limiting case

As the variance of a Gaussian goes to 0, the distribution approaches an infinitely narrow, but infinitely tall, “spike” at the mean. We can write this as follows:

$$
\operatorname* { l i m } _ { \sigma \to 0 } \mathcal { N } ( y | \mu , \sigma ^ { 2 } ) \to \delta ( y - \mu )
$$

where $\delta$ is the Dirac delta function, defined by

$$
\delta ( x ) = { \left\{ \begin{array} { l l } { + \infty } & { { \mathrm { ~ i f ~ } } x = 0 } \\ { 0 } & { { \mathrm { ~ i f ~ } } x \neq 0 } \end{array} \right. }
$$

where

$$
\int _ { - \infty } ^ { \infty } \delta ( x ) d x = 1
$$

A slight variant of this is to define

$$
\delta _ { y } ( x ) = { \left\{ \begin{array} { l l } { + \infty } & { { \mathrm { ~ i f ~ } } x = y } \\ { 0 } & { { \mathrm { ~ i f ~ } } x \neq y } \end{array} \right. }
$$

Note that we have

$$
\delta _ { y } ( x ) = \delta ( x - y )
$$

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

![](images/71c2b55693b8008eeb0492ea00e3caf667bbbdc88f6605d4e964482d86e6f0a4.jpg)  
Figure 2.15: (a) The pdf’s for a $\mathcal { N } ( 0 , 1 )$ , ${ \mathcal T } ( \mu = 0 , \sigma = 1 , \nu = 1 )$ , ${ \mathcal T } ( \mu = 0 , \sigma = 1 , \nu = 2 )$ , and Laplace $( 0 , 1 / \sqrt { 2 } )$ . The mean is $\boldsymbol { \theta }$ and the variance is $^ { 1 }$ for both the Gaussian and Laplace. When $\nu = 1$ , the Student is the same as the Cauchy, which does not have a well-defined mean and variance. (b) Log of these pdf’s. Note that the Student distribution is not log-concave for any parameter value, unlike the Laplace distribution. Nevertheless, both are unimodal. Generated by student_laplace_pdf_plot.ipynb.

The delta function distribution satisfies the following sifting property, which we will use later on:

$$
\int _ { - \infty } ^ { \infty } f ( y ) \delta ( x - y ) d y = f ( x )
$$

# 2.7 Some other common univariate distributions \*

In this section, we briefly introduce some other univariate distributions that we will use in this book.

# 2.7.1 Student $\scriptstyle t$ distribution

The Gaussian distribution is quite sensitive to outliers. A robust alternative to the Gaussian is the Student $t$ -distribution, which we shall call the Student distribution for short.9 Its pdf is as follows:

$$
\mathcal { T } ( y | \mu , \sigma ^ { 2 } , \nu ) \propto \left[ 1 + \frac { 1 } { \nu } \left( \frac { y - \mu } { \sigma } \right) ^ { 2 } \right] ^ { - ( \frac { \nu + 1 } { 2 } ) }
$$

where $\mu$ is the mean, $\sigma > 0$ is the scale parameter (not the standard deviation), and $\nu > 0$ is called the degrees of freedom (although a better term would be the degree of normality [Kru13], since large values of $\nu$ make the distribution act like a Gaussian).

![](images/6ceb7ae036127b42b3368743e9105300e313b565dbb4d457409cbac8b7742931.jpg)  
Figure 2.16: Illustration of the effect of outliers on fitting Gaussian, Student and Laplace distributions. (a) No outliers (the Gaussian and Student curves are on top of each other). (b) With outliers. We see that the Gaussian is more affected by outliers than the Student and Laplace distributions. Adapted from Figure 2.16 of [Bis06]. Generated by robust_pdf_plot.ipynb.

We see that the probability density decays as a polynomial function of the squared distance from the center, as opposed to an exponential function, so there is more probability mass in the tail than with a Gaussian distribution, as shown in Figure 2.15. We say that the Student distribution has heavy tails, which makes it robust to outliers.

To illustrate the robustness of the Student distribution, consider Figure 2.16. On the left, we show a Gaussian and a Student distribution fit to some data with no outliers. On the right, we add some outliers. We see that the Gaussian is affected a lot, whereas the Student hardly changes. We discuss how to use the Student distribution for robust linear regression in Section 11.6.2.

For later reference, we note that the Student distribution has the following properties:

$$
{ \mathrm { m e a n } } = \mu , { \mathrm { ~ m o d e } } = \mu , { \mathrm { ~ v a r } } = { \frac { \nu \sigma ^ { 2 } } { ( \nu - 2 ) } }
$$

The mean is only defined if $\nu > 1$ . The variance is only defined if $\nu > 2$ . For $\nu \gg 5$ , the Student distribution rapidly approaches a Gaussian distribution and loses its robustness properties. It is common to use $\nu = 4$ , which gives good performance in a range of problems [LLT89].

# 2.7.2 Cauchy distribution

If $\nu = 1$ , the Student distribution is known as the Cauchy or Lorentz distribution. Its pdf is defined by

$$
\mathcal { C } ( x | \mu , \gamma ) = \frac { 1 } { \gamma \pi } \left[ 1 + \left( \frac { x - \mu } { \gamma } \right) ^ { 2 } \right] ^ { - 1 }
$$

This distribution has very heavy tails compared to a Gaussian. For example, $9 5 \%$ of the values from a standard normal are between -1.96 and 1.96, but for a standard Cauchy they are between -12.7 and 12.7. In fact the tails are so heavy that the integral that defines the mean does not converge.

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

The half Cauchy distribution is a version of the Cauchy (with $\mu = 0$ ) that is “folded over” on itself, so all its probability density is on the positive reals. Thus it has the form

$$
\mathcal { C } _ { + } ( x | \gamma ) \triangleq \frac { 2 } { \pi \gamma } \left[ 1 + \left( \frac { x } { \gamma } \right) ^ { 2 } \right] ^ { - 1 }
$$

This is useful in Bayesian modeling, where we want to use a distribution over positive reals with heavy tails, but finite density at the origin.

# 2.7.3 Laplace distribution

Another distribution with heavy tails is the Laplace distribution $\cdot ^ { 1 0 }$ , also known as the double sided exponential distribution. This has the following pdf:

$$
{ \mathrm { L a p l a c e } } ( y | \mu , b ) \triangleq { \frac { 1 } { 2 b } } \exp \left( - { \frac { | y - \mu | } { b } } \right)
$$

See Figure 2.15 for a plot. Here $\mu$ is a location parameter and $b > 0$ is a scale parameter. This distribution has the following properties:

In Section 11.6.1, we discuss how to use the Laplace distribution for robust linear regression, and in Section 11.4, we discuss how to use the Laplace distribution for sparse linear regression.

# 2.7.4 Beta distribution

The beta distribution has support over the interval $[ 0 , 1 ]$ and is defined as follows:

$$
\operatorname { B e t a } ( x | a , b ) = { \frac { 1 } { B ( a , b ) } } x ^ { a - 1 } ( 1 - x ) ^ { b - 1 }
$$

where $B ( a , b )$ is the beta function, defined by

$$
B ( a , b ) \triangleq { \frac { \Gamma ( a ) \Gamma ( b ) } { \Gamma ( a + b ) } }
$$

where $\Gamma ( a )$ is the Gamma function defined by

$$
\Gamma ( a ) \triangleq \int _ { 0 } ^ { \infty } x ^ { a - 1 } e ^ { - x } d x
$$

See Figure 2.17a for plots of some beta distributions.

We require $a , b > 0$ to ensure the distribution is integrable (i.e., to ensure $B ( a , b )$ exists). If $a = b = 1$ , we get the uniform distribution. If $a$ and $b$ are both less than 1, we get a bimodal distribution with “spikes” at 0 and $1$ ; if $a$ and $b$ are both greater than 1, the distribution is unimodal. For later reference, we note that the distribution has the following properties (Exercise 2.8):

$$
{ \mathrm { m e a n } } = { \frac { a } { a + b } } , { \mathrm { ~ m o d e ~ } } = { \frac { a - 1 } { a + b - 2 } } , { \mathrm { ~ v a r } } = { \frac { a b } { ( a + b ) ^ { 2 } ( a + b + 1 ) } }
$$

![](images/1e2ce491614ca6219542fbe8603601d59830501becf68e0813a8c050caf05e32.jpg)  
Figure 2.17: (a) Some beta distributions. If $a < 1$ , we get a “spike” on the left, and if $b < 1$ , we get a “spike” on the right. if $a = b = 1$ , the distribution is uniform. If $a > 1$ and $b > 1$ , the distribution is unimodal. Generated by beta_dist_plot.ipynb. (b) Some gamma distributions. If $a \leq 1$ , the mode is at $\boldsymbol { \theta }$ , otherwise the mode is away from 0. As we increase the rate $b$ , we reduce the horizontal scale, thus squeezing everything leftwards and upwards. Generated by gamma_dist_plot.ipynb.

# 2.7.5 Gamma distribution

The gamma distribution is a flexible distribution for positive real valued rv’s, $x > 0$ . It is defined in terms of two parameters, called the shape $a > 0$ and the rate $b > 0$ :

$$
{ \mathrm { G a } } ( x | { \mathrm { s h a p e } } = a , { \mathrm { r a t e } } = b ) \triangleq { \frac { b ^ { a } } { \Gamma ( a ) } } x ^ { a - 1 } e ^ { - x b }
$$

Sometimes the distribution is parameterized in terms of the shape $a$ and the scale $s = 1 / b$ :

$$
\mathrm { G a } ( x | \mathrm { s h a p e } = a , \mathrm { s c a l e } = s ) \triangleq { \frac { 1 } { s ^ { a } \Gamma ( a ) } } x ^ { a - 1 } e ^ { - x / s }
$$

See Figure 2.17b for some plots of the gamma pdf. For reference, we note that the distribution has the following properties:

$$
{ \mathrm { m e a n } } = { \frac { a } { b } } , { \mathrm { ~ m o d e } } = { \frac { a - 1 } { b } } , { \mathrm { ~ v a r } } = { \frac { a } { b ^ { 2 } } }
$$

There are several distributions which are just special cases of the Gamma, which we discuss below.

• Exponential distribution. This is defined by

$$
\mathrm { E x p o n } ( x | \lambda ) \triangleq \mathrm { G a } ( x | \mathrm { s h a p e } = 1 , \mathrm { r a t e } = \lambda )
$$

This distribution describes the times between events in a Poisson process, i.e. a process in which events occur continuously and independently at a constant average rate $\lambda$ .

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

![](images/4a3b292db69a3d0f465b93813d4bd000a5869de4bfacc9ebfc213d6d52802e7d.jpg)  
Figure 2.18: Illustration of the (a) empirical pdf and (b) empirical cdf derived from a set of $N = 5$ samples. From https: // bit. ly/ 3hFgi0e . Used with kind permission of Mauro Escudero.

• Chi-squared distribution. This is defined by

$$
\chi _ { \nu } ^ { 2 } ( x ) \triangleq { \mathrm { G a } } ( x | { \mathrm { s h a p e } } = { \frac { \nu } { 2 } } , { \mathrm { r a t e } } = { \frac { 1 } { 2 } } )
$$

where $\nu$ is called the degrees of freedom. This is the distribution of the sum of squared Gaussian random variables. More precisely, if $Z _ { i } \sim \mathcal { N } ( 0 , 1 )$ , and $\begin{array} { r } { S = \sum _ { i = 1 } ^ { \nu } Z _ { i } ^ { 2 } } \end{array}$ , then $S \sim \chi _ { \nu } ^ { 2 }$ .

• The inverse Gamma distribution is defined as follows:

$$
\operatorname { I G } ( x | { \mathrm { s h a p e } } = a , { \mathrm { s c a l e } } = b ) \triangleq { \frac { b ^ { a } } { \Gamma ( a ) } } x ^ { - ( a + 1 ) } e ^ { - b / x }
$$

The distribution has these properties

$$
{ \mathrm { m e a n } } = { \frac { b } { a - 1 } } , { \mathrm { m o d e } } = { \frac { b } { a + 1 } } , { \mathrm { v a r } } = { \frac { b ^ { 2 } } { ( a - 1 ) ^ { 2 } ( a - 2 ) } }
$$

The mean only exists if $a > 1$ . The variance only exists if $a > 2$ . Note: if $X \sim { \mathrm { G a } } ( { \mathrm { s h a p e } } =$ $a , { \mathrm { r a t e } } = b$ ), then $1 / X \sim \mathrm { I G } ( { \mathrm { s h a p e } } = a , { \mathrm { s c a l e } } = b$ ). (Note that $b$ plays two different roles in this case.)

# 2.7.6 Empirical distribution

Suppose we have a set of $N$ samples $\mathcal { D } = \{ x ^ { ( 1 ) } , . . . , x ^ { ( N ) } \}$ , derived from a distribution $p ( X )$ , where $X \in \mathbb R$ . We can approximate the pdf using a set of delta functions (Section 2.6.5) or “spikes”, centered on these samples:

$$
\hat { p } _ { N } ( x ) = \frac { 1 } { N } \sum _ { n = 1 } ^ { N } \delta _ { x ^ { ( n ) } } ( x )
$$

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

This is called the empirical distribution of the dataset $\mathcal { D }$ . An example of this, with $N = 5$ , is shown in Figure 2.18(a).

The corresponding cdf is given by

$$
\hat { P } _ { N } ( x ) = \frac { 1 } { N } \sum _ { n = 1 } ^ { N } \mathbb { I } \left( x ^ { ( n ) } \leq x \right) = \frac { 1 } { N } \sum _ { n = 1 } ^ { N } u _ { x ^ { ( n ) } } ( x )
$$

where $u _ { y } ( x )$ is a step function at $y$ defined by

$$
u _ { y } ( x ) = { \left\{ \begin{array} { l l } { 1 } & { { \mathrm { ~ i f ~ } } x \geq y } \\ { 0 } & { { \mathrm { ~ i f ~ } } x < y } \end{array} \right. }
$$

This can be visualized as a “stair case”, as in Figure 2.18(b), where the jumps of height $1 / N$ occur at every sample.

# 2.8 Transformations of random variables \*

Suppose $\mathbf { \boldsymbol { x } } \sim p ( \mathbf { \boldsymbol { \mathbf { \mathit { \rho } } } } )$ is some random variable, and $\boldsymbol { y } = f ( \boldsymbol { x } )$ is some deterministic transformation of it.   
In this section, we discuss how to compute $p ( \pmb { y } )$ .

# 2.8.1 Discrete case

If $X$ is a discrete rv, we can derive the pmf for $Y$ by simply summing up the probability mass for all the $x$ ’s such that $f ( x ) = y$ :

$$
p _ { y } ( y ) = \sum _ { x : f ( x ) = y } p _ { x } ( x )
$$

For example, if $f ( X ) = 1$ if $X$ is even and $f ( X ) = 0$ otherwise, and $p _ { x } ( X )$ is uniform on the set $\{ 1 , \ldots , 1 0 \}$ , then $\begin{array} { r } { p _ { y } ( 1 ) = \sum _ { x \in \{ 2 , 4 , 6 , 8 , 1 0 \} } p _ { x } ( x ) = 0 . 5 } \end{array}$ , and hence $p _ { y } ( 0 ) = 0 . 5$ also. Note that in this example, $f$ is a many-to-one function.

# 2.8.2 Continuous case

If $X$ is continuous, we cannot use Equation (2.150) since $p _ { x } ( x )$ is a density, not a pmf, and we cannot sum up densities. Instead, we work with cdf’s, as follows:

$$
P _ { y } ( y ) \triangleq \operatorname* { P r } ( Y \leq y ) = \operatorname* { P r } ( f ( X ) \leq y ) = \operatorname* { P r } ( X \in \{ x | f ( x ) \leq y \} )
$$

If $f$ is invertible, we can derive the pdf of $y$ by differentiating the cdf, as we show below. If $f$ is not invertible, we can use numerical integration, or a Monte Carlo approximation.

# 2.8.3 Invertible transformations (bijections)

In this section, we consider the case of monotonic and hence invertible functions. (Note a function is invertible iff it is a bijector). With this assumption, there is a simple formula for the pdf of $y$ , as we will see. (This can be generalized to invertible, but non-monotonic, functions, but we ignore this case.)

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

![](images/5c2ab626ec6f75d55c6eb2ba27d8521ea03d6e9d085a710f2447bac248ec560d.jpg)  
Figure 2.19: (a) Mapping a uniform pdf through the function $f ( x ) = 2 x + 1$ . (b) Illustration of how two nearby points, $x$ and $x + d x$ , get mapped under $f$ . If $\textstyle { \frac { d y } { d x } } > 0$ , the function is locally increasing, but if $\begin{array} { r } { { \frac { d y } { d x } } < 0 } \end{array}$ , the function is locally decreasing. From [Jan18]. Used with kind permission of Eric Jang.

# 2.8.3.1 Change of variables: scalar case

We start with an example. Suppose $x \sim \mathrm { U n i f } ( 0 , 1 )$ , and $y = f ( x ) = 2 x + 1$ . This function stretches and shifts the probability distribution, as shown in Figure 2.19(a). Now let us zoom in on a point $x$ and another point that is infinitesimally close, namely $x + d x$ . We see this interval gets mapped to $( y , y + d y )$ . The probability mass in these intervals must be the same, hence $p ( x ) d x = p ( y ) d y$ , and so $p ( y ) = p ( x ) d x / d y$ . However, since it does not matter (in terms of probability preservation) whether $d x / d y > 0$ or $d x / d y < 0$ , we get

$$
p _ { y } ( y ) = p _ { x } ( x ) | \frac { d x } { d y } |
$$

Now consider the general case for any $p _ { x } ( x )$ and any monotonic function $f : \mathbb { R } \to \mathbb { R }$ . Let $g = f ^ { - 1 }$ , so $y = f ( x )$ and $x = g ( y )$ . If we assume that $f : \mathbb { R } \to \mathbb { R }$ is monotonically increasing we get

$$
P _ { y } ( y ) = \operatorname* { P r } ( f ( X ) \leq y ) = \operatorname* { P r } ( X \leq f ^ { - 1 } ( y ) ) = P _ { x } ( f ^ { - 1 } ( y ) ) = P _ { x } ( g ( y ) )
$$

Taking derivatives we get

$$
p _ { y } ( y ) \triangleq { \frac { d } { d y } } P _ { y } ( y ) = { \frac { d } { d y } } P _ { x } ( x ) = { \frac { d x } { d y } } { \frac { d } { d x } } P _ { x } ( x ) = { \frac { d x } { d y } } p _ { x } ( x )
$$

We can derive a similar expression (but with opposite signs) for the case where $f$ is monotonically decreasing. To handle the general case we take the absolute value to get

$$
p _ { y } ( y ) = p _ { x } \left( g ( y ) \right) \big | \frac { d } { d y } g ( y ) \big |
$$

This is called change of variables formula.

# 2.8.3.2 Change of variables: multivariate case

We can extend the previous results to multivariate distributions as follows. Let $f$ be an invertible function that maps $\mathbb { R } ^ { n }$ to $\mathbb { R } ^ { n }$ , with inverse $\pmb { g }$ . Suppose we want to compute the pdf of $\boldsymbol { y } = \boldsymbol { f } ( \boldsymbol { x } )$ . By

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

![](images/c7e4fde35e3fca6e5dbd94e01298b613e11cda6f1ac80ad3781e04636f8bce24.jpg)  
Figure 2.20: Illustration of an affine transformation applied to a unit square, $f ( { \pmb x } ) = { \bf A } { \pmb x } + { \pmb b }$ . (a) Here $\mathbf { A } = \mathbf { I }$ . (b) Here $\mathbf { \nabla } _ { b } = \mathbf { 0 }$ . From [Jan18]. Used with kind permission of Eric Jang.

analogy with the scalar case, we have

$$
p _ { y } ( { \pmb y } ) = p _ { x } \left( { \pmb g } ( { \pmb y } ) \right) \big | \operatorname* { d e t } \left[ { \bf J } _ { g } ( { \pmb y } ) \right] \big |
$$

where $\begin{array} { r } { \mathbf { J } _ { g } = \frac { d g ( \pmb { y } ) } { d \pmb { y } ^ { \top } } } \end{array}$ is the Jacobian of $\pmb { g }$ , and $| \operatorname* { d e t } \mathbf { J } ( \pmb { y } ) |$ is the absolute value of the determinant of $\mathbf { J }$ evaluated at $\textbf {  { y } }$ . (See Section 7.8.5 for a discussion of Jacobians.) In Exercise 3.6 you will use this formula to derive the normalization constant for a multivariate Gaussian.

Figure 2.20 illustrates this result in 2d, for the case where $f ( { \pmb x } ) = { \bf A } { \pmb x } + { \pmb b }$ , where $\mathbf { A } = { \binom { a } { b } } \mathbf { \binom { c } { d } }$ We see that the area of the unit square changes by a factor of $\operatorname* { d e t } ( \mathbf { A } ) = a d - b c$ , which is the area of the parallelogram.

As another example, consider transforming a density from Cartesian coordinates ${ \pmb x } = ( x _ { 1 } , x _ { 2 } )$ to polar coordinates $\pmb { y } = \pmb { f } ( x _ { 1 } , x _ { 2 } )$ , so $\pmb { g } ( r , \theta ) = ( r \cos \theta , r \sin \theta )$ . Then

$$
{ \begin{array} { r l } { \mathbf { J } _ { g } = ( { \frac { \partial x _ { 1 } } { \partial r } }  } & { { \frac { \partial x _ { 1 } } { \partial \theta } } } \\ {  { \frac { \partial x _ { 2 } } { \partial r } }  } & { { \frac { \partial x _ { 2 } } { \partial \theta } } ) = { \binom { \cos \theta } { \sin \theta } } \quad r \cos \theta } \\ { | \operatorname* { d e t } ( \mathbf { J } _ { g } ) | = | r \cos ^ { 2 } \theta + r \sin ^ { 2 } \theta | = | r | } \end{array} }
$$

Hence

$$
p _ { r , \theta } ( r , \theta ) = p _ { x _ { 1 } , x _ { 2 } } ( r \cos \theta , r \sin \theta ) r
$$

To see this geometrically, notice that the area of the shaded patch in Figure 2.21 is given by

$$
\operatorname* { P r } ( r \leq R \leq r + d r , \theta \leq \Theta \leq \theta + d \theta ) = p _ { r , \theta } ( r , \theta ) d r d \theta
$$

In the limit, this is equal to the density at the center of the patch times the size of the patch, which is given by $r$ dr $d \theta$ . Hence

$$
p _ { r , \theta } ( r , \theta ) \ d r \ d \theta = p _ { x _ { 1 } , x _ { 2 } } ( r \cos \theta , r \sin \theta ) \ r \ d r \ d \theta
$$

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

![](images/af3c6cfc781ba12570cea7ba7bd995a4dba98bf09ea102cb6a6d83d9c429ddbd.jpg)  
Figure 2.21: Change of variables from polar to Cartesian. The area of the shaded patch is r dr dθ. Adapted from Figure 3.16 of [Ric95].

# 2.8.4 Moments of a linear transformation

Suppose $f$ is an affine function, so $\pmb { y } = \mathbf { A } \pmb { x } + \pmb { b }$ . In this case, we can easily derive the mean and covariance of $\textbf {  { y } }$ as follows. First, for the mean, we have

$$
\mathbb { E } \left[ \pmb { y } \right] = \mathbb { E } \left[ \mathbf { A } \pmb { x } + \pmb { b } \right] = \mathbf { A } \pmb { \mu } + \pmb { b }
$$

where $\pmb { \mu } = \mathbb { E } \left[ \pmb { x } \right]$ . If $f$ is a scalar-valued function, $f ( { \pmb x } ) = { \pmb a } ^ { 1 } { \pmb x } + b$ , the corresponding result is

$$
\mathbb { E } \left[ \pmb { a } ^ { \mathsf { T } } \pmb { x } + b \right] = \pmb { a } ^ { \mathsf { T } } \pmb { \mu } + b
$$

For the covariance, we have

$$
\operatorname { C o v } \left[ \pmb { y } \right] = \operatorname { C o v } \left[ \mathbf { A } \pmb { x } + \pmb { b } \right] = \mathbf { A } \pmb { \Sigma } \mathbf { A } ^ { \top }
$$

where $\pmb { \Sigma } = \mathrm { C o v } \left[ \pmb { x } \right]$ . We leave the proof of this as an exercise.

As a special case, if $y = a ^ { \mathsf { T } } x + b$ , we get

$$
\mathbb { V } \left[ \boldsymbol { y } \right] = \mathbb { V } \left[ \boldsymbol { a } ^ { \top } \boldsymbol { x } + \boldsymbol { b } \right] = \boldsymbol { a } ^ { \top } \boldsymbol { \Sigma } \boldsymbol { a }
$$

For example, to compute the variance of the sum of two scalar random variables, we can set $\pmb { a } = \lfloor 1 , 1 \rfloor$ to get

$$
\begin{array} { r l } & { \mathbb { V } \left[ x _ { 1 } + x _ { 2 } \right] = \left( 1 \quad 1 \right) \binom { \sum _ { 1 1 } \quad \sum _ { 1 2 } } { \sum _ { 2 1 } \quad \sum _ { 2 2 } } \binom { 1 } { 1 } } \\ & { \qquad = \Sigma _ { 1 1 } + \Sigma _ { 2 2 } + 2 \Sigma _ { 1 2 } = \mathbb { V } \left[ x _ { 1 } \right] + \mathbb { V } \left[ x _ { 2 } \right] + 2 \mathrm { C o v } \left[ x _ { 1 } , x _ { 2 } \right] } \end{array}
$$

Note, however, that although some distributions (such as the Gaussian) are completely characterized by their mean and covariance, in general we must use the techniques described above to derive the full distribution of $\textbf {  { y } }$ .

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

$$
\begin{array}{c} \begin{array} { r l } { - \quad - \quad 1 } & { { } 1 \quad 2 \quad 3 \quad 4 \quad - \quad - } \\ { \quad 7 \quad 6 \quad 5 \quad - \quad - \quad - } & { { } - \quad - } & { { } - } \\ { - \quad 7 \quad 6 \quad 5 \quad - \quad - } & { { } - \quad - } & { { } - } \\ { - \quad - \quad 7 \quad 6 \quad 5 \quad - \quad - } & { { } - \quad - } & { { } - } \\ { - \quad - \quad 7 \quad 6 \quad 5 \quad - \quad - } & { { } - \quad - } \\ { - \quad - \quad - } & { { } 7 \quad 6 \quad 5 \quad - } & { { } - } \\ { - \quad - \quad - } & { { } - \quad 7 \quad 6 \quad 5 \quad - } & { { } - } \\ { - \quad - \quad - } & { { } - \quad 7 \quad 6 \quad 5 \quad 5 \quad - } \\ { - \quad - } & { { } - \quad - } & { { } 7 \quad 6 \quad 5 \quad - } \end{array} \left[ \begin{array} { l } { } { } \\ { { z _ { 0 } = x _ { 0 } y _ { 0 } = 5 } } \\ { { z _ { 1 } = x _ { 0 } y _ { 1 } + x _ { 1 } y _ { 0 } = 1 6 } } \\ { { z _ { 2 } = x _ { 0 } y _ { 2 } + x _ { 1 } y _ { 1 } + x _ { 2 } y _ { 0 } = 3 4 } } \\ { { z _ { 3 } = x _ { 1 } y _ { 2 } + x _ { 2 } y _ { 1 } + x _ { 3 } y _ { 0 } = 5 2 } } \\ { { z _ { 4 } = x _ { 2 } y _ { 2 } + x _ { 3 } y _ { 1 } = 4 5 } } \\ { { z _ { 5 } = x _ { 3 } y _ { 2 } = 2 8 } } \end{array} \right.  \end{array}
$$

Table 2.4: Discrete convolution of $\pmb { x } = [ 1 , 2 , 3 , 4 ]$ with $\pmb { y } = [ 5 , 6 , 7 ]$ to yield $\boldsymbol { z } = [ 5 , 1 6 , 3 4 , 5 2 , 4 5 , 2 8 ]$ . In general, $\begin{array} { r } { z _ { n } = \sum _ { k = - \infty } ^ { \infty } x _ { k } y _ { n - k } } \end{array}$ . We see that this operation consists of “flipping” $_ y$ and then “dragging” it over $_ { \pmb { x } }$ , multiplying elementwise, and adding up the results.

# 2.8.5 The convolution theorem

Let $y = x _ { 1 } + x _ { 2 }$ , where $x _ { 1 }$ and $x _ { 2 }$ are independent rv’s. If these are discrete random variables, we can compute the pmf for the sum as follows:

$$
p ( y = j ) = \sum _ { k } p ( x _ { 1 } = k ) p ( x _ { 2 } = j - k )
$$

for $j = \ldots , - 2 , - 1 , 0 , 1 , 2 , \ldots$

If $x _ { 1 }$ and $x _ { 2 }$ have pdf’s $p _ { 1 } ( x _ { 1 } )$ and $p _ { 2 } ( x _ { 2 } )$ , what is the distribution of $y$ ? The cdf for $y$ is given by

$$
P _ { y } ( y ^ { * } ) = \operatorname* { P r } ( y \leq y ^ { * } ) = \int _ { - \infty } ^ { \infty } p _ { 1 } ( x _ { 1 } ) \left[ \int _ { - \infty } ^ { y ^ { * } - x _ { 1 } } p _ { 2 } ( x _ { 2 } ) d x _ { 2 } \right] d x _ { 1 }
$$

where we integrate over the region $R$ defined by $x _ { 1 } + x _ { 2 } < y ^ { * }$ . Thus the pdf for $y$ is

$$
p ( y ) = \left[ { \frac { d } { d y ^ { * } } } P _ { y } ( y ^ { * } ) \right] _ { y ^ { * } = y } = \int p _ { 1 } ( x _ { 1 } ) p _ { 2 } ( y - x _ { 1 } ) d x _ { 1 }
$$

where we used the rule of differentiating under the integral sign:

$$
{ \frac { d } { d x } } \int _ { a ( x ) } ^ { b ( x ) } f ( t ) d t = f ( b ( x ) ) { \frac { d b ( x ) } { d x } } - f ( a ( x ) ) { \frac { d a ( x ) } { d x } }
$$

We can write Equation (2.170) as follows:

$$
p = p _ { 1 } \circledast p _ { 2 }
$$

where $\circledast$ represents the convolution operator. For finite length vectors, the integrals become sums, and convolution can be thought of as a “flip and drag” operation, as illustrated in Table 2.4. Consequently, Equation (2.170) is called the convolution theorem.

For example, suppose we roll two dice, so $p _ { 1 }$ and $p _ { 2 }$ are both the discrete uniform distributions

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

![](images/583733a248792201f3a8093c25d59e7b79fa77789f323b470b070e39b264c64a.jpg)  
Figure 2.22: Distribution of the sum of two dice rolls, i.e., $p ( y )$ where $y = x _ { 1 } + x _ { 2 }$ and $x _ { i } \sim \operatorname { U n i f } ( \{ 1 , 2 , . . . , 6 \} )$ . From https: // en. wikipedia. org/ wiki/ Probability_ distribution . Used with kind permission of Wikipedia author Tim Stellmach.

over $\{ 1 , 2 , \ldots , 6 \}$ . Let $y = x _ { 1 } + x _ { 2 }$ be the sum of the dice. We have

$$
{ \begin{array} { l } { p ( y = 2 ) = p ( x _ { 1 } = 1 ) p ( x _ { 2 } = 1 ) = { \frac { 1 } { 6 } } { \frac { 1 } { 6 } } = { \frac { 1 } { 3 6 } } } \\ { p ( y = 3 ) = p ( x _ { 1 } = 1 ) p ( x _ { 2 } = 2 ) + p ( x _ { 1 } = 2 ) p ( x _ { 2 } = 1 ) = { \frac { 1 } { 6 } } { \frac { 1 } { 6 } } + { \frac { 1 } { 6 } } { \frac { 1 } { 6 } } = { \frac { 2 } { 3 6 } } } \end{array} }
$$

Continuing in this way, we find $p ( y = 4 ) = 3 / 3 6$ , $p ( y = 5 ) = 4 / 3 6$ , $p ( y = 6 ) = 5 / 3 6$ , $p ( y = 7 ) = 6 / 3 6$ , $p ( y = 8 ) = 5 / 3 6$ , $p ( y = 9 ) = 4 / 3 6$ , $p ( y = 1 0 ) = 3 / 3 6$ , $p ( y = 1 1 ) = 2 / 3 6$ and $p ( y = 1 2 ) = 1 / 3 6$ . See Figure 2.22 for a plot. We see that the distribution looks like a Gaussian; we explain the reasons for this in Section 2.8.6.

We can also compute the pdf of the sum of two continuous rv’s. For example, in the case of Gaussians, where $x _ { 1 } \sim \mathcal { N } ( \pmb { \mu } _ { 1 } , \sigma _ { 1 } ^ { 2 } )$ and $x _ { 2 } \sim \mathcal { N } ( \mu _ { 2 } , \sigma _ { 2 } ^ { 2 } )$ , one can show (Exercise 2.4) that if $y = x _ { 1 } + x _ { 2 }$ then

$$
p ( y ) = { \mathcal { N } } ( x _ { 1 } | \mu _ { 1 } , \sigma _ { 1 } ^ { 2 } ) \otimes { \mathcal { N } } ( x _ { 2 } | \mu _ { 2 } , \sigma _ { 2 } ^ { 2 } ) = { \mathcal { N } } ( y | \mu _ { 1 } + \mu _ { 2 } , \sigma _ { 1 } ^ { 2 } + \sigma _ { 2 } ^ { 2 } )
$$

Hence the convolution of two Gaussians is a Gaussian.

# 2.8.6 Central limit theorem

Now consider $N _ { \mathcal { D } }$ random variables with pdf’s (not necessarily Gaussian) $p _ { n } ( x )$ , each with mean $\mu$ and variance $\sigma ^ { 2 }$ . We assume each variable is independent and identically distributed or iid for short, which means $X _ { n } \sim p ( X )$ are independent samples from the same distribution. Let $\begin{array} { r } { S _ { N _ { \mathcal { D } } } = \sum _ { n = 1 } ^ { N _ { \mathcal { D } } } X _ { n } } \end{array}$ be the sum of the rv’s. One can show that, as $N$ increases, the distribution of this sum approaches

$$
p ( S _ { N _ { \mathcal { D } } } = u ) = \frac { 1 } { \sqrt { 2 \pi N _ { \mathcal { D } } \sigma ^ { 2 } } } \exp \left( - \frac { ( u - N _ { \mathcal { D } } \mu ) ^ { 2 } } { 2 N _ { \mathcal { D } } \sigma ^ { 2 } } \right)
$$

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

![](images/a668520c8f83090fdaeca1e59f52876aab8c3cd05a9a723aa703d651d52e9a7b.jpg)  
Figure 2.23: The central limit theorem in pictures. We plot a histogram of $\begin{array} { r } { \hat { \mu } _ { N } ^ { s } = \frac { 1 } { N _ { \mathcal { D } } } \sum _ { n = 1 } ^ { N _ { \mathcal { D } } } x _ { n s } } \end{array}$ , where $x _ { n s } \sim \mathrm { B e t a } ( 1 , 5 )$ , for $s = 1 : 1 0 0 0 0$ . As $N _ { \mathcal { D } }  \infty$ , the distribution tends towards a Gaussian. (a) $N = 1$ . (b) $N = 5$ . Adapted from Figure 2.6 of [Bis06]. Generated by centralLimitDemo.ipynb.

Hence the distribution of the quantity

$$
Z _ { N _ { \mathcal { D } } } \triangleq \frac { S _ { N _ { \mathcal { D } } } - N _ { \mathcal { D } } \mu } { \sigma \sqrt { N _ { \mathcal { D } } } } = \frac { \overline { { X } } - \mu } { \sigma / \sqrt { N _ { \mathcal { D } } } }
$$

converges to the standard normal, where $\overline { { X } } = S _ { N } / N$ is the sample mean. This is called the central limit theorem. See e.g., [Jay03, p222] or [Ric95, p169] for a proof.

In Figure 2.23 we give an example in which we compute the sample mean of rv’s drawn from a beta distribution. We see that the sampling distribution of this mean rapidly converges to a Gaussian distribution.

# 2.8.7 Monte Carlo approximation

Suppose $_ { x }$ is a random variable, and $\boldsymbol { y } = f ( \boldsymbol { x } )$ is some function of $_ { x }$ . It is often difficult to compute the induced distribution $p ( \pmb { y } )$ analytically. One simple but powerful alternative is to draw a large number of samples from the $_ { x }$ ’s distribution, and then to use these samples (instead of the distribution) to approximate $p ( \pmb { y } )$ .

For example, suppose $x \sim \mathrm { U n i f } ( - 1 , 1 )$ and $y = f ( x ) = x ^ { 2 }$ . We can approximate $p ( y )$ by drawing many samples from $p ( x )$ (using a uniform random number generator), squaring them, and computing the resulting empirical distribution, which is given by

$$
p _ { S } ( y ) \triangleq \frac { 1 } { N _ { s } } \sum _ { s = 1 } ^ { N _ { s } } \delta ( y - y _ { s } )
$$

This is just an equally weighted “sum of spikes”, each centered on one of the samples (see Section 2.7.6). By using enough samples, we can approximate $p ( y )$ rather well. See Figure 2.24 for an illustration. This approach is called a Monte Carlo approximation to the distribution. (The term “Monte Carlo” comes from the name of a famous gambling casino in Monaco.) Monte Carlo techniques were

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022 first developed in the area of statistical physics — in particular, during development of the atomic bomb — but are now widely used in statistics and machine learning as well. More details can be found in the sequel to this book, [Mur23], as well as specialized books on the topic, such as [Liu01; RC04; KTB11; BZ20].

![](images/0673a134185562b1391cab4254b6d570c06b3bc4bb12f6eaa344192dafdb1049.jpg)  
Figure 2.24: Computing the distribution of $y \ = \ x ^ { 2 }$ , where $p ( x )$ is uniform (left). The analytic result is shown in the middle, and the Monte Carlo approximation is shown on the right. Generated by change_of_vars_demo1d.ipynb.

# 2.9 Exercises

Exercise 2.1 [Conditional independence $^ * ]$ (Source: Koller.)

a. Let $H \in \{ 1 , \ldots , K \}$ be a discrete random variable, and let $e _ { 1 }$ and $e _ { 2 }$ be the observed values of two other random variables $E _ { 1 }$ and $E _ { 2 }$ . Suppose we wish to calculate the vector

$$
\vec { P } ( H | e _ { 1 } , e _ { 2 } ) = ( P ( H = 1 | e _ { 1 } , e _ { 2 } ) , \dots , P ( H = K | e _ { 1 } , e _ { 2 } ) )
$$

Which of the following sets of numbers are sufficient for the calculation?

i. $P ( e _ { 1 } , e _ { 2 } )$ , $P ( H )$ , $P ( e _ { 1 } | H )$ , $P ( e _ { 2 } | H )$ ii. $P ( e _ { 1 } , e _ { 2 } )$ , $P ( H )$ , $P ( e _ { 1 } , e _ { 2 } | H )$ iii. $( e _ { 1 } | H ) , P ( e _ { 2 } | H ) , P ( H )$

b. Now suppose we now assume $E _ { 1 } \perp E _ { 2 } | H$ (i.e., $E _ { 1 }$ and $E _ { 2 } ^ { \prime }$ are conditionally independent given $H$ ). Which of the above 3 sets are sufficient now?

Show your calculations as well as giving the final result. Hint: use Bayes rule.

Exercise 2.2 [Pairwise independence does not imply mutual independence] We say that two random variables are pairwise independent if

$$
p ( X _ { 2 } | X _ { 1 } ) = p ( X _ { 2 } )
$$

and hence

$$
p ( X _ { 2 } , X _ { 1 } ) = p ( X _ { 1 } ) p ( X _ { 2 } | X _ { 1 } ) = p ( X _ { 1 } ) p ( X _ { 2 } )
$$

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

We say that $n$ random variables are mutually independent if

$$
p ( X _ { i } | X _ { S } ) = p ( X _ { i } ) \quad \forall S \subseteq \{ 1 , \dots , n \} \setminus \{ i \}
$$

and hence

$$
p ( X _ { 1 : n } ) = \prod _ { i = 1 } ^ { n } p ( X _ { i } )
$$

Show that pairwise independence between all pairs of variables does not necessarily imply mutual independence.   
It suffices to give a counter example.

Exercise 2.3 [Conditional independence iff joint factorizes \*] In the text we said $X \perp Y | Z$ iff

$$
p ( x , y | z ) = p ( x | z ) p ( y | z )
$$

for all $x , y , z$ such that $p ( z ) > 0$ . Now prove the following alternative definition: $X \perp Y | Z$ iff there exist functions $g$ and $h$ such that

$$
p ( x , y | z ) = g ( x , z ) h ( y , z )
$$

for all $x , y , z$ such that $p ( z ) > 0$ .

Exercise 2.4 [Convolution of two Gaussians is a Gaussian] Show that the convolution of two Gaussians is a Gaussian, i.e.,

$$
p ( y ) = { \mathcal { N } } ( x _ { 1 } | \mu _ { 1 } , \sigma _ { 1 } ^ { 2 } ) \otimes { \mathcal { N } } ( x _ { 2 } | \mu _ { 2 } , \sigma _ { 2 } ^ { 2 } ) = { \mathcal { N } } ( y | \mu _ { 1 } + \mu _ { 2 } , \sigma _ { 1 } ^ { 2 } + \sigma _ { 2 } ^ { 2 } )
$$

where $y = x _ { 1 } + x _ { 2 }$ , $x _ { 1 } \sim \mathcal { N } ( \mu _ { 1 } , \sigma _ { 1 } ^ { 2 } )$ and $x _ { 2 } \sim \mathcal { N } ( \mu _ { 2 } , \sigma _ { 2 } ^ { 2 } )$ .

Exercise 2.5 [Expected value of the minimum of two rv’s $^ *$ ]

Suppose $X , Y$ are two points sampled independently and uniformly at random from the interval $[ 0 , 1 ]$ . What is the expected location of the leftmost point?

Exercise 2.6 [Variance of a sum] Show that the variance of a sum is

$$
\mathbb { V } \left[ X + Y \right] = \mathbb { V } \left[ X \right] + \mathbb { V } \left[ Y \right] + 2 \mathrm { C o v } \left[ X , Y \right] ,
$$

where $\operatorname { C o v } \left[ X , Y \right]$ is the covariance between $X$ and $Y$ .

Exercise 2.7 [Deriving the inverse gamma density \*] Let $X \sim \operatorname { G a } ( a , b )$ , and $Y = 1 / X$ . Derive the distribution of $Y$ .

Exercise 2.8 [Mean, mode, variance for the beta distribution] Suppose $\theta \sim \operatorname { B e t a } ( a , b )$ . Show that the mean, mode and variance are given by

$$
{ \begin{array} { r l } & { \mathbb { E } \left[ \theta \right] = { \frac { a } { a + b } } } \\ & { \mathbb { V } \left[ \theta \right] = { \frac { a b } { \left( a + b \right) ^ { 2 } \left( a + b + 1 \right) } } } \\ & { { \mathrm { m o d e } } \left[ \theta \right] = { \frac { a - 1 } { a + b - 2 } } } \end{array} }
$$

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

Exercise 2.9 [Bayes rule for medical diagnosis \*]

After your yearly checkup, the doctor has bad news and good news. The bad news is that you tested positive for a serious disease, and that the test is 99% accurate (i.e., the probability of testing positive given that you have the disease is 0.99, as is the probability of testing negative given that you don’t have the disease). The good news is that this is a rare disease, striking only one in 10,000 people. What are the chances that you actually have the disease? (Show your calculations as well as giving the final result.)

# Exercise 2.10 [Legal reasoning]

(Source: Peter Lee.) Suppose a crime has been committed. Blood is found at the scene for which there is no innocent explanation. It is of a type which is present in $1 \%$ of the population.

a. The prosecutor claims: “There is a $1 \%$ chance that the defendant would have the crime blood type if he were innocent. Thus there is a 99% chance that he is guilty”. This is known as the prosecutor’s fallacy. What is wrong with this argument?   
b. The defender claims: “The crime occurred in a city of 800,000 people. The blood type would be found in approximately 8000 people. The evidence has provided a probability of just 1 in 8000 that the defendant is guilty, and thus has no relevance.” This is known as the defender’s fallacy. What is wrong with this argument?

Exercise 2.11 [Probabilities are sensitive to the form of the question that was used to generate the answer (Source: Minka.) My neighbor has two children. Assuming that the gender of a child is like a coin flip, it is most likely, a priori, that my neighbor has one boy and one girl, with probability $_ { 1 / 2 }$ . The other possibilities—two boys or two girls—have probabilities 1/4 and $1 / 4$ .

a. Suppose I ask him whether he has any boys, and he says yes. What is the probability that one child is a girl?   
b. Suppose instead that I happen to see one of his children run by, and it is a boy. What is the probability that the other child is a girl?

Exercise 2.12 [Normalization constant for a 1D Gaussian] The normalization constant for a zero-mean Gaussian is given by

$$
Z = \int _ { a } ^ { b } \exp \left( - { \frac { x ^ { 2 } } { 2 \sigma ^ { 2 } } } \right) d x
$$

where $a = - \infty$ and $b = \infty$ . To compute this, consider its square

$$
Z ^ { 2 } = \int _ { a } ^ { b } \int _ { a } ^ { b } \exp \left( - { \frac { x ^ { 2 } + y ^ { 2 } } { 2 \sigma ^ { 2 } } } \right) d x d y
$$

Let us change variables from cartesian $( x , y )$ to polar $( r , \theta )$ using $x \ = \ r \cos \theta$ and $y \ = \ r \sin \theta$ . Since $d x d y = r d r d \theta$ , and $c o s ^ { 2 } \theta + \sin ^ { 2 } \theta = 1$ , we have

$$
Z ^ { 2 } = \int _ { 0 } ^ { 2 \pi } \int _ { 0 } ^ { \infty } r \exp \left( - \frac { r ^ { 2 } } { 2 \sigma ^ { 2 } } \right) d r d \theta
$$

Evaluate this integral and hence show $Z = \sqrt { \sigma ^ { 2 } 2 \pi }$ . Hint 1: separate the integral into a product of two terms, the first of which (involving $d \theta$ ) is constant, so is easy. Hint 2: if $u = e ^ { - r ^ { 2 } / 2 \sigma ^ { 2 } }$ then $\begin{array} { r } { d u / d r = - \frac { 1 } { \sigma ^ { 2 } } r e ^ { - r ^ { 2 } / 2 \sigma ^ { 2 } } } \end{array}$ , so the second integral is also easy (since $\begin{array} { r } { \int u ^ { \prime } ( r ) d r = u ( r ) , } \end{array}$ ).

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

# 3 Probability: Multivariate Models

# 3.1 Joint distributions for multiple random variables

In this section, we discuss various ways to measure the dependence of one or more variables on each other.

# 3.1.1 Covariance

The covariance between two rv’s $X$ and $Y$ measures the degree to which $X$ and $Y$ are (linearly) related. Covariance is defined as

$$
\operatorname { C o v } \left[ X , Y \right] \triangleq \mathbb { E } \left[ ( X - \mathbb { E } \left[ X \right] ) ( Y - \mathbb { E } \left[ Y \right] ) \right] = \mathbb { E } \left[ X Y \right] - \mathbb { E } \left[ X \right] \mathbb { E } \left[ Y \right]
$$

If $_ { x }$ is a $D$ -dimensional random vector, its covariance matrix is defined to be the following symmetric, positive semi definite matrix:

$$
{ \begin{array} { r l } { \operatorname { C o v } \left[ \mathbf { x } \right] \triangleq \mathbb { E } \left[ \left( \mathbf { x } - \mathbb { E } \left[ \mathbf { x } \right] \right) ( \mathbf { x } - \mathbb { E } \left[ \mathbf { x } \right] ) ^ { \mathsf { T } } \right] \triangleq \Sigma } & { } \\ { \qquad \operatorname { V } \left[ X _ { 1 } \right] } & { \operatorname { C o v } \left[ X _ { 1 } , X _ { 2 } \right] } & { \cdots \quad \operatorname { C o v } \left[ X _ { 1 } , X _ { D } \right] } \\ { = { \left( \begin{array} { l l l l l } { \operatorname { C o v } \left[ X _ { 2 } , X _ { 1 } \right] } & { \operatorname { V } \left[ X _ { 2 } \right] } & { \cdots } & { \operatorname { C o v } \left[ X _ { 2 } , X _ { D } \right] } \\ { \vdots } & { \vdots } & { \ddots } & { \vdots } \\ { \operatorname { C o v } \left[ X _ { D } , X _ { 1 } \right] } & { \operatorname { C o v } \left[ X _ { D } , X _ { 2 } \right] } & { \cdots } & { \operatorname { V } \left[ X _ { D } \right] } \end{array} \right) } } \end{array} }
$$

from which we get the important result

$$
\mathbb { E } \left[ \pmb { x } \pmb { x } ^ { \top } \right] = \pmb { \Sigma } + \pmb { \mu } \pmb { \mu } ^ { \top }
$$

Another useful result is that the covariance of a linear transformation is given by

$$
\operatorname { C o v } \left[ \mathbf { A } \pmb { x } + \pmb { b } \right] = \mathbf { A } \mathrm { C o v } \left[ \pmb { x } \right] \mathbf { A } ^ { \top }
$$

as shown in Exercise 3.4.

The cross-covariance between two random vectors is defined as

$$
\operatorname { C o v } \left[ \pmb { x } , \pmb { y } \right] = \mathbb { E } \left[ ( \pmb { x } - \mathbb { E } \left[ \pmb { x } \right] ) ( \pmb { y } - \mathbb { E } \left[ \pmb { y } \right] ) ^ { \top } \right]
$$

![](images/149adf96a5b5b4136cca725a2c1f3d0598fd5346faaa3af3fa0300b47e5e6c75.jpg)  
Figure 3.1: Several sets of $( x , y )$ points, with the correlation coefficient of x and y for each set. Note that the correlation reflects the noisiness and direction of a linear relationship (top row), but not the slope of that relationship (middle), nor many aspects of nonlinear relationships (bottom). (Note: the figure in the center has a slope of 0 but in that case the correlation coefficient is undefined because the variance of $Y$ is zero.) From https: // en. wikipedia. org/ wiki/ Pearson_ correlation_ coefficient . Used with kind permission of Wikipedia author Imagecreator.

# 3.1.2 Correlation

Covariances can be between negative and positive infinity. Sometimes it is more convenient to work with a normalized measure, with a finite lower and upper bound. The (Pearson) correlation coefficient between $X$ and $Y$ is defined as

$$
\rho \triangleq \operatorname { c o r r } \left[ X , Y \right] \triangleq { \frac { \operatorname { C o v } \left[ X , Y \right] } { \sqrt { \mathbb { V } \left[ X \right] \mathbb { V } \left[ Y \right] } } }
$$

One can show (Exercise 3.2) that $- 1 \le \rho \le 1$ .

One can also show that corr $[ X , Y ] = 1$ if and only if $Y = a X + b$ (and $a > 0$ ) for some parameters $a$ and $b$ , i.e., if there is a linear relationship between $X$ and $Y$ (see Exercise 3.3). Intuitively one might expect the correlation coefficient to be related to the slope of the regression line, i.e., the coefficient $a$ in the expression $Y = a X + b$ . However, as we show in Equation (11.27), the regression coefficient is in fact given by $a = \operatorname { C o v } \left[ X , Y \right] / \mathbb { V } \left[ X \right]$ . In Figure 3.1, we show that the correlation coefficient can be 0 for strong, but nonlinear, relationships. (Compare to Figure 6.6.) Thus a better way to think of the correlation coefficient is as $a$ degree of linearity. (See correlation2d.ipynb for a demo to illustrate this idea.)

In the case of a vector $_ { x }$ of related random variables, the correlation matrix is given by

$$
\operatorname { c o r r } ( \pmb { x } ) = \left( \begin{array} { c c c c c } { 1 } & { \frac { \mathbb { E } [ ( X _ { 1 } - \mu _ { 1 } ) ( X _ { 2 } - \mu _ { 2 } ) ] } { \sigma _ { 1 } \sigma _ { 2 } } } & { \cdot . . } & { \frac { \mathbb { E } [ ( X _ { 1 } - \mu _ { 1 } ) ( X _ { D } - \mu _ { D } ) ] } { \sigma _ { 1 } \sigma _ { D } } } \\ { \frac { \mathbb { E } [ ( X _ { 2 } - \mu _ { 2 } ) ( X _ { 1 } - \mu _ { 1 } ) ] } { \sigma _ { 2 } \sigma _ { 1 } } } & { 1 } & { \cdot . . } & { \frac { \mathbb { E } [ ( X _ { 2 } - \mu _ { 2 } ) ( X _ { D } - \mu _ { D } ) ] } { \sigma _ { 2 } \sigma _ { D } } } \\ { \vdots } & { \vdots } & { \ddots } & { \vdots } \\ { \frac { \mathbb { E } [ ( X _ { D } - \mu _ { D } ) ( X _ { 1 } - \mu _ { 1 } ) ] } { \sigma _ { D } \sigma _ { 1 } } } & { \frac { \mathbb { E } [ ( X _ { D } - \mu _ { D } ) ( X _ { 2 } - \mu _ { 2 } ) ] } { \sigma _ { D } \sigma _ { 2 } } } & { \cdot . . } & { 1 } \end{array} \right)
$$

This can be written more compactly as

$$
\mathrm { c o r r } ( { \pmb x } ) = ( \mathrm { d i a g } ( { \bf K } _ { x x } ) ) ^ { - \frac { 1 } { 2 } } { \bf K } _ { x x } ( \mathrm { d i a g } ( { \bf K } _ { x x } ) ) ^ { - \frac { 1 } { 2 } }
$$

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

![](images/572a419de0faec83ed2c82af102ad574621afb181f6256d0e7df0fb2832a4b16.jpg)  
Figure 3.2: Examples of spurious correlation between causally unrelated time series. Consumption of ice cream (red) and violent crime rate (yellow). over time. From http: // icbseverywhere. com/ blog/ 2014/ 10/ the-logic-of-causal-conclusions/ . Used with kind permission of Barbara Drescher.

where ${ \bf K } _ { x x }$ is the auto-covariance matrix

$$
\mathbf { K } _ { x x } = \pmb { \Sigma } = \mathbb { E } \left[ ( \pmb { x } - \mathbb { E } \left[ \pmb { x } \right] ) ( \pmb { x } - \mathbb { E } \left[ \pmb { x } \right] ) ^ { \mathsf { T } } \right] = \mathbf { R } _ { x x } - \pmb { \mu } \pmb { \mu } ^ { \mathsf { T } }
$$

and $\mathbf { R } _ { x x } = \mathbb { E } \left[ \pmb { x } \pmb { x } ^ { \top } \right]$ is the autocorrelation matrix.

# 3.1.3 Uncorrelated does not imply independent

If $X$ and $Y$ are independent, meaning $p ( X , Y ) \ : = \ : p ( X ) p ( Y )$ , then $\mathrm { C o v } [ X , Y ] = 0$ , and hence corr $[ X , Y ] = 0$ . So independent implies uncorrelated. However, the converse is not true: uncorrelated does not imply independent. For example, let $X \sim U ( - 1 , 1 )$ and $Y = X ^ { 2 }$ . Clearly $Y$ is dependent on $X$ (in fact, $Y$ is uniquely determined by $X$ ), yet one can show (Exercise 3.1) that corr $[ X , Y ] = 0$ . Some striking examples of this fact are shown in Figure 3.1. This shows several data sets where there is clear dependence between $X$ and $Y$ , and yet the correlation coefficient is 0. A more general measure of dependence between random variables is mutual information, discussed in Section 6.3. This is zero only if the variables truly are independent.

# 3.1.4 Correlation does not imply causation

It is well known that “correlation does not imply causation”. For example, consider Figure 3.2. In red, we plot $x _ { 1 : T }$ , where $x _ { t }$ is the amount of ice cream sold in month $t$ . In yellow, we plot $y _ { 1 : T }$ , where $y _ { t }$ is the violent crime rate in month $t$ . (Quantities have been rescaled to make the plots overlap.) We see a strong correlation between these signals. Indeed, it is sometimes claimed that “eating ice cream causes murder” [Pet13]. Of course, this is just a spurious correlation, due to a hidden common cause, namely the weather. Hot weather increases ice cream sales, for obvious

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license reasons. Hot weather also increases violent crime; the reason for this is hotly (ahem) debated; some claim it is due to an increase in anger [And01], but other claim it is merely due to more people being outside [Ash18], where most murders occur.

![](images/035187209f576e922b49c3f7979e95bfb9b201430797f555ad8f209b1726f41a.jpg)  
Figure 3.3: Illustration of Simpson’s paradox on the Iris dataset. (Left) Overall, y (sepal width) decreases with $x$ (sepal length). (Right) Within each group, $y$ increases with $x$ . Generated by simpsons_paradox.ipynb.

Another famous example concerns the positive correlation between birth rates and the presence of storks (a kind of bird). This has given rise to the urban legend that storks deliver babies [Mat00]. Of course, the true reason for the correlation is more likely due to hidden factors, such as increased living standards and hence more food. Many more amusing examples of such spurious correlations can be found in [Vig15].

These examples serve as a “warning sign”, that we should not treat the ability for $x$ to predict $y$ as an indicator that x causes y.

# 3.1.5 Simpson’s paradox

Simpson’s paradox says that a statistical trend or relationship that appears in several different groups of data can disappear or reverse sign when these groups are combined. This results in counterintuitive behavior if we misinterpret claims of statistical dependence in a causal way.

A visualization of the paradox is given in Figure 3.3. Overall, we see that $y$ decreases with $x$ , but within each subpopulation, $y$ increases with $x$ .

For a recent real-world example of Simpson’s paradox in the context of COVID-19, consider Figure 3.4(a). This shows that the case fatality rate (CFR) of COVID-19 in Italy is less than in China in each age group, but is higher overall. The reason for this is that there are more older people in Italy, as shown in Figure 3.4(b). In other words, Figure 3.4(a) shows $p ( F = 1 | A , C )$ , where $A$ is age, $C$ is country, and $F = 1$ is the event that someone dies from COVID-19, and Figure 3.4(b) shows $p ( A | C )$ , which is the probability someone is in age bucket $A$ for country $C$ . Combining these, we find $p ( F = 1 | C = \mathrm { I t a l y } ) > p ( F = 1 | C = \mathrm { C h i n a } )$ . See [KGS20] for more details.

# 3.2 The multivariate Gaussian (normal) distribution

The most widely used joint probability distribution for continuous random variables is the multivariate Gaussian or multivariate normal (MVN). This is mostly because it is mathematically convenient, but also because the Gaussian assumption is fairly reasonable in many cases (see the discussion in Section 2.6.4).

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

![](images/63097650d79952c5e1dcc63ba14b3e8ceee7a261d6b31079323ab6ce369bbaf8.jpg)  
Figure 3.4: Illustration of Simpson’s paradox using COVID-19, (a) Case fatality rates (CFRs) in Italy and China by age group, and in aggregated form (“Total”, last pair of bars), up to the time of reporting (see legend). (b) Proportion of all confirmed cases included in (a) within each age group by country. From Figure 1 of [KGS20]. Used with kind permission of Julius von Kügelgen.

# 3.2.1 Definition

The MVN density is defined by the following:

$$
{ \mathcal { N } } ( y | \mu , \Sigma ) \triangleq { \frac { 1 } { ( 2 \pi ) ^ { D / 2 } | \Sigma | ^ { 1 / 2 } } } \exp \left[ - { \frac { 1 } { 2 } } ( y - \mu ) ^ { \mathsf { T } } \Sigma ^ { - 1 } ( y - \mu ) \right]
$$

where $\pmb { \mu } = \mathbb { E } \left[ \pmb { y } \right] \in \mathbb { R } ^ { D }$ is the mean vector, and $\pmb { \Sigma } = \mathrm { C o v } \left[ \pmb { y } \right]$ is the $D \times D$ covariance matrix, defined as follows:

$$
{ \begin{array} { r l } { \operatorname { C o v } [ y ] \triangleq \mathbb { E } \left[ ( y - \mathbb { E } \left[ y \right] ) ( y - \mathbb { E } \left[ y \right] ) ^ { \mathsf { T } } \right] } & { } \\ { = { \left( \begin{array} { l l l l } { \operatorname { W } \left[ Y _ { 1 } \right] } & { \operatorname { C o v } \left[ Y _ { 1 } , Y _ { 2 } \right] } & { \cdots } & { \operatorname { C o v } \left[ Y _ { 1 } , Y _ { D } \right] } \\ { \operatorname { C o v } \left[ Y _ { 2 } , Y _ { 1 } \right] } & { \operatorname { V } \left[ Y _ { 2 } \right] } & { \cdots } & { \operatorname { C o v } \left[ Y _ { 2 } , Y _ { D } \right] } \\ { \vdots } & { \vdots } & { \ddots } & { \vdots } \\ { \operatorname { C o v } \left[ Y _ { D } , Y _ { 1 } \right] } & { \operatorname { C o v } \left[ Y _ { D } , Y _ { 2 } \right] } & { \cdots } & { \operatorname { V } \left[ Y _ { D } \right] } \end{array} \right) } } \end{array} }
$$

where

$\operatorname { C o v } \left[ Y _ { i } , Y _ { j } \right] \triangleq \mathbb { E } \left[ ( Y _ { i } - \mathbb { E } \left[ Y _ { i } \right] ) ( Y _ { j } - \mathbb { E } \left[ Y _ { j } \right] ) \right] = \mathbb { E } \left[ Y _ { i } Y _ { j } \right] - \mathbb { E } \left[ Y _ { i } \right] \mathbb { E } \left[ Y _ { j } \right]$ and $\mathbb { V } \left[ Y _ { i } \right] = \operatorname { C o v } \left[ Y _ { i } , Y _ { i } \right]$ . From Equation (3.12), we get the important result

$$
\mathbb { E } \left[ \pmb { y } \pmb { y } ^ { \top } \right] = \pmb { \Sigma } + \pmb { \mu } \pmb { \mu } ^ { \top }
$$

The normalization constant in Equation (3.11) ${ \cal Z } = ( 2 \pi ) ^ { D / 2 } | \Sigma | ^ { 1 / 2 }$ just ensures that the pdf integrates to 1 (see Exercise 3.6).

In 2d, the MVN is known as the bivariate Gaussian distribution. Its pdf can be represented as $\pmb { y } \sim \mathcal { N } ( \pmb { \mu } , \pmb { \Sigma } )$ , where $\ b { y } \in \mathbb { R } ^ { 2 }$ , $\textstyle \mu \in \mathbb { R } ^ { 2 }$ and

$$
\Sigma = { \binom { \sigma _ { 1 } ^ { 2 } } { \sigma _ { 2 1 } ^ { 2 } } } \quad \sigma _ { 1 2 } ^ { 2 } ) = { \binom { \sigma _ { 1 } ^ { 2 } } { \rho \sigma _ { 1 } \sigma _ { 2 } } } \quad \rho \sigma _ { 1 } \sigma _ { 2 } )
$$

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

![](images/844a9586cd8e18aab73034a9581c8778e74bb5b14de62c28697965deb2d069b8.jpg)  
Figure 3.5: Visualization of a 2d Gaussian density as a surface plot. (a) Distribution using a full covariance matrix can be oriented at any angle. (b) Distribution using a diagonal covariance matrix must be parallel to the axis. (c) Distribution using a spherical covariance matrix must have a symmetric shape. Generated by gauss_plot_2d.ipynb.

![](images/0e8a953d9d574d26e8b53335423c19892dac8dd3fb0c2c6913503ff99b948b19.jpg)  
Figure 3.6: Visualization of a 2d Gaussian density in terms of level sets of constant probability density. (a) $A$ full covariance matrix has elliptical contours. (b) A diagonal covariance matrix is an axis aligned ellipse. (c) A spherical covariance matrix has a circular shape. Generated by gauss_plot_2d.ipynb.

where $\rho$ is the correlation coefficient, defined by

$$
\mathrm { c o r r } \left[ Y _ { 1 } , Y _ { 2 } \right] \triangleq { \frac { \mathrm { C o v } \left[ Y _ { 1 } , Y _ { 2 } \right] } { \sqrt { \mathbb { V } \left[ Y _ { 1 } \right] \mathbb { V } \left[ Y _ { 2 } \right] } } } = { \frac { \sigma _ { 1 2 } ^ { 2 } } { \sigma _ { 1 } \sigma _ { 2 } } }
$$

One can show (Exercise 3.2) that $- 1 \le \mathrm { c o r r } \left[ Y _ { 1 } , Y _ { 2 } \right] \le 1$ . Expanding out the pdf in the 2d case gives the following rather intimidating-looking result:

$$
{ \begin{array} { c } { p ( y _ { 1 } , y _ { 2 } ) = { \cfrac { 1 } { 2 \pi \sigma _ { 1 } \sigma _ { 2 } { \sqrt { 1 - \rho ^ { 2 } } } } } \exp \left( - { \cfrac { 1 } { 2 ( 1 - \rho ^ { 2 } ) } } \times \right. } \\ { \left. \left[ { \cfrac { ( y _ { 1 } - \mu _ { 1 } ) ^ { 2 } } { \sigma _ { 1 } ^ { 2 } } } + { \cfrac { ( y _ { 2 } - \mu _ { 2 } ) ^ { 2 } } { \sigma _ { 2 } ^ { 2 } } } - 2 \rho { \cfrac { \left( y _ { 1 } - \mu _ { 1 } \right) } { \sigma _ { 1 } } } { \cfrac { \left( y _ { 2 } - \mu _ { 2 } \right) } { \sigma _ { 2 } } } \right] \right) } \end{array} }
$$

Figure 3.5 and Figure 3.6 plot some MVN densities in 2d for three different kinds of covariance matrices. A full covariance matrix has $D ( D + 1 ) / 2$ parameters, where we divide by 2 since $\pmb { \Sigma }$ is

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022 symmetric. (The reason for the elliptical shape is explained in Section 7.4.4, where we discuss the geometry of quadratic forms.) A diagonal covariance matrix has $D$ parameters, and has 0s in the off-diagonal terms. A spherical covariance matrix, also called isotropic covariance matrix, has the form $\begin{array} { r } { \pmb { \Sigma } = \sigma ^ { 2 } \mathbf { I } _ { D } } \end{array}$ , so it only has one free parameter, namely $\sigma ^ { 2 }$ .

# 3.2.2 Mahalanobis distance

In this section, we attempt to gain some insights into the geometric shape of the Gaussian pdf in multiple dimensions. To do this, we will consider the shape of the level sets of constant (log) probability.

The log probability at a specific point $\pmb { y }$ is given by

$$
\log p ( { \pmb y } | { \pmb \mu } , { \pmb \Sigma } ) = - \frac { 1 } { 2 } ( { \pmb y } - { \pmb \mu } ) ^ { \mathsf { T } } { \pmb \Sigma } ^ { - 1 } ( { \pmb y } - { \pmb \mu } ) + \mathrm { c o n s t }
$$

The dependence on $\pmb { y }$ can be expressed in terms of the Mahalanobis distance $\Delta$ between $\pmb { y }$ and $\pmb { \mu }$ , whose square is defined as follows:

$$
\Delta ^ { 2 } \triangleq ( { \pmb y } - { \pmb \mu } ) ^ { { \sf T } } { \Sigma } ^ { - 1 } ( { \pmb y } - { \pmb \mu } )
$$

Thus contours of constant (log) probability are equivalent to contours of constant Mahalanobis distance.

To gain insight into the contours of constant Mahalanobis distance, we exploit the fact that $\pmb { \Sigma }$ , and hence $\pmb { \Lambda } = \pmb { \Sigma } ^ { - 1 }$ , are both positive definite matrices (by assumption). Consider the following eigendecomposition (Section 7.4) of $\pmb { \Sigma }$ :

$$
\Sigma = \sum _ { d = 1 } ^ { D } \lambda _ { d } \pmb { u } _ { d } \pmb { u } _ { d } ^ { \intercal }
$$

We can similarly write

$$
\pmb { \Sigma } ^ { - 1 } = \sum _ { d = 1 } ^ { D } \frac { 1 } { \lambda _ { d } } \pmb { u } _ { d } \pmb { u } _ { d } ^ { \top }
$$

Let us define $z _ { d } \triangleq \pmb { u } _ { d } ^ { \intercal } ( \pmb { y } - \pmb { \mu } )$ , so ${ \pmb z } = { \bf U } ( { \pmb y } - { \pmb \mu } )$ . Then we can rewrite the Mahalanobis distance as follows:

$$
\begin{array} { c } { { ( { \pmb y } - { \pmb \mu } ) ^ { \mathsf { T } } { \pmb \Sigma } ^ { - 1 } ( { \pmb y } - { \pmb \mu } ) = ( { \pmb y } - { \pmb \mu } ) ^ { \mathsf { T } } \left( \displaystyle \sum _ { d = 1 } ^ { D } \frac { 1 } { \lambda _ { d } } { \pmb u } _ { d } { \pmb u } _ { d } ^ { \mathsf { T } } \right) ( { \pmb y } - { \pmb \mu } ) } } \\ { { = \displaystyle \sum _ { d = 1 } ^ { D } \displaystyle \frac { 1 } { \lambda _ { d } } ( { \pmb y } - { \pmb \mu } ) ^ { \mathsf { T } } { \pmb u } _ { d } { \pmb u } _ { d } ^ { \mathsf { T } } ( { \pmb y } - { \pmb \mu } ) = \displaystyle \sum _ { d = 1 } ^ { D } \frac { z _ { d } ^ { 2 } } { \lambda _ { d } } } } \end{array}
$$

As we discuss in Section 7.4.4, this means we can interpret the Mahalanobis distance as Euclidean distance in a new coordinate frame $\mathscr { z }$ in which we rotate $\pmb { y }$ by $\mathbf { U }$ and scale by $\pmb { \Lambda }$ .

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

For example, in 2d, let us consider the set of points $( z _ { 1 } , z _ { 2 } )$ that satisfy this equation:

$$
{ \frac { z _ { 1 } ^ { 2 } } { \lambda _ { 1 } } } + { \frac { z _ { 2 } ^ { 2 } } { \lambda _ { 2 } } } = r
$$

Since these points have the same Mahalanobis distance, they correspond to points of equal probability. Hence we see that the contours of equal probability density of a 2d Gaussian lie along ellipses. This is illustrated in Figure 7.6. The eigenvectors determine the orientation of the ellipse, and the eigenvalues determine how elongated it is.

# 3.2.3 Marginals and conditionals of an MVN \*

Suppose $\pmb { y } = ( \pmb { y } _ { 1 } , \pmb { y } _ { 2 } )$ is jointly Gaussian with parameters

$$
 { \boldsymbol { \mu } } = \left( { \begin{array} { l } { \mu _ { 1 } } \\ { \mu _ { 2 } } \end{array} } \right) , ~ { \boldsymbol { \Sigma } } = \left( { \begin{array} { l l } { \Sigma _ { 1 1 } } & { \Sigma _ { 1 2 } } \\ { \Sigma _ { 2 1 } } & { \Sigma _ { 2 2 } } \end{array} } \right) , ~ { \boldsymbol { \Lambda } } = { \boldsymbol { \Sigma } } ^ { - 1 } = \left( { \begin{array} { l l } { \Lambda _ { 1 1 } } & { \Lambda _ { 1 2 } } \\ { \Lambda _ { 2 1 } } & { \Lambda _ { 2 2 } } \end{array} } \right)
$$

where $\pmb { \Lambda }$ is the precision matrix. Then the marginals are given by

and the posterior conditional is given by

These equations are of such crucial importance in this book that we have put a box around them, so you can easily find them later. For the derivation of these results (which relies on computing the Schur complement ${ \boldsymbol \Sigma } / { \boldsymbol \Sigma } _ { 2 2 } = { \boldsymbol \Sigma } _ { 1 1 } - { \boldsymbol \Sigma } _ { 1 2 } { \boldsymbol \Sigma } _ { 2 2 } ^ { - 1 } { \boldsymbol \Sigma } _ { 2 1 } )$ , see Section 7.3.5.

We see that both the marginal and conditional distributions are themselves Gaussian. For the marginals, we just extract the rows and columns corresponding to $\mathbf { \boldsymbol { \mathsf { y } } } _ { 1 }$ or $\mathbf { \nabla } \mathbf { \pmb { y } } _ { 2 }$ . For the conditional, we have to do a bit more work. However, it is not that complicated: the conditional mean is just a linear function of $\mathbf { \mathcal { { y } } } _ { 2 }$ , and the conditional covariance is just a constant matrix that is independent of $\mathbf { \mathcal { { y } } } _ { 2 }$ . We give three different (but equivalent) expressions for the posterior mean, and two different (but equivalent) expressions for the posterior covariance; each one is useful in different circumstances.

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

# 3.2.4 Example: conditioning a 2d Gaussian

Let us consider a 2d example. The covariance matrix is

$$
\pmb { \Sigma } = \left( \begin{array} { c c } { \sigma _ { 1 } ^ { 2 } } & { \rho \sigma _ { 1 } \sigma _ { 2 } } \\ { \rho \sigma _ { 1 } \sigma _ { 2 } } & { \sigma _ { 2 } ^ { 2 } } \end{array} \right)
$$

The marginal $p ( y _ { 1 } )$ is a 1D Gaussian, obtained by projecting the joint distribution onto the $y _ { 1 }$ line:

$$
p ( y _ { 1 } ) = \mathcal { N } ( y _ { 1 } | \mu _ { 1 } , \sigma _ { 1 } ^ { 2 } )
$$

Suppose we observe $Y _ { 2 } = y _ { 2 }$ ; the conditional $p ( y _ { 1 } | y _ { 2 } )$ is obtained by “slicing” the joint distribution through the $Y _ { 2 } = y _ { 2 }$ line:

$$
p ( y _ { 1 } | y _ { 2 } ) = \mathcal { N } \left( y _ { 1 } | \mu _ { 1 } + \frac { \rho \sigma _ { 1 } \sigma _ { 2 } } { \sigma _ { 2 } ^ { 2 } } ( y _ { 2 } - \mu _ { 2 } ) , \sigma _ { 1 } ^ { 2 } - \frac { ( \rho \sigma _ { 1 } \sigma _ { 2 } ) ^ { 2 } } { \sigma _ { 2 } ^ { 2 } } \right)
$$

If $\sigma _ { 1 } = \sigma _ { 2 } = \sigma$ , we get

$$
p ( y _ { 1 } | y _ { 2 } ) = \mathcal { N } \left( y _ { 1 } | \mu _ { 1 } + \rho ( y _ { 2 } - \mu _ { 2 } ) , \sigma ^ { 2 } ( 1 - \rho ^ { 2 } ) \right)
$$

For example, suppose $\rho = 0 . 8$ , $\sigma _ { 1 } = \sigma _ { 2 } = 1$ , $\mu _ { 1 } = \mu _ { 2 } = 0$ , and $y _ { 2 } = 1$ . We see that $\mathbb { E } \left[ y _ { 1 } | y _ { 2 } = 1 \right] =$ 0.8, which makes sense, since $\rho = 0 . 8$ means that we believe that if $y _ { 2 }$ increases by 1 (beyond its mean), then $y _ { 1 }$ increases by 0.8. We also see $\mathbb { V } \left[ y _ { 1 } | y _ { 2 } = 1 \right] = 1 - 0 . 8 ^ { 2 } = 0 . 3 6$ . This also makes sense: our uncertainty about $y _ { 1 }$ has gone down, since we have learned something about $y _ { 1 }$ (indirectly) by observing $y _ { 2 }$ . If $\rho = 0$ , we get $p ( y _ { 1 } | y _ { 2 } ) = \mathcal { N } \left( y _ { 1 } | \mu _ { 1 } , \ \sigma _ { 1 } ^ { 2 } \right)$ , since $y _ { 2 }$ conveys no information about $y _ { 1 }$ if they are uncorrelated (and hence independent).

# 3.2.5 Example: Imputing missing values \*

As an example application of the above results, suppose we observe some parts (dimensions) of $\textbf {  { y } }$ , with the remaining parts being missing or unobserved. We can exploit the correlation amongst the dimensions (encoded by the covariance matrix) to infer the missing entries; this is called missing value imputation.

Figure 3.7 shows a simple example. We sampled $N$ vectors from a $D = 1 0$ -dimensional Gaussian, and then deliberately “hid” $5 0 \%$ of the data in each sample (row). We then inferred the missing entries given the observed entries and the true model parameters.1 More precisely, for each row $n$ of the data matrix, we compute $p ( \pmb { y } _ { n , h } | \pmb { y } _ { n , v } , \pmb \theta )$ , where $\mathbf { \nabla } _ { \mathbf { v } }$ are the indices of the visible entries in that row, $^ { h }$ are the remaining indices of the hidden entries, and $\pmb \theta = ( \pmb \mu , \pmb \Sigma )$ . From this, we compute the marginal distribution of each missing variable $i \in \boldsymbol { h }$ , $p ( y _ { n , i } | \pmb { y } _ { n , \pmb { v } } , \pmb { \theta } )$ . From the marginal, we compute the posterior mean, $\bar { y } _ { n , i } = \mathbb { E } \left[ y _ { n , i } \vert y _ { n , v } , \pmb { \theta } \right]$ .

The posterior mean represents our “best guess” about the true value of that entry, in the sense that it minimizes our expected squared error, as explained in Chapter 5. We can use $\mathbb { V } \left[ y _ { n , i } | y _ { n , v } , \pmb \theta \right]$ as a measure of confidence in this guess, although this is not shown. Alternatively, we could draw multiple posterior samples from $p ( \pmb { y } _ { n , h } | \pmb { y } _ { n , v } , \pmb \theta )$ ; this is called multiple imputation, and provides a more robust estimate to downstream algorithms that consume the “filled in” data.

![](images/8eacb08bd0ae1fc9c0b898988306292077efc68550165951df08ec5f0d679a69.jpg)  
Figure 3.7: Illustration of data imputation using an MVN. (a) Visualization of the data matrix. Blank entries are missing (not observed). Blue are positive, green are negative. Area of the square is proportional to the value. (This is known as a Hinton diagram, named after Geoff Hinton, a famous ML researcher.) (b) True data matrix (hidden). (c) Mean of the posterior predictive distribution, based on partially observed data in that row, using the true model parameters. Generated by gauss_imputation_known_params_demo.ipynb.

# 3.3 Linear Gaussian systems \*

In Section 3.2.3, we conditioned on noise-free observations to infer the posterior over the hidden parts of a Gaussian random vector. In this section, we extend this approach to handle noisy observations. Let $z \in \mathbb { R } ^ { L }$ be an unknown vector of values, and $\pmb { y } \in \mathbb { R } ^ { D }$ be some noisy measurement of $_ { z }$ . We assume these variables are related by the following joint distribution:

$$
\begin{array} { c } { p ( z ) = \mathcal { N } ( z | \boldsymbol { \mu } _ { z } , \boldsymbol { \Sigma } _ { z } ) } \\ { p ( \mathbf { \boldsymbol { y } } | z ) = \mathcal { N } ( \mathbf { \boldsymbol { y } } | \mathbf { \boldsymbol { W } } z + \boldsymbol { b } , \boldsymbol { \Sigma } _ { y } ) } \end{array}
$$

where $\mathbf { W }$ is a matrix of size $D \times L$ . This is an example of a linear Gaussian system.

The corresponding joint distribution, $p ( z , y ) = p ( z ) p ( y | z )$ , is a $L + D$ dimensional Gaussian, with mean and covariance given by

$$
\begin{array} { r l } & { \pmb { \mu } = \left( \begin{array} { c } { \pmb { \mu } _ { z } } \\ { \mathbf { W } \pmb { \mu } _ { z } + b } \end{array} \right) } \\ & { \pmb { \Sigma } = \left( \begin{array} { c c } { \pmb { \Sigma } _ { z } } & { \pmb { \Sigma } _ { z } \mathbf { W } ^ { \top } } \\ { \mathbf { W } \pmb { \Sigma } _ { z } } & { \pmb { \Sigma } _ { y } + \mathbf { W } \pmb { \Sigma } _ { z } \mathbf { W } ^ { \top } } \end{array} \right) } \end{array}
$$

By applying the Gaussian conditioning formula in Equation (3.28) to the joint $p ( { \pmb y } , z )$ we can compute the posterior $p ( \boldsymbol { z } | \boldsymbol { y } )$ , as we explain below. This can be interpreted as inverting the $z  y$ arrow in the generative model from latents to observations.

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

# 3.3.1 Bayes rule for Gaussians

The posterior over the latent is given by

$$
\begin{array} { r l } & { \boldsymbol { \mathscr { \mathbf { \rho } } } ( z | \boldsymbol { \mathbf { \mathscr { y } } } ) = \mathcal { N } ( z | \boldsymbol { \mu } _ { z | \boldsymbol { y } } , \boldsymbol { \Sigma } _ { z | \boldsymbol { y } } ) } \\ & { \boldsymbol { \Sigma } _ { z | \boldsymbol { y } } ^ { - 1 } = \boldsymbol { \Sigma } _ { z } ^ { - 1 } + \boldsymbol { \mathbf { W } } ^ { \mathsf { T } } \boldsymbol { \Sigma } _ { \boldsymbol { y } } ^ { - 1 } \boldsymbol { \mathbf { W } } } \\ & { \boldsymbol { \mu } _ { z | \boldsymbol { y } } = \boldsymbol { \Sigma } _ { z | \boldsymbol { y } } [ \boldsymbol { \mathbf { W } } ^ { \mathsf { T } } \boldsymbol { \Sigma } _ { \boldsymbol { y } } ^ { - 1 } \left( \boldsymbol { y } - \boldsymbol { b } \right) + \boldsymbol { \Sigma } _ { z } ^ { - 1 } \boldsymbol { \mu } _ { z } ] } \end{array}
$$

This is known as Bayes rule for Gaussians. Furthermore, the normalization constant of the posterior is given by

$$
p ( y ) = \int \mathcal { N } ( z | \mu _ { z } , \Sigma _ { z } ) \mathcal { N } ( y | \mathbf { W } z + b , \Sigma _ { y } ) d z = \mathcal { N } ( y | \mathbf { W } \mu _ { z } + b , \Sigma _ { y } + \mathbf { W } \Sigma _ { z } \mathbf { W } ) ,
$$

We see that the Gaussian prior $p ( z )$ , combined with the Gaussian likelihood $p ( \pmb { y } | \pmb { z } )$ , results in a Gaussian posterior $p ( \boldsymbol { z } | \boldsymbol { y } )$ . Thus Gaussians are closed under Bayesian conditioning. To describe this more generally, we say that the Gaussian prior is a conjugate prior for the Gaussian likelihood, since the posterior distribution has the same type as the prior. We discuss the notion of conjugate priors in more detail in Section 4.6.1.

In the sections below, we give various applications of this result. But first, we give the derivation.

# 3.3.2 Derivation \*

We now derive Equation 3.37. The basic idea is to derive the joint distribution, $p ( z , y ) = p ( z ) p ( y | z )$ , and then to use the results from Section 3.2.3 for computing $p ( \boldsymbol { z } | \boldsymbol { y } )$ .

In more detail, we proceed as follows. The log of the joint distribution is as follows (dropping irrelevant constants):

$$
{ \bf \nabla } : p ( z , y ) = - \frac { 1 } { 2 } ( z - \mu _ { z } ) ^ { T } \Sigma _ { z } ^ { - 1 } ( z - \mu _ { z } ) - \frac { 1 } { 2 } ( y - \mathbf { W } z - b ) ^ { T } \Sigma _ { y } ^ { - 1 } ( y - \mathbf { W } z - b )
$$

This is clearly a joint Gaussian distribution, since it is the exponential of a quadratic form.

Expanding out the quadratic terms involving $\mathscr { z }$ and $\textbf {  { y } }$ , and ignoring linear and constant terms, we have

$$
\begin{array} { l } { { \displaystyle Q = - \frac { 1 } { 2 } z ^ { T } { \boldsymbol \Sigma } _ { z } ^ { - 1 } z - \frac { 1 } { 2 } y ^ { T } { \boldsymbol \Sigma } _ { y } ^ { - 1 } y - \frac { 1 } { 2 } ( \mathbf { W } z ) ^ { T } { \boldsymbol \Sigma } _ { y } ^ { - 1 } ( \mathbf { W } z ) + y ^ { T } { \boldsymbol \Sigma } _ { y } ^ { - 1 } \mathbf { W } z } } \\ { { \displaystyle ~ = - \frac { 1 } { 2 } \left( \begin{array} { l } { { \displaystyle z } } \\ { { \displaystyle y } } \end{array} \right) ^ { T } \left( \Sigma _ { z } ^ { - 1 } + \mathbf { W } ^ { T } \Sigma _ { y } ^ { - 1 } \mathbf { W } \quad - \mathbf { W } ^ { T } \Sigma _ { y } ^ { - 1 } \right) \left( \boldsymbol \Sigma \right) } } \\ { { \displaystyle ~ - \Sigma _ { y } ^ { - 1 } \mathbf { W } } } \\ { { \displaystyle ~ = - \frac { 1 } { 2 } \left( \begin{array} { l } { { \displaystyle z } } \\ { { \displaystyle y } } \end{array} \right) ^ { T } \Sigma ^ { - 1 } \left( \begin{array} { l } { { \displaystyle z } } \\ { { \displaystyle y } } \end{array} \right) } } \end{array}
$$

where the precision matrix of the joint is defined as

$$
\begin{array} { r l } { \Sigma ^ { - 1 } = \left( \begin{array} { c c } { \Sigma _ { z } ^ { - 1 } + \mathbf { W } ^ { T } \Sigma _ { y } ^ { - 1 } \mathbf { W } } & { - \mathbf { W } ^ { T } \Sigma _ { y } ^ { - 1 } } \\ { - \Sigma _ { y } ^ { - 1 } \mathbf { W } } & { \Sigma _ { y } ^ { - 1 } } \end{array} \right) \triangleq \Lambda = \left( \begin{array} { c c } { \Lambda _ { z z } } & { \Lambda _ { z y } } \\ { \Lambda _ { y z } } & { \Lambda _ { y y } } \end{array} \right) } \end{array}
$$

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

From Equation 3.28, and using the fact that $\pmb { \mu } _ { y } = \mathbf { W } \pmb { \mu } _ { z } + \pmb { b }$ , we have

$$
\begin{array} { r l } & { p ( \boldsymbol { z } | \boldsymbol { y } ) = \mathcal { N } ( \boldsymbol { \mu } _ { \boldsymbol { z } | \boldsymbol { y } } , \boldsymbol { \Sigma } _ { z | \boldsymbol { y } } ) } \\ & { \quad \boldsymbol { \Sigma } _ { z | \boldsymbol { y } } = \boldsymbol { \Lambda } _ { z z } ^ { - 1 } = ( \boldsymbol { \Sigma } _ { z } ^ { - 1 } + \mathbf { W } ^ { T } \boldsymbol { \Sigma } _ { \boldsymbol { y } } ^ { - 1 } \mathbf { W } ) ^ { - 1 } } \\ & { \quad \boldsymbol { \mu } _ { z | \boldsymbol { y } } = \boldsymbol { \Sigma } _ { z | \boldsymbol { y } } \left( \boldsymbol { \Lambda } _ { z z } \boldsymbol { \mu } _ { z } - \boldsymbol { \Lambda } _ { z y } ( \boldsymbol { y } - \boldsymbol { \mu } _ { \boldsymbol { y } } ) \right) } \\ & { \quad \quad \quad = \boldsymbol { \Sigma } _ { z | \boldsymbol { y } } \left( \boldsymbol { \Sigma } _ { z } ^ { - 1 } \boldsymbol { \mu } _ { z } + \mathbf { W } ^ { \mathsf { T } } \boldsymbol { \Sigma } _ { \boldsymbol { y } } ^ { - 1 } \mathbf { W } \boldsymbol { \mu } _ { z } + \mathbf { W } ^ { \mathsf { T } } \boldsymbol { \Sigma } _ { \boldsymbol { y } } ^ { - 1 } ( \boldsymbol { y } - \boldsymbol { \mu } _ { \boldsymbol { y } } ) \right) } \\ & { \quad \quad \quad = \boldsymbol { \Sigma } _ { z | \boldsymbol { y } } \left( \boldsymbol { \Sigma } _ { z } ^ { - 1 } \boldsymbol { \mu } _ { z } + \mathbf { W } ^ { \mathsf { T } } \boldsymbol { \Sigma } _ { \boldsymbol { y } } ^ { - 1 } ( \mathbf { W } \boldsymbol { \mu } _ { z } + \boldsymbol { y } - \boldsymbol { \mu } _ { \boldsymbol { y } } ) \right) } \\ & { \quad \quad = \boldsymbol { \Sigma } _ { z | \boldsymbol { y } } \left( \boldsymbol { \Sigma } _ { z } ^ { - 1 } \boldsymbol { \mu } _ { z } + \mathbf { W } ^ { T } \boldsymbol { \Sigma } _ { \boldsymbol { y } } ^ { - 1 } ( \boldsymbol { y } - \boldsymbol { b } ) \right) } \end{array}
$$

# 3.3.3 Example: Inferring an unknown scalar

Suppose we make $N$ noisy measurements of some underlying quantity ; let us assume the $y _ { i }$ $z$ measurement noise has fixed precision $\lambda _ { y } = 1 / \sigma ^ { 2 }$ , so the likelihood is

$$
p ( y _ { i } | z ) = \mathcal { N } ( y _ { i } | z , \lambda _ { y } ^ { - 1 } )
$$

Now let us use a Gaussian prior for the value of the unknown source:

$$
p ( z ) = \mathcal { N } ( z | \mu _ { 0 } , \lambda _ { 0 } ^ { - 1 } )
$$

We want to compute $p ( z | y _ { 1 } , \dots , y _ { N } , \sigma ^ { 2 } )$ . We can convert this to a form that lets us apply Bayes rule for Gaussians by defining $\pmb { y } = ( y _ { 1 } , \dots y _ { N } )$ , ${ \bf W } = { \bf 1 } _ { N }$ (an $N \times 1$ column vector of $^ { 1 }$ ’s), and $\pmb { \Sigma } _ { y } ^ { - 1 } = \mathrm { d i a g } ( \lambda _ { y } \mathbf { I } )$ . Then we get

$$
\begin{array} { l } { \displaystyle p ( z | \pmb { y } ) = \mathcal { N } ( z | \mu _ { N } , \lambda _ { N } ^ { - 1 } ) } \\ { \displaystyle \quad \lambda _ { N } = \lambda _ { 0 } + N \lambda _ { y } } \\ { \displaystyle \mu _ { N } = \frac { N \lambda _ { y } \overline { { y } } + \lambda _ { 0 } \mu _ { 0 } } { \lambda _ { N } } = \frac { N \lambda _ { y } } { N \lambda _ { y } + \lambda _ { 0 } } \overline { { y } } + \frac { \lambda _ { 0 } } { N \lambda _ { y } + \lambda _ { 0 } } \mu _ { 0 } } \end{array}
$$

These equations are quite intuitive: the posterior precision $\lambda _ { N }$ is the prior precision $\lambda _ { 0 }$ plus $N$ units of measurement precision $\lambda _ { y }$ . Also, the posterior mean $\mu _ { N }$ is a convex combination of the MLE $\overline { y }$ and the prior mean $\mu _ { 0 }$ . This makes it clear that the posterior mean is a compromise between the MLE and the prior. If the prior is weak relative to the signal strength ( $\lambda _ { 0 }$ is small relative to $\lambda _ { y }$ ), we put more weight on the MLE. If the prior is strong relative to the signal strength ( $\lambda _ { 0 }$ is large relative to $\lambda _ { y }$ ), we put more weight on the prior. This is illustrated in Figure 3.8.

Note that the posterior mean is written in terms of $N \lambda _ { y } \overline { { y } }$ , so having $N$ measurements each of precision $\lambda _ { y }$ is like having one measurement with value $\overline { y }$ and precision $N \lambda _ { y }$ .

We can rewrite the results in terms of the posterior variance, rather than posterior precision, as follows:

$$
\begin{array} { c } { { p ( z | \mathcal { D } , \sigma ^ { 2 } ) = \mathcal { N } ( z | \mu _ { N } , \tau _ { N } ^ { 2 } ) } } \\ { { \displaystyle \tau _ { N } ^ { 2 } = \frac { 1 } { \frac { N } { \sigma ^ { 2 } } + \frac { 1 } { \tau _ { 0 } ^ { 2 } } } = \frac { \sigma ^ { 2 } \tau _ { 0 } ^ { 2 } } { N \tau _ { 0 } ^ { 2 } + \sigma ^ { 2 } } } } \\ { { \displaystyle \mu _ { N } = \tau _ { N } ^ { 2 } \left( \frac { \mu _ { 0 } } { \tau _ { 0 } ^ { 2 } } + \frac { N \overline { { { y } } } } { \sigma ^ { 2 } } \right) = \frac { \sigma ^ { 2 } } { N \tau _ { 0 } ^ { 2 } + \sigma ^ { 2 } } \mu _ { 0 } + \frac { N \tau _ { 0 } ^ { 2 } } { N \tau _ { 0 } ^ { 2 } + \sigma ^ { 2 } } \overline { { { y } } } } } \end{array}
$$

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

![](images/250e39787b4aba4de7002b5b6e805db0d26d3174ea0ed5734a7db8f26ebbfb0b.jpg)  
Figure 3.8: Inference about $z$ given a noisy observation $y = 3$ . (a) Strong prior $\mathcal { N } ( 0 , 1 )$ . The posterior mean is “shrunk” towards the prior mean, which is $\boldsymbol { \mathit { 0 } }$ . (b) Weak prior $\mathcal { N } ( 0 , 5 )$ . The posterior mean is similar to the MLE. Generated by gauss_infer_1d.ipynb.

where $\tau _ { 0 } ^ { 2 } = 1 / \lambda _ { 0 }$ is the prior variance and $\tau _ { N } ^ { 2 } = 1 / \lambda _ { N }$ is the posterior variance.

We can also compute the posterior sequentially, by updating after each observation. If $N = 1$ , we can rewrite the posterior after seeing a single observation as follows (where we define $\Sigma _ { y } = \sigma ^ { 2 }$ , $\Sigma _ { 0 } = \tau _ { 0 } ^ { 2 }$ and $\Sigma _ { 1 } = \tau _ { 1 } ^ { 2 }$ to be the variances of the likelihood, prior and posterior):

$$
\begin{array} { l } { \displaystyle { p ( z | y ) = \mathcal { N } ( z | \mu _ { 1 } , \Sigma _ { 1 } ) } } \\ { \displaystyle { \quad \Sigma _ { 1 } = \left( \frac { 1 } { \Sigma _ { 0 } } + \frac { 1 } { \Sigma _ { y } } \right) ^ { - 1 } = \frac { \Sigma _ { y } \Sigma _ { 0 } } { \Sigma _ { 0 } + \Sigma _ { y } } } } \\ { \displaystyle { \mu _ { 1 } = \Sigma _ { 1 } \left( \frac { \mu _ { 0 } } { \Sigma _ { 0 } } + \frac { y } { \Sigma _ { y } } \right) } } \end{array}
$$

We can rewrite the posterior mean in 3 different ways:

$$
\begin{array} { c } { \displaystyle \mu _ { 1 } = \frac { \sum _ { y } } { \sum _ { y } + \sum _ { 0 } } \mu _ { 0 } + \frac { \sum _ { 0 } } { \sum _ { y } + \sum _ { 0 } } y } \\ { \displaystyle = \mu _ { 0 } + ( y - \mu _ { 0 } ) \frac { \sum _ { 0 } } { \sum _ { y } + \sum _ { 0 } } } \\ { \displaystyle = y - ( y - \mu _ { 0 } ) \frac { \sum _ { y } } { \sum _ { y } + \sum _ { 0 } } } \end{array}
$$

The first equation is a convex combination of the prior and the data. The second equation is the prior mean adjusted towards the data. The third equation is the data adjusted towards the prior mean; this is called shrinkage. These are all equivalent ways of expressing the tradeoff between likelihood and prior. If $\Sigma _ { 0 }$ is small relative to $\Sigma _ { y }$ , corresponding to a strong prior, the amount of shrinkage is large (see Figure 3.8(a)), whereas if $\Sigma _ { 0 }$ is large relative to $\Sigma _ { y }$ , corresponding to a weak prior, the amount of shrinkage is small (see Figure 3.8(b)).

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

Another way to quantify the amount of shrinkage is in terms of the signal-to-noise ratio, which is defined as follows:

$$
\mathrm { S N R } \triangleq \frac { \mathbb { E } \left[ Z ^ { 2 } \right] } { \mathbb { E } \left[ \epsilon ^ { 2 } \right] } = \frac { \Sigma _ { 0 } + \mu _ { 0 } ^ { 2 } } { \Sigma _ { y } }
$$

where $z \sim \mathcal { N } ( \mu _ { 0 } , \Sigma _ { 0 } )$ is the true signal, $y = z + \epsilon$ is the observed signal, and $\epsilon \sim \mathcal { N } ( 0 , \Sigma _ { y } )$ is the noise term.

# 3.3.4 Example: inferring an unknown vector

Suppose we have an unknown quantity of interest, $z \in \mathbb { R } ^ { D }$ , which we endow with a Gaussian prior, $p ( z ) = \mathcal { N } ( \pmb { \mu } _ { z } , \pmb { \Sigma } _ { z } )$ . If we “know nothing” about $\mathscr { z }$ a priori, we can set $\Sigma _ { z } = \mathrm { \infty } \mathbf { I }$ , which means we are completely uncertain about what the value of $_ { z }$ should be. (In practice, we can use a large but finite value for the covariance.) By symmetry, it seems reasonable to set $\pmb { \mu } _ { z } = \mathbf { 0 }$ .

Now suppose we make $N$ noisy but independent measurements of $\boldsymbol { z }$ , $\pmb { y } _ { n } \sim \mathcal { N } ( z , \pmb { \Sigma } _ { y } )$ , each of size $D$ . We can represent the likelihood as follows:

$$
p ( \mathcal D | z ) = \prod _ { n = 1 } ^ { N } \mathcal N ( \pmb { y } _ { n } | z , \pmb { \Sigma } _ { y } ) = \mathcal N ( \pmb { \overline { y } } | z , \frac { 1 } { N } \pmb { \Sigma } _ { y } )
$$

Note that we can replace the $N$ observations with their average, $\overline { { { y } } }$ , provided we scale down the covariance by $1 / N$ to compensate. Setting $\mathbf { W } = \mathbf { I }$ , $\mathbf { { \boldsymbol { b } } = 0 }$ , we can then use Bayes rule for Gaussian to compute the posterior over $\boldsymbol { z }$ :

$$
\begin{array} { c } { p ( z | \pmb { y } _ { 1 } , \dots , \pmb { y } _ { N } ) = \mathcal { N } ( z | \hat { \pmb { \mu } } , \pmb { \hat { \Sigma } } ) } \\ { \qquad \quad \widehat { \mathbf { \Sigma } } ^ { - 1 } = \pmb { \Sigma } _ { z } ^ { - 1 } + N _ { \mathcal { D } } \pmb { \Sigma } _ { y } ^ { - 1 } } \\ { \qquad \quad \hat { \pmb { \mu } } = \widehat { \mathbf { \Sigma } } ( \pmb { \Sigma } _ { y } ^ { - 1 } ( N _ { \mathcal { D } } \overline { { \pmb { y } } } ) + \pmb { \Sigma } _ { z } ^ { - 1 } \pmb { \mu } _ { z } ) } \end{array}
$$

where $\hat { \pmb { \mu } }$ and $\hat { \Sigma }$ are the parameters of the posterior.

Figure 3.9 gives a 2d example. We can think of $\boldsymbol { z }$ as representing the true, but unknown, location of an object in 2d space, such as a missile or airplane, and the ${ \bf { y } } _ { n }$ as being noisy observations, such as radar “blips”. As we receive more blips, we are better able to localize the source. (In the sequel to this book, [Mur23], we discuss the Kalman filter algorithm, which extends this idea to a temporal sequence of observations.)

The posterior uncertainty about each component of $\boldsymbol { z }$ location vector depends on how reliable the sensor is in each of these dimensions. In the above example, the measurement noise in dimension 1 is higher than in dimension 2, so we have more posterior uncertainty about $z _ { 1 }$ (horizontal axis) than about $z _ { 2 }$ (vertical axis).

# 3.3.5 Example: sensor fusion

In this section, we extend Section 3.3.4, to the case where we have multiple measurements, coming from different sensors, each with different reliabilities. That is, the model has the form

$$
p ( z , \pmb { y } ) = p ( z ) \prod _ { m = 1 } ^ { M } \prod _ { n = 1 } ^ { N _ { m } } \mathcal { N } ( \pmb { y } _ { n , m } | z , \pmb { \Sigma } _ { m } )
$$

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022 where $M$ is the number of sensors (measurement devices), and $N _ { m }$ is the number of observations from sensor $m$ , and $\pmb { y } = \pmb { y } _ { 1 : N , 1 : M } \in \mathbb { R } ^ { K }$ . Our goal is to combine the evidence together, to compute $p ( \boldsymbol { z } | \boldsymbol { y } )$ . This is known as sensor fusion.

![](images/695bd6034254165cc8ddd643832ae54f562928c4b9eb1de9e7b7a2d0d297ba50.jpg)  
Figure 3.9: Illustration of Bayesian inference for a 2d Gaussian random vector $_ { z }$ . (a) The data is generated from $\pmb { y } _ { n } \sim \mathcal { N } ( z , \pmb { \Sigma } _ { y } )$ , where $\pmb { z } = [ 0 . 5 , 0 . 5 ] ^ { \mathsf { T } }$ and $\Sigma _ { y } = 0 . 1 [ 2 , 1 ; 1 , 1 ] ,$ ). We assume the sensor noise covariance $\Sigma _ { y }$ is known but $z$ is unknown. The black cross represents $_ { z }$ . (b) The prior is $p ( z ) = \mathcal { N } ( z | \mathbf { 0 } , 0 . 1 \mathbf { I } _ { 2 } )$ . (c) We show the posterior after $\boldsymbol { \mathit { 1 0 } }$ data points have been observed. Generated by gauss_infer_2d.ipynb.

We now give a simple example, where there are just two sensors, so $\pmb { y } _ { 1 } \sim \mathcal { N } ( z , \pmb { \Sigma } _ { 1 } )$ and $y _ { 2 } \sim$ $\mathcal { N } ( z , \pmb { \Sigma } _ { 2 } )$ . Pictorially, we can represent this example as $y _ { 1 } \left. z \right. y _ { 2 }$ . We can combine $\mathbf { \boldsymbol { \mathsf { y } } } _ { 1 }$ and $\mathbf { \boldsymbol { \mathsf { y } } } _ { 2 }$ into a single vector $\pmb { y }$ , so the model can be represented as $z  [ { \pmb y } _ { 1 } , { \pmb y } _ { 2 } ]$ , where $p ( \pmb { y } | \boldsymbol { z } ) = \mathcal { N } ( \pmb { y } | \mathbf { W } \boldsymbol { z } , \pmb { \Sigma } _ { y } )$ , where $\mathbf { W } = [ \mathbf { I } ; \mathbf { I } ]$ and $\Sigma _ { y } = [ \Sigma _ { 1 } , \mathbf { 0 } ; \mathbf { 0 } , \Sigma _ { 2 } ]$ are block-structured matrices. We can then apply Bayes’ rule for Gaussians to compute $p ( \boldsymbol { z } | \boldsymbol { y } )$ .

Figure 3.10(a) gives a 2d example, where we set $\Sigma _ { 1 } = \Sigma _ { 2 } = 0 . 0 1 \mathbf { I } _ { 2 }$ , so both sensors are equally reliable. In this case, the posterior mean is halfway between the two observations, $\mathbf { \boldsymbol { \mathsf { y } } } _ { 1 }$ and $\mathbf { \boldsymbol { \mathsf { y } } } _ { 2 }$ . In Figure 3.10(b), we set $\pmb { \Sigma } _ { 1 } = 0 . 0 5 \mathbf { I } _ { 2 }$ and $\pmb { \Sigma } _ { 2 } = 0 . 0 1 \mathbf { I } _ { 2 }$ , so sensor 2 is more reliable than sensor 1. In this case, the posterior mean is closer to $\mathbf { \boldsymbol { \mathsf { y } } } _ { 2 }$ . In Figure 3.10(c), we set

$$
\Sigma _ { 1 } = 0 . 0 1 \left( \begin{array} { c c } { { 1 0 } } & { { 1 } } \\ { { 1 } } & { { 1 } } \end{array} \right) , \Sigma _ { 2 } = 0 . 0 1 \left( \begin{array} { c c } { { 1 } } & { { 1 } } \\ { { 1 } } & { { 1 0 } } \end{array} \right)
$$

so sensor $1$ is more reliable in the second component (vertical direction), and sensor 2 is more reliable in the first component (horizontal direction). In this case, the posterior mean uses ${ \bf { y } } _ { 1 }$ ’s vertical component and $\mathbf { \boldsymbol { \mathsf { y } } } _ { 2 }$ ’s horizontal component.

# 3.4 The exponential family \*

In this section, we define the exponential family, which includes many common probability distributions. The exponential family plays a crucial role in statistics and machine learning. In this book, we mainly use it in the context of generalized linear models, which we discuss in Chapter 12. We will see more applications of the exponential family in the sequel to this book, [Mur23].

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

![](images/5aea7bbeecd05e648706830051805f3bc645b18f2d3f754b9ee20a0b6f7c3126.jpg)  
Figure 3.10: We observe $\pmb { y } _ { 1 } = ( 0 , - 1 )$ (red cross) and $\pmb { y } _ { 2 } = ( 1 , 0 )$ (green cross) and estimate $\mathbb { E } \left[ z | { \pmb y } _ { 1 } , { \pmb y } _ { 2 } \right]$ (black cross). (a) Equally reliable sensors, so the posterior mean estimate is in between the two circles. (b) Sensor 2 is more reliable, so the estimate shifts more towards the green circle. (c) Sensor 1 is more reliable in the vertical direction, Sensor 2 is more reliable in the horizontal direction. The estimate is an appropriate combination of the two measurements. Generated by sensor_fusion_2d.ipynb.

# 3.4.1 Definition

Consider a family of probability distributions parameterized by $\pmb { \eta } \in \mathbb { R } ^ { K }$ with fixed support over $\mathcal { V } ^ { D } \subseteq \mathbb { R } ^ { D }$ . We say that the distribution $p ( \pmb { y } | \pmb { \eta } )$ is in the exponential family if its density can be written in the following way:

$$
p ( { \pmb y } | { \pmb \eta } ) \triangleq \frac { 1 } { Z ( { \pmb \eta } ) } h ( { \pmb y } ) \exp [ { \pmb \eta } ^ { \top } { \pmb \mathcal { T } } ( { \pmb y } ) ] = h ( { \pmb y } ) \exp [ { \pmb \eta } ^ { \top } { \pmb \mathcal { T } } ( { \pmb y } ) - A ( { \pmb \eta } ) ]
$$

where $h ( \boldsymbol { y } )$ is a scaling constant (also known as the base measure, often 1), $\mathcal { T } ( \pmb { y } ) \in \mathbb { R } ^ { K }$ are the sufficient statistics, $\eta$ are the natural parameters or canonical parameters, $Z ( \eta )$ is a normalization constant known as the partition function, and $A ( \pmb { \eta } ) = \log Z ( \pmb { \eta } )$ is the log partition function. One can show that $A$ is a convex function over the concave set $\Omega \triangleq \{ \pmb { \eta } \in \mathbb { R } ^ { K } : A ( \pmb { \eta } ) < \infty \}$ .

It is convenient if the natural parameters are independent of each other. Formally, we say that an exponential family is minimal if there is no $\pmb { \eta } \in \mathbb { R } ^ { K } \setminus \{ 0 \}$ such that $\eta ^ { \mathsf { T } } \mathcal { T } ( \pmb { y } ) = 0$ . This last condition can be violated in the case of multinomial distributions, because of the sum to one constraint on the parameters; however, it is easy to reparameterize the distribution using $K - 1$ independent parameters, as we show below.

Equation (3.71) can be generalized by defining $\eta = f ( \phi )$ , where $\phi$ is some other, possibly smaller, set of parameters. In this case, the distribution has the form

$$
p ( { \pmb y } | \phi ) = h ( { \pmb y } ) \exp [ f ( \phi ) ^ { \top } \mathcal { T } ( { \pmb y } ) - A ( f ( \phi ) ) ]
$$

If the mapping from $\phi$ to $\eta$ is nonlinear, we call this a curved exponential family. If $\pmb { \eta } = f ( \phi ) = \phi$ , the model is said to be in canonical form. If, in addition, $\boldsymbol { \mathcal { T } } ( \boldsymbol { \mathsf { \pmb { y } } } ) = \boldsymbol { \mathsf { \pmb { y } } }$ , we say this is a natural exponential family or NEF. In this case, it can be written as

$$
p ( \pmb { y } | \pmb { \eta } ) = h ( \pmb { y } ) \exp [ \pmb { \eta } ^ { \top } \pmb { y } - A ( \pmb { \eta } ) ]
$$

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

# 3.4.2 Example

As a simple example, let us consider the Bernoulli distribution. We can write this in exponential family form as follows:

$$
\begin{array} { r l } & { \mathrm { B e r } ( y | \boldsymbol { \mu } ) = \boldsymbol { \mu } ^ { y } ( 1 - \boldsymbol { \mu } ) ^ { 1 - y } } \\ & { \qquad = \exp [ y \log ( \boldsymbol { \mu } ) + ( 1 - y ) \log ( 1 - \boldsymbol { \mu } ) ] } \\ & { \qquad = \exp [ \mathcal { T } ( y ) ^ { \top } \boldsymbol { \eta } ] } \end{array}
$$

where $\mathcal { T } ( y ) = \left[ \mathbb { I } \left( y = 1 \right) , \mathbb { I } \left( y = 0 \right) \right]$ , $\pmb { \eta } = [ \mathrm { l o g } ( \mu ) , \mathrm { l o g } ( 1 - \mu ) ]$ , and $\mu$ is the mean parameter. However, this is an over-complete representation since there is a linear dependence between the features. We can see this as follows:

$$
\mathbf { 1 } ^ { \mathsf { T } } \mathcal { T } ( y ) = \mathbb { I } \left( y = 0 \right) + \mathbb { I } \left( y = 1 \right) = 1
$$

If the representation is overcomplete, $\eta$ is not uniquely identifiable. It is common to use a minimal representation, which means there is a unique $\eta$ associated with the distribution. In this case, we can just define

$$
\mathrm { B e r } ( y | \mu ) = \exp \left[ y \log \left( { \frac { \mu } { 1 - \mu } } \right) + \log ( 1 - \mu ) \right]
$$

We can put this into exponential family form by defining

$$
\begin{array} { c } { { \eta = \displaystyle \log \left( \frac { \mu } { 1 - \mu } \right) } } \\ { { \mathcal { T } ( y ) = y } } \\ { { A ( \eta ) = - \log ( 1 - \mu ) = \log ( 1 + e ^ { \eta } ) } } \\ { { h ( y ) = 1 } } \end{array}
$$

We can recover the mean parameter $\mu$ from the canonical parameter $\eta$ using

$$
\mu = \sigma ( \eta ) = \frac { 1 } { 1 + e ^ { - \eta } }
$$

which we recognize as the logistic (sigmoid) function.

See the sequel to this book, [Mur23], for more examples.

# 3.4.3 Log partition function is cumulant generating function

The first and second cumulants of a distribution are its mean $\mathbb { E } \left[ Y \right]$ and variance $\mathbb { V } \left[ Y \right]$ , whereas the first and second moments are $\mathbb { E } \left[ Y \right]$ and $\mathbb { E } \left\lfloor Y ^ { 2 } \right\rfloor$ . We can also compute higher order cumulants (and moments). An important property of the exponential family is that derivatives of the log partition function can be used to generate all the cumulants of the sufficient statistics. In particular, the first and second cumulants are given by

$$
\begin{array} { r l } & { \nabla A ( \pmb { \eta } ) = \mathbb { E } \left[ \pmb { \mathcal { T } } ( \pmb { y } ) \right] } \\ & { \nabla ^ { 2 } A ( \pmb { \eta } ) = \mathrm { C o v } \left[ \pmb { \mathcal { T } } ( \pmb { y } ) \right] } \end{array}
$$

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

From the above result, we see that the Hessian is positive definite, and hence $A ( \pmb { \eta } )$ is convex in $\eta$ . Since the log likelihood has the form $\log p ( { \pmb y } | { \pmb \eta } ) = { \pmb \eta } ^ { 1 } T ( { \pmb y } ) - A ( { \pmb \eta } ) + \mathrm { c o n s t }$ , we see that this is concave, and hence the MLE has a unique global maximum.

# 3.4.4 Maximum entropy derivation of the exponential family

Suppose we want to find a distribution $p ( { \pmb x } )$ to describe some data, where all we know are the expected values ( $F _ { k }$ ) of certain features or functions $f _ { k } ( { \pmb x } )$ :

$$
\int d { \pmb x } p ( { \pmb x } ) f _ { k } ( { \pmb x } ) = F _ { k }
$$

For example, $f _ { 1 }$ might compute $x$ , $f _ { 2 }$ might compute $x ^ { 2 }$ , making $F _ { 1 }$ the empirical mean and $F _ { 2 }$ the empirical second moment. Our prior belief in the distribution is $q ( x )$ .

To formalize what we mean by “least number of assumptions”, we will search for the distribution that is as close as possible to our prior $q ( { \pmb x } )$ , in the sense of KL divergence (Section 6.2), while satisfying our constraints:

If we use a uniform prior, $q ( \pmb { x } ) \propto 1$ , minimizing the KL divergence is equivalent to maximizing the entropy (Section 6.1):

The result is called a maximum entropy model.

To minimize the KL subject to the constraints in Equation (3.86), and the constraint that $p ( { \pmb x } ) \geq 0$ and $\begin{array} { r } { \sum _ { \pmb { x } } p ( \pmb { x } ) = 1 } \end{array}$ , we will use Lagrange multipliers (see Section 8.5.1). The Lagrangian is given by

$$
J ( p , \lambda ) = - \sum _ { x } p ( x ) \log { \frac { p ( x ) } { q ( x ) } } + \lambda _ { 0 } \left( 1 - \sum _ { x } p ( x ) \right) + \sum _ { k } \lambda _ { k } \left( F _ { k } - \sum _ { x } p ( x ) f _ { k } \right)
$$

We can use the calculus of variations to take derivatives wrt the function $p$ , but we will adopt a simpler approach and treat $\mathbf { \nabla } _ { \mathbf { p } }$ as a fixed length vector (since we are assuming that $_ { x }$ is discrete). Then we have

$$
{ \frac { \partial J } { \partial p _ { c } } } = - 1 - \log { \frac { p ( x = c ) } { q ( x = c ) } } - \lambda _ { 0 } - \sum _ { k } \lambda _ { k } f _ { k } ( x = c )
$$

Setting ∂p ∂J = 0 for each c yields

$$
p ( { \pmb x } ) = \frac { q ( { \pmb x } ) } { Z } \exp \left( - \sum _ { k } \lambda _ { k } f _ { k } ( { \pmb x } ) \right)
$$

where we have defined $Z \triangleq e ^ { 1 + \lambda _ { 0 } }$ . Using the sum-to-one constraint, we have

$$
1 = \sum _ { \pmb { x } } p ( \pmb { x } ) = \frac { 1 } { Z } \sum _ { \pmb { x } } q ( \pmb { x } ) \exp \left( - \sum _ { k } \lambda _ { k } f _ { k } ( \pmb { x } ) \right)
$$

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

Hence the normalization constant is given by

$$
Z = \sum _ { \mathbf { x } } q ( \pmb { x } ) \exp \left( - \sum _ { k } \lambda _ { k } f _ { k } ( \pmb { x } ) \right)
$$

This has exactly the form of the exponential family, where ${ \pmb f } ( { \pmb x } )$ is the vector of sufficient statistics, $- \lambda$ are the natural parameters, and $q ( { \pmb x } )$ is our base measure.

For example, if the features are $f _ { 1 } ( x ) = x$ and $f _ { 2 } ( x ) = x ^ { 2 }$ , and we want to match the first and second moments, we get the Gaussian disribution.

# 3.5 Mixture models

One way to create more complex probability models is to take a convex combination of simple distributions. This is called a mixture model. This has the form

$$
p ( { \pmb y } | { \pmb \theta } ) = \sum _ { k = 1 } ^ { K } \pi _ { k } p _ { k } ( { \pmb y } )
$$

where $p _ { k }$ is the $k$ ’th mixture component, and $\pi _ { k }$ are the mixture weights which satisfy $0 \leq \pi _ { k } \leq 1$ and $\textstyle \sum _ { k = 1 } ^ { K } \pi _ { k } = 1$ .

We can re-express this model as a hierarchical model, in which we introduce the discrete latent variable $z \in \{ 1 , \ldots , K \}$ , which specifies which distribution to use for generating the output $\textbf {  { y } }$ . The prior on this latent variable is $p ( z = k | \pmb \theta ) = \pi _ { k }$ , and the conditional is $p ( \pmb { y } | \boldsymbol { z } = k , \pmb { \theta } ) = p _ { k } ( \pmb { y } ) = p ( \pmb { y } | \pmb { \theta } _ { k } )$ . That is, we define the following joint model:

$$
\begin{array} { c } { p ( z | \pmb { \theta } ) = \mathrm { C a t } ( z | \pmb { \pi } ) } \\ { p ( \pmb { y } | z = k , \pmb { \theta } ) = p ( \pmb { y } | \pmb { \theta } _ { k } ) } \end{array}
$$

where $\pmb \theta = ( \pi _ { 1 } , \ldots , \pi _ { K } , \pmb \theta _ { 1 } , \ldots , \pmb \theta _ { K } )$ are all the model parameters. The “generative story” for the data is that we first sample a specific component $z$ , and then we generate the observations $\mathbf { \nabla } _ { \mathbf { \boldsymbol { y } } }$ using the parameters chosen according to the value of $z$ . By marginalizing out $z$ , we recover Equation (3.94):

$$
p ( { \pmb y } | { \pmb \theta } ) = \sum _ { k = 1 } ^ { K } p ( { \boldsymbol z } = k | { \pmb \theta } ) p ( { \pmb y } | { \boldsymbol z } = k , { \pmb \theta } ) = \sum _ { k = 1 } ^ { K } { \pi } _ { k } p ( { \pmb y } | { \pmb \theta } _ { k } )
$$

We can create different kinds of mixture model by varying the base distribution $p _ { k }$ , as we illustrate below.

# 3.5.1 Gaussian mixture models

A Gaussian mixture model or GMM, also called a mixture of Gaussians (MoG), is defined as follows:

$$
p ( \pmb { y } | \pmb { \theta } ) = \sum _ { k = 1 } ^ { K } \pi _ { k } \mathcal { N } ( \pmb { y } | \pmb { \mu } _ { k } , \pmb { \Sigma } _ { k } )
$$

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

![](images/1b2fe146b7b1c03d91275d67803a9c0dd7b235ad07ea1026b0fb8d8dfa258068.jpg)  
Figure 3.11: $A$ mixture of 3 Gaussians in 2d. (a) We show the contours of constant probability for each component in the mixture. (b) A surface plot of the overall density. Adapted from Figure 2.23 of [Bis06]. Generated by gmm_plot_demo.ipynb

![](images/9680bb785fa8c7cb97b69abe6ce2869e9bdc3b68b31a6a0d38c849348e07ea53.jpg)  
Figure 3.12: (a) Some data in 2d. (b) A possible clustering using $K = 5$ clusters computed using a GMM. Generated by gmm_2d.ipynb.

In Figure 3.11 we show the density defined by a mixture of 3 Gaussians in 2d. Each mixture component is represented by a different set of elliptical contours. If we let the number of mixture components grow sufficiently large, a GMM can approximate any smooth distribution over $\mathbb { R } ^ { D }$ .

GMMs are often used for unsupervised clustering of real-valued data samples $\pmb { y } _ { n } \in \mathbb { R } ^ { D }$ . This works in two stages. First we fit the model e.g., by computing the MLE $\hat { \pmb { \theta } } = \mathrm { a r g m a x } \log p ( \mathcal { D } | \pmb { \theta } )$ , where $\mathcal { D } = \{ \pmb { y } _ { n } : n = 1 : N \}$ . (We discuss how to compute this MLE in Section 8.7.3.) Then we associate each data point ${ \bf { \nabla } } \mathbf { \pmb { y } } _ { n }$ with a discrete latent or hidden variable $z _ { n } \in \{ 1 , \ldots , K \}$ which specifies the identity of the mixture component or cluster which was used to generate ${ \bf { y } } _ { n }$ . These latent identities are unknown, but we can compute a posterior over them using Bayes rule:

$$
r _ { n k } \triangleq p ( z _ { n } = k | y _ { n } , \pmb \theta ) = \frac { p ( z _ { n } = k | \pmb \theta ) p ( \pmb y _ { n } | z _ { n } = k , \pmb \theta ) } { \sum _ { k ^ { \prime } = 1 } ^ { K } p ( z _ { n } = k ^ { \prime } | \pmb \theta ) p ( \pmb y _ { n } | z _ { n } = k ^ { \prime } , \pmb \theta ) }
$$

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

![](images/4794073765f5c142dbd3ba5cb11193539c4e31f01ee9fd9817fb72a7ea45b4a4.jpg)  
Figure 3.13: We fit a mixture of 20 Bernoullis to the binarized MNIST digit data. We visualize the estimated cluster means ${ \hat { \pmb { \mu } } } _ { k }$ . The numbers on top of each image represent the estimated mixing weights $\hat { \pi } _ { k }$ . No labels were used when training the model. Generated by mix_bernoulli_em_mnist.ipynb.

The quantity $r _ { n k }$ is called the responsibility of cluster $k$ for data point $n$ . Given the responsibilities, we can compute the most probable cluster assignment as follows:

$$
\hat { z } _ { n } = \arg \operatorname* { m a x } _ { k } r _ { n k } = \arg \operatorname* { m a x } _ { k } \left[ \log p ( \pmb { y } _ { n } | \boldsymbol { z } _ { n } = k , \pmb { \theta } ) + \log p ( \boldsymbol { z } _ { n } = k | \pmb { \theta } ) \right]
$$

This is known as hard clustering. (If we use the responsibilities to fractionally assign each data point to different clusters, it is called soft clustering.) See Figure 3.12 for an example.

If we have a uniform prior over $z _ { n }$ , and we use spherical Gaussians with $\boldsymbol { \Sigma } _ { k } = \mathbf { I }$ , the hard clustering problem reduces to

$$
z _ { n } = \mathop { \mathrm { a r g m i n } } _ { k } | | \pmb { y } _ { n } - \hat { \pmb { \mu } } _ { k } | | _ { 2 } ^ { 2 }
$$

In other words, we assign each data point to its closest centroid, as measured by Euclidean distance.   
This is the basis of the $\mathbf { K }$ -means clustering algorithm, which we discuss in Section 21.3.

# 3.5.2 Bernoulli mixture models

If the data is binary valued, we can use a Bernoulli mixture model or BMM (also called a mixture of Bernoullis), where each mixture component has the following form:

$$
p ( \pmb { y } | \boldsymbol { z } = \boldsymbol { k } , \pmb { \theta } ) = \prod _ { d = 1 } ^ { D } \mathrm { B e r } ( y _ { d } | \mu _ { d k } ) = \prod _ { d = 1 } ^ { D } \mu _ { d k } ^ { y _ { d } } ( 1 - \mu _ { d k } ) ^ { 1 - y _ { d } }
$$

Here $\mu _ { d k }$ is the probability that bit $d$ turns on in cluster $k$ .

As an example, we fit a BMM using $K = 2 0$ components to the MNIST dataset (Section 3.5.2). (We use the EM algorithm to do this fitting, which is similar to EM for GMMs discussed in Section 8.7.3; however we can also use SGD to fit the model, which is more efficient for large datasets.2 ) The resulting parameters for each mixture component (i.e., $\pmb { \mu } _ { k }$ and $\pi _ { k }$ ) are shown in Figure 3.13. We see that the model has “discovered” a representation of each type of digit. (Some digits are represented multiple times, since the model does not know the “true” number of classes. See Section 21.3.7 for more information on how to choose the number $K$ of mixture components.)

![](images/7db73c8991acc4b037b5046a5420a0603fa206b562fd2cb1b313aac6d6794c10.jpg)  
Figure 3.14: Water sprinkler PGM with corresponding binary CPTs. $T$ and F stand for true and false.

# 3.6 Probabilistic graphical models \*

I basically know of two principles for treating complicated systems in simple ways: the first is the principle of modularity and the second is the principle of abstraction. I am an apologist for computational probability in machine learning because I believe that probability theory implements these two principles in deep and intriguing ways — namely through factorization and through averaging. Exploiting these two mechanisms as fully as possible seems to me to be the way forward in machine learning. — Michael Jordan, 1997 (quoted in [Fre98]).

We have now introduced a few simple probabilistic building blocks. In Section 3.3, we showed one way to combine some Gaussian building blocks to build a high dimensional distribution $p ( \pmb { y } )$ from simpler parts, namely the marginal $p ( \pmb { y } _ { 1 } )$ and the conditional $p ( \pmb { y } _ { 2 } | \pmb { y } _ { 1 } )$ . This idea can be extended to define joint distributions over sets of many random variables. The key assumption we will make is that some variables are conditionally independent of others. We will represent our CI assumptions using graphs, as we briefly explain below. (See the sequel to this book, [Mur23], for more information.)

# 3.6.1 Representation

A probabilistic graphical model or PGM is a joint probability distribution that uses a graph structure to encode conditional independence assumptions. When the graph is a directed acyclic

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022 graph or DAG, the model is sometimes called a Bayesian network, although there is nothing inherently Bayesian about such models.

The basic idea in PGMs is that each node in the graph represents a random variable, and each edge represents a direct dependency. More precisely, each lack of edge represents a conditional independency. In the DAG case, we can number the nodes in topological order (parents before children), and then we connect them such that each node is conditionally independent of all its predecessors given its parents:

$$
Y _ { i } \perp \mathbf { Y } _ { \mathrm { p r e d } ( i ) \backslash \mathrm { p a } ( i ) } | \mathbf { Y } _ { \mathrm { p a } ( i ) }
$$

where $\mathrm { p a } ( i )$ are the parents of node $i$ , and $\mathrm { p r e d } ( i )$ are the predecessors of node $i$ in the ordering. (This is called the ordered Markov property.) Consequently, we can represent the joint distribution as follows:

$$
p ( \mathbf { Y } _ { 1 : N _ { G } } ) = \prod _ { i = 1 } ^ { N _ { G } } p ( Y _ { i } | \mathbf { Y } _ { \mathrm { p a } ( i ) } )
$$

where $N _ { G }$ is the number of nodes in the graph.

# 3.6.1.1 Example: water sprinkler network

Suppose we want to model the dependencies between 4 random variables: $C$ (whether it is cloudy season or not), $R$ (whether it is raining or not), $S$ (whether the water sprinkler is on or not), and $W$ (whether the grass is wet or not). We know that the cloudy season makes rain more likely, so we add a $C  R$ arc. We know that the cloudy season makes turning on a water sprinkler less likely, so we add a $C  S$ arc. Finally, we know that either rain or sprinklers can cause the grass to get wet, so we add $S  W$ and $R \to W$ edges.

Formally, this defines the following joint distribution:

$$
p ( C , S , R , W ) = p ( C ) p ( S | C ) p ( R | C , \mathcal { S } ) p ( W | S , R , \mathcal { C } )
$$

where we strike through terms that are not needed due to the conditional independence properties of the model.

Each term $p ( Y _ { i } | \mathbf { Y _ { p a } } ( i ) )$ is a called the conditional probability distribution or CPD for node $i$ . This can be any kind of distribution we like. In Figure 3.14, we assume each CPD is a conditional categorical distribution, which can be represented as a conditional probability table or CPT. We can represent the $i$ ’th CPT as follows:

$$
\theta _ { i j k } \triangleq p ( Y _ { i } = k | \mathbf { Y } _ { \mathrm { p a } ( i ) } = j )
$$

This satisfies the properties $0 \leq \theta _ { i j k } \leq 1$ and $\begin{array} { r } { \sum _ { k = 1 } ^ { K _ { i } } \theta _ { i j k } = 1 } \end{array}$ for each row $j$ . Here $i$ indexes nodes, $i \in [ N _ { G } ]$ ; $k$ indexes node states, $k \in [ K _ { i } ]$ , where $K _ { i }$ is the number of states for node $i$ ; and $j$ indexes joint parent states, $j \in [ J _ { i } ]$ , where $\begin{array} { r } { J _ { i } = \prod _ { p \in \mathrm { p a } ( i ) } K _ { p } } \end{array}$ . For example, the wet grass node has 2 binary parents, so there are 4 parent states.

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

![](images/94634193e77935637a0ec47ee75bf0fe297d3c858946609249a68d3ac352efd5.jpg)  
Figure 3.15: Illustration of first and second order autoregressive (Markov) models.

# 3.6.1.2 Example: Markov chain

Suppose we want to create a joint probability distribution over variable-length sequences, $p ( \boldsymbol { y } _ { 1 : T } )$ . If each variable $y _ { t }$ represents a word from a vocabulary with $K$ possible values, so $y _ { t } \in \{ 1 , \ldots , K \}$ , the resulting model represents a distribution over possible sentences of length $T$ ; this is often called a language model.

By the chain rule of probability, we can represent any joint distribution over $T$ variables as follows:

$$
p ( \pmb { y } _ { 1 : T } ) = p ( y _ { 1 } ) p ( y _ { 2 } | y _ { 1 } ) p ( y _ { 3 } | y _ { 2 } , y _ { 1 } ) p ( y _ { 4 } | y _ { 3 } , y _ { 2 } , y _ { 1 } ) \dots = \prod _ { t = 1 } ^ { T } p ( y _ { t } | \pmb { y } _ { 1 : t - 1 } )
$$

Unfortunately, the number of parameters needed to represent each conditional distribution $p ( y _ { t } | y _ { 1 : t - 1 } )$ grows exponentially with $t$ . However, suppose we make the conditional independence assumption that the future, $\mathbf { \mathscr { y } } _ { t + 1 : T }$ , is independent of the past, $\mathbf { \delta } _ { \mathbf { \delta } } \mathbf { \cdot } \mathbf { \delta } _ { t - 1 }$ , given the present, $y _ { t }$ . This is called the first order Markov condition, and is repesented by the PGM in Figure 3.15(a). With this assumption, we can write the joint distribution as follows:

$$
p ( \pmb { y } _ { 1 : T } ) = p ( y _ { 1 } ) p ( y _ { 2 } | y _ { 1 } ) p ( y _ { 3 } | y _ { 2 } ) p ( y _ { 4 } | y _ { 3 } ) \dots = p ( y _ { 1 } ) \prod _ { t = 2 } ^ { T } p ( y _ { t } | y _ { t - 1 } )
$$

This is called a Markov chain, Markov model or autoregressive model of order 1.

The function $p ( y _ { t } | y _ { t - 1 } )$ is called the transition function, transition kernel or Markov kernel. This is just a conditional distribution over the states at time $t$ given the state at time $t - 1$ , and hence it satisfies the conditions $p ( y _ { t } | y _ { t - 1 } ) \ge 0$ and $\begin{array} { r } { \sum _ { k = 1 } ^ { K } p ( y _ { t } = k | y _ { t - 1 } = j ) = 1 } \end{array}$ . We can represent this CPT as a stochastic matrix, $A _ { j k } = p ( y _ { t } = k | y _ { t - 1 } = j $ ), where each row sums to 1. This is known as the state transition matrix. We assume this matrix is the same for all time steps, so the model is said to be homogeneous, stationary, or time-invariant. This is an example of parameter tying, since the same parameter is shared by multiple variables. This assumption allows us to model an arbitrary number of variables using a fixed number of parameters.

The first-order Markov assumption is rather strong. Fortunately, we can easily generalize first-order models to depend on the last $M$ observations, thus creating a model of order (memory length) $M$ :

$$
p ( \pmb { y } _ { 1 : T } ) = p ( \pmb { y } _ { 1 : M } ) \prod _ { t = M + 1 } ^ { T } p ( \pmb { y } _ { t } | \pmb { y } _ { t - M : t - 1 } ) \qquad \
$$

This is called an $M ^ { \prime } { \bf t h }$ order Markov model. For example, if $M = 2$ , $y _ { t }$ depends on $y _ { t - 1 }$ and $_ { y _ { t - 2 } }$ , as shown in Figure 3.15(b). This is called a trigram model, since it models the distribution

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022 over word triples. If we use $M = 1$ , we get a bigram model, which models the distribution over word pairs.

For large vocabulary sizes, the number of parameters needed to estimate the conditional distributions for $M$ -gram models for large $M$ can become prohibitive. In this case, we need to make additional assumptions beyond conditional independence. For example, we can assume that $p \big ( y _ { t } | y _ { t - M : t - 1 } \big )$ can be represented as a low-rank matrix, or in terms of some kind of neural network. This is called a neural language model. See Chapter 15 for details.

# 3.6.2 Inference

A PGM defines a joint probability distribution. We can therefore use the rules of marginalization and conditioning to compute $p ( \mathbf { Y } _ { i } | \mathbf { Y } _ { j } = \pmb { y } _ { j } )$ for any sets of variables $i$ and $j$ . Efficient algorithms to perform this computation are discussed in the sequel to this book, [Mur23].

For example, consider the water sprinkler example in Figure 3.14. Our prior belief that it has rained is given by $p ( R = 1 ) = 0 . 5$ . If we see that the grass is wet, then our posterior belief that it has rained changes to $p ( R = 1 | W = 1 ) = 0 . 7 0 7 9$ . Now suppose we also notice the water sprinkler was turned on: our belief that it rained goes down to $p ( R = 1 | W = 1 , S = 1 ) = 0 . 3 2 0 4$ . This negative mutual interaction between multiple causes of some observations is called the explaining away effect, also known as Berkson’s paradox. (See sprinkler_pgm.ipynb for some code that reproduces these calculations.)

# 3.6.3 Learning

If the parameters of the CPDs are unknown, we can view them as additional random variables, add them as nodes to the graph, and then treat them as hidden variables to be inferred. Figure 3.16(a) shows a simple example, in which we have $N$ iid random variables, ${ \bf { y } } _ { n }$ , all drawn from the same distribution with common parameter $\pmb \theta$ . (The shaded nodes represent observed values, whereas the unshaded (hollow) nodes represent latent variables or parameters.)

More precisely, the model encodes the following “generative story” about the data:

$$
\begin{array} { c } { \pmb { \theta } \sim p ( \pmb { \theta } ) } \\ { \pmb { y } _ { n } \sim p ( \pmb { y } | \pmb { \theta } ) } \end{array}
$$

where $p ( \pmb \theta )$ is some (unspecified) prior over the parameters, and $p ( \pmb { y } | \pmb { \theta } )$ is some specified likelihood function. The corresponding joint distribution has the form

$$
p ( \mathcal { D } , \pmb { \theta } ) = p ( \pmb { \theta } ) p ( \mathcal { D } | \pmb { \theta } )
$$

where $\mathcal { D } = ( \pmb { y } _ { 1 } , \dots , \pmb { y } _ { N } )$ . By virtue of the iid assumption, the likelihood can be rewritten as follows:

$$
p ( \mathcal { D } | \pmb { \theta } ) = \prod _ { n = 1 } ^ { N } p ( \pmb { y } _ { n } | \pmb { \theta } )
$$

Notice that the order of the data vectors is not important for defining this model, i.e., we can permute the numbering of the leaf nodes in the PGM. When this property holds, we say that the data is exchangeable.

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

![](images/8957ab9839ef2e10ffba6727a9105537ddb063cbd5f412cc92707a9c96e5cf7c.jpg)  
Figure 3.16: Left: data points ${ \pmb y } _ { n }$ are conditionally independent given $\pmb \theta$ . Right: Same model, using plate notation. This represents the same model as the one on the left, except the repeated $\pmb { y } _ { n }$ nodes are inside a box, known as a plate; the number in the lower right hand corner, $N$ , specifies the number of repetitions of the ${ \pmb y } _ { n }$ node.

# 3.6.3.1 Plate notation

In Figure 3.16(a), we see that the $\mathbf { \nabla } _ { \mathbf { \boldsymbol { y } } }$ nodes are repeated $N$ times. To avoid visual clutter, it is common to use a form of syntactic sugar called plates. This is a notational convention in which we draw a little box around the repeated variables, with the understanding that nodes within the box will get repeated when the model is unrolled. We often write the number of copies or repetitions in the bottom right corner of the box. This is illustrated in Figure 3.16(b). This notation is widely used to represent certain kinds of Bayesian model.

Figure 3.17 shows a more interesting example, in which we represent a GMM (Section 3.5.1) as a graphical model. We see that this encodes the joint distribution

$$
y _ { 1 : N } , z _ { 1 : N } , \theta ) = p ( \pi ) \left[ \prod _ { k = 1 } ^ { K } p ( \pmb \mu _ { k } ) p ( \pmb \Sigma _ { k } ) \right] \left[ \prod _ { n = 1 } ^ { N } p ( z _ { n } | \pmb \pi ) p ( \pmb y _ { n } | z _ { n } , \pmb \mu _ { 1 : K } , \pmb \Sigma _ { 1 : K } ) \right]
$$

We see that the latent variables $z _ { n }$ as well as the unknown paramters, $\pmb \theta = ( \pmb \pi , \pmb \mu _ { 1 : K } , \pmb \Sigma _ { 1 : K } )$ , are all shown as unshaded nodes.

# 3.7 Exercises

Exercise 3.1 [Uncorrelated does not imply independent \*]

Let $X \sim U ( - 1 , 1 )$ and $Y = X ^ { 2 }$ . Clearly $Y$ is dependent on $X$ (in fact, $Y$ is uniquely determined by $X$ ).   
However, show that $\rho ( X , Y ) = 0$ . Hint: if $X \sim U ( a , b )$ then $E [ X ] = ( a + b ) / 2$ and $\mathbb { V } \left[ X \right] = ( b - a ) ^ { 2 } / 1 2$ .

Exercise 3.2 [Correlation coefficient is between -1 and $^ +$ 1] Prove that $- 1 \le \rho ( X , Y ) \le 1$

Exercise 3.3 [Correlation coefficient for linearly related variables is $\pm 1$ \*]   
Show that, if $Y = a X + b$ for some parameters $a > 0$ and $b$ , then $\rho ( X , Y ) = 1$ . Similarly show that if $a < 0$ , then $\rho ( X , Y ) = - 1$ .

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

![](images/147f78054456ba50a6b476b1078603daae62b3c523932b8a0f31b0269ebdbf78.jpg)  
Figure 3.17: A Gaussian mixture model represented as a graphical model.

Exercise 3.4 [Linear combinations of random variables] Let $_ { \pmb { x } }$ be a random vector with mean $_ { m }$ and covariance matrix $\Sigma$ . Let $\mathbf { A }$ and $\mathbf { B }$ be matrices.

a. Derive the covariance matrix of ${ \bf A } x$ .   
b. Show that $\operatorname { t r } ( \mathbf { A } \mathbf { B } ) = \operatorname { t r } ( \mathbf { B } \mathbf { A } )$ .   
c. Derive an expression for $\mathbb { E } \left[ \pmb { x } ^ { T } \mathbf { A } \pmb { x } \right]$ . Exercise 3.5 [Gaussian vs jointly Gaussian ]   
Let $X \sim \mathcal { N } ( 0 , 1 )$ and $Y = W X$ , where $p ( W = - 1 ) = p ( W = 1 ) = 0 . 5$ . It is clear that $X$ and $Y$ are not independent, since $Y$ is a function of $X$ .   
a. Show $Y \sim { \mathcal { N } } ( 0 , 1 )$ .   
b. Show $\operatorname { C o v } \left[ X , Y \right] = 0$ . Thus $X$ and $Y$ are uncorrelated but dependent, even though they are Gaussian. Hint: use the definition of covariance

$$
\operatorname { C o v } \left[ X , Y \right] = \mathbb { E } \left[ X Y \right] - \mathbb { E } \left[ X \right] \mathbb { E } \left[ Y \right]
$$

and the rule of iterated expectation

$$
\mathbb { E } \left[ X Y \right] = \mathbb { E } \left[ \mathbb { E } \left[ X Y | W \right] \right]
$$

Exercise 3.6 [Normalization constant for a multidimensional Gaussian] Prove that the normalization constant for a $d$ -dimensional Gaussian is given by

$$
( 2 \pi ) ^ { d / 2 } | \Sigma | ^ { \frac { 1 } { 2 } } = \int \exp ( - \frac { 1 } { 2 } ( { \pmb x } - { \pmb \mu } ) ^ { T } { \pmb \Sigma } ^ { - 1 } ( { \pmb x } - { \pmb \mu } ) ) d { \pmb x }
$$

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

Hint: diagonalize $\pmb { \Sigma }$ and use the fact that $| \Sigma | = \prod _ { i \atop r } \lambda _ { i }$ to write the joint pdf as a product of $d$ one-dimensional Gaussians in a transformed coordinate system. (QYou will need the change of variables formula.) Finally, use the normalization constant for univariate Gaussians.

Exercise 3.7 [Sensor fusion with known variances in 1d]

Suppose we have two sensors with known (and different) variances $v _ { 1 }$ and $_ { v _ { 2 } }$ , but unknown (and the same) mean $\mu$ . Suppose we observe $n _ { 1 }$ observations $y _ { i } ^ { ( 1 ) } \sim \mathcal { N } ( \mu , v _ { 1 } )$ from the first sensor and $n _ { 2 }$ observations $y _ { i } ^ { ( 2 ) } \sim \mathcal { N } ( \mu , v _ { 2 } )$ from the second sensor. (For example, suppose $\mu$ is the true temperature outside, and sensor $^ { 1 }$ is a precise (low variance) digital thermosensing device, and sensor 2 is an imprecise (high variance) mercury thermometer.) Let $\mathcal { D }$ represent all the data from both sensors. What is the posterior $p ( \mu | \mathcal { D } )$ , assuming a non-informative prior for $\mu$ (which we can simulate using a Gaussian with a precision of $0$ )? Give an explicit expression for the posterior mean and variance.

Exercise 3.8 [Show that the Student distribution can be written as a Gaussian scale mixture]

Show that a Student distribution can be written as a Gaussian scale mixture, where we use a Gamma mixing distribution on the precision $\alpha$ , i.e.

$$
p ( x | \mu , a , b ) = \int _ { 0 } ^ { \infty } \mathcal { N } ( x | \mu , \alpha ^ { - 1 } ) \mathrm { G a } ( \alpha | a , b ) d \alpha
$$

This can be viewed as an infinite mixture of Gaussians, with different precisions.

# 4 Statistics

# 4.1 Introduction

In Chapter 2–Chapter 3, we assumed all the parameters $\pmb \theta$ of our probability models were known. In this chapter, we discuss how to learn these parameters from data.

The process of estimating $\pmb \theta$ from $\mathcal { D }$ is called model fitting, or training, and is at the heart of machine learning. There are many methods for producing such estimates, but most boil down to an optimization problem of the form

$$
\hat { \pmb { \theta } } = \operatorname * { a r g m i n } _ { \pmb { \theta } } \mathcal { L } ( \pmb { \theta } )
$$

where ${ \mathcal { L } } ( \theta )$ is some kind of loss function or objective function. We discuss several different loss functions in this chapter. In some cases, we also discuss how to solve the optimization problem in closed form. In general, however, we will need to use some kind of generic optimization algorithm, which we discuss in Chapter 8.

In addition to computing a point estimate, $\hat { \pmb { \theta } }$ , we discuss how to model our uncertainty or confidence in this estimate. In statistics, the process of quantifying uncertainty about an unknown quantity estimated from a finite sample of data is called inference. We will discuss both Bayesian and frequentist approaches to inference.1

# 4.2 Maximum likelihood estimation (MLE)

The most common approach to parameter estimation is to pick the parameters that assign the highest probability to the training data; this is called maximum likelihood estimation or MLE. We give more details below, and then give a series of worked examples.

# 4.2.1 Definition

We define the MLE as follows:

$$
\hat { \pmb { \theta } } _ { \mathrm { m l e } } \triangleq \underset { \pmb { \theta } } { \mathrm { a r g m a x } } p ( \mathcal { D } | \pmb { \theta } )
$$

We usually assume the training examples are independently sampled from the same distribution, so the (conditional) likelihood becomes

$$
p ( \mathcal { D } | \pmb { \theta } ) = \prod _ { n = 1 } ^ { N } p ( \pmb { y } _ { n } | \pmb { x } _ { n } , \pmb { \theta } )
$$

This is known as the iid assumption, which stands for “independent and identically distributed”. We usually work with the log likelihood, which is given by

$$
\ell ( \pmb \theta ) \triangleq \log p ( \mathcal { D } | \pmb \theta ) = \sum _ { n = 1 } ^ { N } \log p ( \pmb y _ { n } | \pmb x _ { n } , \pmb \theta )
$$

This decomposes into a sum of terms, one per example. Thus the MLE is given by

$$
\hat { \pmb { \theta } } _ { \mathrm { m l e } } = \underset { \pmb { \theta } } { \operatorname { a r g m a x } } \sum _ { n = 1 } ^ { N } \log p ( \pmb { y } _ { n } | \pmb { x } _ { n } , \pmb { \theta } )
$$

Since most optimization algorithms (such as those discussed in Chapter 8) are designed to minimize cost functions, we can redefine the objective function to be the (conditional) negative log likelihood or NLL:

$$
\mathrm { N L L } ( \pmb \theta ) \triangleq - \log p ( \mathcal { D } | \pmb \theta ) = - \sum _ { n = 1 } ^ { N _ { \mathcal { D } } } \log p ( \pmb y _ { n } | \pmb x _ { n } , \pmb \theta )
$$

Minimizing this will give the MLE. If the model is unconditional (unsupervised), the MLE becomes

$$
\hat { \pmb { \theta } } _ { \mathrm { m l e } } = \underset { \pmb { \theta } } { \operatorname { a r g m i n } } - \sum _ { n = 1 } ^ { N } \log p ( \pmb { y } _ { n } | \pmb { \theta } )
$$

since we have outputs ${ \bf { y } } _ { n }$ but no inputs ${ \boldsymbol { \mathbf { \mathit { x } } } } _ { n }$ .

Alternatively we may want to maximize the joint likelihood of inputs and outputs. The MLE in this case becomes

$$
\hat { \pmb { \theta } } _ { \mathrm { m l e } } = \underset { \pmb { \theta } } { \operatorname { a r g m i n } } - \sum _ { n = 1 } ^ { N } \log p ( \pmb { y } _ { n } , \pmb { x } _ { n } | \pmb { \theta } )
$$

# 4.2.2 Justification for MLE

There are several ways to justify the method of MLE. One way is to view it as simple point approximation to the Bayesian posterior $p ( \pmb { \theta } | \mathcal { D } )$ using a uniform prior, as explained in Section 4.6.7.1.

In particular, suppose we approximate the posterior by a delta function, $p ( \pmb \theta | \mathcal { D } ) = \delta ( \pmb \theta - \hat { \pmb \theta } _ { \mathrm { m a p } } )$ , where $\hat { \pmb { \theta } } _ { \mathrm { m a p } }$ is the posterior mode, given by

$$
\hat { \pmb \theta } _ { \mathrm { m a p } } = \underset { \pmb \theta } { \operatorname { a r g m a x } } \log p ( \pmb \theta | \mathcal { D } ) = \underset { \pmb \theta } { \operatorname { a r g m a x } } \log p ( \mathcal { D } | \pmb \theta ) + \log p ( \pmb \theta )
$$

If we use a uniform prior, $p ( \pmb \theta ) \propto 1$ , the MAP estimate becomes equal to the MLE, $\hat { \pmb { \theta } } _ { \mathrm { m a p } } = \hat { \pmb { \theta } } _ { \mathrm { m l e } }$ . Another way to justify the use of the MLE is that the resulting predictive distribution $p ( \boldsymbol { y } | \hat { \boldsymbol { \theta } } _ { \mathrm { m l e } } )$ is as close as possible (in a sense to be defined below) to the empirical distribution of the data. In the unconditional case, the empirical distribution is defined by

$$
p _ { \mathcal { D } } ( \pmb { y } ) \triangleq \frac { 1 } { N } \sum _ { n = 1 } ^ { N } \delta ( \pmb { y } - \pmb { y } _ { n } )
$$

We see that the empirical distribution is a series of delta functions or “spikes” at the observed training points. We want to create a model whose distribution $q ( y ) = p ( y | \pmb { \theta } )$ is similar to $p _ { \mathcal { D } } ( \pmb { y } )$ .

A standard way to measure the (dis)similarity between probability distributions $p$ and $q$ is the Kullback Leibler divergence, or KL divergence. We give the details in Section 6.2, but in brief this is defined as

$$
\begin{array} { l } { { \cal D } _ { \mathbb { K L } } \left( p \Vert q \right) = \displaystyle \sum _ { y } p ( y ) \log \frac { p ( y ) } { q ( y ) } \ } \\ { = \underbrace { \displaystyle \sum _ { y } p ( y ) \log p ( y ) } _ { \mathrm { - } \mathbb { H } ( p ) } \underbrace { - \sum _ { y } p ( y ) \log q ( y ) } _ { \mathbb { H } _ { c e } ( p , q ) } } \end{array}
$$

where $\mathbb { H } \left( p \right)$ is the entropy of $p$ (see Section 6.1), and $\mathbb { H } _ { c e } \left( p , q \right)$ is the cross-entropy of $p$ and $q$ (see Section 6.1.2). One can show that $D _ { \mathbb { K L } } \left( p \parallel q \right) \ge 0$ , with equality iff $p = q$ .

If we define $q ( \pmb { y } ) = p ( \pmb { y } | \pmb { \theta } )$ , and set $p ( \pmb { y } ) = p _ { \mathcal { D } } ( \pmb { y } )$ , then the KL divergence becomes

$$
\begin{array} { l } { { \displaystyle { \cal D } _ { \mathbb { K L } } \left( p \| q \right) = \sum _ { y } \left[ p _ { \mathcal D } ( { \pmb y } ) \log p _ { \mathcal D } ( { \pmb y } ) - p _ { \mathcal D } ( { \pmb y } ) \log q ( { \pmb y } ) \right] } } \\ { ~ } \\ { { \displaystyle ~ = - \mathbb { H } ( p _ { \mathcal D } ) - \frac { 1 } { N } \sum _ { n = 1 } ^ { N } \log p ( { \pmb y } _ { n } | \theta ) } } \\ { ~ } \\ { { \displaystyle ~ = \mathrm { c o n s t } + \mathrm { N L L } ( \theta ) } } \end{array}
$$

The first term is a constant which we can ignore, leaving just the NLL. Thus minimizing the KL is equivalent to minimizing the NLL which is equivalent to computing the MLE, as in Equation (4.7). We can generalize the above results to the supervised (conditional) setting by using the following empirical distribution:

$$
p _ { \mathcal { D } } ( \pmb { x } , \pmb { y } ) = p _ { \mathcal { D } } ( \pmb { y } | \pmb { x } ) p _ { \mathcal { D } } ( \pmb { x } ) = \frac { 1 } { N } \sum _ { n = 1 } ^ { N } \delta ( \pmb { x } - \pmb { x } _ { n } ) \delta ( \pmb { y } - \pmb { y } _ { n } )
$$

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

The expected KL then becomes

$$
\begin{array} { l } { \displaystyle \mathbb { E } _ { p _ { D } ( \pmb { x } ) } [ D _ { \mathbb { K L } } ( p _ { D } ( \boldsymbol { Y } | \boldsymbol { x } ) \mathrm { ~ } \mathrm { ~ } \mathrm { ~ } \mathrm { ~ } \mathrm { ~ } ] \mathrm { ~ } q ( \boldsymbol { Y } | \pmb { x } ) ) ] = \sum _ { \boldsymbol { x } } p _ { \mathcal D } ( \pmb { x } ) [ \displaystyle \sum _ { \boldsymbol { y } } p _ { \mathcal D } ( \pmb { y } | \boldsymbol { x } ) \log \frac { p _ { D } ( \pmb { y } | \boldsymbol { x } ) } { q ( \pmb { y } | \pmb { x } ) } ] } \\ { \displaystyle \mathrm { ~ \qquad ~ } = \mathrm { c o n s t - } \sum _ { \boldsymbol { x } , \boldsymbol { y } } p _ { \mathcal D } ( \pmb { x } , \boldsymbol { y } ) \log q ( \pmb { y } | \pmb { x } ) } \\ { \displaystyle \mathrm { ~ \qquad ~ } = \mathrm { c o n s t - } \frac { 1 } { N } \sum _ { n = 1 } ^ { N } \log p ( y _ { n } | \pmb { x } _ { n } , \theta ) } \end{array}
$$

Minimizing this is equivalent to minimizing the conditional NLL in Equation (4.6).

# 4.2.3 Example: MLE for the Bernoulli distribution

Suppose $Y$ is a random variable representing a coin toss, where the event $Y = 1$ corresponds to heads and $Y = 0$ corresponds to tails. Let $\theta = p ( Y = 1 )$ be the probability of heads. The probability distribution for this rv is the Bernoulli, which we introduced in Section 2.4.

The NLL for the Bernoulli distribution is given by

$$
\begin{array} { l } { { \displaystyle \mathrm { N L L } ( \theta ) = - \log \prod _ { n = 1 } ^ { N } p ( y _ { n } | \theta ) } } \\ { ~ = - \log \prod _ { n = 1 } ^ { N } \theta ^ { [ [ g _ { n } = 1 ) } ( 1 - \theta ) ^ { ] ( y _ { n } = 0 ) } } \\ { ~ = - \displaystyle \sum _ { n = 1 } ^ { N } [ [ ( y _ { n } = 1 ) \log \theta + \mathbb { I } ( y _ { n } = 0 ) \log ( 1 - \theta ) ] } \\ { ~ = - [ N _ { 1 } \log \theta + N _ { 0 } \log ( 1 - \theta ) ] } \end{array}
$$

where we have defined $\begin{array} { r } { N _ { 1 } = \sum _ { n = 1 } ^ { N _ { D } } \mathbb { I } \left( y _ { n } = 1 \right) } \end{array}$ and $\begin{array} { r } { N _ { 0 } = \sum _ { n = 1 } ^ { N _ { \mathcal { D } } } \mathbb { I } \left( y _ { n } = 0 \right) } \end{array}$ , representing the number of heads and tails. (The NLL for the binomial is the same as for the Bernoulli, modulo an irrelevant $\binom { N } { c }$ term, which is a constant independent of $\theta$ .) These two numbers are called the sufficient statistics of the data, since they summarize everything we need to know about $\mathcal { D }$ . The total count, $N = N _ { 0 } + N _ { 1 }$ , is called the sample size.

The MLE can be found by solving $\begin{array} { r } { \frac { d } { d \theta } \mathrm { N L L } ( \theta ) = 0 } \end{array}$ . The derivative of the NLL is

$$
\frac { d } { d \theta } \mathrm { { N L L } } ( \theta ) = \frac { - N _ { 1 } } { \theta } + \frac { N _ { 0 } } { 1 - \theta }
$$

and hence the MLE is given by

$$
\hat { \theta } _ { \mathrm { m l e } } = \frac { N _ { 1 } } { N _ { 0 } + N _ { 1 } }
$$

We see that this is just the empirical fraction of heads, which is an intuitive result.

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

# 4.2.4 Example: MLE for the categorical distribution

Suppose we roll a $K$ -sided dice $N$ times. Let $Y _ { n } \in \{ 1 , \ldots , K \}$ be the $\boldsymbol { n }$ ’th outcome, where $Y _ { n } \sim \mathrm { C a t } ( \pmb \theta )$ . We want to estimate the probabilities $\pmb \theta$ from the dataset $\mathcal { D } = \{ y _ { n } : n = 1 : N \}$ . The NLL is given by

$$
\mathrm { N L L } ( \pmb { \theta } ) = - \sum _ { k } N _ { k } \log \theta _ { k }
$$

where $N _ { k }$ is the number of times the event $Y = k$ is observed. (The NLL for the multinomial is the same, up to irrelevant scale factors.)

To compute the MLE, we have to minimize the NLL subject to the constraint that $\textstyle \sum _ { k = 1 } ^ { K } \theta _ { k } = 1$ To do this, we will use the method of Lagrange multipliers (see Section 8.5.1).3

The Lagrangian is as follows:

$$
\mathcal { L } ( \theta , \lambda ) \triangleq - \sum _ { k } N _ { k } \log \theta _ { k } - \lambda \left( 1 - \sum _ { k } \theta _ { k } \right)
$$

Taking derivatives with respect to $\lambda$ yields the original constraint:

$$
\frac { \partial \mathcal { L } } { \partial \lambda } = 1 - \sum _ { k } \theta _ { k } = 0
$$

Taking derivatives with respect to $\theta _ { k }$ yields

$$
{ \frac { \partial { \mathcal { L } } } { \partial \theta _ { k } } } = - { \frac { N _ { k } } { \theta _ { k } } } + \lambda = 0 \implies N _ { k } = \lambda \theta _ { k }
$$

We can solve for $\lambda$ using the sum-to-one constraint:

$$
\sum _ { k } N _ { k } = N _ { \mathcal { D } } = \lambda \sum _ { k } \theta _ { k } = \lambda
$$

Thus the MLE is given by

$$
\widehat { \theta } _ { k } = \frac { N _ { k } } { \lambda } = \frac { N _ { k } } { N }
$$

which is just the empirical fraction of times event $k$ occurs.

# 4.2.5 Example: MLE for the univariate Gaussian

Suppose $Y \sim { \mathcal { N } } ( \mu , \sigma ^ { 2 } )$ and let $\mathcal { D } = \{ y _ { n } : n = 1 : N \}$ be an iid sample of size $N$ . We can estimate the parameters $\pmb \theta = ( \mu , \sigma ^ { 2 } )$ using MLE as follows. First, we derive the NLL, which is given by

$$
\begin{array} { l } { { \displaystyle \mathrm { N L L } ( \mu , \sigma ^ { 2 } ) = - \sum _ { n = 1 } ^ { N _ { \mathcal D } } \log \left[ \left( \frac { 1 } { 2 \pi \sigma ^ { 2 } } \right) ^ { \frac { 1 } { 2 } } \exp \left( - \frac { 1 } { 2 \sigma ^ { 2 } } ( y _ { n } - \mu ) ^ { 2 } \right) \right] } } \\ { { \displaystyle ~ = \frac { 1 } { 2 \sigma ^ { 2 } } \sum _ { n = 1 } ^ { N } ( y _ { n } - \mu ) ^ { 2 } + \frac { N _ { \mathcal D } } { 2 } \log ( 2 \pi \sigma ^ { 2 } ) } } \end{array}
$$

The minimum of this function must satisfy the following conditions, which we explain in Section 8.1.1.1:

$$
\frac \partial { \partial \mu } \mathrm { N L L } ( \mu , \sigma ^ { 2 } ) = 0 , \ \frac \partial { \partial \sigma ^ { 2 } } \mathrm { N L L } ( \mu , \sigma ^ { 2 } ) = 0
$$

So all we have to do is to find this stationary point. Some simple calculus (Exercise 4.1) shows that the solution is given by the following:

$$
\begin{array} { r l r } {  { \hat { \mu } _ { \mathrm { m i e } } = \frac { 1 } { N } \displaystyle \sum _ { n = 1 } ^ { N } y _ { n } = \overline { { y } } } } \\ & { } & { \hat { \sigma } _ { \mathrm { m i e } } ^ { 2 } = \frac { 1 } { N } \displaystyle \sum _ { n = 1 } ^ { N } ( y _ { n } - \hat { \mu } _ { \mathrm { m i e } } ) ^ { 2 } = \frac { 1 } { N } \sum _ { n = 1 } ^ { N } [ y _ { n } ^ { 2 } + \hat { \mu } _ { \mathrm { m i e } } ^ { 2 } - 2 y _ { n } \hat { \mu } _ { \mathrm { m l e } } ] = s ^ { 2 } - \overline { { y } } ^ { 2 } } \\ & { } & { s ^ { 2 } \triangleq \frac { 1 } { N } \displaystyle \sum _ { n = 1 } ^ { N } y _ { n } ^ { 2 } } \end{array}
$$

The quantities $y$ and $s ^ { 2 }$ are called the sufficient statistics of the data, since they are sufficient to compute the MLE, without loss of information relative to using the raw data itself.

Note that you might be used to seeing the estimate for the variance written as

$$
\hat { \sigma } _ { \mathrm { u n b } } ^ { 2 } = \frac { 1 } { N - 1 } \sum _ { n = 1 } ^ { N } ( y _ { n } - \hat { \mu } _ { \mathrm { m l e } } ) ^ { 2 }
$$

where we divide by $N - 1$ . This is not the MLE, but is a different kind of estimate, which happens to be unbiased (unlike the MLE); see Section 4.7.6.1 for details.4

# 4.2.6 Example: MLE for the multivariate Gaussian

In this section, we derive the maximum likelihood estimate for the parameters of a multivariate Gaussian.

First, let us write the log-likelihood, dropping irrelevant constants:

$$
\ell ( \pmb \mu , \pmb \Sigma ) = \log p ( \mathscr { D } | \pmb \mu , \pmb \Sigma ) = \frac { N _ { \mathscr { D } } } { 2 } \log | \pmb \Lambda | - \frac { 1 } { 2 } \sum _ { n = 1 } ^ { N _ { \mathscr { D } } } ( \pmb y _ { n } - \pmb \mu ) ^ { \top } \pmb \Lambda ( \pmb y _ { n } - \pmb \mu )
$$

where $\pmb { \Lambda } = \pmb { \Sigma } ^ { - 1 }$ is the precision matrix (inverse covariance matrix).

# 4.2.6.1 MLE for the mean

Using the substitution $z _ { n } = y _ { n } - \mu$ , the derivative of a quadratic form (Equation (7.264)) and the chain rule of calculus, we have

$$
\begin{array} { r } { \displaystyle \frac { \partial } { \partial \pmb { \mu } } ( \pmb { y } _ { n } - \pmb { \mu } ) ^ { \mathsf { T } } \pmb { \Sigma } ^ { - 1 } ( \pmb { y } _ { n } - \pmb { \mu } ) = \displaystyle \frac { \partial } { \partial \pmb { z } _ { n } } \pmb { z } _ { n } ^ { \mathsf { T } } \pmb { \Sigma } ^ { - 1 } \pmb { z } _ { n } \displaystyle \frac { \partial \pmb { z } _ { n } } { \partial \pmb { \mu } ^ { \mathsf { T } } } } \\ { = - 1 ( \pmb { \Sigma } ^ { - 1 } + \pmb { \Sigma } ^ { - T } ) \pmb { z } _ { n } } \end{array}
$$

since ∂znT = I. Hence

$$
\begin{array} { c } { { \displaystyle { \frac { \partial } { \partial \mu } } \ell ( \mu , \Sigma ) = - \frac { 1 } { 2 } \sum _ { n = 1 } ^ { N _ { \mathcal { D } } } - 2 \Sigma ^ { - 1 } ( y _ { n } - \mu ) = \Sigma ^ { - 1 } \sum _ { n = 1 } ^ { N _ { \mathcal { D } } } ( y _ { n } - \mu ) = 0 } } \\ { { \hat { \mu } = \displaystyle { \frac { 1 } { N _ { \mathcal { D } } } \sum _ { n = 1 } ^ { N _ { \mathcal { D } } } y _ { n } } = \overline { { { y } } } } } \end{array}
$$

So the MLE of $\pmb { \mu }$ is just the empirical mean.

# 4.2.6.2 MLE for the covariance matrix

We can use the trace trick (Equation (7.36)) to rewrite the log-likelihood in terms of the precision matrix $\pmb { \Lambda } = \pmb { \Sigma } ^ { - 1 }$ as follows:

$$
\begin{array} { c } { { \displaystyle \ell ( \hat { \pmb { \mu } } , \pmb { \Lambda } ) = \frac { N _ { \mathcal { D } } } { 2 } \log | \pmb { \Lambda } | - \frac { 1 } { 2 } \displaystyle \sum _ { n } \mathrm { t r } \big [ \big ( \pmb { y } _ { n } - \hat { \pmb { \mu } } \big ) \big ( \pmb { y } _ { n } - \hat { \pmb { \mu } } \big ) ^ { \top } \pmb { \Lambda } \big ] } } \\ { { \displaystyle = \frac { N _ { \mathcal { D } } } { 2 } \log | \pmb { \Lambda } | - \frac { 1 } { 2 } \mathrm { t r } \big [ \pmb { \mathrm { S } } _ { \overline { { y } } } \pmb { \Lambda } \big ] } } \\ { { \displaystyle \pmb { \mathrm { S } } _ { \overline { { y } } } \triangleq \sum _ { n = 1 } ^ { N } \big ( \pmb { y } _ { n } - \overline { { y } } \big ) \big ( \pmb { y } _ { n } - \overline { { y } } \big ) ^ { \top } = \Bigg ( \displaystyle \sum _ { n } \pmb { y } _ { n } \pmb { y } _ { n } ^ { \top } \Bigg ) - N \overline { { y } } \overline { { y } } ^ { \top } } }  \end{array}
$$

where $\mathbf { S } _ { \overline { { y } } }$ is the scatter matrix centered on $\overline { { { y } } }$ .

We can rewrite the scatter matrix in a more compact form as follows:

$$
\mathbf { S } _ { \overline { { y } } } = \tilde { \mathbf { Y } } ^ { \mathsf { T } } \tilde { \mathbf { Y } } = \mathbf { Y } ^ { \mathsf { T } } \mathbf { C } _ { N } ^ { \mathsf { T } } \mathbf { C } _ { N } \mathbf { Y } = \mathbf { Y } ^ { \mathsf { T } } \mathbf { C } _ { N } \mathbf { Y }
$$

where

$$
\mathbf { C } _ { N } \triangleq \mathbf { I } _ { N } - \frac { 1 } { N } \mathbf { 1 } _ { N } \mathbf { 1 } _ { N } ^ { \mathsf { T } }
$$

is the centering matrix, which converts $\mathbf { Y }$ to $\dot { \mathbf { Y } }$ by subtracting the mean $\begin{array} { r } { \overline { { \pmb { y } } } = \frac { 1 } { N } \mathbf { Y } ^ { 1 } \mathbf { 1 } _ { N } } \end{array}$ off every row.

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

![](images/5a3f09d0f9cf25e966859e63315904662a0277152f07338649b91b251280961e.jpg)  
Figure 4.1: (a) Covariance matrix for the features in the iris dataset from Section 1.2.1.1. (b) Correlation matrix. We only show the lower triangle, since the matrix is symmetric and has a unit diagonal. Compare this to Figure 1.3. Generated by iris_cov_mat.ipynb.

Using results from Section 7.8, we can compute derivatives of the loss with respect to $\pmb { \Lambda }$ to get

$$
\begin{array} { l } { \displaystyle \frac { \partial \ell ( \hat { \pmb { \mu } } , { \bf { A } } ) } { \partial { \bf { A } } } = \frac { N _ { \mathcal { D } } } { 2 } { \bf { A } } ^ { - T } - \frac { 1 } { 2 } { \bf { S } } _ { \overline { { y } } } ^ { \top } = { \bf { 0 } } } \\ { \displaystyle { { \bf { A } } ^ { - \mathbb { T } } } = { \bf { A } } ^ { - 1 } = { \bf { \Sigma } } = \frac { 1 } { N _ { \mathcal { D } } } { \bf { S } } _ { \overline { { y } } } } \\ { \displaystyle \quad \hat { \bf { \Sigma } } = \frac { 1 } { N _ { \mathcal { D } } } \sum _ { n = 1 } ^ { N _ { \mathcal { D } } } ( { \bf { y } } _ { n } - \overline { { y } } ) ( { \bf { y } } _ { n } - \overline { { y } } ) ^ { \top } = \frac { 1 } { N } { \bf { Y } } ^ { \top } { \bf { C } } _ { N } { \bf { Y } } } \end{array}
$$

Thus the MLE for the covariance matrix is the empirical covariance matrix. See Figure 4.1a for an example.

Sometimes it is more convenient to work with the correlation matrix defined in Equation (3.8). This can be computed using

$$
\operatorname { c o r r } ( \mathbf { Y } ) = ( \operatorname { d i a g } ( \Sigma ) ) ^ { - \frac { 1 } { 2 } } \Sigma ( \operatorname { d i a g } ( \Sigma ) ) ^ { - \frac { 1 } { 2 } }
$$

where $\mathrm { d i a g } ( \Sigma ) ^ { - \frac { 1 } { 2 } }$ is a diagonal matrix containing the entries $1 / \sigma _ { i }$ . See Figure 4.1b for an example. Note, however, that the MLE may overfit or be numerically unstable, especially when the number of samples $N$ is small compared to the number of dimensions $D$ . The main problem is that $\pmb { \Sigma }$ has $O ( D ^ { 2 } )$ parameters, so we may need a lot of data to reliably estimate it. In particular, as we see from Equation (4.51), the MLE for a full covariance matrix is singular if $N _ { \mathcal { D } } < D$ . And even when $N _ { \mathcal { D } } > D$ , the MLE can be ill-conditioned, meaning it is close to singular. We discuss solutions to this problem in Section 4.5.2.

# 4.2.7 Example: MLE for linear regression

We briefly mentioned linear regression in Section 2.6.3. Recall that it corresponds to the following model:

$$
p ( y | \mathbf x ; \pmb \theta ) = \mathcal { N } ( y | \pmb w ^ { \top } \mathbf x , \sigma ^ { 2 } )
$$

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

where $\pmb \theta = ( \pmb w , \pmb \sigma ^ { 2 } )$ . Let us assume for now that $\sigma ^ { 2 }$ is fixed, and focus on estimating the weights $\mathbf { \boldsymbol { w } }$ . The negative log likelihood or NLL is given by

$$
\mathrm { N L L } ( { \boldsymbol { w } } ) = - \sum _ { n = 1 } ^ { N _ { D } } \log \left[ \left( { \frac { 1 } { 2 \pi \sigma ^ { 2 } } } \right) ^ { \frac { 1 } { 2 } } \exp \left( - { \frac { 1 } { 2 \sigma ^ { 2 } } } ( y _ { n } - { \boldsymbol { w ^ { \mathsf { T } } } } { \boldsymbol { x } } _ { n } ) ^ { 2 } \right) \right]
$$

Dropping the irrelevant additive constants gives the following simplified objective, known as the residual sum of squares or RSS:

$$
\operatorname { R S S } ( \pmb { w } ) \triangleq \sum _ { n = 1 } ^ { N } ( y _ { n } - \pmb { w } ^ { \top } \pmb { x } _ { n } ) ^ { 2 } = \sum _ { n = 1 } ^ { N } r _ { n } ^ { 2 }
$$

where $r _ { n }$ the $n$ ’th residual error. Scaling by the number of examples $N$ gives the mean squared error or MSE:

$$
\operatorname { M S E } ( { \pmb w } ) = \frac { 1 } { N } \mathrm { R S S } ( { \pmb w } ) = \frac { 1 } { N } \sum _ { n = 1 } ^ { N } ( y _ { n } - { \pmb w } ^ { \top } { \pmb x } _ { n } ) ^ { 2 }
$$

Finally, taking the square root gives the root mean squared error or RMSE:

$$
\mathrm { R M S E } ( \boldsymbol { w } ) = \sqrt { \mathrm { M S E } ( \boldsymbol { w } ) } = \sqrt { \frac { 1 } { N } \sum _ { n = 1 } ^ { N } ( y _ { n } - \boldsymbol { w } ^ { \top } \mathbfit { x } _ { n } ) ^ { 2 } }
$$

We can compute the MLE by minimizing the NLL, RSS, MSE or RMSE. All will give the same results, since these objective functions are all the same, up to irrelevant constants Let us focus on the RSS objective. It can be written in matrix notation as follows:

$$
\operatorname { R S S } ( \pmb { w } ) = \sum _ { n = 1 } ^ { N } ( y _ { n } - \pmb { w } ^ { \top } \pmb { x } _ { n } ) ^ { 2 } = | | \mathbf { X } \pmb { w } - \pmb { y } | | _ { 2 } ^ { 2 } = ( \mathbf { X } \pmb { w } - \pmb { y } ) ^ { \top } ( \mathbf { X } \pmb { w } - \pmb { y } )
$$

In Section 11.2.2.1, we prove that the optimum, which occurs where $\nabla _ { \mathbf { \boldsymbol { w } } } \mathrm { R S S } ( \mathbf { \boldsymbol { w } } ) = \mathbf { 0 }$ , satisfies th following equation:

$$
{ \hat { \pmb { w } } } _ { \mathrm { m l e } } \triangleq \operatorname * { a r g m i n } _ { \pmb { w } } \mathrm { R S S } ( \pmb { w } ) = ( \mathbf { X } ^ { \mathsf { T } } \mathbf { X } ) ^ { - 1 } \mathbf { X } ^ { \mathsf { T } } \pmb { y }
$$

This is called the ordinary least squares or OLS estimate, and is equivalent to the MLE.

# 4.3 Empirical risk minimization (ERM)

We can generalize MLE by replacing the (conditional) log loss term in Equation (4.6), $\ell ( { \pmb y } _ { n } , { \pmb \theta } ; { \pmb x } _ { n } ) =$ $- \log p ( \pmb { y } _ { n } | \pmb { x } _ { n } , \pmb { \theta } )$ , with any other loss function, to get

$$
\mathcal { L } ( \pmb { \theta } ) = \frac { 1 } { N } \sum _ { n = 1 } ^ { N } \ell ( \pmb { y } _ { n } , \pmb { \theta } ; \pmb { x } _ { n } )
$$

This is known as empirical risk minimization or ERM, since it is the expected loss where the expectation is taken wrt the empirical distribution. See Section 5.4 for more details.

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

# 4.3.1 Example: minimizing the misclassification rate

If we are solving a classification problem, we might want to use 0-1 loss:

$$
\ell _ { 0 1 } ( { \pmb y } _ { n } , { \pmb \theta } ; { \pmb x } _ { n } ) = \left\{ 0 \begin{array} { l l } { 0 } & { \mathrm { i f } { \pmb y } _ { n } = f ( { \pmb x } _ { n } ; { \pmb \theta } ) } \\ { 1 } & { \mathrm { i f } { \pmb y } _ { n } \neq f ( { \pmb x } _ { n } ; { \pmb \theta } ) } \end{array} \right.
$$

where $f ( { \pmb x } ; { \pmb \theta } )$ is some kind of predictor. The empirical risk becomes

$$
\mathcal { L } ( \pmb { \theta } ) = \frac { 1 } { N } \sum _ { n = 1 } ^ { N } \ell _ { 0 1 } ( \pmb { y } _ { n } , \pmb { \theta } ; \pmb { x } _ { n } )
$$

This is just the empirical misclassification rate on the training set.

Note that for binary problems, we can rewrite the misclassifcation rate in the following notation. Let $\tilde { y } \in \{ - 1 , + 1 \}$ be the true label, and $\hat { y } \in \{ - 1 , + 1 \} = f ( \pmb { x } ; \pmb { \theta } )$ be our prediction. We define the 0-1 loss as follows:

$$
\ell _ { 0 1 } ( \tilde { y } , \hat { y } ) = \mathbb { I } \left( \tilde { y } \neq \hat { y } \right) = \mathbb { I } \left( \tilde { y } \ \hat { y } < 0 \right)
$$

The corresponding empirical risk becomes

$$
\mathcal { L } ( \pmb { \theta } ) = \frac { 1 } { N } \sum _ { n = 1 } ^ { N } \ell _ { 0 1 } ( y _ { n } , \hat { y } _ { n } ) = \frac { 1 } { N } \sum _ { n = 1 } ^ { N } \mathbb { I } \left( \tilde { y } _ { n } \hat { y } _ { n } < 0 \right)
$$

where the dependence on ${ \boldsymbol { \mathbf { \mathit { x } } } } _ { n }$ and $\pmb \theta$ is implicit.

# 4.3.2 Surrogate loss

Unfortunately, the 0-1 loss used in Section 4.3.1 is a non-smooth step function, as shown in Figure 4.2, making it difficult to optimize. (In fact, it is NP-hard [BDEL03].) In this section we consider the use of a surrogate loss function [BJM06]. The surrogate is usually chosen to be a maximally tight convex upper bound, which is then easy to minimize.

For example, consider a probabilistic binary classifier, which produces the following distribution over labels:

$$
p ( \tilde { y } | x , \pmb { \theta } ) = \sigma ( \tilde { y } \eta ) = \frac { 1 } { 1 + e ^ { - \tilde { y } \eta } }
$$

where $\eta = f ( \pmb { x } ; \pmb { \theta } )$ is the log odds. Hence the log loss is given by

$$
\ell _ { l l } ( \tilde { y } , \eta ) = - \log p ( \tilde { y } | \eta ) = \log ( 1 + e ^ { - \tilde { y } \eta } )
$$

Figure 4.2 shows that this is a smooth upper bound to the 0-1 loss, where we plot the loss vs the quantity $\tilde { y } \eta$ , known as the margin, since it defines a “margin of safety” away from the threshold value of 0. Thus we see that minimizing the negative log likelihood is equivalent to minimizing a (fairly tight) upper bound on the empirical 0-1 loss.

Another convex upper bound to 0-1 loss is the hinge loss, which is defined as follows:

$$
\ell _ { \mathrm { h i n g e } } ( \tilde { y } , \eta ) = \operatorname* { m a x } ( 0 , 1 - \tilde { y } \eta ) \triangleq ( 1 - \tilde { y } \eta ) _ { + }
$$

This is plotted in Figure 4.2; we see that it has the shape of a partially open door hinge. This is convex upper bound to the 0-1 loss, although it is only piecewise differentiable, not everywhere differentiable.

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

![](images/ce4a34348d47632c37aa0a04bff14eafe6785dbc896ac7596466bfcf2c690ae4.jpg)  
Figure 4.2: Illustration of various loss functions for binary classification. The horizontal axis is the margin $z = \tilde { y } \eta$ , the vertical axis is the loss. 0-1 loss is $\mathbb { I } \left( z < 0 \right)$ . Hinge-loss is $\operatorname* { m a x } ( 0 , 1 - z )$ . Log-loss is $\log _ { 2 } ( 1 + e ^ { - z } )$ . Exp-loss is $e ^ { - z }$ . Generated by hinge_loss_plot.ipynb.

# 4.4 Other estimation methods \*

# 4.4.1 The method of moments

Computing the MLE requires solving the equation $\nabla _ { \pmb { \theta } } \mathrm { N L L } ( \pmb { \theta } ) = \mathbf { 0 }$ . Sometimes this is computationally difficult. In such cases, we may be able to use a simpler approach known as the method of moments (MOM). In this approach, we equate the theoretical moments of the distribution to the empirical moments, and solve the resulting set of $K$ simultaneous equations, where $K$ is the number of parameters. The theoretical moments are given by $\mu _ { k } = \operatorname { \mathbb { E } } \left\lfloor Y ^ { k } \right\rfloor$ , for $k = 1 : K$ , and the empirical moments are given by

$$
\hat { \mu } _ { k } = \frac { 1 } { N } \sum _ { n = 1 } ^ { n } y _ { n } ^ { k }
$$

so we just need to solve $\mu _ { k } = \hat { \mu } _ { k }$ for each $k$ . We give some examples below.

The method of moments is simple, but it is theoretically inferior to the MLE approach, since it may not use all the data as efficiently. (For details on these theoretical results, see e.g., [CB02].) Furthermore, it can sometimes produce inconsistent results (see Section 4.4.1.2). However, when it produces valid estimates, it can be used to initialize iterative algorithms that are used to optimize the NLL (see e.g., [AHK12]), thus combining the computational efficiency of MOM with the statistical accuracy of MLE.

# 4.4.1.1 Example: MOM for the univariate Gaussian

For example, consider the case of a univariate Gaussian distribution. From Section 4.2.5, we have

$$
\begin{array} { l } { \mu _ { 1 } = \mu = \overline { { y } } } \\ { \mu _ { 2 } = \sigma ^ { 2 } + \mu ^ { 2 } = s ^ { 2 } } \end{array}
$$

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

where $\overline { y }$ is the empirical mean and $s ^ { 2 }$ is the empirical average sum of squares. so $\hat { \mu } = \overline { { y } }$ and $\hat { \sigma } ^ { 2 } = s ^ { 2 } - \overline { { y } } ^ { 2 }$ . In this case, the MOM estimate is the same as the MLE, but this is not always the case.

# 4.4.1.2 Example: MOM for the uniform distribution

In this section, we give an example of the MOM applied to the uniform distribution. Our presentation follows the wikipedia page.5 Let $Y \sim \mathrm { U n i f } ( \theta _ { 1 } , \theta _ { 2 } )$ be a uniform random variable, so

$$
p ( y | \theta ) = \frac { 1 } { \theta _ { 2 } - \theta _ { 1 } } \mathbb { I } \left( \theta _ { 1 } \leq y \leq \theta _ { 2 } \right)
$$

The first two moments are

$$
\begin{array} { l } { \displaystyle \mu _ { 1 } = \mathbb { E } \left[ Y \right] = \frac 1 2 ( \theta _ { 1 } + \theta _ { 2 } ) } \\ { \displaystyle \mu _ { 2 } = \mathbb { E } \left[ Y ^ { 2 } \right] = \frac 1 3 ( \theta _ { 1 } ^ { 2 } + \theta _ { 1 } \theta _ { 2 } + \theta _ { 2 } ^ { 2 } ) } \end{array}
$$

Inverting these equations gives

$$
( \theta _ { 1 } , \theta _ { 2 } ) = \bigg ( \mu _ { 1 } - \sqrt { 3 ( \mu _ { 2 } - \mu _ { 1 } ^ { 2 } ) } , 2 \mu _ { 1 } - \theta _ { 1 } \bigg )
$$

Unfortunately this estimator can sometimes give invalid results. For example, suppose $\mathcal { D } =$ $\{ 0 , 0 , 0 , 0 , 1 \}$ . The empirical moments are $\hat { \mu } _ { 1 } = \textstyle \frac { 1 } { 5 }$ and $\hat { \mu } _ { 2 } = \textstyle \frac { 1 } { 5 }$ , so the estimated parameters are $\begin{array} { r } { \hat { \theta } _ { 1 } = \frac { 1 } { 5 } - \frac { 2 \sqrt { 3 } } { 5 } = - 0 . 4 9 3 } \end{array}$ and $\begin{array} { r } { \hat { \theta } _ { 2 } = \frac { 1 } { 5 } + \frac { 2 \sqrt { 3 } } { 5 } = 0 . 8 9 3 } \end{array}$ . However, these cannot possibly be the correct parameters, since if $\theta _ { 2 } = 0 . 8 9 3$ , we cannot generate a sample as large as 1.

By contrast, consider the MLE. Let $y _ { ( 1 ) } \leq y _ { ( 2 ) } \leq \cdot \cdot \cdot \leq y _ { ( N ) }$ be the order statistics of the data (i.e., the values sorted in increasing order). Let $\theta = \theta _ { 2 } - \theta _ { 1 }$ . Then the likelihood is given by

$$
p ( \mathcal { D } | \theta ) = ( \theta ) ^ { - N } \mathbb { I } \left( y _ { ( 1 ) } \geq \theta _ { 1 } \right) \mathbb { I } \left( y _ { ( N ) } \leq \theta _ { 2 } \right)
$$

Within the permitted bounds for $\theta$ , the derivative of the log likelihood is given by

$$
\frac { d } { d \theta } \log p ( \boldsymbol { D } | \theta ) = - \frac { N } { \theta } < 0
$$

Hence the likelihood is a decreasing function of $\theta$ , so we should pick

$$
\hat { \theta } _ { 1 } = y _ { ( 1 ) } , \hat { \theta } _ { 2 } = y _ { ( N ) }
$$

In the above example, we get $\widehat { \theta } _ { 1 } = 0$ and $\hat { \theta } _ { 2 } = 1$ , as one would expect.

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

# 4.4.2 Online (recursive) estimation

If the entire dataset $\mathcal { D }$ is available before training starts, we say that we are doing batch learning. However, in some cases, the data set arrives sequentially, so $\mathcal { D } = \{ \pmb { y } _ { 1 } , \pmb { y } _ { 2 } , \dots \}$ in an unbounded stream. In this case, we want to perform online learning.

Let $\hat { \pmb { \theta } } _ { t - 1 }$ be our estimate (e.g., MLE) given $\mathcal { D } _ { 1 : t - 1 }$ . To ensure our learning algorithm takes constant time per update, we need to find a learning rule of the form

$$
\pmb \theta _ { t } = f ( \hat { \pmb \theta } _ { t - 1 } , \pmb y _ { t } )
$$

This is called a recursive update. Below we give some examples of such online learning methods.

# 4.4.2.1 Example: recursive MLE for the mean of a Gaussian

Let us reconsider the example from Section 4.2.5 where we computed the MLE for a univariate Gaussian. We know that the batch estimate for the mean is given by

$$
\hat { \pmb { \mu } } _ { t } = \frac { 1 } { t } \sum _ { n = 1 } ^ { t } \pmb { y } _ { n }
$$

This is just a running sum of the data, so we can easily convert this into a recursive estimate as follows:

$$
\begin{array} { c } { { \displaystyle \hat { \pmb { \mu } } _ { t } = \frac { 1 } { t } \sum _ { n = 1 } ^ { t } { \pmb { y } } _ { n } = \frac { 1 } { t } \left( ( t - 1 ) \hat { \pmb { \mu } } _ { t - 1 } + { \pmb y } _ { t } \right) } } \\ { { = \hat { \pmb { \mu } } _ { t - 1 } + \frac { 1 } { t } ( { \pmb y } _ { t } - \hat { \pmb { \mu } } _ { t - 1 } ) } } \end{array}
$$

This is known as a moving average.

We see from Equation (4.81) that the new estimate is the old estimate plus a correction term. The size of the correction diminishes over time (i.e., as we get more samples). However, if the distribution is changing, we want to give more weight to more recent data examples. We discuss how to do this in Section 4.4.2.2.

# 4.4.2.2 Exponentially-weighted moving average

Equation (4.81) shows how to compute the moving average of a signal. In this section, we show how to adjust this to give more weight to more recent examples. In particular, we will compute the following exponentially weighted moving average or EWMA, also called an exponential moving average or EMA:

$$
\hat { \pmb { \mu } } _ { t } = \beta \pmb { \mu } _ { t - 1 } + ( 1 - \beta ) \pmb { y } _ { t }
$$

where $0 < \beta < 1$ . The contribution of a data point $k$ steps in the past is weighted by $\beta ^ { k } ( 1 - \beta )$ . Thus the contribution from old data is exponentially decreasing. In particular, we have

$$
\begin{array} { r l } & { \hat { \pmb { \mu } } _ { t } = \beta { \pmb { \mu } } _ { t - 1 } + ( 1 - \beta ) { \pmb { y } } _ { t } } \\ & { \quad = \beta ^ { 2 } { \pmb { \mu } } _ { t - 2 } + \beta ( 1 - \beta ) { \pmb { y } } _ { t - 1 } + ( 1 - \beta ) { \pmb { y } } _ { t } } \\ & { \quad = \beta ^ { t } { \pmb { y } } _ { 0 } + ( 1 - \beta ) \beta ^ { t - 1 } { \pmb { y } } _ { 1 } + \dots + ( 1 - \beta ) \beta { \pmb { y } } _ { t - 1 } + ( 1 - \beta ) { \pmb { y } } _ { t } } \end{array}
$$

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

![](images/3d31bb97d0bc9cc1d83506ec4207605afabf9ed3da3ef517ec63d28f00e0bc3f.jpg)  
Figure 4.3: Illustration of exponentially-weighted moving average with and without bias correction. (a) Short memory: $\beta = 0 . 9$ . (a) Long memory: $\beta = 0 . 9 9$ . Generated by ema_demo.ipynb.

The sum of a geometric series is given by

$$
\beta ^ { t } + \beta ^ { t - 1 } + \cdot \cdot \cdot + \beta ^ { 1 } + \beta ^ { 0 } = \frac { 1 - \beta ^ { t + 1 } } { 1 - \beta }
$$

Hence

$$
( 1 - \beta ) \sum _ { k = 0 } ^ { t } \beta ^ { k } = ( 1 - \beta ) \frac { 1 - \beta ^ { t + 1 } } { 1 - \beta } = 1 - \beta ^ { t + 1 }
$$

Since $0 < \beta < 1$ , we have $\beta ^ { t + 1 }  0$ as $t \to \infty$ , so smaller $\beta$ forgets the past more quickly, and adapts to the more recent data more rapidly. This is illustrated in Figure 4.3.

Since the initial estimate starts from $\hat { \pmb { \mu } } _ { 0 } = { \bf 0 }$ , there is an initial bias. This can be corrected by scaling as follows [KB15]:

$$
\tilde { \mu } _ { t } = \frac { \hat { \mu } _ { t } } { 1 - \beta ^ { t } }
$$

(Note that the update in Equation (4.82) is still applied to the uncorrected EMA, $\hat { \pmb { \mu } } _ { t - 1 }$ , before being corrected for the current time step.) The benefit of this is illustrated in Figure 4.3.

# 4.5 Regularization

A fundamental problem with MLE, and ERM, is that it will try to pick parameters that minimize loss on the training set, but this may not result in a model that has low loss on future data. This is called overfitting.

As a simple example, suppose we want to predict the probability of heads when tossing a coin. We toss it $N = 3$ times and observe 3 heads. The MLE is $\hat { \theta } _ { \mathrm { m l e } } = N _ { 1 } / ( N _ { 0 } + N _ { 1 } ) = 3 / ( 3 + 0 ) = 1$ (see Section 4.2.3). However, if we use $\mathrm { B e r } ( y | \hat { \theta } _ { \mathrm { m l e } } )$ to make predictions, we will predict that all future coin tosses will also be heads, which seems rather unlikely.

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

The core of the problem is that the model has enough parameters to perfectly fit the observed training data, so it can perfectly match the empirical distribution. However, in most cases the empirical distribution is not the same as the true distribution, so putting all the probability mass on the observed set of $N$ examples will not leave over any probability for novel data in the future. That is, the model may not generalize.

The main solution to overfitting is to use regularization, which means to add a penalty term to the NLL (or empirical risk). Thus we optimize an objective of the form

$$
\mathcal { L } ( \pmb { \theta } ; \lambda ) = \left[ \frac { 1 } { N } \sum _ { n = 1 } ^ { N } \ell ( \pmb { y } _ { n } , \pmb { \theta } ; \pmb { x } _ { n } ) \right] + \lambda C ( \pmb { \theta } )
$$

where $\lambda \geq 0$ is the regularization parameter, and $C ( \pmb \theta )$ is some form of complexity penalty. A common complexity penalty is to use $C ( \pmb \theta ) = - \log p ( \pmb \theta )$ , where $p ( \pmb \theta )$ is the prior for $\pmb \theta$ . If $\ell$ is the log loss, the regularized objective becomes

$$
\mathcal { L } ( \theta ; \lambda ) = - \frac { 1 } { N } \sum _ { n = 1 } ^ { N } \log p ( \pmb { y } _ { n } | \pmb { x } _ { n } , \pmb { \theta } ) - \lambda \log p ( \pmb { \theta } )
$$

By setting $\lambda = 1$ and rescaling $p ( \pmb \theta )$ appropriately, we can equivalently minimize the following:

$$
\mathcal { L } ( \pmb \theta ; \lambda ) = - \left[ \sum _ { n = 1 } ^ { N } \log p ( \pmb { y } _ { n } | \pmb x _ { n } , \pmb \theta ) + \log p ( \pmb \theta ) \right] = - \left[ \log p ( \mathcal { D } | \pmb \theta ) + \log p ( \pmb \theta ) \right]
$$

Minimizing this is equivalent to maximizing the log posterior:

$$
\hat { \pmb { \theta } } = \underset { \pmb { \theta } } { \operatorname { a r g m a x } } \log p ( \pmb { \theta } | \mathcal { D } ) = \underset { \pmb { \theta } } { \operatorname { a r g m a x } } \left[ \log p ( \mathcal { D } | \pmb { \theta } ) + \log p ( \pmb { \theta } ) - \operatorname { c o n s t } \right]
$$

This is known as MAP estimation, which stands for maximum a posterior estimation.

# 4.5.1 Example: MAP estimation for the Bernoulli distribution

Consider again the coin tossing example. If we observe just one head, the MLE is $\theta _ { \mathrm { m l e } } = 1$ , which predicts that all future coin tosses will also show up heads. To avoid such overfitting, we can add a penalty to $\theta$ to discourage “extreme” values, such as $\theta = 0$ or $\theta = 1$ . We can do this by using a beta distribution as our prior, $p ( \theta ) = \operatorname { B e t a } ( \theta | a , b )$ , where $a , b > 1$ encourages values of $\theta$ near to $a / ( a + b )$ (see Section 2.7.4 for details). The log likelihood plus log prior becomes

$$
\begin{array} { r l } & { \ell ( \theta ) = \log p ( \mathcal { D } | \theta ) + \log p ( \theta ) } \\ & { \qquad = [ N _ { 1 } \log \theta + N _ { 0 } \log ( 1 - \theta ) ] + [ ( a - 1 ) \log ( \theta ) + ( b - 1 ) \log ( 1 - \theta ) ] } \end{array}
$$

Using the method from Section 4.2.3 we find that the MAP estimate is

$$
\theta _ { \mathrm { m a p } } = \frac { N _ { 1 } + a - 1 } { N _ { 1 } + N _ { 0 } + a + b - 2 }
$$

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

If we set $a = b = 2$ (which weakly favors a value of $\theta$ near 0.5), the estimate becomes

$$
\theta _ { \mathrm { { m a p } } } = \frac { N _ { 1 } + 1 } { N _ { 1 } + N _ { 0 } + 2 }
$$

This is called add-one smoothing, and is a simple but widely used technique to avoid the zero count problem. (See also Section 4.6.2.9.)

The zero-count problem, and overfitting more generally, is analogous to a problem in philosophy called the black swan paradox. This is based on the ancient Western conception that all swans were white. In that context, a black swan was a metaphor for something that could not exist. (Black swans were discovered in Australia by European explorers in the 17th Century.) The term “black swan paradox” was first coined by the famous philosopher of science Karl Popper; the term has also been used as the title of a recent popular book [Tal07]. This paradox was used to illustrate the problem of induction, which is the problem of how to draw general conclusions about the future from specific observations from the past. The solution to the paradox is to admit that induction is in general impossible, and that the best we can do is to make plausible guesses about what the future might hold, by combining the empirical data with prior knowledge.

# 4.5.2 Example: MAP estimation for the multivariate Gaussian \*

In Section 4.2.6, we showed that the MLE for the mean of an MVN is the empirical mean, $\hat { \pmb { \mu } } _ { \mathrm { m l e } } = \overline { { \pmb { y } } }$ .   
We also showed that the MLE for the covariance is the empirical covariance, $\begin{array} { r } { \hat { \bf Z } = \frac { 1 } { N } { \bf S } _ { \overline { { \pmb { y } } } } } \end{array}$ .

In high dimensions the estimate for $\pmb { \Sigma }$ can easily become singular. One solution to this is to perform MAP estimation, as we explain below.

# 4.5.2.1 Shrinkage estimate

A convenient prior to use for $\pmb { \Sigma }$ is the inverse Wishart prior. This is a distribution over positive definite matrices, where the parameters are defined in terms of a prior scatter matrix, $\breve { \mathbf { S } }$ , and a prior sample size or strength $\breve { N }$ . One can show that the resulting MAP estimate is given by

$$
\hat { \bf { \cal { \Sigma } } } _ { \mathrm { m a p } } = \frac { \breve { \bf { S } } + { \bf { S } } _ { \overline { { { y } } } } } { \breve { N } + N } = \frac { \breve { N } } { \breve { N } + N } \frac { \breve { \bf { S } } } { \breve { N } } + \frac { N } { \breve { N } + N } \frac { { \bf { S } } _ { \overline { { { y } } } } } { N } = \lambda { \bf { \Sigma } } _ { 0 } + ( 1 - \lambda ) \hat { \bf { \Sigma } } _ { \mathrm { { m l e } } }
$$

where $\begin{array} { r } { \lambda = \frac { \widecheck N } { \widecheck N + N } } \end{array}$ controls the amount of regularization.

A common choice (see e.g., [FR07, p6]) for the prior scatter matrix is to use $\breve { \mathbf { S } }$ = $\breve { N }$ $\mathrm { d i a g } ( \hat { \Sigma } _ { \mathrm { m l e } } )$ . With this choice, we find that the MAP estimate for $\pmb { \Sigma }$ is given by

$$
\begin{array} { r } { \hat { \Sigma } _ { \mathrm { m a p } } ( i , j ) = \left\{ \begin{array} { l l } { \hat { \Sigma } _ { \mathrm { m l e } } ( i , j ) } & { \mathrm { i f ~ } i = j } \\ { ( 1 - \lambda ) \hat { \Sigma } _ { \mathrm { m l e } } ( i , j ) } & { \mathrm { o t h e r w i s e } } \end{array} \right. } \end{array}
$$

Thus we see that the diagonal entries are equal to their ML estimates, and the off-diagonal elements are “shrunk” somewhat towards 0. This technique is therefore called shrinkage estimation.

The other parameter we need to set is $\lambda$ , which controls the amount of regularization (shrinkage towards the MLE). It is common to set $\lambda$ by cross validation (Section 4.5.5). Alternatively, we can use the closed-form formula provided in [LW04a; LW04b; SS05], which is the optimal

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022 frequentist estimate if we use squared loss. This is implemented in the sklearn function https://scikitlearn.org/stable/modules/generated/sklearn.covariance.LedoitWolf.html.

![](images/056f160115e015796e3403e2425da57b70c14e0ac5bfadf42b299440558f0879.jpg)  
Figure 4.4: Estimating a covariance matrix in $D = 5 0$ dimensions using $N \in \{ 1 0 0 , 5 0 , 2 5 \}$ samples. We plot the eigenvalues in descending order for the true covariance matrix (solid black), the MLE (dotted blue) and the MAP estimate (dashed red), using Equation (4.98) with $\lambda = 0 . 9$ . We also list the condition number of each matrix in the legend. We see that the MLE is often poorly conditioned, but the MAP estimate is numerically well behaved. Adapted from Figure 1 of [SS05]. Generated by shrinkcov_plots.ipynb.

The benefits of this approach are illustrated in Figure 4.4. We consider fitting a 50-dimensional Gaussian to $N = 1 0 0$ , $N = 5 0$ and $N = 2 5$ data points. We see that the MAP estimate is always well-conditioned, unlike the MLE (see Section 7.1.4.4 for a discussion of condition numbers). In particular, we see that the eigenvalue spectrum of the MAP estimate is much closer to that of the true matrix than the MLE’s spectrum. The eigenvectors, however, are unaffected.

# 4.5.3 Example: weight decay

In Figure 1.7, we saw how using polynomial regression with too high of a degree can result in overfitting. One solution is to reduce the degree of the polynomial. However, a more general solution is to penalize the magnitude of the weights (regression coefficients). We can do this by using a zero-mean Gaussian prior, $p ( { \boldsymbol { w } } )$ . The resulting MAP estimate is given by

$$
\hat { \pmb w } _ { \mathrm { m a p } } = \underset { \pmb w } { \mathrm { a r g m i n } } \mathrm { N L L } ( \pmb w ) + \lambda | | \pmb w | | _ { 2 } ^ { 2 }
$$

where $\begin{array} { r } { \lvert | \boldsymbol { w } \rvert | _ { 2 } ^ { 2 } = \sum _ { d = 1 } ^ { D } w _ { d } ^ { 2 } } \end{array}$ . (We write $\pmb { w }$ rather than $\pmb \theta$ , since it only really make sense to penalize the magnitude of weight vectors, rather than other parameters, such as bias terms or noise variances.)

Equation (4.99) is called $\ell _ { 2 }$ regularization or weight decay. The larger the value of $\lambda$ , the more the parameters are penalized for being “large” (deviating from the zero-mean prior), and thus the less flexible the model.

In the case of linear regression, this kind of penalization scheme is called ridge regression. For example, consider the polynomial regression example from Section 1.2.2.2, where the predictor has the form

$$
f ( x ; \pmb { w } ) = \sum _ { d = 0 } ^ { D } w _ { d } x ^ { d } = \pmb { w } ^ { \top } [ 1 , x , x ^ { 2 } , \ldots , x ^ { D } ]
$$

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

![](images/7daf56d3b8643d7d0f12f2f13f64f0395fea53496ee04807e5f44cb1e3f92de5.jpg)  
Figure 4.5: (a-c) Ridge regression applied to a degree 14 polynomial fit to 21 datapoints. (d) MSE vs strength of regularizer. The degree of regularization increases from left to right, so model complexity decreases from left to right. Generated by linreg_poly_ridge.ipynb.

Suppose we use a high degree polynomial, say $D = 1 4$ , even though we have a small dataset with just $N = 2 1$ examples. MLE for the parameters will enable the model to fit the data very well, by carefully adjusting the weights, but the resulting function is very “wiggly”, thus resulting in overfitting. Figure 4.5 illustrates how increasing $\lambda$ can reduce overfitting. For more details on ridge regression, see Section 11.3.

# 4.5.4 Picking the regularizer using a validation set

A key question when using regularization is how to choose the strength of the regularizer $\lambda$ : a small value means we will focus on minimizing empirical risk, which may result in overfitting, whereas a large value means we will focus on staying close to the prior, which may result in underfitting.

In this section, we describe a simple but very widely used method for choosing $\lambda$ . The basic idea is to partition the data into two disjoint sets, the training set $\mathscr { D } _ { \mathrm { t r a i n } }$ and a validation set $\mathcal { D } _ { \mathrm { v a l i d } }$ (also called a development set). (Often we use about 80% of the data for the training set, and

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

![](images/d6bb646a1884ab6f102526071742e7f66cddb0b693164a4edce9046eae1e962c.jpg)  
Figure 4.6: Schematic of 5-fold cross validation.

$2 0 \%$ for the validation set.) We fit the model on $\mathscr { D } _ { \mathrm { t r a i n } }$ (for each setting of $\lambda$ ) and then evaluate its performance on $\mathcal { D } _ { \mathrm { v a l i d } }$ . We then pick the value of $\lambda$ that results in the best validation performance. (This optimization method is a 1d example of grid search, discussed in Section 8.8.)

To explain the method in more detail, we need some notation. Let us define the regularized empirical risk on a dataset as follows:

$$
R _ { \lambda } ( \pmb \theta , \mathscr D ) = \frac { 1 } { | \mathscr D | } \sum _ { ( \pmb x , \pmb y ) \in \mathscr D } \ell ( \pmb y , f ( \pmb x ; \pmb \theta ) ) + \lambda C ( \pmb \theta )
$$

For each $\lambda$ , we compute the parameter estimate

$$
\hat { \pmb \theta } _ { \lambda } ( { \mathcal D } _ { \mathrm { t r a i n } } ) = \underset { \pmb \theta } { \operatorname { a r g m i n } } R _ { \lambda } ( \pmb \theta , { \mathcal D } _ { \mathrm { t r a i n } } )
$$

We then compute the validation risk:

$$
R _ { \lambda } ^ { \mathrm { v a l } } \triangleq R _ { 0 } ( \hat { \pmb \theta } _ { \lambda } ( { \mathcal { D } } _ { \mathrm { t r a i n } } ) , { \mathcal { D } } _ { \mathrm { v a l i d } } )
$$

This is an estimate of the population risk, which is the expected loss under the true distribution $p ^ { * } ( { \pmb x } , { \pmb y } )$ . Finally we pick

$$
\lambda ^ { * } = \operatorname * { a r g m i n } _ { \lambda \in \mathcal { S } } R _ { \lambda } ^ { \mathrm { v a l } }
$$

(This requires fitting the model once for each value of $\lambda$ in $\boldsymbol { S }$ , although in some cases, this can be done more efficiently.)

After picking $\lambda ^ { * }$ , we can refit the model to the entire dataset, $\mathcal { D } = \mathcal { D } _ { \mathrm { t r a i n } } \cup \mathcal { D } _ { \mathrm { v a l i d } }$ , to get

$$
\hat { \pmb { \theta } } ^ { * } = \operatorname * { a r g m i n } _ { \pmb { \theta } } R _ { \lambda ^ { * } } ( \pmb { \theta } , \mathcal { D } )
$$

# 4.5.5 Cross-validation

The above technique in Section 4.5.4 can work very well. However, if the size of the training set is small, leaving aside 20% for a validation set can result in an unreliable estimate of the model parameters.

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

A simple but popular solution to this is to use cross validation (CV). The idea is as follows: we split the training data into $K$ folds; then, for each fold $k \in \{ 1 , \ldots , K \}$ , we train on all the folds but the $k$ ’th, and test on the $k$ ’th, in a round-robin fashion, as sketched in Figure 4.6. Formally, we have

$$
R _ { \lambda } ^ { \mathrm { c v } } \triangleq \frac { 1 } { K } \sum _ { k = 1 } ^ { K } R _ { 0 } ( \hat { \pmb \theta } _ { \lambda } ( \mathcal D _ { - k } ) , \mathcal D _ { k } )
$$

where $\mathcal { D } _ { k }$ is the data in the $k$ ’th fold, and $\mathcal { D } _ { - k }$ is all the other data. This is called the cross-validated risk. Figure 4.6 illustrates this procedure for $K = 5$ . If we set $K = N$ , we get a method known as leave-one-out cross-validation, since we always train on $N - 1$ items and test on the remaining one.

We can use the CV estimate as an objective inside of an optimization routine to pick the optimal hyperparameter, $\ddot { \lambda } = \mathrm { a r g m i n } _ { \lambda } R _ { \lambda } ^ { \mathrm { c v } }$ . Finally we combine all the available data (training and validation), and re-estimate the model parameters using $\begin{array} { r } { \hat { \pmb \theta } = \mathrm { a r g m i n } _ { \pmb \theta } R _ { \hat { \lambda } } ( \pmb \theta , \mathcal { D } ) } \end{array}$ . See Section 5.4.3 for more details.

# 4.5.5.1 The one standard error rule

CV gives an estimate of $\hat { R } _ { \lambda }$ , but does not give any measure of uncertainty. A standard frequentist measure of uncertainty of an estimate is the standard error of the mean, which is the mean of the sampling distribution of the estimate (see Section 4.7.1). We can compute this as follows. First let $L _ { n } = \ell ( { \pmb y } _ { n } , f ( { \pmb x } _ { n } ; \hat { \pmb \theta } _ { \lambda } ( { \pmb D } _ { - n } ) )$ be the loss on the $n$ ’th example, where we use the parameters that were estimated using whichever training fold excludes $n$ . (Note that $L _ { n }$ depends on $\lambda$ , but we drop this from the notation.) Next let $\begin{array} { r } { \hat { \mu } = \frac { 1 } { N } \sum _ { n = 1 } ^ { N } L _ { n } } \end{array}$ be the empirical mean and $\begin{array} { r } { \hat { \sigma } ^ { 2 } = \frac { 1 } { N } \sum _ { n = 1 } ^ { N } ( L _ { n } - \hat { \mu } ) ^ { 2 } } \end{array}$ be the empirical variance. Given this, we define our estimate to be $\hat { \mu }$ , and the standard error of this estimate to be $\begin{array} { r } { \mathrm { s e } ( \hat { \mu } ) = \frac { \ddot { \sigma } } { \sqrt { N _ { \mathscr D } } } } \end{array}$ . Note that $\sigma$ measures the intrinsic variability of $L _ { n }$ across samples, whereas $\mathrm { s e } ( \hat { \mu } )$ measures our uncertainty about the mean $\hat { \mu }$ .

Suppose we apply CV to a set of models and compute the mean and se of their estimated risks. A common heuristic for picking a model from these noisy estimates is to pick the value which corresponds to the simplest model whose risk is no more than one standard error above the risk of the best model; this is called the one-standard error rule [HTF01, p216].

# 4.5.5.2 Example: ridge regression

As an example, consider picking the strength of the $\ell _ { 2 }$ regularizer for the ridge regression problem in Section 4.5.3. In Figure 4.7a, we plot the error vs $\log ( \lambda )$ on the train set (blue) and test set (red curve). We see that the test error has a U-shaped curve, where it decreases as we increase the regularizer, and then increases as we start to underfit. In Figure 4.7b, we plot the 5-fold CV estimate of the test MSE vs $\log ( \lambda )$ . We see that the minimum CV error is close the optimal value for the test set (although it does underestimate the spike in the test error for large lambda, due to the small sample size.)

# 4.5.6 Early stopping

A very simple form of regularization, which is often very effective in practice (especially for complex models), is known as early stopping. This leverages the fact that optimization algorithms are

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022 iterative, and so they take many steps to move away from the initial parameter estimates. If we detect signs of overfitting (by monitoring performance on the validation set), we can stop the optimization process, to prevent the model memorizing too much information about the training set. See Figure 4.8 for an illustration.

![](images/fc02f4b5db8befb7634c2e909d0a5135d2c5631d8948c294b790786f1c2ef598.jpg)  
Figure 4.7: Ridge regression is applied to a degree 14 polynomial fit to 21 datapoints shown in Figure 4.5 for different values of the regularizer λ. The degree of regularization increases from left to right, so model complexity decreases from left to right. (a) MSE on train (blue) and test (red) vs $\log ( \lambda )$ . (b) 5-fold crossvalidation estimate of test MSE; error bars are standard error of the mean. Vertical line is the point chosen by the one standard error rule. Generated by polyfitRidgeCV.ipynb.

# 4.5.7 Using more data

As the amount of data increases, the chance of overfitting (for a model of fixed complexity) decreases (assuming the data contains suitably informative examples, and is not too redundant). This is illustrated in Figure 4.9. We show the MSE on the training and test sets for four different models (polynomials of increasing degree) as a function of the training set size $N$ . (A plot of error vs training set size is known as a learning curve.) The horizontal black line represents the Bayes error, which is the error of the optimal predictor (the true model) due to inherent noise. (In this example, the true model is a degree 2 polynomial, and the noise has a variance of $\sigma ^ { 2 } = 4$ ; this is called the noise floor, since we cannot go below it.)

We notice several interesting things. First, the test error for degree 1 remains high, even as $N$ increases, since the model is too simple to capture the truth; this is called underfitting. The test error for the other models decreases to the optimal level (the noise floor), but it decreases more rapidly for the simpler models, since they have fewer parameters to estimate. The gap between the test error and training error is larger for more complex models, but decreases as $N$ grows.

Another interesting thing we can note is that the training error (blue line) initially increases with $N$ , at least for the models that are sufficiently flexible. The reason for this is as follows: as the data set gets larger, we observe more distinct input-output pattern combinations, so the task of fitting the data becomes harder. However, eventually the training set will come to resemble the test set, and

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

![](images/ed8a2c774bf0bba0414aae815f94420c3ccfee0770b0ebc3a5a8160e35f7ec53.jpg)  
Figure 4.8: Performance of a text classifier (a neural network applied to a bag of word embeddings using average pooling) vs number of training epochs on the IMDB movie sentiment dataset. $B l u e = t r a i n$ , $r e d =$ validation. (a) Cross entropy loss. Early stopping is triggered at about epoch 25. (b) Classification accuracy. Generated by imdb_mlp_bow_tf.ipynb.

![](images/c3a3cc6b4c856d017a695cfd33fe4040078eb63e5dc8445706a267b5bc810eb2.jpg)  
Figure 4.9: MSE on training and test sets vs size of training set, for data generated from a degree 2 polynomial with Gaussian noise of variance $\sigma ^ { 2 } = 4$ . We fit polynomial models of varying degree to this data. Generated by linreg_poly_vs_n.ipynb.

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022 the error rates will converge, and will reflect the optimal performance of that model.

# 4.6 Bayesian statistics \*

So far, we have discussed several ways to estimate parameters from data. However, these approaches ignore any uncertainty in the estimates, which can be important for some applications, such as active learning, or avoiding overfitting, or just knowing how much to trust the estimate of some scientifically meaningful quantity. In statistics, modeling uncertainty about parameters using a probability distribution (as opposed to just computing a point estimate) is known as inference.

In this section, we use the posterior distribution to represent our uncertainty. This is the approach adopted in the field of Bayesian statistics. We give a brief introduction here, but more details can be found in the sequel to this book, [Mur23], as well as other good books, such as [Lam18; Kru15; McE20; Gel+14].

To compute the posterior, we start with a prior distribution $p ( \pmb \theta )$ , which reflects what we know before seeing the data. We then define a likelihood function $p ( { \mathcal { D } } | \mathbf { \theta } )$ , which reflects the data we expect to see for each setting of the parameters. We then use Bayes rule to condition the prior on the observed data to compute the posterior $p ( \pmb { \theta } | \mathcal { D } )$ as follows:

$$
p ( \pmb \theta | \mathcal { D } ) = \frac { p ( \pmb \theta ) p ( \mathcal { D } | \pmb \theta ) } { p ( \mathcal { D } ) } = \frac { p ( \pmb \theta ) p ( \mathcal { D } | \pmb \theta ) } { \int p ( \pmb \theta ^ { \prime } ) p ( \mathcal { D } | \pmb \theta ^ { \prime } ) d \pmb \theta ^ { \prime } }
$$

The denominator $p ( \mathcal D )$ is called the marginal likelihood, since it is computed by marginalizing over (or integrating out) the unknown $\pmb \theta$ . This can be interpreted as the average probability of the data, where the average is wrt the prior. Note, however, that $p ( \mathcal D )$ is a constant, independent of $\pmb \theta$ , so we will often ignore it when we just want to infer the relative probabilities of $\pmb \theta$ values.

Equation (4.107) is analogous to the use of Bayes rule for COVID-19 testing in Section 2.3.1. The difference is that the unknowns correspond to parameters of a statistical model, rather than the unknown disease state of a patient. In addition, we usually condition on a set of observations $\mathcal { D }$ , as opposed to a single observation (such as a single test outcome). In particular, for a supervised or conditional model, the observed data has the form $\mathcal { D } = \{ ( \boldsymbol { x } _ { n } , \boldsymbol { y } _ { n } ) : n = 1 : N \}$ . For an unsupervised or unconditional model, the observed data has the form $\mathcal { D } = \{ ( \pmb { y } _ { n } ) : n = 1 : N \}$ .

Once we have computed the posterior over the parameters, we can compute the posterior predictive distribution over outputs given inputs by marginalizing out the unknown parameters. In the supervised/ conditional case, this becomes

$$
p ( \pmb { y } | \pmb { x } , \mathcal { D } ) = \int p ( \pmb { y } | \pmb { x } , \pmb { \theta } ) p ( \pmb { \theta } | \mathcal { D } ) d \pmb { \theta }
$$

This can be viewed as a form of Bayes model averaging (BMA), since we are making predictions using an infinite set of models (parameter values), each one weighted by how likely it is. The use of BMA reduces the chance of overfitting (Section 1.2.3), since we are not just using the single best model.

# 4.6.1 Conjugate priors

In this section, we consider a set of (prior, likelihood) pairs for which we can compute the posterior in closed form. In particular, we will use priors that are “conjugate” to the likelihood. We say that

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license a prior $p ( \pmb { \theta } ) \in \mathcal { F }$ is a conjugate prior for a likelihood function $p ( \mathcal { D } | \pmb { \theta } )$ if the posterior is in the same parameterized family as the prior, i.e., $p ( \pmb { \theta } | \mathcal { D } ) \in \mathcal { F }$ . In other words, $\mathcal { F }$ is closed under Bayesian updating. If the family $\mathcal { F }$ corresponds to the exponential family (defined in Section 3.4), then the computations can be performed in closed form.

In the sections below, we give some common examples of this framework, which we will use later in the book. For simplicity, we focus on unconditional models (i.e., there are only outcomes or targets $y$ , and no inputs or features $_ { x }$ ); we relax this assumption in Section 4.6.7.

# 4.6.2 The beta-binomial model

Suppose we toss a coin $N$ times, and want to infer the probability of heads. Let $y _ { n } = 1$ denote the event that the $n$ ’th trial was heads, $y _ { n } = 0$ represent the event that the $n$ ’th trial was tails, and let $\mathcal { D } = \{ y _ { n } : n = 1 : N \}$ be all the data. We assume $y _ { n } \sim \operatorname { B e r } ( \theta )$ , where $\theta \in [ 0 , 1 ]$ is the rate parameter (probability of heads). In this section, we discuss how to compute $p ( \theta | \mathcal { D } )$ .

# 4.6.2.1 Bernoulli likelihood

We assume the data are iid or independent and identically distributed. Thus the likelihood has the form

$$
p ( \mathcal { D } | \theta ) = \prod _ { n = 1 } ^ { N } \theta ^ { y _ { n } } ( 1 - \theta ) ^ { 1 - y _ { n } } = \theta ^ { N _ { 1 } } ( 1 - \theta ) ^ { N _ { 0 } }
$$

where we have defined $\begin{array} { r } { N _ { 1 } = \sum _ { n = 1 } ^ { N _ { D } } \mathbb { I } \left( y _ { n } = 1 \right) } \end{array}$ and $\begin{array} { r } { N _ { 0 } = \sum _ { n = 1 } ^ { N _ { D } } \mathbb { I } \left( y _ { n } = 0 \right) } \end{array}$ , representing the number of heads and tails. These counts are called the sufficient statistics of the data, since this is all we need to know about $\mathcal { D }$ to infer $\theta$ . The total count, $N = N _ { 0 } + N _ { 1 }$ , is called the sample size.

# 4.6.2.2 Binomial likelihood

Note that we can also consider a Binomial likelihood model, in which we perform $N$ trials and observe the number of heads, $y$ , rather than observing a sequence of coin tosses. Now the likelihood has the following form:

$$
p ( \mathcal { D } | \theta ) = \mathrm { B i n } ( y | N , \theta ) = { \binom { N } { y } } \theta ^ { y } ( 1 - \theta ) ^ { N - y }
$$

The scaling factor $\binom { N } { y }$ is independent of $\theta$ , so we can ignore it. Thus this likelihood is proportional to the Bernoulli likelihood in Equation (4.109), so our inferences about $\theta$ will be the same for both models.

# 4.6.2.3 Prior

To simplify the computations, we will assume that the prior $p ( \pmb \theta ) \in \mathcal { F }$ is a conjugate prior for the likelihood function $p ( \pmb { y } | \pmb { \theta } )$ . This means that the posterior is in the same parameterized family as the prior, i.e., $p ( \pmb \theta | \mathcal { D } ) \in \mathcal { F }$ .

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

![](images/06f68ccdf90ae8a00327ee99996fd6b6b02e81082749d3bbf6c72ccc990da839.jpg)  
Figure 4.10: Updating a Beta prior with a Bernoulli likelihood with sufficient statistics $N _ {  { D _ { 1 } } } = 4 , N _ {  { D _ { 0 } } } = 1$ . (a) Beta(2,2) prior. (b) Uniform Beta(1,1) prior. Generated by beta_binom_post_plot.ipynb.

To ensure this property when using the Bernoulli (or Binomial) likelihood, we should use a prior of the following form:

$$
p ( \theta ) \propto \theta ^ { \widecheck { \alpha } - 1 } ( 1 - \theta ) ^ { \widecheck { \beta } - 1 } = \operatorname { B e t a } ( \theta | \ \widecheck { \alpha } , \widecheck { \beta } )
$$

We recognize this as the pdf of a beta distribution (see Section 2.7.4).

# 4.6.2.4 Posterior

If we multiply the Bernoulli likelihood in Equation (4.109) with the beta prior in Equation (2.13 we get a beta posterior:

$$
\begin{array} { r l } & { p ( \theta | \mathcal { D } ) \propto \theta ^ { N _ { 1 } } ( 1 - \theta ) ^ { N _ { 0 } } \theta ^ { \widecheck { \alpha } - 1 } ( 1 - \theta ) ^ { \widecheck { \beta } - 1 } } \\ & { \qquad \propto \mathrm { B e t a } ( \theta | \widecheck { \alpha } + N _ { 1 } , \widecheck { \beta } + N _ { 0 } ) } \\ & { \qquad = \mathrm { B e t a } ( \theta | \widehat { \alpha } , \widehat { \beta } ) } \end{array}
$$

where $\widehat { \alpha } \overset { \Delta } { = } \widecheck { \alpha } + N _ { 1 }$ and ${ \widehat { \beta } } { \triangleq } { \breve { \beta } } + N _ { 0 }$ are the parameters of the posterior. Since the posterior has the same functional form as the prior, we say that the beta distribution is a conjugate prior for the Bernoulli likelihood.

The parameters of the prior are called hyper-parameters. It is clear that (in this example) the hyper-parameters play a role analogous to the sufficient statistics; they are therefore often called pseudo counts. We see that we can compute the posterior by simply adding the observed counts (from the likelihood) to the pseudo counts (from the prior).

The strength of the prior is controlled by $\breve { N } = \breve { \alpha } + \breve { \beta }$ ; this is called the equivalent sample size, since it plays a role analogous to the observed sample size, $N = N _ { 0 } + N _ { 1 }$ .

# 4.6.2.5 Example

For example, suppose we set $\breve { \alpha }$ = ${ \vec { \beta } } = 2$ . This is like saying we believe we have already seen two heads and two tails before we see the actual data; this is a very weak preference for the value of $\theta = 0 . 5$ .

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

The effect of using this prior is illustrated in Figure 4.10a. We see the posterior (blue line) is a “compromise” between the prior (red line) and the likelihood (black line).

If we set $\scriptstyle { \breve { \alpha } } = { \breve { \beta } } = 1$ , the corresponding prior becomes the uniform distribution:

$$
p ( \theta ) = \mathrm { B e t a } ( \theta | 1 , 1 ) \propto \theta ^ { 0 } ( 1 - \theta ) ^ { 0 } = \mathrm { U n i f } ( \theta | 0 , 1 )
$$

The effect of using this prior is illustrated in Figure 4.10b. We see that the posterior has exactly the same shape as the likelihood, since the prior was “uninformative”.

# 4.6.2.6 Posterior mode (MAP estimate)

The most probable value of the parameter is given by the MAP estimate

$$
\begin{array} { r l } & { \hat { \theta } _ { \operatorname* { m a p } } = \arg \underset { \theta } { \operatorname* { m a x } } p ( \theta | \mathcal { D } ) } \\ & { \qquad = \arg \underset { \theta } { \operatorname* { m a x } } \log p ( \theta | \mathcal { D } ) } \\ & { \qquad = \arg \underset { \theta } { \operatorname* { m a x } } \log p ( \theta ) + \log p ( \mathcal { D } | \theta ) } \end{array}
$$

One can show that this is given by

$$
\hat { \theta } _ { \mathrm { m a p } } = \frac { \stackrel { \smile } { \alpha } + N _ { 1 } - 1 } { \stackrel { \smile } { \alpha } + N _ { 1 } - 1 + \stackrel { \smile } { \beta } + N _ { 0 } - 1 }
$$

If we use a $\mathrm { B e t a } ( \theta | 2 , 2 )$ prior, this amounts to add-one smoothing:

$$
{ \hat { \theta } } _ { \mathrm { m a p } } = { \frac { N _ { 1 } + 1 } { N _ { 1 } + 1 + N _ { 0 } + 1 } } = { \frac { N _ { 1 } + 1 } { N + 2 } }
$$

If we use a uniform prior, $p ( \theta ) \propto 1$ , the MAP estimate becomes the MLE, since $\log p ( \theta ) = 0$ :

$$
\hat { \theta } _ { \mathrm { m l e } } = \arg \operatorname* { m a x } _ { \theta } \log p ( \mathcal { D } | \theta )
$$

When we use a Beta prior, the uniform distribution is $\scriptstyle { \breve { \alpha } } = { \breve { \beta } } = 1$ . In this case, the MAP estimate reduces to the MLE:

$$
{ \hat { \theta } } _ { \mathrm { m l e } } = { \frac { N _ { 1 } } { N _ { 1 } + N _ { 0 } } } = { \frac { N _ { 1 } } { N } }
$$

If $N _ { 1 } = 0$ , we will estimate that $p ( Y = 1 ) = 0 . 0$ , which says that we do not predict any future observations to be 1. This is a very extreme estimate, that is likely due to insufficient data. We can solve this problem using a MAP estimate with a stronger prior, or using a fully Bayesian approach, in which we marginalize out $\theta$ instead of estimating it, as explained in Section 4.6.2.9.

# 4.6.2.7 Posterior mean

The posterior mode can be a poor summary of the posterior, since it corresponds to a single point.   
The posterior mean is a more robust estimate, since it integrates over the whole space.

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

If $p ( \theta | \mathcal { D } ) = \mathrm { B e t a } ( \theta | \widehat { \alpha } , \widehat { \beta } )$ , then the posterior mean is given by

$$
{ \overline { { \theta } } } \triangleq \mathbb { E } \left[ \theta | { \mathcal { D } } \right] = { \frac { { \widehat { \alpha } } } { { \widehat { \beta } } + { \widehat { \alpha } } } } = { \frac { { \widehat { \alpha } } } { \widehat { N } } }
$$

where $\scriptstyle { \widehat { N } } = { \widehat { \beta } } + { \widehat { \alpha } }$ is the strength (equivalent sample size) of the posterior.

We will now show that the posterior mean is a convex combination of the prior mean, $\scriptstyle { m = \breve { \alpha } } / \breve { N }$ (where $\breve { N } ^ { \triangleq } \breve { \alpha } + \breve { \beta }$ is the prior strength), and the MLE: $\begin{array} { r } { \hat { \theta } _ { \mathrm { m l e } } = \frac { N _ { \mathcal { D } 1 } } { N _ { \mathcal { D } } } } \end{array}$

$$
 \begin{array} { l } { \displaystyle \gamma ] = \frac { \aleph + N _ { 1 } } { \aleph + N _ { 1 } + \aleph + N _ { 0 } } = \frac { \aleph m + N _ { \mathcal { D } 1 } } { N _ { \mathcal { D } } + \aleph } = \frac { \aleph } { N _ { \mathcal { D } } + \aleph } m + \frac { N _ { \mathcal { D } } } { N _ { \mathcal { D } } + \aleph } \frac { N _ { \mathcal { D } 1 } } { N _ { \mathcal { D } } } = \lambda m + N _ { \mathcal { D } } , } \end{array} 
$$

where $\begin{array} { r } { \lambda = \frac { \widetilde { N } } { \widetilde { N } } } \end{array}$ is the ratio of the prior to posterior equivalent sample size. So the weaker the prior, the smaller is $\lambda$ , and hence the closer the posterior mean is to the MLE.

# 4.6.2.8 Posterior variance

To capture some notion of uncertainty in our estimate, a common approach is to compute the standard error of our estimate, which is just the posterior standard deviation:

$$
\sec ( \theta ) = { \sqrt { \mathbb { V } \left[ \theta | { \mathcal { D } } \right] } }
$$

In the case of the Bernoulli model, we showed that the posterior is a beta distribution. The variance of the beta posterior is given by

$$
\mathbb { V } \left[ \theta \vert D \right] = \frac { \widehat { \alpha } \widehat { \beta } } { ( \widehat { \alpha } + \widehat { \beta } ) ^ { 2 } ( \widehat { \alpha } + \widehat { \beta } + 1 ) } = \mathbb { E } \left[ \theta \vert D \right] ^ { 2 } \frac { \widehat { \beta } } { \widehat { \alpha } \left( 1 + \widehat { \alpha } + \widehat { \beta } \right) }
$$

where $\widehat { \alpha } { = } \breve { \alpha } { + } N _ { 1 }$ and $\hat { \beta }$ = $\bigcup { } + N _ { 0 }$ . If $N _ { \mathscr D } \gg \breve { \alpha } + \breve { \beta }$ , this simplifies to

$$
\mathbb { V } \left[ \boldsymbol { \theta } | \mathcal { D } \right] \approx \frac { N _ { \mathcal { D } 1 } N _ { \mathcal { D } 0 } } { { N _ { \mathcal { D } } } ^ { 3 } } = \frac { \hat { \boldsymbol { \theta } } ( 1 - \hat { \boldsymbol { \theta } } ) } { N _ { \mathcal { D } } }
$$

where $\hat { \theta }$ is the MLE. Hence the standard error is given by

$$
\sigma = \sqrt { \mathbb { V } \left[ \theta | \mathcal { D } \right] } \approx \sqrt { \frac { \hat { \theta } ( 1 - \hat { \theta } ) } { N _ { \mathcal { D } } } }
$$

We see that the uncertainty goes down at a rate of $1 / \sqrt { N }$ . We also see that the uncertainty (variance) is maximized when $\hat { \theta } = 0 . 5$ , and is minimized when $\hat { \theta }$ is close to $0$ or $^ { 1 }$ . This makes sense, since it is easier to be sure that a coin is biased than to be sure that it is fair.

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

![](images/125565a4ed3b096137450bc53f3afd0e83bd103839be30379322657656d10bb8.jpg)  
Figure 4.11: Illustration of sequential Bayesian updating for the beta-Bernoulli model. Each colored box represents the predicted distribution $p ( x _ { t } | h _ { t } )$ , where $\pmb { h } _ { t } = ( N _ { 1 , t } , N _ { 0 , t } )$ is the sufficient statistic derived from history of observations up until time $t$ , namely the total number of heads and tails. The probability of heads (blue bar) is given by $p ( x _ { t } = 1 | h _ { t } ) = ( N _ { t , 1 } + 1 ) / ( t + 2 )$ , assuming we start with a uniform ${ \mathrm { B e t a } } ( \theta | 1 , 1 )$ prior. From Figure 3 of [Ort+19]. Used with kind permission of Pedro Ortega.

# 4.6.2.9 Posterior predictive

Suppose we want to predict future observations. A very common approach is to first compute an estimate of the parameters based on training data, $ { \hat { \theta } } (  { \mathcal { D } } )$ , and then to plug that parameter back into the model and use $p ( y | \hat { \pmb \theta } )$ to predict the future; this is called a plug-in approximation. However, this can result in overfitting. As an extreme example, suppose we have seen $N _ { \mathcal { D } } = 3$ heads in a row. The MLE is $\hat { \theta } = 3 / 3 = 1$ . However, if we use this estimate, we would predict that tails are impossible.

One solution to this is to compute a MAP estimate, and plug that in, as we discussed in Section 4.5.1 Here we discuss a fully Bayesian solution, in which we marginalize out $\theta$ .

# Bernoulli model

For the Bernoulli model, the resulting posterior predictive distribution has the form

$$
\begin{array} { l } { \displaystyle p ( y = 1 | D ) = \int _ { 0 } ^ { 1 } p ( y = 1 | \theta ) p ( \theta | \mathcal { D } ) d \theta } \\ { \displaystyle \qquad = \int _ { 0 } ^ { 1 } \theta \operatorname { B e t a } ( \theta | { \widehat { \alpha } } , { \widehat { \beta } } ) d \theta = \mathbb { E } \left[ \theta | D \right] = \frac { { \widehat { \alpha } } } { { \widehat { \alpha } } + { \widehat { \beta } } } } \end{array}
$$

In Section 4.5.1, we had to use the Beta(2,2) prior to recover add-one smoothing, which is a rather unnatural prior. In the Bayesian approach, we can get the same effect using a uniform prior, $p ( \theta ) = \mathrm { B e t a } ( \theta | 1 , 1 )$ , since the predictive distribution becomes

$$
p ( y = 1 | D ) = \frac { N _ { \mathscr D 1 } + 1 } { N _ { \mathscr D 1 } + N _ { \mathscr D 0 } + 2 }
$$

This is known as Laplace’s rule of succession. See Figure 4.11 for an illustration of this in the sequential setting.

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

# Binomial model

Now suppose we were interested in predicting the number of heads in $M > 1$ future coin tossing trials, i.e., we are using the binomial model instead of the Bernoulli model. The posterior over $\theta$ is the same as before, but the posterior predictive distribution is different:

$$
\begin{array} { l } { \displaystyle p ( y | \mathcal { D } , M ) = \int _ { 0 } ^ { 1 } \mathrm { B i n } ( y | M , \theta ) \mathrm { B e t a } ( \theta | \widehat { \alpha } , \widehat { \beta } ) d \theta } \\ { \displaystyle \ = \left( \begin{array} { l } { M } \\ { y } \end{array} \right) \frac { 1 } { B ( \widehat { \alpha } , \widehat { \beta } ) } \int _ { 0 } ^ { 1 } \theta ^ { y } ( 1 - \theta ) ^ { M - y } \theta ^ { \widehat { \alpha } - 1 } ( 1 - \theta ) ^ { \widehat { \beta } - 1 } d \theta } \end{array}
$$

We recognize the integral as the normalization constant for a $\operatorname { B e t a } ( { \widehat { \alpha } } + y , M - y + { \widehat { \beta } } )$ distribution. Hence

$$
\int _ { 0 } ^ { 1 } \theta ^ { y + \widehat { \alpha } - 1 } ( 1 - \theta ) ^ { M - y + \widehat { \beta } - 1 } d \theta = B ( y + \widehat { \alpha } , M - y + \widehat { \beta } )
$$

Thus we find that the posterior predictive is given by the following, known as the (compound) beta-binomial distribution:

$$
B b ( x | M , \widehat { \alpha } , \widehat { \beta } ) \triangleq \binom { M } { x } \frac { B ( x + \widehat { \alpha } , M - x + \widehat { \beta } ) } { B ( \widehat { \alpha } , \widehat { \beta } ) }
$$

In Figure 4.12(a), we plot the posterior predictive density for $M = 1 0$ after seeing $N _ { \mathscr { D } 1 } = 4$ heads and $N _ { \mathscr { D } 0 } = 1$ tails, when using a uniform Beta(1,1) prior. In Figure 4.12(b), we plot the plug-in approximation, given by

$$
\begin{array} { c } { { p ( \theta | \mathcal { D } ) \approx \delta ( \theta - \hat { \theta } ) } } \\ { { p ( y | \mathcal { D } , M ) = \displaystyle \int _ { 0 } ^ { 1 } \mathrm { B i n } ( y | M , \theta ) p ( \theta | \mathcal { D } ) d \theta = \mathrm { B i n } ( y | M , \hat { \theta } ) } } \end{array}
$$

where $\hat { \theta }$ is the MAP estimate. Looking at Figure 4.12, we see that the Bayesian prediction has longer tails, spreading its probability mass more widely, and is therefore less prone to overfitting and black-swan type paradoxes. (Note that we use a uniform prior in both cases, so the difference is not arising due to the use of a prior; rather, it is due to the fact that the Bayesian approach integrates out the unknown parameters when making its predictions.)

# 4.6.2.10 Marginal likelihood

The marginal likelihood or evidence for a model $\mathcal { M }$ is defined as

$$
p ( \mathcal { D } | \mathcal { M } ) = \int p ( \pmb { \theta } | \mathcal { M } ) p ( \mathcal { D } | \pmb { \theta } , \mathcal { M } ) d \pmb { \theta }
$$

When performing inference for the parameters of a specific model, we can ignore this term, since it is constant wrt $\pmb \theta$ . However, this quantity plays a vital role when choosing between different models, as we discuss in Section 5.2.2. It is also useful for estimating the hyperparameters from data (an approach known as empirical Bayes), as we discuss in Section 4.6.5.3.

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

![](images/d7a3a7c7909808b419870f47a70856b5f03af4d3f74d6e5cbac91f23c40f280e.jpg)  
Figure 4.12: (a) Posterior predictive distributions for 10 future trials after seeing $N _ { \mathscr { D } 1 } = 4$ heads and $N _ { \mathscr { D } 0 } = 1$ tails. (b) Plug-in approximation based on the same data. In both cases, we use a uniform prior. Generated by beta_binom_post_pred_plot.ipynb.

In general, computing the marginal likelihood can be hard. However, in the case of the betaBernoulli model, the marginal likelihood is proportional to the ratio of the posterior normalizer to the prior normalizer. To see this, recall that the posterior for the beta-binomial models is given by $p ( \theta | \mathcal { D } ) = \mathrm { B e t a } ( \theta | a ^ { \prime } , b ^ { \prime } )$ , where $a ^ { \prime } = a + N _ { D 1 }$ and $b ^ { \prime } = b + N _ { \mathcal { D } 0 }$ . We know the normalization constant of the posterior is $B ( a ^ { \prime } , b ^ { \prime } )$ . Hence

$$
\begin{array} { c l } { \displaystyle p ( \theta | \mathcal { D } ) = \frac { p ( \mathcal { D } | \theta ) p ( \theta ) } { p ( \mathcal { D } ) } } \\ { \displaystyle } & { = \frac { 1 } { p ( \mathcal { D } ) } \left[ \frac { 1 } { B ( a , b ) } \theta ^ { a - 1 } ( 1 - \theta ) ^ { b - 1 } \right] \left[ \left( { \displaystyle N _ { \mathcal { D } 1 } } \right) \theta ^ { N _ { \mathcal { D } 1 } } ( 1 - \theta ) ^ { N _ { \mathcal { D } 0 } } \right] } \\ { \displaystyle } & { = \left( { \displaystyle N _ { \mathcal { D } 1 } } \right) \frac { 1 } { p ( \mathcal { D } ) } \frac { 1 } { B ( a , b ) } \left[ \theta ^ { a + N _ { \mathcal { D } 1 } - 1 } ( 1 - \theta ) ^ { b + N _ { \mathcal { D } 0 } - 1 } \right] } \end{array}
$$

So

$$
\begin{array} { c } { { \displaystyle \frac { 1 } { B ( a + N _ { \mathcal D 1 } , b + N _ { \mathcal D 0 } ) } = \left( { N _ { \mathcal D 1 } } \right) \displaystyle \frac { 1 } { p ( \mathcal D ) } \displaystyle \frac { 1 } { B ( a , b ) } } } \\ { { p ( \mathcal D ) = \left( { N _ { \mathcal D } } \right) \displaystyle \frac { B ( a + N _ { \mathcal D 1 } , b + N _ { \mathcal D 0 } ) } { B ( a , b ) } } } \end{array}
$$

The marginal likelihood for the beta-Bernoulli model is the same as above, except it is missing the $\binom { N _ { D } } { N _ { D 1 } }$ term.

# 4.6.2.11 Mixtures of conjugate priors

The beta distribution is a conjugate prior for the binomial likelihood, which enables us to easily compute the posterior in closed form, as we have seen. However, this prior is rather restrictive. For example, suppose we want to predict the outcome of a coin toss at a casino, and we believe that the coin may be fair, but may equally likely be biased towards heads. This prior cannot be represented

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022 by a beta distribution. Fortunately, it can be represented as a mixture of beta distributions. For example, we might use

![](images/dcbcecdf3478909ae76615c9973c89395cc85f2ce7604942884aed5844862cb4.jpg)  
Figure 4.13: A mixture of two Beta distributions. Generated by mixbetademo.ipynb.

$$
\begin{array} { r } { p ( \theta ) = 0 . 5 \mathrm { B e t a } ( \theta | 2 0 , 2 0 ) + 0 . 5 \mathrm { B e t a } ( \theta | 3 0 , 1 0 ) } \end{array}
$$

If $\theta$ comes from the first distribution, the coin is fair, but if it comes from the second, it is biased towards heads.

We can represent a mixture by introducing a latent indicator variable $h$ , where $h = k$ means that $\theta$ comes from mixture component $k$ . The prior has the form

$$
p ( \theta ) = \sum _ { k } p ( h = k ) p ( \theta | h = k )
$$

where each $p ( \theta | h = k )$ is conjugate, and $p ( h = k )$ are called the (prior) mixing weights. One can show (Exercise 4.6) that the posterior can also be written as a mixture of conjugate distributions as follows:

$$
p ( \theta | \mathcal { D } ) = \sum _ { k } p ( h = k | \mathcal { D } ) p ( \theta | \mathcal { D } , h = k )
$$

where $p ( h = k | \mathcal { D } )$ are the posterior mixing weights given by

$$
p ( h = k | \mathcal { D } ) = \frac { p ( h = k ) p ( \mathcal { D } | h = k ) } { \sum _ { k ^ { \prime } } p ( h = k ^ { \prime } ) p ( \mathcal { D } | h = k ^ { \prime } ) }
$$

Here the quantity $p ( \mathcal { D } | h = k )$ is the marginal likelihood for mixture component $k$ (see Section 4.6.2.10). Returning to our example above, if we have the prior in Equation (4.144), and we observe $N _ { D 1 } = 2 0$ heads and $N _ {  Ḋ \mathcal Ḋ D Ḍ Ḍ _ { 0 } } = 1 0$ tails, then, using Equation (4.143), the posterior becomes

$$
p ( \theta | \mathcal { D } ) = 0 . 3 4 6 \ \mathrm { B e t a } ( \theta | 4 0 , 3 0 ) + 0 . 6 5 4 \ \mathrm { B e t a } ( \theta | 5 0 , 2 0 )
$$

See Figure 4.13 for an illustration.

We can compute the posterior probability that the coin is biased towards heads as follows:

$$
\operatorname* { P r } ( \theta > 0 . 5 | \mathcal { D } ) = \sum _ { k } \operatorname* { P r } ( \theta > 0 . 5 | \mathcal { D } , h = k ) p ( h = k | \mathcal { D } ) = 0 . 9 6 0 4
$$

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

If we just used a single Beta(20,20) prior, we would get a slightly smaller value of $\operatorname* { P r } ( \theta > 0 . 5 | \mathcal { D } ) =$ 0.8858. So if we were “suspicious” initially that the casino might be using a biased coin, our fears would be confirmed more quickly than if we had to be convinced starting with an open mind.

# 4.6.3 The Dirichlet-multinomial model

In this section, we generalize the results from Section 4.6.2 from binary variables (e.g., coins) to $K$ -ary variables (e.g., dice).

# 4.6.3.1 Likelihood

Let $Y \sim { \mathrm { C a t } } ( \pmb { \theta } )$ be a discrete random variable drawn from a categorical distribution. The likelihood has the form

$$
p ( \mathcal { D } | \boldsymbol { \theta } ) = \prod _ { n = 1 } ^ { N } \mathrm { C a t } ( y _ { n } | \boldsymbol { \theta } ) = \prod _ { n = 1 } ^ { N } \prod _ { c = 1 } ^ { C } \theta _ { c } ^ { \mathbb { I } ( y _ { n } = c ) } = \prod _ { c = 1 } ^ { C } \theta _ { c } ^ { N _ { c } }
$$

where $\begin{array} { r } { N _ { c } = \sum _ { n } \mathbb { I } \left( y _ { n } = c \right) } \end{array}$ .

# 4.6.3.2 Prior

The conjugate prior for a categorical distribution is the Dirichlet distribution, which is a multivariate generalization of the beta distribution. This has support over the probability simplex, defined by

$$
S _ { K } = \{ \pmb \theta : 0 \leq \theta _ { k } \leq 1 , \sum _ { k = 1 } ^ { K } \theta _ { k } = 1 \}
$$

The pdf of the Dirichlet is defined as follows:

$$
\operatorname { D i r } ( \pmb \theta | \overset { \triangledown } { \vec { \alpha } } ) \triangleq \frac { 1 } { B ( \widecheck { \alpha } ) } \prod _ { k = 1 } ^ { K } \theta _ { k } ^ { \widecheck { \alpha } _ { k } - 1 } \mathbb { I } \left( \pmb \theta \in S _ { K } \right)
$$

where $B ( \breve { \alpha } )$ is the multivariate beta function,

$$
B ( \breve { \pmb { \alpha } } ) \triangleq \frac { \prod _ { k = 1 } ^ { K } \Gamma ( \breve { \alpha } _ { k } ) } { \Gamma ( \sum _ { k = 1 } ^ { K } \breve { \alpha } _ { k } ) }
$$

Figure 4.14 shows some plots of the Dirichlet when $K = 3$ . We see that $\begin{array} { r } { \breve { \alpha } _ { 0 } = \sum _ { k } \breve { \alpha } _ { k } } \end{array}$ controls the strength of the distribution (how peaked it is), and the $\breve { \alpha } _ { k }$ control where the peak occurs. For example, $\operatorname { D i r } ( 1 , 1 , 1 )$ is a uniform distribution, $\operatorname { D i r } ( 2 , 2 , 2 )$ is a broad distribution centered at $( 1 / 3 , 1 / 3 , 1 / 3 )$ , and $\operatorname { D i r } ( 2 0 , 2 0 , 2 0 )$ is a narrow distribution centered at $( 1 / 3 , 1 / 3 , 1 / 3 )$ . $\mathrm { D i r } ( 3 , 3 , 2 0 )$ is an asymmetric distribution that puts more density in one of the corners. If $\breve { \alpha } _ { k } < 1$ for all $k$ , we get “spikes” at the corners of the simplex. Samples from the distribution when $\breve { \alpha } _ { k } < 1$ will be sparse, as shown in Figure 4.15.

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

![](images/0025b3177809af6f2c3706e893ec5eb1d60349ae34e70f67b61f4c968d96334b.jpg)  
Figure 4.14: (a) The Dirichlet distribution when $K = 3$ defines a distribution over the simplex, which can be represented by the triangular surface. Points on this surface satisfy $0 \leq \theta _ { k } \leq 1$ and $\textstyle \sum _ { k = 1 } ^ { 3 } \theta _ { k } = 1$ . Generated by dirichlet_ ${ \mathit { 3 d } } _ { - }$ triangle_plot.ipynb. (b) Plot of the Dirichlet density for $\breve { \pmb { \alpha } } = ( 2 0 , 2 0 , 2 0 )$ . (c) Plot of the Dirichlet density for $\breve { \alpha } = ( 3 , 3 , 2 0 )$ . (d) Plot of the Dirichlet density for $\breve { \alpha } = ( 0 . 1 , 0 . 1 , 0 . 1 )$ . Generated by dirichlet_3d_spiky_plot.ipynb.

# 4.6.3.3 Posterior

We can combine the multinomial likelihood and Dirichlet prior to compute the posterior, as follows:

$$
\begin{array} { l } { { \displaystyle p ( \theta | { \mathcal D } ) \propto p ( { \mathcal D } | \theta ) \mathrm { D i r } ( \theta | \xrightarrow \alpha ) } } \\ { ~ = \left[ \prod _ { k } \theta _ { k } ^ { N _ { k } } \right] \left[ \prod _ { k } \theta _ { k } ^ { \widecheck { \alpha } _ { k } - 1 } \right] } \\ { ~ = \operatorname { D i r } ( \theta | \widecheck { \alpha } _ { 1 } + N _ { 1 } , \ldots , \widecheck { \alpha } _ { K } + N _ { K } ) } \\ { ~ = \operatorname { D i r } ( \theta | \widehat { \alpha } ) } \end{array}
$$

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

![](images/5b6d5886a8ff821dbb986278c4af053a742703da530f91933847e49185d402d0.jpg)  
Figure 4.15: Samples from a 5-dimensional symmetric Dirichlet distribution for different parameter values. (a) $\breve { \alpha } = ( 0 . 1 , \ldots , 0 . 1 )$ . This results in very sparse distributions, with many 0s. (b) $\breve { \alpha } = ( 1 , \ldots , 1 )$ . This results in more uniform (and dense) distributions. Generated by dirichlet_samples_plot.ipynb.

where $\widehat { \alpha } _ { k } { = } \breve { \alpha } _ { k } + N _ { k }$ are the parameters of the posterior. So we see that the posterior can be computed by adding the empirical counts to the prior counts.

The posterior mean is given by

$$
\overline { { \theta } } _ { k } = \frac { \widehat { \alpha } _ { k } } { \sum _ { k ^ { \prime } = 1 } ^ { K } \widehat { \alpha } _ { k ^ { \prime } } }
$$

The posterior mode, which corresponds to the MAP estimate, is given by

$$
\hat { \theta } _ { k } = \frac { \hat { \alpha } _ { k } - 1 } { \sum _ { k ^ { \prime } = 1 } ^ { K } \left( \hat { \alpha } _ { k ^ { \prime } } - 1 \right) }
$$

If we use $\breve { \alpha } _ { k } = 1$ , corresponding to a uniform prior, the MAP becomes the MLE:

$$
\hat { \theta } _ { k } = N _ { k } / N
$$

(See Section 4.2.4 for a more direct derivation of this result.)

# 4.6.3.4 Posterior predictive

The posterior predictive distribution is given by

$$
\begin{array} { l } { { \displaystyle p ( y = k | \mathcal { D } ) = \int p ( y = k | \theta ) p ( \theta | \mathcal { D } ) d \theta } } \\ { { \displaystyle \qquad = \int \theta _ { k } p ( \theta _ { k } | \mathcal { D } ) d \theta _ { k } = \mathbb { E } \left[ \theta _ { k } | \mathcal { D } \right] = \frac { \widehat { \alpha } _ { k } } { \sum _ { k ^ { \prime } } \widehat { \alpha } _ { k ^ { \prime } } } } } \end{array}
$$

In other words, the posterior predictive distribution is given by

$$
p ( y | \mathcal { D } ) = \mathrm { C a t } ( y | \overline { { \pmb { \theta } } } )
$$

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

where $\overline { { \pmb { \theta } } } \triangleq \mathbb { E } \left[ \pmb { \theta } | \mathcal { D } \right]$ are the posterior mean parameters. If instead we plug-in the MAP estimate, we will suffer from the zero-count problem. The only way to get the same effect as add-one smoothing is to use a MAP estimate with $\breve { \alpha } _ { c } = 2$ .

Equation (4.162) gives the probability of a single future event, conditioned on past observations ${ \pmb y } = ( y _ { 1 } , \dots , y _ { N } )$ . In some cases, we want to know the probability of observing a batch of future data, say $\tilde { \pmb { y } } = ( \tilde { y } _ { 1 } , \dots , \tilde { y } _ { M } )$ . We can compute this as follows:

$$
p ( \tilde { \pmb { y } } | \pmb { y } ) = \frac { p ( \tilde { \pmb { y } } , \pmb { y } ) } { p ( \pmb { y } ) }
$$

The denominator is the marginal likelihood of the training data, and the numerator is the marginal likelihood of the training and future test data. We discuss how to compute such marginal likelihoods in Section 4.6.3.5.

# 4.6.3.5 Marginal likelihood

By the same reasoning as in Section 4.6.2.10, one can show that the marginal likelihood for the Dirichlet-categorical model is given by

$$
p ( \mathcal { D } ) = \frac { B ( \mathbf { N } + \pmb { \alpha } ) } { B ( \pmb { \alpha } ) }
$$

where

$$
B ( \alpha ) = { \frac { \prod _ { k = 1 } ^ { K } \Gamma ( \alpha _ { k } ) } { \Gamma ( \sum _ { k } \alpha _ { k } ) } }
$$

Hence we can rewrite the above result in the following form, which is what is usually presented in the literature:

$$
p ( \mathcal D ) = \frac { \Gamma ( \sum _ { k } \alpha _ { k } ) } { \Gamma ( N _ { \mathcal D } + \sum _ { k } \alpha _ { k } ) } \prod _ { k } \frac { \Gamma ( N _ { \mathcal D k } + \alpha _ { k } ) } { \Gamma ( \alpha _ { k } ) }
$$

# 4.6.4 The Gaussian-Gaussian model

In this section, we derive the posterior for the parameters of a Gaussian distribution. For simplicity, we assume the variance is known. (The general case is discussed in the sequel to this book, [Mur23], as well as other standard references on Bayesian statistics.)

# 4.6.4.1 Univariate case

If $\sigma ^ { 2 }$ is a known constant, the likelihood for $\mu$ has the form

$$
p ( \mathcal D | \boldsymbol \mu ) \propto \exp \left( - \frac { 1 } { 2 \sigma ^ { 2 } } \sum _ { n = 1 } ^ { N _ { D } } ( y _ { n } - \mu ) ^ { 2 } \right)
$$

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

![](images/326acd4365cd16643326bf278406f61d23459d9a33d6a36b53fbee5e11c75bd9.jpg)  
Figure 4.16: Inferring the mean of a univariate Gaussian with known $\sigma ^ { 2 }$ given observation $y = 3$ . (a) Using strong prior, $p ( \mu ) = \mathcal { N } ( \mu | 0 , 1 )$ . (b) Using weak prior, $p ( \mu ) = \mathcal { N } ( \mu | 0 , 5 )$ . Generated by gauss_infer_1d.ipynb.

One can show that the conjugate prior is another Gaussian, $\mathcal { N } ( \mu | \breve { m } , \breve { \tau } ^ { 2 } )$ . Applying Bayes’ rule for Gaussians, as in Section 4.6.4.1, we find that the corresponding posterior is given by

$$
\begin{array} { c } { \displaystyle p ( \mu | \mathcal { D } , \boldsymbol { \sigma } ^ { 2 } ) = \mathcal { N } ( \mu | \hat { m } , \hat { \tau } ^ { 2 } ) } \\ { \displaystyle \hat { \tau } ^ { 2 } = \frac { 1 } { \frac { N } { \sigma ^ { 2 } } + \frac { 1 } { \check { \tau } ^ { 2 } } } = \frac { \boldsymbol { \sigma } ^ { 2 } \check { \tau } ^ { 2 } } { N \check { \tau } ^ { 2 } + \boldsymbol { \sigma } ^ { 2 } } } \\ { \displaystyle \hat { m } = \hat { \tau } ^ { 2 } \left( \frac { \check { m } } { \check { \tau } ^ { 2 } } + \frac { N \check { y } } { \boldsymbol { \sigma } ^ { 2 } } \right) = \frac { \boldsymbol { \sigma } ^ { 2 } } { N \check { \tau } ^ { 2 } + \boldsymbol { \sigma } ^ { 2 } } \check { m } + \frac { N \check { \tau } ^ { 2 } } { N \check { \tau } ^ { 2 } + \boldsymbol { \sigma } ^ { 2 } } \overline { { y } } } \end{array}
$$

where $\textstyle { \overline { { y } } } \triangleq { \frac { 1 } { N } } \sum _ { n = 1 } ^ { N } y _ { n }$ is the empirical mean.

This result is easier to understand if we work in terms of the precision parameters, which are just inverse variances. Specifically, let $\kappa = 1 / \sigma ^ { 2 }$ be the observation precision, and $\breve { \lambda } = 1 / \breve { \tau } ^ { 2 }$ be the precision of the prior. We can then rewrite the posterior as follows:

$$
\begin{array} { l } { { p ( \mu | \mathcal { D } , \kappa ) = \mathcal { N } ( \mu | \hat { m } , \widehat { \lambda } ^ { - 1 } ) } } \\ { { \displaystyle \qquad \widehat { \lambda } = \widecheck { \lambda } + N \kappa } } \\ { { \displaystyle \widehat { m } = \frac { N \kappa \overline { { y } } + \widecheck { \lambda } \widecheck { m } } { \widehat { \lambda } } = \frac { N \kappa } { N \kappa + \widecheck { \lambda } } \overline { { y } } + \frac { \widecheck { \lambda } } { N \kappa + \widecheck { \lambda } } \widecheck { m } } } \end{array}
$$

These equations are quite intuitive: the posterior precision $\hat { \lambda }$ is the prior precision $\breve { \lambda }$ plus $N$ units of measurement precision $\kappa$ . Also, the posterior mean $\acute { m }$ is a convex combination of the empirical mean $y$ and the prior mean $\breve { m }$ . This makes it clear that the posterior mean is a compromise between the empirical mean and the prior. If the prior is weak relative to the signal strength ( $\breve { \lambda }$ is small relative to $\kappa$ ), we put more weight on the empirical mean. If the prior is strong relative to the signal strength ( $\breve { \lambda }$ is large relative to $\kappa$ ), we put more weight on the prior. This is illustrated in Figure 4.16. Note also that the posterior mean is written in terms of $N \kappa \overline { { y } }$ , so having $N$ measurements each of precision $\kappa$ is like having one measurement with value $\overline { y }$ and precision $N \kappa$ .

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

# Posterior after seeing $N = 1$ examples

To gain further insight into these equations, consider the posterior after seeing a single data point $y$ (so $N = 1$ ). Then the posterior mean can be written in the following equivalent ways:

$$
\begin{array} { l } { { \displaystyle { \widehat { m } } = \frac { \check { \lambda } } { \hat { \lambda } } \ \breve { m } + \frac { \kappa } { \hat { \lambda } } y } } \\ { { \displaystyle ~ = \breve { m } + \frac { \kappa } { \hat { \lambda } } ( y - \breve { m } ) } } \\ { { \displaystyle ~ = y - \frac { \breve { \lambda } } { \hat { \lambda } } ( y - \breve { m } ) } } \end{array}
$$

The first equation is a convex combination of the prior mean and the data. The second equation is the prior mean adjusted towards the data $y$ . The third equation is the data adjusted towards the prior mean; this is called a shrinkage estimate. This is easier to see if we define the weight $w = \left. \breve { \lambda } \right/ \hat { \lambda }$ , which is the ratio of the prior to posterior precision. Then we have

$$
\begin{array} { r } { \widehat { m } = y - w ( y - \check { m } ) = ( 1 - w ) y + w \check { m } } \end{array}
$$

Note that, for a Gaussian, the posterior mean and posterior mode are the same. Thus we can use the above equations to perform MAP estimation. See Exercise 4.2 for a simple example.

# Posterior variance

In addition to the posterior mean or mode of $\mu$ , we might be interested in the posterior variance, which gives us a measure of confidence in our estimate. The square root of this is called the standard error of the mean:

$$
\operatorname { s e } ( \mu ) \triangleq { \sqrt { \mathbb { V } \left[ \mu | { \mathcal { D } } \right] } }
$$

Suppose we use an uninformative prior for $\mu$ by setting $\overset { \smile } { \lambda } = 0$ (see Section 4.6.5.1). In this case, the posterior mean is equal to the MLE, $\mathrm { { \acute { m } } = \mathrm { { \overline { { y } } } } }$ . Suppose, in addition, that we approximate $\sigma ^ { 2 }$ by the sample variance

$$
s ^ { 2 } \triangleq \frac { 1 } { N } \sum _ { n = 1 } ^ { N } ( y _ { n } - \overline { { y } } ) ^ { 2 }
$$

Hence $\widehat { \lambda } { = } N \widehat { \kappa } = N / s ^ { 2 }$ , so the SEM becomes

$$
\sec ( \mu ) = { \sqrt { \mathbb { V } [ \mu | { \mathcal { D } } ] } } = { \frac { 1 } { \sqrt { \lambda } } } = { \frac { s } { \sqrt { N } } }
$$

Thus we see that the uncertainty in $\mu$ is reduced at a rate of $1 / \sqrt { N }$ .

In addition, we can use the fact that $9 5 \%$ of a Gaussian distribution is contained within 2 standard deviations of the mean to approximate the $9 5 \%$ credible interval for $\mu$ using

$$
I _ { \cdot 9 5 } ( \mu | \mathcal { D } ) = \overline { { y } } \pm 2 \frac { s } { \sqrt { N } }
$$

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

![](images/d5801ead814b18f3b38946d06567059a42ad9d8c4514b39265d5d5dae7642af7.jpg)  
Figure 4.17: Illustration of Bayesian inference for the mean of a 2d Gaussian. (a) The data is generated from ${ \pmb y } _ { n } \sim \mathcal { N } ( { \pmb \mu } , { \pmb \Sigma } )$ , where $\pmb { \mu } = [ 0 . 5 , 0 . 5 ] ^ { \top }$ and $\pmb { \Sigma } = 0 . 1 [ 2 , 1 ; 1 , 1 ] ,$ ). (b) The prior is $p ( \pmb { \mu } ) = \mathcal { N } ( \pmb { \mu } | \mathbf { 0 } , 0 . 1 \mathbf { I } _ { 2 } )$ . (c) We show the posterior after 10 data points have been observed. Generated by gauss_infer_2d.ipynb.

# 4.6.4.2 Multivariate case

For $D$ -dimensional data, the likelihood has the form

$$
\begin{array} { l } { { \displaystyle p ( { \mathcal D } | { \boldsymbol \mu } ) = \prod _ { n = 1 } ^ { N } { \mathcal N } ( y _ { n } | { \boldsymbol \mu } , { \boldsymbol \Sigma } ) } } \\ { ~ = \frac { N } { ( 2 \pi ) ^ { D / 2 } | { \boldsymbol \Sigma } | ^ { \frac { 1 } { 2 } } } \exp \left[ - \frac { 1 } { 2 } \sum _ { n = 1 } ^ { N } ( y _ { n } - { \boldsymbol \mu } ) ^ { \mathsf T } { \boldsymbol \Sigma } ^ { - 1 } ( y _ { n } - { \boldsymbol \mu } ) \right] }  \\ { ~ = { \mathcal N } ( \overline { y } | { \boldsymbol \mu } , \frac { 1 } { N } { \boldsymbol \Sigma } ) } \end{array}
$$

where $\begin{array} { r } { \overline { { \pmb { y } } } = \frac { 1 } { N } \sum _ { n = 1 } ^ { N } { \pmb { y } _ { n } } } \end{array}$ . T us we replace the set of observations with their mean, and scale down the $N$

For simplicity, we will use a conjugate prior, which in this case is a Gaussian, namely

$$
\begin{array} { r } { p ( \pmb { \mu } ) = \mathcal { N } ( \pmb { \mu } | \breve { \pmb { m } } , \breve { \bf V } ) } \end{array}
$$

We can derive a Gaussian posterior for $\pmb { \mu }$ based on the results in Section 3.3.1 We get

$$
\begin{array} { c } { p ( \pmb { \mu } | \mathcal { D } , \pmb { \Sigma } ) = \mathcal { N } ( \pmb { \mu } | \hat { m } , \pmb { \hat { \mathbf { V } } } ) } \\ { \pmb { \hat { \mathbf { V } } } ^ { - 1 } = \check { \mathbf { V } } ^ { - 1 } + N _ { \mathcal { D } } \pmb { \Sigma } ^ { - 1 } } \\ { \pmb { \hat { m } } = \hat { \mathbf { V } } \left( \pmb { \Sigma } ^ { - 1 } ( N _ { \mathcal { D } } \overline { { \pmb { y } } } ) + \check { \mathbf { V } } ^ { - 1 } \check { m } \right) } \end{array}
$$

Figure 4.17 gives a 2d example of these results.

# 4.6.5 Beyond conjugate priors

We have seen various examples of conjugate priors, all of which have come from the exponential family (see Section 3.4). These priors have the advantage of being easy to interpret (in terms of

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022 sufficient statistics from a virtual prior dataset), and easy to compute with. However, for most models, there is no prior in the exponential family that is conjugate to the likelihood. Furthermore, even where there is a conjugate prior, the assumption of conjugacy may be too limiting. Therefore in the sections below, we briefly discuss various other kinds of priors.

# 4.6.5.1 Noninformative priors

When we have little or no domain specific knowledge, it is desirable to use an uninformative, noninformative or objective priors, to “let the data speak for itself”. For example, if we want to infer a real valued quantity, such as a location parameter $\mu \in \mathbb { R }$ , we can use a flat prior $p ( \mu ) \propto 1$ . This can be viewed as an “infinitely wide” Gaussian.

Unfortunately, there is no unique way to define uninformative priors, and they all encode some kind of knowledge. It is therefore better to use the term diffuse prior, minimally informative prior or default prior. See the sequel to this book, [Mur23], for more details.

# 4.6.5.2 Hierarchical priors

Bayesian models require specifying a prior $p ( \pmb \theta )$ for the parameters. The parameters of the prior are called hyperparameters, and will be denoted by $\phi$ . If these are unknown, we can put a prior on them; this defines a hierarchical Bayesian model, or multi-level model, which can visualize like this: $\phi  \theta  \mathcal { D }$ . We assume the prior on the hyper-parameters is fixed (e.g., we may use some kind of minimally informative prior), so the joint distribution has the form

$$
p ( \phi , \pmb \theta , \mathcal { D } ) = p ( \phi ) p ( \pmb \theta | \phi ) p ( \mathcal { D } | \pmb \theta )
$$

The hope is that we can learn the hyperparameters by treating the parameters themselves as datapoints. This is useful when we have multiple related parameters that need to be estimated (e.g., from different subpopulations, or muliple tasks); this provides a learning signal to the top level of the model. See the sequel to this book, [Mur23], for details.

# 4.6.5.3 Empirical priors

In Section 4.6.5.2, we discussed hierarchical Bayes as a way to infer parameters from data. Unfortunately, posterior inference in such models can be computationally challenging. In this section, we discuss a computationally convenient approximation, in which we first compute a point estimate of the hyperparameters, $\hat { \phi }$ , and then compute the conditional posterior, $p ( \pmb { \theta } | \hat { \phi } , \mathcal { D } )$ , rather than the joint posterior, $p ( \theta , \phi | \mathcal { D } )$ .

To estimate the hyper-parameters, we can maximize the marginal likelihood:

$$
\hat { \phi } _ { \mathrm { m m l } } ( { \mathcal D } ) = \underset { \phi } { \operatorname { a r g m a x } } p ( { \mathcal D } | \phi ) = \underset { \phi } { \operatorname { a r g m a x } } \int p ( { \mathcal D } | \theta ) p ( \theta | \phi ) d \theta
$$

This technique is known as type II maximum likelihood, since we are optimizing the hyperparameters, rather than the parameters. Once we have estimated $\hat { \phi }$ , we compute the posterior $p ( \pmb { \theta } | \hat { \phi } , \mathcal { D } )$ in the usual way.

Since we are estimating the prior parameters from data, this approach is empirical Bayes (EB) [CL96]. This violates the principle that the prior should be chosen independently of the data.

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

However, we can view it as a computationally cheap approximation to inference in the full hierarchical Bayesian model, just as we viewed MAP estimation as an approximation to inference in the one level model $\theta  \mathcal { D }$ . In fact, we can construct a hierarchy in which the more integrals one performs, the “more Bayesian” one becomes, as shown below.

<html><body><table><tr><td>Method</td><td>Definition</td></tr><tr><td>Maximum likelihood</td><td>0 = argmaxo p(D|0)</td></tr><tr><td>MAP estimation</td><td>0 = argmaxθ p(D|θ)p(0|Φ)</td></tr><tr><td>ML-II (Empirical Bayes) MAP-II</td><td>= argmaxΦ ʃ p(D|0)p(0|Φ)d0</td></tr><tr><td>Full Bayes</td><td>Φ= argmaxρ ʃ p(D|0)p(0\Φ)p(Φ)d0 p(0,Φ|D) x p(D|0)p(0|Φ)p(Φ)</td></tr></table></body></html>

Note that ML-II is less likely to overfit than “regular” maximum likelihood, because there are typically fewer hyper-parameters $\phi$ than there are parameters $\pmb \theta$ . See the sequel to this book, [Mur23], for details.

# 4.6.6 Credible intervals

A posterior distribution is (usually) a high dimensional object that is hard to visualize and work with. A common way to summarize such a distribution is to compute a point estimate, such as the posterior mean or mode, and then to compute a credible interval, which quantifies the uncertainty associated with that estimate. (A credible interval is not the same as a confidence interval, which is a concept from frequentist statistics which we discuss in Section 4.7.4.)

More precisely, we define a $1 0 0 ( 1 - \alpha ) \%$ credible interval to be a (contiguous) region $C = ( \ell , u )$ (standing for lower and upper) which contains $1 - \alpha$ of the posterior probability mass, i.e.,

$$
C _ { \alpha } ( \mathcal { D } ) = ( \ell , u ) : P ( \ell \leq \theta \leq u | \mathcal { D } ) = 1 - \alpha
$$

There may be many intervals that satisfy Equation (4.192), so we usually choose one such that there is $( 1 - \alpha ) / 2$ mass in each tail; this is called a central interval. If the posterior has a known functional form, we can compute the posterior central interval using $\ell = F ^ { - 1 } ( \alpha / 2 )$ and $u = F ^ { - 1 } ( 1 - \alpha / 2 )$ , where $F$ is the cdf of the posterior, and $F ^ { - 1 }$ is the inverse cdf. For example, if the posterior is Gaussian, $p ( \theta | \mathcal { D } ) = \mathcal { N } ( 0 , 1 )$ , and $\alpha = 0 . 0 5$ , then we have $\ell = \Phi ^ { - 1 } ( \alpha / 2 ) = - 1 . 9 6$ , and $u = \Phi ^ { - 1 } ( 1 - \alpha / 2 ) = 1 . 9 6$ , where $\Phi$ denotes the cdf of the Gaussian. This is illustrated in Figure 2.2b. This justifies the common practice of quoting a credible interval in the form of $\mu \pm 2 \sigma$ , where $\mu$ represents the posterior mean, $\sigma$ represents the posterior standard deviation, and 2 is a good approximation to 1.96.

In general, it is often hard to compute the inverse cdf of the posterior. In this case, a simple alternative is to draw samples from the posterior, and then to use a Monte Carlo approximation to the posterior quantiles: we simply sort the $S$ samples, and find the one that occurs at location $\alpha / S$ along the sorted list. As $S \to \infty$ , this converges to the true quantile. See beta_credible_int_demo.ipynb for a demo of this.

A problem with central intervals is that there might be points outside the central interval which have higher probability than points that are inside, as illustrated in Figure 4.18(a). This motivates an alternative quantity known as the highest posterior density or HPD region, which is the set of points which have a probability above some threshold. More precisely we find the threshold $p ^ { * }$ on

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

![](images/2d5189c1e95240906b854843720d04fc664b31b2369c77b0dac27bf5d5b60b79.jpg)  
Figure 4.18: (a) Central interval and (b) HPD region for a Beta(3,9) posterior. The $C I$ is (0.06, 0.52) and the HPD is (0.04, 0.48). Adapted from Figure 3.6 of [Hof09]. Generated by betaHPD.ipynb.

the pdf such that

$$
1 - \alpha = \int _ { \theta : p ( \theta | \mathcal { D } ) > p ^ { * } } p ( \theta | \mathcal { D } ) d \theta
$$

and then define the HPD as

$$
C _ { \alpha } ( { \mathcal { D } } ) = \{ \theta : p ( \theta | { \mathcal { D } } ) \geq p ^ { * } \}
$$

In 1d, the HPD region is sometimes called a highest density interval or HDI. For example, Figure 4.18(b) shows the 95% HDI of a $\mathrm { B e t a } ( 3 , 9 )$ distribution, which is (0.04, 0.48). We see that this is narrower than the central interval, even though it still contains $9 5 \%$ of the mass; furthermore, every point inside of it has higher density than every point outside of it.

For a unimodal distribution, the HDI will be the narrowest interval around the mode containing $9 5 \%$ of the mass. To see this, imagine “water filling” in reverse, where we lower the level until $9 5 \%$ of the mass is revealed, and only 5% is submerged. This gives a simple algorithm for computing HDIs in the 1d case: simply search over points such that the interval contains $9 5 \%$ of the mass and has minimal width. This can be done by 1d numerical optimization if we know the inverse CDF of the distribution, or by search over the sorted data points if we have a bag of samples (see betaHPD.ipynb for some code).

If the posterior is multimodal, the HDI may not even be a connected region: see Figure 4.19(b) for an example. However, summarizing multimodal posteriors is always difficult.

# 4.6.7 Bayesian machine learning

So far, we have focused on unconditional models of the form $p ( \pmb { y } | \pmb { \theta } )$ . In supervised machine learning, we use conditional models of the form $p ( \pmb { y } | \pmb { x } , \pmb \theta )$ . The posterior over the parameters is now $p ( \pmb { \theta } | \mathcal { D } )$ , where $\mathcal { D } = \{ ( \pmb { x } _ { n } , \pmb { y } _ { n } ) : n = 1 : N \}$ . Computing this posterior can be done using the principles we have already discussed. This approach is called Bayesian machine learning, since we are “being Bayesian” about the model parameters.

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

![](images/0e2b5af8a9cb5e7356cf1158bffa079bbd071ee7b48f6e40963d0393655b7f08.jpg)  
Figure 4.19: (a) Central interval and (b) HPD region for a hypothetical multimodal posterior. Adapted from Figure 2.2 of [Gel+04]. Generated by postDensityIntervals.ipynb.

# 4.6.7.1 Plugin approximation

Once we have computed the posterior over the parameters, we can compute the posterior predictive distribution over outputs given inputs by marginalizing out the unknown parameters:

$$
p ( \pmb { y } | \pmb { x } , \mathcal { D } ) = \int p ( \pmb { y } | \pmb { x } , \pmb { \theta } ) p ( \pmb { \theta } | \mathcal { D } ) d \pmb { \theta }
$$

Of course, computing this integral is often intractable. A very simple approximation is to assume there is just a single best model, $\hat { \pmb { \theta } }$ , such as the MLE. This is equivalent to approximating the posterior as an infinitely narrow, but infinitely tall, “spike” at the chosen value. We can write this as follows:

$$
p ( \pmb \theta | \mathcal { D } ) = \delta ( \pmb \theta - \hat { \pmb \theta } )
$$

where $\delta$ is the Dirac delta function (see Section 2.6.5). If we use this approximation, then the predictive distribution can be obtained by simply “plugging in” the point estimate into the likelihood:

$$
p ( \pmb { y } | \pmb { x } , \mathcal { D } ) = \int p ( \pmb { y } | \pmb { x } , \pmb { \theta } ) p ( \pmb { \theta } | \mathcal { D } ) d \pmb { \theta } \approx \int p ( \pmb { y } | \pmb { x } , \pmb { \theta } ) \delta ( \pmb { \theta } - \hat { \pmb { \theta } } ) d \pmb { \theta } = p ( \pmb { y } | \pmb { x } , \hat { \pmb { \theta } } )
$$

This follows from the sifting property of delta functions (Equation (2.129)).

The approach in Equation (4.197) is called a plug-in approximation. This approach is equivalent to the standard approach used in most of machine learning, in which we first fit the model (i.e. compute a point estimate $\hat { \pmb { \theta } }$ ) and then use it to make predicitons. However, the standard (plug-in) approach can suffer from overfitting and overconfidence, as we discussed in Section 1.2.3. The fully Bayesian approach avoids this by marginalizing out the parameters, but can be expensive. Fortunately, even simple approximations, in which we average over a few plausible parameter values, can improve performance. We give some examples of this below.

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

![](images/499c2459beda9db1b5e73770c7e338e0eea47c32f3bd55512888d03bf2db04dd.jpg)  
Figure 4.20: (a) Logistic regression for classifying if an Iris flower is Versicolor $\begin{array} { r } { \left. y = 1 \right. } \end{array}$ ) or setosa ( $\mathit { y } = 0$ ) using a single input feature x corresponding to sepal length. Labeled points have been (vertically) jittered to avoid overlapping too much. Vertical line is the decision boundary. Generated by logreg_iris_1d.ipynb. (b) Same as (a) but showing posterior distribution. Adapted from Figure 4.4 of [Mar18]. Generated by logreg_iris_bayes_1d_pymc3.ipynb.

# 4.6.7.2 Example: scalar input, binary output

Suppose we want to perform binary classification, so $y \in \{ 0 , 1 \}$ . We will use a model of the form

$$
p ( \boldsymbol { y } | \boldsymbol { x } ; \boldsymbol { \theta } ) = \mathrm { B e r } ( \boldsymbol { y } | \sigma ( \boldsymbol { w } ^ { \top } \boldsymbol { x } + b ) )
$$

where

$$
\sigma ( a ) \triangleq { \frac { e ^ { a } } { 1 + e ^ { a } } }
$$

is the sigmoid or logistic function which maps $\mathbb { R } \to [ 0 , 1 ]$ , and $\operatorname { B e r } ( y | \mu )$ is the Bernoulli distribution with mean $\mu$ (see Section 2.4 for details). In other words,

$$
p ( y = 1 | \mathbf { \boldsymbol { x } } ; \mathbf { \boldsymbol { \theta } } ) = \sigma ( \mathbf { \boldsymbol { w } } ^ { \mathsf { T } } \mathbf { \boldsymbol { x } } + b ) = \frac { 1 } { 1 + e ^ { - ( \mathbf { \boldsymbol { w } } ^ { \mathsf { T } } \mathbf { \boldsymbol { x } } + b ) } }
$$

This model is called logistic regression. (We discuss this in more detail in Chapter 10.)

Let us apply this model to the task of determining if an iris flower is of type Setosa or Versicolor, $y _ { n } \in \{ 0 , 1 \}$ , given information about the sepal length, $x _ { n }$ . (See Section 1.2.1.1 for a description of the iris dataset.)

We first fit a 1d logistic regression model of the following form

$$
p ( y = 1 | x ; \pmb \theta ) = \sigma ( b + w x )
$$

to the dataset $\mathcal { D } = \{ ( x _ { n } , y _ { n } ) \}$ using maximum likelihood estimation. (See Section 10.2.3 for details on how to compute the MLE for this model.) Figure 4.20a shows the plugin approximation to the

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

posterior predictive, $p ( y = 1 | x , \hat { \pmb { \theta } } )$ , where $\hat { \pmb { \theta } }$ is the MLE of the parameters. We see that we become more confident that the flower is of type Versicolor as the sepal length gets larger, as represented by the sigmoidal (S-shaped) logistic function.

The decision boundary is defined to be the input value $x ^ { * }$ where $p ( y = 1 | x ^ { * } ; \hat { \pmb \theta } ) = 0 . 5$ . We can solve for this value as follows:

$$
\begin{array} { c } { { \displaystyle \sigma ( b + w x ^ { * } ) = \frac { 1 } { 1 + e ^ { - ( b + w x ^ { * } ) } } = \frac { 1 } { 2 } } } \\ { { \displaystyle b + w x ^ { * } = 0 } } \\ { { \displaystyle x ^ { * } = - \frac { b } { w } } } \end{array}
$$

From Figure 4.20a, we see that $x ^ { * } \approx 5 . 5$ cm.

However, the above approach does not model the uncertainty in our estimate of the parameters, and therefore ignores the induced uncertainty in the output probabilities, and the location of the decision boundary. To capture this additional uncertainty, we can use a Bayesian approach to approximate the posterior $p ( \pmb { \theta } | \mathcal { D } )$ . (See Section 10.5 for details.) Given this, we can approximate the posterior predictive distribution using a Monte Carlo approximation:

$$
p ( y = 1 | x , \mathcal { D } ) \approx \frac { 1 } { S } \sum _ { s = 1 } ^ { S } p ( y = 1 | x , \pmb { \theta } ^ { s } )
$$

where $\theta ^ { s } \sim p ( \theta | \mathcal { D } )$ is a posterior sample. Figure 4.20b plots the mean and $9 5 \%$ credible interval of this function. We see that there is now a range of predicted probabilities for each input. We can also compute a distribution over the location of the decision boundary by using the Monte Carlo approximation

$$
p ( x ^ { * } | \mathcal { D } ) \approx \frac { 1 } { S } \sum _ { s = 1 } ^ { S } \delta \left( x ^ { * } - ( - \frac { b ^ { s } } { w ^ { s } } ) \right)
$$

where $( b ^ { s } , w ^ { s } ) = \pmb { \theta } ^ { s }$ . The $9 5 \%$ credible interval for this distribution is shown by the “fat” vertical line in Figure 4.20b.

Although carefully modeling our uncertainty may not matter for this application, it can be important in risk-sensitive applications, such as health care and finance, as we discuss in Chapter 5.

# 4.6.7.3 Example: binary input, scalar output

Now suppose we want to predict the delivery time for a package, $y \in \mathbb { R }$ , if shipped by company A vs B. We can encode the company id using a binary feature $x \in \{ 0 , 1 \}$ , where $x = 0$ means company A and $x = 1$ means company B. We will use the following discriminative model for this problem:

$$
p ( y | x , \pmb { \theta } ) = \mathcal { N } ( y | \mu _ { x } , \sigma _ { x } ^ { 2 } )
$$

where $\mathcal { N } ( y | \mu , \sigma ^ { 2 } )$ is the Gaussian distribution

$$
\mathcal { N } ( y | \mu , \sigma ^ { 2 } ) \triangleq \frac { 1 } { \sqrt { 2 \pi \sigma ^ { 2 } } } e ^ { - \frac { 1 } { 2 \sigma ^ { 2 } } ( y - \mu ) ^ { 2 } }
$$

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022 and $\pmb \theta = ( \mu _ { 0 } , \mu _ { 1 } , \sigma _ { 0 } , \sigma _ { 1 } )$ are the parameters of the model. We can fit this model using maximum likelihood estimation as we discuss in Section 4.2.5; alternatively, we can adopt a Bayesian approach, as we discuss in Section 4.6.4.

![](images/f442341dadb8085a9efb397d997ec3dbbfb8d0d76bcb07f3b26c1dd3b4d7ee08.jpg)  
Figure 4.21: Distribution of arrival times for two different shipping companies. ETA is the expected time of arrival. A’s distribution has greater uncertainty, and may be too risky. From https: // bit. ly/ 39bc4XL . Used with kind permission of Brendan Hasz.

The advantage of the Bayesian approach is that by capturing uncertainty in the parameters $\pmb \theta$ , we also capture uncertainty in our forecasts $p ( \boldsymbol { y } | \boldsymbol { x } , \mathcal { D } )$ , whereas using a plug-in approximation $p ( \boldsymbol { y } | \boldsymbol { x } , \hat { \pmb { \theta } } )$ would underestimate this uncertainty. For example, suppose we have only used each company once, so our training set has the form $\mathcal { D } = \{ ( x _ { 1 } = 0 , y _ { 1 } = 1 5 ,$ ), ( $x _ { 2 } = 1 , y _ { 2 } = 2 0 ) _ { . }$ . As we show in Section 4.2.5, the MLE for the means will be the empirical means, $\hat { \mu } _ { 0 } = 1 5$ and $\hat { \mu } _ { 1 } = 2 0$ , but the MLE for the standard deviations will be zero, $\hat { \sigma } _ { 0 } = \hat { \sigma } _ { 1 } = 0$ , since we only have a single sample from each “class”. The resulting plug-in prediction will therefore not capture any uncertainty.

To see why modeling the uncertainty is important, consider Figure 4.21. We see that the expected time of arrival (ETA) for company A is less than for company B; however, the variance of A’s distribution is larger, which makes it a risky choice if you want to be confident the package will arrive by the specified deadline. (For more details on how to choose optimal actions in the presence of uncertainty, see Chapter 5.)

Of course, the above example is extreme, because we assumed we only had one example from each delivery company. However, this kind of problem occurs whenever we have few examples of a given kind of input, as can happen whenever the data has a long tail of novel patterns, such as a new combination of words or categorical features.

# 4.6.7.4 Scaling up

The above examples were both extremely simple, involving 1d input and 1d output, and just 2–4 parameters. Most practical problems involve high dimensional inputs, and sometimes high dimensional outputs, and therefore use models with lots of parameters. Unfortunately, computing the posterior, $p ( \pmb { \theta } | \mathcal { D } )$ , and the posterior predictive, $p ( \pmb { y } | \pmb { x } , \mathcal { D } )$ , can be computationally challenging in such cases. We discuss this issue in Section 4.6.8.

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

![](images/c16a698eeb1bae6b6697918447cd641ff6ed2d356cedc850580a0f6b92999a93.jpg)  
Figure 4.22: Approximating the posterior of a beta-Bernoulli model. (a) Grid approximation using 20 grid points. (b) Laplace approximation. Generated by laplace_approx_beta_binom_jax.ipynb.

# 4.6.8 Computational issues

Given a likelihood $p ( \mathcal { D } | \mathbf { \theta } )$ and a prior $p ( \pmb \theta )$ , we can compute the posterior $p ( \pmb { \theta } | \mathcal { D } )$ using Bayes’ rule. However, actually performing this computation is usually intractable, except for simple special cases, such as conjugate models (Section 4.6.1), or models where all the latent variables come from a small finite set of possible values. We therefore need to approximate the posterior. There are a large variety of methods for performing approximate posterior inference, which trade off accuracy, simplicity, and speed. We briefly discuss some of these algorithms below, but go into more detail in the sequel to this book, [Mur23]. (See also [MFR20] for a review of various approximate inference methods, starting with Bayes’ original method in 1763.)

As a running example, we will use the problem of approximating the posterior of a beta-Bernoulli model. Specifically, the goal is to approximate

$$
p ( \theta | \mathcal { D } ) \propto \left[ \prod _ { n = 1 } ^ { N } \mathrm { B i n } ( y _ { n } | \theta ) \right] \mathrm { B e t a } ( \theta | 1 , 1 )
$$

where $\mathcal { D }$ consists of 10 heads and 1 tail (so the total number of observations is $N = 1 1$ ), and we use a uniform prior. Although we can compute this posterior exactly (see Figure 4.22), using the method discussed in Section 4.6.2, this serves as a useful pedagogical example since we can compare the approximation to the exact answer. Also, since the target distribution is just 1d, it is easy to visualize the results. (Note, however, that the problem is not completely trivial, since the posterior is highly skewed, due to the use of an imbalanced sample of 10 heads and 1 tail.)

# 4.6.8.1 Grid approximation

The simplest approach to approximate posterior inference is to partition the space of possible values for the unknowns into a finite set of possibilities, call them $\pmb { \theta } _ { 1 } , \ldots , \pmb { \theta } _ { K }$ , and then to approximate the posterior by brute-force enumeration, as follows:

$$
p ( \pmb \theta = \pmb \theta _ { k } | \mathcal D ) \approx \frac { p ( \mathcal D | \pmb \theta _ { k } ) p ( \pmb \theta _ { k } ) } { p ( \mathcal D ) } = \frac { p ( \mathcal D | \pmb \theta _ { k } ) p ( \pmb \theta _ { k } ) } { \sum _ { k ^ { \prime } = 1 } ^ { K } p ( \mathcal D , \pmb \theta _ { k ^ { \prime } } ) }
$$

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

This is called a grid approximation. In Figure 4.22a, we illustrate this method applied to our 1d problem. We see that it is easily able to capture the skewed posterior. Unfortunately, this approach does not scale to problems in more than 2 or 3 dimensions, because the number of grid points grows exponentially with the number of dimensions.

# 4.6.8.2 Quadratic (Laplace) approximation

In this section, we discuss a simple way to approximate the posterior using a multivariate Gaussian;   
this is known as a Laplace approximation or a quadratic approximation (see e.g., [TK86;   
RMC09]).

To derive this, suppose we write the posterior as follows:

$$
p ( \pmb \theta | \mathcal D ) = \frac { 1 } { Z } e ^ { - \mathcal E ( \pmb \theta ) }
$$

where $\mathcal { E } ( \pmb { \theta } ) = - \log p ( \pmb { \theta } , \mathcal { D } )$ is called an energy function, and $Z = p ( { \mathcal { D } } )$ is the normalization constant. Performing a Taylor series expansion around the mode $\hat { \pmb { \theta } }$ (i.e., the lowest energy state) we get

$$
\mathcal { E } ( \pmb { \theta } ) \approx \mathcal { E } ( \hat { \pmb { \theta } } ) + ( \pmb { \theta } - \hat { \pmb { \theta } } ) ^ { \top } \pmb { g } + \frac { 1 } { 2 } ( \pmb { \theta } - \hat { \pmb { \theta } } ) ^ { \top } \mathbf { H } ( \pmb { \theta } - \hat { \pmb { \theta } } )
$$

where $\pmb { g }$ is the gradient at the mode, and $\mathbf { H }$ is the Hessian. Since $\hat { \pmb { \theta } }$ is the mode, the gradient term is zero. Hence

$$
\begin{array} { c } { { \hat { p } ( \pmb { \theta } , \mathcal { D } ) = e ^ { - \mathcal { E } ( \hat { \pmb { \theta } } ) } \exp \left[ - \displaystyle \frac { 1 } { 2 } ( \pmb { \theta } - \hat { \pmb { \theta } } ) ^ { \top } \mathbf { H } ( \pmb { \theta } - \hat { \pmb { \theta } } ) \right] } } \\ { { \hat { p } ( \pmb { \theta } | \mathcal { D } ) = \displaystyle \frac { 1 } { Z } \hat { p } ( \pmb { \theta } , \mathcal { D } ) = \mathcal { N } ( \pmb { \theta } | \hat { \pmb { \theta } } , \mathbf { H } ^ { - 1 } ) } } \\ { { Z = e ^ { - \mathcal { E } ( \hat { \pmb { \theta } } ) } ( 2 \pi ) ^ { D / 2 } | \mathbf { H } | ^ { - \frac { 1 } { 2 } } } } \end{array}
$$

The last line follows from normalization constant of the multivariate Gaussian.

The Laplace approximation is easy to apply, since we can leverage existing optimization algorithms to compute the MAP estimate, and then we just have to compute the Hessian at the mode. (In high dimensional spaces, we can use a diagonal approximation.)

In Figure 4.22b, we illustrate this method applied to our 1d problem. Unfortunately we see that it is not a particularly good approximation. This is because the posterior is skewed, whereas a Gaussian is symmetric. In addition, the parameter of interest lies in the constrained interval $\theta \in [ 0 , 1 ]$ , whereas the Gaussian assumes an unconstrained space, $\pmb \theta \in \mathbb R$ . Fortunately, we can solve this latter problem by using a change of variable. For example, in this case we can apply the Laplace approximation to $\alpha = \log \mathrm { i t } ( \theta )$ . This is a common trick to simplify the job of inference.

# 4.6.8.3 Variational approximation

In Section 4.6.8.2, we discussed the Laplace approximation, which uses an optimization procedure to find the MAP estimate, and then approximates the curvature of the posterior at that point based on the Hessian. In this section, we discuss variational inference (VI), which is another optimization-based approach to posterior inference, but which has much more modeling flexibility (and thus can give a much more accurate approximation).

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

VI attempts to approximate an intractable probability distribution, such as $p ( \pmb { \theta } | \mathcal { D } )$ , with one that is tractable, $q ( \pmb \theta )$ , so as to minimize some discrepancy $D$ between the distributions:

$$
q ^ { * } = \underset { q \in \mathcal { Q } } { \operatorname { a r g m i n } } D ( q , p )
$$

where $\mathcal { Q }$ is some tractable family of distributions (e.g., multivariate Gaussian). If we define $D$ to be the KL divergence (see Section 6.2), then we can derive a lower bound to the log marginal likelihood; this quantity is known as the evidence lower bound or ELBO. By maximizing the ELBO, we can improve the quality of the posterior approximation. See the sequel to this book, [Mur23], for details.

# 4.6.8.4 Markov Chain Monte Carlo (MCMC) approximation

Although VI is a fast, optimization-based method, it can give a biased approximation to the posterior, since it is restricted to a specific function form $q \in \mathcal { Q }$ . A more flexible approach is to use a nonparametric approximation in terms of a set of samples, $\begin{array} { r } { q ( \pmb { \theta } ) \approx \frac { 1 } { S } \sum _ { s = 1 } ^ { S } \delta ( \pmb { \theta } - \pmb { \theta } ^ { s } ) } \end{array}$ . This is called a Monte Carlo approximation to the posterior. The key issue is how to create the posterior samples $\theta ^ { s } \sim p ( \theta | \mathcal { D } )$ efficiently, without having to evaluate the normalization constant $\begin{array} { r } { p ( \mathcal { D } ) = \int p ( \theta , \mathcal { D } ) d \theta } \end{array}$ . A common approach to this problem is known as Markov chain Monte Carlo or MCMC. If we augment this algorithm with gradient-based information, derived from $\nabla \log p ( \pmb \theta , \mathcal { D } )$ , we can significantly speed up the method; this is called Hamiltonian Monte Carlo or HMC. See the sequel to this book, [Mur23], for details.

# 4.7 Frequentist statistics \*

The approach to statistical inference that we described in Section 4.6 is called Bayesian statistics. It treats parameters of models just like any other unknown random variable, and applies the rules of probability theory to infer them from data. Attempts have been made to devise approaches to statistical inference that avoid treating parameters like random variables, and which thus avoid the use of priors and Bayes rule. This alternative approach is known as frequentist statistics, classical statistics or orthodox statistics.

The basic idea (formalized in Section 4.7.1) is to to represent uncertainty by calculating how a quantity estimated from data (such as a parameter or a predicted label) would change if the data were changed. It is this notion of variation across repeated trials that forms the basis for modeling uncertainty used by the frequentist approach. By contrast, the Bayesian approach views probability in terms of information rather than repeated trials. This allows the Bayesian to compute the probability of one-off events, as we discussed in Section 2.1.1. Perhaps more importantly, the Bayesian approach avoids certain paradoxes that plague the frequentist approach (see Section 4.7.5 and Section 5.5.4). These pathologies led the famous statistician George Box to say:

I believe that it would be very difficult to persuade an intelligent person that current [frequentist] statistical practice was sensible, but that there would be much less difficulty with an approach via likelihood and Bayes’ theorem. — George Box, 1962 (quoted in [Jay76]).

Nevertheless, it is useful to be familiar with frequentist statistics, since it is widely used, and has some key concepts that are useful even for Bayesians [Rub84].

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

# 4.7.1 Sampling distributions

In frequentist statistics, uncertainty is not represented by the posterior distribution of a random variable, but instead by the sampling distribution of an estimator. (We define these two terms below.)

As explained in the section on decision theory in Section 5.1, an estimator is a decision procedure that specifies what action to take given some observed data. In the context of parameter estimation, where the action space is to return a parameter vector, we will denote this by $\hat { \pmb { \theta } } = \pi ( \mathcal { D } )$ . For example, $\hat { \pmb { \theta } }$ could be the maximum likelihood estimate, the MAP estimate, or the method of moments estimate.

The sampling distribution of an estimator is the distribution of results we would see if we applied the estimator multiple times to different datasets sampled from some distribution; in the context of parameter estimation, it is the distribution of $\hat { \pmb { \theta } }$ , viewed as a random variable that depends on the random sample $\mathcal { D }$ . In more detail, imagine sampling $S$ different data sets, each of size $N$ , from some true model $p ( { \pmb x } | \pmb \theta ^ { * } )$ to generate

$$
\tilde { \mathcal { D } } ^ { ( s ) } = \{ \pmb { x } _ { n } \sim p ( \pmb { x } _ { n } | \pmb { \theta } ^ { * } ) : n = 1 : N \}
$$

We denote this by $\mathcal { D } ^ { ( s ) } \sim \theta ^ { * }$ for brevity. Now apply the estimator to each $\mathcal { D } ^ { ( s ) }$ to get a set of estimates, $\{ \hat { \pmb { \theta } } ( \mathcal { D } ^ { ( s ) } ) \}$ . As we let $S \to \infty$ , the distribution induced by this set is the sampling distribution of the estimator. More precisely, we have

$$
p ( \pi ( \tilde { \mathcal { D } } ) = \pmb { \theta } | \tilde { \mathcal { D } } \sim \pmb { \theta } ^ { * } ) \approx \frac { 1 } { S } \sum _ { s = 1 } ^ { S } \delta ( \pmb { \theta } = \pi ( \mathcal { D } ^ { ( s ) } ) )
$$

In some cases, we can compute this analytically, as we discuss in Section 4.7.2, although typically we need to approximate it by Monte Carlo, as we discuss in Section 4.7.3.

# 4.7.2 Gaussian approximation of the sampling distribution of the MLE

The most common estimator is the MLE. When the sample size becomes large, the sampling distribution of the MLE for certain models becomes Gaussian. This is known as the asymptotic normality of the sampling distribution. More formally, we have the following result:

Theorem 4.7.1. If the parameters are identifiable, then

$$
p ( \pi ( \tilde { \mathcal { D } } ) = \hat { \pmb { \theta } } | \tilde { \mathcal { D } } \sim \pmb { \theta } ^ { * } )  \mathcal { N } ( \hat { \pmb { \theta } } | \pmb { \theta } ^ { * } , ( N \mathbf { F } ( \pmb { \theta } ^ { * } ) ) ^ { - 1 } )
$$

where $\mathbf { F } ( \pmb \theta ^ { * } )$ is the Fisher information matrix, defined in Equation (4.220).

The Fisher information matrix measures the amount of curvature of the log-likelihood surface at its peak, as we show below.

More formally, the Fisher information matrix (FIM) is defined to be the covariance of the gradient of the log likelihood (also called the score function):

$$
\mathbf { F } \triangleq \mathbb { E } _ { \pmb { x } \sim p ( \pmb { x } | \pmb { \theta } ) } \left[ \nabla \log p ( \pmb { x } | \pmb { \theta } ) \nabla \log p ( \pmb { x } | \pmb { \theta } ) ^ { \top } \right]
$$

Hence the $( i , j )$ ’th entry has the form

$$
F _ { i j } = \mathbb { E } _ { \pmb { x } \sim \pmb { \theta } } \left[ \left( \frac { \partial } { \partial \theta _ { i } } \log p ( \pmb { x } | \pmb { \theta } ) \right) \left( \frac { \partial } { \partial \theta _ { j } } \log p ( \pmb { x } | \pmb { \theta } ) \right) \right]
$$

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

One can show the following result.

Theorem 4.7.2. If $\log p ( { \pmb x } | { \pmb \theta } )$ is twice differentiable, and under certain regularity conditions, the FIM is equal to the expected Hessian of the NLL, i.e.,

$$
\mathbf { F } _ { i j } = - \mathbb { E } _ { \pmb { x } \sim \pmb { \theta } } \left[ \frac { \partial ^ { 2 } } { \partial \theta _ { i } \theta _ { j } } \log p ( \pmb { x } | \pmb { \theta } ) \right]
$$

Thus we can interpret the FIM as the Hessian of the NLL.

This helps us understand the result in Equation (4.219): a log-likelihood function with high curvature (large Hessian) will result in a low variance estimate, since the parameters are “well determined” by the data, and hence robust to repeated sampling.

# 4.7.3 Bootstrap approximation of the sampling distribution of any estimator

In cases where the estimator is a complex function of the data (e.g., not just an MLE), or when the sample size is small, we can approximate its sampling distribution using a Monte Carlo technique known as the bootstrap.

The idea is simple. If we knew the true parameters $\theta ^ { * }$ , we could generate many (say $S$ ) fake datasets, each of size $N _ { \mathcal { D } }$ , from the true distribution, using ${ \tilde { \mathcal { D } } } ^ { ( s ) } = \{ \mathbf { x } _ { n } \sim p ( \mathbf { \boldsymbol { x } } _ { n } | \mathbf { \boldsymbol { \theta } } ^ { * } ) : n = 1 : N \}$ . We could then compute our estimate from each sample, $\hat { \pmb { \theta } } ^ { s } = \pi ( \tilde { \mathcal { D } } ^ { ( s ) } )$ and use the empirical distribution of the resulting $\hat { \pmb { \theta } } ^ { s }$ as our estimate of the sampling distribution, as in Equation (4.218). Since $\theta ^ { * }$ is unknown, the idea of the parametric bootstrap is to generate each sampled dataset using $ { \hat { \theta } } = \pi (  { D } )$ instead of $\pmb { \theta } ^ { * }$ , i.e., we use $\tilde { \mathcal { D } } ^ { ( s ) } = \{ \pmb { x } _ { n } \sim p ( \pmb { x } _ { n } | \hat { \pmb { \theta } } ) : n = 1 : N \}$ in Equation (4.218). This is a plug-in approximation to the sampling distribution.

The above approach requires that we have a parametric generative model for the data, $p ( { \boldsymbol { \mathbf { \mathit { x } } } } | \mathbf { \boldsymbol { \theta } } )$ . An alternative, called the non-parametric bootstrap, is to sample $N$ data points from the original dataset with replacement. This creates a new distribution $\mathcal { D } ^ { ( s ) }$ which has the same size as the original. However, the number of unique data points in a bootstrap sample is just $0 . 6 3 2 \times N$ , on average. (To see this, note that the probability an item is picked at least once is $( 1 - ( 1 - 1 / N ) ^ { N } )$ , which approaches $1 - e ^ { - 1 } \approx 0 . 6 3 2$ for large $N$ .)

Figure 4.23(a-b) shows an example where we compute the sampling distribution of the MLE for a Bernoulli using the parametric bootstrap. (Results using the non-parametric bootstrap are essentially the same.) When $N = 1 0$ , we see that the sampling distribution is asymmetric, and therefore quite far from Gaussian, but when $N _ { \mathit { D } } = 1 0 0$ , the distribution looks more Gaussian, as theory suggests (see Section 4.7.2).

# 4.7.3.1 Bootstrap is a “poor man’s” posterior

A natural question is: what is the connection between the parameter estimates $\hat { \pmb { \theta } } ^ { s } = \pi ( \mathcal { D } ^ { ( s ) } )$ computed by the bootstrap and parameter values sampled from the posterior, $\theta ^ { s } \sim p ( \cdot | \mathcal { D } )$ ? Conceptually they are quite different. But in the common case that the estimator is MLE and the prior is not very strong, they can be quite similar. For example, Figure 4.23(c-d) shows an example where we compute the posterior using a uniform Beta(1,1) prior, and then sample from it. We see that the posterior and the sampling distribution are quite similar. So one can think of the bootstrap distribution as a “poor man’s” posterior [HTF01, p235].

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

![](images/42c21f30bccb95558b605cfa6bf101ef8f501d70e6117e42feedec07a9632f2b.jpg)  
Figure 4.23: Bootstrap (top row) vs Bayes (bottom row). The $N$ data cases were generated from $\operatorname { B e r } ( \theta = 0 . 7 )$ . Left column: $N = 1 0$ . Right column: $N = 1 0 0$ . (a-b) $A$ bootstrap approximation to the sampling distribution of the MLE for a Bernoulli distribution. We show the histogram derived from $B = 1 0 , 0 0 0$ bootstrap samples. (c-d) Histogram of 10,000 samples from the posterior distribution using a uniform prior. Generated by bootstrapDemoBer.ipynb.

However, perhaps surprisingly, bootstrap can be slower than posterior sampling. The reason is that the bootstrap has to generate $S$ sampled datasets, and then fit a model to each one. By contrast, in posterior sampling, we only have to “fit” a model once given a single dataset. (Some methods for speeding up the bootstrap when applied to massive data sets are discussed in [Kle+11].)

# 4.7.4 Confidence intervals

In frequentist statistics, we use the variability induced by the sampling distribution as a way to estimate uncertainty of a parameter estimate. More precisely, we define a $1 0 0 ( 1 - \alpha ) \%$ confidence interval for a parameter estimate $\theta$ as any interval $I ( \tilde { \mathcal { D } } ) = ( \ell ( \tilde { \mathcal { D } } ) , u ( \tilde { \mathcal { D } } ) )$ derived from a hypothetical dataset $\ddot { \mathcal { D } }$ such that

$$
\mathrm { P r } ( \theta \in I ( \tilde { \mathcal { D } } ) | \tilde { \mathcal { D } } \sim \theta ) = 1 - \alpha
$$

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

It is common to set $\alpha = 0 . 0 5$ , which yields a 95% CI. This means that, if we repeatedly sampled data, and compute $I ( \tilde { \mathcal { D } } )$ for each such dataset, then about $9 5 \%$ of such intervals will contain the true parameter $\theta$ .

Note, however, that Equation (4.223) does not mean that for any particular dataset that $\theta \in I ( \mathcal { D } )$ with $9 5 \%$ probability; this is what a Bayesian credible interval computes (Section 4.6.6), but is not what a frequentist confidence interval computes. For more details on this important distinction, see Section 4.7.5.

Let us put aside such “philosophical” concerns, and discuss how to compute a confidence interval. Suppose that $\hat { \theta }$ is an estimate of the parameter $\theta$ . Let $\theta ^ { * }$ be its true but unknown value. Also, suppose that the sampling distribution of $\Delta = \widehat { \theta } - \theta ^ { * }$ is known. Let $\underline { { \delta } }$ and $\overline { { \delta } }$ denote its $\alpha / 2$ and $1 - \alpha / 2$ quantiles. Hence

$$
\operatorname* { P r } ( \underline { { \delta } } \ \leq \ \hat { \theta } - \theta ^ { * } \leq \overline { { \delta } } ) = 1 - \alpha
$$

Rearranging we get

$$
\operatorname* { P r } ( { \hat { \theta } } - { \overline { { \delta } } } \leq \theta ^ { * } \leq { \hat { \theta } } + \underline { { \delta } } ) = 1 - \alpha
$$

And hence

$$
I ( \tilde { \mathcal { D } } ) = ( \hat { \theta } ( \tilde { \mathcal { D } } ) - \overline { { \delta } } ( \tilde { \mathcal { D } } ) , \hat { \theta } ( \tilde { \mathcal { D } } ) + \underline { { \delta } } ( \tilde { \mathcal { D } } ) )
$$

is a $1 0 0 ( 1 - \alpha ) \%$ confidence interval.

In some cases, we can analytically compute the distribution of $\Delta = \hat { \theta } - \theta ^ { * }$ . This can be used to derive exact confidence intervals. However, it is more common to assume a Gaussian approximation to the sampling distribution, as in Section 4.7.2. In this case, we have $\sqrt { N F ( \hat { \theta } ) } ( \hat { \theta } - \theta ^ { * } ) \sim \mathcal { N } ( 0 , 1 )$ . Hence we can compute an approximate CI using

$$
\hat { \theta } \pm z _ { \alpha / 2 } \hat { \mathrm { s e } }
$$

where $z _ { \alpha / 2 }$ is the $\alpha / 2$ quantile of the Gaussian cdf, and $\hat { \mathrm { s e } } = { 1 } / { \sqrt { N F ( \hat { \theta } ) } }$ is the estimated standard error. If we set $\alpha = 0 . 0 5$ , we have $z _ { \alpha / 2 } = 1 . 9 6$ , which justifies the common approximation $\hat { \theta } \pm 2 \mathrm { s } \mathrm { \hat { e } }$ .

If the Gaussian approximation is not a good one, we can use a bootstrap approximation (see Section 4.7.3). In particular, we sample $S$ datasets from $ { \hat { \theta } } (  { \mathcal { D } } )$ , and apply the estimator to each one to get $\hat { \theta } ( \mathcal { D } ^ { ( s ) } )$ ; we then use the empirical distribution of $\hat { \theta } ( \mathcal { D } ) - \hat { \theta } ( \mathcal { D } ^ { ( s ) } )$ as an approximation to the sampling distribution of $\Delta$ .

# 4.7.5 Caution: Confidence intervals are not credible

A $9 5 \%$ frequentist confidence interval for a parameter $\theta$ is defined as any interval $I ( \tilde { \mathcal { D } } )$ such that $\operatorname* { P r } ( \theta \in I ( \tilde { \mathcal { D } } ) | \tilde { \mathcal { D } } \sim \theta ) = 0 . 9 5$ , as we explain in Section 4.7.4. This does not mean that the parameter is $9 5 \%$ likely to live inside this interval given the observed data. That quantity — which is usually what we want to compute — is instead given by the Bayesian credible interval $p ( \theta \in I | \mathcal { D } )$ , as we explain in Section 4.6.6. These concepts are quite different: In the frequentist approach, $\theta$ is treated as an unknown fixed constant, and the data is treated as random. In the Bayesian approach, we treat the data as fixed (since it is known) and the parameter as random (since it is unknown).

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

This counter-intuitive definition of confidence intervals can lead to bizarre results. Consider the following example from [Ber85, p11]. Suppose we draw two integers $\mathcal { D } = ( y _ { 1 } , y _ { 2 } )$ from

$$
p ( y | \theta ) = { \left\{ \begin{array} { l l } { 0 . 5 } & { { \mathrm { i f ~ } } y = \theta } \\ { 0 . 5 } & { { \mathrm { i f ~ } } y = \theta + 1 } \\ { 0 } & { { \mathrm { o t h e r w i s e } } } \end{array} \right. }
$$

If $\theta = 3 9$ , we would expect the following outcomes each with probability 0.25:

$$
( 3 9 , 3 9 ) , ( 3 9 , 4 0 ) , ( 4 0 , 3 9 ) , ( 4 0 , 4 0 )
$$

Let $m = \operatorname* { m i n } ( y _ { 1 } , y _ { 2 } )$ and define the following interval:

$$
[ \ell ( \mathcal { D } ) , u ( \mathcal { D } ) ] = [ m , m ]
$$

For the above samples this yields

Hence Equation (4.230) is clearly a $7 5 \%$ CI, since 39 is contained in $3 / 4$ of these intervals. However, if we observe $\mathcal { D } = ( 3 9 , 4 0 )$ then $p ( \theta = 3 9 | D ) = 1 . 0$ , so we know that $\theta$ must be 39, yet we only have $7 5 \%$ “confidence” in this fact. We see that the CI will “cover” the true parameter $7 5 \%$ of the time, if we compute multiple CIs from different randomly sampled datasets, but if we just have a single observed dataset, and hence a single CI, then the frequentist “coverage” probability can be very misleading.

Another, less contrived, example is as follows. Suppose we want to estimate the parameter $\theta$ of a Bernoulli distribution. Let $\begin{array} { r } { \overline { { y } } = \frac { 1 } { N _ { D } } \sum _ { n = 1 } ^ { N _ { D } } y _ { n } } \end{array}$ be the sample mean. The MLE is $\hat { \theta } = \overline { { y } }$ . An approximate $9 5 \%$ confidence interval for a Bernoulli parameter is $\overline { { y } } \pm 1 . 9 6 \sqrt { \overline { { y } } ( 1 - \overline { { y } } ) / N _ { D } }$ (this is called a Wald interval and is based on a Gaussian approximation to the Binomial distribution; compare to Equation (4.128)). Now consider a single trial, where $N _ { \mathcal { D } } = 1$ and $y _ { 1 } = 0$ . The MLE is 0, which overfits, as we saw in Section 4.5.1. But our $9 5 \%$ confidence interval is also $( 0 , 0 )$ , which seems even worse. It can be argued that the above flaw is because we approximated the true sampling distribution with a Gaussian, or because the sample size was too small, or the parameter “too extreme”. However, the Wald interval can behave badly even for large $N _ { \mathcal { D } }$ , and non-extreme parameters [BCD01]. By contrast, a Bayesian credible interval with a non-informative Jeffreys prior behaves in the way we would expect.

Several more interesting examples, along with Python code, can be found at [Van14]. See also [Hoe+14; Mor+16; Lyu+20; Cha+19b], who show that many people, including professional statisticians, misunderstand and misuse frequentist confidence intervals in practice, whereas Bayesian credible intervals do not suffer from these problems.

# 4.7.6 The bias-variance tradeoff

An estimator is a procedure applied to data which returns an estimand. Let $\hat { \pmb \theta } ( )$ be the estimator, and $ { \hat { \theta } } (  { \mathcal { D } } )$ be the estimand. In frequentist statistics, we treat the data as a random variable, drawn from some true but unknown distribution, $p ^ { * } ( \mathcal { D } )$ ; this induces a distribution over the estimand, $p ^ { * } ( \hat { \pmb { \theta } } ( { \mathcal { D } } ) )$ , known as the sampling distribution (see Section 4.7.1). In this section, we discuss two key properties of this distribution, its bias and its variance, which we define below.

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

# 4.7.6.1 Bias of an estimator

The bias of an estimator is defined as

$$
\mathrm { b i a s } ( \hat { \theta } ( \cdot ) ) \triangleq \mathbb { E } \left[ \hat { \theta } ( \mathcal { D } ) \right] - \theta ^ { * }
$$

where $\theta ^ { * }$ is the true parameter value, and the expectation is wrt “nature’s distribution” $p ( \mathcal { D } | \theta ^ { * } )$ . If the bias is zero, the estimator is called unbiased. For example, the MLE for a Gaussian mean is unbiased:

$$
\mathrm { b i a s } ( \hat { \mu } ) = \mathbb { E } \left[ \overline { { x } } \right] - \mu = \mathbb { E } \left[ \frac { 1 } { N _ { \mathcal { D } } } \sum _ { n = 1 } ^ { N _ { \mathcal { D } } } x _ { n } \right] - \mu = \frac { N _ { \mathcal { D } } \mu } { N _ { \mathcal { D } } } - \mu = 0
$$

where $\textstyle { \overline { { x } } }$ is the sample mean.

However, the MLE for a Gaussian variance, $\begin{array} { r } { \sigma _ { \mathrm { m l e } } ^ { 2 } = \frac { 1 } { N } \sum _ { n = 1 } ^ { N } ( x _ { n } - \overline { { x } } ) ^ { 2 } } \end{array}$ , is not an unbiased estimator of $\sigma ^ { 2 }$ . In fact, one can show (Exercise 4.7) that

$$
\mathbb { E } \left[ \sigma _ { \mathrm { m l e } } ^ { 2 } \right] = \frac { N _ { \mathcal { D } } - 1 } { N _ { \mathcal { D } } } \sigma ^ { 2 }
$$

so the ML estimator slightly underestimates the variance. Intuitively, this is because we “use up” one of the data points to estimate the mean, so if we have a sample size of 1, we will estimate the variance to be 0. If, however, $\mu$ is known, the ML estimator is unbiased (see Exercise 4.8).

Now consider the following estimator

$$
\sigma _ { \mathrm { u n b } } ^ { 2 } \triangleq \frac { 1 } { N _ { \mathscr { D } } - 1 } \sum _ { n = 1 } ^ { N _ { \mathscr { D } } } ( x _ { n } - \overline { { x } } ) ^ { 2 } = \frac { N _ { \mathscr { D } } } { N _ { \mathscr { D } } - 1 } \sigma _ { \mathrm { m l e } } ^ { 2 }
$$

This is an unbiased estimator, which we can easily prove as follows:

$$
\mathbb { E } \left[ \sigma _ { \mathrm { u n b } } ^ { 2 } \right] = \frac { N _ { \mathcal { D } } } { N _ { \mathcal { D } } - 1 } \mathbb { E } \left[ \sigma _ { \mathrm { m l e } } ^ { 2 } \right] = \frac { N _ { \mathcal { D } } } { N _ { \mathcal { D } } - 1 } \frac { N _ { \mathcal { D } } - 1 } { N _ { \mathcal { D } } } \sigma ^ { 2 } = \sigma ^ { 2 }
$$

# 4.7.6.2 Variance of an estimator

It seems intuitively reasonable that we want our estimator to be unbiased. However, being unbiased is not enough. For example, suppose we want to estimate the mean of a Gaussian from $\mathcal { D } =$ $\{ x _ { 1 } , \ldots , x _ { N _ { D } } \}$ . The estimator that just looks at the first data point, $\hat { \theta } ( \mathcal { D } ) = x _ { 1 }$ , is an unbiased estimator, but will generally be further from $\theta ^ { * }$ than the empirical mean $\textstyle { \overline { { x } } }$ (which is also unbiased). So the variance of an estimator is also important.

We define the variance of an estimator as follows:

$$
\mathbb { V } \left[ \boldsymbol { \hat { \theta } } \right] \triangleq \mathbb { E } \left[ \boldsymbol { \hat { \theta } } ^ { 2 } \right] - \left( \mathbb { E } \left[ \boldsymbol { \hat { \theta } } \right] \right) ^ { 2 }
$$

where the expectation is taken wrt $p ( \mathcal { D } | \theta ^ { * } )$ . This measures how much our estimate will change as the data changes. We can extend this to a covariance matrix for vector valued estimators.

Intuitively we would like the variance of our estimator to be as small as possible. Therefore, a natural question is: how low can the variance go? A famous result, called the Cramer-Rao lower

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022 bound, provides a lower bound on the variance of any unbiased estimator. More precisely, let $X _ { 1 } , \dots , X _ { N } \sim p ( X | \theta ^ { * } )$ and $\hat { \theta } = \hat { \theta } ( x _ { 1 } , \ldots , x _ { N } )$ be an unbiased estimator of $\theta ^ { * }$ . Then, under various smoothness assumptions on $p ( X | \theta ^ { * } )$ , we have $\begin{array} { r } { \bar { \boldsymbol { \gamma } } \left[ \hat { \boldsymbol { \theta } } \right] \geq \frac { 1 } { N F \left( \boldsymbol { \theta } ^ { * } \right) } } \end{array}$ , where $F ( \theta ^ { * } )$ is the Fisher information matrix (Section 4.7.2). A proof can be found e.g., in [Ric95, p275].

It can be shown that the MLE achieves the Cramer Rao lower bound, and hence has the smallest asymptotic variance of any unbiased estimator. Thus MLE is said to be asymptotically optimal.

# 4.7.6.3 The bias-variance tradeoff

In this section, we discuss a fundamental tradeoff that needs to be made when picking a method for parameter estimation, assuming our goal is to minimize the mean squared error (MSE) of our estimate. Let $ { \hat { \theta } } =  { \hat { \theta } } (  { \mathcal { D } } )$ denote the estimate, and $\overline { { \theta } } = \mathbb { E } \left[ \hat { \theta } \right]$ denote the expected value of the estimate (as we vary $\mathcal { D }$ ). (All expectations and variances are wrt $p ( \mathcal { D } | \theta ^ { * } )$ , but we drop the explicit conditioning for notational brevity.) Then we have

$$
\begin{array} { r l } & { \mathbb { E } \left[ ( \hat { \theta } - \theta ^ { * } ) ^ { 2 } \right] = \mathbb { E } \left[ \left[ ( \hat { \theta } - \bar { \theta } ) + ( \overline { { \theta } } - \theta ^ { * } ) \right] ^ { 2 } \right] } \\ & { \quad \quad \quad = \mathbb { E } \left[ \left( \hat { \theta } - \overline { { \theta } } \right) ^ { 2 } \right] + 2 ( \overline { { \theta } } - \theta ^ { * } ) \mathbb { E } \left[ \hat { \theta } - \overline { { \theta } } \right] + ( \overline { { \theta } } - \theta ^ { * } ) ^ { 2 } } \\ & { \quad \quad \quad = \mathbb { E } \left[ \left( \hat { \theta } - \overline { { \theta } } \right) ^ { 2 } \right] + ( \overline { { \theta } } - \theta ^ { * } ) ^ { 2 } } \\ & { \quad \quad \quad = \mathbb { V } \left[ \hat { \theta } \right] + \mathrm { b i a s } ^ { 2 } ( \hat { \theta } ) } \end{array}
$$

In words,

MSE = variance + bias2

This is called the bias-variance tradeoff (see e.g., [GBD92]). What it means is that it might be wise to use a biased estimator, so long as it reduces our variance by more than the square of the bias, assuming our goal is to minimize squared error.

# 4.7.6.4 Example: MAP estimator for a Gaussian mean

Let us give an example, based on [Hof09, p79]. Suppose we want to estimate the mean of a Gaussian from $\pmb { x } = ( x _ { 1 } , \dots , x _ { N _ { \mathcal { D } } } )$ . We assume the data is sampled from $x _ { n } \sim { \mathcal { N } } ( \theta ^ { * } = 1 , \sigma ^ { 2 } )$ . An obvious estimate is the MLE. This has a bias of 0 and a variance of

$$
\mathbb { V } \left[ \overline { { x } } | \theta ^ { * } \right] = \frac { \sigma ^ { 2 } } { N }
$$

But we could also use a MAP estimate. In Section 4.6.4.2, we show that the MAP estimate under a Gaussian prior of the form $\mathcal { N } ( \theta _ { 0 } , \sigma ^ { 2 } / \kappa _ { 0 } )$ is given by

$$
\tilde { x } \triangleq \frac { N _ { \mathscr { D } } } { N _ { \mathscr { D } } + \kappa _ { 0 } } \overline { { x } } + \frac { \kappa _ { 0 } } { N _ { \mathscr { D } } + \kappa _ { 0 } } \theta _ { 0 } = w \overline { { x } } + ( 1 - w ) \theta _ { 0 }
$$

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

![](images/b8d715f9ead1a198062a65658c80fbdcb9dbc405ce14488e7e1fe3d2103d3d99.jpg)  
Figure 4.24: Left: Sampling distribution of the MAP estimate (equivalent to the posterior mean) under a $\mathcal { N } ( \theta _ { 0 } = 0 , \sigma ^ { 2 } / \kappa _ { 0 } )$ prior with different prior strengths $\kappa _ { 0 }$ . (If we set $\kappa = 0$ , the MAP estimate reduces to the MLE.) The data is $n = 5$ samples drawn from $\mathcal { N } ( \theta ^ { * } = 1 , \sigma ^ { 2 } = 1 )$ ). Right: MSE relative to that of the MLE versus sample size. Adapted from Figure 5.6 of [Hof09]. Generated by samplingDistributionGaussianShrinkage.ipynb.

where $0 \leq w \leq 1$ controls how much we trust the MLE compared to our prior. The bias and variance are given by

$$
\begin{array} { c } { { \displaystyle \mathbb { E } \left[ \tilde { x } \right] - \theta ^ { * } = w \theta ^ { * } + ( 1 - w ) \theta _ { 0 } - \theta ^ { * } = ( 1 - w ) ( \theta _ { 0 } - \theta ^ { * } ) } } \\ { { \displaystyle \mathbb { V } \left[ \tilde { x } \right] = w ^ { 2 } \frac { \sigma ^ { 2 } } { N } } } \end{array}
$$

So although the MAP estimate is biased (assuming $w < 1$ ), it has lower variance.

Let us assume that our prior is slightly misspecified, so we use $\theta _ { 0 } = 0$ , whereas the truth is $\theta ^ { * } = 1$ . In Figure 4.24(a), we see that the sampling distribution of the MAP estimate for $\kappa _ { 0 } > 0$ is biased away from the truth, but has lower variance (is narrower) than that of the MLE.

In Figure 4.24(b), we plot $\mathrm { m s e } ( \tilde { x } ) / \mathrm { m s e } ( \overline { { x } } )$ vs $N$ . We see that the MAP estimate has lower MSE than the MLE for $\kappa _ { 0 } \in \{ 1 , 2 \}$ . The case $\kappa _ { 0 } = 0$ corresponds to the MLE, and the case $\kappa _ { 0 } = 3$ corresponds to a strong prior, which hurts performance because the prior mean is wrong. Thus we see that, provided the prior strength is properly “tuned”, a MAP estimate can outperform an ML estimate in terms of minimizing MSE.

# 4.7.6.5 Example: MAP estimator for linear regression

Another important example of the bias-variance tradeoff arises in ridge regression, which we discuss in Section 11.3. In brief, this corresponds to MAP estimation for linear regression under a Gaussian prior, $p ( \pmb { w } ) = \mathcal { N } ( \pmb { w } | \mathbf { 0 } , \lambda ^ { - 1 } \mathbf { I } )$ The zero-mean prior encourages the weights to be small, which reduces overfitting; the precision term, $\lambda$ , controls the strength of this prior. Setting $\lambda = 0$ results in the MLE; using $\lambda > 0$ results in a biased estimate. To illustrate the effect on the variance, consider a simple example where we fit a 1d ridge regression model using 2 different values of $\lambda$ . Figure 4.25 on

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022 the left plots each individual fitted curve, and on the right plots the average fitted curve. We see that as we increase the strength of the regularizer, the variance decreases, but the bias increases. See also Figure 4.26 where we give a cartoon sketch of the bias variance tradeoff in terms of model complexity.

![](images/124996f91ad42fb55f16b4cdeb416503abdb8e23870465f401d75fca7db25639.jpg)  
Figure 4.25: Illustration of bias-variance tradeoff for ridge regression. We generate 100 data sets from the true function, shown in solid green. Left: we plot the regularized fit for 20 different data sets. We use linear regression with a Gaussian RBF expansion, with 25 centers evenly spread over the [0, 1] interval. Right: we plot the average of the fits, averaged over all 100 datasets. Top row: strongly regularized: we see that the individual fits are similar to each other (low variance), but the average is far from the truth (high bias). Bottom row: lightly regularized: we see that the individual fits are quite different from each other (high variance), but the average is close to the truth (low bias). Adapted from [Bis06] Figure 3.5. Generated by biasVarModelComplexity3.ipynb.

# 4.7.6.6 Bias-variance tradeoff for classification

If we use 0-1 loss instead of squared error, the frequentist risk is no longer expressible as squared bias plus variance. In fact, one can show (Exercise 7.2 of [HTF09]) that the bias and variance combine multiplicatively. If the estimate is on the correct side of the decision boundary, then the bias is negative, and decreasing the variance will decrease the misclassification rate. But if the estimate is on the wrong side of the decision boundary, then the bias is positive, so it pays to increase the variance [Fri97a]. This little known fact illustrates that the bias-variance tradeoff is not very useful for classification. It is better to focus on expected loss, not directly on bias and variance. We can approximate the expected loss using cross validation, as we discuss in Section 4.5.5.

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

![](images/1245757605ab6cbbb31cee52fb45791b2a4971de530a8630b8ec15ea3dca72d4.jpg)  
Figure 4.26: Cartoon illustration of the bias variance tradeoff. From http: // scott. fortmann-roe. com/ docs/ BiasVariance. html . Used with kind permission of Scott Fortmann-Roe.

# 4.8 Exercises

Exercise 4.1 [MLE for the univariate Gaussian \*] Show that the MLE for a univariate Gaussian is given by

$$
\begin{array} { l } { \displaystyle { \hat { \mu } = \frac { 1 } { N } \sum _ { n = 1 } ^ { N } y _ { n } } } \\ { \displaystyle { \hat { \sigma } ^ { 2 } = \frac { 1 } { N } \sum _ { n = 1 } ^ { N } ( y _ { n } - \hat { \mu } ) ^ { 2 } } } \end{array}
$$

Exercise 4.2 [MAP estimation for 1D Gaussians $^ *$ ]

(Source: Jaakkola.)

Consider samples $x _ { 1 } , \ldots , x _ { n }$ from a Gaussian random variable with known variance $\sigma ^ { 2 }$ and unknown mean $\mu$ . We further assume a prior distribution (also Gaussian) over the mean, $\mu \sim \mathcal N ( m , s ^ { 2 } )$ , with fixed mean $m$ and fixed variance $s ^ { 2 }$ . Thus the only unknown is $\mu$ .

a. Calculate the MAP estimate $\hat { \mu } _ { M A P }$ . You can state the result without proof. Alternatively, with a lot more work, you can compute derivatives of the log posterior, set to zero and solve.   
b. Show that as the number of samples $n$ increase, the MAP estimate converges to the maximum likelihood estimate.   
c. Suppose $n$ is small and fixed. What does the MAP estimator converge to if we increase the prior variance $s ^ { 2 }$ ?   
d. Suppose $n$ is small and fixed. What does the MAP estimator converge to if we decrease the prior variance $s ^ { 2 }$ ?

Exercise 4.3 [Gaussian posterior credible interval]

(Source: DeGroot.) Let $X \sim \mathcal { N } ( \mu , \sigma ^ { 2 } = 4 )$ where $\mu$ is unknown but has prior $\mu \sim \mathcal N ( \mu _ { 0 } , \sigma _ { 0 } ^ { 2 } = 9 _ { , }$ ). The posterior after seeing $n$ samples is $\mu \sim \mathcal N ( \mu _ { n } , \sigma _ { n } ^ { 2 } )$ . (This is called a credible interval, and is the Bayesian analog of a confidence interval.) How big does $n$ have to be to ensure

$$
p ( \ell \leq \mu _ { n } \leq u | D ) \geq 0 . 9 5
$$

where $( \ell , u )$ is an interval (centered on $\mu _ { n }$ ) of width 1 and $D$ is the data? Hint: recall that $9 5 \%$ of the probability mass of a Gaussian is within $\pm 1 . 9 6 \sigma$ of the mean.

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

Exercise 4.4 [BIC for Gaussians $^ * ]$

(Source: Jaakkola.)

The Bayesian information criterion (BIC) is a penalized log-likelihood function that can be used for model selection. It is defined as

$$
B I C = \log p ( \mathcal { D } | \hat { \pmb { \theta } } _ { M L } ) - \frac { d } { 2 } \log ( N )
$$

where $d$ is the number of free parameters in the model and $N$ is the number of samples. In this question, we will see how to use this to choose between a full covariance Gaussian and a Gaussian with a diagonal covariance. Obviously a full covariance Gaussian has higher likelihood, but it may not be “worth” the extra parameters if the improvement over a diagonal covariance matrix is too small. So we use the BIC score to choose the model.

We can write

$$
{ \boldsymbol { \cdot } } { \boldsymbol { p } } ( { \mathcal { D } } | { \hat { \mathbf { \Sigma } } } , { \hat { \boldsymbol { \mu } } } ) = - { \frac { N } { 2 } } \mathrm { t r } \left( { \hat { \mathbf { \Sigma } } } ^ { - 1 } { \hat { \mathbf { S } } } \right) - { \frac { N } { 2 } } \log ( | { \hat { \mathbf { \Sigma } } } | )
$$

where $\hat { \bf S }$ is the scatter matrix (empirical covariance), the trace of a matrix is the sum of its diagonals, and we have used the trace trick.

a. Derive the BIC score for a Gaussian in $\mathcal { D }$ dimensions with full covariance matrix. Simplify your answer as much as possible, exploiting the form of the MLE. Be sure to specify the number of free parameters $d$ .   
b. Derive the BIC score for a Gaussian in $D$ dimensions with a diagonal covariance matrix. Be sure to specify the number of free parameters $d$ . Hint: for the digaonal case, the ML estimate of $\pmb { \Sigma }$ is the same as $\hat { \mathbf { \Sigma } } _ { \hat { \mathbf { Z } } _ { M L } }$ except the off-diagonal terms are zero:

$$
\hat { \Sigma } _ { d i a g } = { \mathrm { d i a g } } ( \hat { \Sigma } _ { M L } ( 1 , 1 ) , \dots , \hat { \Sigma } _ { M L } ( D , D ) )
$$

Exercise 4.5 [BIC for a 2d discrete distribution] (Source: Jaakkola.)

Let $x \in \{ 0 , 1 \}$ denote the result of a coin toss ( $x = 0$ for tails, $x = 1$ for heads). The coin is potentially biased, so that heads occurs with probability $\theta _ { 1 }$ . Suppose that someone else observes the coin flip and reports to you the outcome, $y$ . But this person is unreliable and only reports the result correctly with probability $\theta _ { 2 }$ ; i.e., $p ( \boldsymbol { y } | \boldsymbol { x } , \theta _ { 2 } )$ is given by

$$
\left. \begin{array} { c c } { { y = 0 } } & { { y = 1 } } \\ { { x = 0 } } & { { \theta _ { 2 } \ } } \\ { { x = 1 } } & { { \left| \begin{array} { l l } { { 1 - \theta _ { 2 } } } & { { 1 - \theta _ { 2 } } } \\ { { 1 - \theta _ { 2 } } } & { { \theta _ { 2 } } } \end{array} \right. } } \end{array} \right.
$$

Assume that $\theta _ { 2 }$ is independent of $x$ and $\theta _ { 1 }$ .

a. Write down the joint probability distribution $p ( x , y | \pmb \theta )$ as a $2 \times 2$ table, in terms of $\pmb { \theta } = ( \theta _ { 1 } , \theta _ { 2 } )$ . b. Suppose have the following dataset: $\pmb { x } = ( 1 , 1 , 0 , 1 , 1 , 0 , 0 )$ , $\pmb { y } = ( 1 , 0 , 0 , 0 , 1 , 0 , 1 )$ . What are the MLEs for $\theta _ { 1 }$ and $\theta _ { 2 }$ ? Justify your answer. Hint: note that the likelihood function factorizes,

$$
p ( x , y | \pmb { \theta } ) = p ( y | x , \theta _ { 2 } ) p ( x | \theta _ { 1 } )
$$

What is $p ( \mathcal { D } | \widehat { \pmb { \theta } } , M _ { 2 } )$ where $M _ { 2 }$ denotes this 2-parameter model? (You may leave your answer in fractional form if you wish.)

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

c. Now consider a model with 4 parameters, $\pmb { \theta } = ( \theta _ { 0 , 0 } , \theta _ { 0 , 1 } , \theta _ { 1 , 0 } , \theta _ { 1 , 1 } )$ , representing $p ( x , y | \pmb { \theta } ) = \theta _ { x , y }$ . (Only 3 of these parameters are free to vary, since they must sum to one.) What is the MLE of $\pmb \theta$ ? What is $p ( \mathcal { D } | \hat { \pmb { \theta } } , M _ { 4 } )$ where $M _ { 4 }$ denotes this 4-parameter model?

d. Suppose we are not sure which model is correct. We compute the leave-one-out cross validated log likelihood of the 2-parameter model and the 4-parameter model as follows:

$$
L ( m ) = \sum _ { i = 1 } ^ { n } \log p ( x _ { i } , y _ { i } | m , \hat { \theta } ( \mathcal { D } _ { - i } ) )
$$

and $\widehat { \theta } \big ( \mathcal { D } _ { - i } \big ) \Big )$ ) denotes the MLE computed on $\mathcal { D }$ excluding row $i$ . Which model will CV pick and why? Hint: notice how the table of counts changes when you omit each training case one at a time.

e. Recall that an alternative to CV is to use the BIC score, defined as

$$
\operatorname { B I C } ( M , { \mathcal { D } } ) \triangleq \log p ( { \mathcal { D } } | \hat { \pmb { \theta } } _ { M L E } ) - { \frac { \operatorname { d o f } ( M ) } { 2 } } \log N _ { \mathcal { D } }
$$

where $\operatorname* { d o f } ( M )$ is the number of free parameters in the model, Compute the BIC scores for both models (use log base $e$ ). Which model does BIC prefer?

Exercise 4.6 [A mixture of conjugate priors is conjugate \*] Consider a mixture prior

$$
p ( \theta ) = \sum _ { k } p ( h = k ) p ( \theta | z = k )
$$

where each $p ( \theta | z = k )$ is conjugate to the likelihood. Prove that this is a conjugate prior.

Exercise 4.7 [ML estimator $\sigma _ { \mathrm { m l e } } ^ { 2 }$ is biased]

Show that $\begin{array} { r } { \hat { \sigma } _ { M L E } ^ { 2 } = \frac { 1 } { N } \sum _ { n = 1 } ^ { N } ( x _ { n } - \hat { \mu } ) ^ { 2 } } \end{array}$ is a biased estimator of $\sigma ^ { 2 }$ , i.e., show

$$
\mathbf { E } _ { \mathrm { X _ { 1 } } , \ldots , \mathrm { X _ { n } } \sim \mathcal { N } ( \mu , \sigma ) } [ \hat { \sigma } ^ { 2 } ( \mathrm { X _ { 1 } } , \ldots , \mathrm { X _ { n } } ) ] \neq \sigma ^ { 2 }
$$

Hint: note that $X _ { 1 } , \ldots , X _ { N }$ are independent, and use the fact that the expectation of a product of independent random variables is the product of the expectations.

Exercise 4.8 [Estimation of $\sigma ^ { 2 }$ when $\mu$ is known $^ *$ ]

Suppose we sample $x _ { 1 } , \dots , x _ { N } \sim { \mathcal { N } } ( \mu , \sigma ^ { 2 } )$ where $\mu$ is a known constant. Derive an expression for the MLE for $\sigma ^ { 2 }$ in this case. Is it unbiased?

Exercise 4.9 [Variance and MSE of estimators for Gaussian variance $^ *$ ] Prove that the standard error for the MLE for a Gaussian variance is

$$
\sqrt { \mathbb { V } \left[ \sigma _ { \mathrm { m l e } } ^ { 2 } \right] } = \sqrt { \frac { 2 ( N - 1 ) } { N ^ { 2 } } } \sigma ^ { 2 }
$$

Hint: use the fact that

$$
{ \frac { N - 1 } { \sigma ^ { 2 } } } \sigma _ { \mathrm { u n b } } ^ { 2 } \sim \chi _ { N - 1 } ^ { 2 } ,
$$

and that $\mathbb { V } \left\lfloor \chi _ { N - 1 } ^ { 2 } \right\rfloor = 2 ( N - 1 )$ . Finally, show that $\begin{array} { r } { \mathrm { M S E } ( \sigma _ { \mathrm { u n b } } ^ { 2 } ) = \frac { 2 N - 1 } { N ^ { 2 } } \sigma ^ { 4 } } \end{array}$ and $\begin{array} { r } { \mathrm { M S E } ( \sigma _ { \mathrm { m l e } } ^ { 2 } ) = \frac { 2 } { N - 1 } \sigma ^ { 4 } } \end{array}$ .

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

# 5 Decision Theory

# 5.1 Bayesian decision theory

Bayesian inference provides the optimal way to update our beliefs about hidden quantities $H$ given observed data $\mathbf { X } = { \boldsymbol { x } }$ by computing the posterior $p ( H | \pmb { x } )$ . However, at the end of the day, we need to turn our beliefs into actions that we can perform in the world. How can we decide which action is best? This is where Bayesian decision theory comes in. In this chapter, we give a brief introduction. For more details, see e.g., [DeG70; KWW22].

# 5.1.1 Basics

In decision theory, we assume the decision maker, or agent, has a set of possible actions, $\mathcal { A }$ , to choose from. For example, consider the case of a hypothetical doctor treating someone who may have COVID-19. Suppose the actions are to do nothing, or to give the patient an expensive drug with bad side effects, but which can save their life.

Each of these actions has costs and benefits, which will depend on the underlying state of nature $H \in { \mathcal { H } }$ . We can encode this information into a loss function $\ell ( h , a )$ , that specifies the loss we incur if we take action $a \in { \mathcal { A } }$ when the state of nature is $h \in \mathcal { H }$ .

For example, suppose the state is defined by the age of the patient (young vs old), and whether they have COVID-19 or not. Note that the age can be observed directly, but the disease state must be inferred from noisy observations, as we discussed in Section 2.3. Thus the state is partially observed.

Let us assume that the cost of administering a drug is the same, no matter what the state of the patient is. However, the benefits will differ. If the patient is young, we expect them to live a long time, so the cost of not giving the drug if they have COVID-19 is high; but if the patient is old, they have fewer years to live, so the cost of not giving the drug if they have COVID-19 is arguably less (especially in view of the side effects). In medical circles, a common unit of cost is quality-adjusted life years or QALY. Suppose that the expected QALY for a young person is 60, and for an old person is 10. Let us assume the drug costs the equivalent of 8 QALY, due to induced pain and suffering from side effects. Then we get the loss matrix shown in Table 5.1.

These numbers reflect relative costs and benefits, and will depend on many factors. The numbers can be derived by asking the decision maker about their preferences about different possible outcomes. It is a theorem of decision theory that any consistent set of preferences can be converted into an ordinal cost scale (see e.g., https://en.wikipedia.org/wiki/Preference_(economics)).

Once we have specified the loss function, we can compute the posterior expected loss or risk

Table 5.2: Optimal policy for treating COVID-19 patients for each possible observation.   

<html><body><table><tr><td>State</td><td>Nothing</td><td>Drugs</td></tr><tr><td>No COVID-19, young</td><td>0</td><td>8</td></tr><tr><td>COVID-19, young</td><td>60</td><td>8</td></tr><tr><td>No COVID-19, old</td><td>0</td><td>8</td></tr><tr><td>COVID-19, old</td><td>10</td><td>8</td></tr></table></body></html>

Table 5.1: Hypothetical loss matrix for a decision maker, where there are 4 states of nature, and 2 possible actions.   

<html><body><table><tr><td>test</td><td>age</td><td>pr(covid)</td><td>cost-noop</td><td>cost-drugs</td><td>action</td></tr><tr><td>0</td><td>0</td><td>0.01</td><td>0.84</td><td>8.00</td><td>0</td></tr><tr><td>0</td><td>1</td><td>0.01</td><td>0.14</td><td>8.00</td><td>0</td></tr><tr><td>1</td><td>0</td><td>0.80</td><td>47.73</td><td>8.00</td><td>1</td></tr><tr><td>1</td><td>1</td><td>0.80</td><td>7.95</td><td>8.00</td><td>0</td></tr></table></body></html>

for each possible action:

$$
R ( a | \pmb { x } ) \triangleq \mathbb { E } _ { p ( h | \pmb { x } ) } \left[ \ell ( h , a ) \right] = \sum _ { h \in \mathcal { H } } \ell ( h , a ) p ( h | \pmb { x } )
$$

The optimal policy (also called the Bayes estimator) specifies what action to take for each possible observation so as to minimize the risk:

$$
\pi ^ { * } ( \pmb { x } ) = \underset { \ b { a } \in \mathcal { A } } { \mathrm { a r g m i n } } \mathbb { E } _ { p ( h | \pmb { x } ) } \left[ \ell ( h , \pmb { a } ) \right]
$$

An alternative, but equivalent, way of stating this result is as follows. Let us define a utility function $U ( h , a )$ to be the desirability of each possible action in each possible state. If we set $U ( h , a ) = - \ell ( h , a )$ , then the optimal policy is as follows:

$$
\pi ^ { * } ( \pmb { x } ) = \underset { \ b { a } \in \mathcal { A } } { \mathrm { a r g m a x } } \mathbb { E } _ { h } \left[ U ( h , a ) \right]
$$

This is called the maximum expected utility principle.

Let us return to our COVID-19 example. The observation $_ { x }$ consists of the age (young or old) and the test result (positive or negative). Using the results from Section 2.3.1 on Bayes rule for COVID-19 diagnosis, we can convert the test result into a distribution over disease states (i.e., compute the probability the patient has COVID-19 or not). Given this belief state, and the loss matrix in Table 5.1, we can compute the optimal policy for each possible observation, as shown in Table 5.2.

We see from Table 5.2 that the drug should only be given to young people who test positive. If, however, we reduce the cost of the drug from 8 units to 5, then the optimal policy changes: in this case, we should give the drug to everyone who tests positive. The policy can also change depending on the reliability of the test. For example, if we increase the sensitivity from 0.875 to 0.975, then

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022 the probability that someone has COVID-19 if they test positive increases from 0.80 to 0.81, which changes the optimal policy to be one in which we should administer the drug to everyone who tests positive, even if the drug costs 8 QALY. (See dtheory.ipynb for the code to reproduce this example.) So far, we have implicitly assumed that the agent is risk neutral. This means that their decision is not affected by the degree of certainty in a set of outcomes. For example, such an agent would be indifferent between getting \$50 for sure, or a $5 0 \%$ chance of $\$ 100$ or $\$ 0$ . By contrast, a risk averse agent would choose the first. We can generalize the framework of Bayesian decision theory to risk sensitive applications, but we do not pursue the matter here. (See e.g., [Cho+15] for details.)

# 5.1.2 Classification problems

In this section, we use Bayesian decision theory to decide the optimal class label to predict given an observed input $\mathbf { \boldsymbol { x } } \in \mathcal { X }$ .

# 5.1.2.1 Zero-one loss

Suppose the states of nature correspond to class labels, so $\mathcal { H } = \mathcal { Y } = \{ 1 , . . . , C \}$ . Furthermore, suppose the actions also correspond to class labels, so $\mathcal { A } = \mathcal { y }$ . In this setting, a very commonly used loss function is the zero-one loss $\ell _ { 0 1 } ( y ^ { * } , \hat { y } )$ , defined as follows:

$$
\begin{array} { c }  { | \begin{array} { l l l } { { \hat { y } = 0 } } & { { \hat { y } = 1 } } & { { } } \\ { { \begin{array} { c c c } { { | \begin{array} { l } { { 0 } } & { { 1 } } \\ { { 1 } } & { { 0 } } \end{array} | } } } \end{array} } } \end{array} \end{array}
$$

We can write this more concisely as follows:

$$
\ell _ { 0 1 } ( y ^ { \ast } , \hat { y } ) = \mathbb { I } \left( y ^ { \ast } \neq \hat { y } \right)
$$

In this case, the posterior expected loss is

$$
R ( \hat { y } | x ) = p ( \hat { y } \neq y ^ { \ast } | x ) = 1 - p ( y ^ { \ast } = \hat { y } | x )
$$

Hence the action that minimizes the expected loss is to choose the most probable label:

$$
\pi ( \pmb { x } ) = \underset { \pmb { y } \in \mathcal { Y } } { \operatorname { a r g m a x } } p ( \pmb { y } | \pmb { x } )
$$

This corresponds to the mode of the posterior distribution, also known as the maximum a posteriori or MAP estimate.

# 5.1.2.2 Cost-sensitive classification

Consider a binary classification problem where the loss function is $\ell ( y ^ { * } , \hat { y } )$ is as follows:

$$
\left( \begin{array} { l l } { \ell _ { 0 0 } } & { \ell _ { 0 1 } } \\ { \ell _ { 1 0 } } & { \ell _ { 1 1 } } \end{array} \right)
$$

Let $p _ { 0 } = p ( y ^ { \ast } = 0 | x )$ and $p _ { 1 } = 1 - p _ { 0 }$ . Thus we should choose label $\hat { y } = 0$ iff

$$
\ell _ { 0 0 } p _ { 0 } + \ell _ { 1 0 } p _ { 1 } < \ell _ { 0 1 } p _ { 0 } + \ell _ { 1 1 } p _ { 1 }
$$

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

If $\ell _ { 0 0 } = \ell _ { 1 1 } = 0$ , this simplifies to

$$
p _ { 1 } < \frac { \ell _ { 0 1 } } { \ell _ { 0 1 } + \ell _ { 1 0 } }
$$

Now suppose $\ell _ { 1 0 } = c \ell _ { 0 1 }$ , so a false negative costs $c$ times more than a false positive. The decision rule further simplifies to the following: pick $a = 0$ iff $p _ { 1 } < 1 / ( 1 + c )$ . For example, if a false negative costs twice as much as false positive, so $c = 2$ , then we use a decision threshold of $1 / 3$ before declaring a positive.

# 5.1.2.3 Classification with the “reject” option

In some cases, we may able to say “I don’t know” instead of returning an answer that we don’t really trust; this is called picking the reject option (see e.g., [BW08]). This is particularly important in domains such as medicine and finance where we may be risk averse.

We can formalize the reject option as follows. Suppose the states of nature are $\mathcal { H } = \mathcal { Y } = \{ 1 , . . . , C \}$ , and the actions are $\mathcal { A } = \mathcal { V } \cup \{ 0 \}$ , where action 0 represents the reject action. Now define the following loss function:

$$
\ell ( y ^ { * } , a ) = \left. \begin{array} { c c } { 0 } & { \mathrm { i f } y ^ { * } = a \mathrm { a n d } a \in \{ 1 , \ldots , C \} } \\ { \lambda _ { r } } & { \mathrm { i f } a = 0 } \\ { \lambda _ { e } } & { \mathrm { o t h e r w i s e } } \end{array} \right.
$$

where $\lambda _ { r }$ is the cost of the reject action, and $\lambda _ { e }$ is the cost of a classification error. Exercise 5.1 asks you to show that the optimal action is to pick the reject action if the most probable class has a probability below $\begin{array} { r } { \lambda ^ { * } = 1 - \frac { \lambda _ { r } } { \lambda _ { e } } } \\ { . . } \end{array}$ ; otherwise you should just pick the most probable class. In other words, the optimal policy is as follows:

$$
a ^ { * } = { \left\{ \begin{array} { l l } { y ^ { * } } & { { \mathrm { i f ~ } } p ^ { * } > \lambda ^ { * } } \\ { { \mathrm { r e j e c t } } } & { { \mathrm { o t h e r w i s e } } } \end{array} \right. }
$$

where

$$
\begin{array} { l l } { { y ^ { * } = \underset { y \in \{ 1 , \ldots , C \} } { \mathrm { a r g m a x } } p ( y | x ) } } \\ { { p ^ { * } = p ( y ^ { * } | x ) = \underset { y \in \{ 1 , \ldots , C \} } { \mathrm { m a x } } p ( y | x ) } } \\ { { \lambda ^ { * } = 1 - \displaystyle \frac { \lambda _ { r } } { \lambda _ { e } } } } \end{array}
$$

See Figure 5.1 for an illustration.

One interesting application of the reject option arises when playing the TV game show Jeopardy. In this game, contestants have to solve various word puzzles and answer a variety of trivia questions, but if they answer incorrectly, they lose money. In 2011, IBM unveiled a computer system called Watson which beat the top human Jeopardy champion. Watson uses a variety of interesting techniques [Fer+10], but the most pertinent one for our present discussion is that it contains a module that estimates how confident it is of its answer. The system only chooses to “buzz in” its answer if sufficiently confident it is correct.

For some other methods and applications, see e.g., [Cor+16; GEY19].

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

![](images/111261af6dd2a4840a88a37c0078a9d7d3c379fbf801889a9f24c7720f79c1cf.jpg)  
Figure 5.1: For some regions of input space, where the class posteriors are uncertain, we may prefer not to choose class 1 or 2; instead we may prefer the reject option. Adapted from Figure 1.26 of [Bis06].

<html><body><table><tr><td></td><td colspan="2">Estimate 0 1</td><td>Row sum</td></tr><tr><td>0 Truth 1</td><td>TN FP FN</td><td></td><td>N P</td></tr><tr><td>Col. sum</td><td>N</td><td>TP P</td><td></td></tr></table></body></html>

Table 5.3: Class confusion matrix for a binary classification problem. TP is the number of true positives, $F P$ is the number of false positives, TN is the number of true negatives, FN is the number of false negatives, $P$ is the true number of positives, $\hat { P }$ is the predicted number of positives, $N$ is the true number of negatives, $\hat { N }$ is the predicted number of negatives.

# 5.1.3 ROC curves

In Section 5.1.2.2, we showed that we can pick the optimal label in a binary classification problem by thresholding the probability using a value $\tau$ , derived from the relative cost of a false positive and false negative. Instead of picking a single threshold, we can consider using a set of different thresholds, and comparing the resulting performance, as we discuss below.

# 5.1.3.1 Class confusion matrices

For any fixed threshold $\tau$ , we consider the following decision rule:

$$
\hat { y } _ { \tau } ( \pmb { x } ) = \mathbb { I } \left( p ( y = 1 | \pmb { x } ) \geq 1 - \tau \right)
$$

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

Table 5.4: Class confusion matrix for a binary classification problem normalized per row to get $p ( \hat { y } | y )$ . Abbreviations: TNR = true negative rate, Spec = specificity, $F P R = f a l s e$ positive rate, FNR = false negative rate, Miss = miss rate, TPR = true positive rate, Sens = sensitivity. Note FNR=1-TPR and $F P R { = } I { - } T N R$ .   

<html><body><table><tr><td></td><td colspan="2">Estimate 1</td></tr><tr><td>0 Truth 1</td><td>0 TN/N=TNR=Spec FN/P=FNR=Miss=Type II</td><td>FP/N =FPR=TypeI= Fallout TP/P=TPR=Sens=Recall</td></tr></table></body></html>

Table 5.5: Class confusion matrix for a binary classification problem normalized per column to get $p ( y | \hat { y } )$ . Abbreviations: $N P V = n$ egative predictive value, FDR = false discovery rate, $F O R = f a l s e$ omission rate, PPV = positive predictive value, Prec = precision. Note that FOR=1-NPV and FDR=1-PPV.   

<html><body><table><tr><td></td><td>Estimate 0 1</td></tr><tr><td>0 Truth</td><td>TN/N=NPV FP/P=FDR</td></tr><tr><td>1</td><td>FN/N=FOR TP/P=Prec=PPV</td></tr></table></body></html>

We can compute the empirical number of false positives (FP) that arise from using this policy on a set of $N$ labeled examples as follows:

$$
F P _ { \tau } = \sum _ { n = 1 } ^ { N } \mathbb { I } \left( \hat { y } _ { \tau } ( \pmb { x } _ { n } ) = 1 , y _ { n } = 0 \right)
$$

Similarly, we can compute the empirical number of false negatives (FN), true positives (TP), and true negatives (TN). We can store these results in a $2 \times 2$ class confusion matrix $C$ , where $C _ { i j }$ is the number of times an item with true class label $i$ was (mis)classified as having label $j$ . In the case of binary classification problems, the resulting matrix will look like Table 5.3.

From this table, we can compute $p ( \hat { y } | y )$ or $p ( y | \hat { y } )$ , depending on whether we normalize across the rows or columns. We can derive various summary statistics from these distributions, as summarized in Table 5.4 and Table 5.5. For example, the true positive rate (TPR), also known as the sensitivity, recall or hit rate, is defined as

$$
T P R _ { \tau } = p ( \hat { y } = 1 | y = 1 , \tau ) = \frac { T P _ { \tau } } { T P _ { \tau } + F N _ { \tau } }
$$

and the false positive rate (FPR), also called the false alarm rate, or the type I error rate, is defined as

$$
F P R _ { \tau } = p ( \hat { y } = 1 | y = 0 , \tau ) = \frac { F P _ { \tau } } { F P _ { \tau } + T N _ { \tau } }
$$

We can now plot the TPR vs FPR as an implicit function of $\tau$ . This is called a receiver operating characteristic or ROC curve. See Figure 5.2(a) for an example.

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

![](images/400c5ba45c77aa561b2baf9bdef74b12e7a934843c7b35e18dedb2790dbf6253.jpg)  
Figure 5.2: (a) ROC curves for two hypothetical classification systems. The red curve for system $A$ is better than the blue curve for system B. We plot the true positive rate (TPR) vs the false positive rate (FPR) as we vary the threshold $ { \gamma }$ . We also indicate the equal error rate (EER) with the red and blue dots, and the area under the curve (AUC) for classifier B by the shaded area. Generated by roc_plot.ipynb. (b) A precision-recall curve for two hypothetical classification systems. The red curve for system A is better than the blue curve for system B. Generated by pr_plot.ipynb.

# 5.1.3.2 Summarizing ROC curves as a scalar

The quality of a ROC curve is often summarized as a single number using the area under the curve or AUC. Higher AUC scores are better; the maximum is obviously 1. Another summary statistic that is used is the equal error rate or EER, also called the cross-over rate, defined as the value which satisfies FPR = FNR. Since FNR $\circeq$ 1-TPR, we can compute the EER by drawing a line from the top left to the bottom right and seeing where it intersects the ROC curve (see points A and B in Figure 5.2(a)). Lower EER scores are better; the minimum is obviously 0 (corresponding to the top left corner).

# 5.1.3.3 Class imbalance

In some problems, there is severe class imbalance. For example, in information retrieval, the set of negatives (irrelevant items) is usually much larger than the set of positives (relevant items). The ROC curve is unaffected by class imbalance, as the TPR and FPR are fractions within the positives and negatives, respectively. However, the usefulness of an ROC curve may be reduced in such cases, since a large change in the absolute number of false positives will not change the false positive rate very much, since FPR is divided by FP+TN (see e.g., [SR15] for discussion). Thus all the “action” happens in the extreme left part of the curve. In such cases, we may choose to use other ways of summarizing the class confusion matrix, such as precision-recall curves, which we discuss in Section 5.1.4.

# 5.1.4 Precision-recall curves

In some problems, the notion of a “negative” is not well-defined. For example, consider detecting objects in images: if the detector works by classifying patches, then the number of patches examined and hence the number of true negatives — is a parameter of the algorithm, not part of the problem definition. Similarly, information retrieval systems usually get to choose the initial set of candidate

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license items, which are then ranked for relevance; by specifying a cutoff, we can partition this into a positive and negative set, but note that the size of the negative set depends on the total number of items retrieved, which is an algorithm parameter, not part of the problem specification.

In these kinds of situations, we may choose to use a precision-recall curve to summarize the performance of our system, as we explain below. (See [DG06] for a more detailed discussion of the connection between ROC curves and PR curves.)

# 5.1.4.1 Computing precision and recall

The key idea is to replace the FPR with a quantity that is computed just from positives, namely the precision:

$$
\mathcal { P } ( \tau ) \triangleq p ( y = 1 | \hat { y } = 1 , \tau ) = \frac { T P _ { \tau } } { T P _ { \tau } + F P _ { \tau } }
$$

The precision measures what fraction of our detections are actually positive. We can compare this to the recall (which is the same as the TPR), which measures what fraction of the positives we actually detected:

$$
\mathcal { R } ( \tau ) \triangleq p ( \hat { y } = 1 | y = 1 , \tau ) = \frac { T P _ { \tau } } { T P _ { \tau } + F N _ { \tau } }
$$

If $\hat { y } _ { n } \in \{ 0 , 1 \}$ is the predicted label, and $y _ { n } \in \{ 0 , 1 \}$ is the true label, we can estimate precision and recall using

$$
\begin{array} { l } { \displaystyle \mathcal { P } ( \tau ) = \frac { \sum _ { n } y _ { n } \hat { y } _ { n } } { \sum _ { n } \hat { y } _ { n } } } \\ { \displaystyle \mathcal { R } ( \tau ) = \frac { \sum _ { n } y _ { n } \hat { y } _ { n } } { \sum _ { n } y _ { n } } } \end{array}
$$

We can now plot the precision vs recall as we vary the threshold $\tau$ . See Figure 5.2(b). Hugging the top right is the best one can do.

# 5.1.4.2 Summarizing PR curves as a scalar

The PR curve can be summarized as a single number in several ways. First, we can quote the precision for a fixed recall level, such as the precision of the first $K = 1 0$ entities recalled. This is called the precision at $\mathbf { K }$ score. Alternatively, we can compute the area under the PR curve. However, it is possible that the precision does not drop monotonically with recall. For example, suppose a classifier has $9 0 \%$ precision at $1 0 \%$ recall, and $9 6 \%$ precision at $2 0 \%$ recall. In this case, rather than measuring the precision at a recall of $1 0 \%$ , we should measure the maximum precision we can achieve with at least a recall of $1 0 \%$ (which would be $9 6 \%$ ). This is called the interpolated precision. The average of the interpolated precisions is called the average precision; it is equal to the area under the interpolated PR curve, but may not be equal to the area under the raw PR curve.1 The mean average precision or mAP is the mean of the AP over a set of different PR curves.

# 5.1.4.3 F-scores

For a fixed threshold, corresponding to a single point on the PR curve, we can compute a single precision and recall value, which we will denote by $\mathcal { P }$ and $\mathcal { R }$ . These are often combined into a single statistic called the $F _ { \beta }$ , defined as follows:2

$$
\frac { 1 } { F _ { \beta } } = \frac { 1 } { 1 + \beta ^ { 2 } } \frac { 1 } { \mathcal { P } } + \frac { \beta ^ { 2 } } { 1 + \beta ^ { 2 } } \frac { 1 } { \mathcal { R } }
$$

or equivalently

$$
F _ { \beta } \triangleq ( 1 + \beta ^ { 2 } ) \frac { \mathscr { P } \cdot \mathscr { R } } { \beta ^ { 2 } \mathscr { P } + \mathscr { R } } = \frac { ( 1 + \beta ^ { 2 } ) T P } { ( 1 + \beta ^ { 2 } ) T P + \beta ^ { 2 } F N + F P }
$$

If we set $\beta = 1$ , we get the harmonic mean of precision and recall:

$$
\begin{array} { l } { \displaystyle \frac { 1 } { F _ { 1 } } = \frac { 1 } { 2 } \left( \frac { 1 } { \mathcal { P } } + \frac { 1 } { \mathcal { R } } \right) } \\ { \displaystyle F _ { 1 } = \frac { 2 } { 1 / \mathcal { R } + 1 / \mathcal { P } } = 2 \frac { \mathcal { P } \cdot \mathcal { R } } { \mathcal { P } + \mathcal { R } } = \frac { T P } { T P + \frac { 1 } { 2 } \left( F P + F N \right) } } \end{array}
$$

To understand why we use the harmonic mean instead of the arithmetic mean, $( \mathcal { P } + \mathcal { R } ) / 2$ , consider the following scenario. Suppose we recall all entries, so ${ \hat { y } } _ { n } = 1$ for all $n$ , and $\mathcal { R } = 1$ . In this case, the precision $\mathcal { P }$ will be given by the prevalence, $\begin{array} { r } { p ( y = 1 ) = \frac { \sum _ { n } \mathbb { I } ( y _ { n } = 1 ) } { N } } \end{array}$ . Suppose the prevalence is low, say $p ( y = 1 ) = 1 0 ^ { - 4 }$ . The arithmetic mean of $\mathcal { P }$ and $\mathcal { R }$ is given by $( \mathcal { P } + \mathcal { R } ) / 2 = ( 1 0 ^ { - 4 } + 1 ) / 2 \approx 5 0 \%$ . By contrast, the harmonic mean of this strategy is only $\frac { 2 \times 1 0 ^ { - 4 } \times 1 } { 1 + 1 0 ^ { - 4 } } \approx 0 . 0 2 \%$ . In general, the harmonic mean is more conservative, and requires both precision and recall to be high.

Using $F _ { 1 }$ score weights precision and recall equally. However, if recall is more important, we may use $\beta = 2$ , and if precision is more important, we may use $\beta = 0 . 5$ .

# 5.1.4.4 Class imbalance

ROC curves are insensitive to class imbalance, but PR curves are not, as noted in [Wil20]. To see this, let the fraction of positives in the dataset be $\pi = P / ( P + N )$ , and define the ratio $r = P / N = \pi / ( 1 - \pi )$ . Let $n = P + N$ be the population size. ROC curves are not affected by changes in $r$ , since the TPR is defined as a ratio within the positive examples, and FPR is defined as a ratio within the negative examples. This means it does not matter which class we define as positive, and which we define as negative.

Now consider PR curves. The precision can be written as

$$
\mathrm { P r e c } = { \frac { T P } { T P + F P } } = { \frac { P \cdot T P R } { P \cdot T P R + N \cdot F P R } } = { \frac { T P R } { T P R + { \frac { 1 } { r } } F P R } }
$$

Thus $\mathrm { P r e c }  1$ as $\pi  1$ and $r  \infty$ , and $\mathrm { P r e c }  0$ as $\pi  0$ and $r  0$ . For example, if we change from a balanced problem where $r = 0 . 5$ to an imbalanced problem where $r = 0 . 1$ (so positives are rarer), the precision at each threshold will drop, and the recall (aka TPR) will stay the same, so the overall PR curve will be lower. Thus if we have multiple binary problems with different prevalences (e.g., object detection of common or rare objects), we should be careful when averaging their precisions [HCD12].

The F-score is also affected by class imbalance. To see this, note that we can rewrite the F-score as follows:

$$
{ \begin{array} { l } { { \cfrac { 1 } { F _ { \beta } } } = { \cfrac { 1 } { 1 + \beta ^ { 2 } } } { \cfrac { 1 } { \mathcal { P } } } + { \cfrac { \beta ^ { 2 } } { 1 + \beta ^ { 2 } } } { \cfrac { 1 } { \mathcal { R } } } } \\ { = { \cfrac { 1 } { 1 + \beta ^ { 2 } } } { \cfrac { T P R + { \frac { N } { P } } F P R } { T P R } } + { \cfrac { \beta ^ { 2 } } { 1 + \beta ^ { 2 } } } { \cfrac { 1 } { T P R } } } \\ { F _ { \beta } = { \cfrac { ( 1 + \beta ^ { 2 } ) T P R } { T P R + { \frac { 1 } { r } } F P R + \beta ^ { 2 } } } } \end{array} }
$$

# 5.1.5 Regression problems

So far, we have considered the case where there are a finite number of actions $\mathcal { A }$ and states of nature $\mathcal { H }$ . In this section, we consider the case where the set of actions and states are both equal to the real line, $\mathcal { A } = \mathcal { H } = \mathbb { R }$ . We will specify various commonly used loss functions for this case (which can be extended to $\mathbb { R } ^ { D }$ by computing the loss elementwise.) The resulting decision rules can be used to compute the optimal parameters for an estimator to return, or the optimal action for a robot to take, etc.

# 5.1.5.1 L2 loss

The most common loss for continuous states and actions is the $\ell _ { 2 }$ loss, also called squared error or quadratic loss, which is defined as follows:

$$
\ell _ { 2 } ( h , a ) = ( h - a ) ^ { 2 }
$$

In this case, the risk is given by

$$
R ( a | \pmb { x } ) = \mathbb { E } \left[ ( h - a ) ^ { 2 } | \pmb { x } \right] = \mathbb { E } \left[ h ^ { 2 } | \pmb { x } \right] - 2 a \mathbb { E } \left[ h | \pmb { x } \right] + a ^ { 2 }
$$

The optimal action must satisfy the condition that the derivative of the risk (at that point) is zero (as explained in Chapter 8). Hence the optimal action is to pick the posterior mean:

$$
{ \frac { \partial } { \partial a } } R ( a | \mathbf { x } ) = - 2 \mathbb { E } \left[ h | \mathbf { x } \right] + 2 a = 0 ~ \Rightarrow ~ \pi ( \pmb { x } ) = \mathbb { E } \left[ h | \pmb { x } \right] = \int h ~ p ( h | \pmb { x } ) d h
$$

This is often called the minimum mean squared error estimate or MMSE estimate.

# 5.1.5.2 L1 loss

The $\ell _ { 2 }$ loss penalizes deviations from the truth quadratically, and thus is sensitive to outliers. A more robust alternative is the absolute or $\ell _ { 1 }$ loss

$$
\ell _ { 1 } ( h , a ) = | h - a |
$$

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

![](images/91078cb052c8cf5f8b1f821b89e76066ff466db59b8978d4cff4f8893e7c7e6e.jpg)  
Figure 5.3: Illustration of $\ell _ { 2 }$ , $\ell _ { 1 }$ , and Huber loss functions with $\delta = 1 . 5$ . Generated by huberLossPlot.ipynb.

This is sketched in Figure 5.3. Exercise 5.4 asks you to show that the optimal estimate is the posterior median, i.e., a value $a$ such that $\operatorname* { P r } ( h < a | \pmb { x } ) = \operatorname* { P r } ( h \geq a | \pmb { x } ) = 0 . 5$ . We can use this for robust regression as discussed in Section 11.6.1.

# 5.1.5.3 Huber loss

Another robust loss function is the Huber loss [Hub64], defined as follows:

$$
\ell _ { \delta } ( h , a ) = { \left\{ \begin{array} { l l } { \qquad r ^ { 2 } / 2 } & { { \mathrm { i f ~ } } | r | \leq \delta } \\ { \delta | r | - \delta ^ { 2 } / 2 } & { { \mathrm { i f ~ } } | r | > \delta } \end{array} \right. }
$$

where $r = h - a$ . This is equivalent to $\ell _ { 2 }$ for errors that are smaller than $\delta$ , and is equivalent to $\ell _ { 1 }$ for larger errors. See Figure 5.3 for a plot. We can use this for robust regression as discussed in Section 11.6.3.

# 5.1.6 Probabilistic prediction problems

In Section 5.1.2, we assumed the set of possible actions was to pick a single class label (or possibly the “reject” or “do not know” action). In Section 5.1.5, we assumed the set of possible actions was to pick a real valued scalar. In this section, we assume the set of possible actions is to pick a probability distribution over some value of interest. That is, we want to perform probabilistic prediction or probabilistic forecasting, rather than predicting a specific value. More precisely, we assume the true “state of nature” is a distribution, $h = p ( Y | x )$ , the action is another distribution, $a = q ( Y | x )$ , and we want to pick $q$ to minimize $\mathbb { E } \left[ \ell ( p , q ) \right]$ for a given $x$ . We discuss various possible loss functions below.

# 5.1.6.1 KL, cross-entropy and log-loss

A common form of loss functions for comparing two distributions is the Kullback Leibler divergence, or KL divergence, which is defined as follows:

$$
D _ { \mathbb { K L } } \left( p \parallel q \right) \triangleq \sum _ { y \in y } p ( y ) \log \frac { p ( y ) } { q ( y ) }
$$

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license (We have assumed the variable $y$ is discrete, for notational simplicity, but this can be generalized to real-valued variables.) In Section 6.2, we show that the KL divergence satisfies the following properties: $D _ { \mathbb { K L } } \left( p \parallel q \right) \ge 0$ with equality iff $p = q$ . Note that it is an asymmetric function of its arguments.

We can expand the KL as follows:

$$
\begin{array} { l } { { \displaystyle D _ { \mathbb { K L } } ( p \| q ) = \sum _ { y \in \mathcal { V } } p ( y ) \log p ( y ) - \sum _ { y \in \mathcal { V } } p ( y ) \log q ( y ) \ ~ } } \\ { { \displaystyle ~ = - \mathbb { H } ( p ) + \mathbb { H } _ { c e } ( p , q ) } } \\ { { \displaystyle ~ \mathbb { H } ( p ) \triangleq - \sum _ { y } p ( y ) \log p ( y ) \ ~ } } \\ { { \displaystyle \mathbb { H } _ { c e } ( p , q ) \triangleq - \sum _ { y } p ( y ) \log q ( y ) } } \end{array}
$$

The $\mathbb H ( p )$ term is known as the entropy. This is a measure of uncertainty or variance of $p$ ; it is maximal if $p$ is uniform, and is 0 if $p$ is a degenerate or deterministic delta function. Entropy is often used in the field of information theory, which is concerned with optimal ways of compressing and communicating data (see Chapter 6). The optimal coding scheme will allocate fewer bits to more frequent symbols (i.e., values of $Y$ for which $p ( y )$ is large), and more bits to less frequent symbols. A key result states that the number of bits needed to compress a dataset generated by a distribution $p$ is at least $\mathbb { H } ( p )$ ; the entropy therefore provides a lower bound on the degree to which we can compress data without losing information. The $\mathbb { H } _ { c e } ( p , q )$ term is known as the cross-entropy. This measures the expected number of bits we need to use to compress a dataset coming from distribution $p$ if we design our code using distribution $q$ . Thus the KL is the extra number of bits we need to use to compress the data due to using the incorrect distribution $q$ . If the KL is zero, it means that we can correctly predict the probabilities of all possible future events, and thus we have learned to predict the future as well as an “oracle” that has access to the true distribution $p$ .

To find the optimal distribution to use when predicting future data, we can minimize $D _ { \mathbb { K L } } \left( p \parallel q \right)$ . Since $\mathbb H ( p )$ is a constant wrt $q$ , it can be ignored, and thus we can equivalently minimize the cross-entropy:

$$
\boldsymbol { q } ^ { * } ( Y | \boldsymbol { x } ) = \underset { \boldsymbol { q } } { \mathrm { a r g m i n } } \mathbb { H } _ { c e } ( \boldsymbol { q } ( Y | \boldsymbol { x } ) , p ( Y | \boldsymbol { x } ) )
$$

Now consider the special case in which the true state of nature is a degenerate distribution, which puts all its mass on a single outcome, say $c$ , i.e., $h = p ( Y | x ) = \mathbb { I } \left( Y = c \right)$ . This is often called a “one-hot” distribution, since it turns “on” the $c$ ’th element of the vector, and leaves the other elements “off”, as shown in Figure 2.1. In this case, the cross entropy becomes

$$
\mathbb { H } _ { c e } ( \delta ( Y = c ) , q ) = - \sum _ { y \in \mathcal { Y } } \delta ( y = c ) \log q ( y ) = - \log q ( c )
$$

This is known as the log loss of the predictive distribution $q$ when given target label $c$ .

# 5.1.6.2 Proper scoring rules

Cross-entropy loss is a very common choice for probabilistic forecasting, but is not the only possible metric. The key property we desire is that the loss function is minimized iff the decision maker picks

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

the distribution $q$ that matches the true distribution $p$ , i.e., $\ell ( p , p ) \leq \ell ( p , q )$ , with equality iff $p = q$ .   
Such a loss function $\ell$ is called a proper scoring rule [GR07].

We can show that cross-entropy loss is a proper scoring rule by virtue of the fact that $D _ { \mathbb { K L } } \left( p \parallel p \right) \leq$ $D _ { \mathbb { K L } } \left( p \parallel q \right)$ . However, the $\log p ( \boldsymbol { y } ) / q ( \boldsymbol { y } )$ term can be quite sensitive to errors for low probability events [QC+06]. A common alternative is to use the Brier score [Bri50], which is defined as follows (for a discrete distribution with $C$ values):

$$
\ell ( p , q ) \triangleq { \frac { 1 } { C } } \sum _ { c = 1 } ^ { C } ( q ( y = c | x ) - p ( y = c | x ) ) ^ { 2 }
$$

This is just the squared error of the predictive distribution compared to the true distribution, when viewed as vectors. Since it is based on squared error, the Brier score is less sensitive to extremely rare or extremely common classes. Fortunately, it is also a proper scoring rule.

# 5.2 Choosing the “right” model

In this section, we consider the setting in which we have several candidate (parametric) models (e.g., neural networks with different numbers of layers), and we want to choose the “right” one. This can be tackled using tools from Bayesian decision theory.

# 5.2.1 Bayesian hypothesis testing

Suppose we have two hypotheses or models, commonly called the null hypothesis, $M _ { 0 }$ , and the alternative hypothesis, $M _ { 1 }$ , and we want to know which one is more likely to be true. This is called hypothesis testing.

If we use 0-1 loss, the optimal decision is to pick the alternative hypothesis iff $p ( M _ { 1 } | \mathcal { D } ) > p ( M _ { 0 } | \mathcal { D } )$ , or equivalently, if $p ( M _ { 1 } | \mathcal { D } ) / p ( M _ { 0 } | \mathcal { D } ) > 1$ . If we use a uniform prior, $p ( M _ { 0 } ) = p ( M _ { 1 } ) = 0 . 5$ , the decision rule becomes: select $M _ { 1 }$ iff $p ( { \mathcal { D } } | M _ { 1 } ) / p ( { \mathcal { D } } | M _ { 0 } ) > 1$ . This quantity, which is the ratio of marginal likelihoods of the two models, is known as the Bayes factor:

$$
B _ { 1 , 0 } \triangleq { \frac { p ( D | M _ { 1 } ) } { p ( D | M _ { 0 } ) } }
$$

This is like a likelihood ratio, except we integrate out the parameters, which allows us to compare models of different complexity, due to the Bayesian Occam’s razor effect explained in Section 5.2.3. If $B _ { 1 , 0 } > 1$ then we prefer model 1, otherwise we prefer model 0. Of course, it might be that $\boldsymbol { B } _ { 1 , 0 }$ is only slightly greater than 1. In that case, we are not very confident that model 1 is better. Jeffreys [Jef61] proposed a scale of evidence for interpreting the magnitude of a Bayes factor, which is shown in Table 5.6. This is a Bayesian alternative to the frequentist concept of a p-value (see Section 5.5.3). We give a worked example of how to compute Bayes factors in Section 5.2.1.1.

# 5.2.1.1 Example: Testing if a coin is fair

As an example, suppose we observe some coin tosses, and want to decide if the data was generated by a fair coin, $\theta = 0 . 5$ , or a potentially biased coin, where $\theta$ could be any value in $\lfloor 0 , 1 \rfloor$ . Let us denote

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

<html><body><table><tr><td>Bayes factor BF(1,0)</td><td>Interpretation</td></tr><tr><td>BF<100 BF<1</td><td>Decisive evidence for Mo Strong evidence for Mo</td></tr><tr><td>1 <BF<1 3</td><td>Moderate evidence for Mo</td></tr><tr><td>10 ↓<BF<1</td><td></td></tr><tr><td>1<BF<3</td><td>Weak evidence for Mo</td></tr><tr><td>3<BF<10</td><td>Weak evidence for M1</td></tr><tr><td>BF>10</td><td>Moderate evidence for M1</td></tr><tr><td></td><td>Strong evidence for M1</td></tr><tr><td>BF>100</td><td>Decisive evidence for M1</td></tr></table></body></html>

![](images/72d3e1a4f2c69bc3b4cd5f11505fe078a25f15b92b0e552ed92e894e588a49de.jpg)  
Table 5.6: Jeffreys scale of evidence for interpreting Bayes factors.   
Figure 5.4: (a) Log marginal likelihood vs number of heads for the coin tossing example. (b) BIC approximation. (The vertical scale is arbitrary, since we are holding N fixed.) Generated by coins_model_sel_demo.ipynb.

the first model by $M _ { 0 }$ and the second model by $M _ { 1 }$ . The marginal likelihood under $M _ { 0 }$ is simply

$$
p ( \mathcal { D } | M _ { 0 } ) = \left( \frac { 1 } { 2 } \right) ^ { N }
$$

where $N$ is the number of coin tosses. From Equation (4.143), the marginal likelihood under $M _ { 1 }$ , using a Beta prior, is

$$
p ( \mathcal D | M _ { 1 } ) = \int p ( \mathcal D | \theta ) p ( \theta ) d \theta = \frac { B ( \alpha _ { 1 } + N _ { 1 } , \alpha _ { 0 } + N _ { 0 } ) } { B ( \alpha _ { 1 } , \alpha _ { 0 } ) }
$$

We plot $\log p ( \mathcal { D } | M _ { 1 } )$ vs the number of heads $N _ { 1 }$ in Figure 5.4(a), assuming $N = 5$ and a uniform prior, $\alpha _ { 1 } = \alpha _ { 0 } = 1$ . (The shape of the curve is not very sensitive to $\alpha _ { 1 }$ and $\alpha _ { 0 }$ , as long as the prior is symmetric, so $\alpha _ { 0 } ~ = \alpha _ { 1 }$ .) If we observe 2 or 3 heads, the unbiased coin hypothesis $M _ { 0 }$ is more likely than $M _ { 1 }$ , since $M _ { 0 }$ is a simpler model (it has no free parameters) — it would be a suspicious coincidence if the coin were biased but happened to produce almost exactly 50/50

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022 heads/tails. However, as the counts become more extreme, we favor the biased coin hypothesis. Note that, if we plot the log Bayes factor, $\log B _ { 1 , 0 }$ , it will have exactly the same shape, since $\log p ( \mathcal { D } | M _ { 0 } )$ is a constant.

# 5.2.2 Bayesian model selection

Now suppose we have a set $\mathcal { M }$ of more than 2 models, and we want to pick the most likely. This is called model selection. We can view this as a decision theory problem, where the action space requires choosing one model, $m \in \mathcal { M }$ . If we have a 0-1 loss, the optimal action is to pick the most probable model:

$$
\hat { m } = \mathop { \mathrm { a r g m a x } } _ { m \in \mathcal { M } } p ( m | \mathcal { D } )
$$

where

$$
p ( m | { \mathcal { D } } ) = { \frac { p ( { \mathcal { D } } | m ) p ( m ) } { \sum _ { m \in { \mathcal { M } } } p ( { \mathcal { D } } | m ) p ( m ) } }
$$

is the posterior over models. If the prior over models is uniform, $p ( m ) = 1 / | \mathcal { M } |$ , then the MAP model is given by

$$
\hat { m } = \mathop { \mathrm { a r g m a x } } _ { m \in \mathcal { M } } p ( \mathcal { D } | m )
$$

The quantity $p ( \mathcal { D } | m )$ is given by

$$
p ( { \mathcal { D } } | m ) = \int p ( { \mathcal { D } } | \theta , m ) p ( \theta | m ) d \theta
$$

This is known as the marginal likelihood, or the evidence for model $m$ . Intuitively, it is the likelihood of the data averaged over all possible parameter values, weighted by the prior $p ( \pmb \theta | m )$ . If all settings of $\pmb \theta$ assign high probability to the data, then this is probably a good model.

# 5.2.2.1 Example: polynomial regression

As an example of Bayesian model selection, we will consider polynomial regression in 1d. Figure 5.5 shows the posterior over three different models, corresponding to polynomials of degrees 1, 2 and 3 fit to $N = 5$ data points. We use a uniform prior over models, and use empirical Bayes to estimate the prior over the regression weights (see Section 11.7.7). We then compute the evidence for each model (see Section 11.7 for details on how to do this). We see that there is not enough data to justify a complex model, so the MAP model is $m = 1$ . Figure 5.6 shows the analogous plot for $N = 3 0$ data points. Now we see that the MAP model is $m = 2$ ; the larger sample size means we can safely pick a more complex model.

# 5.2.3 Occam’s razor

Consider two models, a simple one, $m _ { 1 }$ , and a more complex one, $m _ { 2 }$ . Suppose that both can explain the data by suitably optimizing their parameters, i.e., for which $p ( \mathcal { D } | \widehat { \pmb { \theta } } _ { 1 } , m _ { 1 } )$ and $p ( \mathcal { D } | \hat { \pmb { \theta } } _ { 2 } , m _ { 2 } )$ are

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license both large. Intuitively we should prefer $m _ { 1 }$ , since it is simpler and just as good as $m _ { 2 }$ . This principle is known as Occam’s razor.

![](images/fb119b67299a92a5890f2cd429d88da810ceb80be2e3cf78d5ce0c7c9cb6ad57.jpg)  
Figure 5.5: Ilustration of Bayesian model selection for polynomial regression. (a-c) We fit polynomials of degrees 1, 2 and $\mathcal { B }$ fit to $N = 5$ data points. The solid green curve is the true function, the dashed red curve is the prediction (dotted blue lines represent $\pm 2 \sigma$ around the mean). (d) We plot the posterior over models, $p ( m | \mathcal { D } )$ , assuming a uniform prior $p ( m ) \propto 1$ . Generated by linreg_eb_modelsel_vs_n.ipynb.

Let us now see how ranking models based on their marginal likelihood, which involves averaging the likelihood wrt the prior, will give rise to this behavior. The complex model will put less prior probability on the “good” parameters that explain the data, $\hat { \pmb { \theta } } _ { 2 }$ , since the prior must integrate to 1.0 over the entire parameter space. Thus it will take averages in parts of parameter space with low likelihood. By contrast, the simpler model has fewer parameters, so the prior is concentrated over a smaller volume; thus its averages will mostly be in the good part of parameter space, near $\hat { \pmb { \theta } } _ { 1 }$ . Hence we see that the marginal likelihood will prefer the simpler model. This is called the Bayesian Occam’s razor effect [Mac95; MG05].

Another way to understand the Bayesian Occam’s razor effect is to compare the relative predictive abilities of simple and complex models. Since probabilities must sum to one, we have $\begin{array} { r } { \sum _ { \mathcal { D } ^ { \prime } } p ( \mathcal { D } ^ { \prime } | m ) = 1 } \end{array}$ , where the sum is over all possible datasets. Complex models, which can predict many things, must spread their predicted probability mass thinly, and hence will not obtain as large a probability for any given data set as simpler models. This is sometimes called the conservation of probability mass principle, and is illustrated in Figure 5.7. On the horizontal axis we plot all possible data sets in order of increasing complexity (measured in some abstract sense). On the vertical axis we plot the

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022 predictions of 3 possible models: a simple one, $M _ { 1 }$ ; a medium one, $M _ { 2 }$ ; and a complex one, $M _ { 3 }$ . We also indicate the actually observed data $\mathcal { D } _ { 0 }$ by a vertical line. Model 1 is too simple and assigns low probability to $\mathcal { D } _ { 0 }$ . Model 3 also assigns $\mathcal { D } _ { 0 }$ relatively low probability, because it can predict many data sets, and hence it spreads its probability quite widely and thinly. Model 2 is “just right”: it predicts the observed data with a reasonable degree of confidence, but does not predict too many other things. Hence model 2 is the most probable model.

![](images/b16b88da1315cc0b9259c9fea03df51f599887bb99e3755817cffde80d934042.jpg)  
Figure 5.6: Same as Figure 5.5 except now $N = 3 0$ . Generated by linreg_ ${ } ^ { e b } -$ modelsel_vs_n.ipynb.

# 5.2.4 Connection between cross validation and marginal likelihood

We have seen how the marginal likelihood helps us choose models of the “right” complexity. In non-Bayesian approaches to model selection, it is standard to use cross validation (Section 4.5.5) for this purpose.

It turns out that the marginal likelihood is closely related to the leave-one-out cross-validation (LOO-CV) estimate, as we now show. We start with the marginal likelihood for model $m$ , which we write in sequential form as follows:

$$
p ( \mathcal D | m ) = \prod _ { n = 1 } ^ { N } p ( y _ { n } | y _ { 1 : n - 1 } , x _ { 1 : N } , m ) = \prod _ { n = 1 } ^ { N } p ( y _ { n } | x _ { n } , \mathcal D _ { 1 : n - 1 } , m )
$$

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

![](images/2ec6ac75eb92184abfb443c102a203c9890ef407bfc4878773f02dfcb5f5971d.jpg)  
Figure 5.7: A schematic illustration of the Bayesian Occam’s razor. The broad (green) curve corresponds to a complex model, the narrow (blue) curve to a simple model, and the middle (red) curve is just right. Adapted from Figure 3.13 of [Bis06]. See also [MG05, Figure 2] for a similar plot produced on real data.

where

$$
p ( y | \pmb { x } , \mathcal { D } _ { 1 : n - 1 } , m ) = \int p ( y | \pmb { x } , \pmb { \theta } ) p ( \pmb { \theta } | \mathcal { D } _ { 1 : n - 1 } , m ) d \pmb { \theta }
$$

Suppose we use a plugin approximation to the above distribution to get

$$
p ( y | x , \mathcal { D } _ { 1 : n - 1 } , m ) \approx \int p ( y | x , \theta ) \delta ( \theta - \hat { \theta } _ { m } ( \mathcal { D } _ { 1 : n - 1 } ) ) d \theta = p ( y | x , \hat { \theta } _ { m } ( \mathcal { D } _ { 1 : n - 1 } ) )
$$

Then we get

$$
\log p ( \mathcal { D } | m ) \approx \sum _ { n = 1 } ^ { N } \log p ( y _ { n } | \pmb { x } _ { n } , \hat { \pmb { \theta } } _ { m } ( \mathcal { D } _ { 1 : n - 1 } ) )
$$

This is similar to a leave-one-out cross-validation estimate of the likelihood, which has the form $\begin{array} { r } { \frac { 1 } { N } \sum _ { n = 1 } ^ { N } \log p ( y _ { n } | \pmb { x } _ { n } , \hat { \pmb { \theta } } _ { m } ( \mathcal { D } _ { 1 : n - 1 , n + 1 : N } ) ) } \end{array}$ , except we ignore the $\mathcal { D } _ { n + 1 : N }$ part. The intuition behind the connection is this: an overly complex model will overfit the “early” examples and will then predict the remaining ones poorly, and thus will also get a low cross-validation score. See [FH20] for a more detailed discussion of the connection between these performance metrics.

# 5.2.5 Information criteria

The marginal likelihood, $\begin{array} { r } { p ( \mathcal { D } | m ) = \int p ( \mathcal { D } | \pmb { \theta } , m ) p ( \pmb { \theta } ) d \pmb { \theta } } \end{array}$ , which is needed for Bayesian model selection discussed in Section 5.2.2, can be difficult to compute, since it requires marginalizing over the entire parameter space. Furthermore, the result can be quite sensitive to the choice of prior. In this section, we discuss some other related metrics for model selection known as information criteria. We only give a brief discussion; see e.g., [GHV14] for further details.

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

# 5.2.5.1 The Bayesian information criterion (BIC)

The Bayesian information criterion or BIC [Sch78] can be thought of as a simple approximation to the log marginal likelihood. In particular, if we make a Gaussian approximation to the posterior, as discussed in Section 4.6.8.2, we get (from Equation (4.215)) the following:

$$
\log p ( \mathcal { D } | m ) \approx \log p ( \mathcal { D } | \hat { \theta } _ { \mathrm { m a p } } ) + \log p ( \hat { \theta } _ { \mathrm { m a p } } ) - \frac { 1 } { 2 } \log | \mathbf { H } |
$$

where $\mathbf { H }$ is the Hessian of the negative log joint, $- \log p ( \mathcal { D } , \pmb { \theta } )$ , evaluated at the MAP estimate $\hat { \pmb { \theta } } _ { \mathrm { m a p } }$ . We see that Equation (5.56) is the log likelihood plus some penalty terms. If we have a uniform prior, $p ( \pmb \theta ) \propto 1$ , we can drop the prior term, and replace the MAP estimate with the MLE, $\hat { \pmb { \theta } }$ , yielding

$$
\log p ( \mathcal { D } | m ) \approx \log p ( \mathcal { D } | \hat { \pmb { \theta } } ) - \frac { 1 } { 2 } \log | { \bf H } |
$$

We now focus on approximating the $\log | \mathbf { H } |$ term, which is sometimes called the Occam factor, since it is a measure of model complexity (volume of the posterior distribution). We have $\mathbf { H } =$ $\textstyle \sum _ { i = 1 } ^ { N } \mathbf { H } _ { i }$ , where $\mathbf { H } _ { i } = \nabla \nabla \log p ( \mathcal { D } _ { i } | \pmb { \theta } )$ . Let us approximate each $\mathbf { H } _ { i }$ by a fixed matrix $\hat { \bf H }$ . Then we have

$$
\log | \mathbf { H } | = \log | N \hat { \mathbf { H } } | = \log ( N ^ { D } | \hat { \mathbf { H } } | ) = D \log N + \log | \hat { \mathbf { H } } |
$$

where $D = \dim ( \theta )$ and we have assumed $\mathbf { H }$ is full rank. We can drop the $\log | \hat { \mathbf { H } } |$ term, since it is independent of $N$ , and thus will get overwhelmed by the likelihood. Putting all the pieces together, we get the BIC score that we want to maximize:

$$
J _ { \mathrm { B I C } } ( m ) = \log p ( \mathcal { D } | m ) \approx \log p ( \mathcal { D } | \hat { \theta } , m ) - \frac { D _ { m } } { 2 } \log N
$$

We can also define the BIC loss, that we want to minimize, by multiplying by -2:

$$
\mathcal { L } _ { \mathrm { B I C } } ( m ) = - 2 \log p ( \mathcal { D } | \hat { \pmb { \theta } } , m ) + D _ { m } \log N
$$

(The use of 2 as a scale factor is chosen to simplify the expression when using a model with a Gaussian likelihood.)

# 5.2.5.2 Akaike information criterion

The Akaike information criterion [Aka74] is closely related to the BIC. It has the form

$$
\mathcal { L } _ { \mathrm { A I C } } ( m ) = - 2 \log p ( \mathcal { D } | \hat { \pmb { \theta } } , m ) + 2 D
$$

This penalizes complex models less heavily than BIC, since the regularization term is independent of $N$ . This estimator can be derived from a frequentist perspective.

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

# 5.2.5.3 Minimum description length (MDL)

We can think about the problem of scoring different models in terms of information theory (Chapter 6). The goal is for the sender to communicate the data to the receiver. First the sender needs to specify which model $m$ to use; this takes $C ( m ) = - \log p ( m )$ bits (see Section 6.1). Then the receiver can fit the model, by computing $\hat { \pmb { \theta } } _ { m }$ , and can thus approximately reconstruct the data. To perfectly reconstruct the data, the sender needs to send the residual errors that cannot be explained by the model; this takes $\begin{array} { r } { - L ( m ) = - \log p ( \mathcal { D } | \hat { \theta } , m ) = - \sum _ { n } \log p ( y _ { n } | \hat { \theta } , m ) } \end{array}$ bits. The total cost is

$$
\mathcal { L } _ { \mathrm { M D L } } ( m ) = - \log p ( \mathcal { D } | \hat { \pmb { \theta } } , m ) + C ( m )
$$

We see that has the same basic form as BIC/AIC. Choosing the model which minimizes $J ( m )$ is known as the minimum description length or MDL principle. See e.g., [HY01] for details.

# 5.2.6 Posterior inference over effect sizes and Bayesian significance testing

The approach to hypothesis testing discussed in Section 5.2.1 relies on computing the Bayes factors for the null vs the alternative model, $p ( \mathcal { D } | H _ { 0 } ) / p ( \mathcal { D } | H _ { 1 } )$ . Unfortunately, computing the necessary marginal likelihoods can be computationally difficult, and the results can be sensitive to the choice of prior. Furthermore, we are often more interested in estimating an effect size, which is the difference in magnitude between two parameters, rather than in deciding if an effect size is 0 (null hypothesis) or not (alternative hypothesis) — the latter is called a point null hypothesis, and is often regarded as an irrelevant “straw man” (see e.g., [Mak+19] and references therein).

For example, suppose we have two classifiers, $m _ { 1 }$ and $m _ { 2 }$ , and we want to know which one is better. That is, we want to perform a comparison of classifiers. Let $\mu _ { 1 }$ and $\mu _ { 2 }$ be their average accuracies, and let $\delta = \mu _ { 1 } - \mu _ { 2 }$ be the difference in their accuracies. The probability that model 1 is more accurate, on average, than model 2 is given by $p ( \delta > 0 | \mathcal { D } )$ . However, even if this probability is large, the improvement may be not be practically significant. So it is better to compute a probability such as $p ( \delta > \epsilon | \mathcal { D } )$ or $p ( | \delta | > \epsilon | \mathcal { D } )$ , where $\epsilon$ represents the minimal magnitude of effect size that is meaningful for the problem at hand. This is called a one-sided test or two-sided test.

More generally, let $R = [ - \epsilon , \epsilon ]$ represent a region of practical equivalence or ROPE [Kru15; KL17]. We can define 3 events of interest: the null hypothesis $H _ { 0 } : \delta \in R$ , which says both methods are practically the same (which is a more realistic assumption than $H _ { 0 } : \delta = 0$ ); $H _ { A } : \delta > \epsilon$ , which says $m _ { 1 }$ is better than $m _ { 2 }$ ; and $H _ { B } : \delta < - \epsilon$ , which says $m _ { 2 }$ is better than $m _ { 1 }$ . To choose amongst these 3 hypotheses, we just have to compute $p ( \delta | \mathcal { D } )$ , which avoids the need to compute Bayes factors. In the sections below, we discuss how to compute this quantity using two different kinds of model.

# 5.2.6.1 Bayesian t-test for difference in means

Suppose we have two classifiers, $m _ { 1 }$ and $m _ { 2 }$ , which are evaluated on the same set of $N$ test examples. Let $e _ { i } ^ { m }$ be the error of method $m$ on test example $i$ . (Or this could be the conditional log likelihood, $e _ { i } ^ { m } = \log p ^ { m } ( y _ { i } | \pmb { x } _ { i } )$ .) Since the classifiers are applied to the same data, we can use a paired test for comparing them, which is more sensitive than looking at average performance, since the factors that make one example easy or hard to classify (e.g., due to label noise) will be shared by both methods. Thus we will work with the differences, $d _ { i } = e _ { i } ^ { 1 } - e _ { i } ^ { 2 }$ . We assume $d _ { i } \sim \mathcal { N } ( \delta , \sigma ^ { 2 } )$ . We are interested in $p ( \delta | \pmb { d } )$ , where $\pmb { d } = ( d _ { 1 } , \ldots , d _ { N } )$ .

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

If we use an uninformative prior for the unknown parameters $( \delta , \sigma )$ , one can show that the posterior marginal for the mean is given by a Student distribution:

$$
p ( \delta | d ) = \mathcal { T } _ { N - 1 } ( \delta | \mu , s ^ { 2 } / N )
$$

where $\textstyle \mu = { \frac { 1 } { N } } \sum _ { i = 1 } ^ { N } d _ { i }$ is the sample mean, and $\begin{array} { r } { s ^ { 2 } = \frac { 1 } { N - 1 } \sum _ { i = 1 } ^ { N } ( d _ { i } - \mu ) ^ { 2 } } \end{array}$ is an unbiased estimate of the variance. Hence we can easily compute $p ( | \delta | > \epsilon | d )$ , with a ROPE of $\epsilon = 0 . 0 1$ (say). This is known as a Bayesian t-test [Ben+17]. (See also [Rou+09] for Bayesian t-test based on Bayes factors, and [Die98] for a non-Bayesian approach to comparing classifiers.)

An alternative to a formal test is to just plot the posterior $p ( \delta | \pmb { d } )$ . If this distribution is tightly centered on 0, we can conclude that there is no significant difference between the methods. (In fact, an even simpler approach is to just make a boxplot of the data, $\{ d _ { i } \}$ , which avoids the need for any formal statistical analysis.)

Note that this kind of problem arises in many applications, not just evaluating classifiers. For example, suppose we have a set of $N$ people, each of whom is exposed two drugs; let $e _ { i } ^ { m }$ be the outcome (e.g., sickness level) when person $i$ is exposed to drug $m$ , and let $d _ { i } ^ { m } = e _ { i } ^ { 1 } - e _ { i } ^ { 2 }$ be the difference in response. We can then analyse the effect of the drug by computing $p ( \delta | \pmb { d } )$ as we discussed above.

# 5.2.6.2 Bayesian $x ^ { 2 }$ -test for difference in rates

Now suppose we have two classifiers which are evaluated on different test sets. Let $y _ { m }$ be the number of correct examples from method $m \in \{ 1 , 2 \}$ out of $N _ { m }$ trials, so the accuracy rate is $y _ { m } / N _ { m }$ . We assume $y _ { m } \sim \mathrm { B i n } ( N _ { m } , \theta _ { m } )$ , so we are interested in $p ( \delta | \mathcal { D } )$ , where $\delta = \theta _ { 1 } - \theta _ { 2 }$ , and $\mathcal { D } = ( y _ { 1 } , N _ { 1 } , y _ { 2 } , N _ { 2 } )$ is all the data.

If we use a uniform prior for $\theta _ { 1 }$ and $\theta _ { 2 }$ (i.e., $p ( \theta _ { j } ) = \mathrm { B e t a } ( \theta _ { j } | 1 , 1 ) )$ , the posterior is given by

$$
p ( \theta _ { 1 } , \theta _ { 2 } | \mathcal { D } ) = \mathrm { B e t a } ( \theta _ { 1 } | y _ { 1 } + 1 , N _ { 1 } - y _ { 1 } + 1 ) \mathrm { B e t a } ( \theta _ { 2 } | y _ { 2 } + 1 , N _ { 2 } - y _ { 2 } + 1 )
$$

The posterior for $\delta$ is given by

$$
\begin{array} { l } { { \displaystyle p ( \delta | { \mathcal D } ) = \int _ { 0 } ^ { 1 } \int _ { 0 } ^ { 1 } \mathbb { I } \left( \delta = \theta _ { 1 } - \theta _ { 2 } \right) p ( \theta _ { 1 } | { \mathcal D } _ { 1 } ) p ( \theta _ { 2 } | { \mathcal D } _ { 2 } ) } } \\ { { \displaystyle \qquad = \int _ { 0 } ^ { 1 } \mathrm { B e t a } ( \theta _ { 1 } | y _ { 1 } + 1 , N _ { 1 } - y _ { 1 } + 1 ) \mathrm { B e t a } ( \theta _ { 1 } - \delta | y _ { 2 } + 1 , N _ { 2 } - y _ { 2 } + 1 ) d \theta } } \end{array}
$$

We can then evaluate this for any value of $\delta$ that we choose. For example, we can compute

$$
p ( \delta > \epsilon | \mathcal { D } ) = \int _ { \epsilon } ^ { \infty } p ( \delta | \mathcal { D } ) d \delta
$$

(We can compute this using 1 dimensional numerical integration or analytically [Coo05].) This is called a Bayesian $\chi ^ { 2 }$ -test.

Note that this kind of problem arises in many applications, not just evaluating classifiers, For example, suppose the two groups are different companies selling the same product on Amazon, and $y _ { m }$ is the number of positive reviews for merchant $m$ . Or suppose the two groups correspond to men and women, and $y _ { m }$ is the number of people in group $m$ who are left handed, and $N _ { m } - y _ { m }$ to be

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license the number who are right handed.3 We can represent the data as a $2 \times 2$ contingency table of counts, as shown in Table 5.7.

Table 5.7: A 2x2 contingency table from $h t t p : / / e n$ . wikipedia. org/ wiki/ Contingency_ table . The MLEs for the left handedness rate in males and females are $\hat { \theta } _ { 1 } = 9 / 5 2 = 0 . 1 7 3 1$ and $\hat { \theta } _ { 2 } = 4 / 4 8 = 0 . 0 4 1 7$ .   

<html><body><table><tr><td></td><td>LH RH</td><td></td></tr><tr><td>Male</td><td>9 43</td><td>N1 = 52</td></tr><tr><td>Female</td><td>4 44</td><td>N2 = 48</td></tr><tr><td>Totals</td><td>13 87</td><td>100</td></tr></table></body></html>

The MLEs for the left handedness rate in males and females are $\hat { \theta } _ { 1 } = 9 / 5 2 = 0 . 1 7 3 1$ and $\hat { \theta } _ { 2 } = 4 / 4 8 = 0 . 0 4 1 7$ . It seems that there is a difference, but the sample size is low, so we cannot be sure. Hence we will represent our uncertainty by computing $p ( \delta | \mathcal { D } )$ , where $\delta = \theta _ { 1 } - \theta _ { 2 }$ and $\mathcal { D }$ is the table of counts. We find $\begin{array} { r } { p ( \theta _ { 1 } > \theta _ { 2 } | \mathcal { D } ) = \int _ { 0 } ^ { \infty } p ( \delta | \mathcal { D } ) = 0 . 9 0 1 } \end{array}$ , which suggests that left handedness is more common in males, consistent with other studies [PP+20].

# 5.3 Frequentist decision theory

In this section, we discuss frequentist decision theory. This is similar to Bayesian decision theory, discussed in Section 5.1, but differs in that there is no prior, and hence no posterior, over the unknown state of nature. Consequently we cannot define the risk as the posterior expected loss. We will consider other definitions in Section 5.3.1.

# 5.3.1 Computing the risk of an estimator

We define the frequentist risk of an estimator $\pi$ given an unknown state of nature $\pmb \theta$ to be the expected loss when applying that estimator to data $_ { x }$ sampled from the likelihood function $p ( { \pmb x } | { \pmb \theta } )$ :

$$
R ( \pmb \theta , \pi ) \triangleq \mathbb { E } _ { p ( \pmb x | \pmb \theta ) } \left[ \ell ( \pmb \theta , \pi ( \pmb x ) ) \right]
$$

We give an example of this in Section 5.3.1.1.

# 5.3.1.1 Example

Let us give an example, based on [BS94]. Consider the problem of estimating the mean of a Gaussian. We assume the data is sampled from $x _ { n } \sim { \mathcal { N } } ( \theta ^ { * } , \sigma ^ { 2 } = 1 )$ ). If we use quadratic loss, $\ell _ { 2 } ( \theta , { \hat { \theta } } ) = ( \theta - { \hat { \theta } } ) ^ { 2 }$ , the corresponding risk function is the MSE.

We now consider 5 different estimators for computing $\theta$ :

• $\pi _ { 1 } ( \mathcal { D } ) = \overline { { x } }$ , the sample mean • $\pi _ { 2 } ( \mathcal { D } ) = \mathrm { m e d i a n } ( \mathcal { D } )$ , the sample median • $\pi _ { 3 } ( \mathcal { D } ) = \theta _ { 0 }$ , a fixed value

![](images/2ac63700dafd18bf434f82c249ee758a91fcd6cad392d7b0a61f02f9a87e830c.jpg)  
Figure 5.8: Risk functions for estimating the mean of a Gaussian. Each curve represents $R ( { \hat { \theta } } _ { i } ( \cdot ) , \theta ^ { * } )$ plotted vs $\theta ^ { * }$ , where i indexes the estimator. Each estimator is applied to $N$ samples from $\mathcal { N } ( \theta ^ { * } , \sigma ^ { 2 } = 1 )$ . The dark blue horizontal line is the sample mean $( M L E )$ ; the red line horizontal line is the sample median; the black curved line is the estimator $\hat { \theta } = \theta _ { 0 } = 0$ ; the green curved line is the posterior mean when $\kappa = 1$ ; the light blue curved line is the posterior mean when $\kappa = 5$ . (a) $N _ { \mathcal { D } } = 5$ samples. (b) $N _ { \mathcal { D } } = 2 0$ samples. Adapted from Figure B.1 of [BS94]. Generated by riskFnGauss.ipynb.

• $\pi _ { \kappa } ( \mathcal { D } )$ , the posterior mean under a $\mathcal { N } ( \theta | \theta _ { 0 } , \sigma ^ { 2 } / \kappa )$ prior:

$$
\pi _ { \kappa } ( \mathcal { D } ) = \frac { N _ { \mathcal { D } } } { N _ { \mathcal { D } } + \kappa } \overline { { x } } + \frac { \kappa } { N _ { \mathcal { D } } + \kappa } \theta _ { 0 } = w \overline { { x } } + ( 1 - w ) \theta _ { 0 }
$$

For $\pi _ { \kappa }$ , we use $\theta _ { 0 } = 0$ , and consider a weak prior, $\kappa = 1$ , and a stronger prior, $\kappa = 5$ .

Let $\hat { \theta } = \hat { \theta } ( \pmb { x } ) = \pi ( \pmb { x } )$ be the estimated parameter. The risk of this estimator is given by the MSE. In Section 4.7.6.3, we show that the MSE can be decomposed into squared bias plus variance:

$$
\operatorname { M S E } ( { \hat { \theta } } | \theta ^ { * } ) = \mathbb { V } \left[ { \hat { \theta } } \right] + \operatorname { b i a s } ^ { 2 } ( { \hat { \theta } } )
$$

where the bias is defined as $\mathrm { b i a s } ( \hat { \theta } ) = \mathbb { E } \left[ \hat { \theta } - \theta ^ { * } \right]$ . We now use this expression to derive the risk for each estimator.

$\pi _ { 1 }$ is the sample mean. This is unbiased, so its risk is

$$
\mathrm { M S E } ( \pi _ { 1 } | \theta ^ { * } ) = \mathbb { V } \left[ \overline { { x } } \right] = \frac { \sigma ^ { 2 } } { N _ { \mathcal { D } } }
$$

$\pi _ { 2 }$ is the sample median. This is also unbiased. Furthermore, one can show that its variance is approximately $\pi / ( 2 N _ { \mathcal { D } } )$ , so the risk is

$$
\mathrm { M S E } ( \pi _ { 2 } | \theta ^ { * } ) = \frac { \pi } { 2 N _ { D } }
$$

$\pi _ { 3 }$ returns the constant $\theta _ { 0 }$ , so its bias is $( \theta ^ { * } - \theta _ { 0 } )$ and its variance is zero. Hence the risk is

$$
\mathrm { M S E } ( \pi _ { 3 } | \theta ^ { * } ) = ( \theta ^ { * } - \theta _ { 0 } ) ^ { 2 }
$$

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

Finally, $\pi _ { 4 }$ is the posterior mean under a Gaussian prior. We can derive its MSE as follows:

$$
\begin{array} { r l } & { \mathrm { M S E } ( \pi _ { \kappa } | \theta ^ { * } ) = \mathbb { E } \left[ ( w \overline { { x } } + ( 1 - w ) \theta _ { 0 } - \theta ^ { * } ) ^ { 2 } \right] } \\ & { \qquad = \mathbb { E } \left[ ( w ( \overline { { x } } - \theta ^ { * } ) + ( 1 - w ) ( \theta _ { 0 } - \theta ^ { * } ) ) ^ { 2 } \right] } \\ & { \qquad = w ^ { 2 } \frac { \sigma ^ { 2 } } { N _ { D } } + ( 1 - w ) ^ { 2 } ( \theta _ { 0 } - \theta ^ { * } ) ^ { 2 } } \\ & { \qquad = \frac { 1 } { ( N _ { \mathcal { D } } + \kappa ) ^ { 2 } } \left( N _ { \mathcal { D } } \sigma ^ { 2 } + \kappa ^ { 2 } ( \theta _ { 0 } - \theta ^ { * } ) ^ { 2 } \right) } \end{array}
$$

These functions are plotted in Figure 5.8 for $N _ { \mathcal { D } } \in \{ 5 , 2 0 \}$ . We see that in general, the best estimator depends on the value of $\theta ^ { * }$ , which is unknown. If $\theta ^ { * }$ is very close to $\theta _ { 0 }$ , then $\pi _ { 3 }$ (which just predicts $\theta _ { 0 }$ ) is best. If $\theta ^ { * }$ is within some reasonable range around $\theta _ { 0 }$ , then the posterior mean, which combines the prior guess of $\theta _ { 0 }$ with the actual data, is best. If $\theta ^ { * }$ is far from $\theta _ { 0 }$ , the MLE is best.

# 5.3.1.2 Bayes risk

In general, the true state of nature $\pmb \theta$ that generates the data $_ { \pmb { x } }$ is unknown, so we cannot compute the risk given in Equation (5.63). One solution to this is to assume a prior $\pi _ { 0 }$ for $\pmb \theta$ , and then average it out. This gives us the Bayes risk, also called the integrated risk:

$$
R ( \pi _ { 0 } , \pi ) \triangleq \mathbb { E } _ { \pi _ { 0 } ( \pmb { \theta } ) } \left[ R ( \pmb { \theta } , \pi ) \right] = \int d \pmb { \theta } d \pmb { x } \pi _ { 0 } ( \pmb { \theta } ) p ( \pmb { x } | \pmb { \theta } ) \ell ( \pmb { \theta } , \pi ( \pmb { x } ) )
$$

A decision rule that minimizes the Bayes risk is known as a Bayes estimator. This is equivalent to the optimal policy recommended by Bayesian decision theory in Equation (5.2) since

$$
\pi ( { \pmb x } ) = \operatorname * { a r g m i n } _ { a } \int d \pmb \theta \pi _ { 0 } ( \pmb \theta ) p ( { \pmb x } | \pmb \theta ) \ell ( \pmb \theta , a ) = \operatorname * { a r g m i n } _ { a } \int d \pmb \theta p ( \pmb \theta | x ) \ell ( \pmb \theta , a )
$$

Hence we see that picking the optimal action on a case-by-case basis (as in the Bayesian approach) is optimal on average (as in the frequentist approach). In other words, the Bayesian approach provides a good way of achieving frequentist goals. See [BS94, p448] for further discussion of this point.

# 5.3.1.3 Maximum risk

Of course the use of a prior might seem undesirable in the context of frequentist statistics. We can therefore define the maximum risk as follows:

$$
R _ { \mathrm { m a x } } ( \pi ) \triangleq \operatorname* { s u p } _ { \pmb { \theta } } R ( \pmb { \theta } , \pi )
$$

A decision rule that minimizes the maximum risk is called a minimax estimator, and is denoted $\pi _ { M M }$ . For example, in Figure 5.9, we see that $\pi _ { 1 }$ has lower worst-case risk than $\pi _ { 2 }$ , ranging over all possible values of $\pmb \theta$ , so it is the minimax estimator.

Minimax estimators have a certain appeal. However, computing them can be hard. And furthermore, they are very pessimistic. In fact, one can show that all minimax estimators are equivalent to Bayes estimators under a least favorable prior. In most statistical situations (excluding game theoretic ones), assuming nature is an adversary is not a reasonable assumption.

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

![](images/0c89eca4e7c190faa35fe17d93516cdfb40b4d486bddf1b95448b324d7eb7262.jpg)  
Figure 5.9: Risk functions for two decision procedures, $\pi _ { 1 }$ and $\pi _ { 2 }$ . Since $\pi _ { 1 }$ has lower worst case risk, it is the minimax estimator, even though $\pi _ { 2 }$ has lower risk for most values of $\theta$ . Thus minimax estimators are overly conservative.

# 5.3.2 Consistent estimators

Suppose we have a dataset $\mathcal { D } = \{ \pmb { x } _ { n } : n = 1 : N \}$ where the samples $\pmb { x } _ { n } \in \mathcal { X }$ are generated from a distribution $p ( { \pmb x } | \pmb \theta ^ { * } )$ , where $\theta ^ { \ast } \in \Theta$ is the true parameter. Furthermore, suppose the parameters are identifiable, meaning that $p ( \mathcal { D } | \pmb { \theta } ) = p ( \mathcal { D } | \pmb { \theta } ^ { \prime } )$ iff $\pmb \theta = \pmb \theta ^ { \prime }$ for any dataset $\mathcal { D }$ . Then we say that an estimator $\pi : \mathcal { X } ^ { N } \to \Theta$ is a consistent estimator if $\hat { \pmb { \theta } } ( \mathcal { D } )  { \pmb { \theta } } ^ { * }$ as $N  \infty$ (where the arrow denotes convergence in probability). In other words, the procedure $\pi$ recovers the true parameter (or a subset of it) in the limit of infinite data. This is equivalent to minimizing the 0-1 loss, $\mathcal { L } ( \pmb { \theta } ^ { * } , \hat { \pmb { \theta } } ) = \mathbb { I } \left( \pmb { \theta } ^ { * } \neq \hat { \pmb { \theta } } \right)$ . An example of a consistent estimator is the maximum likelihood estimator (MLE).

Note that an estimator can be unbiased but not consistent. For example, consider the estimator $\pi ( \{ x _ { 1 } , \ldots , x _ { N } \} ) = x _ { N }$ . This is an unbiased estimator of the mean, since $\mathbb { E } \left[ \pi ( \mathcal { D } ) \right] = \mathbb { E } \left[ \pmb { x } \right]$ . But the sampling distribution of $\pi ( \mathcal { D } )$ does not converge to a fixed value, so it cannot converge to the point $\theta ^ { * }$ .

Although consistency is a desirable property, it is of somewhat limited usefulness in practice since most real datasets do not come from our chosen model family (i.e., there is no $\pmb { \theta } ^ { * }$ such that $p ( \cdot | \pmb \theta ^ { * } )$ generates the observed data $\mathcal { D }$ ). In practice, it is more useful to find estimators that minimize some discrepancy measure between the empirical distribution $p _ { \mathcal { D } } ( \pmb { x } | \mathcal { D } )$ and the estimated distribution $p ( { \pmb x } | { \hat { \pmb \theta } } )$ . If we use KL divergence as our discrepancy measure, our estimate becomes the MLE.

# 5.3.3 Admissible estimators

We say that $\pi _ { 1 }$ dominates $\pi _ { 2 }$ if $R ( \pmb \theta , \pi _ { 1 } ) \leq R ( \pmb \theta , \pi _ { 2 } )$ for all $\pmb \theta$ . The domination is said to be strict if the inequality is strict for some $\theta ^ { * }$ . An estimator is said to be admissible if it is not strictly dominated by any other estimator. Interestingly, [Wal47] proved that all admissible decision rules are equivalent to some kind of Bayesian decision rule, under some technical conditions. (See [DR21] for a more general version of this result.)

For example, in Figure 5.8, we see that the sample median (dotted red line) always has higher risk than the sample mean (solid blue line). Therefore the sample median is not an admissible estimator for the mean. More surprisingly, one can show that the sample mean is not always an admissible estimator either, even under a Gaussian likelihood model with squared error loss (this is known as Stein’s paradox [Ste56]).

However, the concept of admissibility is of somewhat limited value. For example, let $X \sim { \mathcal { N } } ( \theta , 1 )$ , and consider estimating $\theta$ under squared loss. Consider the estimator $\pi _ { 1 } ( x ) = \theta _ { 0 }$ , where $\theta _ { 0 }$ is a

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license constant independent of the data. We now show that this is an admissible estimator.

To see this, suppose it were not true. Then there would be some other estimator $\pi _ { 2 }$ with smaller risk, so $R ( \theta ^ { * } , \pi _ { 2 } ) \leq R ( \theta ^ { * } , \pi _ { 1 } )$ , where the inequality must be strict for some $\theta ^ { * }$ . Consider the risk at $\theta ^ { * } = \theta _ { 0 }$ . We have $R ( \theta _ { 0 } , \pi _ { 1 } ) = 0$ , and

$$
R ( \theta _ { 0 } , \pi _ { 2 } ) = \int ( \pi _ { 2 } ( x ) - \theta _ { 0 } ) ^ { 2 } p ( x | \theta _ { 0 } ) d x
$$

Since $0 \leq R ( \theta ^ { * } , \pi _ { 2 } ) \leq R ( \theta ^ { * } , \pi _ { 1 } )$ for all $\theta ^ { * }$ , and $R ( \theta _ { 0 } , \pi _ { 1 } ) = 0$ , we have $R ( \theta _ { 0 } , \pi _ { 2 } ) = 0$ and hence $\pi _ { 2 } ( x ) = \theta _ { 0 } = \pi _ { 1 } ( x )$ . Thus the only way $\pi _ { 2 }$ can avoid having higher risk than $\pi _ { 1 }$ at $\theta _ { 0 }$ is by being equal to $\pi _ { 1 }$ . Hence there is no other estimator $\pi _ { 2 }$ with strictly lower risk, so $\pi _ { 2 }$ is admissible.

Thus we see that the estimator $\pi _ { 1 } ( x ) = \theta _ { 0 }$ is admissible, even though it ignores the data, so is useless as an estimator. Conversely, it is possible to construct useful estimators that are not admissable (see e.g., [Jay03, Sec 13.7]).

# 5.4 Empirical risk minimization

In this section, we consider how to apply frequentist decision theory in the context of supervised learning.

# 5.4.1 Empirical risk

In standard accounts of frequentist decision theory used in statistics textbooks, there is a single unknown “state of nature”, corresponding to the unknown parameters $\theta ^ { * }$ of some model, and we define the risk as in Equation (5.63), namely $R ( \pi , \pmb { \theta } ^ { * } ) = \mathbb { E } _ { p ( \mathcal { D } | \pmb { \theta } ^ { * } ) } \left[ \ell ( \pmb { \theta } ^ { * } , \pi ( \mathcal { D } ) ) \right]$ .

In supervised learning, we have a different unknown state of nature (namely the output $y$ ) for each input $_ { x }$ , and our estimator $\pi$ is a prediction function ${ \hat { y } } = f ( { \boldsymbol { \mathbf { \mathit { x } } } } )$ , and the state of nature is the true distribution $p ^ { * } ( { \pmb x } , { \pmb y } )$ . Thus the risk of an estimator is as follows:

$$
R ( f , p ^ { * } ) = R ( f ) \triangleq \mathbb { E } _ { p ^ { * } ( \pmb { x } ) p ^ { * } ( y | \pmb { x } ) } \left[ \ell ( \pmb { y } , f ( \pmb { x } ) \right]
$$

This is called the population risk, since the expectations are taken wrt the true joint distribution $p ^ { * } ( { \pmb x } , { \pmb y } )$ . Of course, $p ^ { * }$ is unknown, but we can approximate it using the empirical distribution with $N$ samples:

$$
p _ { \mathcal { D } } ( \pmb { x } , \pmb { y } | \mathcal { D } ) \triangleq \frac { 1 } { | \mathcal { D } | } \sum _ { ( \pmb { x } _ { n } , \pmb { y } _ { n } ) \in \mathcal { D } } \delta ( \pmb { x } - \pmb { x } _ { n } ) \delta ( \pmb { y } - \pmb { y } _ { n } )
$$

where $p _ { \mathcal { D } } ( { \pmb x } , { \pmb y } ) = p _ { \mathrm { t r } } ( { \pmb x } , { \pmb y } )$ . Plugging this in gives us the empirical risk:

$$
R ( f , \mathcal { D } ) \triangleq \mathbb { E } _ { p _ { \mathcal { D } } ( \pmb { x } , \pmb { y } ) } \left[ \ell ( \pmb { y } , f ( \pmb { x } ) \right] = \frac { 1 } { N } \sum _ { n = 1 } ^ { N } \ell ( \pmb { y } _ { n } , f ( \pmb { x } _ { n } ) )
$$

Note that $R ( f , { \mathcal { D } } )$ is a random variable, since it depends on the training set. A natural way to choose the predictor is to use

$$
\hat { f } _ { \mathrm { E R M } } = \underset { f \in \mathcal { H } } { \operatorname { a r g m i n } } R ( f , \mathcal { D } ) = \underset { f \in \mathcal { H } } { \operatorname { a r g m i n } } \frac { 1 } { N } \sum _ { n = 1 } ^ { N } \ell ( { \pmb y } _ { n } , f ( { \pmb x } _ { n } ) )
$$

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

where we optimize over a specific hypothesis space $\mathcal { H }$ of functions. This is called empirical risk minimization (ERM).

# 5.4.1.1 Approximation error vs estimation error

In this section, we analyze the theoretical performance of functions that are fit using the ERM principle. Let $f ^ { * * } = \mathrm { a r g m i n } _ { f } R ( f )$ be the function that achieves the minimal possible population risk, where we optimize over all possible functions. Of course, we cannot consider all possible functions, so let us also define $\begin{array} { r } { f ^ { * } = \operatorname * { a r g m i n } _ { f \in \mathcal { H } } R ( f ) } \end{array}$ to be the best function in our hypothesis space, $\mathcal { H }$ . Unfortunately we cannot compute $f ^ { * }$ , since we cannot compute the population risk, so let us finally define the prediction function that minimizes the empirical risk in our hypothesis space:

$$
f _ { N } ^ { * } = \underset { f \in \mathcal { H } } { \mathrm { a r g m i n } } R ( f , \mathcal { D } ) = \underset { f \in \mathcal { H } } { \mathrm { a r g m i n } } \mathbb { E } _ { p _ { \mathrm { t r } } } \left[ \ell ( \pmb { y } , f ( \pmb { x } ) ) \right]
$$

One can show [BB08] that the risk of our chosen predictor compared to the best possible predictor can be decomposed into two terms, as follows:

$$
\mathbb { E } _ { p ^ { * } } \left[ R ( f _ { N } ^ { * } ) - R ( f ^ { * * } ) \right] = \underbrace { R ( f ^ { * } ) - R ( f ^ { * * } ) } _ { \mathcal { E } _ { \mathrm { a p p } } ( \mathcal { H } ) } + \underbrace { \mathbb { E } _ { p ^ { * } } \left[ R ( f _ { N } ^ { * } ) - R ( f ^ { * } ) \right] } _ { \mathcal { E } _ { \mathrm { e s t } } ( \mathcal { H } , N ) }
$$

The first term, $\mathcal { E } _ { \mathrm { a p p } } ( \mathcal { H } )$ , is the approximation error, which measures how closely $\mathcal { H }$ can model the true optimal function $f ^ { * * }$ . The second term, $\mathcal { E } _ { \mathrm { e s t } } ( \mathcal { H } , N )$ , is the estimation error or generalization error, which measures the difference in estimated risks due to having a finite training set. We can approximate this by the difference between the training set error and the test set error, using two empirical distributions drawn from $p ^ { * }$ :

$$
\begin{array} { r } { \mathbb { E } _ { p ^ { * } } \left[ R ( f _ { N } ^ { * } ) - R ( f ^ { * } ) \right] \approx \mathbb { E } _ { p _ { \mathrm { t r } } } \left[ \ell ( \pmb { y } , f _ { N } ^ { * } ( \pmb { x } ) ) \right] - \mathbb { E } _ { p _ { \mathrm { t e } } } \left[ \ell ( \pmb { y } , f _ { N } ^ { * } ( \pmb { x } ) ) \right] } \end{array}
$$

This difference is often called the generalization gap.

We can decrease the approximation error by using a more expressive family of functions $\mathcal { H }$ , but this usually increases the generalization error, due to overfitting. We discuss solutions to this tradeoff below.

# 5.4.1.2 Regularized risk

To avoid the chance of overfitting, it is common to add a complexity penalty to the objective function, giving us the regularized empirical risk:

$$
R _ { \lambda } ( f , \mathcal { D } ) = R ( f , \mathcal { D } ) + \lambda C ( f )
$$

where $C ( f )$ measures the complexity of the prediction function $f ( { \pmb x } ; { \pmb \theta } )$ , and $\lambda \geq 0$ , which is known as a hyperparameter, controls the strength of the complexity penalty. (We discuss how to pick $\lambda$ in Section 5.4.2.)

In practice, we usually work with parametric functions, and apply the regularizer to the parameters themselves. This yields the following form of the objective:

$$
R _ { \lambda } ( \pmb \theta , \mathcal { D } ) = R ( \pmb \theta , \mathcal { D } ) + \lambda C ( \pmb \theta )
$$

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

Note that, if the loss function is log loss, and the regularizer is a negative log prior, the regularized risk is given by

$$
R _ { \lambda } ( \pmb \theta , \mathcal { D } ) = - \frac { 1 } { N } \sum _ { n = 1 } ^ { N } \log p ( \pmb y _ { n } | \pmb x _ { n } , \pmb \theta ) - \lambda \log p ( \pmb \theta )
$$

Minimizing this is equivalent to MAP estimation.

# 5.4.2 Structural risk

A natural way to estimate the hyperparameters is to minimize for the lowest achievable empirical risk:

$$
\hat { \lambda } = \mathop { \operatorname { a r g m i n } } _ { \lambda } \operatorname* { m i n } _ { \pmb { \theta } } R _ { \lambda } ( \pmb { \theta } , \mathcal { D } )
$$

(This is an example of bilevel optimization, also called nested optimization.) Unfortunately, this technique will not work, since it will always pick the least amount of regularization, i.e., $\hat { \lambda } = 0$ . To see this, note that

$$
\operatorname * { a r g m i n } _ { \lambda } \operatorname* { m i n } _ { \pmb { \theta } } R _ { \lambda } ( \pmb { \theta } , \mathcal { D } ) = \operatorname * { a r g m i n } _ { \lambda } \operatorname* { m i n } _ { \pmb { \theta } } R ( \pmb { \theta } , \mathcal { D } ) + \lambda C ( \pmb { \theta } )
$$

which is minimized by setting $\lambda = 0$ . The problem is that the empirical risk underestimates the population risk, resulting in overfitting when we choose $\lambda$ . This is called optimism of the training error.

If we knew the regularized population risk $R _ { \lambda } ( \pmb \theta )$ , instead of the regularized empirical risk $R _ { \lambda } ( \pmb \theta , D )$ , we could use it to pick a model of the right complexity (e.g., value of $\lambda$ ). This is known as structural risk minimization [Vap98]. There are two main ways to estimate the population risk for a given model (value of $\lambda$ ), namely cross-validation (Section 5.4.3), and statistical learning theory (Section 5.4.4), which we discuss below.

# 5.4.3 Cross-validation

In this section, we discuss a simple way to estimate the population risk for a supervised learning setup. We simply partition the dataset into two, the part used for training the model, and a second part, called the validation set or holdout set, used for assessing the risk. We can fit the model on the training set, and use its performance on the validation set as an approximation to the population risk.

To explain the method in more detail, we need some notation. First we make the dependence of the empirical risk on the dataset more explicit as follows:

$$
R _ { \lambda } ( \pmb \theta , \mathscr D ) = \frac { 1 } { | \mathscr D | } \sum _ { ( \pmb x , \pmb y ) \in \mathscr D } \ell ( \pmb y , f ( \pmb x ; \pmb \theta ) ) + \lambda C ( \pmb \theta )
$$

Let us also define $\hat { \pmb { \theta } } _ { \lambda } ( \mathcal { D } ) = \mathrm { a r g m i n } _ { \pmb { \theta } } R _ { \lambda } ( \mathcal { D } , \pmb { \theta } )$ . Finally, let $\mathscr { D } _ { \mathrm { t r a i n } }$ and $\mathcal { D } _ { \mathrm { v a l i d } }$ be a partition of $\mathcal { D }$ . (Often we use about $8 0 \%$ of the data for the training set, and $2 0 \%$ for the validation set.)

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

For each model $\lambda$ , we fit it to the training set to get $\begin{array} { r } { \hat { \pmb { \theta } } _ { \lambda } ( \mathcal { D } _ { \mathrm { t r a i n } } ) } \end{array}$ . We then use the unregularized empirical risk on the validation set as an estimate of the population risk. This is known as the validation risk:

$$
R _ { \lambda } ^ { \mathrm { v a l } } \triangleq R _ { 0 } ( \hat { \pmb \theta } _ { \lambda } ( { \mathcal { D } } _ { \mathrm { t r a i n } } ) , { \mathcal { D } } _ { \mathrm { v a l i d } } )
$$

Note that we use different data to train and evaluate the model.

The above technique can work very well. However, if the number of training cases is small, this technique runs into problems, because the model won’t have enough data to train on, and we won’t have enough data to make a reliable estimate of the future performance.

A simple but popular solution to this is to use cross validation (CV). The idea is as follows: we split the training data into $K$ folds; then, for each fold $k \in \{ 1 , \ldots , K \}$ , we train on all the folds but the $k$ ’th, and test on the $k$ ’th, in a round-robin fashion, as sketched in Figure 4.6. Formally, we have

$$
R _ { \lambda } ^ { \mathrm { c v } } \triangleq \frac { 1 } { K } \sum _ { k = 1 } ^ { K } R _ { 0 } ( \hat { \pmb { \theta } } _ { \lambda } ( \mathcal { D } _ { - k } ) , \mathcal { D } _ { k } )
$$

where $\mathcal { D } _ { k }$ is the data in the $k$ ’th fold, and $\mathcal { D } _ { - k }$ is all the other data. This is called the cross-validated risk. Figure 4.6 illustrates this procedure for $K = 5$ . If we set $K = N$ , we get a method known as leave-one-out cross-validation, since we always train on $N - 1$ items and test on the remaining one.

We can use the CV estimate as an objective inside of an optimization routine to pick the optimal hyperparameter, $\hat { \lambda } = \mathrm { a r g m i n } _ { \lambda } R _ { \lambda } ^ { \mathrm { c v } }$ . Finally we combine all the available data (training and validation), and re-estimate the model parameters using $\hat { \pmb \theta } = \mathrm { a r g m i n } _ { \pmb \theta } R _ { \hat { \lambda } } ( \pmb \theta , \mathcal { D } )$ .

# 5.4.4 Statistical learning theory \*

The principal problem with cross validation is that it is slow, since we have to fit the model multiple times. This motivates the desire to compute analytic approximations or bounds on the population risk. This is studied in the field of statistical learning theory (SLT) (see e.g., [Vap98]).

More precisely, the goal of SLT is to upper bound the generalization error with a certain probability. If the bound is satisfied, then we can be confident that a hypothesis that is chosen by minimizing the empirical risk will have low population risk. In the case of binary classifiers, this means the hypothesis will make the correct predictions; in this case we say it is probably approximately correct, and that the hypothesis class is PAC learnable (see e.g., [KV94] for details).

# 5.4.4.1 Bounding the generalization error

In this section, we establish conditions under which we can prove that a hypothesis class is PAC learnable. Let us initially consider the case where the hypothesis space is finite, with size $\dim ( { \mathcal { H } } ) = | { \mathcal { H } } |$ . In other words, we are selecting a hypothesis from a finite list, rather than optimizing real-valued parameters. In this case, we can prove the following.

Theorem 5.4.1. For any data distribution $p ^ { * }$ , and any dataset $\mathcal { D }$ of size $N _ { \mathcal { D } }$ drawn from $p ^ { * }$ , the probability that the generalization error of a binary classifier will be more than $\epsilon$ , in the worst case,

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

is upper bounded as follows:

$$
P \left( \underset { h \in \mathcal { H } } { \operatorname* { m a x } } | R ( h ) - R ( h , \mathcal { D } ) | > \epsilon \right) \leq 2 \dim ( \mathcal { H } ) e ^ { - 2 N _ { \mathcal { D } } \epsilon ^ { 2 } }
$$

where $\begin{array} { r } { R ( h , \mathcal { D } ) = \frac { 1 } { N _ { \mathcal { D } } } \sum _ { i = 1 } ^ { N } \mathbb { I } \left( f ( { \boldsymbol x } _ { i } ) \neq { \boldsymbol y } _ { i } ^ { * } \right) } \end{array}$ is the empirical risk, and $R ( h ) = \mathbb { E } \left[ \mathbb { I } \left( f ( \pmb { x } ) \neq y ^ { * } \right) \right]$ is the population risk.

Proof. Before we prove this, we introduce two useful results. First, Hoeffding’s inequality, which states that if $E _ { 1 } , \dots , E _ { N _ { \mathcal { D } } } \sim \mathrm { B e r } ( \theta )$ , then, for any $\epsilon > 0$ ,

$$
P ( | \overline { { E } } - \theta | > \epsilon ) \leq 2 e ^ { - 2 N _ { \mathcal { D } } \epsilon ^ { 2 } }
$$

where $\begin{array} { r } { \overline { { E } } = \frac { 1 } { N _ { \mathcal { D } } } \sum _ { i = 1 } ^ { N _ { \mathcal { D } } } E _ { i } } \end{array}$ is the empirical error rate, and $\theta$ is the true error rate. Second, the union bound, which says that if $A _ { 1 } , \ldots , A _ { d }$ are a set of events, then $\begin{array} { r } { P ( \cup _ { i = 1 } ^ { d } A _ { i } ) \leq \sum _ { i = 1 } ^ { d } P ( A _ { i } ) } \end{array}$ . Using these results, we have

$$
\begin{array} { r l } { P \left( \underset { h \in \mathcal { H } } { \operatorname* { m a x } } | R ( h ) - R ( h , \mathcal { D } ) | > \epsilon \right) = P \left( \underset { h \in \mathcal { H } } { \bigcup } | R ( h ) - R ( h , \mathcal { D } ) | > \epsilon \right) } & { } \\ { \quad \quad \le \underset { h \in \mathcal { H } } { \sum } P \left( | R ( h ) - R ( h , \mathcal { D } ) | > \epsilon \right) } & { } \\ { \quad \quad \le \underset { h \in \mathcal { H } } { \sum } 2 e ^ { - 2 N _ { \mathcal { D } } \epsilon ^ { 2 } } = 2 \dim ( \mathcal { H } ) e ^ { - 2 N _ { \mathcal { D } } \epsilon ^ { 2 } } } \end{array}
$$

This bound tells us that the optimism of the training error increases with $\dim ( { \mathcal { H } } )$ but decreases with $N _ { \mathit { D } } = | \mathcal { D } |$ , as is to be expected.

# 5.4.4.2 VC dimension

If the hypothesis space $\mathcal { H }$ is infinite (e.g., we have real-valued parameters), we cannot use $\dim ( { \mathcal { H } } ) =$ $| \mathcal { H } |$ . Instead, we can use a quantity called the VC dimension of the hypothesis class, named after Vapnik and Chervonenkis; this measures the degrees of freedom (effective number of parameters) of the hypothesis class. See e.g., [Vap98] for the details.

Unfortunately, it is hard to compute the VC dimension for many interesting models, and the upper bounds are usually very loose, making this approach of limited practical value. However, various other, more practical, estimates of generalization error have recently been devised, especially for DNNs, such as [Jia+20].

# 5.5 Frequentist hypothesis testing \*

Suppose we have two hypotheses, known as the null hypothesis $H _ { 0 }$ and an alternative hypothesis $\boldsymbol { H } _ { 1 }$ , and we want to choose the one we think is correct on the basis of a dataset $\mathcal { D }$ . We could use a Bayesian approach and compute the Bayes factor $p ( H _ { 0 } | \mathcal { D } ) / p ( H _ { 1 } | \mathcal { D } )$ , as we discussed in Section 5.2.1. However, this requires integrating over all possible parameterizations of the models $H _ { 0 }$ and $H _ { 1 }$ , which can be computationally difficult, and which can be sensitive to the choice of prior. In this section, we consider a frequentist approach to the problem.

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

![](images/53f8d8924b92d0fd3c2691e9cab06681c1bd79a571906e8400538405266c1741.jpg)  
Figure 5.10: (a) Illustration of the Neyman-Pearson hypothesis testing paradigm. Generated by neymanPearson2.ipynb. (b) Two hypothetical two-sided power curves. $B$ dominates A. Adapted from Figure 6.3.5 of [LM86]. Generated by twoPowerCurves.ipynb.

# 5.5.1 Likelihood ratio test

If we use 0-1 loss, and assume $p ( H _ { 0 } ) = p ( H _ { 1 } )$ , then the optimal decision rule is to accept $H _ { 0 }$ iff p(D|H0) > 1. This is called the likelihood ratio test. We give some examples of this below.

# 5.5.1.1 Example: comparing Gaussian means

Suppose we are interested in testing whether some data comes from a Gaussian with mean $\mu _ { 0 }$ or from a Gaussian with mean $\mu _ { 1 }$ . (We assume a known shared variance $\sigma ^ { 2 }$ .) This is illustrated in Figure 5.10a, where we plot $p ( x | H _ { 0 } )$ and $p ( x | H _ { 1 } )$ . We can derive the likelihood ratio as follows:

$$
\begin{array} { c } { { \displaystyle \frac { p ( \mathcal { D } | H _ { 0 } ) } { p ( \mathcal { D } | H _ { 1 } ) } = \frac { \exp { \left( - \frac { 1 } { 2 \sigma ^ { 2 } } \sum _ { n = 1 } ^ { N } ( x _ { n } - \mu _ { 0 } ) ^ { 2 } \right) } } { \exp { \left( - \frac { 1 } { 2 \sigma ^ { 2 } } \sum _ { n = 1 } ^ { N } ( x _ { n } - \mu _ { 1 } ) ^ { 2 } \right) } } } } \\ { { = \exp { \left( \frac { 1 } { 2 \sigma ^ { 2 } } ( 2 N \overline { { { x } } } ( \mu _ { 0 } - \mu _ { 1 } ) + N \mu _ { 1 } ^ { 2 } - N \mu _ { 0 } ^ { 2 } ) \right) } } } \end{array}
$$

We see that this ratio only depends on the observed data via its mean, $\textstyle { \overline { { x } } }$ . This is an example of a test statistic $\operatorname { t e s t } ( \mathcal { D } )$ , which is a scalar sufficient statistic for hypothesis testing. From Figure 5.10a, $\begin{array} { r } { \frac { p ( \mathcal { D } | H _ { 0 } ) } { p ( \mathcal { D } | H _ { 1 } ) } > 1 } \end{array}$ $\overline { { x } } < x ^ { * }$ $x ^ { * }$ assuming this point is unique).

# 5.5.1.2 Simple vs compound hypotheses

In Section 5.5.1.1, the parameters for the null and alternative hypotheses were either fully specified ( $\mu _ { 0 }$ and $\mu _ { 1 }$ ) or shared $( \sigma ^ { 2 } )$ . This is called a simple hypothesis test. In general, a hypothesis might not fully specify all the parameters; this is called a compound hypothesis. In this case, we should integrate out these unknown parameters, as in the Bayesian approach, since a hypothesis with more parameters will always have higher likelihood. As an approximation, we can “maximize them out”, which gives us the maximum likelihood ratio test:

$$
\frac { p ( H _ { 0 } | \mathcal { D } ) } { p ( H _ { 1 } | \mathcal { D } ) } = \frac { \int _ { \theta \in H _ { 0 } } p ( \pmb \theta ) p _ { \pmb \theta } ( \mathcal { D } ) } { \int _ { \theta \in H _ { 1 } } p ( \pmb \theta ) p _ { \pmb \theta } ( \mathcal { D } ) } \approx \frac { \operatorname* { m a x } _ { \pmb \theta \in H _ { 0 } } p _ { \pmb \theta } ( \mathcal { D } ) } { \operatorname* { m a x } _ { \pmb \theta \in H _ { 1 } } p _ { \pmb \theta } ( \mathcal { D } ) }
$$

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

# 5.5.2 Null hypothesis significance testing (NHST)

Rather than assuming 0-1 loss, it is conventional to design the decision rule so that it has a type I error rate (the probability of accidentally rejecting the null hypothesis $H _ { 0 }$ ) of $\alpha$ . (See Section 5.1.3 for details on error rates of binary decision rules.) The error rate $\alpha$ is called the significance of the test. Hence the overall approach is called null hypothesis significance testing or NHST.

In our Gaussian mean example, we see from Figure 5.10a that the type I error rate is the vertical shaded blue area:

$$
\begin{array} { c } { { \alpha ( \mu _ { 0 } ) = p ( \mathrm { r e j e c t ~ } H _ { 0 } | H _ { 0 } \mathrm { ~ i s ~ t r u e } ) } } \\ { { = p ( \overline { { { X } } } ( \tilde { \mathcal { D } } ) > x ^ { * } | \tilde { \mathcal { D } } \sim H _ { 0 } ) } } \\ { { = p \left( \displaystyle \frac { \overline { { { X } } } - \mu _ { 0 } } { \sigma / \sqrt { N } } > \displaystyle \frac { x ^ { * } - \mu _ { 0 } } { \sigma / \sqrt { N } } \right) } } \end{array}
$$

Hence $x ^ { * } = z _ { \alpha } \sigma / \sqrt { N } + \mu _ { 0 }$ , where $z _ { \alpha }$ is the upper $\alpha$ quantile of the standard Normal.

The type II error rate is the probability we accidentally accept the null when the alternative is true:

$$
) = p ( { \mathrm { t y p e ~ I I ~ e r r o r } } ) = p ( { \mathrm { a c c e p t ~ } } H _ { 0 } | H _ { 1 } { \mathrm { ~ i s ~ t r u e } } ) = p ( { \mathrm { t e s t } } ( { \tilde { D } } ) < { \mathrm { t e s t } } ^ { * } | { \tilde { D } } \sim H _ { 1 } )
$$

This is shown by the horizontal shaded red area in Figure 5.10a. We define the power of a test as $1 - \beta ( \mu _ { 1 } )$ ; this is the probability that we reject $H _ { 0 }$ given that $H _ { 1 }$ is true. In other words, it is the ability to correctly recognize that the null hypothesis is wrong. Clearly the least power occurs if $\mu _ { 1 } = \mu _ { 0 }$ (so the curves overlap); in this case, we have $1 - \beta ( \mu _ { 1 } ) = \alpha ( \mu _ { 0 } )$ . As $\mu _ { 1 }$ and $\mu _ { 0 }$ become further apart, the power approaches 1 (because the shaded red area gets smaller, $\beta  0$ ). If we have two tests, $A$ and $B$ , where $\operatorname { p o w e r } ( B ) \geq \operatorname { p o w e r } ( A )$ for the same type I error rate, we say $B$ dominates $A$ . See Figure 5.10b. A test with highest power under $H _ { 1 }$ amongst all tests with significance level $\alpha$ is called a most powerful test. It turns out that the likelihood ratio test is a most powerful test, a result known as the Neyman-Pearson lemma.

# 5.5.3 p-values

When we reject $H _ { 0 }$ we often say the result is statistically significant at level $\alpha$ . However, the result may be statistically significant but not practically significant, depending on how far from the decision boundary the test statistic is.

Rather than arbitrarily declaring a result as significant or not, it is preferable to quote the $\mathbf { p }$ -value. This is defined as the probability, under the null hypothesis, of observing a test statistic that is as large or larger than that actually observed:

$$
\mathrm { p v a l } ( \mathrm { t e s t } ( \mathcal { D } ) ) \triangleq \mathrm { P r } ( \mathrm { t e s t } ( \tilde { \mathcal { D } } ) \geq \mathrm { t e s t } ( \mathcal { D } ) | \tilde { \mathcal { D } } \sim H _ { 0 } )
$$

In other words, $\mathrm { p v a l } ( \mathrm { t e s t _ { o b s } } ) \triangleq \mathrm { P r } ( \mathrm { t e s t _ { n u l l } } \geq \mathrm { t e s t _ { o b s } } )$ ), where $\mathrm { \ t e s t { o b s } } = \mathrm { t e s t } ( \mathcal { D } )$ and $\mathrm { t e s t } _ { \mathrm { n u l l } } = \mathrm { t e s t } ( \tilde { \mathcal { D } } )$ , where $\tilde { \mathcal { D } } \sim H _ { 0 }$ is hypothetical future data. To see the connection with hypothesis testing, suppose we pick a decision threshold $t ^ { * }$ such that $\mathrm { P r } ( \mathrm { t e s t } ( \tilde { \mathcal { D } } ) \geq t ^ { * } | H _ { 0 } ) = \alpha$ . If we set $t ^ { * } = \mathrm { t e s t } ( \mathcal { D } )$ , then $\alpha = \mathrm { p v a l } ( \mathrm { t e s t } ( \mathcal { D } ) )$ .

Thus if we only accept hypotheses where the p-value is less than $\alpha = 0 . 0 5$ , then $9 5 \%$ of the time we will correctly reject the null hypothesis. However, this does not mean that the alternative hypothesis

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

$H _ { 1 }$ is true with probability 0.95. Indeed, even most scientists misinterpret p-values.4 The quantity that most people want to compute is the Bayesian posterior $p ( H _ { 1 } | \mathcal { D } ) = 0 . 9 5$ . For more on this important distinction, see Section 5.5.4.

# 5.5.4 p-values considered harmful

A p-value is often interpreted as the likelihood of the data under the null hypothesis, so small values are interpreted to mean that $H _ { 0 }$ is unlikely, and therefore that $\boldsymbol { H } _ { 1 }$ is likely. The reasoning is roughly as follows:

If $H _ { 0 }$ is true, then this test statistic would probably not occur. This statistic did occur.   
Therefore $H _ { 0 }$ is probably false.

However, this is invalid reasoning. To see why, consider the following example (from [Coh94]):

If a person is an American, then he is probably not a member of Congress. This person is a member of Congress. Therefore he is probably not an American.

This is obviously fallacious reasoning. By contrast, the following logical argument is valid reasoning:

If a person is a Martian, then he is not a member of Congress. This person is a member of Congress. Therefore he is not a Martian.

The difference between these two cases is that the Martian example is using deduction, that is, reasoning forward from logical definitions to their consequences. More precisely, this example uses a rule from logic called modus tollens, in which we start out with a definition of the form $P \Rightarrow Q$ ; when we observe $\neg Q$ , we can conclude $\neg P$ . By contrast, the American example concerns induction, that is, reasoning backwards from observed evidence to probable (but not necessarily true) causes using statistical regularities, not logical definitions.

To perform induction, we need to use probabilistic inference (as explained in detail in [Jay03]). In particular, to compute the probability of the null hypothesis, we should use Bayes rule, as follows:

$$
p ( H _ { 0 } | \mathcal { D } ) = \frac { p ( \mathcal { D } | H _ { 0 } ) p ( H _ { 0 } ) } { p ( \mathcal { D } | H _ { 0 } ) p ( H _ { 0 } ) + p ( \mathcal { D } | H _ { 1 } ) p ( H _ { 1 } ) }
$$

If the prior is uniform, so $p ( H _ { 0 } ) = p ( H _ { 1 } ) = 0 . 5$ , this can be rewritten in terms of the likelihood ratio $L R = p ( { \mathcal { D } } | H _ { 0 } ) / p ( { \mathcal { D } } | H _ { 1 } )$ as follows:

$$
p ( H _ { 0 } | \mathcal { D } ) = \frac { L R } { L R + 1 }
$$

In the American Congress example, $\mathcal { D }$ is the observation that the person is a member of Congress. The null hypothesis $H _ { 0 }$ is that the person is American, and the alternative hypothesis $\boldsymbol { H } _ { 1 }$ is that the person is not American. We assume that $p ( \mathcal { D } | H _ { 0 } )$ is low, since most Americans are not members of Congress. However, $p ( \mathcal { D } | H _ { 1 } )$ is also low — in fact, in this example, it is 0, since only Americans can be members of Congress. Hence $L R = \infty$ , so $p ( H _ { 0 } | \mathcal { D } ) = 1 . 0$ , as intuition suggests. Note, however, that NHST ignores $p ( \mathcal { D } | H _ { 1 } )$ as well as the prior $p ( H _ { 0 } )$ , so it gives the wrong results — not just in this problem, but in many problems.

Table 5.8: Some statistics of a hypothetical clinical trial. Source: [SAM04, p74].   

<html><body><table><tr><td></td><td>Ineffective</td><td>Effective</td><td></td></tr><tr><td>"Not significant”</td><td>171</td><td>4</td><td>175</td></tr><tr><td>"Significant”</td><td>9</td><td>16</td><td>25</td></tr><tr><td></td><td>180</td><td>20</td><td>200</td></tr></table></body></html>

In general there can be huge differences between p-values and $p ( H _ { 0 } | \mathcal { D } )$ . In particular, [SBB01] show that even if the p-value is as low as 0.05, the posterior probability of $H _ { 0 }$ can be as high as $3 0 \%$ or more, even with a uniform prior.

Consider this concrete example from [SAM04, p74]. Suppose 200 clinical trials are carried out for some drug, and we get the data in Table 5.8. Suppose we perform a statistical test of whether the drug has a significant effect or not. The test has a type I error rate of $\alpha = 9 / 2 0 0 = 0 . 0 4 5$ and a type II error rate of $\beta = 2 / 1 0 0 = 0 . 0 2$ .

We can compute the probability that the drug is not effective, given that the result is supposedly “significant”, as follows:

$$
\begin{array} { r l } { p ( H _ { 0 } | \mathrm {  ~ \mathrm { > i g n i f f c a n t } ~ } ^ { \prime } ) = \frac { p ( \mathrm {  ~ \mathrm { ` s i g n i f i c a n t } ~ } ^ { \prime } \backslash H _ { 0 } ) p ( H _ { 0 } ) } { p ( \mathrm {  ~ \mathrm { ' s i g n i f i c a n t } ~ } ^ { \prime } | H _ { 0 } ) p ( H _ { 0 } ) + p ( \mathrm {  ~ \mathrm { ' s i g n i f i c a n t } ~ } ^ { \prime } | H _ { 1 } ) p ( H _ { 1 } ) } } & { } \\ { = \frac { p ( \mathrm { t y p e ~ I ~ e r r o r } ) p ( H _ { 0 } ) } { p ( \mathrm { t y p e ~ I ~ e r r o r } ) p ( H _ { 0 } ) + ( 1 - p ( \mathrm { t y p e ~ I I ~ e r r o r } ) ) p ( H _ { 1 } ) } } & { } \\ { = \frac { \alpha p ( H _ { 0 } ) } { \alpha p ( H _ { 0 } ) + ( 1 - \beta ) p ( H _ { 1 } ) } } & { } \end{array}
$$

If we have prior knowledge, based on past experience, that most (say 90%) drugs are ineffective, then we find $p ( H _ { 0 } | ^ { \prime } \mathrm { s i g n i f i c a n t } ^ { \prime } ) = 0 . 3 6$ , which is much more than the 5% probability people usually associate with a p-value of $\alpha = 0 . 0 5$ .

Thus we should distrust claims of statistical significance if they violate our prior knowledge.

# 5.5.5 Why isn’t everyone a Bayesian?

In Section 4.7.5 and Section 5.5.4, we have seen that inference based on frequentist principles can exhibit various forms of counter-intuitive behavior that can sometimes contradict common sense reason, as has been pointed out in multiple articles (see e.g., [Mat98; MS11; Kru13; Gel16; Hoe+14; Lyu+20; Cha+19b; Cla21]).

The fundamental reason is that frequentist inference violates the likelihood principle [BW88], which says that inference should be based on the likelihood of the observed data, not on hypothetical future data that you have not observed. Bayes obviously satisfies the likelihood principle, and consequently does not suffer from these pathologies.

Given these fundamental flaws of frequentist statistics, and the fact that Bayesian methods do not have such flaws, an obvious question to ask is: “Why isn’t everyone a Bayesian?” The (frequentist) statistician Bradley Efron wrote a paper with exactly this title [Efr86]. His short paper is well worth reading for anyone interested in this topic. Below we quote his opening section:

The title is a reasonable question to ask on at least two counts. First of all, everyone used to

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022 be a Bayesian. Laplace wholeheartedly endorsed Bayes’s formulation of the inference problem, and most 19th-century scientists followed suit. This included Gauss, whose statistical work is usually presented in frequentist terms.

![](images/26081cb72265241819671eabd32ac123c367e346cbc9cba1adafdad03ed6de09.jpg)  
Figure 5.11: Cartoon illustrating the difference between frequentists and Bayesians. (The $p < 0 . 0 5$ comment is explained in Section 5.5.4. The betting comment is a reference to the Dutch book theorem, which essentially proves that the Bayesian approach to gambling (and other decision theory problems) is optimal, as explained in e.g., [Háj08].) From https: // xkcd. com/ 1132/ . Used with kind permission of Rundall Munroe (author of xkcd).

A second and more important point is the cogency of the Bayesian argument. Modern statisticians, following the lead of Savage and de Finetti, have advanced powerful theoretical arguments for preferring Bayesian inference. A byproduct of this work is a disturbing catalogue of inconsistencies in the frequentist point of view.

Nevertheless, everyone is not a Bayesian. The current era (1986) is the first century in which statistics has been widely used for scientific reporting, and in fact, 20th-century statistics is mainly non-Bayesian. However, Lindley (1975) predicts a change for the 21st century.

Time will tell whether Lindley was right. However, the trends seem to be going in this direction. For example, some journals have banned p-values [TM15; AGM19], and the journal The American Statistician (produced by the American Statistical Association) published a whole special issue warning about the use of p-values and NHST [WSL19].

Traditionally, computation has been a barrier to using Bayesian methods, but this is less of an issue these days, due to faster computers and better algorithms (which we will discuss in the sequel to this book, [Mur23]). Another, more fundamental, concern is that the Bayesian approach is only as correct as its modeling assumptions. However, this criticism also applies to frequentist methods, since the

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license sampling distribution of an estimator must be derived using assumptions about the data generating mechanism. (In fact [BT73] show that the sampling distributions for the MLE for common models are identical to the posterior distributions under a noninformative prior.) Fortunately, we can check modeling assumptions empirically using cross validation (Section 4.5.5), calibration, and Bayesian model checking. We discuss these topics in the sequel to this book, [Mur23].

To summarize, it is worth quoting Donald Rubin, who wrote a paper [Rub84] called “Bayesianly Justifiable and Relevant Frequency Calculations for the Applied Statistician”. In it, he writes

The applied statistician should be Bayesian in principle and calibrated to the real world in practice. [They] should attempt to use specifications that lead to approximately calibrated procedures under reasonable deviations from [their assumptions]. [They] should avoid models that are contradicted by observed data in relevant ways — frequency calculations for hypothetical replications can model a model’s adequacy and help to suggest more appropriate models.

# 5.6 Exercises

Exercise 5.1 [Reject option in classifiers]

(Source: [DHS01, Q2.13].) In many classification problems one has the option either of assigning $_ x$ to class $j$ or, if you are too uncertain, of choosing the reject option. If the cost for rejects is less than the cost of falsely classifying the object, it may be the optimal action. Let $\alpha _ { i }$ mean you choose action $i$ , for $i = 1 : C + 1$ , where $C$ is the number of classes and $C + 1$ is the reject action. Let $Y = j$ be the true (but unknown) state of nature. Define the loss function as follows

$$
\lambda ( \alpha _ { i } | Y = j ) = \left\{ { \begin{array} { l l } { 0 } & { { \mathrm { i f ~ } } i = j { \mathrm { ~ a n d ~ } } i , j \in \{ 1 , \dots , C \} } \\ { \lambda _ { r } } & { { \mathrm { ~ i f ~ } } i = C + 1 } \\ { \lambda _ { s } } & { { \mathrm { ~ o t h e r w i s e } } } \end{array} } \right.
$$

In other words, you incur 0 loss if you correctly classify, you incur $\lambda _ { r }$ loss (cost) if you choose the reject option, and you incur $\lambda _ { s }$ loss (cost) if you make a substitution error (misclassification).

a. Show that the minimum risk is obtained if we decide $Y = j$ if $p ( Y = j | \pmb { x } ) \geq p ( Y = k | \pmb { x } )$ for all $k$ (i.e., $j$ is the most probable class) and if $\begin{array} { r } { p ( Y = j | \pmb { x } ) \ge 1 - \frac { \lambda _ { r } } { \lambda _ { s } } } \end{array}$ ; otherwise we decide to reject. b. Describe qualitatively what happens as $\lambda _ { r } / \lambda _ { s }$ is increased from 0 to 1 (i.e., the relative cost of rejection increases).

# Exercise 5.2 [Newsvendor problem \*]

Consider the following classic problem in decision theory / economics. Suppose you are trying to decide how much quantity $Q$ of some product (e.g., newspapers) to buy to maximize your profits. The optimal amount will depend on how much demand $D$ you think there is for your product, as well as its cost to you $C$ and its selling price $P$ . Suppose $\mathcal { D }$ is unknown but has pdf $f ( D )$ and cdf $F ( D )$ . We can evaluate the expected profit by considering two cases: if $D > Q$ , then we sell all $Q$ items, and make profit $\pi = ( P - C ) Q$ ; but if $D < Q$ , we only sell $\mathcal { D }$ items, at profit $( P - C ) D$ , but have wasted $C ( Q - D )$ on the unsold items. So the expected profit if we buy quantity $Q$ is

$$
E \pi ( Q ) = \int _ { Q } ^ { \infty } ( P - C ) Q f ( D ) d D + \int _ { 0 } ^ { Q } ( P - C ) D f ( D ) d D - \int _ { 0 } ^ { Q } C ( Q - D ) f ( D ) d D
$$

Simplify this expression, and then take derivatives wrt $Q$ to show that the optimal quantity $Q ^ { * }$ (which maximizes the expected profit) satisfies

$$
F ( Q ^ { * } ) = { \frac { P - C } { P } }
$$

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

Exercise 5.3 [Bayes factors and ROC curves \*]

Let $B = p ( D | H _ { 1 } ) / p ( D | H _ { 0 } )$ be the Bayes factor in favor of model 1. Suppose we plot two ROC curves, one computed by thresholding $B$ , and the other computed by thresholding $p ( H _ { 1 } | D )$ . Will they be the same or different? Explain why.

Exercise 5.4 [Posterior median is optimal estimate under L1 loss] Prove that the posterior median is the optimal estimate under L1 loss.

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

# 6 Information Theory

In this chapter, we introduce a few basic concepts from the field of information theory. More details can be found in other books such as [Mac03; CT06], as well as the sequel to this book, [Mur23].

# 6.1 Entropy

The entropy of a probability distribution can be interpreted as a measure of uncertainty, or lack of predictability, associated with a random variable drawn from a given distribution, as we explain below.

We can also use entropy to define the information content of a data source. For example, suppose we observe a sequence of symbols $X _ { n } \sim p$ generated from distribution $p$ . If $p$ has high entropy, it will be hard to predict the value of each osbervation $X _ { n }$ . Hence we say that the dataset ${ \mathcal { D } } = ( X _ { 1 } , \ldots , X _ { n } )$ has high information content. By contrast, if $p$ is a degenerate distribution with 0 entropy (the minimal value), then every $X _ { n }$ will be the same, so $\mathcal { D }$ does not contain much information. (All of this can be formalized in terms of data compression, as we discuss in the sequel to this book.)

# 6.1.1 Entropy for discrete random variables

The entropy of a discrete random variable $X$ with distribution $p$ over $K$ states is defined by

$$
\mathbb { H } \left( X \right) \triangleq - \sum _ { k = 1 } ^ { K } p ( X = k ) \log _ { 2 } p ( X = k ) = - \mathbb { E } _ { X } \left[ \log p ( X ) \right]
$$

(Note that we use the notation $\mathbb { H } \left( X \right)$ to denote the entropy of the rv with distribution $p$ , just as people write V $[ X ]$ to mean the variance of the distribution associated with $X$ ; we could alternatively write $\mathbb { H } \left( p \right)$ .) Usually we use log base 2, in which case the units are called bits (short for binary digits). For example, if $X \in \{ 1 , \ldots , 5 \}$ with histogram distribution $p = [ 0 . 2 5 , 0 . 2 5 , 0 . 2 , 0 . 1 5 , 0 . 1 5 ]$ , we find $H = 2 . 2 9$ bits. If we use log base $e$ , the units are called nats.

The discrete distribution with maximum entropy is the uniform distribution. Hence for a $K$ -ary random variable, the entropy is maximized if $p ( x = k ) = 1 / K$ ; in this case, $\mathbb { H } \left( X \right) = \log _ { 2 } K$ . To see this, note that

$$
\mathbb { H } \left( X \right) = - \sum _ { k = 1 } ^ { K } \frac { 1 } { K } \log ( 1 / K ) = - \log ( 1 / K ) = \log ( K )
$$

![](images/6ce6c532408823904f41181285eeb1b71e37a71e009998a84c5f103959c45041.jpg)  
Figure 6.1: Entropy of a Bernoulli random variable as a function of $\theta$ . The maximum entropy is $\log _ { 2 } 2 = 1$ . Generated by bernoulli_entropy_fig.ipynb.   
Figure 6.2: (a) Some aligned DNA sequences. Each row is a sequence, each column is a location within the sequence. (b) The corresponding position weight matrix represented as a sequence logo. Each column represents a probability distribution over the alphabet $\{ A , C , G , T \}$ for the corresponding location in the sequence. The size of the letter is proportional to the probability. The height of column t is given by $2 - H _ { t }$ , where $0 \leq H _ { t } \leq 2$ is the entropy (in bits) of the distribution $\mathbf { \mathcal { P } } t$ . Thus deterministic distributions (with an entropy of 0, corresponding to highly conserved locations) have height 2, and uniform distributions (with an entropy of 2) have height 0. Generated by seq_logo_demo.ipynb.

$\begin{array} { r }  \begin{array} { r l } & { \alpha \textbf { t } \alpha \textbf { g } \textrm { c c g } \textrm { g t } \alpha \textbf { c g } \textrm { g c a } } \\ & { \textrm { t } \textrm { t a } \textrm { g c t } \textrm { g c a } \textrm { c c g } \textrm { g c a } } \\ & { \textrm { t c a } \textrm { g c c } \textrm { c c a } \textrm { g c a } \textrm { g a } \textrm { g c a } } \\ & { \alpha \textbf { t } \alpha \textbf { \textrm { a } c c g } \textrm { c g } \textrm { g c a } \textrm { c g } \textrm { g c a } } \\ & { \textrm { t } \textrm { t a } \textrm { g c c g } \textrm { c t } \textrm { a } \textrm { a } } \\ & { \textrm { t } \textrm { a } \textrm { a g c c } \textrm { c t } \textrm { c g } \textrm { t a } \textrm { c g } \textrm { g t } \alpha } \\ & { \textrm { t } \textrm { t a } \textrm { a g c c } \textrm { g t } \textrm { t a } \textrm { c g } \textrm { g c c } \textrm { c } } \\ & { \textrm { t } \textrm { t a } \textrm { g c c g } \textrm { g t } \textrm { t a c g } \textrm { g c c } \textrm { c } } \\ & { \alpha \textbf { t } \textrm { a } \textrm { t c c g } \textrm { g } \textrm { g t } \textrm { a c c } \textrm { g a } } \\ & { \alpha \textbf { \textrm { t } \alpha \textrm { g c } \textrm { c g } \textrm { g t } \textrm { c a } \textrm { c g } \textrm { g a } \textrm { a } } \\ & { \alpha \textbf { \textrm { c a } \textrm { t c c g } \textrm { g t } \textrm { g a c c g } \textrm { g a } \textrm { a } } \end{array} } } \end{array}$ TTAGCCGETACEGEA 12 13 (a) (b)

Conversely, the distribution with minimum entropy (which is zero) is any delta-function that puts all its mass on one state. Such a distribution has no uncertainty.

For the special case of binary random variables, $X \in \{ 0 , 1 \}$ , we can write $p ( X = 1 ) = \theta$ and $p ( X = 0 ) = 1 - \theta$ . Hence the entropy becomes

$$
\begin{array} { c } { { \mathbb { H } \left( X \right) = - [ p ( X = 1 ) \log _ { 2 } p ( X = 1 ) + p ( X = 0 ) \log _ { 2 } p ( X = 0 ) ] } } \\ { { = - [ \theta \log _ { 2 } \theta + ( 1 - \theta ) \log _ { 2 } ( 1 - \theta ) ] } } \end{array}
$$

This is called the binary entropy function, and is also written $\mathbb { H } \left( \theta \right)$ . We plot this in Figure 6.1. We see that the maximum value of 1 bit occurs when the distribution is uniform, $\theta = 0 . 5$ . A fair coin requires a single yes/no question to determine its state.

As an interesting application of entropy, consider the problem of representing DNA sequence motifs, which is a distribution over short DNA strings. We can estimate this distribution by aligning a set of DNA sequences (e.g., from different species), and then estimating the empirical distribution of each possible nucleotide from the 4 letter alphabet $X \sim \{ A , C , G , T \}$ at each location $t$ in the $i$ th sequence as follows:

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

$$
\begin{array} { r l } & { \mathbf { N } _ { t } = \left( \displaystyle \sum _ { i = 1 } ^ { N _ { \mathcal { D } } } \mathbb { I } \left( X _ { i t } = A \right) , \displaystyle \sum _ { i = 1 } ^ { N _ { \mathcal { D } } } \mathbb { I } \left( X _ { i t } = C \right) , \displaystyle \sum _ { i = 1 } ^ { N _ { \mathcal { D } } } \mathbb { I } \left( X _ { i t } = G \right) , \displaystyle \sum _ { i = 1 } ^ { N _ { \mathcal { D } } } \mathbb { I } \left( X _ { i t } = T \right) \right) } \\ & { \quad \hat { \pmb { \theta } } _ { t } = \mathbf { N } _ { t } / N _ { \mathcal { D } } , } \end{array}
$$

This $\mathbf { N } _ { t }$ is a length four vector counting the number of times each letter appears at each location amongst the set of sequences. This $\hat { \pmb { \theta } } _ { t }$ distribution is known as a motif. We can also compute the most probable letter in each location; this is called the consensus sequence.

One way to visually summarize the data is by using a sequence logo, as shown in Figure 6.2(b). We plot the letters A, C, G and T, with the most probable letter on the top; the height of the $t$ ’th bar is defined to be $0 \leq 2 - H _ { t } \leq 2$ , where $H _ { t }$ is the entropy of $\hat { \pmb { \theta } } _ { t }$ (note that 2 is the maximum possible entropy for a distribution over 4 letters). Thus tall bars correspond to nearly deterministic distributions, which are the locations that are conserved by evolution (e.g., because they are part of a gene coding region). In this example, we see that column 13 is all G’s, and hence has height 2.

Estimating the entropy of a random variable with many possible states requires estimating its distribution, which can require a lot of data. For example, imagine if $X$ represents the identity of a word in an English document. Since there is a long tail of rare words, and since new words are invented all the time, it can be difficult to reliably estimate $p ( X )$ and hence $\mathbb { H } \left( X \right)$ . For one possible solution to this problem, see [VV13].

# 6.1.2 Cross entropy

The cross entropy between distribution $p$ and $q$ is defined by

$$
\mathbb { H } ( p , q ) \triangleq - \sum _ { k = 1 } ^ { K } p _ { k } \log q _ { k }
$$

One can show that the cross entropy is the expected number of bits needed to compress some data samples drawn from distribution $p$ using a code based on distribution $q$ . This can be minimized by setting $q = p$ , in which case the expected number of bits of the optimal code is $\mathbb { H } ( p , p ) = \mathbb { H } ( p )$ — this is known as Shannon’s source coding theorem (see e.g., [CT06]).

# 6.1.3 Joint entropy

The joint entropy of two random variables $X$ and $Y$ is defined as

$$
\mathbb { H } \left( X , Y \right) = - \sum _ { x , y } p ( x , y ) \log _ { 2 } p ( x , y )
$$

For example, consider choosing an integer from 1 to 8, $n \in \{ 1 , \ldots , 8 \}$ . Let $X ( n ) = 1$ if $n$ is even, and $Y ( n ) = 1$ if $n$ is prime:

$$
{ \begin{array} { c } { { \frac { n } { X } } } \\ { { \begin{array} { c } { { \left| \begin{array} { c c c c c c c c c } { { 1 } } & { { 2 } } & { { 3 } } & { { 4 } } & { { 5 } } & { { 6 } } & { { 7 } } & { { 8 } } \\ { { 0 } } & { { 1 } } & { { 0 } } & { { 1 } } & { { 0 } } & { { 1 } } & { { 0 } } & { { 1 } } \end{array} \right| } } \\ { { \begin{array} { c } { { Y } } \\ { { Y } } \end{array} } } \end{array} } } \end{array} }
$$

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

The joint distribution is

$$
\begin{array}{c} { \frac { p ( X , Y ) \ \mid \ Y = 0 \quad Y = 1 } { X = 0 } } \end{array} \quad
$$

so the joint entropy is given by

$$
\mathbb { H } \left( X , Y \right) = - \left[ \frac { 1 } { 8 } \log _ { 2 } \frac { 1 } { 8 } + \frac { 3 } { 8 } \log _ { 2 } \frac { 3 } { 8 } + \frac { 3 } { 8 } \log _ { 2 } \frac { 3 } { 8 } + \frac { 1 } { 8 } \log _ { 2 } \frac { 1 } { 8 } \right] = 1 . 8 1 \mathrm { ~ b i t s }
$$

Clearly the marginal probabilities are uniform: $p ( X = 1 ) = p ( X = 0 ) = p ( Y = 0 ) = p ( Y =$ $1 ) = 0 . 5$ , so $\mathbb { H } \left( X \right) = \mathbb { H } \left( Y \right) = 1$ . Hence $\mathbb { H } ( X , Y ) = 1 . 8 1$ bits $< \mathbb { H } \left( X \right) + \mathbb { H } \left( Y \right) = 2$ bits. In fact, this upper bound on the joint entropy holds in general. If $X$ and $Y$ are independent, then $\mathbb { H } \left( X , Y \right) = \mathbb { H } \left( X \right) + \mathbb { H } \left( Y \right)$ , so the bound is tight. This makes intuitive sense: when the parts are correlated in some way, it reduces the “degrees of freedom” of the system, and hence reduces the overall entropy.

What is the lower bound on $\mathbb { H } \left( X , Y \right)$ ? If $Y$ is a deterministic function of $X$ , then $\mathbb { H } \left( X , Y \right) = \mathbb { H } \left( X \right)$ . So

$$
\mathbb { H } \left( X , Y \right) \geq \operatorname* { m a x } \{ \mathbb { H } \left( X \right) , \mathbb { H } \left( Y \right) \} \geq 0
$$

Intuitively this says combining variables together does not make the entropy go down: you cannot reduce uncertainty merely by adding more unknowns to the problem, you need to observe some data, a topic we discuss in Section 6.1.4.

We can extend the definition of joint entropy from two variables to $n$ in the obvious way.

# 6.1.4 Conditional entropy

The conditional entropy of $Y$ given $X$ is the uncertainty we have in $Y$ after seeing $X$ , averaged over possible values for $X$ :

$$
\begin{array} { r l } & { \mathbb { H } \displaystyle \left( Y | X \right) \triangleq \mathbb { E } _ { p ( X ) } \left[ \mathbb { H } \left( p ( Y | X ) \right) \right] } \\ & { \qquad = \displaystyle \sum _ { x } p ( x ) \mathbb { H } \left( p ( Y | X = x ) \right) = - \sum _ { x } p ( x ) \sum _ { y } p ( y | x ) \log p ( y | x ) } \\ & { \qquad = - \displaystyle \sum _ { x , y } p ( x , y ) \log p ( y | x ) = - \sum _ { x , y } p ( x , y ) \log \frac { p ( x , y ) } { p ( x ) } } \\ & { \qquad = - \displaystyle \sum _ { x , y } p ( x , y ) \log p ( x , y ) + \displaystyle \sum _ { x } p ( x ) \log p ( x ) } \\ & { \qquad = \mathbb { H } \left( X , Y \right) - \mathbb { H } \left( X \right) } \end{array}
$$

If $Y$ is a deterministic function of $X$ , then knowing $X$ completely determines $Y$ , so $\mathbb { H } \left( Y | X \right) = 0$ . If $X$ and $Y$ are independent, knowing $X$ tells us nothing about $Y$ and $\mathbb { H } \left( Y | X \right) = \mathbb { H } \left( Y \right)$ . Since $\mathbb { H } \left( X , Y \right) \leq \mathbb { H } \left( Y \right) + \mathbb { H } \left( X \right)$ , we have

$$
\mathbb { H } \left( Y | X \right) \le \mathbb { H } \left( Y \right)
$$

with equality iff $X$ and $Y$ are independent. This shows that, on average, conditioning on data never increases one’s uncertainty. The caveat “on average” is necessary because for any particular observation

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

(value of $X$ ), one may get more “confused” (i.e., $\mathbb { H } \left( Y | x \right) > \mathbb { H } \left( Y \right) .$ ). However, in expectation, looking at the data is a good thing to do. (See also Section 6.3.8.)

We can rewrite Equation (6.15) as follows:

$$
\mathbb { H } \left( X _ { 1 } , X _ { 2 } \right) = \mathbb { H } \left( X _ { 1 } \right) + \mathbb { H } \left( X _ { 2 } \vert X _ { 1 } \right)
$$

This can be generalized to get the chain rule for entropy:

$$
\mathbb { H } \left( X _ { 1 } , X _ { 2 } , \ldots , X _ { n } \right) = \sum _ { i = 1 } ^ { n } \mathbb { H } \left( X _ { i } | X _ { 1 } , \ldots , X _ { i - 1 } \right)
$$

# 6.1.5 Perplexity

The perplexity of a discrete probability distribution $p$ is defined as

This is often interpreted as a measure of predictability. For example, suppose $p$ is a uniform distribution over $K$ states. In this case, the perplexity is $K$ . Obviously the lower bound on perplexity is $2 ^ { 0 } = 1$ , which will be achieved if the distribution can perfectly predict outcomes.

Now suppose we have an empirical distribution based on data $\mathcal { D }$ :

$$
p _ { \mathcal { D } } ( x | \mathcal { D } ) = \frac { 1 } { N } \sum _ { n = 1 } ^ { N } \delta _ { x _ { n } } ( x )
$$

We can measure how well $p$ predicts $\mathcal { D }$ by computing

Perplexity is often used to evaluate the quality of statistical language models, which is a generative model for sequences of tokens. Suppose the data is a single long document $x$ of length $N$ , and suppose $p$ is a simple unigram model. In this case, the cross entropy term is given by

$$
H = - \frac { 1 } { N } \sum _ { n = 1 } ^ { N } \log p ( x _ { n } )
$$

and hence the perplexity is given by

$$
{ \mathrm { p e r p l e x i t y } } ( p _ { \mathcal { D } } , p ) = 2 ^ { H } = 2 ^ { - { \frac { 1 } { N } } } \log ( \prod _ { n = 1 } ^ { N } p ( x _ { n } ) ) = \sqrt [ N ] { \prod _ { n = 1 } ^ { N } \frac { 1 } { p ( x _ { n } ) } }
$$

This is sometimes called the exponentiated cross entropy. We see that this is the geometric mean of the inverse predictive probabilities.

In the case of language models, we usually condition on previous words when predicting the next word. For example, in a bigram model, we use a first order Markov model of the form $p ( x _ { i } | x _ { i - 1 } )$ . We define the branching factor of a language model as the number of possible words that can

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license follow any given word. We can thus interpret the perplexity as the weighted average branching factor. For example, suppose the model predicts that each word is equally likely, regardless of context, so $p ( x _ { i } | x _ { i - 1 } ) = 1 / K$ . Then the perplexity is $( ( 1 / K ) ^ { N } ) ^ { - 1 / N } = K$ . If some symbols are more likely than others, and the model correctly reflects this, its perplexity will be lower than $K$ . However, as we show in Section 6.2, we have $\mathbb { H } \left( p ^ { * } \right) \leq \mathbb { H } _ { c e } \left( p ^ { * } , p \right)$ , so we can never reduce the perplexity below the entropy of the underlying stochastic process $p ^ { * }$ .

See [JM08, p96] for further discussion of perplexity and its uses in language models.

# 6.1.6 Differential entropy for continuous random variables \*

If $X$ is a continuous random variable with pdf $p ( x )$ , we define the differential entropy as

$$
h ( X ) \triangleq - \int _ { \mathcal { X } } p ( x ) \log p ( x ) \ d x
$$

assuming this integral exists. For example, suppose $X \sim U ( 0 , a )$ . Then

$$
h ( X ) = - \int _ { 0 } ^ { a } d x { \frac { 1 } { a } } \log { \frac { 1 } { a } } = \log a
$$

Note that, unlike the discrete case, differential entropy can be negative. This is because pdf’s can be bigger than 1. For example if $X \sim U ( 0 , 1 / 8 )$ , we have $h ( X ) = \log _ { 2 } ( 1 / 8 ) = - 3$ .

One way to understand differential entropy is to realize that all real-valued quantities can only be represented to finite precision. It can be shown [CT91, p228] that the entropy of an $n$ -bit quantization of a continuous random variable $X$ is approximately $h ( X ) + n$ . For example, suppose $X \sim U ( 0 , \frac { 1 } { 8 } )$ . Then in a binary representation of $X$ , the first 3 bits to the right of the binary point must be 0 (since the number is $\leq 1 / 8$ ). So to describe $X$ to $n$ bits of accuracy only requires $n - 3$ bits, which agrees with $h ( X ) = - 3$ calculated above.

# 6.1.6.1 Example: Entropy of a Gaussian

The entropy of a $d$ -dimensional Gaussian is

$$
h ( { \mathcal { N } } ( \mu , \Sigma ) ) = { \frac { 1 } { 2 } } \ln \left| 2 \pi e \Sigma \right| = { \frac { 1 } { 2 } } \ln [ ( 2 \pi e ) ^ { d } | \Sigma | ] = { \frac { d } { 2 } } + { \frac { d } { 2 } } \ln ( 2 \pi ) + { \frac { 1 } { 2 } } \ln \left| \Sigma \right|
$$

In the 1d case, this becomes

$$
h ( \mathcal { N } ( \mu , \sigma ^ { 2 } ) ) = \frac { 1 } { 2 } \ln \left[ 2 \pi e \sigma ^ { 2 } \right]
$$

# 6.1.6.2 Connection with variance

The entropy of a Gaussian increases monotonically as the variance increases. However, this is not always the case. For example, consider a mixture of two 1d Gaussians centered at -1 and $+ 1$ . As we move the means further apart, say to -10 and $+ 1 0$ , the variance increases (since the average distance from the overall mean gets larger). However, the entropy remains more or less the same, since we are still uncertain about where a sample might fall, even if we know that it will be near -10 or $+ 1 0$ . (The exact entropy of a GMM is hard to compute, but a method to compute upper and lower bounds is presented in [Hub+08].)

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

# 6.1.6.3 Discretization

In general, computing the differential entropy for a continuous random variable can be difficult. A simple approximation is to discretize or quantize the variables. There are various methods for this (see e.g., [DKS95; KK06] for a summary), but a simple approach is to bin the distribution based on its empirical quantiles. The critical question is how many bins to use [LM04]. Scott [Sco79] suggested the following heuristic:

$$
B = N _ { \mathscr { D } } ^ { 1 / 3 } \frac { \operatorname* { m a x } ( \mathscr { D } ) - \operatorname* { m i n } ( \mathscr { D } ) } { 3 . 5 \sigma ( \mathscr { D } ) }
$$

where $\sigma ( \mathcal { D } )$ is the empirical standard deviation of the data, and $N _ { \mathit { D } } = | \mathcal { D } |$ is the number of datapoints in the empirical distribution. However, the technique of discretization does not scale well if $X$ is a multi-dimensional random vector, due to the curse of dimensionality.

# 6.2 Relative entropy (KL divergence) \*

Given two distributions $p$ and $q$ , it is often useful to define a distance metric to measure how “close” or “similar” they are. In fact, we will be more general and consider a divergence measure $D ( p , q )$ which quantifies how far $q$ is from $p$ , without requiring that $D$ be a metric. More precisely, we say that $D$ is a divergence if $D ( p , q ) \geq 0$ with equality iff $p = q$ , whereas a metric also requires that $D$ be symmetric and satisfy the triangle inequality, $D ( p , r ) \leq D ( p , q ) + D ( q , r )$ . There are many possible divergence measures we can use. In this section, we focus on the Kullback-Leibler divergence or KL divergence, also known as the information gain or relative entropy, between two distributions $p$ and $q$ .

# 6.2.1 Definition

For discrete distributions, the KL divergence is defined as follows:

$$
D _ { \mathbb { K L } } ( p \nmid | q ) \triangleq \sum _ { k = 1 } ^ { K } p _ { k } \log \frac { p _ { k } } { q _ { k } }
$$

This naturally extends to continuous distributions as well:

$$
D _ { \mathbb { K L } } \left( p \parallel q \right) \triangleq \int d x p ( x ) \log \frac { p ( x ) } { q ( x ) }
$$

# 6.2.2 Interpretation

We can rewrite the KL as follows:

$$
D _ { \mathbb { K L } } \left( { p } \parallel { q } \right) = \underbrace { \sum _ { k = 1 } ^ { K } { p _ { k } \log { p _ { k } } } } _ { - \mathbb { H } \left( p \right) } \underbrace { - \sum _ { k = 1 } ^ { K } { p _ { k } \log { q _ { k } } } } _ { \mathbb { H } \left( p , q \right) }
$$

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

We recognize the first term as the negative entropy, and the second term as the cross entropy. It can be shown that the cross entropy $\mathbb { H } ( p , q )$ is a lower bound on the number of bits needed to compress data coming from distribution $p$ if your code is designed based on distribution $q$ ; thus we can interpret the KL divergence as the “extra number of bits” you need to pay when compressing data samples if you use the incorrect distribution $q$ as the basis of your coding scheme compared to the true distribution $p$ .

There are various other interpretations of KL divergence. See the sequel to this book, [Mur23], for more information.

# 6.2.3 Example: KL divergence between two Gaussians

For example, one can show that the KL divergence between two multivariate Gaussian distributions is given by

$$
\begin{array} { r l } & { D _ { \mathbb { K L } } \left( { \mathcal { N } } ( x | \mu _ { 1 } , \Sigma _ { 1 } ) \parallel { \mathcal { N } } ( x | \mu _ { 2 } , \Sigma _ { 2 } ) \right) } \\ & { = \displaystyle \frac { 1 } { 2 } \left[ \mathrm { t r } ( \Sigma _ { 2 } ^ { - 1 } \Sigma _ { 1 } ) + ( \mu _ { 2 } - \mu _ { 1 } ) ^ { \mathsf { T } } \Sigma _ { 2 } ^ { - 1 } ( \mu _ { 2 } - \mu _ { 1 } ) - D + \log \left( \frac { \mathrm { d e t } ( \Sigma _ { 2 } ) } { \mathrm { d e t } ( \Sigma _ { 1 } ) } \right) \right] } \end{array}
$$

In the scalar case, this becomes

$$
D _ { \mathbb { K } } \left( { \mathcal { N } } ( x | \mu _ { 1 } , \sigma _ { 1 } ) \parallel { \mathcal { N } } ( x | \mu _ { 2 } , \sigma _ { 2 } ) \right) = \log { \frac { \sigma _ { 2 } } { \sigma _ { 1 } } } + { \frac { \sigma _ { 1 } ^ { 2 } + ( \mu _ { 1 } - \mu _ { 2 } ) ^ { 2 } } { 2 \sigma _ { 2 } ^ { 2 } } } - { \frac { 1 } { 2 } }
$$

# 6.2.4 Non-negativity of KL

In this section, we prove that the KL divergence is always non-negative.

To do this, we use Jensen’s inequality. This states that, for any convex function $f$ , we have that

$$
f ( \sum _ { i = 1 } ^ { n } \lambda _ { i } { \pmb x } _ { i } ) \leq \sum _ { i = 1 } ^ { n } \lambda _ { i } f ( { \pmb x } _ { i } )
$$

where $\lambda _ { i } \geq 0$ and $\begin{array} { r } { \sum _ { i = 1 } ^ { n } \lambda _ { i } = 1 } \end{array}$ . In words, this result says that $f$ of the average is less than the average of the $f$ ’s. This is clearly true for $n = 2$ , since a convex function curves up above a straight line connecting the two end points (see Section 8.1.3). To prove for general $n$ , we can use induction. For example, if $f ( x ) = \log ( x )$ , which is a concave function, we have

$$
\log ( \mathbb { E } _ { x } g ( x ) ) \geq \mathbb { E } _ { x } \log ( g ( x ) )
$$

We use this result below.

Theorem 6.2.1. (Information inequality) $D _ { \mathbb { K L } } \left( p \parallel q \right) \ge 0$ with equality iff $p = q$ .

Proof. We now prove the theorem following [CT06, p28]. Let $A = \{ x : p ( x ) > 0 \}$ be the support of

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

$p ( x )$ . Using the concavity of the log function and Jensen’s inequality (Section 6.2.4), we have that

$$
\begin{array} { l } { \displaystyle - D _ { \mathbb { K L } } \left( p \parallel q \right) = - \sum _ { x \in A } p ( x ) \log \frac { p ( x ) } { q ( x ) } = \sum _ { x \in A } p ( x ) \log \frac { q ( x ) } { p ( x ) } } \\ { \displaystyle \quad \leq \log \sum _ { x \in A } p ( x ) \frac { q ( x ) } { p ( x ) } = \log \sum _ { x \in A } q ( x ) } \\ { \displaystyle \quad \leq \log \sum _ { x \in \mathcal { X } } q ( x ) = \log 1 = 0 } \end{array}
$$

Since $\log ( x )$ is a strictly concave function $( - \log ( x )$ is convex), we have equality in Equation (6.37) iff $p ( x ) = c q ( x )$ for some $c$ that tracks the fraction of the whole space $\mathcal { X }$ contained in $A$ . We have equality in Equation (6.38) iff $\begin{array} { r } { \sum _ { x \in A } q ( x ) = \sum _ { x \in \mathcal { X } } q ( x ) = 1 } \end{array}$ , which implies $c = 1$ . Hence $D _ { \mathbb { K L } } \left( p \parallel q \right) = 0$ iff $p ( x ) = q ( x )$ for all $x$ . □

This theorem has many important implications, as we will see throughout the book. For example, we can show that the uniform distribution is the one that maximizes the entropy:

Corollary 6.2.1. (Uniform distribution maximizes the entropy) $\mathbb { H } \left( X \right) \leq \log \left| \mathcal { X } \right|$ , where $| { \mathcal { X } } |$ is the number of states for $X$ , with equality iff $p ( x )$ is uniform.

Proof. Let $u ( x ) = 1 / \vert x \vert$ . Then

$$
0 \leq D _ { \mathbb { K L } } \left( p \parallel u \right) = \sum _ { x } p ( x ) \log { \frac { p ( x ) } { u ( x ) } } = \log | { \mathcal { X } } | - \mathbb { H } \left( X \right)
$$

# 6.2.5 KL divergence and MLE

Suppose we want to find the distribution $q$ that is as close as possible to $p$ , as measured by KL divergence:

$$
q ^ { * } = \arg \operatorname* { m i n } _ { q } D _ { \mathbb { K L } } \left( p \parallel q \right) = \arg \operatorname* { m i n } _ { q } \int p ( x ) \log p ( x ) d x - \int p ( x ) \log q ( x ) d x
$$

Now suppose $p$ is the empirical distribution, which puts a probability atom on the observed training data and zero mass everywhere else:

$$
p _ { \mathcal { D } } ( x ) = \frac { 1 } { N _ { \mathcal { D } } } \sum _ { n = 1 } ^ { N _ { \mathcal { D } } } \delta ( x - x _ { n } )
$$

Using the sifting property of delta functions we get

$$
\begin{array} { l } { { \displaystyle { \cal D } _ { \mathbb { R } \mathbb { L } } \left( p _ { \mathcal { D } } \parallel q \right) = - \int p _ { \mathcal { D } } ( x ) \log q ( x ) d x + C } \ ~ } \\ { { \displaystyle ~ = - \int \left[ \frac { 1 } { N _ { \mathcal { D } } } \sum _ { n } \delta ( x - x _ { n } ) \right] \log q ( x ) d x + C } \ ~ } \\ { { \displaystyle ~ = - \frac { 1 } { N _ { \mathcal { D } } } \sum _ { n } \log q ( x _ { n } ) + C } } \end{array}
$$

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license where $\begin{array} { r } { C = \int p ( x ) \log p ( x ) d x } \end{array}$ is a constant independent of $q$ . This is called the cross entropy objective, and is equal to the average negative log likelihood of $q$ on the training set. Thus we see that minimizing KL divergence to the empirical distribution is equivalent to maximizing likelihood.

This perspective points out the flaw with likelihood-based training, namely that it puts too much weight on the training set. In most applications, we do not really believe that the empirical distribution is a good representation of the true distribution, since it just puts “spikes” on a finite set of points, and zero density everywhere else. Even if the dataset is large (say 1M images), the universe from which the data is sampled is usually even larger (e.g., the set of “all natural images” is much larger than 1M). We could smooth the empirical distribution using kernel density estimation (Section 16.3), but that would require a similar kernel on the space of images. An alternative, algorithmic approach is to use data augmentation, which is a way of perturbing the observed data samples in way that we believe reflects plausible “natural variation”. Applying MLE on this augmented dataset often yields superior results, especially when fitting models with many parameters (see Section 19.1).

# 6.2.6 Forward vs reverse KL

Suppose we want to approximate a distribution $p$ using a simpler distribution $q$ . We can do this by minimizing $D _ { \mathbb { K L } } \left( q \parallel p \right)$ or $D _ { \mathbb { K L } } \left( p \parallel q \right)$ . This gives rise to different behavior, as we discuss below. First we consider the forwards KL, also called the inclusive KL, defined by

$$
D _ { \mathbb { K L } } \left( p \parallel q \right) = \int p ( x ) \log \frac { p ( x ) } { q ( x ) } d x
$$

Minimizing this wrt $q$ is known as an M-projection or moment projection.

We can gain an understanding of the optimal $q$ by considering inputs $x$ for which $p ( x ) > 0$ but $q ( x ) = 0$ . In this case, the term $\log p ( x ) / q ( x )$ will be infinite. Thus minimizing the KL will force $q$ to include all the areas of space for which $p$ has non-zero probability. Put another way, $q$ will be zero-avoiding or mode-covering, and will typically over-estimate the support of $p$ . Figure 6.3(a) illustrates mode covering where $p$ is a bimodal distribution but $q$ is unimodal.

Now consider the reverse $\mathbf { K L }$ , also called the exclusive KL:

$$
D _ { \mathbb { K L } } \left( q \parallel p \right) = \int q ( x ) \log { \frac { q ( x ) } { p ( x ) } } d x
$$

Minimizing this wrt $q$ is known as an I-projection or information projection.

We can gain an understanding of the optimal $q$ by consider inputs $x$ for which $p ( x ) = 0$ but $q ( x ) > 0$ . In this case, the term $\log { q ( x ) } / p ( x )$ will be infinite. Thus minimizing the exclusive KL will force $q$ to exclude all the areas of space for which $p$ has zero probability. One way to do this is for $q$ to put probability mass in very few parts of space; this is called zero-forcing or mode-seeking behavior. In this case, $q$ will typically under-estimate the support of $p$ . We illustrate mode seeking when $p$ is bimodal but $q$ is unimodal in Figure 6.3(b-c).

# 6.3 Mutual information \*

The KL divergence gave us a way to measure how similar two distributions were. How should we measure how dependant two random variables are? One thing we could do is turn the question

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

![](images/222e33f49b36651d103d073c20d28a702484d7d13941e73949119d8f5d1c3b08.jpg)  
Figure 6.3: Illustrating forwards vs reverse $K L$ on a bimodal distribution. The blue curves are the contours of the true distribution $p$ . The red curves are the contours of the unimodal approximation $q$ . (a) Minimizing forwards $K L$ , $D _ { \mathbb { K L } } \left( p \parallel q \right)$ , wrt $q$ causes q to “cover” p. (b-c) Minimizing reverse $K L$ , $D _ { \mathbb { K L } } \left( q \parallel p \right)$ wrt $q$ causes $q$ to “lock onto” one of the two modes of p. Adapted from Figure 10.3 of [Bis06]. Generated by KLfwdReverseMixGauss.ipynb.

of measuring the dependence of two random variables into a question about the similarity of their distributions. This gives rise to the notion of mutual information (MI) between two random variables, which we define below.

# 6.3.1 Definition

The mutual information between rv’s $X$ and $Y$ is defined as follows:

$$
\mathbb { I } \left( X ; Y \right) \triangleq D _ { \mathbb { K L } } \left( p ( x , y ) \parallel p ( x ) p ( y ) \right) = \sum _ { y \in Y } \sum _ { x \in X } p ( x , y ) \log { \frac { p ( x , y ) } { p ( x ) p ( y ) } }
$$

(We write $\mathbb { I } ( X ; Y )$ instead of $\mathbb { I } ( X , Y )$ , in case $X$ and/or $Y$ represent sets of variables; for example, we can write $\mathbb { I } ( X ; Y , Z )$ to represent the MI between $X$ and $( Y , Z )$ .) For continuous random variables, we just replace sums with integrals.

It is easy to see that MI is always non-negative, even for continuous random variables, since

$$
\mathbb { I } \left( X ; Y \right) = D _ { \mathbb { K L } } \left( p ( x , y ) \parallel p ( x ) p ( y ) \right) \ge 0
$$

We achieve the bound of $0$ iff $p ( x , y ) = p ( x ) p ( y )$ .

# 6.3.2 Interpretation

Knowing that the mutual information is a KL divergence between the joint and factored marginal distributions tells us that the MI measures the information gain if we update from a model that treats the two variables as independent $p ( x ) p ( y )$ to one that models their true joint density $p ( x , y )$ .

To gain further insight into the meaning of MI, it helps to re-express it in terms of joint and conditional entropies, as follows:

$$
\mathbb { I } \left( X ; Y \right) = \mathbb { H } \left( X \right) - \mathbb { H } \left( X | Y \right) = \mathbb { H } \left( Y \right) - \mathbb { H } \left( Y | X \right)
$$

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

![](images/04d2166a8836fa525e0509a871f5496c38e23f853509b399ce57ebcc47f43ba9.jpg)  
Figure 6.4: The marginal entropy, joint entropy, conditional entropy and mutual information represented as information diagrams. Used with kind permission of Katie Everett.

Thus we can interpret the MI between $X$ and $Y$ as the reduction in uncertainty about $X$ after observing $Y$ , or, by symmetry, the reduction in uncertainty about $Y$ after observing $X$ . Incidentally, this result gives an alternative proof that conditioning, on average, reduces entropy. In particular, we have $0 \le \mathbb { I } \left( X ; Y \right) = \mathbb { H } \left( X \right) - \mathbb { H } \left( X | Y \right)$ , and hence $\mathbb { H } \left( X | Y \right) \leq \mathbb { H } \left( X \right)$ .

We can also obtain a different interpretation. One can show that

$$
\mathbb { I } \left( \boldsymbol { X } ; \boldsymbol { Y } \right) = \mathbb { H } \left( \boldsymbol { X } , \boldsymbol { Y } \right) - \mathbb { H } \left( \boldsymbol { X } | \boldsymbol { Y } \right) - \mathbb { H } \left( \boldsymbol { Y } | \boldsymbol { X } \right)
$$

Finally, one can show that

$$
\mathbb { I } \left( \boldsymbol { X } ; \boldsymbol { Y } \right) = \mathbb { H } \left( \boldsymbol { X } \right) + \mathbb { H } \left( \boldsymbol { Y } \right) - \mathbb { H } \left( \boldsymbol { X } , \boldsymbol { Y } \right)
$$

See Figure 6.4 for a summary of these equations in terms of an information diagram. (Formally, this is a signed measure mapping set expressions to their information-theoretic counterparts [Yeu91].)

# 6.3.3 Example

As an example, let us reconsider the example concerning prime and even numbers from Section 6.1.3. Recall that $\mathbb { H } \left( X \right) = \mathbb { H } \left( Y \right) = 1$ . The conditional distribution $p ( { Y } | { X } )$ is given by normalizing each row:

<html><body><table><tr><td></td><td>Y=0</td><td>Y=1</td></tr><tr><td>X=0</td><td>1-43-</td><td>3-41-</td></tr><tr><td></td><td></td><td></td></tr><tr><td>X=1</td><td>4</td><td>4</td></tr></table></body></html>

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

Hence the conditional entropy is

$$
\mathbb { H } \left( Y | X \right) = - \left[ \frac { 1 } { 8 } \log _ { 2 } \frac { 1 } { 4 } + \frac { 3 } { 8 } \log _ { 2 } \frac { 3 } { 4 } + \frac { 3 } { 8 } \log _ { 2 } \frac { 3 } { 4 } + \frac { 1 } { 8 } \log _ { 2 } \frac { 1 } { 4 } \right] = 0 . 8 1 \ \mathrm { { I } }
$$

and the mutual information is

$$
\operatorname { I } \left( X ; Y \right) = \operatorname { I f } \left( Y \right) - \operatorname { I f } \left( Y | X \right) = \left( 1 - 0 . 8 1 \right) { \mathrm { ~ b i t s } } = 0 . 1 9 { \mathrm { ~ b i t s } }
$$

You can easily verify that

$$
{ \begin{array} { r l } & { \mathbb { H } \left( X , Y \right) = \mathbb { H } \left( X | Y \right) + \mathbb { I } \left( X ; Y \right) + \mathbb { H } \left( Y | X \right) } \\ & { \qquad = ( 0 . 8 1 + 0 . 1 9 + 0 . 8 1 ) { \mathrm { ~ b i t s } } = 1 . 8 1 { \mathrm { ~ b i t s } } } \end{array} }
$$

# 6.3.4 Conditional mutual information

We can define the conditional mutual information in the obvious way

$$
{ \begin{array} { r l } & { \mathbb { I } \left( X ; Y | Z \right) \triangleq \mathbb { E } _ { p ( Z ) } \left[ \mathbb { I } ( X ; Y ) | Z \right] } \\ & { \qquad = \mathbb { E } _ { p ( x , y , z ) } \left[ \log { \frac { p ( x , y | z ) } { p ( x | z ) p ( y | z ) } } \right] } \\ & { \qquad = \mathbb { H } \left( X | Z \right) + \mathbb { H } \left( Y | Z \right) - \mathbb { H } \left( X , Y | Z \right) } \\ & { \qquad = \mathbb { H } \left( X | Z \right) - \mathbb { H } \left( X | Y , Z \right) = \mathbb { H } \left( Y | Z \right) - \mathbb { H } \left( Y | X , Z \right) } \\ & { \qquad = \mathbb { H } \left( X , Z \right) + \mathbb { H } \left( Y , Z \right) - \mathbb { H } \left( Z \right) - \mathbb { H } \left( X , Y , Z \right) } \\ & { \qquad = \mathbb { I } \left( Y ; X , Z \right) - \mathbb { I } \left( Y ; Z \right) } \end{array} }
$$

The last equation tells us that the conditional MI is the extra (residual) information that $X$ tells us about $Y$ , excluding what we already knew about $Y$ given $Z$ alone.

We can rewrite Equation (6.61) as follows:

$$
\mathbb { I } ( Z , Y ; X ) = \mathbb { I } ( Z ; X ) + \mathbb { I } ( Y ; X \vert Z )
$$

Generalizing to $N$ variables, we get the chain rule for mutual information:

$$
\mathbb { I } \left( Z _ { 1 } , \ldots , Z _ { N } ; X \right) = \sum _ { n = 1 } ^ { N } \mathbb { I } \left( Z _ { n } ; X | Z _ { 1 } , \ldots , Z _ { n - 1 } \right)
$$

# 6.3.5 MI as a “generalized correlation coefficient”

Suppose that $( x , y )$ are jointly Gaussian:

$$
{ \binom { x } { y } } \sim \mathcal { N } ( \mathbf { 0 } , { \binom { \sigma ^ { 2 } } { \rho \sigma ^ { 2 } } } \quad { \rho \sigma ^ { 2 } } ) )
$$

We now show how to compute the mutual information between $X$ and $Y$ .

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

Using Equation (6.26), we find that the entropy is

$$
h ( X , Y ) = { \frac { 1 } { 2 } } \log \left[ ( 2 \pi e ) ^ { 2 } \operatorname* { d e t } \Sigma \right] = { \frac { 1 } { 2 } } \log \left[ ( 2 \pi e ) ^ { 2 } \sigma ^ { 4 } ( 1 - \rho ^ { 2 } ) \right]
$$

Since $X$ and $Y$ are individually normal with variance $\sigma ^ { 2 }$ , we have

$$
h ( X ) = h ( Y ) = { \frac { 1 } { 2 } } \log \left[ 2 \pi e \sigma ^ { 2 } \right]
$$

Hence

$$
\begin{array} { l } { { I ( X , Y ) = h ( X ) + h ( Y ) - h ( X , Y ) } } \\ { { \ = \log [ 2 \pi e \sigma ^ { 2 } ] - \displaystyle \frac { 1 } { 2 } \log [ ( 2 \pi e ) ^ { 2 } \sigma ^ { 4 } ( 1 - \rho ^ { 2 } ) ] } } \\ { { \ = \displaystyle \frac { 1 } { 2 } \log [ ( 2 \pi e \sigma ^ { 2 } ) ^ { 2 } ] - \displaystyle \frac { 1 } { 2 } \log [ ( 2 \pi e \sigma ^ { 2 } ) ^ { 2 } ( 1 - \rho ^ { 2 } ) ] } } \\ { { \ = \displaystyle \frac { 1 } { 2 } \log \displaystyle \frac { 1 } { 1 - \rho ^ { 2 } } = - \displaystyle \frac { 1 } { 2 } \log [ 1 - \rho ^ { 2 } ] } } \end{array}
$$

We now discuss some interesting special cases.

1. $\rho = 1$ . In this case, $X = Y$ , and $I ( X , Y ) = \infty$ , which makes sense. Observing $Y$ tells us an infinite amount of information about $X$ (as we know its real value exactly).   
2. $\rho = 0$ . In this case, $X$ and $Y$ are independent, and $I ( X , Y ) = 0$ , which makes sense. Observing $Y$ tells us nothing about $X$ .   
3. $\rho = - 1$ . In this case, $X = - Y$ , and $I ( X , Y ) = \infty$ , which again makes sense. Observing $Y$ allows us to predict $X$ to infinite precision.

Now consider the case where $X$ and $Y$ are scalar, but not jointly Gaussian. In general it can be difficult to compute the mutual information between continuous random variables, because we have to estimate the joint density $p ( X , Y )$ . For scalar variables, a simple approximation is to discretize or quantize them, by dividing the ranges of each variable into bins, and computing how many values fall in each histogram bin [Sco79]. We can then easily compute the MI using the empirical pmf.

Unfortunately, the number of bins used, and the location of the bin boundaries, can have a significant effect on the results. One way to avoid this is to use $K$ -nearest neighbor distances to estimate densities in a non-parametric, adaptive way. This is the basis of the KSG estimator for MI proposed in [KSG04]. This is implemented in the sklearn.feature_selection.mutual_info_regression function. For papers related to this estimator, see [GOV18; HN19].

# 6.3.6 Normalized mutual information

For some applications, it is useful to have a normalized measure of dependence, between 0 and 1. We now discuss one way to construct such a measure.

First, note that

$$
\begin{array} { r } { \mathbb { I } \left( \boldsymbol { X } ; \boldsymbol { Y } \right) = \mathbb { H } \left( \boldsymbol { X } \right) - \mathbb { H } \left( \boldsymbol { X } | \boldsymbol { Y } \right) \leq \mathbb { H } \left( \boldsymbol { X } \right) } \\ { = \mathbb { H } \left( \boldsymbol { Y } \right) - \mathbb { H } \left( \boldsymbol { Y } | \boldsymbol { X } \right) \leq \mathbb { H } \left( \boldsymbol { Y } \right) } \end{array}
$$

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

$$
0 \leq \mathbb { I } \left( X ; Y \right) \leq \operatorname* { m i n } \left( \mathbb { H } \left( X \right) , \mathbb { H } \left( Y \right) \right)
$$

Therefore we can define the normalized mutual information as follows:

$$
N M I ( X , Y ) = \frac { \mathbb { I } \left( X ; Y \right) } { \operatorname* { m i n } \left( \mathbb { H } \left( X \right) , \mathbb { H } \left( Y \right) \right) } \leq 1
$$

This normalized mutual information ranges from 0 to 1. When $N M I ( X , Y ) = 0$ , we have $\mathbb { I } \left( X ; Y \right) = 0$ , so $X$ and $Y$ are independent. When $N M I ( X , Y ) = 1$ , and $\mathbb { H } \left( X \right) < \mathbb { H } \left( Y \right)$ , we have

$$
\operatorname { I } \left( X ; Y \right) = \operatorname { \mathbb { H } } \left( X \right) - \operatorname { \mathbb { H } } \left( X | Y \right) = \operatorname { \mathbb { H } } \left( X \right) \implies \operatorname { \mathbb { H } } \left( X | Y \right) = 0
$$

and so $X$ is a deterministic function of $Y$ . For example, suppose $X$ is a discrete random variable with pmf [0.5, 0.25, 0.25]. We have $M I ( X , X ) = 1 . 5$ (using log base 2), and $H ( X ) = 1 . 5$ , so the normalized MI is $^ { 1 }$ , as is to be expected.

For continuous random variables, it is harder to normalize the mutual information, because of the need to estimate the differential entropy, which is sensitive to the level of quantization. See Section 6.3.7 for further discussion.

# 6.3.7 Maximal information coefficient

As we discussed in Section 6.3.6, it is useful to have a normalized estimate of the mutual information, but this can be tricky to compute for real-valued data. One approach, known as the maximal information coefficient (MIC) [Res+11], is to define the following quantity:

$$
\operatorname { M I C } ( X , Y ) = \operatorname* { m a x } _ { G } { \frac { \mathbb { I } ( ( X , Y ) | _ { G } ) } { \log | | G | | } }
$$

where $G$ is the set of 2d grids, and $( X , Y ) | _ { G }$ represents a discretization of the variables onto this grid, and $| | G | |$ is $\operatorname* { m i n } ( G _ { x } , G _ { y } )$ , where $G _ { x }$ is the number of grid cells in the $x$ direction, and $G _ { y }$ is the number of grid cells in the $y$ direction. (The maximum grid resolution depends on the sample size $n$ ; they suggest restricting grids so that $G _ { x } G _ { y } \leq B ( n )$ , where $B ( n ) = n ^ { \alpha }$ , where $\alpha = 0 . 6$ .) The denominator is the entropy of a uniform joint distribution; dividing by this ensures $0 \leq \mathrm { M I C } \leq 1$ .

The intuition behind this statistic is the following: if there is a relationship between $X$ and $Y$ , then there should be some discrete gridding of the 2d input space that captures this. Since we don’t know the correct grid to use, MIC searches over different grid resolutions (e.g., 2x2, 2x3, etc), as well as over locations of the grid boundaries. Given a grid, it is easy to quantize the data and compute MI. We define the characteristic matrix $M ( k , l )$ to be the maximum MI achievable by any grid of size $( k , l )$ , normalized by $\log ( \operatorname* { m i n } ( k , l ) )$ . The MIC is then the maximum entry in this matrix, $\mathrm { m a x } _ { k l \le B ( n ) } M ( k , l )$ . See Figure 6.5 for a visualization of this process.

In [Res+11], they show that this quantity exhibits a property known as equitability, which means that it gives similar scores to equally noisy relationships, regardless of the type of relationship (e.g., linear, non-linear, non-functional).

In [Res+16], they present an improved estimator, called MICe, which is more efficient to compute, and only requires optimizing over 1d grids, which can be done in $O ( n )$ time using dynamic programming. They also present another quantity, called TICe (total information content), that has higher

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license power to detect relationships from small sample sizes, but lower equitability. This is defined to be $\begin{array} { r } { \sum _ { k l \leq B ( n ) } M ( k , l ) } \end{array}$ . They recommend using TICe to screen a large number of candidate relationships, and then using MICe to quantify the strength of the relationship. For an efficient implementation of both of these metrics, see [Alb+18].

![](images/af6697b8c62c625ae90a2f78f89825b4fa999d117cdb1bb930e001e9c6f870e0.jpg)  
Figure 6.5: Illustration of how the maximal information coefficient (MIC) is computed. (a) We search over different grid resolutions, and grid cell locations, and compute the MI for each. (b) For each grid resolution $( k , l )$ , we define set $M ( k , l )$ to be the maximum MI for any grid of that size, normalized by $\log ( \operatorname* { m i n } ( k , l ) )$ . (c) We visualize the matrix M. The maximum entry (denoted by a star) is defined to be the MIC. From Figure 1 of [Res+11]. Used with kind permission of David Reshef.

![](images/0e7cff8acd279256862c9c69a2d388cb7f35109d01c682ca1bb432fcdcdb2b6a.jpg)  
Figure 6.6: Plots of some 2d distributions and the corresponding estimate of correlation coefficient $R ^ { 2 }$ and the maximal information coefficient (MIC). Compare to Figure 3.1. Generated by $M I C _ { - }$ correlation_2d.ipynb.

We can interpret MIC of $0$ to mean there is no relationship between the variables, and 1 to represent a noise-free relationship of any form. This is illustrated in Figure 6.6. Unlike correlation coefficients, MIC is not restricted to finding linear relationships. For this reason, the MIC has been called “a correlation for the 21st century” [Spe11].

In Figure 6.7, we give a more interesting example, from [Res+11]. The data consists of 357 variables measuring a variety of social, economic, health and political indicators, collected by the World Health Organization (WHO). On the left of the figure, we see the correlation coefficient (CC) plotted against

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022 the MIC for all 63,546 variable pairs. On the right of the figure, we see scatter plots for particular pairs of variables, which we now discuss:

![](images/38fd2ded7096ead292194ef48180269fefb21f565eb56d75fa813a736089bf1f.jpg)  
Figure 6.7: Left: Correlation coefficient vs maximal information criterion (MIC) for all pairwise relationships in the WHO data. Right: scatter plots of certain pairs of variables. The red lines are non-parametric smoothing regressions fit separately to each trend. From Figure 4 of [Res+11]. Used with kind permission of David Reshef.

• The point marked C (near 0,0 on the plot) has a low CC and a low MIC. The corresponding scatter plot makes it clear that there is no relationship between these two variables (percentage of lives lost to injury and density of dentists in the population).   
• The points marked D and H have high CC (in absolute value) and high MIC, because they represent nearly linear relationships.   
• The points marked E, F, and G have low CC but high MIC. This is because they correspond to non-linear (and sometimes, as in the case of $\mathrm { E }$ and F, non-functional, i.e., one-to-many) relationships between the variables.

# 6.3.8 Data processing inequality

Suppose we have an unknown variable $X$ , and we observe a noisy function of it, call it $Y$ . If we process the noisy observations in some way to create a new variable $Z$ , it should be intuitively obvious that we cannot increase the amount of information we have about the unknown quantity, $X$ . This is known as the data processing inequality. We now state this more formally, and then prove it.

Theorem 6.3.1. Suppose $X  Y  Z$ forms a Markov chain, so that $X \perp Z | Y$ . Then $\mathbb { I } \left( X ; Y \right) \geq$ $\mathbb { I } \left( X ; Z \right)$ .

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

Proof. By the chain rule for mutual information (Equation (6.62)), we can expand the mutual information in two different ways:

$$
\begin{array} { r } { \mathbb { I } \left( X ; Y , Z \right) = \mathbb { I } \left( X ; Z \right) + \mathbb { I } \left( X ; Y | Z \right) } \\ { = \mathbb { I } \left( X ; Y \right) + \mathbb { I } \left( X ; Z | Y \right) } \end{array}
$$

Since $X \perp Z | Y$ , we have $\mathbb { I } \left( X ; Z | Y \right) = 0$ , so

$$
\mathbb { I } \left( X ; Z \right) + \mathbb { I } \left( X ; Y | Z \right) = \mathbb { I } \left( X ; Y \right)
$$

Since $\mathbb { I } \left( X ; Y | Z \right) \ge 0$ , we have $\mathbb { I } \left( X ; Y \right) \ge \mathbb { I } \left( X ; Z \right)$ . Similarly one can prove that $\mathbb { I } \left( Y ; Z \right) \ge \mathbb { I } \left( X ; Z \right)$ . □

# 6.3.9 Sufficient Statistics

An important consequence of the DPI is the following. Suppose we have the chain $\theta \to { \mathcal { D } } \to s ( { \mathcal { D } } )$ . Then

$$
\mathbb { I } \left( \theta ; s ( \mathcal { D } ) \right) \le \mathbb { I } \left( \theta ; \mathcal { D } \right)
$$

If this holds with equality, then we say that $s ( \mathcal D )$ is a sufficient statistic of the data $\mathcal { D }$ for the purposes of inferring $\theta$ . In this case, we can equivalently write $\theta \ :  \ : s ( \mathcal { D } )  \mathcal { D }$ , since we can reconstruct the data from knowing $s ( \mathcal D )$ just as accurately as from knowing $\theta$ .

An example of a sufficient statistic is the data itself, $s ( \mathcal { D } ) = \mathcal { D }$ , but this is not very useful, since it doesn’t summarize the data at all. Hence we define a minimal sufficient statistic $s ( \mathcal D )$ as one which is sufficient, and which contains no extra information about $\theta$ ; thus $s ( \mathcal D )$ maximally compresses the data $\mathcal { D }$ without losing information which is relevant to predicting $\theta$ . More formally, we say $s$ is a minimal sufficient statistic for $\mathcal { D }$ if for all sufficient statistics $s ^ { \prime } ( \mathcal { D } )$ there is some function $f$ such that $s ( \mathcal D ) = f ( s ^ { \prime } ( \mathcal D ) )$ . We can summarize the situation as follows:

$$
\theta  s ( \mathcal { D } )  s ^ { \prime } ( \mathcal { D } )  \mathcal { D }
$$

Here $s ^ { \prime } ( \mathcal { D } )$ takes $s ( \mathcal D )$ and adds redundant information to it, thus creating a one-to-many mapping. For example, a minimal sufficient statistic for a set of $N$ Bernoulli trials is simply $N$ and $N _ { 1 } =$ $\begin{array} { r } { \sum _ { n } \mathbb { I } \left( X _ { n } = 1 \right) } \end{array}$ , i.e., the number of successes. In other words, we don’t need to keep track of the entire sequence of heads and tails and their ordering, we only need to keep track of the total number of heads and tails. Similarly, for inferring the mean of a Gaussian distribution with known variance we only need to know the empirical mean and number of samples.

# 6.3.10 Fano’s inequality \*

A common method for feature selection is to pick input features $X _ { d }$ which have high mutual information with the response variable $Y$ . Below we justify why this is a reasonable thing to do. In particular, we state a result, known as Fano’s inequality, which bounds the probability of misclassification (for any method) in terms of the mutual information between the features $X$ and the class label $Y$ .

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

Theorem 6.3.2. (Fano’s inequality) Consider an estimator ${ \hat { Y } } = f ( X )$ such that $Y  X  { \hat { Y } }$ forms a Markov chain. Let $E$ be the event $\hat { Y } \neq Y$ , indicating that an error occured, and let $P _ { e } = P ( Y \neq \hat { Y } )$ be the probability of error. Then we have

$$
\mathbb { H } \left( Y | X \right) \leq \mathbb { H } \left( Y | \hat { Y } \right) \leq \mathbb { H } \left( E \right) + P _ { e } \log \left| \mathcal { V } \right|
$$

Since $\mathbb { H } \left( E \right) \leq 1$ , as we saw in Figure 6.1, we can weaken this result to get

$$
1 + P _ { e } \log | \mathcal { V } | \geq \mathbb { H } \left( Y | X \right)
$$

and hence

$$
P _ { e } \geq \frac { \mathbb { H } \left( Y | X \right) - 1 } { \log | \mathcal { V } | }
$$

Thus minimizing $\mathbb { H } \left( Y | X \right)$ (which can be done by maximizing $\mathbb { I } ( X ; Y )$ ) will also minimize the lower bound on $P _ { e }$ .

Proof. (From [CT06, p38].) Using the chain rule for entropy, we have

$$
\begin{array} { r } { \mathbb { H } \left( E , Y | \hat { Y } \right) = \mathbb { H } \left( Y | \hat { Y } \right) + \underbrace { \mathbb { H } \left( E | Y , \hat { Y } \right) } _ { = 0 } } \\ { = \mathbb { H } \left( E | \hat { Y } \right) + \mathbb { H } \left( Y | E , \hat { Y } \right) } \end{array}
$$

Since conditioning reduces entropy (see Section 6.2.4), we have $\mathbb { H } \left( E | \hat { Y } \right) \leq \mathbb { H } \left( E \right)$ . The final term can be bounded as follows:

$$
\begin{array} { r l } & { \mathbb { H } \left( Y | E , \hat { Y } \right) = P ( E = 0 ) \mathbb { H } \left( Y | \hat { Y } , E = 0 \right) + P ( E = 1 ) \mathbb { H } \left( Y | \hat { Y } , E = 1 \right) } \\ & { \qquad \leq ( 1 - P _ { e } ) 0 + P _ { e } \log | \mathcal { Y } | } \end{array}
$$

Hence

$$
\mathbb { H } \left( Y | \hat { Y } \right) \leq \underbrace { \mathbb { H } \left( E | \hat { Y } \right) } _ { \leq \mathbb { H } \left( E \right) } + \underbrace { \mathbb { H } \left( Y | E , \hat { Y } \right) } _ { P _ { e } \log | \mathcal { V } | }
$$

Finally, by the data processing inequality, we have $\mathbb { I } ( Y ; \hat { Y } ) \leq \mathbb { I } ( Y ; X )$ , so $\mathbb { H } \left( Y | X \right) \leq \mathbb { H } \left( Y | \hat { Y } \right)$ , which establishes Equation (6.82). □

# 6.4 Exercises

Exercise 6.1 [Expressing mutual information in terms of entropies \*] Prove the following identities:

$$
I ( X ; Y ) = H ( X ) - H ( X | Y ) = H ( Y ) - H ( Y | X )
$$

and

$$
H ( X , Y ) = H ( X | Y ) + H ( Y | X ) + I ( X ; Y )
$$

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

Exercise 6.2 [Relationship between $D ( p | | q )$ and $\chi ^ { 2 }$ statistic] (Source: [CT91, Q12.2].)

Show that, if $p ( x ) \approx q ( x )$ , then

$$
D _ { \mathbb { K L } } \left( p \parallel q \right) \approx \frac { 1 } { 2 } \chi ^ { 2 }
$$

where

$$
\chi ^ { 2 } = \sum _ { x } \frac { ( p ( x ) - q ( x ) ) ^ { 2 } } { q ( x ) }
$$

Hint: write

$$
\begin{array} { l } { \displaystyle p ( \boldsymbol { x } ) = \Delta ( x ) + q ( \boldsymbol { x } ) } \\ { \displaystyle \frac { p ( \boldsymbol { x } ) } { q ( \boldsymbol { x } ) } = 1 + \frac { \Delta ( \boldsymbol { x } ) } { q ( \boldsymbol { x } ) } } \end{array}
$$

and use the Taylor series expansion for $\log ( 1 + x )$ .

$$
\log ( 1 + x ) = x - { \frac { x ^ { 2 } } { 2 } } + { \frac { x ^ { 3 } } { 3 } } - { \frac { x ^ { 4 } } { 4 } } \cdot \cdot \cdot
$$

for $- 1 < x \leq 1$ .

Exercise 6.3 [Fun with entropies \*]

(Source: Mackay.) Consider the joint distribution $p ( X , Y )$

<html><body><table><tr><td></td><td>x 1 2</td><td>3</td><td>4</td></tr><tr><td rowspan="3">1 y2</td><td>1/8 1/16</td><td>1/32</td><td>1/32</td></tr><tr><td>1/16</td><td>1/8</td><td>1/32 1/32</td></tr><tr><td>3</td><td>1/16</td><td>1/16</td></tr><tr><td>4</td><td>1/16 1/4 0</td><td>1/16 0</td><td>0</td></tr></table></body></html>

a. What is the joint entropy $H ( X , Y )$ ?

b. What are the marginal entropies $H ( X )$ and $H ( Y )$ ? c. The entropy of $X$ conditioned on a specific value of $y$ is defined as

$$
H ( X | Y = y ) = - \sum _ { x } p ( x | y ) \log p ( x | y )
$$

Compute $H ( X | y )$ for each value of $y$ . Does the posterior entropy on $X$ ever increase given an observation of $Y$ ?

d. The conditional entropy is defined as

$$
H ( X | Y ) = \sum _ { y } p ( y ) H ( X | Y = y )
$$

Compute this. Does the posterior entropy on $X$ increase or decrease when averaged over the possible values of $Y$ ?

e. What is the mutual information between $X$ and $Y$ ?

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

Exercise 6.4 [Forwards vs reverse KL divergence]

(Source: Exercise 33.7 of [Mac03].) Consider a factored approximation $q ( x , y ) = q ( x ) q ( y )$ to a joint distribution $p ( x , y )$ . Show that to minimize the forwards KL $D _ { \mathbb { K L } } \left( p \parallel q \right)$ we should set $q ( x ) = p ( x )$ and $q ( y ) = p ( y )$ , i.e., the optimal approximation is a product of marginals

Now consider the following joint distribution, where the rows represent $y$ and the columns $x$ .

<html><body><table><tr><td></td><td>1 2</td><td>3</td><td>4</td></tr><tr><td>1</td><td>1/8 1/8</td><td>0</td><td>0</td></tr><tr><td>2</td><td>1/8 1/8</td><td>0</td><td>0</td></tr><tr><td>3</td><td>0 0</td><td>1/4</td><td>0</td></tr><tr><td>4</td><td>0 0</td><td>0</td><td>1/4</td></tr></table></body></html>

Show that the reverse KL $D _ { \mathbb { K L } } \left( q \parallel p \right)$ for this $p$ has three distinct minima. Identify those minima and evaluate $D _ { \mathbb { K L } } \left( q \parallel p \right)$ at each of them. What is the value of $D _ { \mathbb { K L } } \left( q \parallel p \right)$ if we set $q ( x , y ) = p ( x ) p ( y ) ^ { * }$ ?

# 7 Linear Algebra

This chapter is co-authored with Zico Kolter.

# 7.1 Introduction

Linear algebra is the study of matrices and vectors. In this chapter, we summarize the key material that we will need throughout the book. Much more information can be found in other sources, such as [Str09; Ips09; Kle13; Mol04; TB97; Axl15; Tho17; Agg20].

# 7.1.1 Notation

In this section, we define some notation.

# 7.1.1.1 Vectors

A vector $\pmb { x } \in \mathbb { R } ^ { n }$ is a list of $n$ numbers, usually written as a column vector

$$
\begin{array} { r } { \pmb { x } = \left[ \begin{array} { c } { x _ { 1 } } \\ { x _ { 2 } } \\ { \vdots } \\ { x _ { n } } \end{array} \right] . } \end{array}
$$

The vector of all ones is denoted 1. The vector of all zeros is denoted 0. The unit vector $e _ { i }$ is a vector of all $0$ ’s, except entry $i$ , which has value 1:

$$
\pmb { e } _ { i } = ( 0 , \dots , 0 , 1 , 0 , \dots , 0 )
$$

This is also called a one-hot vector.

# 7.1.1.2 Matrices

A matrix $\mathbf { A } \in \mathbb { R } ^ { m \times n }$ with $m$ rows and $n$ columns is a 2d array of numbers, arranged as follows:

$$
\mathbf { A } = \left[ \begin{array} { c c c c } { a _ { 1 1 } } & { a _ { 1 2 } } & { \cdot \cdot \cdot } & { a _ { 1 n } } \\ { a _ { 2 1 } } & { a _ { 2 2 } } & { \cdot \cdot \cdot } & { a _ { 2 n } } \\ { \vdots } & { \vdots } & { \ddots } & { \vdots } \\ { a _ { m 1 } } & { a _ { m 2 } } & { \cdot \cdot \cdot } & { a _ { m n } } \end{array} \right] .
$$

If $m = n$ , the matrix is said to be square.

We use the notation $A _ { i j }$ or $A _ { i , j }$ to denote the entry of $\mathbf { A }$ in the $i$ th row and $j$ th column. We use the notation $\mathbf { A } _ { i } ,$ : to denote the $i$ ’th row and A: $, j$ to denote the $j$ ’th column. We treat all vectors as column vectors by default (so $\mathbf { A } _ { i } ,$ : is viewed as a column vector with $n$ entries). We use bold upper case letters to denote matrices, bold lower case letters to denote vectors, and non-bold letters to denote scalars.

We can view a matrix as a set of columns stacked along the horizontal axis:

$$
\mathbf { A } = \left[ \begin{array} { c c c c } { | } & { | } & & { | } \\ { \mathbf { A } _ { : , 1 } } & { \mathbf { A } _ { : , 2 } } & { \cdots } & { \mathbf { A } _ { : , n } } \\ { | } & { | } & & { | } \end{array} \right] .
$$

For brevity, we will denote this by

$$
\mathbf { A } = [ \mathbf { A } _ { : , 1 } , \mathbf { A } _ { : , 2 } , \ldots , \mathbf { A } _ { : , n } ]
$$

We can also view a matrix as a set of rows stacked along the vertical axis:

$$
\mathbf { A } = \left[ { \begin{array} { c c c } { - } & { \mathbf { A } _ { 1 , : } ^ { \mathsf { T } } } & { - } \\ { - } & { \mathbf { A } _ { 2 , : } ^ { \mathsf { T } } } & { - } \\ & { \vdots } \\ { - } & { \mathbf { A } _ { m , : } ^ { \mathsf { T } } } & { - } \end{array} } \right] .
$$

For brevity, we will denote this by

$$
\mathbf { A } = [ \mathbf { A } _ { 1 , : } ; \mathbf { A } _ { 2 , : } ; . . . ; \mathbf { A } _ { m , : } ]
$$

(Note the use of a semicolon.)

The transpose of a matrix results from “flipping” the rows and columns. Given a matrix $\mathbf { A } \in \mathbb { R } ^ { m \times n }$ , its transpose, written $\mathbf { A } ^ { \top } \in \mathbb { R } ^ { n \times m }$ , is defined as

$$
( \mathbf { A } ^ { \mathsf { T } } ) _ { i j } = A _ { j i }
$$

The following properties of transposes are easily verified:

$$
\begin{array} { c } { ( \mathbf { A } ^ { \mathsf { T } } ) ^ { \mathsf { T } } = \mathbf { A } } \\ { ( \mathbf { A } \mathbf { B } ) ^ { \mathsf { T } } = \mathbf { B } ^ { \mathsf { T } } \mathbf { A } ^ { \mathsf { T } } } \\ { ( \mathbf { A } + \mathbf { B } ) ^ { \mathsf { T } } = \mathbf { A } ^ { \mathsf { T } } + \mathbf { B } ^ { \mathsf { T } } } \end{array}
$$

If a square matrix satisfies $\mathbf { A } = \mathbf { A } ^ { \mathsf { I } }$ , it is called symmetric. We denote the set of all symmetric matrices of size $n$ as $\mathbb { S } ^ { n }$ .

# 7.1.1.3 Tensors

A tensor (in machine learning terminology) is just a generalization of a 2d array to more than 2 dimensions, as illustrated in Figure 7.1. For example, the entries of a 3d tensor are denoted by $A _ { i j k }$ .

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

![](images/f4b53291773b431dab130f50d24c9b63686c4587041b8a71121562edb654eade.jpg)  
Figure 7.1: Illustration of a 1d vector, 2d matrix, and 3d tensor. The colors are used to represent individual entries of the vector; this list of numbers can also be stored in a 2d matrix, as shown. (In this example, the matrix is layed out in column-major order, which is the opposite of that used by Python.) We can also reshape the vector into a 3d tensor, as shown.

![](images/f52f69d0bfc3b4e7d94102b4bcf4923632baec1e0d9f462fef839b98be3f050d.jpg)  
Figure 7.2: Illustration of (a) row-major vs (b) column-major order. From https: // commons. wikimedia. org/ wiki/ File: Row_ and_ column_ major_ order. svg . Used with kind permission of Wikipedia author Cmglee.

The number of dimensions is known as the order or rank of the tensor.1 In mathematics, tensors can be viewed as a way to define multilinear maps, just as matrices can be used to define linear functions, although we will not need to use this interpretation.

We can reshape a matrix into a vector by stacking its columns on top of each other, as shown in Figure 7.1. This is denoted by

$$
\operatorname { v e c } ( \mathbf { A } ) = [ \mathbf { A } _ { : , 1 } ; \cdot \cdot \cdot ; \mathbf { A } _ { : , n } ] \in \mathbb { R } ^ { m n \times 1 }
$$

Conversely, we can reshape a vector into a matrix. There are two choices for how to do this, known as row-major order (used by languages such as Python and C++) and column-major order (used by languages such as Julia, Matlab, R and Fortran). See Figure 7.2 for an illustration of the difference.

![](images/ff25c9b41a2da20fbaa7cf3d3c8b45ebcd69b3c6163737001a369404a8d2b4c4.jpg)  
Figure 7.3: (a) Top: A vector $\boldsymbol { v }$ (blue) is added to another vector w (red). Bottom: w is stretched by a factor of 2, yielding the sum $\pmb { v } + 2 \pmb { w }$ . From https: // en. wikipedia. org/ wiki/ Vector_ space . Used with kind permission of Wikipedia author IkamusumeFan (b) $A$ vector $_ v$ in $\mathbb { R } ^ { 2 }$ (blue) expressed in terms of different bases: using the standard basis of $\mathbb { R } ^ { 2 }$ , $\pmb { v } = x \pmb { e } _ { 1 } + y \pmb { e } _ { 2 }$ (black), and using a different, non-orthogonal basis: ${ \pmb v } = { \pmb f } _ { 1 } + { \pmb f } _ { 2 }$ (red). From https: // en. wikipedia. org/ wiki/ Vector_ space . Used with kind permission of Wikiepdia author Jakob.scholbach.

# 7.1.2 Vector spaces

In this section, we discuss some fundamental concepts in linear algebra.

# 7.1.2.1 Vector addition and scaling

We can view a vector $\pmb { x } \in \mathbb { R } ^ { n }$ as defining a point in $n$ -dimensional Euclidean space. A vector space is a collection of such vectors, which can be added together, and scaled by scalars (1-dimensional numbers), in order to create new points. These operations are defined to operate elementwise, in the obvious way, namely $\pmb { x } + \pmb { y } = ( x _ { 1 } + y _ { 1 } , \dots , x _ { n } + y _ { n } )$ and $c { \pmb x } = ( c x _ { 1 } , \ldots , c x _ { n } )$ , where $c \in \mathbb { R }$ . See Figure 7.3a for an illustration.

# 7.1.2.2 Linear independence, spans and basis sets

A set of vectors $\{ \pmb { x } _ { 1 } , \pmb { x } _ { 2 } , \ldots \pmb { x } _ { n } \}$ is said to be (linearly) independent if no vector can be represented as a linear combination of the remaining vectors. Conversely, a vector which can be represented as a linear combination of the remaining vectors is said to be (linearly) dependent. For example, if

$$
\pmb { x } _ { n } = \sum _ { i = 1 } ^ { n - 1 } \alpha _ { i } \pmb { x } _ { i }
$$

for some $\{ \alpha _ { 1 } , \dotsc , \alpha _ { n - 1 } \}$ then ${ \boldsymbol { \mathbf { \mathit { x } } } } _ { n }$ is dependent on $\{ \pmb { x } _ { 1 } , \ldots , \pmb { x } _ { n - 1 } \}$ ; otherwise, it is independent of $\{ \pmb { x } _ { 1 } , \dotsc , \pmb { x } _ { n - 1 } \}$ .

The span of a set of vectors $\{ \pmb { x } _ { 1 } , \pmb { x } _ { 2 } , \dots , \pmb { x } _ { n } \}$ is the set of all vectors that can be expressed as a linear combination of $\{ \pmb { x } _ { 1 } , \ldots , \pmb { x } _ { n } \}$ . That is,

$$
\operatorname { s p a n } ( \{ \mathbf { x } _ { 1 } , \dots , \mathbf { x } _ { n } \} ) \triangleq \left\{ { \pmb { v } } : { \pmb { v } } = \sum _ { i = 1 } ^ { n } \alpha _ { i } \mathbf { x } _ { i } , \alpha _ { i } \in \mathbb { R } \right\} .
$$

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

It can be shown that if $\{ \pmb { x } _ { 1 } , \hdots , \pmb { x } _ { n } \}$ is a set of $n$ linearly independent vectors, where each $\pmb { x } _ { i } \in \mathbb { R } ^ { n }$ , then $\operatorname { s p a n } ( \{ \pmb { x } _ { 1 } , \ldots , \pmb { x } _ { n } \} ) = \mathbb { R } ^ { n }$ . In other words, any vector $\pmb { v } \in \mathbb { R } ^ { n }$ can be written as a linear combination of ${ \bf { x } } _ { 1 }$ through ${ \boldsymbol { \mathbf { \mathit { x } } } } _ { n }$ .

A basis $\boldsymbol { B }$ is a set of linearly independent vectors that spans the whole space, meaning that $\operatorname { s p a n } ( B ) = \mathbb { R } ^ { n }$ . There are often multiple bases to choose from, as illustrated in Figure 7.3b. The standard basis uses the coordinate vectors $\pmb { e } _ { 1 } = ( 1 , 0 , \dots , 0 )$ , up to $\pmb { e } _ { n } = ( 0 , 0 , \ldots , 0 , 1 )$ . This lets us translate back and forth between viewing a vector in $\mathbb { R } ^ { 2 }$ as an either an “arrow in the plane”, rooted at the origin, or as an ordered list of numbers (corresponding to the coefficients for each basis vector).

# 7.1.2.3 Linear maps and matrices

A linear map or linear transformation is any function $f : \mathcal { V } \to \mathcal { W }$ such that $f ( { \pmb v } + { \pmb w } ) =$ $f ( \pmb { v } ) + f ( \pmb { w } )$ and $f ( a \ v ) = a \ f ( { \pmb v } )$ for all $\pmb { v } , \pmb { w } \in \mathcal { V }$ . Once the basis of $\nu$ is chosen, a linear map $f : \mathcal { V } \to \mathcal { W }$ is completely determined by specifying the images of the basis vectors, because any element of $\nu$ can be expressed uniquely as a linear combination of them.

Suppose $\nu = \mathbb { R } ^ { n }$ and $\mathcal { W } = \mathbb { R } ^ { m }$ . We can compute $f ( \pmb { v } _ { i } ) \in \mathbb { R } ^ { m }$ for each basis vector in $\nu$ , and store these along the columns of an $m \times n$ matrix A. We can then compute $\pmb { y } = f ( \pmb { x } ) \in \mathbb { R } ^ { m }$ for any $\pmb { x } \in \mathbb { R } ^ { n }$ as follows:

$$
{ \pmb y } = \left( \sum _ { j = 1 } ^ { n } a _ { 1 j } x _ { j } , \ldots , \sum _ { j = 1 } ^ { n } a _ { m j } x _ { j } \right)
$$

This corresponds to multiplying the vector $_ { x }$ by the matrix A:

$$
\pmb { y } = \mathbf { A } \pmb { x }
$$

See Section 7.2 for more details.

If the function is invertible, we can write

$$
\pmb { x } = \mathbf { A } ^ { - 1 } \pmb { y }
$$

See Section 7.3 for details.

# 7.1.2.4 Range and nullspace of a matrix

Suppose we view a matrix $\mathbf { A } \in \mathbb { R } ^ { m \times n }$ as a set of $n$ vectors in $\mathbb { R } ^ { m }$ . The range (sometimes also called the column space) of this matrix is the span of the columns of A. In other words,

$$
\operatorname { r a n g e } ( \mathbf { A } ) \triangleq \{ \pmb { v } \in \mathbb { R } ^ { m } : \pmb { v } = \mathbf { A } \pmb { x } , \pmb { x } \in \mathbb { R } ^ { n } \} .
$$

This can be thought of as the set of vectors that can be “reached” or “generated” by A; it is a subspace of $\mathbb { R } ^ { m }$ whose dimensionality is given by the rank of $\mathbf { A }$ (see Section 7.1.4.3). The nullspace of a matrix $\mathbf { A } \in \mathbb { R } ^ { m \times n }$ is the set of all vectors that get mapped to the null vector when multiplied by $\mathbf { A }$ , i.e.,

$$
\mathrm { n u l l s p a c e } ( \mathbf { A } ) \triangleq \{ \pmb { x } \in \mathbb { R } ^ { n } : \mathbf { A } \pmb { x } = \mathbf { 0 } \} .
$$

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

![](images/bf235f30428c8fe521d8763ab2e7a76c777123ac7b038dd16f1ffd533f80d3f6.jpg)  
Figure 7.4: Visualization of the nullspace and range of an $m \times n$ matrix A. Here $\pmb { y } _ { 1 } = \mathbf { A } \pmb { x } _ { 1 }$ and $\pmb { y } _ { 2 } = \mathbf { A } \pmb { x } _ { 4 }$ , so y1 and y2 are in the range of A (are reachable from some $\textbf { \em x }$ ). Also $\mathbf { A } \mathbf { x } _ { 2 } = \mathbf { 0 }$ and $\mathbf { A } { \pmb x } _ { 3 } = \mathbf { 0 }$ , so $\scriptstyle { \pmb x } _ { 2 }$ and $\pmb { x } _ { 3 }$ are in the nullspace of A (get mapped to $\boldsymbol { \theta }$ ). We see that the range is often a subset of the input domain of the mapping.

The span of the rows of A is the complement to the nullspace of A

See Figure 7.4 for an illustration of the range and nullspace of a matrix. We shall discuss how to compute the range and nullspace of a matrix numerically in Section 7.5.4 below.

# 7.1.2.5 Linear projection

The projection of a vector $\pmb { y } \in \mathbb { R } ^ { m }$ onto the span of $\{ \pmb { x } _ { 1 } , \ldots , \pmb { x } _ { n } \}$ (here we assume $\pmb { x } _ { i } \in \mathbb { R } ^ { m }$ ) is the vector ${ \pmb v } \in \operatorname { s p a n } ( \{ { \pmb x } _ { 1 } , \dots , { \pmb x } _ { n } \} )$ , such that $_ { v }$ is as close as possible to $\textbf {  { y } }$ , as measured by the Euclidean norm $\| { \pmb v } - { \pmb y } \| _ { 2 }$ . We denote the projection as $\operatorname { P r o j } ( \pmb { y } ; \{ \pmb { x } _ { 1 } , \dots , \pmb { x } _ { n } \} )$ and can define it formally as

$$
\operatorname { P r o j } ( y ; \{ \pmb { x } _ { 1 } , \dots , \pmb { x } _ { n } \} ) = \operatorname { a r g m i n } _ { \pmb { v } \in \operatorname { s p a n } ( \{ \pmb { x } _ { 1 } , \dots , \pmb { x } _ { n } \} ) } \| \pmb { y } - \pmb { v } \| _ { 2 } .
$$

Given a (full rank) matrix $\mathbf { A } \in \mathbb { R } ^ { m \times n }$ with $m \geq n$ , we can define the projection of a vector $\pmb { y } \in \mathbb { R } ^ { m }$ onto the range of $\mathbf { A }$ as follows:

$$
\begin{array} { r } { \mathrm { P r o j } ( \pmb { y } ; \mathbf { A } ) = \operatorname * { a r g m i n } _ { \pmb { v } \in \mathcal { R } ( \mathbf { A } ) } \| \pmb { v } - \pmb { y } \| _ { 2 } = \mathbf { A } ( \mathbf { A } ^ { \top } \mathbf { A } ) ^ { - 1 } \mathbf { A } ^ { \top } \pmb { y } } \end{array} .
$$

These are the same as the normal equations from Section 11.2.2.2.

# 7.1.3 Norms of a vector and matrix

In this section, we discuss ways of measuring the “size” of a vector and matrix.

# 7.1.3.1 Vector norms

A norm of a vector $\| \pmb { x } \|$ is, informally, a measure of the “length” of the vector. More formally, a norm is any function $f : \mathbb { R } ^ { n }  \mathbb { R }$ that satisfies 4 properties:

• For all $\pmb { x } \in \mathbb { R } ^ { n }$ , $f ( { \pmb x } ) \geq 0$ (non-negativity).

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

• $f ( { \pmb x } ) = 0$ if and only if $\mathbf { \boldsymbol { x } } = \mathbf { \boldsymbol { 0 } }$ (definiteness).

For all $\pmb { x } \in \mathbb { R } ^ { n }$ , $t \in \mathbb R$ , $f ( t { \mathbf { } } x ) = | t | f ( x )$ (absolute value homogeneity).

• For all $\pmb { x } , \pmb { y } \in \mathbb { R } ^ { n }$ , $f ( { \pmb x } + { \pmb y } ) \leq f ( { \pmb x } ) + f ( { \pmb y } )$ (triangle inequality).

Consider the following common examples:

p-norm $\begin{array} { r } { \| \pmb { x } \| _ { p } = \big ( \sum _ { i = 1 } ^ { n } | x _ { i } | ^ { p } \big ) ^ { 1 / p } } \end{array}$ , for $p \geq 1$ .

2-norm $\begin{array} { r } { \| \pmb { x } \| _ { 2 } = \sqrt { \sum _ { i = 1 } ^ { n } x _ { i } ^ { 2 } } } \end{array}$ , also called Euclidean norm. Note that $\| \pmb { x } \| _ { 2 } ^ { 2 } = \pmb { x } ^ { 1 } \pmb { x }$ .

1-norm $\begin{array} { r } { \| \pmb { x } \| _ { 1 } = \sum _ { i = 1 } ^ { n } \left| x _ { i } \right| } \end{array}$ .

Max-norm $\| \pmb { x } \| _ { \infty } = \operatorname* { m a x } _ { i } | x _ { i } |$ .

0-norm $\begin{array} { r } { \| \pmb { x } \| _ { 0 } = \sum _ { i = 1 } ^ { n } \mathbb { I } \left( | x _ { i } | > 0 \right) } \end{array}$ . This is a pseudo norm, since it does not satisfy homogeneity. It counts the number of non-zero elements in $_ { x }$ . If we define $0 ^ { 0 } = 0$ , we can write this as $\begin{array} { r } { \| \pmb { x } \| _ { 0 } = \sum _ { i = 1 } ^ { n } x _ { i } ^ { 0 } } \end{array}$ .

# 7.1.3.2 Matrix norms

Suppose we think of a matrix $\mathbf { A } \in \mathbb { R } ^ { m \times n }$ as defining a linear function $f ( \pmb { x } ) = \mathbf { A } \pmb { x }$ . We define the induced norm of $\mathbf { A }$ as the maximum amount by which $f$ can lengthen any unit-norm input:

$$
| | \mathbf { A } | | _ { p } = \operatorname* { m a x } _ { \mathbf { x } \neq \mathbf { 0 } } { \frac { | | \mathbf { A } \mathbf { x } | | _ { p } } { | | \mathbf { x } | | _ { p } } } = \operatorname* { m a x } _ { | | \mathbf { x } | | = 1 } | | \mathbf { A } \mathbf { x } | | _ { p }
$$

Typically $p = 2$ , in which case

$$
| | \mathbf { A } | | _ { 2 } = \sqrt { \lambda _ { \operatorname* { m a x } } ( \mathbf { A } ^ { \mathsf { T } } \mathbf { A } ) } = \operatorname* { m a x } _ { i } \sigma _ { i }
$$

where $\sigma _ { i }$ is the $i$ ’th singular value.

The nuclear norm, also called the trace norm, is defined as

$$
\| \mathbf { A } \| _ { * } = \operatorname { t r } ( { \sqrt { \mathbf { A } ^ { \mathsf { T } } \mathbf { A } } } ) = \sum _ { i } \sigma _ { i }
$$

where $\sqrt { \mathbf { A } ^ { \mathsf { T } } \mathbf { A } }$ is the matrix square root. Since the singular values are always non-negative, we have

$$
| | \mathbf { A } | | _ { * } = \sum _ { i } | \sigma _ { i } | = | | \pmb { \sigma } | | _ { 1 }
$$

Using this as a regularizer encourages many singular values to become zero, resulting in a low rank matrix. More generally, we can define the Schatten $p$ -norm as

$$
\| \mathbf { A } \| _ { p } = \left( \sum _ { i } \sigma _ { i } ^ { p } ( \mathbf { A } ) \right) ^ { 1 / p }
$$

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

If we think of a matrix as a vector, we can define the matrix norm in terms of a vector norm, $| | \mathbf { A } | | = | | \mathrm { v e c } ( \mathbf { A } ) | |$ . If the vector norm is the 2-norm, the corresponding matrix norm is the Frobenius norm:

$$
| | \mathbf { A } | | _ { F } = \sqrt { \sum _ { i = 1 } ^ { m } \sum _ { j = 1 } ^ { n } a _ { i j } ^ { 2 } } = \sqrt { \operatorname { t r } ( \mathbf { A } ^ { \mathsf { T } } \mathbf { A } ) } = | | \operatorname { v e c } ( \mathbf { A } ) | | _ { 2 }
$$

If $\mathbf { A }$ is expensive to evaluate, but ${ \bf A } v$ is cheap (for a random vector $_ { v }$ ), we can create a stochastic approximation to the Frobenius norm by using the Hutchinson trace estimator from Equation (7.37) as follows:

$$
| | \mathbf { A } | | _ { F } ^ { 2 } = \operatorname { t r } ( \mathbf { A } ^ { \mathsf { T } } \mathbf { A } ) = \mathbb { E } \left[ v ^ { \mathsf { T } } \mathbf { A } ^ { \mathsf { T } } \mathbf { A } v \right] = \mathbb { E } \left[ | | \mathbf { A } v | | _ { 2 } ^ { 2 } \right]
$$

where $\pmb { v } \sim \mathcal { N } ( \mathbf { 0 } , \mathbf { I } )$ .

# 7.1.4 Properties of a matrix

In this section, we discuss various scalar properties of matrices.

# 7.1.4.1 Trace of a square matrix

The trace of a square matrix $\mathbf { A } \in \mathbb { R } ^ { n \times n }$ , denoted $\operatorname { t r } ( \mathbf { A } )$ , is the sum of diagonal elements in the matrix:

$$
\operatorname { t r } ( \mathbf { A } ) \triangleq \sum _ { i = 1 } ^ { n } A _ { i i } .
$$

The trace has the following properties, where $c \in \mathbb { R }$ is a scalar, and $\mathbf { A } , \mathbf { B } \in \mathbb { R } ^ { n \times n }$ are square matrices:

$$
\begin{array} { c } { \operatorname { t r } ( \mathbf { A } ) = \operatorname { t r } ( \mathbf { A } ^ { \top } ) } \\ { \operatorname { t r } ( \mathbf { A } + \mathbf { B } ) = \operatorname { t r } ( \mathbf { A } ) + \operatorname { t r } ( \mathbf { B } ) } \\ { \operatorname { t r } ( c \mathbf { A } ) = c \operatorname { t r } ( \mathbf { A } ) } \\ { \operatorname { t r } ( \mathbf { A } \mathbf { B } ) = \operatorname { t r } ( \mathbf { B } \mathbf { A } ) } \end{array}
$$

We also have the following important cyclic permutation property: For $\mathbf { A } , \mathbf { B } , \mathbf { C }$ such that ABC is square,

$$
\operatorname { t r } ( \mathbf { A } \mathbf { B } \mathbf { C } ) = \operatorname { t r } ( \mathbf { B } \mathbf { C } \mathbf { A } ) = \operatorname { t r } ( \mathbf { C } \mathbf { A } \mathbf { B } )
$$

From this, we can derive the trace trick, which rewrites the scalar inner product ${ \pmb x } ^ { 1 } { \bf A } { \pmb x }$ as follows

$$
\mathbf { \boldsymbol { x } } ^ { \mathsf { T } } \mathbf { \boldsymbol { A } } \mathbf { \boldsymbol { x } } = \operatorname { t r } ( \mathbf { \boldsymbol { x } } ^ { \mathsf { T } } \mathbf { \boldsymbol { A } } \mathbf { \boldsymbol { x } } ) = \operatorname { t r } ( \mathbf { \boldsymbol { x } } \mathbf { \boldsymbol { x } } ^ { \mathsf { T } } \mathbf { \boldsymbol { A } } )
$$

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

In some cases, it may be expensive to evaluate the matrix $\mathbf { A }$ , but we may be able to cheaply evaluate matrix-vector products $\mathbf { A } v$ . Suppose $\mathbf { \nabla } _ { \mathbf { v } }$ is a random vector such that $\mathbb { E } \left\lfloor { \boldsymbol { v } } { \boldsymbol { v } } ^ { \mathsf { T } } \right\rfloor = \mathbf { I }$ . In this case, we can create a Monte Carlo approximation to $\operatorname { t r } ( \mathbf { A } )$ using the following identity:

$$
\operatorname { t r } ( \mathbf { A } ) = \operatorname { t r } ( \mathbf { A } \mathbb { E } \left[ { \pmb v } { \pmb v } ^ { \mathsf { T } } \right] ) = \mathbb { E } \left[ \operatorname { t r } ( \mathbf { A } { \pmb v } { \pmb v } ^ { \mathsf { T } } ) \right] = \mathbb { E } \left[ \operatorname { t r } ( { \pmb v } ^ { \mathsf { T } } \mathbf { A } { \pmb v } ) \right] = \mathbb { E } \left[ { \pmb v } ^ { \mathsf { T } } \mathbf { A } { \pmb v } \right]
$$

This is called the Hutchinson trace estimator [Hut90].

# 7.1.4.2 Determinant of a square matrix

The determinant of a square matrix, denoted $\operatorname* { d e t } ( \mathbf { A } )$ or $| \mathbf { A } |$ , is a measure of how much it changes a unit volume when viewed as a linear transformation. (The formal definition is rather complex and is not needed here.)

The determinant operator satisfies these properties, where $\mathbf { A } , \mathbf { B } \in \mathbb { R } ^ { n \times n }$

$$
| \mathbf { A } | = | \mathbf { A } ^ { \mathsf { T } } |
$$

$$
| c \mathbf { A } | = c ^ { n } | \mathbf { A } |
$$

$$
| \mathbf { A B } | = | \mathbf { A } | | \mathbf { B } |
$$

For a positive definite matrix $\mathbf { A }$ , we can write $\mathbf { A } = \mathbf { L L } ^ { \mathsf { I } }$ , where $\mathbf { L }$ is the lower triangular Cholesky decomposition. In this case, we have

$$
\operatorname* { d e t } ( \mathbf { A } ) = \operatorname* { d e t } ( \mathbf { L } ) \operatorname* { d e t } ( \mathbf { L } ^ { \mathsf { T } } ) = \operatorname* { d e t } ( \mathbf { L } ) ^ { 2 }
$$

so

$$
\log \operatorname* { d e t } ( \mathbf { A } ) = 2 \log \operatorname* { d e t } ( \mathbf { L } ) = 2 \log \prod _ { i } L _ { i i } = 2 \mathrm { t r a c e } ( \log ( \operatorname { d i a g } ( \mathbf { L } ) ) )
$$

# 7.1.4.3 Rank of a matrix

The column rank of a matrix A is the dimension of the space spanned by its columns, and the row rank is the dimension of the space spanned by its rows. It is a basic fact of linear algebra (that can be shown using the SVD, discussed in Section 7.5) that for any matrix A, columnrank $\mathbf { \dot { \eta } } ( \mathbf { A } ) = \operatorname { r o w r a n k } ( \mathbf { A } )$ , and so this quantity is simply referred to as the rank of $\mathbf { A }$ , denoted as rank(A). The following are some basic properties of the rank:

• For $\mathbf { A } \in \mathbb { R } ^ { m \times n }$ , $\operatorname { r a n k } ( \mathbf { A } ) \leq \operatorname* { m i n } ( m , n )$ . If $\operatorname { r a n k } ( \mathbf { A } ) = \operatorname* { m i n } ( m , n )$ , then $\mathbf { A }$ is said to be full rank, otherwise it is called rank deficient.   
• For $\mathbf { A } \in \mathbb { R } ^ { m \times n }$ $\begin{array} { r l } & { \mathrm { , ~ r a n k } ( \mathbf { A } ) = \mathrm { r a n k } ( \mathbf { A } ^ { \mathsf { T } } ) = \mathrm { r a n k } ( \mathbf { A } ^ { \mathsf { T } } \mathbf { A } ) = \mathrm { r a n k } ( \mathbf { A } \mathbf { A } ^ { \mathsf { T } } ) \mathrm { . } } \\ & { \mathrm { , ~ } \mathbf { B } \in \mathbb { R } ^ { n \times p } \mathrm { , ~ r a n k } ( \mathbf { A } \mathbf { B } ) \le \operatorname* { m i n } ( \mathrm { r a n k } ( \mathbf { A } ) \mathrm { , r a n k } ( \mathbf { B } ) ) \mathrm { . } } \end{array}$   
• For $\mathbf { A } \in \mathbb { R } ^ { m \times n }$

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license • For $\mathbf { A } , \mathbf { B } \in \mathbb { R } ^ { m \times n }$ , $\operatorname { r a n k } ( \mathbf { A } + \mathbf { B } ) \leq \operatorname { r a n k } ( \mathbf { A } ) + \operatorname { r a n k } ( \mathbf { B } ) .$

One can show that a square matrix is invertible iff it is full rank.

# 7.1.4.4 Condition numbers

The condition number of a matrix A is a measure of how numerically stable any computations involving A will be. It is defined as follows:

$$
\kappa ( \mathbf { A } ) \triangleq | | \mathbf { A } | | \cdot | | \mathbf { A } ^ { - 1 } | |
$$

where $| | \mathbf { A } | |$ is the norm of the matrix. We can show that $\kappa ( \mathbf { A } ) \geq 1$ . (The condition number depends on which norm we use; we will assume the $\ell _ { 2 }$ -norm unless stated otherwise.)

We say A is well-conditioned if $\kappa ( \mathbf { A } )$ is small (close to 1), and ill-conditioned if $\kappa ( \mathbf { A } )$ is large. A large condition number means $\mathbf { A }$ is nearly singular. This is a better measure of nearness to singularity than the size of the determinant. For example, suppose $\mathbf { A } = 0 . 1 \mathbf { I } _ { 1 0 0 \times 1 0 0 }$ . Then $\operatorname* { d e t } ( \mathbf { A } ) = 1 0 ^ { - 1 0 0 }$ , which suggests $\mathbf { A }$ is nearly singular, but $\kappa ( \mathbf { A } ) = 1$ , which means $\mathbf { A }$ is well-conditioned, reflecting the fact that ${ \bf A } x$ simply scales the entries of $_ { x }$ by 0.1.

To get a better understanding of condition numbers, consider the linear system of equations $\mathbf { A } { \boldsymbol { \mathbf { \mathit { x } } } } = \mathbf { \mathit { b } }$ . If $\mathbf { A }$ is non-singular, the unique solution is ${ \pmb x } = { \bf A } ^ { - 1 } { \pmb b }$ . Suppose we change $^ { b }$ to $\boldsymbol { b } + \Delta \boldsymbol { b }$ ; what effect will that have on $_ { x }$ ? The new solution must satisify

$$
\mathbf { A } ( { \pmb x } + \Delta { \pmb x } ) = { \pmb b } + \Delta { \pmb b }
$$

where

$$
\Delta \pmb { x } = \mathbf { A } ^ { - 1 } \Delta \pmb { b }
$$

We say that $\mathbf { A }$ is well-conditioned if a small $\Delta \boldsymbol { b }$ results in a small $\Delta { } x$ ; otherwise we say that $\mathbf { A }$ is ill-conditioned.

For example, suppose

$$
\mathbf { A } = { \frac { 1 } { 2 } } \left( { \begin{array} { c c } { 1 } & { 1 } \\ { 1 + 1 0 ^ { - 1 0 } } & { 1 - 1 0 ^ { - 1 0 } } \end{array} } \right) , \mathbf { A } ^ { - 1 } = { \binom { 1 - 1 0 ^ { 1 0 } } { 1 + 1 0 ^ { 1 0 } } } \mathbf { - } 1 0 ^ { 1 0 } \mathbf { \Sigma }
$$

The solution for $\pmb { b } = ( 1 , 1 )$ is ${ \pmb x } = ( 1 , 1 )$ . If we change $^ { b }$ by $\Delta \boldsymbol { b }$ , the solution changes to

$$
\Delta { \pmb x } = { \bf A } ^ { - 1 } \Delta { \pmb b } = \left( \Delta b _ { 1 } - 1 0 ^ { 1 0 } ( \Delta b _ { 1 } - \Delta b _ { 2 } ) \right)
$$

So a small change in $^ { b }$ can lead to an extremely large change in $_ { x }$ , because $\mathbf { A }$ is ill-conditioned ( $\kappa ( \mathbf { A } ) = 2 \times 1 0 ^ { 1 0 }$ ).

In the case of the $\ell _ { 2 }$ -norm, the condition number is equal to the ratio of the largest to smallest singular values (defined in Section 7.5); furthermore, the singular values of $\mathbf { A }$ are the square roots of the eigenvalues of $\mathbf { A } ^ { 1 } \mathbf { A }$ , and so

$$
\kappa ( \mathbf { A } ) = \sigma _ { m a x } / \sigma _ { m i n } = \sqrt { \frac { \lambda _ { \mathrm { m a x } } } { \lambda _ { \mathrm { m i n } } } }
$$

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

We can gain further insight into condition numbers by considering a quadratic objective function $f ( \pmb { x } ) = \pmb { x } ^ { \top } \mathbf { A } \pmb { x }$ . If we plot the level set of this function, it will be elliptical, as shown in Section 7.4.4. As we increase the condition number of A, the ellipses become more and more elongated along certain directions, corresponding to a very narrow valley in function space. If $\kappa = 1$ (the minimum possible value), the level set will be circular.

# 7.1.5 Special types of matrices

In this section, we will list some common kinds of matrices with various forms of structure.

# 7.1.5.1 Diagonal matrix

A diagonal matrix is a matrix where all non-diagonal elements are 0. This is typically denoted $\mathbf { D } = \mathrm { d i a g } ( d _ { 1 } , d _ { 2 } , \ldots , d _ { n } )$ , with

$$
{ \bf D } = \left( \begin{array} { c c c c } { { d _ { 1 } } } & { { } } & { { } } & { { } } \\ { { } } & { { d _ { 2 } } } & { { } } & { { } } \\ { { } } & { { } } & { { \ddots } } & { { } } \\ { { } } & { { } } & { { } } & { { d _ { n } } } \end{array} \right)
$$

The identity matrix, denoted $\mathbf { I } \in \mathbb { R } ^ { n \times n }$ , is a square matrix with ones on the diagonal and zeros everywhere else, $\mathbf { I } = \mathrm { d i a g } ( 1 , 1 , \dots , 1 )$ . It has the property that for all $\mathbf { A } \in \mathbb { R } ^ { n \times n }$ ,

$$
\mathbf { A I } = \mathbf { A } = \mathbf { I A }
$$

where the size of $\mathbf { I }$ is determined by the dimensions of $\mathbf { A }$ so that matrix multiplication is possible.

We can extract the diagonal vector from a matrix using $\pmb { d } = \mathrm { d i a g } ( \mathbf { D } )$ . We can convert a vector into a diagonal matrix by writing $\mathbf { D } = \mathrm { d i a g } ( \pmb { d } )$ .

A block diagonal matrix is one which contains matrices on its main diagonal, and is $0$ everywhere else, e.g.,

$$
\left( \begin{array} { c c } { \mathbf { A } } & { \mathbf { 0 } } \\ { \mathbf { 0 } } & { \mathbf { B } } \end{array} \right)
$$

A band-diagonal matrix only has non-zero entries along the diagonal, and on $k$ sides of the diagonal, where $k$ is the bandwidth. For example, a tridiagonal $6 \times 6$ matrix looks like this:

$$
\left[ { \begin{array} { r r r r r r r } { A _ { 1 1 } } & { A _ { 1 2 } } & { 0 } & { \cdots } & { \cdots } & { 0 } \\ { A _ { 2 1 } } & { A _ { 2 2 } } & { A _ { 2 3 } } & { \ddots } & { \ddots } & { \vdots } \\ { 0 } & { A _ { 3 2 } } & { A _ { 3 3 } } & { A _ { 3 4 } } & { \ddots } & { \vdots } \\ { \vdots } & { \ddots } & { A _ { 4 3 } } & { A _ { 4 4 } } & { A _ { 4 5 } } & { 0 } \\ { \vdots } & { \ddots } & { \ddots } & { A _ { 5 4 } } & { A _ { 5 5 } } & { A _ { 5 6 } } \\ { 0 } & { \cdots } & { \cdots } & { 0 } & { A _ { 6 5 } } & { A _ { 6 6 } } \end{array} } \right]
$$

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

# 7.1.5.2 Triangular matrices

An upper triangular matrix only has non-zero entries on and above the diagonal. A lower triangular matrix only has non-zero entries on and below the diagonal.

Triangular matrices have the useful property that the diagonal entries of $\mathbf { A }$ are the eigenvalues of A, and hence the determinant is the product of diagonal entries: $\begin{array} { r } { \operatorname* { d e t } ( \mathbf { A } ) = \prod _ { i } A _ { i i } } \end{array}$ .

# 7.1.5.3 Positive definite matrices

Given a square matrix $\mathbf { A } \in \mathbb { R } ^ { n \times n }$ and a vector $\pmb { x } \in \mathbb { R } ^ { n }$ , the scalar value ${ \pmb x } ^ { 1 } { \bf A } { \pmb x }$ is called a quadratic form. Written explicitly, we see that

$$
x ^ { \mathsf { T } } \mathbf { A } x = \sum _ { i = 1 } ^ { n } \sum _ { j = 1 } ^ { n } A _ { i j } x _ { i } x _ { j } ~ .
$$

Note that,

$$
x ^ { \mathsf { T } } \mathbf { A } x = ( x ^ { \mathsf { T } } \mathbf { A } x ) ^ { \mathsf { T } } = x ^ { \mathsf { T } } \mathbf { A } ^ { \mathsf { T } } x = x ^ { \mathsf { T } } ( { \frac { 1 } { 2 } } \mathbf { A } + { \frac { 1 } { 2 } } \mathbf { A } ^ { \mathsf { T } } ) \mathbf { \Delta } x
$$

For this reason, we often implicitly assume that the matrices appearing in a quadratic form are symmetric.

We give the following definitions:

• A symmetric matrix $\mathbf { A } \in \mathbb { S } ^ { n }$ is positive definite iff for all non-zero vectors $\pmb { x } \in \mathbb { R } ^ { n }$ , ${ \pmb x } ^ { 1 } { \bf A } { \pmb x } > 0$ . This is usually denoted $\mathbf A \succ 0$ (or just $\mathbf A > 0$ ). If it is possible that ${ \pmb x } ^ { 1 } { \bf A } { \pmb x } = 0$ , we say the matrix is positive semidefinite or psd. We denote the set of all positive definite matrices by $\mathbb { S } _ { + + } ^ { n }$ . • A symmetric matrix $\mathbf { A } \in \mathbb { S } ^ { n }$ is negative definite, denoted $\mathbf A \prec 0$ (or just $\mathbf A < 0$ ) iff for all non-zero $\pmb { x } \in \mathbb { R } ^ { n }$ , $\pmb { x } ^ { \top } \mathbf { A } \pmb { x } < 0$ . If it is possible that ${ \pmb x } ^ { 1 } { \bf A } { \pmb x } = 0$ , we say the matrix is negative semidefinite. • A symmetric matrix $\mathbf { A } \in \mathbb { S } ^ { n }$ is indefinite, if it is neither positive semidefinite nor negative semidefinite — i.e., if there exists $\pmb { x } _ { 1 } , \pmb { x } _ { 2 } \in \mathbb { R } ^ { n }$ such that $x _ { 1 } ^ { \mathsf { T } } \mathbf { A } x _ { 1 } > 0$ and $\pmb { x } _ { 2 } ^ { \top } \mathbf { A } \pmb { x } _ { 2 } < 0$ .

It should be obvious that if $\mathbf { A }$ is positive definite, then $- \mathbf { A }$ is negative definite and vice versa. Likewise, if $\mathbf { A }$ is positive semidefinite then $- \mathbf { A }$ is negative semidefinite and vice versa. If A is indefinite, then so is $- \mathbf { A }$ . It can also be shown that positive definite and negative definite matrices are always invertible.

In Section 7.4.3.1, we show that a symmetric matrix is positive definite iff its eigenvalues are positive. Note that if all elements of $\mathbf { A }$ are positive, it does not mean A is necessarily positive definite. For example, $\mathbf { A } = { \left( \begin{array} { l l } { 4 } & { 3 } \\ { 3 } & { 2 } \end{array} \right) }$ is not positive definite. Conversely, a positive definite matrix can have negative entries e.g., $\mathbf { A } = { \binom { 2 } { - 1 } } \quad { \binom { - 1 } { 2 } }$

A sufficient condition for a (real, symmetric) matrix to be positive definite is that it is diagonally dominant, i.e., if in every row of the matrix, the magnitude of the diagonal entry in that row is

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022 larger than the sum of the magnitudes of all the other (non-diagonal) entries in that row. More precisely,

$$
| a _ { i i } | > \sum _ { j \neq i } | a _ { i j } | \quad { \mathrm { f o r ~ a l l ~ } } i
$$

In 2d, any real, symmetric $2 \times 2$ matrix $\textstyle { \binom { a \quad b } { b } }$ is positive definite iff $a > 0$ , $d > 0$ and $a d > b ^ { 2 }$ . Finally, there is one type of positive definite matrix that comes up frequently, and so deserves some special mention. Given any matrix $\mathbf { A } \in \mathbb { R } ^ { m \times n }$ (not necessarily symmetric or even square), the Gram matrix $\mathbf { G } = \mathbf { A } ^ { \mathsf { I } } \mathbf { A }$ is always positive semidefinite. Further, if $m \geq n$ (and we assume for convenience that A is full rank), then $\mathbf { G } = \mathbf { A } ^ { 1 } \mathbf { A }$ is positive definite.

# 7.1.5.4 Orthogonal matrices

Two vectors $\pmb { x } , \pmb { y } \in \mathbb { R } ^ { n }$ are orthogonal if $\pmb { x } ^ { 1 } \pmb { y } = 0$ . A vector $\pmb { x } \in \mathbb { R } ^ { n }$ is normalized if $\| { \pmb x } \| _ { 2 } = 1$ . A set of vectors that is pairwise orthogonal and normalized is called orthonormal. A square matrix $\mathbf { U } \in \mathbb { R } ^ { n \times n }$ is orthogonal if all its columns are orthonormal. (Note the different meaning of the term orthogonal when talking about vectors versus matrices.) If the entries of $\mathbf { U }$ are complex valued, we use the term unitary instead of orthogonal.

It follows immediately from the definition of orthogonality and normality that $\mathbf { U }$ is orthogonal iff

$$
\mathbf { U } ^ { \mathsf { T } } \mathbf { U } = \mathbf { I } = \mathbf { U } \mathbf { U } ^ { \mathsf { T } } .
$$

In other words, the inverse of an orthogonal matrix is its transpose. Note that if $\mathbf { U }$ is not square i.e., $\mathbf { U } \in \mathbb { R } ^ { m \times n } , n < m$ — but its columns are still orthonormal, then $\mathbf { U } ^ { \mathsf { T } } \mathbf { U } = \mathbf { I }$ , but $\mathbf { U } \mathbf { U } ^ { \mathsf { I } } \neq I$ . We generally only use the term orthogonal to describe the previous case, where $\mathbf { U }$ is square.

An example of an orthogonal matrix is a rotation matrix (see Exercise 7.1). For example, a rotation in 3d by angle $\alpha$ about the $z$ axis is given by

$$
\mathbf { R } ( \alpha ) = \left( \begin{array} { c c c } { \cos ( \alpha ) } & { - \sin ( \alpha ) } & { 0 } \\ { \sin ( \alpha ) } & { \cos ( \alpha ) } & { 0 } \\ { 0 } & { 0 } & { 1 } \end{array} \right)
$$

If $\alpha = 4 5 ^ { \circ }$ , this becomes

$$
\mathbf { R } ( 4 5 ) = { \left( \begin{array} { l l l } { { \frac { 1 } { \sqrt { 2 } } } } & { - { \frac { 1 } { \sqrt { 2 } } } } & { 0 } \\ { { \frac { 1 } { \sqrt { 2 } } } } & { { \frac { 1 } { \sqrt { 2 } } } } & { 0 } \\ { 0 } & { 0 } & { 1 } \end{array} \right) }
$$

where $\textstyle { \frac { 1 } { \sqrt { 2 } } } = 0 . 7 0 7 1$ . We see that $\mathbf { R } ( - \alpha ) = \mathbf { R } ( \alpha ) ^ { - 1 } = \mathbf { R } ( \alpha ) ^ { 1 }$ , so this is an orthogonal matrix.

One nice property of orthogonal matrices is that operating on a vector with an orthogonal matrix will not change its Euclidean norm, i.e.,

$$
\| \mathbf { U } \pmb { x } \| _ { 2 } = \| \pmb { x } \| _ { 2 }
$$

for any nonzero $\pmb { x } \in \mathbb { R } ^ { n }$ , and orthogonal $\mathbf { U } \in \mathbb { R } ^ { n \times n }$ .

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

Similarly, one can show that the angle between two vectors is preserved after they are transformed by an orthogonal matrix. The cosine of the angle between $_ { x }$ and $\pmb { y }$ is given by

$$
\cos ( \alpha ( \pmb { x } , \pmb { y } ) ) = \frac { \pmb { x } ^ { \top } \pmb { y } } { | | \pmb { x } | | | \pmb { y } | | }
$$

so

$$
\cos ( \alpha ( \mathbf { U } x , \mathbf { U } y ) ) = { \frac { ( \mathbf { U } x ) ^ { \mathsf { T } } ( \mathbf { U } y ) } { | | \mathbf { U } x | | | \mathbf { U } y | | } } = { \frac { x ^ { \mathsf { T } } y } { | | x | | | y | | } } = \cos ( \alpha ( \pmb { x } , \pmb { y } ) )
$$

In summary, transformations by orthogonal matrices are generalizations of rotations (if $\operatorname* { d e t } ( \mathbf { U } ) = 1$ ) and reflections (if $\operatorname* { d e t } ( \mathbf { U } ) = - 1$ ), since they preserve lengths and angles.

Note that there is technique called Gram Schmidt orthogonalization which is a way to make any square matrix orthogonal, but we will not cover it here.

# 7.2 Matrix multiplication

The product of two matrices $\mathbf { A } \in \mathbb { R } ^ { m \times n }$ and $\mathbf { B } \in \mathbb { R } ^ { n \times p }$ is the matrix

$$
\mathbf { C } = \mathbf { A } \mathbf { B } \in \mathbb { R } ^ { m \times p } ,
$$

where

$$
C _ { i j } = \sum _ { k = 1 } ^ { n } A _ { i k } B _ { k j } .
$$

Note that in order for the matrix product to exist, the number of columns in A must equal the number of rows in $\mathbf { B }$ .

Matrix multiplication generally takes $O ( m n p )$ time, although faster methods exist. In addition, specialized hardware, such as GPUs and TPUs, can be leveraged to speed up matrix multiplication significantly, by performing operations across the rows (or columns) in parallel.

It is useful to know a few basic properties of matrix multiplication:

• Matrix multiplication is associative: $( \mathbf { A B } ) \mathbf { C } = \mathbf { A } ( \mathbf { B C } )$ .   
• Matrix multiplication is distributive: $\mathbf { A } ( \mathbf { B } + \mathbf { C } ) = \mathbf { A B } + \mathbf { A C }$ .   
• Matrix multiplication is, in general, not commutative; that is, it can be the case that $\mathbf { A B } \neq \mathbf { B A }$ .

(In each of the above cases, we are assuming that the dimensions match.) There are many important special cases of matrix multiplication, as we discuss below.

# 7.2.1 Vector–vector products

Given two vectors $\pmb { x } , \pmb { y } \in \mathbb { R } ^ { n }$ , the quantity $x ^ { 1 } y$ , called the inner product, dot product or scalar product of the vectors, is a real number given by

$$
\langle { \pmb x } , { \pmb y } \rangle \triangleq { \pmb x } ^ { \top } { \pmb y } = \sum _ { i = 1 } ^ { n } x _ { i } y _ { i } .
$$

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

Note that it is always the case that $\mathbf { x } ^ { \mathsf { \Pi } } \mathbf { y } = \mathbf { y } ^ { \mathsf { \Pi } } \mathbf { x }$ .

Given vectors $\pmb { x } \in \mathbb { R } ^ { r n }$ , $\ b { y } \in \mathbb { R } ^ { n }$ (they no longer have to be the same size), $\boldsymbol { x } \boldsymbol { y } ^ { \intercal }$ is called the outer product of the vectors. It is a matrix whose entries are given by $( { \pmb x } { \pmb y } ^ { \top } ) _ { i j } = x _ { i } y _ { j }$ , i.e.,

$$
\pmb { x } \pmb { y } ^ { \top } \in \mathbb { R } ^ { m \times n } = \left[ \begin{array} { c c c c } { x _ { 1 } y _ { 1 } } & { x _ { 1 } y _ { 2 } } & { \cdots } & { x _ { 1 } y _ { n } } \\ { x _ { 2 } y _ { 1 } } & { x _ { 2 } y _ { 2 } } & { \cdots } & { x _ { 2 } y _ { n } } \\ { \vdots } & { \vdots } & { \ddots } & { \vdots } \\ { x _ { m } y _ { 1 } } & { x _ { m } y _ { 2 } } & { \cdots } & { x _ { m } y _ { n } } \end{array} \right] .
$$

# 7.2.2 Matrix–vector products

Given a matrix $\mathbf { A } \in \mathbb { R } ^ { m \times n }$ and a vector $\pmb { x } \in \mathbb { R } ^ { n }$ , their product is a vector $\pmb { y } = \mathbf { A } \pmb { x } \in \mathbb { R } ^ { m }$ . There are a couple ways of looking at matrix-vector multiplication, and we will look at them both.

If we write $\mathbf { A }$ by rows, then we can express $\mathbf { \boldsymbol { y } } = \mathbf { \boldsymbol { A } } \mathbf { \boldsymbol { x } }$ as follows:

$$
\pmb { y } = \mathbf { A } \pmb { x } = \left[ \begin{array} { c c c } { - } & { \pmb { a } _ { 1 } ^ { \mathsf { T } } } & { - } \\ { - } & { \pmb { a } _ { 2 } ^ { \mathsf { T } } } & { - } \\ & { \vdots } \\ { - } & { \pmb { a } _ { m } ^ { \mathsf { T } } } & { - } \end{array} \right] \pmb { x } = \left[ \begin{array} { c c c } { \pmb { a } _ { 1 } ^ { \mathsf { T } } \pmb { x } } \\ { \pmb { a } _ { 2 } ^ { \mathsf { T } } \pmb { x } } \\ { \vdots } \\ { \pmb { a } _ { m } ^ { \mathsf { T } } \pmb { x } } \end{array} \right] .
$$

In other words, the $i$ th entry of $\textbf {  { y } }$ is equal to the inner product of the $i$ th $r o w$ of $\mathbf { A }$ and $_ { x }$ , $y _ { i } = \pmb { a } _ { i } ^ { 1 } \pmb { x }$ . Alternatively, let’s write $\mathbf { A }$ in column form. In this case we see that

$$
: = \left[ \begin{array} { c c c c } { | } & { | } & & { | } \\ { a _ { 1 } } & { a _ { 2 } } & { \ldots } & { a _ { n } } \\ { | } & { | } & & { | } \end{array} \right] \left[ \begin{array} { c } { x _ { 1 } } \\ { x _ { 2 } } \\ { \vdots } \\ { x _ { n } } \end{array} \right] = \left[ \begin{array} { c } { | } \\ { a _ { 1 } } \\ { | } \end{array} \right] x _ { 1 } + \left[ \begin{array} { c } { | } \\ { a _ { 2 } } \\ { | } \end{array} \right] x _ { 2 } + \ldots + \left[ \begin{array} { c } { | } \\ { a _ { n } } \\ { | } \end{array} \right] x _ { 2 } + \ldots = : x _ { n }
$$

In other words, $\pmb { y }$ is a linear combination of the columns of A, where the coefficients of the linear combination are given by the entries of $_ { x }$ . We can view the columns of $\mathbf { A }$ as a set of basis vectors defining a linear subspace. We can contstruct vectors in this subspace by taking linear combinations of the basis vectors. See Section 7.1.2 for details.

# 7.2.3 Matrix–matrix products

Below we look at four different (but, of course, equivalent) ways of viewing the matrix-matrix multiplication $\mathbf { C } = \mathbf { A } \mathbf { B }$ .

First we can view matrix-matrix multiplication as a set of vector-vector products. The most obvious viewpoint, which follows immediately from the definition, is that the $i , j$ entry of $\mathbf { C }$ is equal to the inner product of the $i$ th row of $\mathbf { A }$ and the $j$ th column of $\mathbf { B }$ . Symbolically, this looks like the following,

$$
\mathbf { 3 } = \left[ \begin{array} { c c c c } { - } & { a _ { 1 } ^ { \top } } & { - } \\ { - } & { a _ { 2 } ^ { \top } } & { - } \\ & { \vdots } & \\ { - } & { a _ { m } ^ { \top } } & { - } \end{array} \right] \left[ \begin{array} { c c c c } { \vert } & { \vert } & & { \vert } \\ { b _ { 1 } } & { b _ { 2 } } & { \cdots } & { b _ { p } } \\ { \vert } & { \vert } & & { \vert } \end{array} \right] = \left[ \begin{array} { c c c c } { a _ { 1 } ^ { \top } b _ { 1 } } & { a _ { 1 } ^ { \top } b _ { 2 } } & { \cdots } & { a _ { 1 } ^ { \top } b _ { p } } \\ { a _ { 2 } ^ { \top } b _ { 1 } } & { a _ { 2 } ^ { \top } b _ { 2 } } & { \cdots } & { a _ { 2 } ^ { \top } b _ { p } } \\ { \vdots } & { \vdots } & { \ddots } & { \vdots } \\ { a _ { m } ^ { \top } b _ { 1 } } & { a _ { m } ^ { \top } b _ { 2 } } & { \cdots } & { a _ { m } ^ { \top } b _ { p } } \end{array} \right]
$$

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

![](images/86b00b963ac3d29fbd708e861315db63d8c8ea97aa2b6f9c76c73aea4025e1a4.jpg)  
Figure 7.5: Illustration of matrix multiplication. From https: // en. wikipedia. org/ wiki/ Matrix_ multiplication . Used with kind permission of Wikipedia author Bilou.

Remember that since $\mathbf { A } \in \mathbb { R } ^ { m \times n }$ and $\mathbf { B } \in \mathbb { R } ^ { n \times p }$ , $\mathbf { \pmb { a } } _ { i } \in \mathbb { R } ^ { n }$ and $\boldsymbol { b } _ { j } \in \mathbb { R } ^ { n }$ , so these inner products all make sense. This is the most “natural” representation when we represent $\mathbf { A }$ by rows and $\mathbf { B }$ by columns. See Figure 7.5 for an illustration.

Alternatively, we can represent $\mathbf { A }$ by columns, and $\mathbf { B }$ by rows, which leads to the interpretation of AB as a sum of outer products. Symbolically,

$$
\mathbf { C } = \mathbf { A } \mathbf { B } = { \left[ \begin{array} { l l l l } { | } & { | } & & { | } \\ { a _ { 1 } } & { a _ { 2 } } & { \cdots } & { a _ { n } } \\ { | } & { | } & & { | } \end{array} \right] } { \left[ \begin{array} { l l l } { - } & { b _ { 1 } ^ { \intercal } } & { - } \\ { - } & { b _ { 2 } ^ { \intercal } } & { - } \\ & { \vdots } & \\ { - } & { b _ { n } ^ { \intercal } } & { - } \end{array} \right] } = \sum _ { i = 1 } ^ { n } a _ { i } b _ { i } ^ { \intercal } \ .
$$

Put another way, AB is equal to the sum, over all $i$ , of the outer product of the $i$ th column of A and the $i$ th row of $\mathbf { B }$ . Since, in this case, $\mathbf { \pmb { a } } _ { i } \in \mathbb { R } ^ { m }$ and $\mathbf { \Delta } b _ { i } \in \mathbb { R } ^ { p }$ , the dimension of the outer product $\mathbf { \alpha } _ { \mathbf { } \mathbf { } \mathbf { } a _ { i } \mathbf { \delta } _ { i } }$ is $m \times p$ , which coincides with the dimension of $\mathbf { C }$ .

We can also view matrix-matrix multiplication as a set of matrix-vector products. Specifically, if we represent $\mathbf { B }$ by columns, we can view the columns of $\mathbf { C }$ as matrix-vector products between $\mathbf { A }$ and the columns of $\mathbf { B }$ . Symbolically,

$$
\mathbf { C } = \mathbf { A } \mathbf { B } = \mathbf { A } \left[ \begin{array} { c c c c } { | } & { | } & & { | } \\ { b _ { 1 } } & { b _ { 2 } } & { \cdots } & { b _ { p } } \\ { | } & { | } & & { | } \end{array} \right] = \left[ \begin{array} { c c c c } { | } & { | } & & { | } \\ { \mathbf { A } b _ { 1 } } & { \mathbf { A } b _ { 2 } } & { \cdots } & { \mathbf { A } b _ { p } } \\ { | } & { | } & & { | } \end{array} \right] .
$$

Here the $i$ th column of $\mathbf { C }$ is given by the matrix-vector product with the vector on the right, $\pmb { c } _ { i } = \mathbf { A } b _ { i }$ These matrix-vector products can in turn be interpreted using both viewpoints given in the previous subsection.

Finally, we have the analogous viewpoint, where we represent A by rows, and view the rows of $\mathbf { C }$ as the matrix-vector product between the rows of $\mathbf { A }$ and the matrix $\mathbf { B }$ . Symbolically,

$$
\mathbf { C } = \mathbf { A } \mathbf { B } = \left[ { \begin{array} { c c } { - } & { \mathbf { { \boldsymbol { a } } } _ { 1 } ^ { \mathsf { T } } } \\ { - } & { \mathbf { { \boldsymbol { a } } } _ { 2 } ^ { \mathsf { T } } } & { - } \\ & { \vdots } \\ { - } & { \mathbf { { \boldsymbol { a } } } _ { m } ^ { \mathsf { T } } } & { - } \end{array} } \right] \mathbf { B } = \left[ { \begin{array} { c c } { - } & { \mathbf { { \boldsymbol { a } } } _ { 1 } ^ { \mathsf { T } } \mathbf { B } } \\ { - } & { \mathbf { { \boldsymbol { a } } } _ { 2 } ^ { \mathsf { T } } \mathbf { B } } \\ & { \vdots } \\ { - } & { \mathbf { { \boldsymbol { a } } } _ { m } ^ { \mathsf { T } } \mathbf { B } } \end{array} } - \right] .
$$

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

Here the $i$ th row of $\mathbf { C }$ is given by the matrix-vector product with the vector on the left, $\mathbf { c } _ { i } ^ { \mathsf { I } } = \mathbf { a } _ { i } ^ { \mathsf { I } } \mathbf { B }$ . It may seem like overkill to dissect matrix multiplication to such a large degree, especially when all these viewpoints follow immediately from the initial definition we gave (in about a line of math) at the beginning of this section. However, virtually all of linear algebra deals with matrix multiplications of some kind, and it is worthwhile to spend some time trying to develop an intuitive understanding of the viewpoints presented here.

Finally, a word on notation. We write ${ \mathbf { A } } ^ { 2 }$ as shorthand for AA, which is the matrix product. To denote elementwise squaring of the elements of a matrix, we write $\mathbf { A } ^ { \odot 2 } = [ A _ { i j } ^ { 2 } ]$ . (If A is diagonal, then $\mathbf { A } ^ { 2 } = \mathbf { A } ^ { \odot 2 }$ .)

We can also define the inverse of ${ \mathbf A } ^ { 2 }$ using the matrix square root: we say $\mathbf { A } = { \sqrt { \mathbf { M } } }$ if $\mathbf { A } ^ { 2 } = \mathbf { M }$ . To denote elementwise square root of the elements of a matrix, we write $[ \sqrt { M _ { i j } } ]$ .

# 7.2.4 Application: manipulating data matrices

As an application of the above results, consider the case where $\mathbf { X }$ is the $N \times D$ design matrix, whose rows are the data cases. There are various common preprocessing operations that we apply to this matrix, which we summarize below. (Writing these operations in matrix form is useful because it is notationally compact, and it allows us to implement the methods quickly using fast matrix code.)

# 7.2.4.1 Summing slices of the matrix

Suppose $\mathbf { X }$ is an $N \times D$ matrix. We can sum across the rows by premultiplying by a $1 \times N$ matrix of ones to create a $1 \times D$ matrix:

$$
\begin{array} { r } { \mathbf { 1 } _ { N } ^ { \mathsf { T } } \mathbf { X } = \left( \sum _ { n } x _ { n 1 } \quad \cdots \quad \sum _ { n } x _ { n D } \right) } \end{array}
$$

Hence the mean of the data vectors is given by

$$
\overline { { \pmb { x } } } ^ { \mathsf { T } } = \frac { 1 } { N } \pmb { 1 } _ { N } ^ { \mathsf { T } } \pmb { \mathrm { X } }
$$

We can sum across the columns by postmultiplying by a $D \times 1$ matrix of ones to create a $N \times 1$ matrix:

$$
\mathbf { X 1 } _ { D } = \left( \sum _ { \vdots } x _ { 1 d } \atop \sum _ { d } x _ { N d } \right)
$$

We can sum all entries in a matrix by pre and post multiplying by a vector of 1s:

$$
{ \bf 1 } _ { N } ^ { \top } { \bf X } { \bf 1 } _ { D } = \sum _ { i j } X _ { i j }
$$

Hence the overall mean is given by

$$
\overline { { x } } = \frac { 1 } { N D } \mathbf { 1 } _ { N } ^ { \top } \mathbf { X } \mathbf { 1 } _ { D }
$$

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

# 7.2.4.2 Scaling rows and columns of a matrix

We often want to scale rows or columns of a data matrix (e.g., to standardize them). We now show how to write this in matrix notation.

If we pre-multiply $\mathbf { X }$ by a diagonal matrix $\mathbf { S } = \mathrm { d i a g } ( \pmb { s } )$ , where $s$ is an $N$ -vector, then we just scale each row of $\mathbf { X }$ by the corresponding scale factor in $\pmb { s }$ :

$$
\begin{array} { r } { s ) \mathbf { X } = \left( \begin{array} { l l l } { s _ { 1 } } & { \cdots } & { 0 } \\ & { \ddots } & \\ { 0 } & { \cdots } & { s _ { N } } \end{array} \right) \left( \begin{array} { l l l } { x _ { 1 , 1 } } & { \cdots } & { x _ { 1 , D } } \\ & { \ddots } & \\ { x _ { N , 1 } } & { \cdots } & { x _ { N , D } } \end{array} \right) = \left( \begin{array} { l l l } { s _ { 1 } x _ { 1 , 1 } } & { \cdots } & { s _ { 1 } x _ { 1 , D } } \\ & { \ddots } & \\ { s _ { N } x _ { N , 1 } } & { \cdots } & { s _ { N } x _ { N , D } } \end{array} \right) } \end{array}
$$

If we post-multiply $\mathbf { X }$ by a diagonal matrix $\mathbf { S } = \mathrm { d i a g } ( \pmb { s } )$ , where $\pmb { s }$ is a $D$ -vector, then we just scale each column of $\mathbf { X }$ by the corresponding element in $\pmb { s }$ .

$$
\operatorname { l i a g } ( s ) = { \left( \begin{array} { l l l } { x _ { 1 , 1 } } & { \cdots } & { x _ { 1 , D } } \\ & { \ddots } & \\ { x _ { N , 1 } } & { \cdots } & { x _ { N , D } } \end{array} \right) } { \left( \begin{array} { l l l } { s _ { 1 } } & { \cdots } & { 0 } \\ & { \ddots } & \\ { 0 } & { \cdots } & { s _ { D } } \end{array} \right) } = { \left( \begin{array} { l l l } { s _ { 1 } x _ { 1 , 1 } } & { \cdots } & { s _ { D } x _ { 1 , D } } \\ & { \ddots } & \\ { s _ { 1 } x _ { N , 1 } } & { \cdots } & { s _ { D } x _ { N , D } } \end{array} \right) }
$$

Thus we can rewrite the standardization operation from Section 10.2.8 in matrix form as follows:

$$
\mathrm { s t a n d a r d i z e } ( \mathbf { X } ) = ( \mathbf { X } - \mathbf { 1 } _ { N } { \boldsymbol { \mu } } ^ { T } ) \mathrm { d i a g } ( { \pmb \sigma } ) ^ { - 1 }
$$

where $\pmb { \mu } = \overline { { \pmb { x } } }$ is the empirical mean, and $\pmb { \sigma }$ is a vector of the empirical standard deviations.

# 7.2.4.3 Sum of squares and scatter matrix

The sum of squares matrix is $D \times D$ matrix defined by

$$
\mathbf { S } _ { 0 } \triangleq \mathbf { X } ^ { \mathsf { T } } \mathbf { X } = \sum _ { n = 1 } ^ { N _ { \mathcal { D } } } \mathbf { x } _ { n } \mathbf { x } _ { n } ^ { \mathsf { T } } = \sum _ { n = 1 } ^ { N _ { \mathcal { D } } } \left( \begin{array} { c c c } { x _ { n , 1 } ^ { 2 } } & { \cdots } & { x _ { n , 1 } x _ { n , D } } \\ & { \ddots } & \\ { x _ { n , D } x _ { n , 1 } } & { \cdots } & { x _ { n , D } ^ { 2 } } \end{array} \right)
$$

The scatter matrix is a $D \times D$ matrix defined by

$$
\mathbf { S } _ { \overline { { \mathbf { x } } } } \triangleq \sum _ { n = 1 } ^ { N } ( \pmb { x } _ { n } - \overline { { \mathbf { x } } } ) ( \pmb { x } _ { n } - \overline { { \mathbf { x } } } ) ^ { \intercal } = \left( \sum _ { n } \pmb { x } _ { n } \pmb { x } _ { n } ^ { \intercal } \right) - N \overline { { \mathbf { x } } } \overline { { \mathbf { x } } } ^ { \intercal }
$$

We see that this is the sum of squares matrix applied to the mean-centered data. More precisely, define $\tilde { \mathbf { X } }$ to be a version of $\mathbf { X }$ where we subtract the mean $\begin{array} { r } { \overline { { \pmb { x } } } = \frac { 1 } { N } \mathbf { X } ^ { \mathsf { T } } \mathbf { 1 } _ { N } } \end{array}$ off every row. Hence we can compute the centered data matrix using

$$
\tilde { \mathbf { X } } = \mathbf { X } - \mathbf { 1 } _ { N } \overline { { \mathbf { x } } } ^ { \mathsf { T } } = \mathbf { X } - \frac { 1 } { N } \mathbf { 1 } _ { N } \mathbf { 1 } _ { N } ^ { \mathsf { T } } \mathbf { X } = \mathbf { C } _ { N } \mathbf { X }
$$

where

$$
\mathbf { C } _ { N } \triangleq \mathbf { I } _ { N } - \frac { 1 } { N } \mathbf { J } _ { N }
$$

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

is the centering matrix, and $\mathbf { J } _ { N } = \mathbf { 1 } _ { N } \mathbf { 1 } _ { N } ^ { \sf }$ is a matrix of all 1s. The scatter matrix can now be computed as follows:

$$
\mathbf { S } _ { \overline { { x } } } = \tilde { \mathbf { X } } ^ { \mathsf { T } } \tilde { \mathbf { X } } = \mathbf { X } ^ { \mathsf { T } } \mathbf { C } _ { N } ^ { \mathsf { T } } \mathbf { C } _ { N } \mathbf { X } = \mathbf { X } ^ { \mathsf { T } } \mathbf { C } _ { N } \mathbf { X }
$$

where we exploited the fact that $\mathbf { C } _ { N }$ is symmetric and idempotent, i.e., ${ \bf C } _ { N } ^ { k } = { \bf C } _ { N }$ for $k = 1 , 2 , \ldots$ (since once we subtract the mean, subtracting it again has no effect).

# 7.2.4.4 Gram matrix

The $N \times N$ matrix $\mathbf { X X ^ { \parallel } }$ is a matrix of inner products called the Gram matrix:

$$
\mathbf { K } \triangleq \mathbf { X } \mathbf { X } ^ { \mathsf { T } } = { \binom { \mathbf { x } _ { 1 } ^ { \mathsf { T } } \mathbf { x } _ { 1 } \quad \ldots \quad \mathbf { x } _ { 1 } ^ { \mathsf { T } } \mathbf { x } _ { N } } { \mathbf { \Sigma } \cdot \mathbf { \Sigma } _ { \cdot } } }
$$

Sometimes we want to compute the inner products of the mean-centered data vectors, $\tilde { \mathbf { K } } = \tilde { \mathbf { X } } \tilde { \mathbf { X } } ^ { \top }$ . However, if we are working with a feature similarity matrix instead of raw features, we will only have access to $\mathbf { K }$ , not $\mathbf { X }$ . (We will see examples of this in Section 20.4.4 and Section 20.4.6.) Fortunately, we can compute $\tilde { \bf K }$ from $\mathbf { K }$ using the double centering trick:

$$
\tilde { \bf K } = \tilde { \bf X } \tilde { \bf X } ^ { \top } = { \bf C } _ { N } { \bf K } { \bf C } _ { N } = { \bf K } - { \frac { 1 } { N } } { \bf J } { \bf K } - { \frac { 1 } { N } } { \bf K } { \bf J } + { \frac { 1 } { N ^ { 2 } } } { \bf J } { \bf K } { \bf J }
$$

This subtracts the row means and column means from $\mathbf { K }$ , and adds back the global mean that gets subtracted twice, so that both row means and column means of $\tilde { \bf K }$ are equal to zero.

To see why Equation (7.89) is true, consider the scalar form:

$$
\begin{array} { l } { { \displaystyle \tilde { K } _ { i j } = \tilde { \pmb { x } } _ { i } ^ { \top } \tilde { \pmb { x } } _ { j } = ( { \pmb { x } } _ { i } - \frac { 1 } { N } \sum _ { k = 1 } ^ { N } { \pmb { x } } _ { k } ) ( { \pmb { x } } _ { j } - \frac { 1 } { N } \sum _ { l = 1 } ^ { N } { \pmb { x } } _ { l } ) } \ ~ } \\  { \displaystyle ~ = \pmb { x } _ { i } ^ { \top } { \pmb { x } } _ { j } - \frac { 1 } { N } \sum _ { k = 1 } ^ { N } { \pmb { x } } _ { i } ^ { \top } { \pmb { x } } _ { k } - \frac { 1 } { N } \sum _ { k = 1 } ^ { N } { \pmb { x } } _ { j } ^ { \top } { \pmb { x } } _ { k } + \frac { 1 } { N ^ { 2 } } \sum _ { k = 1 } ^ { N } \sum _ { l = 1 } ^ { N } { \pmb { x } } _ { k } ^ { \top } { \pmb { x } } _ { l } } \end{array}
$$

# 7.2.4.5 Distance matrix

Let $\mathbf { X }$ be $N _ { x } \times D$ datamatrix, and $\mathbf { Y }$ be another $N _ { y } \times D$ datamatrix. We can compute the squared pairwise distances between these using

$$
\mathbf { D } _ { i j } = ( \pmb { x } _ { i } - \pmb { y } _ { j } ) ^ { \top } ( \pmb { x } _ { i } - \pmb { y } _ { j } ) = | | \pmb { x } _ { i } | | ^ { 2 } - 2 \pmb { x } _ { i } ^ { \top } \pmb { y } _ { j } + | | \pmb { y } _ { j } | | ^ { 2 }
$$

Let us now write this in matrix form. Let $\hat { \pmb x } = [ | | { \pmb x } _ { 1 } | | ^ { 2 } ; \cdot \cdot \cdot ; | | { \pmb x } _ { N _ { x } } | | ^ { 2 } ] = \mathrm { d i a g } ( { \pmb X } { \pmb X } ^ { 1 } )$ be a vector where each element is the squared norm of the examples in $\mathbf { X }$ , and define $\hat { \boldsymbol y }$ similarly. Then we have

$$
\mathbf { D } = \hat { \pmb { x } } \mathbf { 1 } _ { N _ { y } } ^ { \mathsf { T } } - 2 \mathbf { X } \mathbf { Y } ^ { \mathsf { T } } + \mathbf { 1 } _ { N _ { x } } \hat { \pmb { y } } ^ { \mathsf { T } }
$$

In the case that $\mathbf { X } = \mathbf { Y }$ , we have

$$
\mathbf { D } = \hat { \pmb { x } } \mathbf { 1 } _ { N } ^ { \mathsf { T } } - 2 \mathbf { X } \mathbf { X } ^ { \mathsf { T } } + \mathbf { 1 } _ { N } \hat { \pmb { x } } ^ { \mathsf { T } }
$$

This vectorized computation is often much faster than using for loops.

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

# 7.2.5 Kronecker products \*

If $\mathbf { A }$ is an $m \times n$ matrix and $\mathbf { B }$ is a $p \times q$ matrix, then the Kronecker product $\mathbf { A } \otimes \mathbf { B }$ is the $m p \times n q$ block matrix

$$
\mathbf { A } \otimes \mathbf { B } = \left[ \begin{array} { c c c } { a _ { 1 1 } \mathbf { B } } & { \cdot \cdot \cdot } & { a _ { 1 n } \mathbf { B } } \\ { \vdots } & { \ddots } & { \vdots } \\ { a _ { m 1 } \mathbf { B } } & { \cdot \cdot \cdot } & { a _ { m n } \mathbf { B } } \end{array} \right]
$$

For example,

$$
\left[ \begin{array} { l l } { a _ { 1 1 } } & { a _ { 1 2 } } \\ { a _ { 2 1 } } & { a _ { 2 2 } } \\ { a _ { 3 1 } } & { a _ { 3 2 } } \end{array} \right] \otimes \left[ \begin{array} { l l l } { b _ { 1 1 } } & { b _ { 1 2 } } & { b _ { 1 3 } } \\ { b _ { 2 1 } } & { b _ { 2 2 } } & { b _ { 2 3 } } \end{array} \right] = \left[ \begin{array} { l l l l l l } { a _ { 1 1 } b _ { 1 1 } } & { a _ { 1 1 } b _ { 1 2 } } & { a _ { 1 1 } b _ { 1 3 } } & { a _ { 1 2 } b _ { 1 1 } } & { a _ { 1 2 } b _ { 1 2 } } & { a _ { 1 2 } b _ { 1 2 } } \\ { a _ { 1 1 } b _ { 2 1 } } & { a _ { 1 1 } b _ { 2 2 } } & { a _ { 1 1 } b _ { 2 3 } } & { a _ { 1 2 } b _ { 2 1 } } & { a _ { 1 2 } b _ { 2 2 } } & { a _ { 2 2 } b _ { 1 2 } } & { a _ { 2 2 } b _ { 2 2 } } \\ { a _ { 2 1 } b _ { 1 1 } } & { a _ { 2 1 } b _ { 1 2 } } & { a _ { 2 1 } b _ { 1 3 } } & { a _ { 2 2 } b _ { 1 1 } } & { a _ { 2 2 } b _ { 1 2 } } & { a _ { 2 2 } b _ { 1 2 } } & { a _ { 2 2 } b _ { 2 2 } } \\ { a _ { 2 1 } b _ { 2 1 } } & { a _ { 2 1 } b _ { 2 2 } } & { a _ { 2 1 } b _ { 2 3 } } & { a _ { 2 2 } b _ { 2 1 } } & { a _ { 2 2 } b _ { 2 2 } } & { a _ { 2 2 } b _ { 2 2 } } & { a _ { 2 2 } b _ { 2 2 } } \\ { a _ { 3 1 } b _ { 1 1 } } & { a _ { 3 1 } b _ { 1 2 } } & { a _ { 3 1 } b _ { 1 3 } } & { a _ { 3 2 } b _ { 1 1 } } & { a _ { 3 2 } b _ { 1 1 } } & { a _ { 3 2 } b _ { 1 2 } } & { a _ { 2 1 } b _ { 1 2 } } \\ { a _ { 3 1 } b _ { 2 1 } } & { a _ { 3 1 } b _ { 2 2 } } & { a _ { 3 1 } b _ { 2 3 } } & { a _ { 3 2 } b _ { 2 1 } } & { a _ { 3 2 } b _ { 2 2 } } & { a _ { 2 2 } b _ { 2 2 } } \end{array} \right]
$$

Here are some useful identities:

$$
\begin{array} { r } { ( \mathbf { A } \otimes \mathbf { B } ) ^ { - 1 } = \mathbf { A } ^ { - 1 } \otimes \mathbf { B } ^ { - 1 } } \\ { ( \mathbf { A } \otimes \mathbf { B } ) \mathrm { v e c } ( \mathbf { C } ) = \mathrm { v e c } ( \mathbf { B } \mathbf { C } \mathbf { A } ^ { \top } ) } \end{array}
$$

where vec(M) stacks the columns of M. (If we stack along the rows, we get $( \mathbf { A } \otimes \mathbf { B } ) \mathrm { v e c } ( \mathbf { C } ) =$ $\mathrm { v e c } ( \mathbf { A C B } ^ { \mathsf { T } } )$ .) See [Loa00] for a list of other useful properties.

# 7.2.6 Einstein summation \*

Einstein summation, or einsum for short, is a notational shortcut for working with tensors. The convention was introduced by Einstein [Ein16, sec 5], who later joked to a friend, “I have made a great discovery in mathematics; I have suppressed the summation sign every time that the summation must be made over an index which occurs twice...” [Pai05, p.216]. For example, instead of writing matrix multiplication as $\begin{array} { r } { C _ { i j } = \sum _ { k } A _ { i k } B _ { k j } } \end{array}$ , we can just write it as $C _ { i j } = A _ { i k } B _ { k j }$ , where we drop the $\scriptstyle \sum _ { k }$ .

As a more complex example, suppose we have a 3d tensor $S _ { n t k }$ where $n$ indexes examples in the batch, $t$ indexes locations in the sequence, and $k$ indexes words in a one-hot representation. Let $W _ { k d }$ be an embedding matrix that maps sparse one-hot vectors $\mathbb { R } ^ { k }$ to dense vectors in $\mathbb { R } ^ { d }$ . We can convert the batch of sequences of one-hots to a batch of sequences of embeddings as follows:

$$
E _ { n t d } = \sum _ { k } S _ { n t k } W _ { k d }
$$

We can compute the sum of the embedding vectors for each sequence (to get a global representation of each bag of words) as follows:

$$
E _ { n d } = \sum _ { k } \sum _ { t } S _ { n t k } W _ { k d }
$$

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

Finally we can pass each sequence’s vector representation through another linear transform $V _ { d c }$ to map to the logits over a classifier with $c$ labels:

$$
L _ { n c } = \sum _ { d } E _ { n d } V _ { d c } = \sum _ { d } \sum _ { k } \sum _ { t } S _ { n t k } W _ { k d } V _ { d c }
$$

In einsum notation, we write $L _ { n c } = S _ { n t k } W _ { k d } V _ { d c }$ . We sum over $k$ and $d$ because those indices occur twice on the RHS. We sum over $t$ because that index does not occur on the LHS.

Einsum is implemented in NumPy, Tensorflow, PyTorch, etc. What makes it particularly useful is that it can perform the relevant tensor multiplications in complex expressions in an optimal order, so as to minimize time and intermediate memory allocation.2 The library is best illustrated by the examples in einsum_demo.ipynb.

Note that the speed of einsum depends on the order in which the operations are performed, which depends on the shapes of the relevant arguments. The optimal ordering minimizes the treewidth of the resulting computation graph, as explained in [GASG18]. In general, the time to compute the optimal ordering is exponential in the number of arguments, so it is common to use a greedy approximation. However, if we expect to repeat the same calculation many times, using tensors of the same shape but potentially different content, we can compute the optimal ordering once and reuse it multiple times.

# 7.3 Matrix inversion

In this section, we discuss how to invert different kinds of matrices.

# 7.3.1 The inverse of a square matrix

The inverse of a square matrix $\mathbf { A } \in \mathbb { R } ^ { n \times n }$ is denoted $\mathbf { A } ^ { - 1 }$ , and is the unique matrix such that

$$
\mathbf { A } ^ { - 1 } \mathbf { A } = \mathbf { I } = \mathbf { A } \mathbf { A } ^ { - 1 } .
$$

Note that ${ { \bf A } ^ { - 1 } }$ exists if and only if $\operatorname* { d e t } ( \mathbf { A } ) \neq 0$ . If $\operatorname* { d e t } ( \mathbf { A } ) = 0$ , it is called a singular matrix. The following are properties of the inverse; all assume that $\mathbf { A } , \mathbf { B } \in \mathbb { R } ^ { n \times n }$ are non-singular:

$$
\begin{array} { r l } & { ( \mathbf { A } ^ { - 1 } ) ^ { - 1 } = \mathbf { A } } \\ & { ( \mathbf { A } \mathbf { B } ) ^ { - 1 } = \mathbf { B } ^ { - 1 } \mathbf { A } ^ { - 1 } } \\ & { ( \mathbf { A } ^ { - 1 } ) ^ { \mathsf { T } } = ( \mathbf { A } ^ { \mathsf { T } } ) ^ { - 1 } \triangleq \mathbf { A } ^ { - T } } \end{array}
$$

For the case of a $2 \times 2$ matrix, the expression for $\mathbf { A } ^ { - 1 }$ is simple enough to give explicitly. We have

$$
\mathbf { A } = { \binom { a } { c } } , \mathbf { \Delta } b _ { } ^ { } \mathbf { \Delta } \mathbf { A } ^ { - 1 } = { \frac { 1 } { | \mathbf { A } | } } { \binom { d } { - c } } { \frac { \mathbf { \partial } - b _ { } } { a _ { } ^ { } } }
$$

For a block diagonal matrix, the inverse is obtained by simply inverting each block separately, e.g.,

$$
\left( { \bf A } \quad { \bf 0 } \right) ^ { - 1 } = \left( { \bf A } ^ { - 1 } \quad { \bf 0 } \right)
$$

2. These optimizations are implemented in the opt-einsum library [GASG18]. Its core functionality is included in NumPy and JAX einsum functions, provided you set optimize $\ c =$ True parameter.

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

# 7.3.2 Schur complements \*

In this section, we review some useful results concerning block structured matrices.

Theorem 7.3.1 (Inverse of a partitioned matrix). Consider a general partitioned matrix

$$
\mathbf { M } = \left( \begin{array} { l l } { \mathbf { E } } & { \mathbf { F } } \\ { \mathbf { G } } & { \mathbf { H } } \end{array} \right)
$$

where we assume $\mathbf { E }$ and $\mathbf { H }$ are invertible. We have

$$
\begin{array} { r } { \mathbf { M } ^ { - 1 } = \left( \begin{array} { c c } { ( \mathbf { M } / \mathbf { H } ) ^ { - 1 } } & { - ( \mathbf { M } / \mathbf { H } ) ^ { - 1 } \mathbf { F } \mathbf { H } ^ { - 1 } } \\ { - \mathbf { H } ^ { - 1 } \mathbf { G } ( \mathbf { M } / \mathbf { H } ) ^ { - 1 } } & { \mathbf { H } ^ { - 1 } + \mathbf { H } ^ { - 1 } \mathbf { G } ( \mathbf { M } / \mathbf { H } ) ^ { - 1 } \mathbf { F } \mathbf { H } ^ { - 1 } } \end{array} \right) } \\ { = \left( \begin{array} { c c } { \mathbf { E } ^ { - 1 } + \mathbf { E } ^ { - 1 } \mathbf { F } ( \mathbf { M } / \mathbf { E } ) ^ { - 1 } \mathbf { G } \mathbf { E } ^ { - 1 } } & { - \mathbf { E } ^ { - 1 } \mathbf { F } ( \mathbf { M } / \mathbf { E } ) ^ { - 1 } } \\ { - ( \mathbf { M } / \mathbf { E } ) ^ { - 1 } \mathbf { G } \mathbf { E } ^ { - 1 } } & { ( \mathbf { M } / \mathbf { E } ) ^ { - 1 } } \end{array} \right) } \end{array}
$$

where

$$
\begin{array} { r } { \mathbf { M } / \mathbf { H } \triangleq \mathbf { E } - \mathbf { F } \mathbf { H } ^ { - 1 } \mathbf { G } } \\ { \mathbf { M } / \mathbf { E } \triangleq \mathbf { H } - \mathbf { G } \mathbf { E } ^ { - 1 } \mathbf { F } } \end{array}
$$

We say that $\mathbf { M } / \mathbf { H }$ is the Schur complement of M wrt $\mathbf { H }$ , and M/E is the Schur complement of M wrt $\mathbf { E }$ .

Equation (7.109) and Equation (7.110) are called the partitioned inverse formulae.

Proof. If we could block diagonalize $\mathbf { M }$ , it would be easier to invert. To zero out the top right block of M we can pre-multiply as follows

$$
\left( { \begin{array} { c c } { \mathbf { I } } & { - \mathbf { F H } ^ { - 1 } } \\ { \mathbf { 0 } } & { \mathbf { I } } \end{array} } \right) \left( { \begin{array} { c c } { \mathbf { E } } & { \mathbf { F } } \\ { \mathbf { G } } & { \mathbf { H } } \end{array} } \right) = \left( { \begin{array} { c c } { \mathbf { E } - \mathbf { F H } ^ { - 1 } \mathbf { G } } & { \mathbf { 0 } } \\ { \mathbf { G } } & { \mathbf { H } } \end{array} } \right)
$$

Similarly, to zero out the bottom left we can post-multiply as follows

$$
\left( \begin{array} { c c c } { \mathbf { E } - \mathbf { F } \mathbf { H } ^ { - 1 } \mathbf { G } } & { \mathbf { 0 } } \\ { \mathbf { G } } & { \mathbf { H } } \end{array} \right) \left( \begin{array} { c c c } { \mathbf { I } } & { \mathbf { 0 } } \\ { - \mathbf { H } ^ { - 1 } \mathbf { G } } & { \mathbf { I } } \end{array} \right) = \left( \begin{array} { c c c } { \mathbf { E } - \mathbf { F } \mathbf { H } ^ { - 1 } \mathbf { G } } & { \mathbf { 0 } } \\ { \mathbf { 0 } } & { \mathbf { H } } \end{array} \right)
$$

Putting it all together we get

$$
\underbrace { \left( \mathbf { I } _ { \mathbf { \Lambda } } - \mathbf { F } \mathbf { H } ^ { - 1 } \right) } _ { \mathbf { X } } \underbrace { \left( \mathbf { E } _ { \mathbf { \Lambda } } \mathbf { \Lambda } ^ { \mathbf { F } } \right) } _ { \mathbf { M } } \underbrace { \left( \mathbf { \Lambda } - \mathbf { H } ^ { - 1 } \mathbf { G } _ { \mathbf { \Lambda } } \mathbf { \Lambda } ^ { \mathbf { 0 } } \right) } _ { \mathbf { Z } } = \underbrace { \left( \mathbf { E } - \mathbf { F } \mathbf { H } ^ { - 1 } \mathbf { G } _ { \mathbf { \Lambda } } \mathbf { \Lambda } ^ { \mathbf { 0 } } \right) } _ { \mathbf { W } }
$$

Taking the inverse of both sides yields

$$
\begin{array} { c } { { { \bf Z } ^ { - 1 } { \bf M } ^ { - 1 } { \bf X } ^ { - 1 } = { \bf W } ^ { - 1 } } } \\ { { { \bf M } ^ { - 1 } = { \bf Z } { \bf W } ^ { - 1 } { \bf X } } } \end{array}
$$

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

Substituting in the definitions we get

$$
\begin{array} { r l } { \left( \mathbf { { E } } \mathbf { { \textbf { ~ F } } } \right) ^ { - 1 } = \left( { \mathbf { { I } } } \mathbf { { \Lambda } } \mathbf { { \textbf { ~ 0 } } } \right) \left( \mathbf { { ( M / H ) ^ { - 1 } } } \mathbf { { \Lambda } } \mathbf { { \textbf { 0 } } } \right) \left( \mathbf { { I } } \mathbf { { \Sigma } } - \mathbf { { F H ^ { - 1 } } } \right) } & { } \\ { = \left( { \mathbf { { M } } / \mathbf { H } } \right) ^ { - 1 } } & { \mathbf { { 0 } } } \\ { \qquad } & { = \left( { - \mathbf { { H } } / \mathbf { H } } \mathbf { { \Lambda } } \mathbf { { \textbf { H } } ^ { - 1 } } \mathbf { { \textbf { { H } } ^ { - 1 } } } \right) \left( \mathbf { { I } } \mathbf { { \Lambda } } - \mathbf { { F H } ^ { - 1 } } \right) } \\ { \qquad } & { = \left( { - \mathbf { { \textbf { H } } / H } } \mathbf { { \Lambda } } \mathbf { { \textbf { H } } ^ { - 1 } } \mathbf { { \Lambda } } \mathbf { { \textbf { - } } ( M / H ) ^ { - 1 } } \mathbf { { F H } ^ { - 1 } } \right) } \end{array}
$$

Alternatively, we could have decomposed the matrix $\mathbf { M }$ in terms of $\mathbf { E }$ and $\mathbf { M } / \mathbf { E } = ( \mathbf { H } - \mathbf { G } \mathbf { E } ^ { - 1 } \mathbf { F } )$ , yielding

$$
\left( \mathbf { { E } } \quad \mathbf { { F } } \right) ^ { - 1 } = \left( { { \mathbf { E } } ^ { - 1 } } + \mathbf { { E } } ^ { - 1 } \mathbf { { F } } ( \mathbf { M } / \mathbf { E } ) ^ { - 1 } \mathbf { { G } } { { \mathbf { E } } ^ { - 1 } } \quad - \mathbf { { E } } ^ { - 1 } \mathbf { { F } } ( \mathbf { M } / \mathbf { E } ) ^ { - 1 } \right)
$$

# 7.3.3 The matrix inversion lemma \*

Equating the top left block of the first matrix in Equation (7.119) with the top left block of the matrix in Equation (7.121)

$$
( \mathbf { M } / \mathbf { H } ) ^ { - 1 } = ( \mathbf { E } - \mathbf { F } \mathbf { H } ^ { - 1 } \mathbf { G } ) ^ { - 1 } = \mathbf { E } ^ { - 1 } + \mathbf { E } ^ { - 1 } \mathbf { F } ( \mathbf { H } - \mathbf { G } \mathbf { E } ^ { - 1 } \mathbf { F } ) ^ { - 1 } \mathbf { G } \mathbf { E } ^ { - 1 }
$$

This is known as the matrix inversion lemma or the Sherman-Morrison-Woodbury formula. A typical application in machine learning is the following. Let $\mathbf { X }$ be an $N \times D$ data matrix, and $\pmb { \Sigma }$ be $N \times N$ diagonal matrix. Then we have (using the substitutions $\mathbf { E } = \Sigma$ , $\mathbf { F } = \mathbf { G } ^ { \sf I } = \mathbf { X }$ , and $\mathbf { H } ^ { - 1 } = - \mathbf { I }$ ) the following result:

$$
( \boldsymbol { \Sigma } + \mathbf { X } \mathbf { X } ^ { \mathsf { T } } ) ^ { - 1 } = \boldsymbol { \Sigma } ^ { - 1 } - \boldsymbol { \Sigma } ^ { - 1 } \mathbf { X } ( \mathbf { I } + \mathbf { X } ^ { \mathsf { T } } \boldsymbol { \Sigma } ^ { - 1 } \mathbf { X } ) ^ { - 1 } \mathbf { X } ^ { \mathsf { T } } \boldsymbol { \Sigma } ^ { - 1 }
$$

The LHS takes $O ( N ^ { 3 } )$ time to compute, the RHS takes time $O ( D ^ { 3 } )$ to compute.

Another application concerns computing a rank one update of an inverse matrix. Let $\mathbf { E } = \mathbf { A }$ , ${ \bf F } = { \pmb u }$ , $\mathbf { G } = v ^ { \mathsf { I } }$ , and $H = - 1$ . Then we have

$$
\begin{array} { r l } & { ( \mathbf { A } + \pmb { u } \pmb { v } ^ { \top } ) ^ { - 1 } = \mathbf { A } ^ { - 1 } + \mathbf { A } ^ { - 1 } \pmb { u } ( - 1 - \pmb { v } ^ { \top } \mathbf { A } ^ { - 1 } \pmb { u } ) ^ { - 1 } \pmb { v } ^ { \top } \mathbf { A } ^ { - 1 } } \\ & { \qquad = \mathbf { A } ^ { - 1 } - \displaystyle \frac { \mathbf { A } ^ { - 1 } \pmb { u } \pmb { v } ^ { \top } \mathbf { A } ^ { - 1 } } { 1 + \pmb { v } ^ { \top } \mathbf { A } ^ { - 1 } \pmb { u } } } \end{array}
$$

This is known as the Sherman-Morrison formula.

# 7.3.4 Matrix determinant lemma \*

We now use the above results to derive an efficient way to compute the determinant of a blockstructured matrix.

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

From Equation (7.115), we have

$$
\begin{array} { r l } & { \quad | { \bf X } | | { \bf M } | | { \bf Z } | = | { \bf W } | = | { \bf E } - { \bf F } { \bf H } ^ { - 1 } { \bf G } | | { \bf H } | } \\ & { | \left( \begin{array} { l l } { { \bf E } } & { { \bf F } } \\ { { \bf G } } & { { \bf H } } \end{array} \right) | = | { \bf E } - { \bf F } { \bf H } ^ { - 1 } { \bf G } | | { \bf H } | } \\ & { \quad \quad | { \bf M } | = | { \bf M } / { \bf H } | | { \bf H } | } \\ & { \quad \quad | { \bf M } / { \bf H } | = \frac { | { \bf M } | } { | { \bf H } | } } \end{array}
$$

So we can see that $\mathbf { M } / \mathbf { H }$ acts somewhat like a division operator (hence the notation). Furthermore, we have

$$
\begin{array} { c } { \displaystyle  \mathbf { M }  = \displaystyle \vert \mathbf { M } / \mathbf { H } \vert \displaystyle \vert \mathbf { H }  = \displaystyle \vert \mathbf { M } / \mathbf { E } \vert \displaystyle \vert \mathbf { E } \vert } \\ { \displaystyle  \mathbf { M } / \mathbf { H }  = \frac { \displaystyle \vert \mathbf { M } / \mathbf { E }  \displaystyle \vert \mathbf { E } \vert } { \displaystyle \vert \mathbf { H } \vert } } \\ { \displaystyle  \mathbf { E } - \mathbf { F } \mathbf { H } ^ { - 1 } \mathbf { G }  = \displaystyle \vert \mathbf { H } - \mathbf { G } \mathbf { E } ^ { - 1 } \mathbf { F } \vert \displaystyle \vert \mathbf { H } ^ { - 1 } \vert \displaystyle \vert \mathbf { E } \vert } \end{array}
$$

Hence (setting $\mathbf { E } = \mathbf { A }$ , $\mathbf { F } = - \pmb { u }$ , $\mathbf { G } = v ^ { \top }$ , $\mathbf { H } = 1$ ) we have

$$
| \mathbf { A } + \mathbf { \boldsymbol { u } } \mathbf { \boldsymbol { v } } ^ { \mathsf { T } } | = ( 1 + \mathbf { \boldsymbol { v } } ^ { \mathsf { T } } \mathbf { A } ^ { - 1 } \mathbf { \boldsymbol { u } } ) | \mathbf { A } |
$$

This is known as the matrix determinant lemma.

# 7.3.5 Application: deriving the conditionals of an MVN \*

Consider a joint Gaussian of the form $p ( { \pmb x } _ { 1 } , { \pmb x } _ { 2 } ) = \mathcal { N } ( { \pmb x } | { \pmb \mu } , { \pmb \Sigma } )$ , where

$$
{ \pmb \mu } = \left( { \pmb \mu } _ { 1 } \right) , \ { \pmb \Sigma } = \left( { \pmb \Sigma } _ { 1 1 } \quad { \pmb \Sigma } _ { 1 2 } \right)
$$

In Section 3.2.3, we claimed that

$$
p ( { \pmb x } _ { 1 } | { \pmb x } _ { 2 } ) = \mathcal { N } ( { \pmb x } _ { 1 } | { \pmb \mu } _ { 1 } + \pmb { \Sigma } _ { 1 2 } \pmb { \Sigma } _ { 2 2 } ^ { - 1 } ( { \pmb x } _ { 2 } - { \pmb \mu } _ { 2 } ) , \pmb { \Sigma } _ { 1 1 } - \pmb { \Sigma } _ { 1 2 } \pmb { \Sigma } _ { 2 2 } ^ { - 1 } \pmb { \Sigma } _ { 2 1 } )
$$

In this section, we derive this result using Schur complenents.

Let us factor the joint $p ( \pmb { x } _ { 1 } , \pmb { x } _ { 2 } )$ as $p ( \pmb { x } _ { 2 } ) p ( \pmb { x } _ { 1 } | \pmb { x } _ { 2 } )$ as follows:

$$
p ( { \pmb x } _ { 1 } , { \pmb x } _ { 2 } ) \propto \mathrm { e x p } \left\{ - \frac { 1 } { 2 } \left( { \pmb x } _ { 1 } - { \pmb \mu } _ { 1 } \right) ^ { \top } \left( { \pmb \Sigma } _ { 1 1 } \quad { \pmb \Sigma } _ { 1 2 } \right) ^ { - 1 } \left( { \pmb x } _ { 1 } - { \pmb \mu } _ { 1 } \right) \right\}
$$

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

Using Equation (7.118) the above exponent becomes

$$
\begin{array} { r l } & { p ( \boldsymbol { x } _ { 1 } , \boldsymbol { x } _ { 2 } ) \propto \exp \{ - \displaystyle \frac { 1 } { 2 } ( x _ { 1 } - \mu _ { 1 } ) ^ { \top } ( \frac { \mathbf { I } } { - \Sigma _ { 2 2 } ^ { - 1 } \Sigma _ { 2 1 } } \mathbf { \Sigma } _ { \mathbf { I } } ^ { 0 } ) ( \frac { ( \Sigma / \Sigma _ { 2 2 } ) ^ { - 1 } } { \mathbf { 0 } } \frac { \mathbf { \Sigma } _ { 0 } } { \Sigma _ { 2 2 } ^ { - 1 } } )  } \\ & { \qquad \times ( \displaystyle \mathbf { I } _ { 0 } ^ { \textsf { I } } \quad - \Sigma _ { 1 2 } \Sigma _ { 2 2 } ^ { - 1 } ) ( x _ { 1 } - \mu _ { 1 } ) \} } \\ & { \qquad = \exp \{ - \displaystyle \frac { 1 } { 2 } ( x _ { 1 } - \mu _ { 1 } - \Sigma _ { 1 2 } \Sigma _ { 2 2 } ^ { - 1 } ( x _ { 2 } - \mu _ { 2 } ) ) ^ { \top } ( \Sigma / \Sigma _ { 2 2 } ) ^ { - 1 }  } \\ & { \qquad ( x _ { 1 } - \mu _ { 1 } - \Sigma _ { 1 2 } \Sigma _ { 2 2 } ^ { - 1 } ( x _ { 2 } - \mu _ { 2 } ) ) \} \times \exp \{ - \displaystyle \frac { 1 } { 2 } ( x _ { 2 } - \mu _ { 2 } ) ^ { \top } \Sigma _ { 2 2 } ^ { - 1 } ( x _ { 2 } - \mu _ { 2 } ) \} } \end{array}
$$

This is of the form

$$
\exp ( \operatorname { q u a d r a t i c } \operatorname { f o r m } \ i n \ x _ { 1 } , \ x _ { 2 } ) \times \exp ( \operatorname { q u a d r a t i c } \ \operatorname { f o r m } \ \sin \ x _ { 2 } )
$$

Hence we have successfully factorized the joint as

$$
\begin{array} { r l } & { p ( { \pmb x } _ { 1 } , { \pmb x } _ { 2 } ) = p ( { \pmb x } _ { 1 } | { \pmb x } _ { 2 } ) p ( { \pmb x } _ { 2 } ) } \\ & { \qquad = \mathcal { N } ( { \pmb x } _ { 1 } | { \pmb \mu } _ { 1 | 2 } , { \pmb \Sigma } _ { 1 | 2 } ) \mathcal { N } ( { \pmb x } _ { 2 } | { \pmb \mu } _ { 2 } , { \pmb \Sigma } _ { 2 2 } ) } \end{array}
$$

where the parameters of the conditional distribution can be read off from the above equations using

$$
\begin{array} { r l } & { \pmb { \mu } _ { 1 | 2 } = \pmb { \mu } _ { 1 } + \pmb { \Sigma } _ { 1 2 } \pmb { \Sigma } _ { 2 2 } ^ { - 1 } ( \pmb { x } _ { 2 } - \pmb { \mu } _ { 2 } ) } \\ & { \pmb { \Sigma } _ { 1 | 2 } = \pmb { \Sigma } / \pmb { \Sigma } _ { 2 2 } = \pmb { \Sigma } _ { 1 1 } - \pmb { \Sigma } _ { 1 2 } \pmb { \Sigma } _ { 2 2 } ^ { - 1 } \pmb { \Sigma } _ { 2 1 } } \end{array}
$$

We can also use the fact that $| \mathbf { M } | = | \mathbf { M } / \mathbf { H } | | \mathbf { H } |$ to check the normalization constants are correct:

$$
\begin{array} { c } { { ( 2 \pi ) ^ { ( d _ { 1 } + d _ { 2 } ) / 2 } | \Sigma | ^ { \frac { 1 } { 2 } } = ( 2 \pi ) ^ { ( d _ { 1 } + d _ { 2 } ) / 2 } ( | \Sigma / \Sigma _ { 2 2 } | \ | \Sigma _ { 2 2 } | ) ^ { \frac { 1 } { 2 } } } } \\ { { = ( 2 \pi ) ^ { d _ { 1 } / 2 } | \Sigma / \Sigma _ { 2 2 } | ^ { \frac { 1 } { 2 } } \ ( 2 \pi ) ^ { d _ { 2 } / 2 } | \Sigma _ { 2 2 } | ^ { \frac { 1 } { 2 } } } } \end{array}
$$

where $d _ { 1 } = \dim ( { \pmb x } _ { 1 } )$ and $d _ { 2 } = \dim ( x _ { 2 } )$ .

# 7.4 Eigenvalue decomposition (EVD)

In this section, we review some standard material on the eigenvalue decomposition or EVD of square (real-valued) matrices.

# 7.4.1 Basics

Given a square matrix $\mathbf { A } \in \mathbb { R } ^ { n \times n }$ , we say that $\lambda \in \mathbb R$ is an eigenvalue of $\mathbf { A }$ and $\pmb { u } \in \mathbb { R } ^ { n }$ is the corresponding eigenvector if

$$
{ \bf A } { \bf u } = \lambda { \bf u } , ~ { \bf u } \neq 0 ~ .
$$

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

Intuitively, this definition means that multiplying $\mathbf { A }$ by the vector $\mathbf { \Delta } _ { \mathbf { u } }$ results in a new vector that points in the same direction as $\mathbf { \Delta } _ { \mathbf { u } }$ , but is scaled by a factor $\lambda$ . For example, if $\mathbf { A }$ is a rotation matrix, then $\mathbf { \Delta } _ { \mathbf { u } }$ is the axis of rotation and $\lambda = 1$ .

Note that for any eigenvector $\pmb { u } \in \mathbb { R } ^ { n }$ , and scalar $c \in \mathbb { R }$ ,

$$
\mathbf { A } ( c \pmb { u } ) = c \mathbf { A } \pmb { u } = c \lambda \pmb { u } = \lambda ( c \pmb { u } )
$$

Hence $c u$ is also an eigenvector. For this reason when we talk about “the” eigenvector associated with $\lambda$ , we usually assume that the eigenvector is normalized to have length 1 (this still creates some ambiguity, since $\mathbf { \Delta } _ { \mathbf { u } }$ and $^ { - }$ will both be eigenvectors, but we will have to live with this).

We can rewrite the equation above to state that $( \lambda , \pmb { x } )$ is an eigenvalue-eigenvector pair of $\mathbf { A }$ if

$$
( \lambda { \bf I } - { \bf A } ) { \pmb u } = { \bf 0 } , \quad { \pmb u } \neq 0 .
$$

Now $( \lambda \mathbf { I } - \mathbf { A } ) \pmb { u } = \mathbf { 0 }$ has a non-zero solution to $\mathbf { \Delta } _ { \mathbf { u } }$ if and only if $( \lambda \mathbf { I } - \mathbf { A } )$ has a non-empty nullspace, which is only the case if $( \lambda \mathbf { I } - \mathbf { A } )$ is singular, i.e.,

$$
\operatorname* { d e t } ( \lambda \mathbf { I } - \mathbf { A } ) = 0 .
$$

This is called the characteristic equation of A. (See Exercise 7.2.) The $n$ solutions of this equation are the $n$ (possibly complex-valued) eigenvalues $\lambda _ { i }$ , and ${ \pmb u } _ { i }$ are the corresponding eigenvectors. It is standard to sort the eigenvectors in order of their eigenvalues, with the largest magnitude ones first. The following are properties of eigenvalues and eigenvectors.

The trace of a matrix is equal to the sum of its eigenvalues,

$$
\operatorname { t r } ( \mathbf { A } ) = \sum _ { i = 1 } ^ { n } \lambda _ { i } .
$$

• The determinant of $\mathbf { A }$ is equal to the product of its eigenvalues,

$$
\operatorname* { d e t } ( \mathbf { A } ) = \prod _ { i = 1 } ^ { n } \lambda _ { i } .
$$

• The rank of $\mathbf { A }$ is equal to the number of non-zero eigenvalues of A.

• If A is non-singular then $1 / \lambda _ { i }$ is an eigenvalue of $\mathbf { A } ^ { - 1 }$ with associated eigenvector $\mathbf { \delta } \mathbf { u } _ { i }$ , i.e., $\mathbf { A } ^ { - 1 } \pmb { u } _ { i } = ( 1 / \lambda _ { i } ) \pmb { u } _ { i }$ .

• The eigenvalues of a diagonal or triangular matrix are just the diagonal entries.

# 7.4.2 Diagonalization

We can write all the eigenvector equations simultaneously as

$$
\mathbf { A U } = \mathbf { U } \mathbf { A }
$$

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

where the columns of $\mathbf { U } \in \mathbb { R } ^ { n \times n }$ are the eigenvectors of $\mathbf { A }$ and $\pmb { \Lambda }$ is a diagonal matrix whose entries are the eigenvalues of $\mathbf { A }$ , i.e.,

$$
\mathbf { U } \in \mathbb { R } ^ { n \times n } = \left[ \begin{array} { c c c c } { \vert } & { \vert } & & { \vert } \\ { \pmb { u } _ { 1 } } & { \pmb { u } _ { 2 } } & { \cdots } & { \pmb { u } _ { n } } \\ { \vert } & { \vert } & & { \vert } \end{array} \right] , \ \pmb { \Lambda } = \mathrm { d i a g } ( \lambda _ { 1 } , \ldots , \lambda _ { n } ) \ .
$$

If the eigenvectors of $\mathbf { A }$ are linearly independent, then the matrix $\mathbf { U }$ will be invertible, so

A matrix that can be written in this form is called diagonalizable.

# 7.4.3 Eigenvalues and eigenvectors of symmetric matrices

When A is real and symmetric, it can be shown that all the eigenvalues are real, and the eigenvectors are orthonormal, i.e., $\pmb { u } _ { i } ^ { 1 } \pmb { u } _ { j } = 0$ if $i \neq j$ , and $\pmb { u } _ { i } ^ { \mathsf { I } } \pmb { u } _ { i } = 1$ , where $\mathbf { \Delta } \mathbf { u } _ { i }$ are the eigenvectors. In matrix form, this becomes $\mathbf { U } ^ { \mathsf { T } } \mathbf { U } = \mathbf { U } \mathbf { U } ^ { \mathsf { T } } = \mathbf { I }$ ; hence we see that $\mathbf { U }$ is an orthogonal matrix.

We can therefore represent $\mathbf { A }$ as

$$
\begin{array} { c c } { { \bf A } = { \bf U } { \bf \Lambda } { \bf U } ^ { \top } = \left( \begin{array} { c c c c } { { \| } } & { { \| } } & { { } } & { { \| } } \\ { { u _ { 1 } } } & { { u _ { 2 } } } & { { \ldots } } & { { u _ { n } } } \\ { { \| } } & { { \| } } & { { } } & { { \| } } \end{array} \right) \left( \begin{array} { c c c c } { { \lambda _ { 1 } } } & { { } } & { { } } & { { } } \\ { { } } & { { \lambda _ { 2 } } } & { { } } & { { } } \\ { { } } & { { \ddots } } & { { } } & { { } } \\ { { } } & { { } } & { { \lambda _ { n } } } \end{array} \right) \left( \begin{array} { c c c c } { { - } } & { { u _ { 1 } ^ { \top } } } & { { - } } & { { } } \\ { { - } } & { { u _ { 2 } ^ { \top } } } & { { - } } \\ { { } } & { { \vdots } } & { { } } & { { } } \\ { { - } } & { { u _ { n } ^ { \top } } } & { { - } } \end{array} \right) }  \\  { = \lambda _ { 1 } \left( \begin{array} { c } { { \| } } \\ { { u _ { 1 } } } \\ { { \| } } \end{array} \right) \left( - \begin{array} { c c c } { { \bf \sigma } } & { { u _ { 1 } ^ { \top } } } & { { - } } \end{array} \right) + \cdots + \lambda _ { n } \left( \begin{array} { c } { { \| } } \\ { { u _ { n } } } \\ { { \| } } \end{array} \right) \left( - } & { { u _ { n } ^ { \top } } } & { { - } \right) = \displaystyle \sum _ { i = 1 } ^ { n } \lambda _ { i } { u _ { i } u _ { i } ^ { \top } } } \end{array}
$$

Thus multiplying by any symmetric matrix A can be interpreted as multiplying by a rotation matrix $\mathbf { U } ^ { \mathsf { I } }$ , a scaling matrix $\pmb { \Lambda }$ , followed by an inverse rotation $\mathbf { U }$ .

Once we have diagonalized a matrix, it is easy to invert. Since $\mathbf { A } = \mathbf { U } \mathbf { A } \mathbf { U } ^ { \mathsf { I } }$ , where ${ \bf U } ^ { \parallel } = { \bf U } ^ { - 1 }$ , we have

$$
\mathbf { A } ^ { - 1 } = \mathbf { U } \mathbf { A } ^ { - 1 } \mathbf { U } ^ { \mathsf { T } } = \sum _ { i = 1 } ^ { d } { \frac { 1 } { \lambda _ { i } } } \mathbf { u } _ { i } \mathbf { u } _ { i } ^ { \mathsf { T } }
$$

This corresponds to rotating, unscaling, and then rotating back.

# 7.4.3.1 Checking for positive definiteness

We can also use the diagonalization property to show that a symmetric matrix is positive definite iff all its eigenvalues are positive. To see this, note that

$$
\mathbf { \boldsymbol { x } } ^ { \mathsf { T } } \mathbf { \boldsymbol { A } } \mathbf { \boldsymbol { x } } = \mathbf { \boldsymbol { x } } ^ { \mathsf { T } } \mathbf { \boldsymbol { U } } \mathbf { \boldsymbol { A } } \mathbf { \boldsymbol { U } } ^ { \mathsf { T } } \mathbf { \boldsymbol { x } } = \mathbf { \boldsymbol { y } } ^ { \mathsf { T } } \mathbf { \boldsymbol { A } } \mathbf { \boldsymbol { y } } = \sum _ { i = 1 } ^ { n } \lambda _ { i } \mathbf { \boldsymbol { y } } _ { i } ^ { 2 }
$$

where $\pmb { y } = \mathbf { U } ^ { \top } \pmb { x }$ . Because $y _ { i } ^ { 2 }$ is always nonnegative, the sign of this expression depends entirely on the $\lambda _ { i }$ ’s. If all $\lambda _ { i } > 0$ , then the matrix is positive definite; if all $\lambda _ { i } \geq 0$ , it is positive semidefinite. Likewise, if all $\lambda _ { i } < 0$ or $\lambda _ { i } \leq 0$ , then A is negative definite or negative semidefinite respectively. Finally, if $\mathbf { A }$ has both positive and negative eigenvalues, it is indefinite.

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

![](images/3592a5e517c78c4408ce0822a7ebc7148517c5dc214fdcc266ad69488520daa6.jpg)  
Figure 7.6: Visualization of a level set of the quadratic form $( { \pmb x } - { \pmb \mu } ) ^ { \mathsf { T } } { \pmb \mathrm A } ( { \pmb x } - { \pmb \mu } )$ in 2d. The major and minor axes of the ellipse are defined by the first two eigenvectors of $\mathbf { A }$ , namely $\mathbf { \delta } \mathbf { u } _ { 1 }$ and $\mathbf { \delta } \mathbf { u } _ { 2 }$ . Adapted from Figure 2.7 of [Bis06]. Generated by gaussEvec.ipynb.

# 7.4.4 Geometry of quadratic forms

A quadratic form is a function that can be written as

$$
f ( \pmb { x } ) = \pmb { x } ^ { \top } \mathbf { A } \pmb { x }
$$

where $\boldsymbol { x } \in \mathbb { R } ^ { n }$ and $\mathbf { A }$ is a positive definite, symmetric $n$ -by- $n$ matrix. Let $\mathbf { A } = \mathbf { U } \mathbf { A } \mathbf { U } ^ { \mathsf { T } }$ be a diagonalization of $\mathbf { A }$ (see Section 7.4.3). Hence we can write

$$
f ( \pmb { x } ) = \pmb { x } ^ { \top } \mathbf { A } \pmb { x } = \pmb { x } ^ { \top } \mathbf { U } \mathbf { A } \mathbf { U } ^ { \top } \pmb { x } = \pmb { y } ^ { \top } \mathbf { A } \pmb { y } = \sum _ { i = 1 } ^ { n } \lambda _ { i } y _ { i } ^ { 2 }
$$

where $y _ { i } = \pmb { x } ^ { \top } \pmb { u } _ { i }$ and ${ { \lambda } _ { i } } > 0$ (since $\mathbf { A }$ is positive definite). The level sets of $f ( { \pmb x } )$ define hyper-ellipsoids. For example, in 2d, we have

$$
\lambda _ { 1 } y _ { 1 } ^ { 2 } + \lambda _ { 2 } y _ { 2 } ^ { 2 } = r
$$

which is the equation of a 2d ellipse. This is illustrated in Figure 7.6. The eigenvectors determine the orientation of the ellipse, and the eigenvalues determine how elongated it is.

# 7.4.5 Standardizing and whitening data

Suppose we have a dataset $\mathbf { X } \in \mathbb { R } ^ { N \times D }$ . It is common to preprocess the data so that each column has zero mean and unit variance. This is called standardizing the data, as we discuss in Section 10.2.8. Although standardizing forces the variance to be 1, it does not remove correlation between the columns. To do that, we must whiten the data. To define this, let the empirical covariance matrix be $\begin{array} { r } { \pmb { \Sigma } = \frac { 1 } { N } \pmb { \mathrm { X } } ^ { \top } \pmb { \mathrm { X } } } \end{array}$ , and let $\begin{array} { r } { \pmb { \Sigma } = \mathbf { E } \mathbf { D } \mathbf { E } ^ { \top } } \end{array}$ be its diagonalization. Equivalently, let [U, S, V] be the SVD of $\mathbf { X }$ (so $\mathbf { E } = \mathbf { V }$ and $\mathbf { D } = \mathbf { S } ^ { 2 }$ , as we discuss in Section 20.1.3.3.) Now define

$$
\mathbf { W } _ { p c a } = \mathbf { D } ^ { - \frac { 1 } { 2 } } \mathbf { E } ^ { \top }
$$

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

![](images/0d713a0e9c7feec372558731c5f072c2b890201d87a18663d2f4381abb4dbbd0.jpg)  
Figure 7.7: (a) Height/weight data. (b) Standardized. (c) PCA Whitening. (d) ZCA whitening. Numbers refer to the first 4 datapoints, but there are 73 datapoints in total. Generated by height_weight_whiten_plot.ipynb.

This is called the PCA whitening matrix. (We discuss PCA in Section 20.1.) Let $\pmb { y } = \mathbf { W } _ { p c a } \pmb { x }$ be a transformed vector. We can check that its covariance is white as follows:

$$
\operatorname { C o v } \left[ { \boldsymbol { y } } \right] = \mathbf { W } \mathbb { E } \left[ { \boldsymbol { x } } { \boldsymbol { x } } ^ { \mathsf { T } } \right] \mathbf { W } ^ { \mathsf { T } } = \mathbf { W } \Sigma \mathbf { W } ^ { \mathsf { T } } = ( \mathbf { D } ^ { - { \frac { 1 } { 2 } } } \mathbf { E } ^ { \mathsf { T } } ) ( \mathbf { E } \mathbf { D } \mathbf { E } ^ { \mathsf { T } } ) ( \mathbf { E } \mathbf { D } ^ { - { \frac { 1 } { 2 } } } ) = \mathbf { I }
$$

The whitening matrix is not unique, since any rotation of it, $\mathbf { W } = \mathbf { R } \mathbf { W } _ { p c a }$ , will still maintain the whitening property, i.e., $\mathbf { W } ^ { \mathsf { T } } \mathbf { W } = \pmb { \Sigma } ^ { - 1 }$ . For example, if we take $\mathbf R = \mathbf E$ , we get

$$
\mathbf { W } _ { z c a } = \mathbf { E D } ^ { - { \frac { 1 } { 2 } } } \mathbf { E } ^ { \mathsf { T } } = \mathbf { \Sigma } \mathbf { \Sigma } ^ { - { \frac { 1 } { 2 } } } = \mathbf { V } \mathbf { S } ^ { - 1 } \mathbf { V } ^ { \mathsf { T } }
$$

This is called Mahalanobis whitening or ZCA. (ZCA stands for “zero-phase component analysis”, and was introduced in [BS97].) The advantage of ZCA whitening over PCA whitening is that the resulting transformed data is as close as possible to the original data (in the least squares sense) [Amo17]. This is illustrated in Figure 7.7. When applied to images, the ZCA transformed data

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license vectors still look like images. This is useful when the method is used inside a deep learning system [KH09].

# 7.4.6 Power method

We now describe a simple iterative method for computing the eigenvector corresponding to the largest eigenvalue of a real, symmetric matrix; this is called the power method. This can be useful when the matrix is very large but sparse. For example, it is used by Google’s PageRank to compute the stationary distribution of the transition matrix of the world wide web (a matrix of size about 3 billion by 3 billion!). In Section 7.4.7, we will see how to use this method to compute subsequent eigenvectors and values.

Let $\mathbf { A }$ be a matrix with orthonormal eigenvectors $\mathbf { \Delta } \mathbf { u } _ { i }$ and eigenvalues $| \lambda _ { 1 } | > | \lambda _ { 2 } | \geq \cdots \geq | \lambda _ { m } | \geq 0$ , so $\mathbf { A } = \mathbf { U } \mathbf { A } \mathbf { U } ^ { \mathsf { I } }$ . Let be an arbitrary vector in the range of $\mathbf { A }$ , so $\mathbf { A } \pmb { x } = \pmb { v } _ { ( 0 ) }$ for some . Hence $\mathbf { \boldsymbol { v } } _ { ( 0 ) }$ $_ { \ast }$ we can write ${ \pmb v } _ { ( 0 ) }$ as

$$
\pmb { v } _ { 0 } = \mathbf { U } ( \pmb { \Lambda } \mathbf { U } ^ { \top } \pmb { x } ) = a _ { 1 } \pmb { u } _ { 1 } + \cdot \cdot \cdot + a _ { m } \pmb { u } _ { m }
$$

for some constants $a _ { i }$ . We can now repeatedly multiply $_ { v }$ by $\mathbf { A }$ and renormalize:

$$
\mathbf { } v _ { t } \propto \mathbf { A } v _ { t - 1 }
$$

(We normalize at each iteration for numerical stability.) Since ${ \mathbf { } } { \mathbf { } } { \mathbf { } } ^ { \mathbf { } } { \mathbf { } } ^ { \mathbf { } } { \mathbf { } } ^ { \mathbf { } } { \mathbf { } } ^ { \mathbf { } } { \mathbf { } } ^ { \mathbf { } } { \mathbf { } } ^ { \mathbf { } } { \mathbf { } } ^ { \mathbf { } } { \mathbf { } } ^ { \mathbf { } } { \mathbf { } } ^ { \mathbf { } } { \mathbf { } } ^ { \mathbf { } } { \mathbf { } } ^ { \mathbf { } } { \mathbf { } } ^ { \mathbf { } } { \mathbf { } } ^ { \mathbf { } } { \mathbf { } } ^ { \mathbf { } } { \mathbf { } } ^ { \mathbf { } } { \mathbf { } } ^ { \mathbf { } } { \mathbf { } } ^ { \mathbf { } } { \mathbf { } } ^ { \mathbf { } } { \mathbf { } } ^ { \mathbf { } } { \mathbf { } } ^ { \mathbf { } } { \mathbf { } } ^ { \mathbf { } } { \mathbf { } } ^ { \mathbf { } } { \mathbf { } } ^ { \mathbf { } } { \mathbf { } } { \mathbf { } } ^ { \mathbf { } } { \mathbf { } } ^ { \mathbf { } } { \mathbf { } } { \mathbf } ^ { \mathbf { } } { \mathbf { } } { \mathbf { } } ^ { \mathbf { } } { \mathbf } { \mathbf { } } ^ { \mathbf { } } { \mathbf } { \mathbf { } } ^ { \mathbf { } } { \mathbf } { \mathbf { } } ^ { \mathbf { } \mathbf { } } { \mathbf } { \mathbf } { } ^ { \mathbf { } \mathbf { } } { \mathbf } { \mathbf } { \mathbf } { \mathbf } ^ { } { \mathbf } { \mathbf } { \mathbf } { \mathbf } { \mathbf } { \mathbf } { } ^ { \mathbf } { \mathbf } { \mathbf } { \mathbf } { \mathbf } { \mathbf } \mathbf { } \mathbf { } \mathbf { } \mathbf { } \mathbf { } \mathbf { } \mathbf \mathbf { } \mathbf { } \mathbf { } \mathbf { } \mathbf \mathbf { } \mathbf { } \mathbf \mathbf { } \mathbf { } \mathbf \mathbf { } \mathbf { } \mathbf \mathbf { } \mathbf \mathbf { } \mathbf { } \mathbf \mathbf { } \mathbf \mathbf { } \mathbf \mathbf { } \mathbf \mathbf { } \mathbf \mathbf { } \mathbf \mathbf \mathbf { } \mathbf \mathbf { } \mathbf \mathbf \mathbf { } \mathbf \mathbf { \mathbf } \mathbf \mathbf { \mathbf } \mathbf \mathbf { } \mathbf \mathbf \mathbf { \mathbf } \mathbf \mathbf { \mathbf } \mathbf \mathbf \mathbf { \mathbf } \mathbf \mathbf \mathbf { \mathbf \mathbf } \mathbf \mathbf { \mathbf \mathbf \mathbf } \mathbf \mathbf { \mathbf \mathbf \mathbf \mathbf } \mathbf \mathbf  \mathbf \mathbf \mathbf \mathbf \mathbf { } \mathbf \mathbf \mathbf \mathbf \mathbf \mathbf \mathbf { \mathbf } \mathbf \mathbf \mathbf \mathbf \mathbf \mathbf \mathbf \mathbf \mathbf  \mathbf \mathbf \mathbf \mathbf \mathbf \mathbf \mathbf \mathbf \mathbf \mathbf \mathbf \mathbf \mathbf \mathbf \mathbf \mathbf \mathbf  \mathbf \mathbf \mathbf \mathbf \mathbf \mathbf \mathbf \mathbf \mathbf \mathbf \mathbf \mathbf \mathbf \mathbf \mathbf \mathbf \mathbf \mathbf \mathbf \$ is a multiple of $\mathbf { A } ^ { t } \pmb { v } _ { 0 }$ , we have

$$
\begin{array} { r l } & { \pmb { v } _ { t } \propto a _ { 1 } \lambda _ { 1 } ^ { t } \pmb { u } _ { 1 } + a _ { 2 } \lambda _ { 2 } ^ { t } \pmb { u } _ { 2 } + \cdot \cdot \cdot + a _ { m } \lambda _ { m } ^ { t } \pmb { u } _ { m } } \\ & { \quad = \lambda _ { 1 } ^ { t } ( a _ { 1 } \pmb { u } _ { 1 } + a _ { 1 } ( \lambda _ { 2 } / \lambda _ { 1 } ) ^ { t } \pmb { u } _ { 2 } + \cdot \cdot \cdot + a _ { m } ( \lambda _ { m } / \lambda _ { 1 } ) ^ { t } \pmb { u } _ { m } ) } \\ & { \quad  \lambda _ { 1 } ^ { t } a _ { 1 } \pmb { u } _ { 1 } } \end{array}
$$

since $\frac { | \lambda _ { k } | } { | \lambda _ { 1 } | } < 1$ for $k > 1$ (assuming the eigenvalues are sorted in descending order). So we see that this converges to $\mathbf { \Delta } \mathbf { u } _ { 1 }$ , although not very quickly (the error is reduced by approximately $| \lambda _ { 2 } / \lambda _ { 1 } |$ at each iteration). The only requirement is that the initial guess satisfy $\pmb { v } _ { 0 } ^ { 1 } \pmb { u } _ { 1 } \neq 0$ , which will be true for a random ${ \pmb v } _ { 0 }$ with high probability.

We now discuss how to compute the corresponding eigenvalue, $\lambda _ { 1 }$ . Define the Rayleigh quotient to be

$$
R ( \mathbf { A } , \pmb { x } ) \triangleq \frac { \pmb { x } ^ { \top } \mathbf { A } \pmb { x } } { \pmb { x } ^ { \top } \pmb { x } }
$$

Hence

$$
R ( \mathbf { A } , { \boldsymbol { \mathbf { u } } } _ { i } ) = { \frac { { \boldsymbol { \mathbf { u } } } _ { i } ^ { \mathsf { T } } \mathbf { A } { \boldsymbol { \mathbf { u } } } _ { i } } { { \boldsymbol { \mathbf { u } } } _ { i } ^ { \mathsf { T } } { \boldsymbol { \mathbf { u } } } _ { i } } } = { \frac { \lambda _ { i } { \boldsymbol { \mathbf { u } } } _ { i } ^ { \mathsf { T } } { \boldsymbol { \mathbf { u } } } _ { i } } { { \boldsymbol { \mathbf { u } } } _ { i } ^ { \mathsf { T } } { \boldsymbol { \mathbf { u } } } _ { i } } } = \lambda _ { i }
$$

Thus we can easily compute $\lambda _ { 1 }$ from $\mathbf { \Delta } \mathbf { u } _ { 1 }$ and $\mathbf { A }$ . See power_method_demo.ipynb for a demo.

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

# 7.4.7 Deflation

Suppose we have computed the first eigenvector and value $\mathbf { \delta } u _ { 1 } , \lambda _ { 1 }$ by the power method. We now describe how to compute subsequent eigenvectors and values. Since the eigenvectors are orthonormal, and the eigenvalues are real, we can project out the $\mathbf { \delta u } _ { 1 }$ component from the matrix as follows:

$$
\mathbf { A } ^ { ( 2 ) } = ( \mathbf { I } - \pmb { u } _ { 1 } \pmb { u } _ { 1 } ^ { \mathsf { T } } ) \mathbf { A } ^ { ( 1 ) } = \mathbf { A } ^ { ( 1 ) } - \pmb { u } _ { 1 } \pmb { u } _ { 1 } ^ { \mathsf { T } } \mathbf { A } ^ { ( 1 ) } = \mathbf { A } ^ { ( 1 ) } - \lambda _ { 1 } \pmb { u } _ { 1 } \pmb { u } _ { 1 } ^ { \mathsf { T } }
$$

This is called matrix deflation. We can then apply the power method to $\mathbf { A } ^ { ( 2 ) }$ , which will find the largest eigenvector/value in the subspace orthogonal to $\mathbf { \Delta } \mathbf { u } _ { 1 }$ .

In Section 20.1.2, we show that the optimal estimate $\hat { \bf W }$ for the PCA model (described in Section 20.1) is given by the first $K$ eigenvectors of the empirical covariance matrix. Hence deflation can be used to implement PCA. It can also be modified to implement sparse PCA [Mac09].

# 7.4.8 Eigenvectors optimize quadratic forms

We can use matrix calculus to solve an optimization problem in a way that leads directly to eigenvalue/eigenvector analysis. Consider the following, equality constrained optimization problem:

$$
\begin{array} { r } { \operatorname* { m a x } _ { \pmb { x } \in \mathbb { R } ^ { n } } \ \pmb { x } ^ { \top } \mathbf { A } \pmb { x } \quad \mathrm { ~ s u b j e c t ~ t o ~ } \| \pmb { x } \| _ { 2 } ^ { 2 } = 1 } \end{array}
$$

for a symmetric matrix $\mathbf { A } \in \mathbb { S } ^ { n }$ . A standard way of solving optimization problems with equality constraints is by forming the Lagrangian, an objective function that includes the equality constraints (see Section 8.5.1). The Lagrangian in this case can be given by

$$
\begin{array} { r } { \mathcal { L } ( \pmb { x } , \lambda ) = \pmb { x } ^ { \top } \mathbf { A } \pmb { x } + \lambda ( 1 - \pmb { x } ^ { \top } \pmb { x } ) } \end{array}
$$

where $\lambda$ is called the Lagrange multiplier associated with the equality constraint. It can be established that for $x ^ { * }$ to be a optimal point to the problem, the gradient of the Lagrangian has to be zero at $x ^ { * }$ (this is not the only condition, but it is required). That is,

$$
\nabla _ { \pmb { x } } \mathcal { L } ( \pmb { x } , \lambda ) = 2 \mathbf { A } ^ { \top } \pmb { x } - 2 \lambda \pmb { x } = \mathbf { 0 } .
$$

Notice that this is just the linear equation $\mathbf { A } { \boldsymbol { \mathbf { \mathit { x } } } } = \lambda { \boldsymbol { \mathbf { \mathit { x } } } }$ . This shows that the only points which can possibly maximize (or minimize) ${ \pmb x } ^ { 1 } { \bf A } { \pmb x }$ assuming $\pmb { x } ^ { 1 } \pmb { x } = 1$ are the eigenvectors of $\mathbf { A }$ .

# 7.5 Singular value decomposition (SVD)

We now discuss the SVD, which generalizes EVD to rectangular matrices.

# 7.5.1 Basics

Any (real) $m \times n$ matrix A can be decomposed as

$$
\mathbf { A } = \mathbf { U S V } ^ { \mathsf { T } } = \sigma _ { 1 } \left( \begin{array} { l } { | } \\ { u _ { 1 } } \\ { | } \end{array} \right) \left( - \begin{array} { l l }  \begin{array} { l l } { v _ { \mathsf { I } } ^ { \mathsf { T } } } & { - } \end{array} \right) + \cdots + \sigma _ { r } \left( \begin{array} { l } { | } \\ { u _ { r } } \\ { | } \end{array} \right) \left( - \begin{array} { l l } { v _ { r } ^ { \mathsf { T } } } & { - } \end{array} \right) \end{array}
$$

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license where $\mathbf { U }$ is an $m \times m$ whose columns are orthornormal (so $\mathbf { U } ^ { \mathsf { I } } \mathbf { U } = \mathbf { I } _ { m }$ ), $\mathbf { V }$ is $n \times n$ matrix whose rows and columns are orthonormal (so $\mathbf { V } ^ { \mathsf { T } } \mathbf { V } = \mathbf { V } \mathbf { V } ^ { \mathsf { T } } = \mathbf { I } _ { n }$ ), and $\mathbf { s }$ is a $m \times n$ matrix containing the $r = \operatorname* { m i n } ( m , n )$ singular values $\sigma _ { i } \geq 0$ on the main diagonal, with 0s filling the rest of the matrix. The columns of U are the left singular vectors, and the columns of $\mathbf { V }$ are the right singular vectors. This is called the singular value decomposition or SVD of the matrix. See Figure 7.8 for an example.

![](images/dbdb7bd9235a7fbb164e83daad3a6638db598f5cb8d6b00106cc5de2c925f4b7.jpg)  
Figure 7.8: SVD decomposition of a matrix, $\mathbf { A } = \mathbf { U } \mathbf { S } \mathbf { V } ^ { \mathsf { T } }$ . The shaded parts of each matrix are not computed in the economy-sized version. (a) Tall skinny matrix. (b) Short wide matrix.

As is apparent from Figure 7.8a, if $m > n$ , there are at most $n$ singular values, so the last $m - n$ columns of $\mathbf { U }$ are irrelevant (since they will be multiplied by 0). The economy sized SVD, also called a thin SVD, avoids computing these unnecessary elements. In other words, if we write the $\mathbf { U }$ matrix as $\mathbf { U } = [ \mathbf { U } _ { 1 } , \mathbf { U } _ { 2 } ]$ , we only compute $\mathbf { U } _ { 1 }$ . Figure 7.8b shows the opposite case, where $m < n$ , where we represent $\mathbf { V } = [ \mathbf { V } _ { 1 } ; \mathbf { V } _ { 2 } ]$ , and only compute $\mathbf { V } _ { 1 }$ .

The cost of computing the SVD is $O ( \operatorname* { m i n } ( m n ^ { 2 } , m ^ { 2 } n ) )$ . Details on how it works can be found in standard linear algebra textbooks.

# 7.5.2 Connection between SVD and EVD

If $\mathbf { A }$ is real, symmetric and positive definite, then the singular values are equal to the eigenvalues, and the left and right singular vectors are equal to the eigenvectors (up to a sign change):

$$
\mathbf { A } = \mathbf { U } \mathbf { S } \mathbf { V } ^ { \mathsf { T } } = \mathbf { U } \mathbf { S } \mathbf { U } ^ { \mathsf { T } } = \mathbf { U } \mathbf { S } \mathbf { U } ^ { - 1 }
$$

Note, however, that NumPy always returns the singular values in decreasing order, whereas the eigenvalues need not necessarily be sorted.

In general, for an arbitrary real matrix $\mathbf { A }$ , if $\mathbf { A } = \mathbf { U } \mathbf { S } \mathbf { V } ^ { \parallel }$ , we have

$$
\mathbf { A } ^ { \mathsf { T } } \mathbf { A } = \mathbf { V } \mathbf { S } ^ { \mathsf { T } } \mathbf { U } ^ { \mathsf { T } } \mathbf { \Psi } \mathbf { U } \mathbf { S } \mathbf { V } ^ { \mathsf { T } } = \mathbf { V } ( \mathbf { S } ^ { \mathsf { T } } \mathbf { S } ) \mathbf { V } ^ { \mathsf { T } }
$$

Hence

$$
( \mathbf { A } ^ { \mathsf { T } } \mathbf { A } ) \mathbf { V } = \mathbf { V } \mathbf { D } _ { n }
$$

so the eigenvectors of $\mathbf { A } ^ { \mathsf { T } } \mathbf { A }$ are equal to $\mathbf { V }$ , the right singular vectors of $\mathbf { A }$ , and the eigenvalues of $\mathbf { A } ^ { \mathsf { T } } \mathbf { A }$ are equal to ${ \mathbf D } _ { n } = { \mathbf S } ^ { \mathsf T } { \mathbf S }$ , which is an $n \times n$ diagonal matrix containing the squared singular values. Similarly

$$
\begin{array} { c } { \mathbf { A } \mathbf { A } ^ { \mathsf { T } } = \mathbf { U } \mathbf { S } \mathbf { V } ^ { \mathsf { T } } \mathbf { \nabla } \mathbf { V } \mathbf { S } ^ { \mathsf { T } } \mathbf { U } ^ { \mathsf { T } } = \mathbf { U } ( \mathbf { S } \mathbf { S } ^ { \mathsf { T } } ) \mathbf { U } ^ { \mathsf { T } } } \\ { ( \mathbf { A } \mathbf { A } ^ { \mathsf { T } } ) \mathbf { U } = \mathbf { U } \mathbf { D } _ { m } } \end{array}
$$

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

so the eigenvectors of $\mathbf { A A } ^ { 1 }$ are equal to $\mathbf { U }$ , the left singular vectors of $\mathbf { A }$ , and the eigenvalues of $\mathbf { A A } ^ { \mathsf { T } }$ are equal to $\mathbf { D } _ { m } = \mathbf { S } \mathbf { S } ^ { \mathsf { I } }$ , which is an $m \times m$ diagonal matrix containing the squared singular values. In summary,

$$
\mathbf { U } = \mathrm { e v e c } ( \mathbf { A } \mathbf { A } ^ { \mathsf { T } } ) , \ \mathbf { V } = \mathrm { e v e c } ( \mathbf { A } ^ { \mathsf { T } } \mathbf { A } ) , \ \mathbf { D } _ { m } = \mathrm { e v a l } ( \mathbf { A } \mathbf { A } ^ { \mathsf { T } } ) , \mathbf { D } _ { n } = \mathrm { e v a l } ( \mathbf { A } ^ { \mathsf { T } } \mathbf { A } )
$$

If we just use the computed (non-zero) parts in the economy-sized SVD, then we can define

$$
\mathbf { D } = \mathbf { S } ^ { 2 } = \mathbf { S } ^ { \mathsf { T } } \mathbf { S } = \mathbf { S } \mathbf { S } ^ { \mathsf { T } }
$$

Note also that an EVD does not always exist, even for square $\mathbf { A }$ , whereas an SVD always exists.

# 7.5.3 Pseudo inverse

The Moore-Penrose pseudo-inverse of $\mathbf { A }$ , pseudo inverse denoted $\mathbf { A } ^ { \dagger }$ , is defined as the unique matrix that satisfies the following 4 properties:

$$
\mathbf { A } \mathbf { A } ^ { \dagger } \mathbf { A } = \mathbf { A } , \ \mathbf { A } ^ { \dagger } \mathbf { A } \mathbf { A } ^ { \dagger } = \mathbf { A } ^ { \dagger } , ( \mathbf { A } \mathbf { A } ^ { \dagger } ) ^ { \top } = \mathbf { A } \mathbf { A } ^ { \dagger } , ( \mathbf { A } ^ { \dagger } \mathbf { A } ) ^ { \top } = \mathbf { A } ^ { \dagger } \mathbf { A }
$$

If $\mathbf { A }$ is square and non-singular, then ${ \bf A } ^ { \dagger } = { \bf A } ^ { - 1 }$ .

If $m > n$ (tall, skinny) and the columns of $\mathbf { A }$ are linearly independent (so $\mathbf { A }$ is full rank), then

$$
\mathbf { A } ^ { \dagger } = ( \mathbf { A } ^ { \mathsf { T } } \mathbf { A } ) ^ { - 1 } \mathbf { A } ^ { \mathsf { T } }
$$

which is the same expression as arises in the normal equations (see Section 11.2.2.1). In this case, $\mathbf { A } ^ { \dagger }$ is a left inverse of $\mathbf { A }$ because

$$
\mathbf { A } ^ { \dagger } \mathbf { A } = ( \mathbf { A } ^ { \mathsf { T } } \mathbf { A } ) ^ { - 1 } \mathbf { A } ^ { \mathsf { T } } \mathbf { A } = \mathbf { I }
$$

but is not a right inverse because

$$
\mathbf { A } \mathbf { A } ^ { \dagger } = \mathbf { A } ( \mathbf { A } ^ { \mathsf { T } } \mathbf { A } ) ^ { - 1 } \mathbf { A } ^ { \mathsf { T } }
$$

only has rank $n$ , and so cannot be the $m \times m$ identity matrix.

If $m < n$ (short, fat) and the rows of $\mathbf { A }$ are linearly independent (so $\mathbf { A } ^ { 1 }$ is full rank), then the pseudo inverse is

$$
\mathbf { A } ^ { \dagger } = \mathbf { A } ^ { \mathsf { T } } ( \mathbf { A A } ^ { \mathsf { T } } ) ^ { - 1 }
$$

In this case, $\mathbf { A } ^ { \dagger }$ is a right inverse of $\mathbf { A }$ .

We can compute the pseudo inverse using the SVD decomposition $\mathbf { A } = \mathbf { U } \mathbf { S } \mathbf { V } ^ { \parallel }$ . In particular, one can show that

$$
\mathbf { A } ^ { \dagger } = \mathbf { V } [ \mathrm { d i a g } ( 1 / \sigma _ { 1 } , \cdots , 1 / \sigma _ { r } , 0 , \cdots , 0 ) ] \mathbf { U } ^ { \mathsf { T } } = \mathbf { V } \mathbf { S } ^ { - 1 } \mathbf { U } ^ { \mathsf { T } }
$$

where $r$ is the rank of the matrix, and where we define $\mathbf { S } ^ { - 1 } = \mathrm { d i a g } ( \sigma _ { 1 } ^ { - 1 } , \ldots , \sigma _ { r } ^ { - 1 } , 0 , \ldots , 0 )$ . Indeed if the matrices were square and full rank we would have

$$
( \mathbf { U S V } ^ { \mathsf { T } } ) ^ { - 1 } = \mathbf { V S } ^ { - 1 } \mathbf { U } ^ { \mathsf { T } }
$$

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

# 7.5.4 SVD and the range and null space of a matrix \*

In this section, we show that the left and right singular vectors form an orthonormal basis for the range and null space.

From Equation (7.178) we have

$$
\mathbf { A } x = \sum _ { j : \sigma _ { j } > 0 } \sigma _ { j } ( \pmb { v } _ { j } ^ { \top } \pmb { x } ) \pmb { u } _ { j } = \sum _ { j = 1 } ^ { r } \sigma _ { j } ( \pmb { v } _ { j } ^ { \top } \pmb { x } ) \pmb { u } _ { j }
$$

where $r$ is the rank of $\mathbf { A }$ . Thus any ${ \bf A } x$ can be written as a linear combination of the left singular vectors $\mathbf { u } _ { 1 } , \ldots , \mathbf { u } _ { r }$ , so the range of $\mathbf { A }$ is given by

$$
\mathrm { r a n g e } ( \mathbf { A } ) = \mathrm { s p a n } \left( \{ \pmb { u } _ { j } : \sigma _ { j } > 0 \} \right)
$$

with dimension $r$ .

To find a basis for the null space, let us now define a second vector $\boldsymbol { y } \in \mathbb { R } ^ { n }$ that is a linear combination solely of the right singular vectors for the zero singular values,

$$
{ \pmb y } = \sum _ { j : \sigma _ { j } = 0 } c _ { j } { \pmb v } _ { j } = \sum _ { j = r + 1 } ^ { n } c _ { j } { \pmb v } _ { j }
$$

Since the ${ \pmb v } _ { j }$ ’s are orthonormal, we have

$$
\mathbf { A } y = \mathbf { U } \left( \begin{array} { c } { \sigma _ { 1 } v _ { 1 } ^ { \top } y } \\ { \vdots } \\ { \sigma _ { r } v _ { r } ^ { \top } y } \\ { \sigma _ { r + 1 } v _ { r + 1 } ^ { \top } y } \\ { \vdots } \\ { \sigma _ { n } v _ { n } ^ { \top } y } \end{array} \right) = \mathbf { U } \left( \begin{array} { c } { \sigma _ { 1 } 0 } \\ { \vdots } \\ { \sigma _ { r } 0 } \\ { 0 v _ { r + 1 } ^ { \top } y } \\ { \vdots } \\ { 0 v _ { n } ^ { \top } y } \end{array} \right) = \mathbf { U 0 } = \mathbf { 0 }
$$

Hence the right singular vectors form an orthonormal basis for the null space:

$$
{ \mathrm { n u l l s p a c e } } ( \mathbf { A } ) = { \mathrm { s p a n } } \left( \left\{ \pmb { v } _ { j } : \sigma _ { j } = 0 \right\} \right)
$$

with dimension $n - r$ . We see that

$$
\mathrm { d i m } ( \mathrm { r a n g e } ( \mathbf { A } ) ) + \mathrm { d i m } ( \mathrm { n u l l s p a c e } ( \mathbf { A } ) ) = r + ( n - r ) = n
$$

In words, this is often written as

$$
{ \mathrm { r a n k } } + { \mathrm { n u l l i t y } } = n
$$

This is called the rank-nullity theorem. It follows from this that the rank of a matrix is the number of nonzero singular values.

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

![](images/14b518e33c1b2c4a50afc2b96541f060d737f84989bba5cfdf6b5f8517e6147e.jpg)  
Figure 7.9: Low rank approximations to an image. Top left: The original image is of size $2 0 0 \times 3 2 0$ , so has rank 200. Subsequent images have ranks 2, 5, and 20. Generated by svd_image_demo.ipynb.

![](images/079c099c238eecfaadd0a6caa6009b285f2d62aecce2e12c6592b1b95edf159d.jpg)  
Figure 7.10: First 100 log singular values for the clown image (red line), and for a data matrix obtained by randomly shuffling the pixels (blue line). Generated by svd_image_demo.ipynb. Adapted from Figure 14.24 of [HTF09].

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

# 7.5.5 Truncated SVD

Let $\mathbf { A } = \mathbf { U } \mathbf { S } \mathbf { V } ^ { T }$ be the SVD of $\mathbf { A }$ , and let $\bar { \mathbf { A } } _ { K } = \mathbf { U } _ { K } \mathbf { S } _ { K } \mathbf { V } _ { K } ^ { \top }$ , where we use the first $K$ columns of $\mathbf { U }$ and $\mathbf { V }$ . This can be shown to be the optimal rank $K$ approximation, in the sense that it minimizes $| | \mathbf { A } - \hat { \mathbf { A } } _ { K } | | _ { F } ^ { 2 }$ .

If $K = r = \mathrm { r a n k } ( \mathbf { A } )$ , there is no error introduced by this decomposition. But if $K < r$ , we incur some error. This is called a truncated SVD. If the singular values die off quickly, as is typical in natural data (see e.g., Figure 7.10), the error will be small. The total number of parameters needed to represent an $N \times D$ matrix using a rank $K$ approximation is

$$
N K + K D + K = K ( N + D + 1 )
$$

As an example, consider the $2 0 0 \times 3 2 0$ pixel image in Figure 7.9(top left). This has 64,000 numbers in it. We see that a rank 20 approximation, with only $( 2 0 0 + 3 2 0 + 1 ) \times 2 0 = 1 0 , 4 2 0$ numbers is a very good approximation.

One can show that the error in this rank- $K$ approximation is given by

$$
\lvert | \mathbf { A } - \hat { \mathbf { A } } \rvert | _ { F } = \sum _ { k = K + 1 } ^ { r } \sigma _ { k }
$$

where $\sigma _ { k }$ is the $k$ ’th singular value of $\mathbf { A }$ .

# 7.6 Other matrix decompositions \*

In this section, we briefly review some other useful matrix decompositions.

# 7.6.1 LU factorization

We can factorize any square matrix A into a product of a lower triangular matrix $\mathbf { L }$ and an upper triangular matrix U. For example,

$$
\begin{array} { r } { \left[ \begin{array} { c c c } { a _ { 1 1 } } & { a _ { 1 2 } } & { a _ { 1 3 } } \\ { a _ { 2 1 } } & { a _ { 2 2 } } & { a _ { 2 3 } } \\ { a _ { 3 1 } } & { a _ { 3 2 } } & { a _ { 3 3 } } \end{array} \right] = \left[ \begin{array} { c c c } { l _ { 1 1 } } & { 0 } & { 0 } \\ { l _ { 2 1 } } & { l _ { 2 2 } } & { 0 } \\ { l _ { 3 1 } } & { l _ { 3 2 } } & { l _ { 3 3 } } \end{array} \right] \left[ \begin{array} { c c c } { u _ { 1 1 } } & { u _ { 1 2 } } & { u _ { 1 3 } } \\ { 0 } & { u _ { 2 2 } } & { u _ { 2 3 } } \\ { 0 } & { 0 } & { u _ { 3 3 } } \end{array} \right] . } \end{array}
$$

In general we may need to permute the entries in the matrix before creating this decomposition. To see this, suppose $a _ { 1 1 } = 0$ . Since $a _ { 1 1 } = l _ { 1 1 } u _ { 1 1 }$ , this means either $l _ { 1 1 }$ or $u _ { 1 1 }$ or both must be zero, but that would imply $\mathbf { L }$ or $\mathbf { U }$ are singular. To avoid this, the first step of the algorithm can simply reorder the rows so that the first element is nonzero. This is repeated for subsequent steps. We can denote this process by

$$
\mathbf { P A } = \mathbf { L U }
$$

where $\mathbf { P }$ is a permutation matrix, i.e., a square binary matrix where $P _ { i j } = 1$ if row $j$ gets permuted to row $i$ . This is called partial pivoting.

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

![](images/85c2b439a718bcbd949f9a7f5898d4b8a11709634422cae28c58986a8879820a.jpg)  
Figure 7.11: Illustration of QR decomposition, $\mathbf { A } = \mathbf { Q } \mathbf { R }$ , where $\mathbf { Q } ^ { \mathsf { T } } \mathbf { Q } = \mathbf { I }$ and $\mathbf { R }$ is upper triangular. (a) Tall, skinny matrix. The shaded parts are not computed in the economy-sized version, since they are not needed. (b) Short, wide matrix.

# 7.6.2 QR decomposition

Suppose we have $\mathbf { A } \in \mathbb { R } ^ { m \times n }$ representing a set of linearly independent basis vectors (so $m \geq n$ ), and we want to find a series of orthonormal vectors $q _ { 1 } , q _ { 2 } , . . .$ that span the successive subspaces of $\operatorname { s p a n } ( \pmb { a } _ { 1 } )$ , $\mathrm { s p a n } ( \pmb { a } _ { 1 } , \pmb { a } _ { 2 } )$ , etc. In other words, we want to find vectors ${ \pmb q } _ { j }$ and coefficients $r _ { i j }$ such that

$$
\left( { \begin{array} { c c c c } { | } & { | } & & { | } \\ { a _ { 1 } } & { a _ { 2 } } & { \cdots } & { a _ { n } } \\ { | } & { | } & & { | } \end{array} } \right) = \left( { \begin{array} { c c c c } { | } & { | } & & { | } \\ { q _ { 1 } } & { q _ { 2 } } & { \cdots } & { q _ { n } } \\ { | } & { | } & & { | } \end{array} } \right) \left( { \begin{array} { c c c c } { r _ { 1 1 } } & { r _ { 1 2 } } & { \cdots } & { r _ { 1 n } } \\ & { r _ { 2 2 } } & { \cdots } & { r _ { 2 n } } \\ & & { \ddots } & \\ & & & { r _ { n n } } \end{array} } \right)
$$

We can write this

$$
\begin{array} { c } { a _ { 1 } = r _ { 1 1 } q _ { 1 } } \\ { a _ { 2 } = r _ { 1 2 } q _ { 1 } + r _ { 2 2 } q _ { 2 } } \\ { \vdots } \\ { a _ { n } = r _ { 1 n } q _ { 1 } + \cdot \cdot + r _ { n n } { \bf q } _ { n } } \end{array}
$$

so we see $\pmb q _ { 1 }$ spans the space of $\mathbf { \delta } _ { \mathbf { u } _ { 1 } }$ , and $\pmb q _ { 1 }$ and $\mathbf { q } _ { 2 }$ span the space of $\{ a _ { 1 } , a _ { 2 } \}$ , etc. In matrix notation, we have

$$
\mathbf { A } = { \hat { \mathbf { Q } } } { \hat { \mathbf { R } } }
$$

where $\hat { \mathbf { Q } }$ is $m \times n$ with orthonormal columns and $\hat { \mathbf { R } }$ is $n \times n$ and upper triangular. This is called a reduced QR or economy sized QR factorization of $\mathbf { A }$ ; see Figure 7.11.

A full QR factorization appends an additional $m - n$ orthonormal columns to $\hat { \mathbf { Q } }$ so it becomes a square, orthogonal matrix $\mathbf { Q }$ , which satisfies $\mathbf { Q Q } ^ { \mathsf { T } } = \mathbf { Q } ^ { \mathsf { T } } \mathbf { Q } = \mathbf { I }$ . Also, we append rows made of zero to $\hat { \textbf { R } }$ so it becomes an $m \times n$ matrix that is still upper triangular, called $\mathbf { R }$ : see Figure 7.11. The zero entries in $\mathbf { R }$ “kill off” the new columns in $\mathbf { Q }$ , so the result is the same as $\hat { \mathbf { Q } } \hat { \mathbf { R } }$ .

QR decomposition is commonly used to solve systems of linear equations, as we discuss in Section 11.2.2.3.

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

# 7.6.3 Cholesky decomposition

Any symmetric positive definite matrix can be factorized as $\mathbf { A } = \mathbf { R } ^ { \mathsf { I } } \mathbf { R }$ , where $\mathbf { R }$ is upper triangular with real, positive diagonal elements. (This can also be written as $\mathbf { A } = \mathbf { L L } ^ { \mathsf { I } }$ , where $\mathbf { L } = \mathbf { R } ^ { \mathsf { I } }$ is lower triangular.) This is called a Cholesky factorization or matrix square root. In NumPy, this is implemented by np.linalg.cholesky. The computational complexity of this operation is $O ( V ^ { 3 } )$ , where $V$ is the number of variables, but can be less for sparse matrices. Below we give some applications of this factorization.

# 7.6.3.1 Application: Sampling from an MVN

The Cholesky decomposition of a covariance matrix can be used to sample from a multivariate Gaussian. Let $\pmb { y } \sim \mathcal { N } ( \pmb { \mu } , \pmb { \Sigma } )$ and $\pmb { \Sigma } = \mathbf { L } \mathbf { L } ^ { \mathsf { I } }$ . We first sample $\pmb { x } \sim \mathcal { N } ( \mathbf { 0 } , \mathbf { I } )$ , which is easy because it just requires sampling from $d$ separate 1d Gaussians. We then set $\pmb { y } = \mathbf { L } \pmb { x } + \pmb { \mu }$ . This is valid since

$$
\operatorname { C o v } \left[ \pmb { y } \right] = \mathbf { L } \operatorname { C o v } \left[ \pmb { x } \right] \mathbf { L } ^ { \mathsf { T } } = \mathbf { L } \mathbf { I } \mathbf { L } ^ { \mathsf { T } } = \pmb { \Sigma }
$$

See cholesky_demo.ipynb for some code.

# 7.7 Solving systems of linear equations \*

An important application of linear algebra is the study of systems of linear equations. For example, consider the following set of 3 equations:

$$
\begin{array} { c } { { 3 x _ { 1 } + 2 x _ { 2 } - x _ { 3 } = 1 } } \\ { { 2 x _ { 1 } - 2 x _ { 2 } + 4 x _ { 3 } = - 2 } } \\ { { - x _ { 1 } + \displaystyle \frac { 1 } { 2 } x _ { 2 } - x _ { 3 } = 0 } } \end{array}
$$

We can represent this in matrix-vector form as follows:

$$
\mathbf { A } { \boldsymbol { x } } = \mathbf { \boldsymbol { b } }
$$

where

$$
{ \bf A } = \left( \begin{array} { c c c } { { 3 } } & { { 2 } } & { { - 1 } } \\ { { 2 } } & { { - 2 } } & { { 4 } } \\ { { - 1 } } & { { { \frac { 1 } { 2 } } } } & { { - 1 } } \end{array} \right) , ~ b = \left( \begin{array} { c } { { 1 } } \\ { { - 2 } } \\ { { 0 } } \end{array} \right)
$$

The solution is $\pmb { x } = [ 1 , - 2 , - 2 ]$ .

In general, if we have $m$ equations and $n$ unknowns, then A will be a $m \times n$ matrix, and $^ { b }$ will be a $m \times 1$ vector. If $m = n$ (and $\mathbf { A }$ is full rank), there is a single unique solution. If $m < n$ , the system is underdetermined, so there is not a unique solution. If $m > n$ , the system is overdetermined, since there are more constraints than unknowns, and not all the lines intersect at the same point. See Figure 7.12 for an illustration. We discuss how to compute solutions in each of these cases below.

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

![](images/24b9f66c52db29c34664556aab1b11c81926011f8227fb06111502b5ce699d66.jpg)  
Figure 7.12: Solution of a set of m linear equations in $n = 2$ variables. (a) $m = 1 < n$ so the system is underdetermined. We show the minimal norm solution as a blue circle. (The dotted red line is orthogonal to the line, and its length is the distance to the origin.) ( $b$ ) $m = n = 2$ , so there is a unique solution. (c) $m = 3 > n$ , so there is no unique solution. We show the least squares solution.

# 7.7.1 Solving square systems

In the case where $m = n$ , we can solve for $_ { x }$ by computing an LU decomposition, $\mathbf { A } = \mathbf { L U }$ , and then proceeding as follows:

$$
\begin{array} { c } { \mathbf { A } \pmb { x } = \pmb { b } } \\ { \mathbf { L } \mathbf { U } \pmb { x } = \pmb { b } } \\ { \mathbf { U } \pmb { x } = \mathbf { L } ^ { - 1 } \pmb { b } \triangleq \pmb { y } } \\ { \pmb { x } = \mathbf { U } ^ { - 1 } \pmb { y } } \end{array}
$$

The crucial point is that $\mathbf { L }$ and $\mathbf { U }$ are both triangular matrices, so we can avoid taking matrix inverses, and use a method known as backsubstitution instead.

In particular, we can solve $\pmb { y } = \mathbf L ^ { - 1 } \pmb { b }$ without taking inverses as follows. First we write

$$
{ \begin{array} { r l } { { \left( \begin{array} { l l l l } { L _ { 1 1 } } & & & \\ { L _ { 2 1 } } & { L _ { 2 2 } } & & \\ & & { \ddots } & \\ { L _ { n 1 } } & { L _ { n 2 } } & { \cdots } & { L _ { n n } } \end{array} \right) } { \left( \begin{array} { l } { y _ { 1 } } \\ { \vdots } \\ { y _ { n } } \end{array} \right) } = { \binom { b _ { 1 } } { \vdots } } } \end{array} }
$$

We start by solving $L _ { 1 1 } y _ { 1 } = b _ { 1 }$ to find $y _ { 1 }$ and then substitute this in to solve

$$
L _ { 2 1 } y _ { 1 } + L _ { 2 2 } y _ { 2 } = b _ { 2 }
$$

for $y _ { 2 }$ . We repeat this recursively. This process is often denoted by the backslash operator, $\pmb { y } = \mathbf { L } \setminus \pmb { b }$ . Once we have $\pmb { y }$ , we can solve ${ \pmb x } = { \bf U } ^ { - 1 } { \pmb y }$ using backsubstitution in a similar manner.

# 7.7.2 Solving underconstrained systems (least norm estimation)

In this section, we consider the underconstrained setting, where $m < n$ .3 We assume the rows are linearly independent, so A is full rank.

When $m < n$ , there are multiple possible solutions, which have the form

$$
\{ \pmb { x } : \mathbf { A } \pmb { x } = \pmb { b } \} = \{ \pmb { x _ { p } } + \pmb { z } : \pmb { z } \in \mathrm { n u l l s p a c e } ( \mathbf { A } ) \}
$$

where ${ \boldsymbol { \mathbf { \mathit { x } } } } _ { p }$ is any particular solution. It is standard to pick the particular solution with minimal $\ell _ { 2 }$ norm, i.e.,

$$
\hat { \pmb { x } } = \underset { \pmb { x } } { \operatorname { a r g m i n } } \ : | | \pmb { x } | | _ { 2 } ^ { 2 } \mathrm { s . t . } \mathrm { \bf A } \pmb { x } = \ b { b }
$$

We can compute the minimal norm solution using the right pseudo inverse:

$$
\pmb { x } _ { \mathrm { p i n v } } = \mathbf { A } ^ { \mathsf { T } } ( \mathbf { A } \mathbf { A } ^ { \mathsf { T } } ) ^ { - 1 } \pmb { b }
$$

(See Section 7.5.3 for more details.) To see this, suppose $\scriptstyle { \mathbf {  { x } } }$ is some other solution, so $\mathbf { A } { \boldsymbol { \mathbf { \mathit { x } } } } = \mathbf { \mathit { b } }$ , and $\mathbf { A } ( \pmb { x } - \pmb { x } _ { \mathrm { p i n v } } ) = \mathbf { 0 }$ . Thus

$$
( \boldsymbol { x } - \boldsymbol { x } _ { \mathrm { p i n v } } ) ^ { \top } \boldsymbol { x } _ { \mathrm { p i n v } } = ( \boldsymbol { x } - \boldsymbol { x } _ { \mathrm { p i n v } } ) ^ { \top } \mathbf { A } ^ { \top } ( \mathbf { A } \mathbf { A } ^ { \top } ) ^ { - 1 } \boldsymbol { b } = ( \mathbf { A } ( \boldsymbol { x } - \boldsymbol { x } _ { \mathrm { p i n v } } ) ) ^ { \top } ( \mathbf { A } \mathbf { A } ^ { \top } ) ^ { - 1 } \boldsymbol { b } .
$$

and hence $( \pmb { x } - \pmb { x } _ { \mathrm { p i n v } } ) \perp \pmb { x } _ { \mathrm { p i n v } }$ . By Pythagoras’s theorem, the norm of $_ { x }$ is

$$
| | \pmb { x } | | ^ { 2 } = | | \pmb { x } _ { \mathrm { p i n v } } + \pmb { x } - \pmb { x } _ { \mathrm { p i n v } } | | ^ { 2 } = | | \pmb { x } _ { \mathrm { p i n v } } | | ^ { 2 } + | | \pmb { x } - \pmb { x } _ { \mathrm { p i n v } } | | ^ { 2 } \geq | | \pmb { x } _ { \mathrm { p i n v } } | | ^ { 2 }
$$

Thus any solution apart from $\pmb { x } _ { \mathrm { p i n v } }$ has larger norm.

We can also solve the constrained optimization problem in Equation (7.222) by minimizing the following unconstrained objective

$$
\mathcal { L } ( \pmb { x } , \lambda ) = \pmb { x } ^ { \top } \pmb { x } + \pmb { \lambda } ^ { \top } ( \mathbf { A } \pmb { x } - \pmb { b } )
$$

From Section 8.5.1, the optimality conditions are

$$
\nabla _ { \boldsymbol { x } } \mathcal { L } = 2 \boldsymbol { x } + \mathbf { A } ^ { \mathsf { T } } \boldsymbol { \lambda } = \mathbf { 0 } , \ \nabla _ { \boldsymbol { \lambda } } \mathcal { L } = \mathbf { A } \boldsymbol { x } - \boldsymbol { b } = \mathbf { 0 }
$$

From the first condition we have $\pmb { x } = - \mathbf { A } ^ { 1 } \lambda / 2$ . Subsituting into the second we get

$$
\mathbf { A } { \pmb x } = - \frac { 1 } { 2 } \mathbf { A } \mathbf { A } ^ { \top } { \pmb \lambda } = { \pmb b }
$$

which implies $\lambda = - 2 ( \mathbf { A } \mathbf { A } ^ { \intercal } ) ^ { - 1 } b$ . Hence $\pmb { x } = \mathbf { A } ^ { 1 } ( \mathbf { A } \mathbf { A } ^ { 1 } ) ^ { - 1 } \pmb { b }$ , which is the right pseudo inverse solution.

# 7.7.3 Solving overconstrained systems (least squares estimation)

If $m > n$ , we have an overdetermined solution, which typically does not have an exact solution, but we will try to find the solution that gets as close as possible to satisfying all of the constraints specified by $\mathbf { A } { \boldsymbol { \mathbf { \mathit { x } } } } = \mathbf { \boldsymbol { \mathbf { b } } }$ . We can do this by minimizing the following cost function, known as the least squares objective:4

$$
f ( \pmb { x } ) = \frac { 1 } { 2 } | | \mathbf { A } \pmb { x } - \pmb { b } | | _ { 2 } ^ { 2 }
$$

Using matrix calculus results from Section 7.8 we have that the gradient is given by

$$
{ \pmb g } ( { \pmb x } ) = \frac { \partial } { \partial { \pmb x } } { f } ( { \pmb x } ) = { \bf A } ^ { \top } { \bf A } { \pmb x } - { \bf A } ^ { \top } { \pmb b }
$$

The optimum can be found by solving $\pmb { g } ( \pmb { x } ) = \mathbf { 0 }$ . This gives

$$
\mathbf { A } ^ { \top } \mathbf { A } \pmb { x } = \mathbf { A } ^ { \top } b
$$

These are known as the normal equations, since, at the optimal solution, $\mathbf { \delta } _ { b \mathrm { ~ - ~ } } \mathbf { A } x$ is normal (orthogonal) to the range of $\mathbf { A }$ , as we explain in Section 11.2.2.2. The corresponding solution $\hat { \textbf { \textit { x } } }$ is the ordinary least squares (OLS) solution, which is given by

$$
{ \hat { \mathbf { x } } } = ( \mathbf { A } ^ { \mathsf { T } } \mathbf { A } ) ^ { - 1 } \mathbf { A } ^ { \mathsf { T } } \mathbf { b }
$$

The quantity $\mathbf { A } ^ { \dagger } = ( \mathbf { A } ^ { \mathsf { T } } \mathbf { A } ) ^ { - 1 } \mathbf { A } ^ { \mathsf { T } }$ is the left pseudo inverse of the (non-square) matrix A (see Section 7.5.3 for more details).

We can check that the solution is unique by showing that the Hessian is positive definite. In this case, the Hessian is given by

$$
\mathbf { H } ( { \pmb x } ) = \frac { \partial ^ { 2 } } { \partial \pmb x ^ { 2 } } f ( \pmb x ) = \mathbf { A } ^ { \top } \mathbf { A }
$$

If $\mathbf { A }$ is full rank (so the columns of $\mathbf { A }$ are linearly independent), then $\mathbf { H }$ is positive definite, since for any $v > 0$ , we have

$$
v ^ { \top } ( \mathbf { A } ^ { \top } \mathbf { A } ) v = ( \mathbf { A } v ) ^ { \top } ( \mathbf { A } v ) = | | \mathbf { A } v | | ^ { 2 } > 0
$$

Hence in the full rank case, the least squares objective has a unique global minimum.

# 7.8 Matrix calculus

The topic of calculus concerns computing “rates of change” of functions as we vary their inputs. It is of vital importance to machine learning, as well as almost every other numerical discipline. In this section, we review some standard results. In some cases, we use some concepts and notation from matrix algebra, which we cover in Chapter 7. For more details on these results from a deep learning perspective, see [PH18].

# 7.8.1 Derivatives

Consider a scalar-argument function $f : \mathbb { R } \to \mathbb { R }$ . We define its derivative at a point $x$ to be the quantity

$$
f ^ { \prime } ( x ) \triangleq \operatorname* { l i m } _ { h  0 } { \frac { f ( x + h ) - f ( x ) } { h } }
$$

assuming the limit exists. This measures how quickly the output changes when we move a small distance in input space away from $x$ (i.e., the “rate of change” of the function). We can interpret $f ^ { \prime } ( x )$ as the slope of the tangent line at $f ( x )$ , and hence

$$
f ( x + h ) \approx f ( x ) + f ^ { \prime } ( x ) h
$$

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

for small $h$ .

We can compute a finite difference approximation to the derivative by using a finite step size $h$ , as follows:

$$
\underbrace { \operatorname* { l i m } _ { h \to 0 } { \frac { f ( x + h ) - f ( x ) } { h } } } _ { \mathrm { f o r w a r d ~ d i f f e r e n c e } } = \underbrace { \operatorname* { l i m } _ { h \to 0 } { \frac { f ( x + h / 2 ) - f ( x - h / 2 ) } { h } } } _ { \mathrm { c e n t r a l ~ d i f f e r e n c e } } = \underbrace { \operatorname* { l i m } _ { h \to 0 } { \frac { f ( x ) - f ( x - h ) - f ( x - h / 2 ) } { h } } } _ { \mathrm { b a c k w a r d ~ d i f f e r e n c e } } .
$$

The smaller the step size $h$ , the better the estimate, although if $h$ is too small, there can be errors due to numerical cancellation.

We can think of differentiation as an operator that maps functions to functions, $D ( f ) = f ^ { \prime }$ , where $f ^ { \prime } ( x )$ computes the derivative at $x$ (assuming the derivative exists at that point). The use of the prime symbol $f ^ { \prime }$ to denote the derivative is called Lagrange notation. The second derivative function, which measures how quickly the gradient is changing, is denoted by $f ^ { \prime \prime }$ . The $n$ ’th derivative function is denoted $f ^ { ( n ) }$ .

Alternatively, we can use Leibniz notation, in which we denote the function by $y = f ( x )$ , and its derivative by $\textstyle { \frac { d y } { d x } }$ or $\textstyle { \frac { d } { d x } } f ( x )$ . To denote the evaluation of the derivative at a point $a$ , we write $\scriptstyle { \frac { d f } { d x } } \left| _ { x = a } . { } \right.$

# 7.8.2 Gradients

We can extend the notion of derivatives to handle vector-argument functions, $f : \mathbb { R } ^ { n }  \mathbb { R }$ , by defining the partial derivative of $f$ with respect to $x _ { i }$ to be

$$
{ \frac { \partial f } { \partial { x _ { i } } } } = \operatorname* { l i m } _ { h \to 0 } { \frac { f ( { \pmb x } + h { \pmb e } _ { i } ) - f ( { \pmb x } ) } { h } }
$$

where $e _ { i }$ is the $i$ ’th unit vector.

The gradient of a function at a point $_ { x }$ is the vector of its partial derivatives:

$$
g = { \frac { \partial f } { \partial \mathbf { x } } } = \nabla f = { \left( \begin{array} { l } { { \frac { \partial f } { \partial x _ { 1 } } } } \\ { \vdots } \\ { { \frac { \partial f } { \partial x _ { n } } } } \end{array} \right) }
$$

To emphasize the point at which the gradient is evaluated, we can write

$$
\pmb { g } ( \pmb { x } ^ { * } ) \triangleq \frac { \partial f } { \partial \pmb { x } } \bigg | _ { \pmb { x } ^ { * } }
$$

We see that the operator $\nabla$ (pronounced “nabla”) maps a function $f : \mathbb { R } ^ { n }  \mathbb { R }$ to another function $g : \mathbb { R } ^ { n }  \mathbb { R } ^ { n }$ . Since $g ( \ u )$ is a vector-valued function, it is known as a vector field. By contrast, the derivative function $f ^ { \prime }$ is a scalar field.

# 7.8.3 Directional derivative

The directional derivative measures how much the function $f : \mathbb { R } ^ { n } \to \mathbb { R }$ changes along a direction $_ { v }$ in space. It is defined as follows

$$
D _ { v } f ( { \pmb x } ) = \operatorname* { l i m } _ { h  0 } \frac { f ( { \pmb x } + h { \pmb v } ) - f ( { \pmb x } ) } { h }
$$

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

We can approximate this numerically using 2 function calls to $f$ , regardless of $n$ . By contrast, a numerical approximation to the standard gradient vector takes $n + 1$ calls (or $2 n$ if using central differences).

Note that the directional derivative along $\mathbf { \nabla } _ { \mathbf { v } }$ is the scalar product of the gradient $\pmb { g }$ and the vector $_ { v }$ :

$$
D _ { v } f ( { \pmb x } ) = \nabla f ( { \pmb x } ) \cdot { \pmb v }
$$

# 7.8.4 Total derivative \*

Suppose that some of the arguments to the function depend on each other. Concretely, suppose the function has the form $f ( t , x ( t ) , y ( t ) )$ . We define the total derivative of $f$ wrt $t$ as follows:

$$
{ \frac { d f } { d t } } = { \frac { \partial f } { \partial t } } + { \frac { \partial f } { \partial x } } { \frac { d x } { d t } } + { \frac { \partial f } { \partial y } } { \frac { d y } { d t } }
$$

If we multiply both sides by the differential $d t$ , we get the total differential

$$
d f = { \frac { \partial f } { \partial t } } d t + { \frac { \partial f } { \partial x } } d x + { \frac { \partial f } { \partial y } } d y
$$

This measures how much $f$ changes when we change $t$ , both via the direct effect of $t$ on $f$ , but also indirectly, via the effects of $t$ on $x$ and $y$ .

# 7.8.5 Jacobian

Consider a function that maps a vector to another vector, $f : \mathbb { R } ^ { n }  \mathbb { R } ^ { m }$ . The Jacobian matrix of this function is an $m \times n$ matrix of partial derivatives:

$$
\mathbf { J } _ { f } ( x ) = { \frac { \partial f } { \partial \mathbf { x } ^ { \mathsf { T } } } } \triangleq { \left( \begin{array} { l l l } { { \frac { \partial f _ { 1 } } { \partial x _ { 1 } } } } & { \cdot \cdot } & { { \frac { \partial f _ { 1 } } { \partial x _ { n } } } } \\ { \cdot } & { \cdot } & { \vdots } \\ { { \frac { \partial f _ { m } } { \partial x _ { 1 } } } } & { \cdot \cdot } & { { \frac { \partial f _ { m } } { \partial x _ { n } } } } \end{array} \right) } = { \left( \begin{array} { l } { \nabla f _ { 1 } ( x ) ^ { \mathsf { T } } } \\ { \vdots } \\ { \nabla f _ { m } ( x ) ^ { \mathsf { T } } } \end{array} \right) }
$$

Note that we lay out the results in the same orientation as the output $f$ ; this is sometimes called numerator layout or the Jacobian formulation.5

# 7.8.5.1 Multiplying Jacobians and vectors

The Jacobian vector product or JVP is defined to be the operation that corresponds to rightmultiplying the Jacobian matrix $\mathbf { J } \in \mathbb { R } ^ { m \times n }$ by a vector $\pmb { v } \in \mathbb { R } ^ { n }$ :

$$
\begin{array} { r } { \mathbf { J } _ { f } ( x ) { \boldsymbol { v } } = \left( \begin{array} { c } { \nabla f _ { 1 } ( x ) ^ { \mathsf { T } } } \\ { \vdots } \\ { \nabla f _ { m } ( x ) ^ { \mathsf { T } } } \end{array} \right) { \boldsymbol { v } } = \left( \begin{array} { c } { \nabla f _ { 1 } ( x ) ^ { \mathsf { T } } { \boldsymbol { v } } } \\ { \vdots } \\ { \nabla f _ { m } ( x ) ^ { \mathsf { T } } { \boldsymbol { v } } } \end{array} \right) } \end{array}
$$

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

So we can see that we can approximate this numerically using just 2 calls to $f$ .

The vector Jacobian product or VJP is defined to be the operation that corresponds to left-multiplying the Jacobian matrix $\mathbf { J } \in \mathbb { R } ^ { m \times n }$ by a vector $\pmb { u } \in \mathbb { R } ^ { m }$ :

$$
\begin{array} { r } { { \boldsymbol { u } } ^ { \mathsf { T } } { \boldsymbol { \mathrm { J } } } _ { f } ( { \boldsymbol { x } } ) = { \boldsymbol { u } } ^ { \mathsf { T } } \left( { \frac { \partial f } { \partial x _ { 1 } } } , \cdots , { \frac { \partial f } { \partial x _ { n } } } \right) = \left( { \boldsymbol { u } } \cdot { \frac { \partial f } { \partial x _ { 1 } } } , \cdots , { \boldsymbol { u } } \cdot { \frac { \partial f } { \partial x _ { n } } } \right) } \end{array}
$$

The JVP is more efficient if $m \geq n$ , and the VJP is more efficient if $m \leq n$ . See Section 13.3 for details on how this can be used to perform automatic differentiation in a computation graph such as a DNN.

# 7.8.5.2 Jacobian of a composition

Sometimes it is useful to take the Jacobian of the composition of two functions. Let $h ( { \pmb x } ) = g ( f ( { \pmb x } ) )$ . By the chain rule of calculus, we have

$$
\mathbf { J } _ { h } ( { \pmb x } ) = \mathbf { J } _ { g } ( f ( { \pmb x } ) ) \mathbf { J } _ { f } ( { \pmb x } )
$$

For example, suppose $f : \mathbb { R } \to \mathbb { R } ^ { 2 }$ and $g : \mathbb { R } ^ { 2 }  \mathbb { R } ^ { 2 }$ . We have

$$
\begin{array} { c } { \displaystyle \frac { \partial g } { \partial x } = ( \frac { \partial } { \partial x } g _ { 1 } ( f _ { 1 } ( x ) , f _ { 2 } ( x ) ) ) = ( \frac { \partial g _ { 1 } } { \partial f _ { 1 } } \frac { \partial f _ { 1 } } { \partial x } + \frac { \partial g _ { 1 } } { \partial f _ { 2 } } \frac { \partial f _ { 2 } } { \partial x } ) } \\ { \displaystyle \frac { \partial } { \partial x } g _ { 2 } ( f _ { 1 } ( x ) , f _ { 2 } ( x ) ) ) = ( \frac { \partial g _ { 2 } } { \partial f _ { 1 } } \frac { \partial f _ { 1 } } { \partial x } + \frac { \partial g _ { 2 } } { \partial f _ { 2 } } \frac { \partial f _ { 2 } } { \partial x } ) } \\ { \displaystyle = \frac { \partial g } { \partial f ^ { \top } } \frac { \partial f } { \partial x } = ( \frac { \partial g _ { 1 } } { \partial f _ { 1 } } \frac { \partial g _ { 1 } } { \partial f _ { 2 } } ) ( \frac { \partial f _ { 1 } } { \partial x } ) } \\ { \displaystyle \frac { \partial g _ { 2 } } { \partial f _ { 1 } } \frac { \partial f _ { 2 } } { \partial x } ) } \end{array}
$$

# 7.8.6 Hessian

For a function $f : \mathbb { R } ^ { n } \to \mathbb { R }$ that is twice differentiable, we define the Hessian matrix as the (symmetric) $n \times n$ matrix of second partial derivatives:

$$
\mathbf { H } _ { f } = { \frac { \partial ^ { 2 } f } { \partial { \boldsymbol { x } } ^ { 2 } } } = \nabla ^ { 2 } f = { \left( \begin{array} { l l l } { { \frac { \partial ^ { 2 } f } { \partial x _ { 1 } ^ { 2 } } } } & { \cdot \cdot \cdot } & { { \frac { \partial ^ { 2 } f } { \partial x _ { 1 } \partial x _ { n } } } } \\ & { \vdots } & \\ { { \frac { \partial ^ { 2 } f } { \partial x _ { n } \partial x _ { 1 } } } } & { \cdot \cdot \cdot } & { { \frac { \partial ^ { 2 } f } { \partial x _ { n } ^ { 2 } } } } \end{array} \right) }
$$

We see that the Hessian is the Jacobian of the gradient.

# 7.8.7 Gradients of commonly used functions

In this section, we list without proof the gradients of certain widely used functions.

# 7.8.7.1 Functions that map scalars to scalars

Consider a differentiable function $f : \mathbb { R } \to \mathbb { R }$ . Here are some useful identities from scalar calculus, which you should already be familiar with.

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

$$
\begin{array} { c } { { \displaystyle \frac { d } { d x } c x ^ { n } = c n x ^ { n - 1 } } } \\ { { \displaystyle \frac { d } { d x } \log ( x ) = 1 / x } } \\ { { \displaystyle \frac { d } { d x } \exp ( x ) = \exp ( x ) } } \\ { { \displaystyle \frac { d } { d x } \left[ f ( x ) + g ( x ) \right] = \frac { d f ( x ) } { d x } + \frac { d g ( x ) } { d x } } } \\ { { \displaystyle \frac { d } { d x } \left[ f ( x ) g ( x ) \right] = f ( x ) \frac { d g ( x ) } { d x } + g ( x ) \frac { d f ( x ) } { d x } } } \\ { { \displaystyle \frac { d } { d x } f ( u ( x ) ) = \frac { d u } { d x } \frac { d f ( u ) } { d u } } } \end{array}
$$

Equation (7.261) is known as the chain rule of calculus.

# 7.8.7.2 Functions that map vectors to scalars

Consider a differentiable function $f : \mathbb { R } ^ { n }  \mathbb { R }$ . Here are some useful identities:6

$$
\begin{array} { c } { \displaystyle { \frac { \partial ( a ^ { \mathsf { T } } x ) } { \partial x } = a } } \\ { \displaystyle { \frac { \partial ( b ^ { \mathsf { T } } \mathbf { A } x ) } { \partial x } = \mathbf { A } ^ { \mathsf { T } } b } } \\ { \displaystyle { \frac { \partial ( x ^ { \mathsf { T } } \mathbf { A } x ) } { \partial x } = ( \mathbf { A } + \mathbf { A } ^ { \mathsf { T } } ) x } } \end{array}
$$

It is fairly easy to prove these identities by expanding out the quadratic form, and applying scalar calculus.

# 7.8.7.3 Functions that map matrices to scalars

Consider a function $f : \mathbb { R } ^ { m \times n }  \mathbb { R }$ which maps a matrix to a scalar. We are using the following natural layout for the derivative matrix:

$$
{ \frac { \partial f } { \partial \mathbf { X } } } = { \left( \begin{array} { l l l } { { \frac { \partial f } { \partial x _ { 1 1 } } } } & { \cdot \cdot \cdot } & { { \frac { \partial f } { \partial x _ { 1 n } } } } \\ & { \vdots } \\ { { \frac { \partial f } { \partial x _ { m 1 } } } } & { \cdot \cdot \cdot } & { { \frac { \partial f } { \partial x _ { m n } } } } \end{array} \right) }
$$

Below are some useful identities.

# Identities involving quadratic forms

One can show the following results.

$$
{ \begin{array} { c } { { \frac { \partial } { \partial \mathbf { X } } } ( \mathbf { a } ^ { \mathsf { T } } \mathbf { X } \mathbf { } b ) = \mathbf { } a b ^ { \mathsf { T } } } \\ { { \frac { \partial } { \partial \mathbf { X } } } ( \mathbf { a } ^ { \mathsf { T } } \mathbf { X } ^ { \mathsf { T } } b ) = b \mathbf { } a ^ { \mathsf { T } } } \end{array} }
$$

# Identities involving matrix trace

One can show the following results.

$$
{ \begin{array} { r l } & { { \frac { \partial } { \partial \mathbf { X } } } \mathrm { t r } ( \mathbf { A X B } ) = \mathbf { A } ^ { \mathsf { T } } \mathbf { B } ^ { \mathsf { T } } } \\ & { { \frac { \partial } { \partial \mathbf { X } } } \mathrm { t r } ( \mathbf { X } ^ { \mathsf { T } } \mathbf { A } ) = \mathbf { A } } \\ & { { \frac { \partial } { \partial \mathbf { X } } } \mathrm { t r } ( \mathbf { X } ^ { - 1 } \mathbf { A } ) = - \mathbf { X } ^ { - \mathsf { T } } \mathbf { A } ^ { \mathsf { T } } \mathbf { X } ^ { - \mathsf { T } } } \\ & { { \frac { \partial } { \partial \mathbf { X } } } \mathrm { t r } ( \mathbf { X } ^ { \mathsf { T } } \mathbf { A X } ) = ( \mathbf { A } + \mathbf { A } ^ { \mathsf { T } } ) \mathbf { X } } \end{array} }
$$

# Identities involving matrix determinant

One can show the following results.

$$
{ \begin{array} { c } { { \frac { \partial } { \partial \mathbf { X } } } \operatorname* { d e t } ( \mathbf { A X B } ) = \operatorname* { d e t } ( \mathbf { A X B } ) \mathbf { X } ^ { - \top } } \\ { { \frac { \partial } { \partial \mathbf { X } } } \log ( \operatorname* { d e t } ( \mathbf { X } ) ) = \mathbf { X } ^ { - \top } } \end{array} }
$$

# 7.9 Exercises

Exercise 7.1 [Orthogonal matrices]

a. A rotation in 3d by angle $\alpha$ about the $z$ axis is given by the following matrix:

$$
\mathbf { R } ( \alpha ) = { \binom { \cos ( \alpha ) } { \sin ( \alpha ) } } \quad { \begin{array} { l } { - \sin ( \alpha ) } \\ { \cos ( \alpha ) } \\ { 0 } \end{array} } \quad { \begin{array} { l } { 0 } \\ { 0 } \\ { 1 } \end{array} }
$$

Prove that $\mathbf { R }$ is an orthogonal matrix, i.e., $\mathbf { R } ^ { T } \mathbf { R } = \mathbf { I }$ , for any $\alpha$ .

b. What is the only eigenvector $_ v$ of $\mathbf { R }$ with an eigenvalue of 1.0 and of unit norm (i.e., $| | \pmb { v } | | ^ { 2 } = 1$ )? (Your answer should be the same for any $\alpha$ .) Hint: think about the geometrical interpretation of eigenvectors.

Exercise 7.2 [Eigenvectors by hand \*] Find the eigenvalues and eigenvectors of the following matrix

$$
A = { \binom { 2 } { 0 } } \quad { \binom { 0 } { 3 } }
$$

Compute your result by hand and check it with Python.

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

# 8 Optimization

Parts of this chapter were written by Frederik Kunstner, Si Yi Meng, Aaron Mishkin, Sharan Vaswani, and Mark Schmidt.

# 8.1 Introduction

We saw in Chapter 4 that the core problem in machine learning is parameter estimation (aka model fitting). This requires solving an optimization problem, where we try to find the values for a set of variables $\pmb \theta \in \Theta$ , that minimize a scalar-valued loss function or cost function $\mathcal { L } : \Theta \to \mathbb { R }$ :

$$
\pmb { \theta } ^ { * } \in \operatorname * { a r g m i n } _ { \pmb { \theta } \in \Theta } \mathcal { L } ( \pmb { \theta } )
$$

We will assume that the parameter space is given by $\Theta \subseteq \mathbb { R } ^ { D }$ , where $D$ is the number of variables being optimized over. Thus we are focusing on continuous optimization, rather than discrete optimization.

If we want to maximize a score function or reward function $R ( \pmb \theta )$ , we can equivalently minimize $\mathcal { L } ( \pmb { \theta } ) = - R ( \pmb { \theta } )$ . We will use the term objective function to refer generically to a function we want to maximize or minimize. An algorithm that can find an optimum of an objective function is often called a solver.

In the rest of this chapter, we discuss different kinds of solvers for different kinds of objective functions, with a focus on methods used in the machine learning community. For more details on optimization, please consult some of the many excellent textbooks, such as [KW19b; BV04; NW06; Ber15; Ber16] as well as various review articles, such as [BCN18; Sun+19b; PPS18; Pey20].

# 8.1.1 Local vs global optimization

A point that satisfies Equation (8.1) is called a global optimum. Finding such a point is called global optimization.

In general, finding global optima is computationally intractable [Neu04]. In such cases, we will just try to find a local optimum. For continuous problems, this is defined to be a point $\pmb { \theta } ^ { * }$ which has lower (or equal) cost than “nearby” points. Formally, we say $\pmb { \theta } ^ { * }$ is a local minimum if

$$
\exists \delta > 0 , \forall \pmb { \theta } \in \Theta \mathrm { s . t . } | | \pmb { \theta } - \pmb { \theta } ^ { * } | | < \delta , \mathcal { L } \big ( \pmb { \theta } ^ { * } \big ) \leq \mathcal { L } ( \pmb { \theta } )
$$

![](images/f603c58156b44e0c5196e156bf89752f94d147099069b23ebea425b27cec1117.jpg)  
Figure 8.1: (a) Illustration of local and global minimum in 1d. Generated by extrema_fig_1d.ipynb. (b Illustration of a saddle point in 2d. Generated by saddle.ipynb.

A local minimum could be surrounded by other local minima with the same objective value; this is known as a flat local minimum. A point is said to be a strict local minimum if its cost is strictly lower than those of neighboring points:

$$
\exists \delta > 0 , \forall \pm \in \Theta , \pm \theta \neq \theta ^ { * } : | | \theta - \theta ^ { * } | | < \delta , \mathcal { L } ( \theta ^ { * } ) < \mathcal { L } ( \theta )
$$

We can define a (strict) local maximum analogously. See Figure 8.1a for an illustration.

A final note on terminology; if an algorithm is guaranteed to converge to a stationary point from any starting point, it is called globally convergent. However, this does not mean (rather confusingly) that it will converge to a global optimum; instead, it just means it will converge to some stationary point.

# 8.1.1.1 Optimality conditions for local vs global optima

For continuous, twice differentiable functions, we can precisely characterize the points which correspond to local minima. Let $\begin{array} { r }  \begin{array} { r l } { \mathbf { \boldsymbol { \mathsf { \sigma } } } } & { { } \mathbf { \boldsymbol { \mathsf { \sigma } } } \mathbf { \boldsymbol { \mathsf { \sigma } } } \end{array} } \end{array}$ be the gradient vector, and $\mathbf { H } ( \pmb \theta ) = \nabla ^ { 2 } \mathcal { L } ( \pmb \theta )$ be the Hessian matrix. (See Section 7.8 for a refresher on these concepts, if necessary.) Consider a point $\pmb { \theta } ^ { \ast } \in \mathbb { R } ^ { D }$ , and let $g ^ { * } = g ( \theta ) | _ { \theta ^ { * } }$ be the gradient at that point, and $\mathbf { H } ^ { * } = \mathbf { H } ( \pmb { \theta } ) | _ { \pmb { \theta } ^ { * } }$ be the corresponding Hessian. One can show that the following conditions characterize every local minimum:

• Necessary condition: If $\pmb { \theta } ^ { * }$ is a local minimum, then we must have $\mathbf { \boldsymbol { g } } ^ { * } = \mathbf { 0 }$ (i.e., $\theta ^ { * }$ must be a stationary point), and $\mathbf { H } ^ { * }$ must be positive semi-definite. • Sufficient condition: If $\mathbf { \boldsymbol { g } } ^ { * } = \mathbf { 0 }$ and $\mathbf { H } ^ { * }$ is positive definite, then $\theta ^ { * }$ is a local optimum.

To see why the first condition is necessary, suppose we were at a point $\pmb { \theta } ^ { * }$ at which the gradient is non-zero: at such a point, we could decrease the function by following the negative gradient a small distance, so this would not be optimal. So the gradient must be zero. (In the case of nonsmooth

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022 functions, the necessary condition is that the zero is a local subgradient at the minimum.) To see why a zero gradient is not sufficient, note that the stationary point could be a local minimum, maximum or saddle point, which is a point where some directions point downhill, and some uphill (see Figure 8.1b). More precisely, at a saddle point, the eigenvalues of the Hessian will be both positive and negative. However, if the Hessian at a point is positive semi-definite, then some directions may point uphill, while others are flat. Moreover, if the Hessian is strictly positive definite, then we are at the bottom of a “bowl”, and all directions point uphill, which is sufficient for this to be a minimum.

# 8.1.2 Constrained vs unconstrained optimization

In unconstrained optimization, we define the optimization task as finding any value in the parameter space $\Theta$ that minimizes the loss. However, we often have a set of constraints on the allowable values. It is standard to partition the set of constraints $\boldsymbol { \mathcal { C } }$ into inequality constraints, $g _ { j } ( \pmb { \theta } ) \leq 0$ for $j \in \mathcal { I }$ and equality constraints, $h _ { k } ( \pmb \theta ) = 0$ for $k \in \mathcal { E }$ . For example, we can represent a sum-to-one constraint as an equality constraint $\begin{array} { r } { h ( \pmb { \theta } ) = ( 1 - \sum _ { i = 1 } ^ { D } \theta _ { i } ) = 0 } \end{array}$ , and we can represent a nonnegativity constraint on the parameters by using $D$ inequality constraints of the form $g _ { i } ( \pmb { \theta } ) = - \theta _ { i } \le 0$

We define the feasible set as the subset of the parameter space that satisfies the constraints:

$$
\mathcal { C } = \{ \pmb \theta : g _ { j } ( \pmb \theta ) \leq 0 : j \in \mathcal { Z } , h _ { k } ( \pmb \theta ) = 0 : k \in \mathcal { E } \} \subseteq \mathbb { R } ^ { D }
$$

Our constrained optimization problem now becomes

$$
\pmb { \theta } ^ { * } \in \operatorname * { a r g m i n } _ { \pmb { \theta } \in \mathcal { C } } \mathcal { L } ( \pmb { \theta } )
$$

If $\mathcal { C } = \mathbb { R } ^ { D }$ , it is called unconstrained optimization.

The addition of constraints can change the number of optima of a function. For example, a function that was previously unbounded (and hence had no well-defined global maximum or minimum) can “acquire” multiple maxima or minima when we add constraints, as illustrated in Figure 8.2. However, if we add too many constraints, we may find that the feasible set becomes empty. The task of finding any point (regardless of its cost) in the feasible set is called a feasibility problem; this can be a hard subproblem in itself.

A common strategy for solving constrained problems is to create penalty terms that measure how much we violate each constraint. We then add these terms to the objective and solve an unconstrained optimization problem. The Lagrangian is a special case of such a combined objective (see Section 8.5 for details).

# 8.1.3 Convex vs nonconvex optimization

In convex optimization, we require the objective to be a convex function defined over a convex set (we define these terms below). In such problems, every local minimum is also a global minimum. Thus many models are designed so that their training objectives are convex.

# 8.1.3.1 Convex sets

We say $\boldsymbol { S }$ is a convex set if, for any ${ \pmb x } , { \pmb x } ^ { \prime } \in \mathcal { S }$ , we have

$$
\lambda \pmb { x } + ( 1 - \lambda ) \pmb { x } ^ { \prime } \in \mathcal { S } , \forall \lambda \in [ 0 , 1 ]
$$

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

![](images/fb93d6b32fae6b7550d66d44a651715b76a807cb1010f5e8890ebe627411c064.jpg)  
Figure 8.2: Illustration of constrained maximization of a nonconvex 1d function. The area between the dotted vertical lines represents the feasible set. (a) There is a unique global maximum since the function is concave within the support of the feasible set. (b) There are two global maxima, both occuring at the boundary of the feasible set. (c) In the unconstrained case, this function has no global maximum, since it is unbounded.

![](images/1285ffacbddaa8f0bf62e4c52823205a5cb5dd69b103d8764e8beb87997b69a3.jpg)  
Figure 8.3: Illustration of some convex and non-convex sets.

That is, if we draw a line from $_ { x }$ to $\mathbf { { x } ^ { \prime } }$ , all points on the line lie inside the set. See Figure 8.3 for some illustrations of convex and non-convex sets.

# 8.1.3.2 Convex functions

We say $f$ is a convex function if its epigraph (the set of points above the function, illustrated in Figure 8.4a) defines a convex set. Equivalently, a function $f ( { \pmb x } )$ is called convex if it is defined on a convex set and if, for any $\mathbf { { \boldsymbol { x } } } , \mathbf { { \boldsymbol { y } } } \in S$ , and for any $0 \leq \lambda \leq 1$ , we have

$$
f ( \lambda { \pmb x } + ( 1 - \lambda ) { \pmb y } ) \leq \lambda f ( { \pmb x } ) + ( 1 - \lambda ) f ( { \pmb y } )
$$

See Figure 8.5(a) for a 1d example of a convex function. A function is called strictly convex if the inequality is strict. A function $f ( { \pmb x } )$ is concave if $- f ( { \pmb x } )$ is convex, and strictly concave if $- f ( { \pmb x } )$ is strictly convex. See Figure 8.5(b) for a 1d example of a function that is neither convex nor concave.

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

![](images/520c24da9a52547a0653af2cdd7219e379827b4adc15662571751fe993ba46cd.jpg)  
Figure 8.4: (a) Illustration of the epigraph of a function. (b) For a convex function $f ( x )$ , its epipgraph can be represented as the intersection of half-spaces defined by linear lower bounds derived from the conjugate function $f ^ { * } ( \lambda ) = \operatorname* { m a x } _ { x } \lambda x - f ( x )$ .

![](images/934bbe0e187918aee5719f137e8cbee7738f4b4ee62794db5f581f998394fa69.jpg)  
Figure 8.5: (a) Illustration of a convex function. We see that the chord joining $( x , f ( x ) )$ to $( y , f ( y ) )$ lies above the function. (b) A function that is neither convex nor concave. A is a local minimum, $\mathbf { B }$ is a global minimum.

Here are some examples of 1d convex functions:

$$
\begin{array} { r l r } { \left. \begin{array} { c } { x ^ { 2 } } \\ { e ^ { a x } } \\ { - \log x } \\ { x ^ { a } , a > 1 , x > 0 } \end{array} \right. } \\ { \left. \begin{array} { c } { | x | ^ { a } , a \geq 1 } \\ { \log x , x > 0 } \end{array} \right. } \end{array}
$$

# 8.1.3.3 Characterization of convex functions

Intuitively, a convex function is shaped like a bowl. Formally, one can prove the following important result:

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

![](images/23dc186878c62205ccb08d2e6e21aee770904d624c23d909f12bf71293e7bd5f.jpg)  
Figure 8.6: The quadratic form $f ( \pmb { x } ) = \pmb { x } ^ { \top } \mathbf { A } \pmb { x }$ in 2d. (a) A is positive definite, so $f$ is convex. (b) A is negative definite, so $f$ is concave. (c) A is positive semidefinite but singular, so $f$ is convex, but not strictly. Notice the valley of constant height in the middle. (d) A is indefinite, so $f$ is neither convex nor concave. The stationary point in the middle of the surface is a saddle point. From Figure 5 of [She94].

Theorem 8.1.1. Suppose $f : \mathbb { R } ^ { n }  \mathbb { R }$ is twice differentiable over its domain. Then $f$ is convex iff ${ \bf H } = \nabla ^ { 2 } f ( { \pmb x } )$ is positive semi definite (Section 7.1.5.3) for all $\pmb { x } \in \operatorname { d o m } ( f )$ . Furthermore, $f$ is strictly convex if $\mathbf { H }$ is positive definite.

For example, consider the quadratic form

$$
f ( \pmb { x } ) = \pmb { x } ^ { \top } \mathbf { A } \pmb { x }
$$

This is convex if $\mathbf { A }$ is positive semi definite, and is strictly convex if $\mathbf { A }$ is positive definite. It is neither convex nor concave if $\mathbf { A }$ has eigenvalues of mixed sign. See Figure 8.6.

# 8.1.3.4 Strongly convex functions

We say a function $f$ is strongly convex with parameter $m > 0$ if the following holds for all $_ { x }$ , $\mathbf { \nabla } _ { \mathbf { \boldsymbol { y } } }$ in $f$ ’s domain:

$$
( \nabla f ( \pmb { x } ) - \nabla f ( \pmb { y } ) ) ^ { \top } ( \pmb { x } - \pmb { y } ) \geq m | | \pmb { x } - \pmb { y } | | _ { 2 } ^ { 2 }
$$

A strongly convex function is also strictly convex, but not vice versa.

If the function $f$ is twice continuously differentiable, then it is strongly convex with parameter $m$ if and only if $\nabla ^ { 2 } f ( { \pmb x } ) \succeq m { \bf I }$ for all $_ { x }$ in the domain, where $\mathbf { I }$ is the identity and $\nabla ^ { 2 } f$ is the Hessian matrix, and the inequality $\succeq$ means that $\nabla ^ { 2 } f ( { \pmb x } ) - m { \bf I }$ is positive semi-definite. This is equivalent

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022 to requiring that the minimum eigenvalue of $\nabla ^ { 2 } f ( { \pmb x } )$ be at least $m$ for all $_ { x }$ . If the domain is just the real line, then $\nabla ^ { 2 } f ( x )$ is just the second derivative $f ^ { \prime \prime } ( x )$ , so the condition becomes $f ^ { \prime \prime } ( x ) \geq m$ . If $m = 0$ , then this means the Hessian is positive semidefinite (or if the domain is the real line, it means that $f ^ { \prime \prime } ( x ) \geq 0$ ), which implies the function is convex, and perhaps strictly convex, but not strongly convex.

![](images/e46d06192dbd9c8a86cab0f4c7ac68077703d08218114cef5605f6d157b6ca57.jpg)  
Figure 8.7: (a) Smooth 1d function. (b) Non-smooth 1d function. (There is a discontinuity at the origin.) Generated by smooth-vs-nonsmooth-1d.ipynb.

The distinction between convex, strictly convex, and strongly convex is rather subtle. To better understand this, consider the case where $f$ is twice continuously differentiable and the domain is the real line. Then we can characterize the differences as follows:

$\bullet$ $f$ is convex if and only if $f ^ { \prime \prime } ( x ) \geq 0$ for all $x$ .   
• $f$ is strictly convex if $f ^ { \prime \prime } ( x ) > 0$ for all $x$ (note: this is sufficient, but not necessary).   
• $f$ is strongly convex if and only if $f ^ { \prime \prime } ( x ) \geq m > 0$ for all $x$ .   
Note that it can be shown that a function $f$ is strongly convex with parameter $m$ iff the function

$$
J ( { \pmb x } ) = f ( { \pmb x } ) - \frac { m } { 2 } | | { \pmb x } | | ^ { 2 }
$$

is convex.

# 8.1.4 Smooth vs nonsmooth optimization

In smooth optimization, the objective and constraints are continuously differentiable functions. For smooth functions, we can quantify the degree of smoothness using the Lipschitz constant. In the 1d case, this is defined as any constant $L \geq 0$ such that, for all real $x _ { 1 }$ and $x _ { 2 }$ , we have

$$
| f ( x _ { 1 } ) - f ( x _ { 2 } ) | \leq L | x _ { 1 } - x _ { 2 } |
$$

This is illustrated in Figure 8.8: for a given constant $L$ , the function output cannot change by more than $L$ if we change the function input by 1 unit. This can be generalized to vector inputs using a suitable norm.

In nonsmooth optimization, there are at least some points where the gradient of the objective function or the constraints is not well-defined. See Figure 8.7 for an example. In some optimization

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

![](images/21850c89be1f1bdd9ed1922e40b8dbcfd5d0527266d3ab4b36dfbec5fedf982e.jpg)  
Figure 8.8: For a Lipschitz continuous function $f$ , there exists a double cone (white) whose origin can be moved along the graph of $f$ so that the whole graph always stays outside the double cone. From https: // en. wikipedia. org/ wiki/ Lipschitz_ continuity . Used with kind permission of Wikipedia author Taschee.

problems, we can partition the objective into a part that only contains smooth terms, and a part that contains the nonsmooth terms:

$$
\mathcal { L } ( \pmb \theta ) = \mathcal { L } _ { s } ( \pmb \theta ) + \mathcal { L } _ { r } ( \pmb \theta )
$$

where $\mathcal { L } _ { s }$ is smooth (differentiable), and $\mathcal { L } _ { r }$ is nonsmooth (“rough”). This is often referred to as a composite objective. In machine learning applications, $\mathcal { L } _ { s }$ is usually the training set loss, and $\mathcal { L } _ { r }$ is a regularizer, such as the $\ell _ { 1 }$ norm of $\pmb \theta$ . This composite structure can be exploited by various algorithms.

# 8.1.4.1 Subgradients

In this section, we generalize the notion of a derivative to work with functions which have local discontinuities. In particular, for a convex function of several variables, $f : \mathbb { R } ^ { n }  \mathbb { R }$ , we say that $\mathbf { \boldsymbol { g } } \in \mathbb { R } ^ { n }$ is a subgradient of $f$ at $\pmb { x } \in \operatorname { d o m } ( f )$ if for all $z \in \operatorname { d o m } ( f )$ ,

$$
f ( { \boldsymbol { z } } ) \geq f ( { \boldsymbol { { \mathbf { \mathit { x } } } } } ) + { \boldsymbol { { \mathbf { \mathit { g } } } } } ^ { \mathsf { T } } ( { \boldsymbol { { \mathbf { \mathit { z } } } } } - { \boldsymbol { { \mathbf { \mathit { x } } } } } )
$$

Note that a subgradient can exist even when $f$ is not differentiable at a point, as shown in Figure 8.9. A function $f$ is called subdifferentiable at $_ { x }$ if there is at least one subgradient at $_ { x }$ . The set of such subgradients is called the subdifferential of $f$ at $_ { x }$ , and is denoted $\partial f ( { \pmb x } )$ .

For example, consider the absolute value function $f ( x ) = \left| x \right|$ . Its subdifferential is given by

$$
\partial f ( x ) = { \left\{ \begin{array} { l l } { \{ - 1 \} } & { { \mathrm { i f ~ } } x < 0 } \\ { \left[ - 1 , 1 \right] } & { { \mathrm { i f ~ } } x = 0 } \\ { \{ + 1 \} } & { { \mathrm { i f ~ } } x > 0 } \end{array} \right. }
$$

where the notation $[ - 1 , 1 ]$ means any value between -1 and $^ { 1 }$ inclusive. See Figure 8.10 for an illustration.

# 8.2 First-order methods

In this section, we consider iterative optimization methods that leverage first-order derivatives of the objective function, i.e., they compute which directions point “downhill”, but they ignore curvature

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

![](images/401b6bd4b40f16d8f2e1954a631669041ae890c2c1665232ad0d7ae84cd02de1.jpg)  
Figure 8.9: Illustration of subgradients. $\mathbf { \nabla } _ { A t \ \mathbf { x } _ { 1 } }$ , the convex function $f$ is differentiable, and $\pmb { g } _ { 1 }$ (which is gt2h,e dge3r atriev sofu $f$ gatr $\pmb { x } _ { 1 }$ )iiesnthtes uanit uxe 2s;u gr1a iesnta $\pmb { x } _ { 1 }$ .b $\mathbf { \nabla } A t \mathbf { \nabla }$ athdeipeonint $\scriptstyle { \pmb x } _ { 2 }$ $f$ i1s not differentiable, because of the “kink”. However, there are many subgradients at this point, of which two are shown. From https: // web. stanford. edu/ class/ ee364b/ lectures/ subgradients_ slides. pdf . Used with kind permission Eof36=S4t ,|pShxtea|n oBrdoyUdn.i

![](images/68bee608653485bec825876cfb82d8ed5c1eb10fc39d3fb5ba4903d3095df104.jpg)  
Figure 8.10: The absolute value function (left) and its subdifferential (right). From https: // web. stanford. ehdua/ncld ps/l eoet s4bh/olewctsures/ su(bgxr,adgi)ents_xslidesR., fg. Used∂wfit(hxki)nd permission of Stephen Boyd.

information. All of these algorithms require that the user specify a starting point $\pmb { \theta } _ { 0 }$ . Then at each iteration $t$ , they perform an update of the following form:

$$
\pmb { \theta } _ { t + 1 } = \pmb { \theta } _ { t } + \eta _ { t } \pmb { d } _ { t }
$$

where $\eta _ { t }$ is known as the step size or learning rate, and $\scriptstyle d _ { t }$ is a descent direction, such as the negative of the gradient, given by $\begin{array} { r } { \pmb { g } _ { t } = \nabla _ { \pmb { \theta } } \mathcal { L } ( \pmb { \theta } ) | _ { \pmb { \theta } _ { t } } } \end{array}$ . These update steps are continued until the method reaches a stationary point, where the gradient is zero.

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

# 8.2.1 Descent direction

We say that a direction $\textbf { \em d }$ is a descent direction if there is a small enough (but nonzero) amount $\eta$ we can move in direction $\textbf { \em d }$ and be guaranteed to decrease the function value. Formally, we require that there exists an $\eta _ { \mathrm { m a x } } > 0$ such that

$$
\mathcal { L } ( { \pmb \theta } + \eta { \pmb d } ) < \mathcal { L } ( { \pmb \theta } )
$$

for all $0 < \eta < \eta _ { \mathrm { m a x } }$ . The gradient at the current iterate, $\pmb { \theta } _ { t }$ , is given by

$$
\pmb { g } _ { t } \triangleq \nabla \mathcal { L } ( \pmb { \theta } ) | _ { \pmb { \theta } _ { t } } = \nabla \mathcal { L } ( \pmb { \theta } _ { t } ) = \pmb { g } ( \pmb { \theta } _ { t } )
$$

This points in the direction of maximal increase in $f$ , so the negative gradient is a descent direction. It can be shown that any direction $\textbf { \em d }$ is also a descent direction if the angle $\theta$ between $\textbf { \em d }$ and $\mathbf { - } \pmb { g } _ { t }$ is less than 90 degrees and satisfies

$$
d ^ { \operatorname { T } } g _ { t } = | | \pmb { d } | | | | \pmb { g } _ { t } | | \cos ( \theta ) < 0
$$

It seems that the best choice would be to pick $d _ { t } = - g _ { t }$ . This is known as the direction of steepest descent. However, this can be quite slow. We consider faster versions later.

# 8.2.2 Step size (learning rate)

In machine learning, the sequence of step sizes $\{ \eta _ { t } \}$ is called the learning rate schedule. There are several widely used methods for picking this, some of which we discuss below. (See also Section 8.4.3, where we discuss schedules for stochastic optimization.)

# 8.2.2.1 Constant step size

The simplest method is to use a constant step size, $\eta _ { t } = \eta$ . However, if it is too large, the method may fail to converge, and if it is too small, the method will converge but very slowly. For example, consider the convex function

$$
\mathscr { L } ( \theta ) = 0 . 5 ( \theta _ { 1 } ^ { 2 } - \theta _ { 2 } ) ^ { 2 } + 0 . 5 ( \theta _ { 1 } - 1 ) ^ { 2 }
$$

Let us pick as our descent direction $d _ { t } = - g _ { t }$ . Figure 8.11 shows what happens if we use this descent direction with a fixed step size, starting from $( 0 , 0 )$ . In Figure 8.11(a), we use a small step size of $\eta = 0 . 1$ ; we see that the iterates move slowly along the valley. In Figure 8.11(b), we use a larger step size $\eta = 0 . 6$ ; we see that the iterates start oscillating up and down the sides of the valley and never converge to the optimum, even though this is a convex problem.

In some cases, we can derive a theoretical upper bound on the maximum step size we can use. For example, consider a quadratic objective, $\begin{array} { r } { \mathcal { L } ( \pmb { \theta } ) = \frac { 1 } { 2 } \pmb { \theta } ^ { \mathrm { 1 } } \mathbf { A } \pmb { \theta } + b ^ { \mathrm { 1 } } \pmb { \theta } + c } \end{array}$ with $\mathbf { A } \succeq \mathbf { 0 }$ . One can show that steepest descent will have global convergence iff the step size satisfies

$$
\eta < \frac { 2 } { \lambda _ { \mathrm { m a x } } ( \mathbf { A } ) }
$$

where $\lambda _ { \operatorname* { m a x } } ( \mathbf { A } )$ is the largest eigenvalue of A. The intuitive reason for this can be understood by thinking of a ball rolling down a valley. We want to make sure it doesn’t take a step that is larger than the slope of the steepest direction, which is what the largest eigenvalue measures (see Section 3.2.2).

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

![](images/aa7ea3be38ecf23676b99d71d288ec1715528398e3095ff4cf7c3d964d7d0956.jpg)  
Figure 8.11: Steepest descent on a simple convex function, starting from $( 0 , 0 )$ , for 20 steps, using a fixed step size. The global minimum is at $( 1 , 1 )$ . (a) $\eta = 0 . 1$ . (b) $\eta = 0 . 6$ . Generated by steepestDescentDemo.ipynb.

More generally, setting $\eta < 2 / L$ , where $L$ is the Lipschitz constant of the gradient (Section 8.1.4), ensures convergence. Since this constant is generally unknown, we usually need to adapt the step size, as we discuss below.

# 8.2.2.2 Line search

The optimal step size can be found by finding the value that maximally decreases the objective along the chosen direction by solving the 1d minimization problem

$$
\eta _ { t } = \underset { \eta > 0 } { \operatorname { a r g m i n } } \phi _ { t } ( \eta ) = \underset { \eta > 0 } { \operatorname { a r g m i n } } \mathcal { L } ( \theta _ { t } + \eta d _ { t } )
$$

This is known as line search, since we are searching along the line defined by $\scriptstyle d _ { t }$ .

If the loss is convex, this subproblem is also convex, because $\phi _ { t } ( \eta ) = \mathcal { L } ( \pmb { \theta } _ { t } + \eta \pmb { d } _ { t } )$ is a convex function of an affine function of $\eta$ , for fixed $\pmb { \theta } _ { t }$ and $\scriptstyle d _ { t }$ . For example, consider the quadratic loss

$$
{ \mathcal { L } } ( \theta ) = { \frac { 1 } { 2 } } \theta ^ { \mathsf { T } } \mathbf { A } \theta + b ^ { \mathsf { T } } \theta + c
$$

Computing the derivative of $\phi$ gives

$$
\begin{array} { l } { \displaystyle \frac { d \phi ( \eta ) } { d \eta } = \frac { d } { d \eta } \left[ \frac { 1 } { 2 } ( \theta + \eta \pmb { d } ) ^ { \top } \mathbf { A } ( \theta + \eta \pmb { d } ) + b ^ { \top } ( \theta + \eta \pmb { d } ) + c \right] } \\ { \displaystyle \qquad = \pmb { d } ^ { \top } \mathbf { A } ( \theta + \eta \pmb { d } ) + d ^ { \top } b } \\ { \displaystyle \qquad = \pmb { d } ^ { \top } ( \mathbf { A } \theta + b ) + \eta \pmb { d } ^ { \top } \mathbf { A } \pmb { d } } \end{array}
$$

Solving for $\begin{array} { r } { \frac { d \phi ( \eta ) } { d \eta } = 0 } \end{array}$ gives

$$
\eta = - \frac { d ^ { \mathsf { T } } ( \mathbf { A } \theta + b ) } { d ^ { \mathsf { T } } \mathbf { A } d }
$$

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

Using the optimal step size is known as exact line search. However, it is not usually necessary to be so precise. There are several methods, such as the Armijo backtracking method, that try to ensure sufficient reduction in the objective function without spending too much time trying to solve Equation (8.21). In particular, we can start with the current stepsize (or some maximum value), and then reduce it by a factor $0 < \beta < 1$ at each step until we satisfy the following condition, known as the Armijo-Goldstein test:

$$
\mathcal { L } ( \pmb { \theta } _ { t } + \eta \pmb { d } _ { t } ) \leq \mathcal { L } ( \pmb { \theta } _ { t } ) + c \eta \pmb { d } _ { t } ^ { \top } \nabla \mathcal { L } ( \pmb { \theta } _ { t } )
$$

where $c \in [ 0 , 1 ]$ is a constant, typically $c = 1 0 ^ { - 4 }$ . In practice, the initialization of the line-search and how to backtrack can significantly affect performance. See [NW06, Sec 3.1] for details.

# 8.2.3 Convergence rates

We want to find optimization algorithms that converge quickly to a (local) optimum. For certain convex problems, with a gradient with bounded Lipschitz constant, one can show that gradient descent converges at a linear rate. This means that there exists a number $0 < \mu < 1$ such that

$$
| \mathcal { L } ( \pmb { \theta } _ { t + 1 } ) - \mathcal { L } ( \pmb { \theta } _ { * } ) | \leq \mu | \mathcal { L } ( \pmb { \theta } _ { t } ) - \mathcal { L } ( \pmb { \theta } _ { * } ) |
$$

Here $\mu$ is called the rate of convergence.

For some simple problems, we can derive the convergence rate explicitly, For example, consider a quadratic objective $\begin{array} { r } { \mathcal { L } ( \pmb { \theta } ) = \frac { 1 } { 2 } \pmb { \theta } ^ { \top } \mathbf { A } \pmb { \theta } + b ^ { \top } \pmb { \theta } + c } \end{array}$ with $\mathbf A \succ 0$ . Suppose we use steepest descent with exact line search. One can show (see e.g., [Ber15]) that the convergence rate is given by

$$
\mu = \left( \frac { \lambda _ { \operatorname* { m a x } } - \lambda _ { \operatorname* { m i n } } } { \lambda _ { \operatorname* { m a x } } + \lambda _ { \operatorname* { m i n } } } \right) ^ { 2 }
$$

where $\lambda _ { \mathrm { m a x } }$ is the largest eigenvalue of $\mathbf { A }$ and $\lambda _ { \mathrm { m i n } }$ is the smallest eigenvalue. We can rewrite this as $\begin{array} { r } { \mu = \left( \frac { \kappa - 1 } { \kappa _ { - } + 1 } \right) ^ { 2 } } \end{array}$ , where $\begin{array} { r } { \kappa = \frac { \lambda _ { \mathrm { m a x } } } { \lambda _ { \mathrm { m i n } } } } \end{array}$ is the condition number of A. Intuitively, the condition number measures how “skewed” the space is, in the sense of being far from a symmetrical “bowl”. (See Section 7.1.4.4 for more information on condition numbers.)

Figure 8.12 illustrates the effect of the condition number on the convergence rate. On the left we show an example where $\mathbf { A } = \lfloor 2 0 , 5 ; 5 , 2 \rfloor$ , $\pmb { b } = [ - 1 4 ; - 6 ]$ and $c = 1 0$ , so $\kappa ( \mathbf { A } ) = 3 0 . 2 3 4$ . On the right we show an example where $\mathbf { A } = \lfloor 2 0 , 5 ; 5 , 1 6 \rfloor$ , $\pmb { b } = [ - 1 4 ; - 6 ]$ and $c = 1 0$ , so $\kappa ( \mathbf { A } ) = 1 . 8 5 4 1$ . We see that steepest descent converges much more quickly for the problem with the smaller condition number.

In the more general case of non-quadratic functions, the objective will often be locally quadratic around a local optimum. Hence the convergence rate depends on the condition number of the Hessian, $\kappa ( { \bf H } )$ , at that point. We can often improve the convergence speed by optimizing a surrogate objective (or model) at each step which has a Hessian that is close to the Hessian of the objective function as we discuss in Section 8.3.

Although line search works well, we see from Figure 8.12 that the path of steepest descent with an exact line-search exhibits a characteristic zig-zag behavior, which is inefficient. This problem can be overcome using a method called conjugate gradient descent (see e.g., [She94]).

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

![](images/9390e4e11fc965661a3f51185ceed0ac13ee3c2c864db8e1e5099d3482349604.jpg)  
Figure 8.12: Illustration of the effect of condition number κ on the convergence speed of steepest descent with exact line searches. (a) Large κ. (b) Small κ. Generated by lineSearchConditionNum.ipynb.

# 8.2.4 Momentum methods

Gradient descent can move very slowly along flat regions of the loss landscape, as we illustrated in Figure 8.11. We discuss some solutions to this below.

# 8.2.4.1 Momentum

One simple heuristic, known as the heavy ball or momentum method [Ber99], is to move faster along directions that were previously good, and to slow down along directions where the gradient has suddenly changed, just like a ball rolling downhill. This can be implemented as follows:

$$
\begin{array} { c } { { { \pmb { m } } _ { t } = \beta { \pmb { m } } _ { t - 1 } + { \pmb g } _ { t - 1 } } } \\ { { { \pmb \theta } _ { t } = { \pmb \theta } _ { t - 1 } - \eta _ { t } { \pmb m } _ { t } } } \end{array}
$$

where ${ \mathbf { } } ^ { \mathbf { \mathit { m } } _ { t } }$ is the momentum (mass times velocity) and $0 < \beta < 1$ . A typical value of $\beta$ is 0.9. For $\beta = 0$ , the method reduces to gradient descent.

We see that ${ \mathbf { } } m _ { t }$ is like an exponentially weighted moving average of the past gradients (see Section 4.4.2.2):

$$
m _ { t } = \beta m _ { t - 1 } + g _ { t - 1 } = \beta ^ { 2 } m _ { t - 2 } + \beta g _ { t - 2 } + g _ { t - 1 } = \cdot \cdot = \sum _ { \tau = 0 } ^ { t - 1 } \beta ^ { \tau } g _ { t - \tau - 1 }
$$

If all the past gradients are a constant, say $\pmb { g }$ , this simplifies to

$$
m _ { t } = g \sum _ { \tau = 0 } ^ { t - 1 } \beta ^ { \tau }
$$

The scaling factor is a geometric series, whose infinite sum is given by

$$
1 + \beta + \beta ^ { 2 } + \cdots = \sum _ { i = 0 } ^ { \infty } \beta ^ { i } = { \frac { 1 } { 1 - \beta } }
$$

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

![](images/32f08da8d67de046dd5a27a25e858aa6312cc13daee6209572401b110c697650.jpg)  
Figure 8.13: Illustration of the Nesterov update. Adapted from Figure 11.6 of [Gér19].

Thus in the limit, we multiply the gradient by $1 / ( 1 - \beta )$ . For example, if $\beta = 0 . 9$ , we scale the gradient up by 10.

Since we update the parameters using the gradient average ${ \mathbf { } } ^ { m } t - 1$ , rather than just the most recent gradient, $\mathbf { \delta } _ { \mathbf { \delta } _ { \mathbf { \delta } _ { \mathbf { \delta } _ { \mathbf { \delta } _ { \mathbf { \delta } _ { \mathbf { \delta } _ { \mathbf { \delta } _ { \mathbf { \delta } _ { \mathbf { \delta } _ { \delta } _ { \mathbf { \delta } _ { \delta } _ { \mathbf { \delta } _ { \delta } _ { \mathbf { \delta } _ { \delta } _ { \mathbf { \delta } _ { \delta } _ { \mathbf \delta } _ { \delta } } } } } } } } } } } } } }$ , we see that past gradients can exhibit some influence on the present. Furthermore, when momentum is combined with SGD, discussed in Section 8.4, we will see that it can simulate the effects of a larger minibatch, without the computational cost.

# 8.2.4.2 Nesterov momentum

One problem with the standard momentum method is that it may not slow down enough at the bottom of a valley, causing oscillation. The Nesterov accelerated gradient method of [Nes04] instead modifies the gradient descent to include an extrapolation step, as follows:

$$
\begin{array} { r l } & { \tilde { \pmb { \theta } } _ { t + 1 } = \pmb { \theta } _ { t } + \beta ( \pmb { \theta } _ { t } - \pmb { \theta } _ { t - 1 } ) } \\ & { \pmb { \theta } _ { t + 1 } = \tilde { \pmb { \theta } } _ { t + 1 } - \eta _ { t } \nabla \mathcal { L } ( \tilde { \pmb { \theta } } _ { t + 1 } ) } \end{array}
$$

This is essentially a form of one-step “look ahead”, that can reduce the amount of oscillation, as illustrated in Figure 8.13.

Nesterov accelerated gradient can also be rewritten in the same format as standard momentum. In this case, the momentum term is updated using the gradient at the predicted new location,

$$
\begin{array} { r l } & { \pmb { m } _ { t + 1 } = \beta \pmb { m } _ { t } - \eta _ { t } \nabla \mathcal { L } ( \pmb { \theta } _ { t } + \beta \pmb { m } _ { t } ) } \\ & { \pmb { \theta } _ { t + 1 } = \pmb { \theta } _ { t } + \pmb { m } _ { t + 1 } } \end{array}
$$

This explains why the Nesterov accelerated gradient method is sometimes called Nesterov momentum. It also shows how this method can be faster than standard momentum: the momentum vector is already roughly pointing in the right direction, so measuring the gradient at the new location, $\pmb { \theta } _ { t } + \beta \pmb { m } _ { t }$ , rather than the current location, $\pmb { \theta } _ { t }$ , can be more accurate.

The Nesterov accelerated gradient method is provably faster than steepest descent for convex functions when $\beta$ and $\eta _ { t }$ are chosen appropriately. It is called “accelerated” because of this improved

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022 convergence rate, which is optimal for gradient-based methods using only first-order information when the objective function is convex and has Lipschitz-continuous gradients. In practice, however, using Nesterov momentum can be slower than steepest descent, and can even unstable if $\beta$ or $\eta _ { t }$ are misspecified.

# 8.3 Second-order methods

Optimization algorithms that only use the gradient are called first-order methods. They have the advantage that the gradient is cheap to compute and to store, but they do not model the curvature of the space, and hence they can be slow to converge, as we have seen in Figure 8.12. Second-order optimization methods incorporate curvature in various ways (e.g., via the Hessian), which may yield faster convergence. We discuss some of these methods below.

# 8.3.1 Newton’s method

The classic second-order method is Newton’s method. This consists of updates of the form

$$
\pmb { \theta } _ { t + 1 } = \pmb { \theta } _ { t } - \eta _ { t } \mathbf { H } _ { t } ^ { - 1 } \pmb { g } _ { t }
$$

where

$$
\mathbf { H } _ { t } \triangleq \nabla ^ { 2 } \mathscr { L } ( \pmb { \theta } ) | _ { \pmb { \theta } _ { t } } = \nabla ^ { 2 } \mathscr { L } ( \pmb { \theta } _ { t } ) = \mathbf { H } ( \pmb { \theta } _ { t } )
$$

is assumed to be positive-definite to ensure the update is well-defined. The pseudo-code for Newton’s method is given in Algorithm 1. The intuition for why this is faster than gradient descent is that the matrix inverse ${ \bf H } ^ { - 1 }$ “undoes” any skew in the local curvature, converting a topology like Figure 8.12a to one like Figure 8.12b.

1 Initialize $\pmb { \theta } _ { 0 }$   
2 for $t = 1 , 2 , \ldots$ . until convergence do   
3 Evaluate $\begin{array} { r } { \pmb { g } _ { t } = \nabla \mathcal { L } ( \pmb { \theta } _ { t } ) } \end{array}$   
4 Evaluate $\mathbf { H } _ { t } = \nabla ^ { 2 } \mathcal { L } ( \pmb { \theta } _ { t } )$   
5 Solve $\mathbf { H } _ { t } \pmb { d } _ { t } = - \pmb { g } _ { t }$ for $\scriptstyle d _ { t }$   
6 Use line search to find stepsize $\eta _ { t }$ along $\scriptstyle d _ { t }$   
7 $\pmb { \theta } _ { t + 1 } = \pmb { \theta } _ { t } + \eta _ { t } \pmb { d } _ { t }$

This algorithm can be derived as follows. Consider making a second-order Taylor series approximation of ${ \mathcal { L } } ( \theta )$ around $\pmb { \theta } _ { t }$ :

$$
\mathcal { L } _ { \mathrm { q u a d } } ( \pmb { \theta } ) = \mathcal { L } ( \pmb { \theta } _ { t } ) + \pmb { g } _ { t } ^ { \top } ( \pmb { \theta } - \pmb { \theta } _ { t } ) + \frac { 1 } { 2 } ( \pmb { \theta } - \pmb { \theta } _ { t } ) ^ { \top } \mathbf { H } _ { t } ( \pmb { \theta } - \pmb { \theta } _ { t } )
$$

The minimum of ${ \mathcal { L } } _ { \mathrm { q u a d } }$ is at

$$
\pmb { \theta } = \pmb { \theta } _ { t } - \mathbf { H } _ { t } ^ { - 1 } \pmb { g } _ { t }
$$

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

![](images/902c004e8b720890de9a39cd31573921e18947776e7b7dd2611e9b5634a3b3c5.jpg)  
Figure 8.14: Illustration of Newton’s method for minimizing a 1d function. (a) The solid curve is the function $\mathcal { L } ( x )$ . The dotted line ${ \mathcal { L } } _ { \mathrm { q u a d } } ( \theta )$ is its second order approximation at $\theta _ { t }$ . The Newton step $d _ { t }$ is what must be added to $\theta _ { t }$ to get to the minimum of ${ \mathcal { L } } _ { \mathrm { q u a d } } ( \theta )$ . Adapted from Figure 13.4 of [Van06]. Generated by newtonsMethodMinQuad.ipynb. (b) Illustration of Newton’s method applied to a nonconvex function. We fit a quadratic function around the current point $\theta _ { t }$ and move to its stationary point, $\theta _ { t + 1 } = \theta _ { t } + d _ { t }$ . Unfortunately, this takes us near a local maximum of $f$ , not minimum. This means we need to be careful about the extent of our quadratic approximation. Adapted from Figure 13.11 of [Van06]. Generated by newtonsMethodNonConvex.ipynb.

So if the quadratic approximation is a good one, we should pick ${ \pmb { d } } _ { t } = - { \bf { H } } _ { t } ^ { - 1 } { \pmb { g } } _ { t }$ as our descent direction. See Figure 8.14(a) for an illustration. Note that, in a “pure” Newton method, we use $\eta _ { t } = 1$ as our stepsize. However, we can also use linesearch to find the best stepsize; this tends to be more robust as using $\eta _ { t } = 1$ may not always converge globally.

If we apply this method to linear regression, we get to the optimum in one step, since (as we shown in Section 11.2.2.1) we have $\mathbf { H } = \mathbf { X } ^ { \mathsf { I } } \mathbf { X }$ and $\begin{array} { r } { \mathbf { \Delta } \mathbf { g } = \mathbf { X } ^ { \top } \mathbf { X } \mathbf { \Delta } w - \mathbf { X } ^ { \top } \mathbf { \Delta } y } \end{array}$ , so the Newton update becomes

$$
{ \boldsymbol { \mathbf { \rho } } } ( \mathbf { w } _ { 0 } - \mathbf { H } ^ { - 1 } { \boldsymbol { g } } = w _ { 0 } - ( \mathbf { X } ^ { \mathsf { T } } \mathbf { X } ) ^ { - 1 } ( \mathbf { X } ^ { \mathsf { T } } \mathbf { X } w _ { 0 } - \mathbf { X } ^ { \mathsf { T } } \pmb { y } ) = w _ { 0 } - w _ { 0 } + ( \mathbf { X } ^ { \mathsf { T } } \mathbf { X } ) ^ { - 1 } \mathbf { X } ^ { \mathsf { T } } \mathbf { y }
$$

which is the OLS estimate. However, when we apply this method to logistic regression, it may take multiple iterations to converge to the global optimum, as we discuss in Section 10.2.6.

# 8.3.2 BFGS and other quasi-Newton methods

Quasi-Newton methods, sometimes called variable metric methods, iteratively build up an approximation to the Hessian using information gleaned from the gradient vector at each step. The most common method is called BFGS (named after its simultaneous inventors, Broyden, Fletcher, Goldfarb and Shanno), which updates the approximation to the Hessian $\mathbf { B } _ { t } \approx \mathbf { H } _ { t }$ as follows:

$$
\begin{array} { r l } & { { \bf \sigma } _ { + 1 } = { \bf B } _ { t } + \frac { y _ { t } y _ { t } ^ { \top } } { y _ { t } ^ { \top } s _ { t } } - \frac { ( { \bf B } _ { t } s _ { t } ) ( { \bf B } _ { t } s _ { t } ) ^ { \top } } { s _ { t } ^ { \top } { \bf B } _ { t } s _ { t } } } \\ & { { \bf \sigma } _ { s _ { t } } = \theta _ { t } - \theta _ { t - 1 } } \\ & { y _ { t } = g _ { t } - g _ { t - 1 } } \end{array}
$$

This is a rank-two update to the matrix. If $\mathbf { B } _ { 0 }$ is positive-definite, and the step size $\eta$ is chosen via line search satisfying both the Armijo condition in Equation (8.27) and the following curvature

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

![](images/fa6bcf80555567106039ec0c20c58a6fe756eb16f85a3787db911897459080c5.jpg)  
Figure 8.15: Illustration of the trust region approach. The dashed lines represents contours of the original nonconvex objective. The circles represent successive quadratic approximations. From Figure 4.2 of [Pas14]. Used with kind permission of Razvan Pascanu.

condition

$$
\nabla \mathcal { L } ( \pmb { \theta } _ { t } + \eta \pmb { d } _ { t } ) \geq c _ { 2 } \eta \pmb { d } _ { t } ^ { \top } \nabla \mathcal { L } ( \pmb { \theta } _ { t } )
$$

then $\mathbf { B } _ { t + 1 }$ will remain positive definite. The constant $c _ { 2 }$ is chosen within $( c , 1 )$ where $c$ is the tunable parameter in Equation (8.27). The two step size conditions are together known as the Wolfe conditions. We typically start with a diagonal approximation, $\mathbf { B } _ { 0 } = \mathbf { I }$ . Thus BFGS can be thought of as a “diagonal plus low-rank” approximation to the Hessian.

Alternatively, BFGS can iteratively update an approximation to the inverse Hessian, $\mathbf { C } _ { t } \approx \mathbf { H } _ { t } ^ { - 1 }$ , as follows:

$$
\mathbf { C } _ { t + 1 } = \left( \mathbf { I } - { \frac { s _ { t } y _ { t } ^ { \mathsf { T } } } { y _ { t } ^ { \mathsf { T } } s _ { t } } } \right) \mathbf { C } _ { t } \left( \mathbf { I } - { \frac { y _ { t } s _ { t } ^ { \mathsf { T } } } { y _ { t } ^ { \mathsf { T } } s _ { t } } } \right) + { \frac { s _ { t } s _ { t } ^ { \mathsf { T } } } { y _ { t } ^ { \mathsf { T } } s _ { t } } }
$$

Since storing the Hessian approximation still takes $O ( D ^ { 2 } )$ space, for very large problems, one can use limited memory BFGS, or L-BFGS, where we control the rank of the approximation by only using the $M$ most recent $\left( \boldsymbol { s } _ { t } , \boldsymbol { y } _ { t } \right)$ pairs while ignoring older information. Rather than storing $\mathbf { B } _ { t }$ explicitly, we just store these vectors in memory, and then approximate $\mathbf { H } _ { t } ^ { - 1 } { \boldsymbol { g } } _ { t }$ by performing a sequence of inner products with the stored $\mathbf { \boldsymbol { s } } _ { t }$ and ${ \mathbf { } } _ { \mathbf { } } \mathbf { \nabla } _  \mathbf { } \mathbf { } \mathbf { } \mathbf { } \mathbf { } \mathbf { } \mathbf { } \mathbf { } \mathbf { } \mathbf { } \mathbf { } \mathbf { } \mathbf { } \mathbf { } \mathbf { } \mathbf { } \mathbf { } \mathbf { } \mathbf { } \mathbf { } \mathbf { } \mathbf { } \mathbf { } \mathbf { } \mathbf { } \mathbf { } \mathbf { } \mathbf { } \mathbf { } \mathbf { } \mathbf { } \mathbf { } \mathbf { } \nabla _  \mathbf { } \mathbf { } \mathbf { } \mathbf { } \mathbf { } \mathbf { } \nabla _  \mathbf { } \mathbf { } \mathbf { } \mathbf { } \mathbf { } \mathbf { } \nabla _  \mathbf { } \mathbf { } \mathbf { } \mathbf { } \mathbf { } \mathbf { } \nabla _  \mathbf { } \mathbf { } \mathbf { } \mathbf { } \mathbf { } \mathbf { } \nabla \mathbf { } \mathbf { } \mathbf { } \mathbf { } \nabla \mathbf { } \mathbf { } \mathbf { } \nabla \mathbf { } \mathbf { } \mathbf { } \nabla \mathbf { } \mathbf { } \nabla \mathbf { } \mathbf { } \nabla \mathbf { } \mathbf { } \nabla \mathbf { } \mathbf { } \nabla \mathbf { } \nabla \mathbf { } \mathbf { } \nabla \mathbf { } \nabla \mathbf { } \nabla \mathbf { } \mathbf { } \nabla \mathbf { } \nabla \mathbf { } \nabla \mathbf { } \nabla \mathbf { } \nabla \mathbf { } \nabla \mathbf { } \nabla \mathbf { } \nabla \mathbf { } \nabla \mathbf { } \nabla \mathbf { } \nabla \nabla \mathbf { } \nabla \mathbf { } \nabla \nabla \mathbf { } \nabla \nabla \mathbf { } \nabla \nabla \mathbf { } \nabla \nabla \nabla \mathbf  \nabla \nabla \nabla \mathbf { } \nabla \nabla \mathbf { } \nabla \nabla \mathbf { \nabla \nabla \nabla \nabla \nabla \mathbf { } \nabla \nabla \mathbf \nabla \nabla \nabla \mathbf { } \nabla \nabla \nabla \nabla \nabla \mathbf \nabla \nabla \nabla \nabla \mathbf } \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla$ vectors. The storage requirements are therefore $O ( M D )$ . Typically choosing $M$ to be between 5–20 suffices for good performance [NW06, p177].

Note that sklearn uses LBFGS as its default solver for logistic regression.

# 8.3.3 Trust region methods

If the objective function is nonconvex, then the Hessian $\mathbf { H } _ { t }$ may not be positive definite, so $\mathbf { } d _ { t } =$ $- \mathbf { H } _ { t } ^ { - 1 } g _ { t }$ may not be a descent direction. This is illustrated in 1d in Figure 8.14(b), which shows that Newton’s method can end up in a local maximum rather than a local minimum.

In general, any time the quadratic approximation made by Newton’s method becomes invalid, we are in trouble. However, there is usually a local region around the current iterate where we can safely

approximate the objective by a quadratic. Let us call this region $\mathcal { R } _ { t }$ , and let us call $M ( \pmb \delta )$ the model (or approximation) to the objective, where $\pmb { \delta } = \pmb { \theta } - \pmb { \theta } _ { t }$ . Then at each step we can solve

$$
\delta ^ { * } = \operatorname * { a r g m i n } _ { \delta \in \mathcal { R } _ { t } } M _ { t } ( \delta )
$$

This is called trust-region optimization. (This can be seen as the “opposite” of line search, in the sense that we pick a distance we want to travel, determined by $\mathcal { R } _ { t }$ , and then solve for the optimal direction, rather than picking the direction and then solving for the optimal distance.)

We usually assume that $M _ { t } ( \delta )$ is a quadratic approximation:

$$
M _ { t } ( \pmb \delta ) = \mathcal { L } ( \pmb \theta _ { t } ) + \pmb { g } _ { t } ^ { \top } \pmb \delta + \frac { 1 } { 2 } \pmb \delta ^ { \top } \mathbf { H } _ { t } \pmb \delta
$$

where $\begin{array} { r } { \pmb { g } _ { t } = \nabla _ { \pmb { \theta } } \mathcal { L } ( \pmb { \theta } ) | _ { \pmb { \theta } _ { t } } } \end{array}$ is the gradient, and $\mathbf { H } _ { t } = \nabla _ { \pmb { \theta } } ^ { 2 } \mathcal { L } ( \pmb { \theta } ) | _ { \pmb { \theta } _ { t } }$ is the Hessian. Furthermore, it is common to assume that $\mathcal { R } _ { t }$ is a ball of radius $r$ , i.e., $\mathcal { R } _ { t } = \{ \delta : | | \delta | | _ { 2 } \leq r \}$ . Using this, we can convert the constrained problem into an unconstrained one as follows:

$$
{ \boldsymbol { \delta } } ^ { * } = \operatorname * { a r g m i n } _ { { \boldsymbol { \delta } } } M ( { \boldsymbol { \delta } } ) + \lambda \vert \vert { \boldsymbol { \delta } } \vert \vert _ { 2 } ^ { 2 } = \operatorname * { a r g m i n } _ { { \boldsymbol { \delta } } } { \boldsymbol { g } } ^ { \intercal } { \boldsymbol { \delta } } + { \frac { 1 } { 2 } } { \boldsymbol { \delta } } ^ { \intercal } ( \mathbf { H } + \lambda \mathbf { I } ) { \boldsymbol { \delta } }
$$

for some Lagrange multiplier $\lambda > 0$ which depends on the radius $r$ (see Section 8.5.1 for a discussion of Lagrange multipliers). We can solve this using

$$
\pmb { \delta } = - ( \mathbf { H } + \lambda \mathbf { I } ) ^ { - 1 } \pmb { g }
$$

This is called Tikhonov damping or Tikhonov regularization. See Figure 8.15 for an illustration. Note that adding a sufficiently large $\lambda \mathbf { I }$ to $\mathbf { H }$ ensures the resulting matrix is always positive definite. As $\lambda  0$ , this trust method reduces to Newton’s method, but for $\lambda$ large enough, it will make all the negative eigenvalues positive (and all the 0 eigenvalues become equal to $\lambda$ ).

# 8.4 Stochastic gradient descent

In this section, we consider stochastic optimization, where the goal is to minimize the average value of a function:

$$
\mathcal { L } ( \pmb { \theta } ) = \mathbb { E } _ { q ( z ) } \left[ \mathcal { L } ( \pmb { \theta } , z ) \right]
$$

where $\boldsymbol { z }$ is a random input to the objective. This could be a “noise” term, coming from the environment, or it could be a training example drawn randomly from the training set, as we explain below.

At each iteration, we assume we observe $\mathcal { L } _ { t } ( \pmb { \theta } ) = \mathcal { L } ( \pmb { \theta } , \pmb { z } _ { t } )$ , where $z _ { t } \sim q$ . We also assume a way to compute an unbiased estimate of the gradient of $\mathcal { L }$ . If the distribution $q ( z )$ is independent of the parameters we are optimizing, we can use $\pmb { g } _ { t } = \nabla _ { \pmb { \theta } } \mathcal { L } _ { t } ( \pmb { \theta } _ { t } )$ . In this case, The resulting algorithm can be written as follows:

$$
\pmb { \theta } _ { t + 1 } = \pmb { \theta } _ { t } - \eta _ { t } \nabla \mathcal { L } ( \pmb { \theta } _ { t } , z _ { t } ) = \pmb { \theta } _ { t } - \eta _ { t } \pmb { g } _ { t }
$$

This method is known as stochastic gradient descent or SGD. As long as the gradient estimate is unbiased, then this method will converge to a stationary point, providing we decay the step size $\mathit { \Delta } ^ { \prime } \mathit { I } _ { t }$ at a certain rate, as we discuss in Section 8.4.3.

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

# 8.4.1 Application to finite sum problems

SGD is very widely used in machine learning. To see why, recall from Section 4.3 that many model fitting procedures are based on empirical risk minimization, which involve minimizing the following loss:

$$
\mathcal { L } ( \pmb { \theta } _ { t } ) = \frac { 1 } { N } \sum _ { n = 1 } ^ { N } \ell ( \pmb { y } _ { n } , f ( \pmb { x } _ { n } ; \pmb { \theta } _ { t } ) ) = \frac { 1 } { N } \sum _ { n = 1 } ^ { N } \mathcal { L } _ { n } ( \pmb { \theta } _ { t } )
$$

This is called a finite sum problem. The gradient of this objective has the form

$$
g _ { t } = \frac { 1 } { N } \sum _ { n = 1 } ^ { N } \nabla _ { \theta } \mathcal { L } _ { n } ( \theta _ { t } ) = \frac { 1 } { N } \sum _ { n = 1 } ^ { N } \nabla _ { \theta } \ell ( y _ { n } , f ( x _ { n } ; \theta _ { t } ) )
$$

This requires summing over all $N$ training examples, and thus can be slow if $N$ is large. Fortunately we can approximate this by sampling a minibatch of $B \ll N$ samples to get

$$
g _ { t } \approx \frac { 1 } { | \mathcal { B } _ { t } | } \sum _ { n \in \mathcal { B } _ { t } } \nabla _ { \theta } \mathcal { L } _ { n } ( \theta _ { t } ) = \frac { 1 } { | \mathcal { B } _ { t } | } \sum _ { n \in \mathcal { B } _ { t } } \nabla _ { \theta } \ell ( y _ { n } , f ( { \boldsymbol x } _ { n } ; { \boldsymbol \theta } _ { t } ) )
$$

where $B _ { t }$ is a set of randomly chosen examples to use at iteration $t$ .2 This is an unbiased approximation to the empirical average in Equation (8.56). Hence we can safely use this with SGD.

Although the theoretical rate of convergence of SGD is slower than batch GD (in particular, SGD has a sublinear convergence rate), in practice SGD is often faster, since the per-step time is much lower [BB08; BB11]. To see why SGD can make faster progress than full batch GD, suppose we have a dataset consisting of a single example duplicated $K$ times. Batch training will be (at least) $K$ times slower than SGD, since it will waste time computing the gradient for the repeated examples. Even if there are no duplicates, batch training can be wasteful, since early on in training the parameters are not well estimated, so it is not worth carefully evaluating the gradient.

# 8.4.2 Example: SGD for fitting linear regression

In this section, we show how to use SGD to fit a linear regression model. Recall from Section 4.2.7 that the objective has the form

$$
\mathcal { L } ( \pmb { \theta } ) = \frac { 1 } { 2 N } \sum _ { n = 1 } ^ { N } ( \pmb { x } _ { n } ^ { \top } \pmb { \theta } - y _ { n } ) ^ { 2 } = \frac { 1 } { 2 N } | | \mathbf { X } \pmb { \theta } - \pmb { y } | | _ { 2 } ^ { 2 }
$$

The gradient is

$$
{ \pmb g } _ { t } = \frac { 1 } { N } \sum _ { n = 1 } ^ { N } ( { \pmb \theta } _ { t } ^ { \top } { \pmb x } _ { n } - y _ { n } ) { \pmb x } _ { n }
$$

![](images/60324b3e03a71b395a2f1d80c1ede9cd0e8dac0511c952ad1f1cb530d0fb83ed.jpg)  
Figure 8.16: Illustration of the LMS algorithm. Left: we start from $\pmb { \theta } = ( - 0 . 5 , 2 )$ and slowly converging to the least squares solution of $\pmb { \hat { \theta } } = ( 1 . 4 5 , 0 . 9 3 )$ (red cross). Right: plot of objective function over time. Note that it does not decrease monotonically. Generated by lms_demo.ipynb.

Now consider using SGD with a minibatch size of $B = 1$ . The update becomes

$$
\pmb { \theta } _ { t + 1 } = \pmb { \theta } _ { t } - \eta _ { t } \big ( \pmb { \theta } _ { t } ^ { \top } \pmb { x } _ { n } - y _ { n } \big ) \pmb { x } _ { n }
$$

where $n = n ( t )$ is the index of the example chosen at iteration $t$ . The overall algorithm is called the least mean squares (LMS) algorithm, and is also known as the delta rule, or the Widrow-Hoff rule.

Figure 8.16 shows the results of applying this algorithm to the data shown in Figure 11.2. We start at $\pmb { \theta } = ( - 0 . 5 , 2 )$ and converge (in the sense that $| | \pmb { \theta } _ { t } - \pmb { \theta } _ { t - 1 } | | _ { 2 } ^ { 2 }$ drops below a threshold of $1 0 ^ { - 2 }$ ) in about 26 iterations. Note that SGD (and hence LMS) may require multiple passes through the data to find the optimum.

# 8.4.3 Choosing the step size (learning rate)

When using SGD, we need to be careful in how we choose the learning rate in order to achieve convergence. For example, in Figure 8.17 we plot the loss vs the learning rate when we apply SGD to a deep neural network classifier (see Chapter 13 for details). We see a U-shaped curve, where an overly small learning rate results in underfitting, and overly large learning rate results in instability of the model (c.f., Figure 8.11(b)); in both cases, we fail to converge to a local optimum.

One heuristic for choosing a good learning rate, proposed in [Smi18], is to start with a small learning rate and gradually increase it, evaluating performance using a small number of minibatches. We then make a plot like the one in Figure 8.17, and pick the learning rate with the lowest loss. (In practice, it is better to pick a rate that is slightly smaller than (i.e., to the left of) the one with the lowest loss, to ensure stability.)

Rather than choosing a single constant learning rate, we can use a learning rate schedule, in which we adjust the step size over time. Theoretically, a sufficient condition for SGD to achieve

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022 convergence is if the learning rate schedule satisfies the Robbins-Monro conditions:

![](images/d90dc7ba7900dc3169fb4f9f9148d2f1efe877972a99aba81540310e528b6180.jpg)  
Figure 8.17: Loss vs learning rate (horizontal axis). Training loss vs learning rate for a small MLP fit to FashionMNIST using vanilla SGD. (Raw loss in blue, EWMA smoothed version in orange). Generated by lrschedule_tf.ipynb.

![](images/03ceae09bba1e92b57871b8886851a88a0c12f55b278aca10994b21acc978cb3.jpg)  
Figure 8.18: Illustration of some common learning rate schedules. (a) Piecewise constant. (b) Exponential decay. (c) Polynomial decay. Generated by learning_rate_plot.ipynb.

$$
\eta _ { t }  0 , \frac { \sum _ { t = 1 } ^ { \infty } \eta _ { t } ^ { 2 } } { \sum _ { t = 1 } ^ { \infty } \eta _ { t } }  0
$$

Some common examples of learning rate schedules are listed below:

In the piecewise constant schedule, $t _ { i }$ are a set of time points at which we adjust the learning rate to a specified value. For example, we may set $\eta _ { i } = \eta _ { 0 } \gamma ^ { i }$ , which reduces the initial learning rate by a factor of $\gamma$ for each threshold (or milestone) that we pass. Figure 8.18a illustrates this for $\eta _ { 0 } = 1$

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license and $\gamma = 0 . 9$ . This is called step decay. Sometimes the thresholds times are computed adaptively, by estimating when the train or validation loss has plateaued; this is called reduce-on-plateau. Exponential decay is typically too fast, as illustrated in Figure 8.18b. A common choice is polynomial decay, with $\alpha = 0 . 5$ and $\beta = 1$ , as illustrated in Figure 8.18c; this corresponds to a square-root schedule, ηt = η0 √t1+1 .

![](images/c44036c7a05b326ad88fb4c08bbff1ffdbd896d35b0c461b8ceb9a34e192ad3f.jpg)  
Figure 8.19: (a) Linear warm-up followed by cosine cool-down. (b) Cyclical learning rate schedule.

In the deep learning community, another common schedule is to quickly increase the learning rate and then gradually decrease it again, as shown in Figure 8.19a. This is called learning rate warmup, or the one-cycle learning rate schedule [Smi18]. The motivation for this is the following: initially the parameters may be in a part of the loss landscape that is poorly conditioned, so a large step size will “bounce around” too much (c.f., Figure 8.11(b)) and fail to make progress downhill. However, with a slow learning rate, the algorithm can discover flatter regions of space, where a larger step size can be used. Once there, fast progress can be made. However, to ensure convergence to a point, we must reduce the learning rate to 0. See [Got+19; Gil+21] for more details.

It is also possible to increase and decrease the learning rate multiple times, in a cyclical fashion. This is called a cyclical learning rate [Smi18], and was popularized by the fast.ai course. See Figure 8.19b for an illustration using triangular shapes. The motivation behind this approach is to escape local minima. The minimum and maximum learning rates can be found based on the initial “dry run” described above, and the half-cycle can be chosen based on how many restarts you want to do with your training budget. A related approach, known as stochastic gradient descent with warm restarts, was proposed in [LH17]; they proposed storing all the checkpoints visited after each cool down, and using all of them as members of a model ensemble. (See Section 18.2 for a discussion of ensemble learning.)

An alternative to using heuristics for estimating the learning rate is to use line search (Section 8.2.2.2). This is tricky when using SGD, because the noisy gradients make the computation of the Armijo condition difficult [CS20]. However, [Vas+19] show that it can be made to work if the variance of the gradient noise goes to zero over time. This can happen if the model is sufficiently flexible that it can perfectly interpolate the training set.

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

# 8.4.4 Iterate averaging

The parameter estimates produced by SGD can be very unstable over time. To reduce the variance of the estimate, we can compute the average using

$$
\overline { { \pmb { \theta } } } _ { t } = \frac { 1 } { t } \sum _ { i = 1 } ^ { t } \pmb { \theta } _ { i } = \frac { 1 } { t } \pmb { \theta } _ { t } + \frac { t - 1 } { t } \overline { { \pmb { \theta } } } _ { t - 1 }
$$

where $\pmb { \theta } _ { t }$ are the usual SGD iterates. This is called iterate averaging or Polyak-Ruppert averaging [Rup88].

In [PJ92], they prove that the estimate ${ \overline { { \theta } } } _ { t }$ achieves the best possible asymptotic convergence rate among SGD algorithms, matching that of variants using second-order information, such as Hessians.

This averaging can also have statistical benefits. For example, in [NR18], they prove that, in the case of linear regression, this method is equivalent to $\ell _ { 2 }$ regularization (i.e., ridge regression).

Rather than an exponential moving average of SGD iterates, Stochastic Weight Averaging (SWA) [Izm+18] uses an equal average in conjunction with a modified learning rate schedule. In contrast to standard Polyak-Ruppert averaging, which was motivated for faster convergence rates, SWA exploits the flatness in objectives used to train deep neural networks, to find solutions which provide better generalization.

# 8.4.5 Variance reduction \*

In this section, we discuss various ways to reduce the variance in SGD. In some cases, this can improve the theoretical convergence rate from sublinear to linear (i.e., the same as full-batch gradient descent) [SLRB17; JZ13; DBLJ14]. These methods reduce the variance of the gradients, rather than the parameters themselves and are designed to work for finite sum problems.

# 8.4.5.1 SVRG

The basic idea of stochastic variance reduced gradient (SVRG) [JZ13] is to use a control variate, in which we estimate a baseline value of the gradient based on the full batch, which we then use to compare the stochastic gradients to.

More precisely, ever so often (e.g., once per epoch), we compute the full gradient at a “snapshot” of the model parameters $\tilde { \pmb { \theta } }$ ; the corresponding “exact” gradient is therefore $\nabla { \mathcal { L } } ( { \tilde { \boldsymbol { \theta } } } )$ . At step $t$ , we compute the usual stochastic gradient at the current parameters, $\nabla { \mathcal { L } } _ { t } ( \theta _ { t } )$ , but also at the snapshot parameters, $\nabla { \mathcal { L } } _ { t } ( { \bar { \pmb { \theta } } } )$ , which we use as a baseline. We can then use the following improved gradient estimate

$$
\pmb { g } _ { t } = \nabla \mathcal { L } _ { t } ( \pmb { \theta } _ { t } ) - \nabla \mathcal { L } _ { t } ( \tilde { \pmb { \theta } } ) + \nabla \mathcal { L } ( \tilde { \pmb { \theta } } )
$$

to compute $\pmb { \theta } _ { t + 1 }$ . This is unbiased because $\mathbb { E } \left[ \nabla \mathcal { L } _ { t } ( \tilde { { \boldsymbol { \theta } } } ) \right] = \nabla \mathcal { L } ( \tilde { { \boldsymbol { \theta } } } )$ . Furthermore, the update only involves two gradient computations, since we can compute $\nabla { \mathcal { L } } ( { \bar { \boldsymbol { \theta } } } )$ once per epoch. At the end of the epoch, we update the snapshot parameters, $\tilde { \pmb { \theta } }$ , based on the most recent value of $\pmb { \theta } _ { t }$ , or a running average of the iterates, and update the expected baseline. (We can compute snapshots less often, but then the baseline will not be correlated with the objective and can hurt performance, as shown in [DB18].)

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

Iterations of SVRG are computationally faster than those of full-batch GD, but SVRG can still match the theoretical convergence rate of GD.

# 8.4.5.2 SAGA

In this section, we describe the stochastic averaged gradient accelerated (SAGA) algorithm of [DBLJ14]. Unlike SVRG, it only requires one full batch gradient computation, at the start of the algorithm. However, it “pays” for this saving in time by using more memory. In particular, it must store $N$ gradient vectors. This enables the method to maintain an approximation of the global gradient by removing the old local gradient from the overall sum and replacing it with the new local gradient. This is called an aggregated gradient method.

$\begin{array} { r } { { \pmb g } ^ { \mathrm { a v g } } = \frac { 1 } { N } \sum _ { n = 1 } ^ { N } { \pmb g } _ { n } ^ { \mathrm { l o c a l } } } \end{array}$ More precisely, we first initialize by computing . Then, at iteration $t$ , we use the gradient estimate $\pmb { g } _ { n } ^ { \mathrm { l o c a l } } = \nabla \mathcal { L } _ { n } ( \pmb { \theta } _ { 0 } )$ for all $n$ , and the average,

$$
\pmb { g } _ { t } = \nabla \mathcal { L } _ { n } ( \pmb { \theta } _ { t } ) - \pmb { g } _ { n } ^ { \mathrm { l o c a l } } + \pmb { g } ^ { \mathrm { a v g } }
$$

where $n \sim \operatorname { U n i f } \{ 1 , \dots , N \}$ is the example index sampled at iteration $t$ . We then update $\begin{array} { l } { { g _ { n } ^ { \mathrm { l o c a l } } = } } \end{array}$ $\nabla { \mathcal { L } } _ { n } ( \theta _ { t } )$ and $g ^ { \mathrm { a v g } }$ by replacing the old $\mathbf { \Psi } _ { g _ { n } } ^ { \mathrm { l o c a l } }$ by its new value.

This has an advantage over SVRG since it only has to do one full batch sweep at the start. (In fact, the initial sweep is not necessary, since we can compute ${ \pmb g } ^ { \mathrm { a v g } }$ “lazily”, by only incorporating gradients we have seen so far.) The downside is the large extra memory cost. However, if the features (and hence gradients) are sparse, the memory cost can be reasonable. Indeed, the SAGA algorithm is recommended for use in the sklearn logistic regression code when $N$ is large and $_ { x }$ is sparse.3

# 8.4.5.3 Application to deep learning

Variance reduction methods are widely used for fitting ML models with convex objectives, such as linear models. However, there are various difficulties associated with using SVRG with conventional deep learning training practices. For example, the use of batch normalization (Section 14.2.4.1), data augmentation (Section 19.1) and dropout (Section 13.5.4) all break the assumptions of the method, since the loss will differ randomly in ways that depend not just on the parameters and the data index $n$ . For more details, see e.g., [DB18; Arn+19].

# 8.4.6 Preconditioned SGD

In this section, we consider preconditioned SGD, which involves the following update:

$$
\pmb { \theta } _ { t + 1 } = \pmb { \theta } _ { t } - \eta _ { t } \mathbf { M } _ { t } ^ { - 1 } \pmb { g } _ { t } ,
$$

where $\mathbf { M } _ { t }$ is a preconditioning matrix, or simply the preconditioner, typically chosen to be positive-definite. Unfortunately the noise in the gradient estimates make it difficult to reliably estimate the Hessian, which makes it difficult to use the methods from Section 8.3. In addition, it is expensive to solve for the update direction with a full preconditioning matrix. Therefore most practitioners use a diagonal preconditioner $\mathbf { M } _ { t }$ . Such preconditioners do not necessarily use second-order information, but often result in speedups compared to vanilla SGD. See also [Roo+21] for a probabilitic interpretation of these heuristics, and sgd_comparison.ipynb for an empirical comparison on some simple datasets.

# 8.4.6.1 AdaGrad

The AdaGrad (short for “adaptive gradient”) method of [DHS11] was originally designed for optimizing convex objectives where many elements of the gradient vector are zero; these might correspond to features that are rarely present in the input, such as rare words. The update has the following form

$$
\theta _ { t + 1 , d } = \theta _ { t , d } - \eta _ { t } \frac { 1 } { \sqrt { s _ { t , d } + \epsilon } } g _ { t , d }
$$

where $d = 1 : D$ indexes the dimensions of the parameter vector, and

$$
s _ { t , d } = \sum _ { i = 1 } ^ { t } g _ { i , d } ^ { 2 }
$$

is the sum of the squared gradients and $\epsilon > 0$ is a small term to avoid dividing by zero. Equivalently we can write the update in vector form as follows:

$$
\Delta \pmb { \theta } _ { t } = - \eta _ { t } \frac { 1 } { \sqrt { s _ { t } + \epsilon } } \pmb { g } _ { t }
$$

where the square root and division is performed elementwise. Viewed as preconditioned SGD, this is equivalent to taking ${ \bf M } _ { t } = \mathrm { d i a g } ( s _ { t } + \epsilon ) ^ { 1 / 2 }$ . This is an example of an adaptive learning rate; the overall stepsize $\eta _ { t }$ still needs to be chosen, but the results are less sensitive to it compared to vanilla GD. In particular, we usually fix $\eta _ { t } = \eta _ { 0 }$ .

# 8.4.6.2 RMSProp and AdaDelta

A defining feature of AdaGrad is that the term in the denominator gets larger over time, so the effective learning rate drops. While it is necessary to ensure convergence, it might hurt performance as the denominator gets large too fast.

An alternative is to use an exponentially weighted moving average (EWMA, Section 4.4.2.2) of the past squared gradients, rather than their sum:

$$
s _ { t + 1 , d } = \beta s _ { t , d } + ( 1 - \beta ) g _ { t , d } ^ { 2 }
$$

In practice we usually use $\beta \sim 0 . 9$ , which puts more weight on recent examples. In this case,

$$
\sqrt { s _ { t , d } } \approx \mathrm { R M S } ( g _ { 1 : t , d } ) = \sqrt { \frac { 1 } { t } \sum _ { \tau = 1 } ^ { t } g _ { \tau , d } ^ { 2 } }
$$

where RMS stands for “root mean squared”. Hence this method, (which is based on the earlier RPROP method of [RB93]) is known as RMSProp [Hin14]. The overall update of RMSProp is

$$
\Delta \pmb { \theta } _ { t } = - \eta _ { t } \frac { 1 } { \sqrt { s _ { t } + \epsilon } } \pmb { g } _ { t } .
$$

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

The AdaDelta method was independently introduced in [Zei12], and is similar to RMSprop. However, in addition to accumulating an EWMA of the gradients in $\hat { \boldsymbol { s } }$ , it also keeps an EWMA of the updates $\delta _ { t }$ to obtain an update of the form

$$
\Delta \pmb { \theta } _ { t } = - \eta _ { t } \frac { \sqrt { \delta _ { t - 1 } + \epsilon } } { \sqrt { s _ { t } + \epsilon } } \pmb { g } _ { t }
$$

where

$$
\delta _ { t } = \beta \delta _ { t - 1 } + ( 1 - \beta ) ( \Delta \pmb { \theta } _ { t } ) ^ { 2 }
$$

and $\mathbf { } s _ { t }$ is the same as in RMSProp. This has the advantage that the “units” of the numerator and denominator cancel, so we are just elementwise-multiplying the gradient by a scalar. This eliminates the need to tune the learning rate $\eta _ { t }$ , which means one can simply set $\eta _ { t } = 1$ , although popular implementations of AdaDelta still keep $\eta _ { t }$ as a tunable hyperparameter. However, since these adaptive learning rates need not decrease with time (unless we choose $\eta _ { t }$ to explicitly do so), these methods are not guaranteed to converge to a solution.

# 8.4.6.3 Adam

It is possible to combine RMSProp with momentum. In particular, let us compute an EWMA of the gradients (as in momentum) and squared gradients (as in RMSProp)

$$
\begin{array} { c } { { \pmb { m } } _ { t } = \beta _ { 1 } { \pmb { m } } _ { t - 1 } + ( 1 - \beta _ { 1 } ) { \pmb { g } } _ { t } } \\ { { \pmb { s } } _ { t } = \beta _ { 2 } { \pmb { s } } _ { t - 1 } + ( 1 - \beta _ { 2 } ) { \pmb { g } } _ { t } ^ { 2 } } \end{array}
$$

We then perform the following update:

$$
\Delta \pmb { \theta } _ { t } = - \eta _ { t } \frac { 1 } { \sqrt { s _ { t } } + \epsilon } \pmb { m } _ { t }
$$

The resulting method is known as Adam, which stands for “adaptive moment estimation” [KB15]. The standard values for the various constants are $\beta _ { 1 } = 0 . 9$ , $\beta _ { 2 } = 0 . 9 9 9$ and $\epsilon = 1 0 ^ { - 6 }$ . (If we set $\beta _ { 1 } = 0$ and no bias-correction, we recover RMSProp, which does not use momentum.) For the overall learning rate, it is common to use a fixed value such as $\eta _ { t } = 0 . 0 0 1$ . Again, as the adaptive learning rate may not decrease over time, convergence is not guaranteed (see Section 8.4.6.4).

If we initialize with $\pmb { m } _ { 0 } = \pmb { s } _ { 0 } = \mathbf { 0 }$ , then initial estimates will be biased towards small values. The authors therefore recommend using the bias-corrected moments, which increase the values early in the optimization process. These estimates are given by

$$
\begin{array} { c } { { \hat { m } _ { t } = m _ { t } / ( 1 - \beta _ { 1 } ^ { t } ) } } \\ { { \hat { s } _ { t } = s _ { t } / ( 1 - \beta _ { 2 } ^ { t } ) } } \end{array}
$$

The advantage of bias-correction is shown in Figure 4.3.

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

# 8.4.6.4 Issues with adaptive learning rates

When using diagonal scaling methods, the overall learning rate is determined by $\eta _ { 0 } \mathbf { M } _ { t } ^ { - 1 }$ , which changes with time. Hence these methods are often called adaptive learning rate methods. However, they still require setting the base learning rate $\eta _ { 0 }$ .

Since the EWMA methods are typically used in the stochastic setting where the gradient estimates are noisy, their learning rate adaptation can result in non-convergence even on convex problems [RKK18]. Various solutions to this problem have been proposed, including AMSGrad [RKK18], Padam [CG18; Zho+18], and Yogi [Zah+18]. For example, the Yogi update modifies Adam by replacing

$$
s _ { t } = \beta _ { 2 } s _ { t - 1 } + ( 1 - \beta _ { 2 } ) g _ { t } ^ { 2 } = s _ { t - 1 } + ( 1 - \beta _ { 2 } ) ( g _ { t } ^ { 2 } - s _ { t - 1 } )
$$

with

$$
\pmb { s } _ { t } = \pmb { s } _ { t - 1 } + ( 1 - \beta _ { 2 } ) \pmb { g } _ { t } ^ { 2 } \odot \mathrm { s g n } ( \pmb { g } _ { t } ^ { 2 } - \pmb { s } _ { t - 1 } )
$$

# 8.4.6.5 Non-diagonal preconditioning matrices

Although the methods we have discussed above can adapt the learning rate of each parameter, they do not solve the more fundamental problem of ill-conditioning due to correlation of the parameters, and hence do not always provide as much of a speed boost over vanilla SGD as one may hope.

One way to get faster convergence is to use the following preconditioning matrix, known as full-matrix Adagrad [DHS11]:

$$
\mathbf { M } _ { t } = [ ( \mathbf { G } _ { t } \mathbf { G } _ { t } ^ { \mathsf { T } } ) ^ { \frac { 1 } { 2 } } + \epsilon \mathbf { I } _ { D } ] ^ { - 1 }
$$

where

$$
\mathbf { G } _ { t } = [ \pmb { g } _ { t } , \dots , \pmb { g } _ { 1 } ]
$$

Here $\pmb { g } _ { i } = \nabla _ { \pmb { \psi } } c ( \pmb { \psi } _ { i } )$ is the $D$ -dimensional gradient vector computed at step $i$ . Unfortunately, $\mathbf { M } _ { t }$ is a $\boldsymbol { D } \times \boldsymbol { D }$ matrix, which is expensive to store and invert.

The Shampoo algorithm [GKS18] makes a block diagonal approximation to $\mathbf { M }$ , one per layer of the model, and then exploits Kronecker product structure to efficiently invert it. (It is called “shampoo” because it uses a conditioner.) Recently, [Ani+20] scaled this method up to fit very large deep models in record time.

# 8.5 Constrained optimization

In this section, we consider the following constrained optimization problem:

$$
\pmb { \theta } ^ { * } = \arg \operatorname* { m i n } _ { \pmb { \theta } \in \mathcal { C } } \mathcal { L } ( \pmb { \theta } )
$$

where the feasible set, or constraint set, is

$$
{ \mathcal { C } } = \{ \pmb { \theta } \in \mathbb { R } ^ { D } : h _ { i } ( \pmb { \theta } ) = 0 , i \in \mathcal { E } , g _ { j } ( \pmb { \theta } ) \leq 0 , j \in \mathbb { Z } \}
$$

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license where $\boldsymbol { \xi }$ is the set of equality constraints, and $\mathcal { T }$ is the set of inequality constraints.

![](images/8fd2c40994378bf85c75cfcda276512674d216d5362201df16bf07f461f46283.jpg)  
Figure 8.20: Illustration of some constrained optimization problems. Red contours are the level sets of the objective function $\mathcal { L } ( \pmb { \theta } )$ . Optimal constrained solution is the black dot, (a) Blue line is the equality constraint $h ( \pmb \theta ) = 0$ . (b) Blue lines denote the inequality constraints $| \theta _ { 1 } | + | \theta _ { 2 } | \leq 1$ . (Compare to Figure 11.8 (left).)

For example, suppose we have a quadratic objective, ${ \mathcal L } ( \pmb { \theta } ) = { \theta } _ { 1 } ^ { 2 } + { \theta } _ { 2 } ^ { 2 }$ , subject to a linear equality constraint, $h ( \pmb \theta ) = 1 - \theta _ { 1 } - \theta _ { 2 } = 0$ . Figure 8.20(a) plots the level sets of $\mathcal { L }$ , as well as the constraint surface. What we are trying to do is find the point $\pmb { \theta } ^ { * }$ that lives on the line, but which is closest to the origin. It is clear from the geometry that the optimal solution is $\pmb { \theta } = ( 0 . 5 , 0 . 5 )$ , indicated by the solid black dot.

In the following sections, we briefly describe some of the theory and algorithms underlying constrained optimization. More details can be found in other books, such as [BV04; NW06; Ber15; Ber16].

# 8.5.1 Lagrange multipliers

In this section, we discuss how to solve equality contrained optimization problems. We initially assume that we have just one equality constraint, $h ( \pmb \theta ) = 0$ .

First note that for any point on the constraint surface, $\nabla h ( \pmb \theta )$ will be orthogonal to the constraint surface. To see why, consider another point nearby, $\theta + \epsilon$ , that also lies on the surface. If we make a first-order Taylor expansion around $\pmb \theta$ we have

$$
\begin{array} { r } { h ( \pmb { \theta } + \epsilon ) \approx h ( \pmb { \theta } ) + \epsilon ^ { \top } \nabla h ( \pmb { \theta } ) } \end{array}
$$

Since both $\pmb \theta$ and $\theta + \epsilon$ are on the constraint surface, we must have $h ( \pmb \theta ) = h ( \pmb \theta + \pmb \epsilon )$ and hence $\epsilon ^ { \mathsf { I } } \nabla h ( \pmb { \theta } ) \approx \mathrm { 0 }$ . Since $\epsilon$ is parallel to the constraint surface, $\nabla h ( \pmb \theta )$ must be perpendicular to it.

We seek a point $\pmb { \theta } ^ { * }$ on the constraint surface such that ${ \mathcal { L } } ( \theta )$ is minimized. We just showed that it must satisfy the condition that $\nabla h ( \theta ^ { * } )$ is orthogonal to the constraint surface. In addition, such a point must have the property that $\nabla { \mathcal { L } } ( \pmb \theta )$ is also orthogonal to the constraint surface, as otherwise we could decrease ${ \mathcal { L } } ( \theta )$ by moving a short distance along the constraint surface. Since both $\nabla h ( \pmb \theta )$ and $\nabla { \mathcal { L } } ( \theta )$ are orthogonal to the constraint surface at $\theta ^ { * }$ , they must be parallel (or anti-parallel) to each other. Hence there must exist a constant $\lambda ^ { \ast } \in \mathbb R$ such that

$$
\nabla \mathcal { L } ( \pmb { \theta } ^ { * } ) = \lambda ^ { * } \nabla h ( \pmb { \theta } ^ { * } )
$$

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

(We cannot just equate the gradient vectors, since they may have different magnitudes.) The constant $\lambda ^ { * }$ is called a Lagrange multiplier, and can be positive, negative, or zero. This latter case occurs when $\nabla { \mathcal { L } } ( \theta ^ { * } ) = 0$ .

We can convert Equation (8.89) into an objective, known as the Lagrangian, that we should find a stationary point of the following:

$$
L ( \pmb \theta , \lambda ) \triangleq \mathcal L ( \pmb \theta ) + \lambda h ( \pmb \theta )
$$

At a stationary point of the Lagrangian, we have

$$
\nabla _ { \pmb { \theta } , \lambda } L ( \pmb { \theta } , \lambda ) = \mathbf { 0 } \Longleftrightarrow \lambda \nabla _ { \pmb { \theta } } h ( \pmb { \theta } ) = \nabla \mathcal { L } ( \pmb { \theta } ) , h ( \pmb { \theta } ) = 0
$$

This is called a critical point, and satisfies the original constraint $h ( \pmb \theta ) = 0$ and Equation (8.89) If we have $m > 1$ constraints, we can form a new constraint function by addition, as follows:

$$
L ( \pmb \theta , \lambda ) = \mathcal L ( \pmb \theta ) + \sum _ { j = 1 } ^ { m } \lambda _ { j } h _ { j } ( \pmb \theta )
$$

We now have $D + m$ equations in $D + m$ unknowns and we can use standard unconstrained optimization methods to find a stationary point. We give some examples below.

# 8.5.1.1 Example: 2d Quadratic objective with one linear equality constraint

Consider minimizing ${ \mathcal L } ( \pmb { \theta } ) = { \theta } _ { 1 } ^ { 2 } + { \theta } _ { 2 } ^ { 2 }$ subject to the constraint that $\theta _ { 1 } + \theta _ { 2 } = 1$ . (This is the problem illustrated in Figure 8.20(a).) The Lagrangian is

$$
L ( \theta _ { 1 } , \theta _ { 2 } , \lambda ) = \theta _ { 1 } ^ { 2 } + \theta _ { 2 } ^ { 2 } + \lambda ( \theta _ { 1 } + \theta _ { 2 } - 1 )
$$

We have the following conditions for a stationary point:

$$
\begin{array} { l } { \displaystyle { \frac { \partial } { \partial \theta _ { 1 } } L ( \theta _ { 1 } , \theta _ { 2 } , \lambda ) = 2 \theta _ { 1 } + \lambda = 0 } } \\ { \displaystyle { \frac { \partial } { \partial \theta _ { 2 } } L ( \theta _ { 1 } , \theta _ { 2 } , \lambda ) = 2 \theta _ { 2 } + \lambda = 0 } } \\ { \displaystyle { \frac { \partial } { \partial \lambda } L ( \theta _ { 1 } , \theta _ { 2 } , \lambda ) = \theta _ { 1 } + \theta _ { 2 } - 1 = 0 } } \end{array}
$$

From Equations 8.94 and 8.95 we find $2 \theta _ { 1 } = - \lambda = 2 \theta _ { 2 }$ , so $\theta _ { 1 } = \theta _ { 2 }$ . Also, from Equation (8.96), we find $2 \theta _ { 1 } = 1$ . So $\pmb { \theta } ^ { * } = ( 0 . 5 , 0 . 5 )$ , as we claimed earlier. Furthermore, this is the global minimum since the objective is convex and the constraint is affine.

# 8.5.2 The KKT conditions

In this section, we generalize the concept of Lagrange multipliers to additionally handle inequality constraints.

First consider the case where we have a single inequality constraint $g ( \pmb \theta ) \le 0$ . To find the optimum, one approach would be to consider an unconstrained problem where we add the penalty as an infinite step function:

$$
\hat { \mathcal { L } } ( \pmb { \theta } ) = \mathcal { L } ( \pmb { \theta } ) + \infty \mathbb { I } \left( g ( \pmb { \theta } ) > 0 \right)
$$

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

However, this is a discontinuous function that is hard to optimize.

Instead, we create a lower bound of the form $\mu g ( \pmb \theta )$ , where $\mu \geq 0$ . This gives us the following Lagrangian:

$$
L ( \pmb \theta , \mu ) = \mathcal L ( \pmb \theta ) + \mu g ( \pmb \theta )
$$

Note that the step function can be recovered using

$$
\hat { \mathcal { L } } ( \pmb { \theta } ) = \operatorname* { m a x } _ { \mu \geq 0 } L ( \pmb { \theta } , \mu ) = \left\{ \begin{array} { l l } { \infty } & { \mathrm { i f ~ } g ( \pmb { \theta } ) > 0 , } \\ { \mathcal { L } ( \pmb { \theta } ) } & { \mathrm { o t h e r w i s e } } \end{array} \right.
$$

Thus our optimization problem becomes

$$
\operatorname* { m i n } _ { \pmb { \theta } } \operatorname* { m a x } _ { \mu \geq 0 } L ( \pmb { \theta } , \mu )
$$

Now consider the general case where we have multiple inequality constraints, $\mathbf { \delta } _ { g ( \pmb { \theta } ) } \le \mathbf { 0 }$ , and multiple equality constraints, $\mathbf { \delta } h ( \theta ) = \mathbf { 0 }$ . The generalized Lagrangian becomes

$$
L ( \theta , \pmb { \mu } , \lambda ) = \mathcal { L } ( \pmb { \theta } ) + \sum _ { i } \mu _ { i } g _ { i } ( \pmb { \theta } ) + \sum _ { j } \lambda _ { j } h _ { j } ( \pmb { \theta } )
$$

(We are free to change $- \lambda _ { j } h _ { j }$ to $+ \lambda _ { j } h _ { j }$ since the sign is arbitrary.) Our optimization problem becomes

$$
\operatorname* { m i n } _ { \pmb { \theta } } \operatorname* { m a x } _ { \pmb { \mu } \geq \mathbf { 0 } , \lambda } L ( \pmb { \theta } , \pmb { \mu } , \lambda )
$$

When $\mathcal { L }$ and $g$ are convex, then all critical points of this problem must satisfy the following criteria (under some conditions [BV04, Sec.5.2.3]):

All constraints are satisfied (this is called feasibility):

$$
{ \pmb g } ( \pmb \theta ) \le { \bf 0 } , \ h ( \pmb \theta ) = { \bf 0 }
$$

• The solution is a stationary point:

$$
\nabla \mathcal { L } ( \pmb \theta ^ { * } ) + \sum _ { i } \mu _ { i } \nabla g _ { i } ( \pmb \theta ^ { * } ) + \sum _ { j } \lambda _ { j } \nabla h _ { j } ( \pmb \theta ^ { * } ) = \mathbf 0
$$

• The penalty for the inequality constraint points in the right direction (this is called dual feasibility):

$$
{ \pmb \mu } \geq { \bf 0 }
$$

• The Lagrange multipliers pick up any slack in the inactive constraints, i.e., either $\mu _ { i } = 0$ or $g _ { i } ( \theta ^ { * } ) = 0$ , so

$$
\pmb { \mu } \odot \pmb { g } = \mathbf { 0 }
$$

This is called complementary slackness.

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

![](images/8a5402eb4907428050a77e6a552a8b1680209526eb1252e7e91c7ec8d39452f4.jpg)  
Figure 8.21: (a) A convex polytope in 2d defined by the intersection of linear constraints. (b) Depiction of the feasible set as well as the linear objective function. The red line is a level set of the objective, and the arrow indicates the direction in which it is improving. We see that the optimal solution lies at a vertex of the polytope.

To see why the last condition holds, consider (for simplicity) the case of a single inequality constraint, $g ( \pmb \theta ) \le 0$ . Either it is active, meaning $g ( \pmb \theta ) = 0$ , or it is inactive, meaning $g ( \pmb \theta ) < 0$ . In the active case, the solution lies on the constraint boundary, and $g ( \pmb \theta ) = 0$ becomes an equality constraint; then we have $\nabla { \mathcal { L } } = \mu \nabla g$ for some constant $\mu \neq 0$ , because of Equation (8.89). In the inactive case, the solution is not on the constraint boundary; we still have $\nabla { \mathcal { L } } = \mu \nabla g$ , but now µ = 0.

These are called called the Karush-Kuhn-Tucker (KKT) conditions. If $\mathcal { L }$ is a convex function, and the constraints define a convex set, the KKT conditions are sufficient for (global) optimality, as well as necessary.

# 8.5.3 Linear programming

Consider optimizing a linear function subject to linear constraints. When written in standard form, this can be represented as

$$
\operatorname* { m i n } _ { \pmb { \theta } } c ^ { \top } \pmb { \theta } \qquad \mathrm { s . t . } \ \ \mathbf { A } \pmb { \theta } \leq \pmb { b } , \ \pmb { \theta } \geq 0
$$

The feasible set defines a convex polytope, which is a convex set defined as the intersection of half spaces. See Figure 8.21(a) for a 2d example. Figure 8.21(b) shows a linear cost function that decreases as we move to the bottom right. We see that the lowest point that is in the feasible set is a vertex. In fact, it can be proved that the optimum point always occurs at a vertex of the polytope, assuming the solution is unique. If there are multiple solutions, the line will be parallel to a face. There may also be no optima inside the feasible set; in this case, the problem is said to be infeasible.

# 8.5.3.1 The simplex algorithm

It can be shown that the optima of an LP occur at vertices of the polytope defining the feasible set (see Figure 8.21(b) for an example). The simplex algorithm solves LPs by moving from vertex to vertex, each time seeking the edge which most improves the objective.

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

In the worst-case scenario, the simplex algorithm can take time exponential in $D$ , although in practice it is usually very efficient. There are also various polynomial-time algorithms, such as the interior point method, although these are often slower in practice.

# 8.5.3.2 Applications

There are many applications of linear programming in science, engineering and business. It is also useful in some machine learning problems. For example, Section 11.6.1.1 shows how to use it to solve robust linear regression. It is also useful for state estimation in graphical models (see e.g., [SGJ11]).

# 8.5.4 Quadratic programming

Consider minimizing a quadratic objective subject to linear equality and inequality constraints. This kind of problem is known as a quadratic program or $\mathbf { Q P }$ , and can be written as follows:

$$
\operatorname* { m i n } _ { \theta } \frac { 1 } { 2 } \theta ^ { \top } \mathbf H \theta + c ^ { \top } \theta \quad \mathrm { ~ s . t . ~ } \quad \mathbf A \theta \leq b , \mathbf C \theta = d
$$

If $\mathbf { H }$ is positive semidefinite, then this is a convex optimization problem.

# 8.5.4.1 Example: 2d quadratic objective with linear inequality constraints

As a concrete example, suppose we want to minimize

$$
{ \mathcal { L } } ( \theta ) = ( \theta _ { 1 } - { \frac { 3 } { 2 } } ) ^ { 2 } + ( \theta _ { 2 } - { \frac { 1 } { 8 } } ) ^ { 2 } = { \frac { 1 } { 2 } } \theta ^ { \mathsf { T } } \mathbf { H } \theta + c ^ { \mathsf { T } } \theta + { \mathrm { c o n s t } }
$$

where $\mathbf { H } = 2 \mathbf { I }$ and $\pmb { c } = - ( 3 , 1 / 4 )$ , subject to

$$
| \theta _ { 1 } | + | \theta _ { 2 } | \leq 1
$$

See Figure 8.20(b) for an illustration.

We can rewrite the constraints as

$$
\theta _ { 1 } + \theta _ { 2 } \leq 1 , \theta _ { 1 } - \theta _ { 2 } \leq 1 , - \theta _ { 1 } + \theta _ { 2 } \leq 1 , - \theta _ { 1 } - \theta _ { 2 } \leq 1
$$

which we can write more compactly as

$$
\mathbf { A } { \boldsymbol { \theta } } \leq { \boldsymbol { b } }
$$

where $\mathbf b = \mathbf 1$ and

$$
\mathbf { A } = { \left( \begin{array} { l l } { 1 } & { 1 } \\ { 1 } & { - 1 } \\ { - 1 } & { 1 } \\ { - 1 } & { - 1 } \end{array} \right) }
$$

This is now in the standard QP form.

From the geometry of the problem, shown in Figure 8.20(b), we see that the constraints corresponding to the two left faces of the diamond) are inactive (since we are trying to get as close to the

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022 center of the circle as possible, which is outside of, and to the right of, the constrained feasible region). Denoting $g _ { i } ( \pmb \theta )$ as the inequality constraint corresponding to row $i$ of $\mathbf { A }$ , this means $g _ { 3 } ( \theta ^ { * } ) > 0$ and $g _ { 4 } ( \pmb { \theta } ^ { * } ) > 0$ , and hence, by complementarity, $\mu _ { 3 } ^ { * } = \mu _ { 4 } ^ { * } = 0$ . We can therefore remove these inactive constraints.

From the KKT conditions we know that

$$
\mathbf { H } \pmb { \theta } + \pmb { c } + \mathbf { A } ^ { \top } \pmb { \mu } = \mathbf { 0 }
$$

Using these for the actively constrained subproblem, we get

$$
\begin{array} { r } { \left( \begin{array} { c c c c } { 2 } & { 0 } & { 1 } & { 1 } \\ { 0 } & { 2 } & { 1 } & { - 1 } \\ { 1 } & { 1 } & { 0 } & { 0 } \\ { 1 } & { - 1 } & { 0 } & { 0 } \end{array} \right) \ \left( \begin{array} { l } { \theta _ { 1 } } \\ { \theta _ { 2 } } \\ { \mu _ { 1 } } \\ { \mu _ { 2 } } \end{array} \right) = \left( \begin{array} { l } { 3 } \\ { 1 / 4 } \\ { 1 } \\ { 1 } \end{array} \right) } \end{array}
$$

Hence the solution is

$$
\pmb { \theta } _ { * } = ( 1 , 0 ) ^ { \mathsf { T } } , \pmb { \mu } _ { * } = ( 0 . 6 2 5 , 0 . 3 7 5 , 0 , 0 ) ^ { \mathsf { T } }
$$

Notice that the optimal value of $\pmb \theta$ occurs at one of the vertices of the $\ell _ { 1 }$ “ball” (the diamond shape).

# 8.5.4.2 Applications

There are several applications of quadratic programming in ML. For example, in Section 11.4, we discuss the lasso method for sparse linear regression, which amounts to optimizing ${ \mathcal { L } } ( w ) =$ $| | \mathbf { X } \pmb { w } - \pmb { y } | | _ { 2 } ^ { 2 } + \lambda | | \pmb { w } | | _ { 1 }$ , which can be reformulated into a QP. And in Section 17.3, we show how to use QP for SVMs (support vector machines).

# 8.5.5 Mixed integer linear programming \*

Integer linear programming or ILP corresponds to minimizing a linear objective, subject to linear constraints, where the optimization variables are discrete integers instead of reals. In standard form, the problem is as follows:

$$
\operatorname* { m i n } _ { \theta } c ^ { \mathsf { T } } \theta \qquad \mathrm { s . t . } \quad \mathbf { A } \theta \leq b , \ \theta \geq 0 , \theta \in \mathbb { Z } ^ { D }
$$

where $\mathbb { Z }$ is the set of integers. If some of the optimization variables are real-valued, it is called a mixed ILP, often called a MIP for short. (If all of the variables are real-valued, it becomes a standard LP.)

MIPs have a large number of applications, such as in vehicle routing, scheduling and packing. They are also useful for some ML applications, such as formally verifying the behavior of certain kinds of deep neural networks [And+18], and proving robustness properties of DNNs to adversarial (worst-case) perturbations [TXT19].

# 8.6 Proximal gradient method \*

We are often interested in optimizing an objective of the form

$$
\mathcal { L } ( \pmb \theta ) = \mathcal { L } _ { s } ( \pmb \theta ) + \mathcal { L } _ { r } ( \pmb \theta )
$$

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license where $\mathcal { L } _ { s }$ is differentiable (smooth), and $\mathcal { L } _ { r }$ is convex but not necessarily differentiable (i.e., it may be non-smooth or “rough”). For example, $\mathcal { L } _ { s }$ might be the negative log likelihood (NLL), and $\mathcal { L } _ { r }$ might be an indicator function that is infinite if a constraint is violated (see Section 8.6.1), or $\mathcal { L } _ { r }$ might be the $\ell _ { 1 }$ norm of some parameters (see Section 8.6.2), or $\mathcal { L } _ { r }$ might measure how far the parameters are from a set of allowed quantized values (see Section 8.6.3).

One way to tackle such problems is to use the proximal gradient method (see e.g., [PB+14; PSW15]). Roughly speaking, this takes a step of size $\eta$ in the direction of the gradient, and then projects the resulting parameter update into a space that respects $\mathcal { L } _ { r }$ . More precisely, the update is as follows

$$
\pmb { \theta } _ { t + 1 } = \mathrm { p r o x } _ { \eta _ { t } \mathcal { L } _ { r } } \big ( \pmb { \theta } _ { t } - \eta _ { t } \nabla \mathcal { L } _ { s } ( \pmb { \theta } _ { t } ) \big )
$$

where $\mathrm { p r o x } _ { \eta f } ( \pmb { \theta } )$ is the proximal operator of $\mathcal { L } _ { r }$ (scaled by $\eta$ ) evaluated at $\pmb \theta$ :

$$
\mathrm { p r o x } _ { \eta \mathcal { L } _ { r } } ( \pmb { \theta } ) \triangleq \underset { \pmb { z } } { \mathrm { a r g m i n } } \left( \mathcal { L } _ { r } ( \pmb { z } ) + \frac { 1 } { 2 \eta } | | \pmb { z } - \pmb { \theta } | | _ { 2 } ^ { 2 } \right)
$$

(The factor of $\textstyle { \frac { 1 } { 2 } }$ is an arbitrary convention.) We can rewrite the proximal operator as solving a constrained opimtization problem, as follows:

$$
\operatorname { p r o x } _ { \eta \mathcal { L } _ { r } } ( \pmb \theta ) = \underset { \pmb z } { \operatorname { a r g m i n } } \mathcal { L } _ { r } ( \pmb z ) \mathrm { s . t . } | | \pmb z - \pmb \theta | | _ { 2 } \leq \rho
$$

where the bound $\rho$ depends on the scaling factor $\eta$ . Thus we see that the proximal projection minimizes the function while staying close to (i.e., proximal to) the current iterate. We give some examples below.

# 8.6.1 Projected gradient descent

Suppose we want to solve the problem

$$
\underset { \pmb { \theta } } { \mathrm { a r g m i n } } \mathcal { L } _ { s } ( \pmb { \theta } ) \mathrm { s . t . } \pmb { \theta } \in \mathcal { C }
$$

where $\boldsymbol { \mathcal { C } }$ is a convex set. For example, we may have the box constraints $\mathcal { C } = \{ \pmb \theta : l \leq \pmb \theta \leq \pmb u \}$ , where we specify lower and upper bounds on each element. These bounds can be infinite for certain elements if we don’t want to constrain values along that dimension. For example, if we just want to ensure the parameters are non-negative, we set $l _ { d } = 0$ and $u _ { d } = \infty$ for each dimension $d$ .

We can convert the constrained optimization problem into an unconstrained one by adding a penalty term to the original objective:

$$
\mathcal { L } ( \pmb \theta ) = \mathcal { L } _ { s } ( \pmb \theta ) + \mathcal { L } _ { r } ( \pmb \theta )
$$

where $\mathcal { L } _ { r } ( \pmb { \theta } )$ is the indicator function for the convex set $\boldsymbol { \mathcal { C } }$ , i.e.,

$$
{ \mathcal { L } } _ { r } ( \theta ) = I _ { \mathcal { C } } ( \theta ) = { \left\{ \begin{array} { l l } { 0 } & { { \mathrm { i f ~ } } \theta \in { \mathcal { C } } } \\ { \infty } & { { \mathrm { i f ~ } } \theta \not \in { \mathcal { C } } } \end{array} \right. }
$$

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

![](images/db3ff22ddfc3056088ad8e62bb2f21b452d950ca6dbac876d2bed496529755a7.jpg)  
Figure 8.22: Illustration of projected gradient descent. w is the current parameter estimate, $\mathbf { \Delta } w ^ { \prime }$ is the update after a gradient step, and $P _ { C } ( { \boldsymbol { w } } ^ { \prime } )$ projects this onto the constraint set $\boldsymbol { \mathscr { C } }$ . From https: // bit. ly/ 3eJ3BhZ Used with kind permission of Martin Jaggi.

We can use proximal gradient descent to solve Equation (8.123). The proximal operator for the indicator function is equivalent to projection onto the set $\boldsymbol { \mathscr { C } }$ :

$$
\operatorname { p r o j } _ { \mathscr { C } } ( \pmb \theta ) = \underset { \pmb { \theta } ^ { \prime } \in \mathscr { C } } { \operatorname { a r g m i n } } | | \pmb \theta ^ { \prime } - \pmb \theta | | _ { 2 }
$$

This method is known as projected gradient descent. See Figure 8.22 for an illustration.

For example, consider the box constraints $\mathcal { C } = \{ \pmb \theta : l \leq \pmb \theta \leq \pmb u \}$ . The projection operator in this case can be computed elementwise by simply thresholding at the boundaries:

$$
\mathrm { p r o j } _ { \mathscr { C } } ( \pmb { \theta } ) _ { d } = \left\{ \begin{array} { l l } { l _ { d } } & { \mathrm { i f ~ } \theta _ { d } \leq l _ { d } } \\ { \theta _ { d } } & { \mathrm { i f ~ } l _ { d } \leq \theta _ { d } \leq u _ { d } } \\ { u _ { d } } & { \mathrm { i f ~ } \theta _ { d } \geq u _ { d } } \end{array} \right.
$$

For example, if we want to ensure all elements are non-negative, we can use

$$
\operatorname { p r o j } _ { \mathcal { C } } ( \pmb { \theta } ) = \pmb { \theta } _ { + } = [ \operatorname* { m a x } ( \theta _ { 1 } , 0 ) , \dots , \operatorname* { m a x } ( \theta _ { D } , 0 ) ]
$$

See Section 11.4.9.2 for an application of this method to sparse linear regression.

# 8.6.2 Proximal operator for $\ell _ { 1 }$ -norm regularizer

Consider a linear predictor of the form $\textstyle f ( \pmb { x } ; \pmb { \theta } ) = \sum _ { d = 1 } ^ { D } \theta _ { d } x _ { d }$ . If we have $\theta _ { d } = 0$ for any dimension $d$ , we ignore the corresponding feature $x _ { d }$ . This is a form of feature selection, which can be useful both as a way to reduce overfitting as well as way to improve model interpretability. We can encourage weights to be zero (and not just small) by penalizing the $\ell _ { 1 }$ norm,

$$
| | \pmb \theta | | _ { 1 } = \sum _ { d = 1 } ^ { D } | \theta _ { d } |
$$

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

This is called a sparsity inducing regularizer.

To see why this induces sparsity, consider two possible parameter vectors, one which is sparse, $\pmb { \theta } = ( 1 , 0 )$ , and one which is non-sparse, $\pmb { \theta } ^ { \prime } = ( 1 / \sqrt { 2 } , 1 / \sqrt { 2 } )$ . Both have the same $\ell _ { 2 }$ norm

$$
| | ( 1 , 0 ) | | _ { 2 } ^ { 2 } = | | ( 1 / \sqrt { 2 } , 1 / \sqrt { 2 } ) | | _ { 2 } ^ { 2 } = 1
$$

Hence $\ell _ { 2 }$ regularization (Section 4.5.3) will not favor the sparse solution over the dense solution. However, when using $\ell _ { 1 }$ regularization, the sparse solution is cheaper, since

$$
| | ( 1 , 0 ) | | _ { 1 } = 1 < | | ( 1 / \sqrt { 2 } , 1 / \sqrt { 2 } ) | | _ { 1 } = \sqrt { 2 }
$$

See Section 11.4 for more details on sparse regression.

If we combine this regularizer with our smooth loss, we get

$$
\begin{array} { r } { \mathcal { L } ( \pmb { \theta } ) = \mathrm { N L L } ( \pmb { \theta } ) + \lambda | | \pmb { \theta } | | _ { 1 } } \end{array}
$$

We can optimize this objective using proximal gradient descent. The key question is how to compute the prox operator for the function $f ( \pmb \theta ) = | | \pmb \theta | | _ { 1 }$ . Since this function decomposes over dimensions $d$ , the proximal projection can be computed componentwise. From Equation (8.120), with $\eta = 1$ , we have

$$
\operatorname { p r o x } _ { \lambda f } ( \theta ) = \operatorname { a r g m i n } _ { z } | z | + { \frac { 1 } { 2 \lambda } } ( z - \theta ) ^ { 2 } = \operatorname { a r g m i n } _ { z } \lambda | z | + { \frac { 1 } { 2 } } ( z - \theta ) ^ { 2 }
$$

In Section 11.4.3, we show that the solution to this is given by

$$
\operatorname { p r o x } _ { \lambda f } ( \theta ) = { \left\{ \begin{array} { l l } { \theta - \lambda } & { { \mathrm { i f ~ } } \theta \geq \lambda } \\ { 0 } & { { \mathrm { i f ~ } } \vert \theta \vert \leq \lambda } \\ { \theta + \lambda } & { { \mathrm { i f ~ } } \theta \leq - \lambda } \end{array} \right. }
$$

This is known as the soft thresholding operator, since values less than $\lambda$ in absolute value are set to 0 (thresholded), but in a continuous way. Note that soft thresholding can be written more compactly as

$$
\operatorname { S o f t T h r e s h o l d } ( \theta , \lambda ) = \operatorname { s i g n } ( \theta ) \left( \left| \theta \right| - \lambda \right) _ { + }
$$

where $\theta _ { + } = \operatorname* { m a x } ( \theta , 0 )$ is the positive part of $\theta$ . In the vector case, we perform this elementwise:

$$
{ \mathrm { S o f t T h r e s h o l d } } ( \pmb { \theta } , \lambda ) = \mathrm { s i g n } ( \pmb { \theta } ) \odot ( | \pmb { \theta } | - \lambda ) _ { + }
$$

See Section 11.4.9.3 for an application of this method to sparse linear regression.

# 8.6.3 Proximal operator for quantization

In some applications (e.g., when training deep neural networks to run on memory-limited edge devices, such as mobile phones) we want to ensure that the parameters are quantized. For example, in the extreme case where each parameter can only be -1 or $+ 1$ , the state space becomes $\mathcal { C } = \{ - 1 , + 1 \} ^ { D }$ .

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

Let us define a regularizer that measures distance to the nearest quantized version of the parameter vector:

$$
\mathcal { L } _ { r } ( \pmb { \theta } ) = \operatorname* { i n f } _ { \pmb { \theta } _ { 0 } \in \mathcal { C } } | | \pmb { \theta } - \pmb { \theta } _ { 0 } | | _ { 1 }
$$

(We could also use the $\ell _ { 2 }$ norm.) In the case of $\mathcal { C } = \{ - 1 , + 1 \} ^ { D }$ , this becomes

$$
\mathcal { L } _ { r } ( \pmb { \theta } ) = \sum _ { d = 1 } ^ { D } \operatorname* { i n f } _ { [ \theta _ { 0 } ] _ { d } \in \{ \pm 1 \} } | \theta _ { d } - [ \theta _ { 0 } ] _ { d } | = \sum _ { d = 1 } ^ { D } \operatorname* { m i n } \{ | \theta _ { d } - 1 | , | \theta _ { d } + 1 | \} = | | \pmb { \theta } - \mathrm { s i g n } ( \theta _ { d } - \theta _ { d } ) | | .
$$

Let us define the corresponding quantization operator to be

$$
q ( \pmb \theta ) = \mathrm { p r o j } _ { \mathcal { C } } ( \pmb \theta ) = \mathrm { a r g m i n } \mathcal { L } _ { r } ( \pmb \theta ) = \mathrm { s i g n } ( \pmb \theta )
$$

The core difficulty with quantized learning is that quantization is not a differentiable operation. A popular solution to this is to use the straight-through estimator, which uses the approximation $\begin{array} { r } { \frac { \partial \mathcal { L } } { \partial q ( \theta ) } \approx \frac { \partial \mathcal { L } } { \partial \theta } } \end{array}$ (see e.g., [Yin+19]). The corresponding update can be done in two steps: first compute the gradient vector at the quantized version of the current parameters, and then update the unconstrained parameters using this approximate gradient:

$$
\begin{array} { r } { \tilde { { \pmb \theta } } _ { t } = \mathrm { p r o j } _ { \mathcal { C } } ( { \pmb \theta } _ { t } ) = q ( { \pmb \theta } _ { t } ) } \\ { { \pmb \theta } _ { t + 1 } = { \pmb \theta } _ { t } - \eta _ { t } \nabla { \mathcal { L } } _ { s } ( \tilde { { \pmb \theta } } _ { t } ) } \end{array}
$$

When applied to $\mathcal { C } = \{ - 1 , + 1 \} ^ { D }$ , this is known as the binary connect method [CBD15].

We can get better results using proximal gradient descent, in which we treat quantization as a regularizer, rather than a hard constraint; this is known as ProxQuant [BWL19]. The update becomes

$$
\begin{array} { r } { \tilde { \pmb { \theta } } _ { t } = \mathrm { p r o x } _ { \lambda \mathcal { L } _ { r } } \left( \pmb { \theta } _ { t } - \eta _ { t } \nabla \mathcal { L } _ { s } ( \pmb { \theta } _ { t } ) \right) } \end{array}
$$

In the case that $\mathcal { C } = \{ - 1 , + 1 \} ^ { D }$ , one can show that the proximal operator is a generalization of the soft thresholding operator in Equation (8.135):

$$
\begin{array} { r l } & { \mathrm { p r o x } _ { \lambda \mathcal { L } _ { r } } ( \pmb { \theta } ) = \mathrm { S o f t T h r e s h o l d } ( \pmb { \theta } , \lambda , \mathrm { s i g n } ( \pmb { \theta } ) ) } \\ & { \quad \quad \quad = \mathrm { s i g n } ( \pmb { \theta } ) + \mathrm { s i g n } ( \pmb { \theta } - \mathrm { s i g n } ( \pmb { \theta } ) ) \odot ( | \pmb { \theta } - \mathrm { s i g n } ( \pmb { \theta } ) | - \lambda ) _ { + } } \end{array}
$$

This can be generalized to other forms of quantization; see [Yin+19] for details.

# 8.6.4 Incremental (online) proximal methods

Many ML problems have an objective function which is a sum of losses, one per example. Such problems can be solved incrementally; this is a special case of online learning. It is possible to extend proximal methods to this setting. For a probabilistic perspective on such methods (in terms of Kalman filtering), see [AEM18; Aky+19].

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

# 8.7 Bound optimization \*

In this section, we consider a class of algorithms known as bound optimization or MM algorithms. In the context of minimization, MM stands for majorize-minimize. In the context of maximization, MM stands for minorize-maximize. We will discuss a special case of MM, known as expectation maximization or EM, in Section 8.7.2.

# 8.7.1 The general algorithm

In this section, we give a brief outline of MM methods. (More details can be found in e.g., [HL04; Mai15; SBP17; Nad+19].) To be consistent with the literature, we assume our goal is to maximize some function $\ell ( \pmb \theta )$ , such as the log likelihood, wrt its parameters $\pmb \theta$ . The basic approach in MM algorithms is to construct a surrogate function $Q ( \pmb \theta , \pmb \theta ^ { t } )$ which is a tight lowerbound to $\ell ( \pmb \theta )$ such that $Q ( \pmb \theta , \pmb \theta ^ { t } ) \leq \ell ( \pmb \theta )$ and $Q ( \pmb \theta ^ { t } , \pmb \theta ^ { t } ) = \ell ( \pmb \theta ^ { t } )$ . If these conditions are met, we say that $Q$ minorizes $\ell$ . We then perform the following update at each step:

$$
\pmb { \theta } ^ { t + 1 } = \operatorname * { a r g m a x } _ { \pmb { \theta } } Q ( \pmb { \theta } , \pmb { \theta } ^ { t } )
$$

This guarantees us monotonic increases in the original objective:

$$
\ell ( \pmb \theta ^ { t + 1 } ) \geq Q ( \pmb \theta ^ { t + 1 } , \pmb \theta ^ { t } ) \geq Q ( \pmb \theta ^ { t } , \pmb \theta ^ { t } ) = \ell ( \pmb \theta ^ { t } )
$$

where the first inequality follows since $Q ( \pmb \theta ^ { t + 1 } , \pmb \theta ^ { \prime } )$ is a lower bound on $\ell ( \pmb { \theta } ^ { t + 1 } )$ for any $\pmb { \theta } ^ { \prime }$ ; the second inequality follows from Equation (8.144); and the final equality follows the tightness property. As a consequence of this result, if you do not observe monotonic increase of the objective, you must have an error in your math and/or code. This is a surprisingly powerful debugging tool.

This process is sketched in Figure 8.23. The dashed red curve is the original function (e.g., the log-likelihood of the observed data). The solid blue curve is the lower bound, evaluated at $\pmb { \theta } ^ { t }$ ; this touches the objective function at $\pmb { \theta } ^ { t }$ . We then set $\pmb { \theta } ^ { t + 1 }$ to the maximum of the lower bound (blue curve), and fit a new bound at that point (dotted green curve). The maximum of this new bound becomes $\pmb { \theta } ^ { t + 2 }$ , etc.

If $Q$ is a quadratic lower bound, the overall method is similar to Newton’s method, which repeatedly fits and then optimizes a quadratic approximation, as shown in Figure 8.14(a). The difference is that optimizing $Q$ is guaranteed to lead to an improvement in the objective, even if it is not convex, whereas Newton’s method may overshoot or lead to a decrease in the objective, as shown in Figure 8.24, since it is a quadratic approximation and not a bound.

# 8.7.2 The EM algorithm

In this section, we discuss the expectation maximization (EM) algorithm [DLR77; MK97], which is a bound optimization algorithm designed to compute the MLE or MAP parameter estimate for probability models that have missing data and/or hidden variables. We let ${ \bf { y } } _ { n }$ be the visible data for example $n$ , and $z _ { n }$ be the hidden data.

The basic idea behind EM is to alternate between estimating the hidden variables (or missing values) during the $\mathbf { E }$ step (expectation step), and then using the fully observed data to compute the MLE during the M step (maximization step). Of course, we need to iterate this process, since the expected values depend on the parameters, but the parameters depend on the expected values.

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

![](images/c23b98256b4b01fd804e85e6f405395464910c415d235090ab1760edece1ac64.jpg)  
Figure 8.23: Illustration of a bound optimization algorithm. Adapted from Figure 9.14 of [Bis06]. Generated by emLogLikelihoodMax.ipynb.

![](images/5b761f249a87b00c20410310a2f2cc894c9abc364980ee01e33c9ba472ea365e.jpg)  
Figure 8.24: The quadratic lower bound of an MM algorithm (solid) and the quadratic approximation of Newton’s method (dashed) superimposed on an empirical density esitmate (dotted). The starting point of both algorithms is the circle. The square denotes the outcome of one MM update. The diamond denotes the outcome of one Newton update. (a) Newton’s method overshoots the global maximum. (b) Newton’s method results in a reduction of the objective. From Figure 4 of [FT05]. Used with kind permission of Carlo Tomasi.

In Section 8.7.2.1, we show that EM is an MM algorithm, which implies that this iterative procedure will converge to a local maximum of the log likelihood. The speed of convergence depends on the amount of missing data, which affects the tightness of the bound [XJ96; MD97; SRG03; KKS20].

# 8.7.2.1 Lower bound

The goal of EM is to maximize the log likelihood of the observed data:

$$
\ell ( \pmb { \theta } ) = \sum _ { n = 1 } ^ { N _ { \mathscr { D } } } \log p ( \pmb { y } _ { n } | \pmb { \theta } ) = \sum _ { n = 1 } ^ { N _ { \mathscr { D } } } \log \left[ \sum _ { z _ { n } } p ( \pmb { y } _ { n } , z _ { n } | \pmb { \theta } ) \right]
$$

where ${ \bf { y } } _ { n }$ are the visible variables and $z _ { n }$ are the hidden variables. Unfortunately this is hard to optimize, since the log cannot be pushed inside the sum.

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

EM gets around this problem as follows. First, consider a set of arbitrary distributions $q _ { n } ( z _ { n } )$ over each hidden variable $z _ { n }$ . The observed data log likelihood can be written as follows:

$$
\ell ( \pmb \theta ) = \sum _ { n = 1 } ^ { N _ { D } } \log \left[ \sum _ { z _ { n } } q _ { n } ( z _ { n } ) \frac { p ( \pmb y _ { n } , z _ { n } | \pmb \theta ) } { q _ { n } ( z _ { n } ) } \right]
$$

Using Jensen’s inequality (Equation (6.34)), we can push the log (which is a concave function) inside the expectation to get the following lower bound on the log likelihood:

$$
\begin{array} { r l } { \ell ( \pmb \theta ) \geq \displaystyle \sum _ { n } \sum _ { z _ { n } } q _ { n } ( z _ { n } ) \log \frac { p ( y _ { n } , z _ { n } | \pmb \theta ) } { q _ { n } ( z _ { n } ) } \ ~ } & { } \\ { = \displaystyle \sum _ { n } \underbrace { { \mathbb E } _ { q _ { n } } \left[ \log p ( y _ { n } , z _ { n } | \pmb \theta ) \right] + { \mathbb H } ( q _ { n } ) } _ { { \mathbf L } ( \pmb \theta , q _ { n } ) } \ ~ } & { } \\ { = \displaystyle \sum _ { n } { \mathbf L } ( \pmb \theta , q _ { n } ) \triangleq { \mathbf L } ( \pmb \theta , \{ q _ { n } \} ) = { \mathbf L } ( \pmb \theta , q _ { 1 : N } ) } \end{array}
$$

where $\mathbb { H } ( q )$ is the entropy of probability distribution $q$ , and ${ \mathrm { { L } } } ( \theta , \{ q _ { n } \} )$ is called the evidence lower bound or ELBO, since it is a lower bound on the log marginal likelihood, $\log p ( { \pmb y } _ { 1 : N } | \pmb \theta )$ , also called the evidence. Optimizing this bound is the basis of variational inference, which we discuss in Section 4.6.8.3.

# 8.7.2.2 E step

We see that the lower bound is a sum of $N$ terms, each of which has the following form:

$$
\begin{array} { l } { \displaystyle \mathbb { E } ( \theta , q _ { n } ) = \sum _ { z _ { n } } q _ { n } ( z _ { n } ) \log \frac { p ( y _ { n } , z _ { n } | \theta ) } { q _ { n } ( z _ { n } ) } } \\ { \displaystyle = \sum _ { z _ { n } } q _ { n } ( z _ { n } ) \log \frac { p ( z _ { n } | y _ { n } , \theta ) p ( y _ { n } | \theta ) } { q _ { n } ( z _ { n } ) } } \\ { \displaystyle = \sum _ { z _ { n } } q _ { n } ( z _ { n } ) \log \frac { p ( z _ { n } | y _ { n } , \theta ) } { q _ { n } ( z _ { n } ) } + \sum _ { z _ { n } } q _ { n } ( z _ { n } ) \log p ( y _ { n } | \theta ) } \\ { \displaystyle = - D _ { \mathbb { E } \mathbb { L } } ( q _ { n } ( z _ { n } )  p ( z _ { n } | y _ { n } , \theta ) ) + \log p ( y _ { n } | \theta ) } \end{array}
$$

bwehtewre $\begin{array} { r } { D _ { \mathbb { K L } } \left( q \parallel p \right) \triangleq \sum _ { z } q ( z ) \log \frac { q ( z ) } { p ( z ) } } \end{array}$ nisd . WKeulldbisacuks-sLteihbisleirndimvoeregednecteai(loirnKSeLctdiiovner6g.e2n,cbeuftorthsehokrety) $q$ $p$   
property we need here is that $D _ { \mathbb { K L } } \left( q \parallel p \right) \geq 0$ and $D _ { \mathbb { K L } } \left( q \parallel p \right) = 0$ iff $q = p$ . Hence we can maximize   
the lower bound $\mathbb { L } ( \pmb { \theta } , \{ q _ { n } \} )$ wrt $\left\{ q _ { n } \right\}$ by setting each one to $q _ { n } ^ { * } = p ( z _ { n } | \pmb { y } _ { n } , \pmb { \theta } )$ . This is called the $\mathbf { E }$   
step. This ensures the ELBO is a tight lower bound:

$$
\operatorname { L } ( \pmb \theta , \{ q _ { n } ^ { * } \} ) = \sum _ { n } \log p ( \pmb y _ { n } | \pmb \theta ) = \ell ( \pmb \theta )
$$

To see how this connects to bound optimization, let us define

$$
Q ( \pmb \theta , \pmb \theta ^ { t } ) = \mathrm { L } ( \pmb \theta , \{ p ( z _ { n } | \pmb y _ { n } ; \pmb \theta ^ { t } ) \} )
$$

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

Then we have $Q ( \pmb \theta , \pmb \theta ^ { t } ) \leq \ell ( \pmb \theta )$ and $Q ( \pmb \theta ^ { t } , \pmb \theta ^ { t } ) = \ell ( \pmb \theta ^ { t } )$ , as required.

However, if we cannot compute the posteriors $p ( z _ { n } | \pmb { y } _ { n } ; \pmb { \theta } ^ { t } )$ exactly, we can still use an approximate distribution $q ( z _ { n } | \pmb { y } _ { n } ; \pmb { \theta } ^ { t } )$ ; this will yield a non-tight lower-bound on the log-likelihood. This generalized version of EM is known as variational EM [NH98]. See the sequel to this book, [Mur23], for details.

# 8.7.2.3 M step

In the M step, we need to maximize $\mathbb { E } ( \pmb { \theta } , \{ q _ { n } ^ { t } \} )$ wrt $\pmb \theta$ , where the $q _ { n } ^ { t }$ are the distributions computed in the $\mathrm { E }$ step at iteration $t$ . Since the entropy terms $\mathbb { H } ( q _ { n } )$ are constant wrt $\pmb \theta$ , so we can drop them in the M step. We are left with

$$
\ell ^ { t } ( \pmb \theta ) = \sum _ { n } \mathbb { E } _ { q _ { n } ^ { t } ( z _ { n } ) } \left[ \log p ( \pmb y _ { n } , z _ { n } | \pmb \theta ) \right]
$$

This is called the expected complete data log likelihood. If the joint probability is in the exponential family (Section 3.4), we can rewrite this as

$$
\ell ^ { t } ( \pmb \theta ) = \sum _ { n } \mathbb { E } \left[ \mathcal { T } ( \pmb y _ { n } , z _ { n } ) ^ { \top } \pmb \theta - A ( \pmb \theta ) \right] = \sum _ { n } ( \mathbb { E } \left[ \mathcal { T } ( \pmb y _ { n } , z _ { n } ) \right] ^ { \top } \pmb \theta - A ( \pmb \theta ) )
$$

where $\mathbb { E } \left[ \mathcal { T } ( \pmb { y } _ { n } , \pmb { z } _ { n } ) \right]$ are called the expected sufficient statistics.

In the M step, we maximize the expected complete data log likelihood to ge

$$
\pmb { \theta } ^ { t + 1 } = \arg \operatorname* { m a x } _ { \pmb { \theta } } \sum _ { n } \mathbb { E } _ { q _ { n } ^ { t } } \left[ \log p ( \pmb { y } _ { n } , z _ { n } | \pmb { \theta } ) \right]
$$

In the case of the exponential family, the maximization can be solved in closed-form by matching the moments of the expected sufficient statistics.

We see from the above that the E step does not in fact need to return the full set of posterior distributions $\{ q ( z _ { n } ) \}$ , but can instead just return the sum of the expected sufficient statistics, $\begin{array} { r l } { \sum _ { n } \mathbb { E } _ { q ( \pmb { z } _ { n } ) } \left[ \mathcal { T } \left( \pmb { y } _ { n } , \pmb { z } _ { n } \right) \right] } & { { } } \end{array}$ . This will become clearer in the examples below.

# 8.7.3 Example: EM for a GMM

In this section, we show how to use the EM algorithm to compute MLE and MAP estimates of the parameters for a Gaussian mixture model (GMM).

# 8.7.3.1 E step

The $\mathrm { E }$ step simply computes the responsibility of cluster $k$ for generating data point $n$ , as estimated using the current parameter estimates ${ \pmb \theta } ^ { ( t ) }$ :

$$
r _ { n k } ^ { ( t ) } = p ^ { * } ( z _ { n } = k | \pmb { y } _ { n } , \pmb { \theta } ^ { ( t ) } ) = \frac { \pi _ { k } ^ { ( t ) } p ( \pmb { y } _ { n } | \pmb { \theta } _ { k } ^ { ( t ) } ) } { \sum _ { k ^ { \prime } } \pi _ { k ^ { \prime } } ^ { ( t ) } p ( \pmb { y } _ { n } | \pmb { \theta } _ { k ^ { \prime } } ^ { ( t ) } ) }
$$

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

# 8.7.3.2 M step

The M step maximizes the expected complete data log likelihood, given by

$$
\begin{array} { l } { { \displaystyle \ell ^ { t } ( \theta ) = \mathbb { E } \left[ \sum _ { n } \log p ( z _ { n } | \pi ) + \log p ( y _ { n } | z _ { n } , \theta ) \right] } \ ~ } \\ { { \displaystyle ~ = \mathbb { E } \left[ \sum _ { n } \log \left( \prod _ { k } \pi _ { k } ^ { z _ { n k } } \right) + \log \left( \prod _ { k } \mathcal { N } ( y _ { n } | \mu _ { k } , \Sigma _ { k } ) ^ { z _ { n k } } \right) \right] } \ ~ } \\ { { \displaystyle ~ = \sum _ { n } \sum _ { k } \mathbb { E } \left[ z _ { n k } \right] \log \pi _ { k } + \sum _ { n } \sum _ { k } \mathbb { E } \left[ z _ { n k } \right] \log \mathcal { N } ( y _ { n } | \mu _ { k } , \Sigma _ { k } ) } \ ~ } \\ { { \displaystyle ~ = \sum _ { n } \sum _ { k } r _ { n k } ^ { ( t ) } \log ( \pi _ { k } ) - \frac { 1 } { 2 } \sum _ { n } \sum _ { k } r _ { n k } ^ { ( t ) } \left[ \log | \Sigma _ { k } | + ( y _ { n } - \mu _ { k } ) ^ { \top } \Sigma _ { k } ^ { - 1 } ( y _ { n } - \mu _ { k } ) \right] } \ ~ , } \end{array}
$$

where $z _ { n k } = \mathbb { I } \left( z _ { n } = k \right)$ is a one-hot encoding of the categorical value $z _ { n }$ . This objective is just a weighted version of the standard problem of computing the MLEs of an MVN (see Section 4.2.6). One can show that the new parameter estimates are given by

$$
\begin{array} { c } { \displaystyle \mu _ { k } ^ { ( t + 1 ) } = \frac { \sum _ { n } r _ { n k } ^ { ( t ) } y _ { n } } { r _ { k } ^ { ( t ) } } } \\ { \displaystyle \Sigma _ { k } ^ { ( t + 1 ) } = \frac { \sum _ { n } r _ { n k } ^ { ( t ) } ( y _ { n } - \mu _ { k } ^ { ( t + 1 ) } ) ( y _ { n } - \mu _ { k } ^ { ( t + 1 ) } ) ^ { \top } } { r _ { k } ^ { ( t ) } } } \\ { \displaystyle = \frac { \sum _ { n } r _ { n k } ^ { ( t ) } y _ { n } y _ { n } ^ { \top } } { r _ { k } ^ { ( t ) } } - \mu _ { k } ^ { ( t + 1 ) } ( \mu _ { k } ^ { ( t + 1 ) } ) ^ { \top } } \end{array}
$$

jwuhsterteh $\begin{array} { r } { \boldsymbol { r } _ { k } ^ { ( t ) } \triangleq \sum _ { n } \boldsymbol { r } _ { n k } ^ { ( t ) } } \end{array}$ erisagteheofwaelilgphtoeindtsnuasmsibgenreodf tpo icnltus taesrs ,naenddtothcelucsotvear $k$ a.ncTehiesmpreoapnoorft colnuasltetro $k$ hies $k$   
weighted empirical scatter matrix.

The M step for the mixture weights is simply a weighted form of the usual MLE:

$$
\pi _ { k } ^ { ( t + 1 ) } = \frac { 1 } { N } \sum _ { n } r _ { n k } ^ { ( t ) } = \frac { r _ { k } ^ { ( t ) } } { N }
$$

# 8.7.3.3 Example

An example of the algorithm in action is shown in Figure 8.25 where we fit some 2d data with a 2 component GMM. The data set, from [Bis06], is derived from measurements of the Old Faithful geyser in Yellowstone National Park. In particular, we plot the time to next eruption in minutes versus the duration of the eruption in minutes. The data was standardized, by removing the mean and dividing by the standard deviation, before processing; this often helps convergence. We start with $\pmb { \mu } _ { 1 } = ( - 1 , 1 )$ , $\boldsymbol { \Sigma } _ { 1 } = \mathbf { I }$ , $\mu _ { 2 } = ( 1 , - 1 )$ , $\Sigma _ { 2 } = \mathbf { I }$ . We then show the cluster assignments, and corresponding mixture components, at various iterations.

For more details on applying GMMs for clustering, see Section 21.4.1.

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

![](images/2c80fb71a3bf279b67d20edbfd46e90ae99e5656397989eb9a7942fe837fd87e.jpg)  
Figure 8.25: Illustration of the EM for a GMM applied to the Old Faithful data. The degree of redness indicates the degree to which the point belongs to the red cluster, and similarly for blue; thus purple points have a roughly 50/50 split in their responsibilities to the two clusters. Adapted from [Bis06] Figure 9.8. Generated by mix_gauss_demo_faithful.ipynb.

# 8.7.3.4 MAP estimation

Computing the MLE of a GMM often suffers from numerical problems and overfitting. To see why, suppose for simplicity that $\boldsymbol { \Sigma } _ { k } = \sigma _ { k } ^ { 2 } \mathbf { I }$ for all $k$ . It is possible to get an infinite likelihood by assigning one of the centers, say $\pmb { \mu } _ { k }$ , to a single data point, say ${ \bf { y } } _ { n }$ , since then the likelihood of that data point is given by

$$
\mathcal { N } ( \pmb { y } _ { n } | \pmb { \mu } _ { k } = \pmb { y } _ { n } , \sigma _ { k } ^ { 2 } \mathbf { I } ) = \frac { 1 } { \sqrt { 2 \pi \sigma _ { k } ^ { 2 } } } e ^ { 0 }
$$

Hence we can drive this term to infinity by letting $\sigma _ { k } \to 0$ , as shown in Figure 8.26(a). We call this the “collapsing variance problem”.

An easy solution to this is to perform MAP estimation. Fortunately, we can still use EM to find this MAP estimate. Our goal is now to maximize the expected complete data log-likelihood plus the log prior:

$$
\ell ^ { t } ( \pmb \theta ) = \left[ \sum _ { n } \sum _ { k } r _ { n k } ^ { ( t ) } \log \pi _ { n k } + \sum _ { n } \sum _ { k } r _ { n k } ^ { ( t ) } \log p ( \pmb y _ { n } | \pmb \theta _ { k } ) \right] + \log p ( \pmb \pi ) + \sum _ { k } \log p ( \pmb x _ { n k } )
$$

Note that the $\mathrm { E }$ step remains unchanged, but the M step needs to be modified, as we now explain. For the prior on the mixture weights, it is natural to use a Dirichlet prior (Section 4.6.3.2) $\pi \sim \operatorname { D i r } ( \alpha )$ , since this is conjugate to the categorical distribution. The MAP estimate is given by

$$
\tilde { \pi } _ { k } ^ { ( t + 1 ) } = \frac { r _ { k } ^ { ( t ) } + \alpha _ { k } - 1 } { N + \sum _ { k } \alpha _ { k } - K }
$$

If we use a uniform prior, $\alpha _ { k } = 1$ , this reduces to the MLE.

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

![](images/7eb259b35631e64dfe7e8fd70e0ee0e1a8fc4ad265a446e2f9212000be3a06b8.jpg)  
Figure 8.26: (a) Illustration of how singularities can arise in the likelihood function of GMMs. Here $K = 2$ , but the first mixture component is a narrow spike (with $\sigma _ { 1 } \approx 0$ ) centered on a single data point $x _ { 1 }$ . Adapted from Figure 9.7 of [Bis06]. Generated by mix_gauss_singularity.ipynb. (b) Illustration of the benefit of MAP estimation vs ML estimation when fitting a Gaussian mixture model. We plot the fraction of times (out of 5 random trials) each method encounters numerical problems vs the dimensionality of the problem, for $N = 1 0 0$ samples. Solid red (upper curve): MLE. Dotted black (lower curve): MAP. Generated by $m i x \_ g a u s s \_ m l e \_ v s \_ m a p . i p y n b$ .

For the prior on the mixture components, let us consider a conjugate prior of the form

$$
p ( { \pmb \mu } _ { k } , { \pmb \Sigma } _ { k } ) = \mathrm { N I W } ( { \pmb \mu } _ { k } , { \pmb \Sigma } _ { k } | \ { \pmb m } , { \mpb \kappa } , { \breve \nu } , { \breve { \bf S } } )
$$

This is called the Normal-Inverse-Wishart distribution (see the sequel to this book, [Mur23], for details.) Suppose we set the hyper-parameters for $\pmb { \mu }$ to be $\breve { \kappa } = 0$ , so that the $\pmb { \mu } _ { k }$ are unregularized; thus the prior will only influence our estimate of $\Sigma _ { k }$ . In this case, the MAP estimates are given by

$$
\begin{array} { l } { { \displaystyle { \tilde { \pmb { \mu } } } _ { k } ^ { ( t + 1 ) } = { \hat { \pmb { \mu } } } _ { k } ^ { ( t + 1 ) } } } \\ { { \displaystyle { \tilde { \pmb { \Sigma } } } _ { k } ^ { ( t + 1 ) } = \frac { \Breve { \bf S } + \hat { \bf S } _ { k } ^ { ( t + 1 ) } } { \overbrace { \boldsymbol { \nu } + \boldsymbol { r } _ { k } ^ { ( t ) } + { D } + 2 } } } } \end{array}
$$

where $\hat { \pmb { \mu } } _ { k }$ is the MLE for $\pmb { \mu } _ { k }$ from Equation (8.165), and $\hat { \Sigma } _ { k }$ is the MLE for $\Sigma _ { k }$ from Equation (8.166). Now we discuss how to set the prior covariance, $\breve { \mathbf { S } }$ . One possibility (suggested in [FR07, p163]) is to use

$$
\breve { \bf S } = \frac { 1 } { K ^ { 2 / D } } \mathrm { d i a g } ( s _ { 1 } ^ { 2 } , \dots , s _ { D } ^ { 2 } )
$$

where $\begin{array} { r } { s _ { d } ^ { 2 } = ( 1 / N ) \sum _ { n = 1 } ^ { N } ( x _ { n d } - \overline { { x } } _ { d } ) ^ { 2 } } \end{array}$ is the pooled variance for dimension $d$ . The parameter $\breve { \nu }$ controls how strongly we believe this prior. The weakest prior we can use, while still being proper, is to set $\scriptstyle { \overrightarrow { \nu } } = D + 2$ , so this is a common choice.

We now illustrate the benefits of using MAP estimation instead of ML estimation in the context of GMMs. We apply EM to some synthetic data with $N = 1 0 0$ samples in $D$ dimensions, using either ML or MAP estimation. We count the trial as a “failure” if there are numerical issues involving singular matrices. For each dimensionality, we conduct 5 random trials. The results are illustrated in Figure 8.26(b). We see that as soon as $D$ becomes even moderately large, ML estimation crashes and burns, whereas MAP with an appropriate prior estimation rarely encounters numerical problems.

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

H 19.5 14. 9.5   
25   
20 −0.5   
15 −5.5   
10 −10.5 −15.5 −15.5 −10.5 −5.5 ${ { \bf \Pi } ^ { - 0 . 5 } } _ { { \bf \Pi } ^ { \sharp } \mathrm { \bf _ { \Pi } } }$ 4.5 9.5 14.5 19.5   
−25 −20 −15 −10 10 (a) (b)

# 8.7.3.5 Nonconvexity of the NLL

The likelihood for a mixture model is given by

$$
\ell ( \pmb \theta ) = \sum _ { n = 1 } ^ { N } \log \left[ \sum _ { z _ { n } = 1 } ^ { K } p ( \pmb y _ { n } , z _ { n } | \pmb \theta ) \right]
$$

In general, this will have multiple modes, and hence there will not be a unique global optimum.

Figure 8.27 illustrates this for a mixture of 2 Gaussians in 1d. We see that there are two equally good global optima, corresponding to two different labelings of the clusters, one in which the left peak corresponds to $z = 1$ , and one in which the left peak corresponds to $z = 2$ . This is called the label switching problem; see Section 21.4.1.2 for more details.

The question of how many modes there are in the likelihood function is hard to answer. There are $K !$ possible labelings, but some of the peaks might get merged, depending on how far apart the $\mu _ { k }$ are. Nevertheless, there can be an exponential number of modes. Consequently, finding any global optimum is NP-hard [Alo+09; Dri+04]. We will therefore have to be satisfied with finding a local optimum. To find a good local optimum, we can use Kmeans $^ { + + }$ (Section 21.3.4) to initialize EM.

# 8.8 Blackbox and derivative free optimization

In some optimization problems, the objective function is a blackbox, meaning that its functional form is unknown. This means we cannot use gradient-based methods to optimize it. Instead, solving such problems require blackbox optimization (BBO) methods, also called derivative free optimization (DFO).

In ML, this kind of problem often arises when performing model selection. For example, suppose we have some hyper-parameters, $\lambda \in \Lambda$ , which control the type or complexity of a model. We often define the objective function ${ \mathcal { L } } ( \lambda )$ to be the loss on a validation set (see Section 4.5.4). Since the validation loss depends on the optimal model parameters, which are computed using a complex

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license algorithm, this objective function is effectively a blackbox.4

A simple approach to such problems is to use grid search, where we evaluate each point in the parameter space, and pick the one with the lowest loss. Unfortunately, this does not scale to high dimensions, because of the curse of dimensionality. In addition, even in low dimensions this can be expensive if evaluate the blackbox objective is expensive (e.g., if it first requires training the model before computing the validation loss). Various solutions to this problem have been proposed. See the sequel to this book, [Mur23], for details.

# 8.9 Exercises

Exercise 8.1 [Subderivative of the hinge loss function $^ *$ ] Let $f ( x ) = ( 1 - x ) _ { + }$ be the hinge loss function, where $( z ) _ { + } = \operatorname* { m a x } ( 0 , z )$ . What are $\partial f ( 0 )$ , $\partial f ( 1 )$ , and $\partial f ( 2 )$ ?

Exercise 8.2 [EM for the Student distribution]

Derive the EM equations for computing the MLE for a multivariate Student distribution. Consider the case where the dof parameter is known and unknown separately. Hint: write the Student distribution as a scale mixture of Gaussians.

# Part II

# Linear Models

# 9 Linear Discriminant Analysis

# 9.1 Introduction

In this chapter, we consider classification models of the following form:

$$
p ( y = c | \pmb { x } ; \pmb { \theta } ) = \frac { p ( \pmb { x } | y = c ; \pmb { \theta } ) p ( y = c ; \pmb { \theta } ) } { \sum _ { c ^ { \prime } } p ( \pmb { x } | y = c ^ { \prime } ; \pmb { \theta } ) p ( y = c ^ { \prime } ; \pmb { \theta } ) }
$$

The term $p ( y = c ; \pmb \theta )$ is the prior over class labels, and the term $p ( { \pmb x } | y = c ; \pmb \theta )$ is called the class conditional density for class $c$ .

The overall model is called a generative classifier, since it specifies a way to generate the features $_ { x }$ for each class $c$ , by sampling from $p ( { \pmb x } | y = c ; \pmb \theta )$ . By contrast, a discriminative classifier directly models the class posterior $p ( \boldsymbol { y } | \boldsymbol { x } ; \boldsymbol { \theta } )$ . We discuss the pros and cons of these two approaches to classification in Section 9.4.

If we choose the class conditional densities in a special way, we will see that the resulting posterior over classes is a linear function of $_ { x }$ , i.e., $\log p ( \boldsymbol { y } = \boldsymbol { c } | \boldsymbol { x } ; \boldsymbol { \theta } ) = \boldsymbol { w } ^ { \top } \boldsymbol { x } + \mathrm { c o n s t }$ , where $\mathbf { \boldsymbol { w } }$ is derived from $\pmb \theta$ . Thus the overall method is called linear discriminant analysis or LDA.1

# 9.2 Gaussian discriminant analysis

In this section, we consider a generative classifier where the class conditional densities are multivariate Gaussians:

$$
p ( { \pmb x } | y = c , \pmb \theta ) = \mathcal { N } ( { \pmb x } | { \pmb \mu } _ { c } , { \pmb \Sigma } _ { c } )
$$

The corresponding class posterior therefore has the form

$$
p ( y = c | \pmb { x } , \pmb { \theta } ) \propto \pi _ { c } \mathcal { N } ( \pmb { x } | \pmb { \mu } _ { c } , \pmb { \Sigma } _ { c } )
$$

where $\pi _ { c } = p ( y = c )$ is the prior probability of label $c$ . (Note that we can ignore the normalization constant in the denominator of the posterior, since it is independent of $c$ .) We call this model Gaussian discriminant analysis or GDA.

![](images/43f0c37968183aa66af14163fd03b7289f549894b8f9088c9956e45354c289f9.jpg)  
Figure 9.1: (a) Some 2d data from 3 different classes. (b) Fitting 2d Gaussians to each class. Generated by discrim_analysis_dboundaries_plot2.ipynb.

![](images/443649d56d84667e6a9880403f0216d99f0f4314c85722271743a6c27d2c0919.jpg)  
Figure 9.2: Gaussian discriminant analysis fit to data in Figure 9.1. (a) Unconstrained covariances induce quadratic decision boundaries. (b) Tied covariances induce linear decision boundaries. Generated by discrim_analysis_dboundaries_plot2.ipynb.

# 9.2.1 Quadratic decision boundaries

From Equation (9.3), we see that the log posterior over class labels is given by

$$
\log p ( y = c | \pmb { x } , \pmb { \theta } ) = \log \pi _ { c } - \frac { 1 } { 2 } \log | 2 \pi \pmb { \Sigma } _ { c } | - \frac { 1 } { 2 } ( \pmb { x } - \pmb { \mu } _ { c } ) ^ { \mathsf { T } } \pmb { \Sigma } _ { c } ^ { - 1 } ( \pmb { x } - \pmb { \mu } _ { c } ) + \mathrm { c o n s t } .
$$

This is called the discriminant function. We see that the decision boundary between any two classes, say $c$ and $c ^ { \prime }$ , will be a quadratic function of $_ { x }$ . Hence this is known as quadratic discriminant analysis (QDA).

For example, consider the 2d data from 3 different classes in Figure 9.1a. We fit full covariance Gaussian class-conditionals (using the method explained in Section 9.2.4), and plot the results in Figure 9.1b. We see that the features for the blue class are somewhat correlated, whereas the features for the green class are independent, and the features for the red class are independent and isotropic (spherical covariance). In Figure 9.2a, we see that the resulting decision boundaries are quadratic functions of $_ { x }$ .

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

![](images/49437a907636c36e28354db34dea94dbba2cdaed82a1e7bd65bde1d77e8e870e.jpg)  
Figure 9.3: Geometry of LDA in the 2 class case where $\pmb { \Sigma } _ { 1 } = \pmb { \Sigma } _ { 2 } = \pmb { \mathrm { I } }$ .

# 9.2.2 Linear decision boundaries

Now we consider a special case of Gaussian discriminant analysis in which the covariance matrices are tied or shared across classes, so $\Sigma _ { c } = \Sigma$ . If $\pmb { \Sigma }$ is independent of $c$ , we can simplify Equation (9.4) as follows:

$$
\begin{array} { r l } & { \log p ( y = c | \pmb { x } , \pmb { \theta } ) = \log \pi _ { c } - \frac { 1 } { 2 } ( \pmb { x } - \pmb { \mu } _ { c } ) ^ { \mathsf { T } } \pmb { \Sigma } ^ { - 1 } ( \pmb { x } - \pmb { \mu } _ { c } ) + \mathrm { c o n s t } } \\ & { \qquad = \underbrace { \log \pi _ { c } - \frac { 1 } { 2 } \pmb { \mu } _ { c } ^ { \mathsf { T } } \pmb { \Sigma } ^ { - 1 } \pmb { \mu } _ { c } } _ { \gamma _ { c } } + \pmb { x } ^ { \mathsf { T } } \underbrace { \pmb { \Sigma } ^ { - 1 } \pmb { \mu } _ { c } } _ { \beta _ { c } } \underbrace { + \mathrm { c o n s t } - \frac { 1 } { 2 } \pmb { x } ^ { \mathsf { T } } \pmb { \Sigma } ^ { - 1 } \pmb { x } } _ { \kappa } } \\ & { \qquad = \gamma _ { c } + \pmb { x } ^ { \mathsf { T } } \beta _ { c } + \kappa } \end{array}
$$

The final term is independent of $c$ , and hence is an irrelevant additive constant that can be dropped. Hence we see that the discriminant function is a linear function of $_ { x }$ , so the decision boundaries will be linear. Hence this method is called linear discriminant analysis or LDA. See Figure 9.2b for an example.

# 9.2.3 The connection between LDA and logistic regression

In this section, we derive an interesting connection between LDA and logistic regression, which we introduced in Section 2.5.3. From Equation (9.7) we can write

$$
p ( y = c | \pmb { x } , \pmb { \theta } ) = \frac { e ^ { \beta _ { c } ^ { \top } \pmb { x } + \gamma _ { c } } } { \sum _ { c ^ { \prime } } e ^ { \beta _ { c ^ { \prime } } ^ { \top } \pmb { x } + \gamma _ { c ^ { \prime } } } } = \frac { e ^ { \pmb { w } _ { c } ^ { \top } [ 1 , \pmb { x } ] } } { \sum _ { c ^ { \prime } } e ^ { \pmb { w } _ { c ^ { \prime } } ^ { \top } [ 1 , \pmb { x } ] } }
$$

where $\pmb { w } _ { c } = [ \gamma _ { c } , \beta _ { c } ]$ . We see that Equation (9.8) has the same form as the multinomial logistic regression model. The key difference is that in LDA, we first fit the Gaussians (and class prior) to maximize the joint likelihood $p ( \boldsymbol { x } , \boldsymbol { y } | \boldsymbol { \theta } )$ , as discussed in Section 9.2.4, and then we derive $\mathbf { \boldsymbol { w } }$ from $\pmb \theta$ . By contrast, in logistic regression, we estimate $\mathbf { \boldsymbol { w } }$ directly to maximize the conditional likelihood $p ( \boldsymbol { y } | \boldsymbol { x } , \boldsymbol { w } )$ . In general, these can give different results (see Exercise 10.3).

To gain further insight into Equation (9.8), let us consider the binary case. In this case, the

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

posterior is given by

$$
\begin{array} { c } { \displaystyle p ( { \boldsymbol y } = 1 | { \boldsymbol x } , { \boldsymbol \theta } ) = \frac { e ^ { \beta _ { 1 } ^ { \intercal } { \boldsymbol x } + \gamma _ { 1 } } } { e ^ { \beta _ { 1 } ^ { \intercal } { \boldsymbol x } + \gamma _ { 1 } } + e ^ { \beta _ { 0 } ^ { \intercal } { \boldsymbol x } + \gamma _ { 0 } } } = \frac { 1 } { 1 + e ^ { ( \beta _ { 0 } - \beta _ { 1 } ) ^ { \intercal } { \boldsymbol x } + ( \gamma _ { 0 } - \gamma _ { 1 } ) } } } \\ { = \sigma \left( ( \beta _ { 1 } - \beta _ { 0 } ) ^ { \intercal } { \boldsymbol x } + ( \gamma _ { 1 } - \gamma _ { 0 } ) \right) } \end{array}
$$

where $\sigma ( \eta )$ refers to the sigmoid function.

Now

$$
\begin{array} { c } { { \gamma _ { 1 } - \gamma _ { 0 } = - \displaystyle \frac 1 2 \pmb { \mu } _ { 1 } ^ { \mathsf { T } } \Sigma ^ { - 1 } \pmb { \mu } _ { 1 } + \displaystyle \frac 1 2 \pmb { \mu } _ { 0 } ^ { \mathsf { T } } \Sigma ^ { - 1 } \pmb { \mu } _ { 0 } + \log ( \pi _ { 1 } / \pi _ { 0 } ) } } \\ { { = - \displaystyle \frac 1 2 ( \pmb { \mu } _ { 1 } - \pmb { \mu } _ { 0 } ) ^ { \mathsf { T } } \Sigma ^ { - 1 } ( \pmb { \mu } _ { 1 } + \pmb { \mu } _ { 0 } ) + \log ( \pi _ { 1 } / \pi _ { 0 } ) } } \end{array}
$$

So if we define

$$
\begin{array} { l } { { \pmb w = \pmb \beta _ { 1 } - \pmb \beta _ { 0 } = \pmb \Sigma ^ { - 1 } ( \pmb \mu _ { 1 } - \pmb \mu _ { 0 } ) } } \\ { { \pmb x } _ { 0 } = \displaystyle \frac { 1 } { 2 } ( \pmb \mu _ { 1 } + \pmb \mu _ { 0 } ) - ( \pmb \mu _ { 1 } - \pmb \mu _ { 0 } ) \frac { \log \left( \pi _ { 1 } / \pi _ { 0 } \right) } { ( \pmb \mu _ { 1 } - \pmb \mu _ { 0 } ) ^ { \mathsf { T } } \pmb \Sigma ^ { - 1 } ( \pmb \mu _ { 1 } - \pmb \mu _ { 0 } ) } } \end{array}
$$

then we have $\boldsymbol { w } ^ { \intercal } \boldsymbol { x } _ { 0 } = - ( \gamma _ { 1 } - \gamma _ { 0 } )$ , and hence

$$
p ( \boldsymbol { y } = 1 | \boldsymbol { x } , \pmb { \theta } ) = \sigma ( \pmb { w } ^ { \top } ( \pmb { x } - \pmb { x } _ { 0 } ) )
$$

This has the same form as binary logistic regression. Hence the MAP decision rule is

$$
\hat { y } ( \pmb { x } ) = 1 \ \mathrm { i f f } \ \pmb { w } ^ { \top } \pmb { x } > c
$$

where $c = \pmb { w } ^ { \top } \pmb { x } _ { 0 }$ . If $\pi _ { 0 } = \pi _ { 1 } = 0 . 5$ , then the threshold simplifies to ${ \boldsymbol { c } } = { \textstyle { \frac { 1 } { 2 } } } { \boldsymbol { w } } ^ { \mathsf { T } } ( { \pmb { \mu } } _ { 1 } + { \pmb { \mu } } _ { 0 } )$ .

To interpret this equation geometrically, suppose $\scriptstyle \pmb { \Sigma } \ = \ \sigma ^ { 2 } \mathbf { I }$ . In this case, ${ \pmb w } = \sigma ^ { - 2 } ( { \pmb \mu } _ { 1 } - { \pmb \mu } _ { 0 } )$ , which is parallel to a line joining the two centroids, $\pmb { \mu } _ { 0 }$ and $\pmb { \mu } _ { 1 }$ . So we can classify a point by projecting it onto this line, and then checking if the projection is closer to $\pmb { \mu } _ { 0 }$ or $\pmb { \mu } _ { 1 }$ , as illustrated in Figure 9.3. The question of how close it has to be depends on the prior over classes. If $\pi _ { 1 } = \pi _ { 0 }$ , then $\begin{array} { r } { { \pmb x } _ { 0 } = \frac { 1 } { 2 } ( { \pmb \mu } _ { 1 } + { \pmb \mu } _ { 0 } ) } \end{array}$ , which is halfway between the means. If we make $\pi _ { 1 } > \pi _ { 0 }$ , we have to be closer to $\pmb { \mu } _ { 0 }$ than halfway in order to pick class 0. And vice versa if $\pi _ { 0 } > \pi _ { 1 }$ . Thus we see that the class prior just changes the decision threshold, but not the overall shape of the decision boundary. (A similar argument applies in the multi-class case.)

# 9.2.4 Model fitting

We now discuss how to fit a GDA model using maximum likelihood estimation. The likelihood function is as follows

$$
p ( \mathcal { D } | \pmb { \theta } ) = \prod _ { n = 1 } ^ { N _ { \mathcal { D } } } \mathrm { C a t } ( y _ { n } | \pi ) \prod _ { c = 1 } ^ { C } \mathcal { N } ( \pmb { x } _ { n } | \pmb { \mu } _ { c } , \pmb { \Sigma } _ { c } ) ^ { \mathbb { I } ( y _ { n } = c ) }
$$

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

Hence the log-likelihood is given by

$$
\log p ( \mathcal { D } | \theta ) = \left[ \sum _ { n = 1 } ^ { N _ { \mathcal { D } } } \sum _ { c = 1 } ^ { C } \mathbb { I } \left( y _ { n } = c \right) \log \pi _ { c } \right] + \sum _ { c = 1 } ^ { C } \left[ \sum _ { n : y _ { n } = c } \log \mathcal { N } ( x _ { n } | \mu _ { c } , \Sigma _ { c } ) \right]
$$

Thus we see that we can optimize $\pi$ and the $( \pmb { \mu } _ { c } , \pmb { \Sigma } _ { c } )$ terms separately.

From Section 4.2.4, we have that the MLE for the class prior is $\begin{array} { r } { \hat { \pi } _ { c } = \frac { N _ { c } } { N } } \end{array}$ . Using the results from Section 4.2.6, we can derive the MLEs for the Gaussians as follows:

$$
\begin{array} { l } { \hat { \boldsymbol { \mu } } _ { c } = \displaystyle \frac { 1 } { N _ { \mathscr { D } c } } \sum _ { n : y _ { n } = c } \boldsymbol { x } _ { n } } \\ { \hat { \boldsymbol { \Sigma } } _ { c } = \displaystyle \frac { 1 } { N _ { \mathscr { D } c } } \sum _ { n : y _ { n } = c } ( \boldsymbol { x } _ { n } - \hat { \boldsymbol { \mu } } _ { c } ) ( \boldsymbol { x } _ { n } - \hat { \boldsymbol { \mu } } _ { c } ) ^ { \top } } \end{array}
$$

Unfortunately the MLE for $\hat { \Sigma } _ { c }$ can easily overfit (i.e., the estimate may not be well-conditioned) if $N _ {  { D _ { c } } }$ is small compared to $D$ , the dimensionality of the input features. We discuss some solutions to this below.

# 9.2.4.1 Tied covariances

If we force $\Sigma _ { c } = \Sigma$ to be tied, we will get linear decision boundaries, as we have seen. This also usually results in a more reliable parameter estimate, since we can pool all the samples across classes:

$$
{ \hat { \mathbf { \boldsymbol { \Sigma } } } } = { \frac { 1 } { N _ { \mathcal { D } } } } \sum _ { c = 1 } ^ { C } \sum _ { n : y _ { n } = c } ( { \boldsymbol { x } } _ { n } - { \hat { \boldsymbol { \mu } } } _ { c } ) ( { \boldsymbol { x } } _ { n } - { \hat { \boldsymbol { \mu } } } _ { c } ) ^ { \intercal }
$$

# 9.2.4.2 Diagonal covariances

If we force $\Sigma _ { c }$ to be diagonal, we reduce the number of parameters from $O ( C D ^ { 2 } )$ to $O ( C D )$ , which avoids the overfitting problem. However, this loses the ability to capture correlations between the features. (This is known as the naive Bayes assumption, which we discuss further in Section 9.3.) Despite this approximation, this approach scales well to high dimensions.

We can further restrict the model capacity by using a shared (tied) diagonal covariace matrix. This is called “diagonal LDA” [BL04].

# 9.2.4.3 MAP estimation

Forcing the covariance matrix to be diagonal is a rather strong assumption. An alternative approach is to perform MAP estimation of a (shared) full covariance Gaussian, rather than using the MLE. Based on the results of Section 4.5.2, we find that the MAP estimate is

$$
\hat { \Sigma } _ { \mathrm { m a p } } = \lambda \mathrm { d i a g } ( \hat { \Sigma } _ { \mathrm { m l e } } ) + ( 1 - \lambda ) \hat { \Sigma } _ { \mathrm { m l e } }
$$

where $\lambda$ controls the amount of regularization. This technique is known as regularized discriminant analysis or RDA [HTF09, p656].

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

# 9.2.5 Nearest centroid classifier

If we assume a uniform prior over classes, we can compute the most probable class label as follows:

$$
\hat { y } ( \pmb { x } ) = \underset { c } { \operatorname { a r g m a x } } \log p ( \pmb { y } = c | \pmb { x } , \pmb { \theta } ) = \underset { c } { \operatorname { a r g m i n } } ( \pmb { x } - \pmb { \mu } _ { c } ) ^ { \mathsf { T } } \pmb { \Sigma } ^ { - 1 } ( \pmb { x } - \pmb { \mu } _ { c } )
$$

This is called the nearest centroid classifier, or nearest class mean classifier (NCM), since we are assigning $_ { x }$ to the class with the closest $\pmb { \mu } _ { c }$ , where distance is measured using (squared) Mahalanobis distance.

We can replace this with any other distance metric to get the decision rule

$$
{ \hat { y } } ( \pmb { x } ) = \operatorname * { a r g m i n } _ { c } d ^ { 2 } ( \pmb { x } , \pmb { \mu } _ { c } )
$$

We discuss how to learn distance metrics in Section 16.2, but one simple approach is to use

$$
d ^ { 2 } ( \mathbf { x } , { \boldsymbol { \mu } } _ { c } ) = | | \mathbf { x } - { \boldsymbol { \mu } } _ { c } | | _ { \mathbf { W } } ^ { 2 } = ( \mathbf { x } - { \boldsymbol { \mu } } _ { c } ) ^ { \mathsf { T } } ( \mathbf { W } \mathbf { W } ^ { \mathsf { T } } ) ( \mathbf { x } - { \boldsymbol { \mu } } _ { c } ) = | | \mathbf { W } ( \mathbf { x } - { \boldsymbol { \mu } } _ { c } ) | | ^ { 2 }
$$

The corresponding class posterior becomes

$$
p ( \boldsymbol { y } = { c } | \boldsymbol { x } , \mu , \mathbf { W } ) = \frac { \exp ( - \frac { 1 } { 2 } | | \mathbf { W } ( \boldsymbol { x } - \mu _ { c } ) | | _ { 2 } ^ { 2 } ) } { \sum _ { c ^ { \prime } = 1 } ^ { C } \exp ( - \frac { 1 } { 2 } | | \mathbf { W } ( \boldsymbol { x } - \mu _ { c ^ { \prime } } ) | | _ { 2 } ^ { 2 } ) }
$$

We can optimize W using gradient descent applied to the discriminative loss. This is called nearest class mean metric learning [Men+12]. The advantage of this technique is that it can be used for one-shot learning of new classes, since we just need to see a single labeled prototype $\pmb { \mu } _ { c }$ per class (assuming we have learned a good W already).

# 9.2.6 Fisher’s linear discriminant analysis \*

Discriminant analysis is a generative approach to classification, which requires fitting an MVN to the features. As we have discussed, this can be problematic in high dimensions. An alternative approach is to reduce the dimensionality of the features $\pmb { x } \in \mathbb { R } ^ { D }$ and then fit an MVN to the resulting low-dimensional features $z \in \mathbb { R } ^ { K }$ . The simplest approach is to use a linear projection matrix, $z = \mathbf { W } \mathbf { x }$ , where $\mathbf { W }$ is a $K \times D$ matrix. One approach to finding W would be to use principal components analysis or PCA (Section 20.1). However, PCA is an unsupervised technique that does not take class labels into account. Thus the resulting low dimensional features are not necessarily optimal for classification, as illustrated in Figure 9.4.

An alternative approach is to use gradient based methods to optimize the log likelihood, derived from the class posterior in the low dimensional space, as we discussed in Section 9.2.5.

A third approach (which relies on an eigendecomposition, rather than a gradient-based optimizer) is to find the matrix W such that the low-dimensional data can be classified as well as possible using a Gaussian class-conditional density model. The assumption of Gaussianity is reasonable since we are computing linear combinations of (potentially non-Gaussian) features. This approach is called Fisher’s linear discriminant analysis, or FLDA.

FLDA is an interesting hybrid of discriminative and generative techniques. The drawback of this technique is that it is restricted to using $K \leq C - 1$ dimensions, regardless of $D$ , for reasons that we will explain below. In the two-class case, this means we are seeking a single vector $\mathbf { \boldsymbol { w } }$ onto which we can project the data. Below we derive the optimal $\mathbf { \boldsymbol { w } }$ in the two-class case. We then generalize to the multi-class case, and finally we give a probabilistic interpretation of this technique.

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

![](images/fd956ea0eb639a5cab9746527d54da849587aa1182462d738c392e8314a69182.jpg)  
Figure 9.4: Linear disciminant analysis applied to two class dataset in 2d, representing (standardized) height and weight for male and female adults (a) PCA direction. (b) FLDA direction. (c) Projection onto PCA direction shows poor class separation. (d) Projection onto FLDA direction shows good class separation. Generated by fisher_lda_demo.ipynb.

# 9.2.6.1 Derivation of the optimal 1d projection

We now derive this optimal direction $\mathbf { \boldsymbol { w } }$ , for the two-class case, following the presentation of [Bis06, Sec 4.1.4]. Define the class-conditional means as

$$
\pmb { \mu } _ { 1 } = \frac { 1 } { N _ { 1 } } \sum _ { n : y _ { n } = 1 } \pmb { x } _ { n } , ~ \pmb { \mu } _ { 2 } = \frac { 1 } { N _ { 2 } } \sum _ { n : y _ { n } = 2 } \pmb { x } _ { n }
$$

Let $m _ { k } = \pmb { w } ^ { \vert } \pmb { \mu } _ { k }$ be the projection of each mean onto the line $\mathbf { \boldsymbol { w } }$ . Also, let $z _ { n } = w ^ { 1 } x _ { n }$ be the projection of the data onto the line. The variance of the projected points is proportional to

$$
s _ { k } ^ { 2 } = \sum _ { n : y _ { n } = k } ( z _ { n } - m _ { k } ) ^ { 2 }
$$

The goal is to find $\mathbf { \boldsymbol { w } }$ such that we maximize the distance between the means, $m _ { 2 } - m _ { 1 }$ , while also ensuring the projected clusters are “tight”, which we can do by minimizing their variance. This suggests the following objective:

$$
J ( w ) = \frac { ( m _ { 2 } - m _ { 1 } ) ^ { 2 } } { s _ { 1 } ^ { 2 } + s _ { 2 } ^ { 2 } }
$$

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

We can rewrite the right hand side of the above in terms of $\mathbf { \boldsymbol { w } }$ as follows

$$
J ( \pmb { w } ) = \frac { \pmb { w } ^ { \top } \mathbf { S } _ { B } \pmb { w } } { \pmb { w } ^ { \top } \mathbf { S } _ { W } \pmb { w } }
$$

where $\mathbf { S } _ { B }$ is the between-class scatter matrix given by

$$
\mathbf { S } _ { B } = ( \pmb { \mu } _ { 2 } - \pmb { \mu } _ { 1 } ) ( \pmb { \mu } _ { 2 } - \pmb { \mu } _ { 1 } ) ^ { \top }
$$

and $\mathbf { s } _ { W }$ is the within-class scatter matrix, given by

$$
\mathbf { S } _ { W } = \sum _ { n : y _ { n } = 1 } ( x _ { n } - \mu _ { 1 } ) ( { \pmb x } _ { n } - { \pmb \mu } _ { 1 } ) ^ { \top } + \sum _ { n : y _ { n } = 2 } ( { \pmb x } _ { n } - { \pmb \mu } _ { 2 } ) ( { \pmb x } _ { n } - { \pmb \mu } _ { 2 } ) ^ { \top }
$$

To see this, note that

$$
{ \boldsymbol { w } } ^ { \mathsf { T } } { \boldsymbol { \mathbf { S } } } _ { B } { \boldsymbol { w } } = { \boldsymbol { w } } ^ { \mathsf { T } } ( \mu _ { 2 } - \mu _ { 1 } ) ( \mu _ { 2 } - \mu _ { 1 } ) ^ { \mathsf { T } } { \boldsymbol { w } } = ( m _ { 2 } - m _ { 1 } ) ( m _ { 2 } - m _ { 1 } )
$$

and

$$
\begin{array} { l } { { \displaystyle w ^ { \mathsf { T } } { \bf S } _ { W } w = \sum _ { n : y _ { n } = 1 } w ^ { \mathsf { T } } ( { \bf x } _ { n } - \mu _ { 1 } ) ( { \bf x } _ { n } - \mu _ { 1 } ) ^ { \mathsf { T } } w + } } \\ { { \displaystyle \sum _ { n : y _ { n } = 2 } w ^ { \mathsf { T } } ( { \bf x } _ { n } - \mu _ { 2 } ) ( { \bf x } _ { n } - \mu _ { 2 } ) ^ { \mathsf { T } } w } } \\ { { \displaystyle \quad = \sum _ { n : y _ { n } = 1 } ( z _ { n } - m _ { 1 } ) ^ { 2 } + \sum _ { n : y _ { n } = 2 } ( z _ { n } - m _ { 2 } ) ^ { 2 } } } \end{array}
$$

Equation (9.30) is a ratio of two scalars; we can take its derivative with respect to $\mathbf { \boldsymbol { w } }$ and equate to zero. One can show (Exercise 9.1) that $J ( w )$ is maximized when

$$
\mathbf { S } _ { B } \pmb { w } = \lambda \mathbf { S } _ { W } \pmb { w }
$$

where

$$
\lambda = \frac { \pmb { w } ^ { \mathsf { T } } \mathbf { S } _ { B } \pmb { w } } { \pmb { w } ^ { \mathsf { T } } \mathbf { S } _ { W } \pmb { w } }
$$

Equation (9.36) is called a generalized eigenvalue problem. If $\mathbf { s } _ { W }$ is invertible, we can convert it to a regular eigenvalue problem:

$$
\mathbf { S } _ { W } ^ { - 1 } \mathbf { S } _ { B } \pmb { w } = \lambda \pmb { w }
$$

However, in the two class case, there is a simpler solution. In particular, since

$$
\mathbf { S } _ { B } { \boldsymbol { w } } = ( { \boldsymbol { \mu } } _ { 2 } - { \boldsymbol { \mu } } _ { 1 } ) ( { \boldsymbol { \mu } } _ { 2 } - { \boldsymbol { \mu } } _ { 1 } ) ^ { \mathsf { T } } { \boldsymbol { w } } = ( { \boldsymbol { \mu } } _ { 2 } - { \boldsymbol { \mu } } _ { 1 } ) ( m _ { 2 } - m _ { 1 } )
$$

then, from Equation (9.38) we have

$$
\begin{array} { r } { \lambda \pmb { w } = \mathbf { S } _ { W } ^ { - 1 } ( \pmb { \mu } _ { 2 } - \pmb { \mu } _ { 1 } ) ( m _ { 2 } - m _ { 1 } ) } \\ { \pmb { w } \propto \mathbf { S } _ { W } ^ { - 1 } ( \pmb { \mu } _ { 2 } - \pmb { \mu } _ { 1 } ) } \end{array}
$$

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

![](images/6b8f76c7c02a7c1cdcaa65af83e2422ad5862a273f4f0e5b7263f77de807d888.jpg)  
Figure 9.5: (a) PCA projection of vowel data to 2d. (b) FLDA projection of vowel data to 2d. We see there is better class separation in the FLDA case. Adapted from Figure 4.11 of [HTF09]. Generated by fisher_discrim_vowel.ipynb.

Since we only care about the directionality, and not the scale factor, we can just set

$$
{ \pmb w } = { \bf S } _ { W } ^ { - 1 } ( { \pmb \mu } _ { 2 } - { \pmb \mu } _ { 1 } )
$$

This is the optimal solution in the two-class case. If ${ \bf S } _ { W } \propto { \bf I }$ , meaning the pooled covariance matrix is isotropic, then $\mathbf { \boldsymbol { w } }$ is proportional to the vector that joins the class means. This is an intuitively reasonable direction to project onto, as shown in Figure 9.3.

# 9.2.6.2 Extension to higher dimensions and multiple classes

We can extend the above idea to multiple classes, and to higher dimensional subspaces, by finding a projection matrix W which maps from $D$ to $K$ . Let $z _ { n } = \mathbf { W } \pmb { x } _ { n }$ be the low dimensional projection of the $n$ ’th data point. Let $\begin{array} { r } { \pmb { m } _ { c } = \frac { 1 } { N _ { c } } \sum _ { n : y _ { n } = c } \pmb { z } _ { n } } \end{array}$ be the corresponding mean for the $c$ ’th class and $\begin{array} { r } { m = { \frac { 1 } { N } } \sum _ { c = 1 } ^ { C } N _ { c } m _ { c } } \end{array}$ be the overall mean, both in the low dimensional space. We define the following scatter matrices:

$$
\begin{array} { l } { { \displaystyle { { \tilde { \bf S } } _ { W } } = \sum _ { c = 1 } ^ { C } \sum _ { n : y _ { n } = c } ( z _ { n } - m _ { c } ) ( z _ { n } - m _ { c } ) ^ { \top } } } \\ { { \displaystyle { { \tilde { \bf S } } _ { B } } = \sum _ { c = 1 } ^ { C } N _ { c } ( m _ { c } - m ) ( m _ { c } - m ) ^ { \top } } } \end{array}
$$

Finally, we define the objective function as maximizing the following:2

$$
J ( \mathbf { W } ) = { \frac { | \tilde { \mathbf { S } } _ { B } | } { | \tilde { \mathbf { S } } _ { W } | } } = { \frac { | \mathbf { W } ^ { \mathsf { T } } \mathbf { S } _ { B } \mathbf { W } | } { | \mathbf { W } ^ { \mathsf { T } } \mathbf { S } _ { W } \mathbf { W } | } }
$$

2. An alternative criterion that is sometimes used [Fuk90] is $\begin{array} { r } { J ( \mathbf { W } ) = \operatorname { t r } \Big \{ \tilde { \mathbf { S } } _ { W } ^ { - 1 } \tilde { \mathbf { S } } _ { B } \Big \} = \operatorname { t r } \big \{ ( \mathbf { W } \mathbf { S } _ { W } \mathbf { W } ^ { \mathsf { T } } ) ^ { - 1 } ( \mathbf { W } \mathbf { S } _ { B } \mathbf { W } ^ { \mathsf { T } } ) \big \} . } \end{array}$

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license where $\mathbf { s } _ { W }$ and $\mathbf { S } _ { B }$ are defined in the original high dimensional space in the obvious way (namely using ${ \boldsymbol { \mathbf { \mathit { x } } } } _ { n }$ instead of $z _ { n }$ , $\pmb { \mu } _ { c }$ instead of ${ \pmb { m } } _ { c }$ , and $\mu$ instead of $_ { \mathbf { \phi } ^ { \prime } m }$ ). The solution can be shown [DHS01] to be $\mathbf { W } = \mathbf { S } _ { W } ^ { - \frac { 1 } { 2 } } \mathbf { U }$ , where $\mathbf { U }$ are the $K$ leading eigenvectors of $\mathbf { S } _ { W } ^ { - \frac { 1 } { 2 } } \mathbf { S } _ { B } \mathbf { S } _ { W } ^ { - \frac { 1 } { 2 } }$ , assuming $\mathbf { s } _ { W }$ is non-singular. (If it is singular, we can first perform PCA on all the data.)

Figure 9.5 gives an example of this method applied to some $D = 1 0$ dimensional speech data, representing $C = 1 1$ different vowel sounds. We project to $K = 2$ dimensions in order to visualize the data. We see that FLDA gives better class separation than PCA.

Note that FLDA is restricted to finding at most a $K \leq C - 1$ dimensional linear subspace, no matter how large $D$ , because the rank of the between class scatter matrix $\mathbf { S } _ { B }$ is $C - 1$ . (The -1 term arises because of the $\pmb { \mu }$ term, which is a linear function of the $\pmb { \mu } _ { c }$ .) This is a rather severe restriction which limits the usefulness of FLDA.

# 9.3 Naive Bayes classifiers

In this section, we discuss a simple generative approach to classification in which we assume the features are conditionally independent given the class label. This is called the naive Bayes assumption. The model is called “naive” since we do not expect the features to be independent, even conditional on the class label. However, even if the naive Bayes assumption is not true, it often results in classifiers that work well [DP97]. One reason for this is that the model is quite simple (it only has $O ( C D )$ parameters, for $C$ classes and $D$ features), and hence it is relatively immune to overfitting.

More precisely, the naive Bayes assumption corresponds to using a class conditional density of the following form:

$$
p ( \pmb { x } | y = c , \pmb { \theta } ) = \prod _ { d = 1 } ^ { D } p ( x _ { d } | y = c , \pmb { \theta } _ { d c } )
$$

where $\pmb { \theta } _ { d c }$ are the parameters for the class conditional density for class $c$ and feature $d$ . Hence the posterior over class labels is given by

$$
p ( y = c | \pmb { x } , \pmb { \theta } ) = \frac { p ( y = c | \pi ) \prod _ { d = 1 } ^ { D } p ( x _ { d } | y = c , \pmb { \theta } _ { d c } ) } { \sum _ { c ^ { \prime } } p ( y = c ^ { \prime } | \pi ) \prod _ { d = 1 } ^ { D } p ( x _ { d } | y = c ^ { \prime } , \pmb { \theta } _ { d c ^ { \prime } } ) }
$$

where $\pi _ { c }$ is the prior probability of class $c$ , and $\pmb { \theta } = ( \pi , \{ \pmb { \theta } _ { d c } \} ) )$ are all the parameters. This is known as a naive Bayes classifier or NBC.

# 9.3.1 Example models

We still need to specify the form of the probability distributions in Equation (9.46). This depends on what type of feature $x _ { d }$ is. We give some examples below:

• In the case of binary features, $x _ { d } \in \{ 0 , 1 \}$ , we can use the Bernoulli distribution: $p ( \pmb { x } | y = c , \pmb { \theta } ) =$ $\textstyle \prod _ { d = 1 } ^ { D } \operatorname { B e r } ( x _ { d } | \theta _ { d c } )$ , where $\theta _ { d c }$ is the probability that $x _ { d } = 1$ in class $c$ . This is sometimes called the multivariate Bernoulli naive Bayes model. For example, Figure 9.6 shows the estimated parameters for each class when we fit this model to a binarized version of MNIST. This approach does surprisingly well, and has a test set accuracy of 84.3%. (See Figure 9.7 for some sample predictions.)

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

0123456789

Figure 9.6: Visualization of the Bernoulli class conditional densities for a naive Bayes classifier fit to a binarized version of the MNIST dataset. Generated by naive_bayes_mnist_jax.ipynb.

![](images/facc11fe18fc3e03eae98869f0e352dbfa66d425a7cbd64f0203519eaa05927d.jpg)  
Figure 9.7: Visualization of the predictions made by the model in Figure 9.6 when applied to some binarized MNIST test images. The title shows the most probable predicted class. Generated by naive_bayes_mnist_jax.ipynb.

• In the case of categorical features, $x _ { d } \in \{ 1 , \ldots , K \}$ , we can use the categorical distribution: $\begin{array} { r } { p ( \pmb { x } | y = c , \pmb { \theta } ) = \prod _ { d = 1 } ^ { L } \mathrm { C a t } ( x _ { d } | \pmb { \theta } _ { d c } ) } \end{array}$ , where $\theta _ { d c k }$ is the probability that $x _ { d } = k$ given that $y = c$ .

• In the case of real-valued features, $x _ { d } \in \mathbb { R }$ , we can use the univariate Gaussian distribution: $\begin{array} { r } { p ( { \pmb x } | y = c , \pmb \theta ) = \prod _ { d = 1 } ^ { L } \mathcal { N } ( x _ { d } | \mu _ { d c } , \sigma _ { d c } ^ { 2 } ) } \end{array}$ , where $\mu _ { d c }$ is the mean of feature $d$ when the class label is $c$ , and $\sigma _ { d c } ^ { 2 }$ is its variance. (This is equivalent to Gaussian discriminant analysis using diagonal covariance matrices.)

# 9.3.2 Model fitting

In this section, we discuss how to fit a naive Bayes classifier using maximum likelihood estimation. We can write the likelihood as follows:

$$
\begin{array} { l } { { \displaystyle p ( { \cal D } | \theta ) = \prod _ { n = 1 } ^ { N _ { \mathcal { D } } } \mathrm { C a t } ( y _ { n } | \pi ) \prod _ { d = 1 } ^ { D } p ( x _ { n d } | y _ { n } , \theta _ { d } ) } } \\ { { \displaystyle ~ = \prod _ { n = 1 } ^ { N _ { \mathcal { D } } } \mathrm { C a t } ( y _ { n } | \pi ) \prod _ { d = 1 } ^ { D } \prod _ { c = 1 } ^ { C } p ( x _ { n d } | \theta _ { d , c } ) ^ { \mathbb { I } ( y _ { n } = c ) } } } \end{array}
$$

so the log-likelihood is given by

$$
\log p ( \mathcal { D } | \theta ) = \left[ \sum _ { n = 1 } ^ { N _ { \mathcal { D } } } \sum _ { c = 1 } ^ { C } \mathbb { I } \left( y _ { n } = c \right) \log \pi _ { c } \right] + \sum _ { c = 1 } ^ { C } \sum _ { d = 1 } ^ { D } \left[ \sum _ { n : y _ { n } = c } \log p ( x _ { n d } | \theta _ { d c } ) \right]
$$

We see that this decomposes into a term for $\pi$ , and $\ C D$ terms for each $\pmb { \theta } _ { d c }$ :

$$
\log p ( \mathcal { D } | \pmb { \theta } ) = \log p ( \mathcal { D } _ { y } | \pmb { \pi } ) + \sum _ { c } \sum _ { d } \log p ( \mathcal { D } _ { d c } | \pmb { \theta } _ { d c } )
$$

where $\mathcal { D } _ { y } = \{ y _ { n } : n = 1 : N \}$ are all the labels, and $\mathcal { D } _ { d c } = \{ x _ { n d } : y _ { n } = c \}$ are all the values of feature $d$ for examples from class $c$ . Hence we can estimate these parameters separately.

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

In Section 4.2.4, we show that the MLE for $\pi$ is the vector of empirical counts, $\begin{array} { r } { \hat { \pi } _ { c } = \frac { N _ { c } } { N } } \end{array}$ . The MLEs for $\theta _ { d c }$ depend on the choice of the class conditional density for feature $d$ . We discuss some common choices below.

• In the case of discrete features, we can use a categorical distribution. A straightforward extension of the results in Section 4.2.4 gives the following expression for the MLE:

$$
\hat { \theta } _ { d c k } = \frac { N _ { d c k } } { \sum _ { k ^ { \prime } = 1 } ^ { K } N _ { d c k ^ { \prime } } } = \frac { N _ { d c k } } { N _ { c } }
$$

where $\begin{array} { r } { N _ { d c k } = \sum _ { n = 1 } ^ { N } \mathbb { I } \left( x _ { n d } = k , y _ { n } = c , \right. } \end{array}$ ) is the number of times that feature $d$ had value $k$ in examples of class $c$ .

• In the case of binary features, the categorical distribution becomes the Bernoulli, and the MLE becomes

$$
\hat { \theta } _ { d c } = \frac { N _ { d c } } { N _ { c } }
$$

which is the empirical fraction of times that feature $d$ is on in examples of class $c$ .

• In the case of real-valued features, we can use a Gaussian distribution. A straightforward extension of the results in Section 4.2.5 gives the following expression for the MLE:

$$
\begin{array} { l } { \displaystyle { \hat { \mu } _ { d c } = \frac { 1 } { N _ { c } } \sum _ { n : y _ { n } = c } x _ { n d } } } \\ { \displaystyle { \hat { \sigma } _ { d c } ^ { 2 } = \frac { 1 } { N _ { c } } \sum _ { n : y _ { n } = c } ( x _ { n d } - \hat { \mu } _ { d c } ) ^ { 2 } } } \end{array}
$$

Thus we see that fitting a naive Bayes classifier is extremely simple and efficient.

# 9.3.3 Bayesian naive Bayes

In this section, we extend our discussion of MLE estimation for naive Bayes classifiers from Section 9.3.2 to compute the posterior distribution over the parameters. For simplicity, let us assume we have categorical features, so $p ( x _ { d } | \pmb { \theta } _ { d c } ) = \mathrm { C a t } ( x _ { d } | \pmb { \theta } _ { d c } )$ , where $\theta _ { d c k } = p ( x _ { d } = k | y = c )$ . In Section 4.6.3.2, we show that the conjugate prior for the categorical likelihood is the Dirichlet distribution, $p ( \pmb { \theta } _ { d c } ) =$ $\operatorname { D i r } ( \pmb { \theta } _ { d c } | \beta _ { d c } )$ , where $\beta _ { d c k }$ can be interpereted as a set of “pseudo counts”, corresponding to counts $N _ { d c k }$ that come from prior data. Similarly we use a Dirichlet prior for the label frequencies, $p ( { \pmb \pi } ) = \operatorname { D i r } ( { \pmb \pi } | { \pmb \alpha } )$ . By using a conjugate prior, we can compute the posterior in closed form, as we explain in Section 4.6.3. In particular, we have

$$
p ( \pmb \theta | \mathcal { D } ) = \mathrm { D i r } ( \pi | \hat { \alpha } ) \prod _ { d = 1 } ^ { D } \prod _ { c = 1 } ^ { C } \mathrm { D i r } ( \pmb \theta _ { d c } | \hat { \beta } _ { d c } )
$$

where $\widehat { \alpha } _ { c } = \breve { \alpha } _ { c } + N _ { c }$ and $\stackrel { \triangledown } { \beta } _ { d c k } = \stackrel { \triangledown } { \beta } _ { d c k } + N _ { d c k }$ .

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

Using the results from Section 4.6.3.4, we can derive the posterior predictive distribution as follows. The prior over the label is given by $p ( y | \mathcal { D } ) = \operatorname { C a t } ( y | \overline { { \pi } } )$ , where $\overline { { \pi } } _ { c } = \widehat { \alpha } _ { c } \mathrm { ~ / ~ } \sum _ { c ^ { \prime } } \widehat { \alpha } _ { c ^ { \prime } }$ . For the features, we have $p ( x _ { d } = k | y = c , D ) = \overline { { \theta } } _ { d c k }$ , where

$$
\overline { { { \theta } } } _ { d c k } = \frac { \widehat { \beta } _ { d c k } } { \sum _ { k ^ { \prime } } \widehat { \beta } _ { d c k ^ { \prime } } } = \frac { \breve { \beta } _ { d c k } + N _ { d c k } } { \sum _ { k ^ { \prime } } \breve { \beta } _ { d c k ^ { \prime } } + N _ { d c k ^ { \prime } } }
$$

is the posterior mean of the parameters.

If $\breve { \beta } _ { d c k } = 0$ , this reduces to the MLE in Equation (9.52). By contrast, if we set $\breve { \beta } _ { d c k } = 1$ , we add 1 to all the empirical counts before normalizing. This is called add-one smoothing or Laplace smoothing. For example, in the binary case, this gives

$$
\overline { { { \theta } } } _ { d c } = \frac { \overline { { { \beta } } } _ { d c 1 } + N _ { d c 1 } } { \overline { { { \beta } } } _ { d c 0 } + N _ { d c 0 } + \overline { { { \beta } } } _ { d c 1 } + N _ { d c 1 } } = \frac { 1 + N _ { d c 1 } } { 2 + N _ { c } }
$$

Once we have estimated the parameter posterior, we can compute the predicted distribution over the label as follows:

$$
p ( y = c | \pmb { x } , \mathcal { D } ) \propto p ( y = c | \mathcal { D } ) \prod _ { d } p ( x _ { d } | y = c , \mathcal { D } ) = \overline { { \pi } } _ { c } \prod _ { d } \prod _ { k } \overline { { \theta } } _ { d c k } ^ { \mathbb { I } ( x _ { d } = k ) }
$$

This gives us a fully Bayesian form of naive Bayes, in which we have integrated out all the parameters. (In this case, the predictive distribution can be obtained merely by plugging in the posterior mean parameters.)

# 9.3.4 The connection between naive Bayes and logistic regression

In this section, we show that the class posterior $p ( \boldsymbol { y } | \boldsymbol { x } , \boldsymbol { \theta } )$ for a NBC model has the same form as multinomial logistic regression. For simplicity, we assume that the features are all discrete, and each has $K$ states, although the result holds for arbitrary feature distributions in the exponential family. Let $x _ { d k } = \mathbb { I } \left( x _ { d } = k \right)$ , so ${ \pmb x } _ { d }$ is a one-hot encoding of feature $d$ . Then the class conditional density can be written as follows:

$$
p ( \pmb { x } | y = c , \pmb { \theta } ) = \prod _ { d = 1 } ^ { D } \mathrm { C a t } ( x _ { d } | y = c , \pmb { \theta } ) = \prod _ { d = 1 } ^ { D } \prod _ { k = 1 } ^ { K } \theta _ { d c k } ^ { x _ { d k } }
$$

Hence the posterior over classes is given by

$$
p ( y = c | \pmb { x } , \pmb { \theta } ) = \frac { \pi _ { c } \prod _ { d } \prod _ { k } \theta _ { d c k } ^ { x _ { d k } } } { \sum _ { c ^ { \prime } } \pi _ { c ^ { \prime } } \prod _ { d } \prod _ { k } \theta _ { d c ^ { \prime } k } ^ { x _ { d k } } } = \frac { \exp [ \log \pi _ { c } + \sum _ { d } \sum _ { k } x _ { d k } \log \theta _ { d c k } ] } { \sum _ { c ^ { \prime } } \exp [ \log \pi _ { c ^ { \prime } } + \sum _ { d } \sum _ { k } x _ { d k } \log \theta _ { d c ^ { \prime } k } ] } .
$$

This can be written as a softmax

$$
p ( y = c | \pmb { x } , \pmb { \theta } ) = \frac { e ^ { \pmb { \beta } _ { c } ^ { \top } \pmb { x } + \gamma _ { c } } } { \sum _ { c ^ { \prime } = 1 } ^ { C } e ^ { \pmb { \beta } _ { c ^ { \prime } } ^ { \top } \pmb { x } + \gamma _ { c ^ { \prime } } } }
$$

by suitably defining $\beta _ { c }$ and $\gamma _ { c }$ . This has exactly the same form as multinomial logistic regression in Section 2.5.3. The difference is that with naive Bayes we optimize the joint likelihood $\begin{array} { r l } {  { \prod _ { n } p ( y _ { n } , \pmb { x } _ { n } | \pmb { \theta } ) } } \end{array}$ , whereas with logistic regression, we optimize the conditional likelihood $\begin{array} { r l } {  { \prod _ { n } p ( y _ { n } | \pmb { x } _ { n } , \pmb \theta ) } } \end{array}$ . In general, these can give different results (see Exercise 10.3).

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

![](images/839f6b454fd3dcbafe104f547b49e4a5596ae24ec5fa9ba1d45d9f213c46fd82.jpg)  
Figure 9.8: The class-conditional densities $p ( x | y = c )$ (left) may be more complex than the class posteriors $p ( y = c | x )$ (right). Adapted from Figure 1.27 of [Bis06]. Generated by generativeVsDiscrim.ipynb.

# 9.4 Generative vs discriminative classifiers

A model of the form $p ( { \pmb x } , y ) = p ( y ) p ( { \pmb x } | y )$ is called a generative classifier, since it can be used to generate examples $_ { x }$ from each class $y$ . By contrast, a model of the form $p ( \boldsymbol { y } | \boldsymbol { x } )$ is called a discriminative classifier, since it can only be used to discriminate between different classes. Below we discuss various pros and cons of the generative and discriminative approaches to classification. (See also [BT04; UB05; LBM06; BL07a; Rot+18].)

# 9.4.1 Advantages of discriminative classifiers

The main advantages of discriminative classifiers are as follows:

• Better predictive accuracy. Discriminative classifiers are often much more accurate than generative classifiers [NJ02]. The reason is that the conditional distribution $p ( \boldsymbol { y } | \boldsymbol { x } )$ is often much simpler (and therefore easier to learn) than the joint distribution $p ( \boldsymbol { y } , \pmb { x } )$ , as illustrated in Figure 9.8. In particular, discriminative models do not need to “waste effort” modeling the distribution of the input features.

• Can handle feature preprocessing. A big advantage of discriminative methods is that they allow us to preprocess the input in arbitrary ways. For example, we can perform a polynomial expansion of the input features, and we can replace a string of words with embedding vectors (see Section 20.5). It is often hard to define a generative model on such pre-processed data, since the new features can be correlated in complex ways which are hard to model.

• Well-calibrated probabilities. Some generative classifiers, such as naive Bayes (described in Section 9.3), make strong independence assumptions which are often not valid. This can result in very extreme posterior class probabilities (very near 0 or 1). Discriminative models, such as logistic regression, are often better calibrated in terms of their probability estimates, although they also sometimes need adjustment (see e.g., [NMC05]).

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

# 9.4.2 Advantages of generative classifiers

The main advantages of generative classifiers are as follows:

• Easy to fit. Generative classifiers are often very easy to fit. For example, in Section 9.3.2, we show how to fit a naive Bayes classifier by simple counting and averaging. By contrast, logistic regression requires solving a convex optimization problem (see Section 10.2.3 for the details), and neural nets require solving a non-convex optimization problem, both of which are much slower.   
• Can easily handle missing input features. Sometimes some of the inputs (components of $_ { x }$ ) are not observed. In a generative classifier, there is a simple method for dealing with this, as we show in Section 1.5.5. However, in a discriminative classifier, there is no principled solution to this problem, since the model assumes that $_ x$ is always available to be conditioned on.   
• Can fit classes separately. In a generative classifier, we estimate the parameters of each class conditional density independently (as we show in Section 9.3.2), so we do not have to retrain the model when we add more classes. In contrast, in discriminative models, all the parameters interact, so the whole model must be retrained if we add a new class.   
• Can handle unlabeled training data. It is easy to use generative models for semi-supervised learning, in which we combine labeled data $\mathcal { D } _ { x y } = \{ ( { \pmb x } _ { n } , y _ { n } ) \}$ and unlabeled data, ${ \mathcal { D } } _ { x } = \{ { \pmb x } _ { n } \}$ . However, this is harder to do with discriminative models, since there is no uniquely optimal way to exploit $\mathcal { D } _ { x }$ .   
• May be more robust to spurious features. A discriminative model $p ( \boldsymbol { y } | \boldsymbol { x } )$ may pick up on features of the input $_ { x }$ that can discriminate different values of $y$ in the training set, but which are not robust and do not generalize beyond the training set. These are called spurious features (see e.g., [Arj21; Zho+21]). By contrast, a generative model $p ( { \pmb x } | { \pmb y } )$ may be better able to capture the causal mechanisms of the underlying data generating process; such causal models can be more robust to distribution shift (see e.g., [Sch19; LBS19; LN81]).

# 9.4.3 Handling missing features

Sometimes we are missing parts of the input $_ { x }$ during training and/or testing. In a generative classifier, we can handle this situation by marginalizing out the missing values. (We assume that the missingness of a feature is not informative about its potential value.) By contrast, when using a discriminative model, there is no unique best way to handle missing inputs, as we discuss in Section 1.5.5.

For example, suppose we are missing the value of $x _ { 1 }$ . We just have to compute

$$
\begin{array} { l } { { \displaystyle p ( y = c | \pmb { x } _ { 2 : D } , \pmb { \theta } ) \propto p ( y = c | \pmb { \pi } ) p ( \pmb { x } _ { 2 : D } | y = c , \pmb { \theta } ) } } \\ { { \displaystyle \ = p ( y = c | \pmb { \pi } ) \sum _ { x _ { 1 } } p ( x _ { 1 } , \pmb { x } _ { 2 : D } | y = c , \pmb { \theta } ) } } \end{array}
$$

In Gaussian discriminant analysis, we can marginalize out $x _ { 1 }$ using the equations from Section 3.2.3

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

If we make the naive Bayes assumption, things are even easier, since we can just ignore the likelihood term for $x _ { 1 }$ . This follows because

$$
\sum _ { x _ { 1 } } p ( x _ { 1 } , x _ { 2 : D } | y = c , \pmb \theta ) = \left[ \sum _ { x _ { 1 } } p ( x _ { 1 } | \pmb \theta _ { 1 c } ) \right] \prod _ { d = 2 } ^ { D } p ( x _ { d } | \pmb \theta _ { d c } ) = \prod _ { d = 2 } ^ { D } p ( x _ { d } | \pmb \theta _ { d c } )
$$

where we exploited the fact that $\begin{array} { r } { \sum _ { x _ { 1 } } p ( x _ { 1 } | y = c , \pmb { \theta } _ { 1 c } ) = 1 } \end{array}$ .

# 9.5 Exercises

Exercise 9.1 [Derivation of Fisher’s linear discriminant] Swhoerwe i.mHuinmt:ofr $\begin{array} { r } { J ( \pmb { w } ) = \frac { \pmb { w } ^ { T } \mathbf { S } _ { B } \pmb { w } } { \pmb { w } ^ { T } \mathbf { S } _ { W } \pmb { w } } } \end{array}$ isvagtiivenobfya $\mathbf { S } _ { B } \pmb { w } = \lambda \mathbf { S } _ { W } \pmb { w }$ calars is given by $\begin{array} { r } { \lambda = \frac { { \pmb w } ^ { T } { \bf S } _ { B } { \pmb w } } { { \pmb w } ^ { T } { \bf S } _ { W } { \pmb w } } } \end{array}$ $\begin{array} { r } { \frac { d } { d x } \frac { f ( x ) } { g ( x ) } = \frac { f ^ { \prime } g - f g ^ { \prime } } { g ^ { 2 } } } \end{array}$ where $\begin{array} { r } { f ^ { \prime } = \frac { d } { d x } f ( x ) } \end{array}$ and $\begin{array} { r } { g ^ { \prime } = \frac { d } { d x } g ( x ) } \end{array}$ . Also, recall that $\begin{array} { r } { \frac { d } { d { \bf x } } { \bf x } ^ { T } { \bf A } { \bf x } = ( { \bf A } + { \bf A } ^ { T } ) { \bf x } } \end{array}$ .

# 10 Logistic Regression

# 10.1 Introduction

Logistic regression is a widely used discriminative classification model $p ( \boldsymbol { y } | \boldsymbol { x } ; \boldsymbol { \theta } )$ , where $\pmb { x } \in \mathbb { R } ^ { D }$ is a fixed-dimensional input vector, $y \in \{ 1 , \ldots , C \}$ is the class label, and $\pmb \theta$ are the parameters. If $C = 2$ , this is known as binary logistic regression, and if $C > 2$ , it is known as multinomial logistic regression, or alternatively, multiclass logistic regression. We give the details below.

# 10.2 Binary logistic regression

Binary logistic regression corresponds to the following model

$$
p ( \boldsymbol { y } | \mathbf { \boldsymbol { x } } ; \mathbf { \boldsymbol { \theta } } ) = \mathrm { B e r } ( \boldsymbol { y } | \sigma ( \mathbf { \boldsymbol { w } } ^ { \top } \mathbf { \boldsymbol { x } } + b ) )
$$

where $\sigma$ is the sigmoid function defined in Section 2.4.2, $\mathbf { \boldsymbol { w } }$ are the weights, $b$ is the bias, and $\pmb \theta = ( \pmb w , b )$ are all the parameters. In other words,

$$
p ( y = 1 | x ; \pmb \theta ) = \sigma ( a ) = \frac { 1 } { 1 + e ^ { - a } }
$$

where $a = \pmb { w } ^ { 1 } \pmb { x } + b$ is the log-odds, $\log ( p / 1 - p )$ , where $p = p ( y = 1 | \boldsymbol { x } ; \boldsymbol { \theta } )$ , as explained in Section 2.4.2. (In ML, the quantity $a$ is usually called the logit or the pre-activation.)

Sometimes we choose to use the labels $\tilde { y } \in \{ - 1 , + 1 \}$ instead of $y \in \{ 0 , 1 \}$ . We can compute the probability of these alternative labels using

$$
p ( \tilde { y } | x , \pmb \theta ) = \sigma ( \tilde { y } a )
$$

since $\sigma ( - a ) = 1 - \sigma ( a )$ . This slightly more compact notation is widely used in the ML literature.

# 10.2.1 Linear classifiers

The sigmoid gives the probability that the class label is $y = 1$ . If the loss for misclassifying each class is the same, then the optimal decision rule is to predict $y = 1$ iff class 1 is more likely than class $0$ , as we explained in Section 5.1.2.2. Thus

$$
f ( \pmb { x } ) = \mathbb { I } \left( p ( y = 1 | \pmb { x } ) > p ( y = 0 | \pmb { x } ) \right) = \mathbb { I } \left( \log \frac { p ( y = 1 | \pmb { x } ) } { p ( y = 0 | \pmb { x } ) } > 0 \right) = \mathbb { I } \left( a > 0 \right)
$$

![](images/53258cda80f902536dbb3e73dd0414acd798c69905387bac45f5f45a642c84d0.jpg)  
Figure 10.1: (a) Visualization of a 2d plane in a 3d space with surface normal w going through point $\pmb { x } _ { 0 } = ( x _ { 0 } , y _ { 0 } , z _ { 0 } )$ . See text for details. (b) Visualization of optimal linear decision boundary induced by logistic regression on a 2-class, 2-feature version of the iris dataset. Generated by iris_logreg.ipynb. Adapted from Figure 4.24 of [Gér19].

where $\boldsymbol { a } = \boldsymbol { w } ^ { \intercal } \boldsymbol { x } + \boldsymbol { b }$ .

Thus we can write the prediction function as follows:

$$
\boldsymbol { f } ( \boldsymbol { x } ; \boldsymbol { \theta } ) = \boldsymbol { b } + \boldsymbol { w ^ { \intercal } } \boldsymbol { x } = \boldsymbol { b } + \sum _ { d = 1 } ^ { D } w _ { d } x _ { d }
$$

where $\pmb { w } ^ { \top } \pmb { x } = \langle \pmb { w } , \pmb { x } \rangle$ is the inner product between the weight vector $\mathbf { \boldsymbol { w } }$ and the feature vector $_ { x }$ . This function defines a linear hyperplane, with normal vector ${ \pmb w } \in \mathbb { R } ^ { D }$ and an offset $b \in \mathbb { R }$ from the origin.

Equation (10.5) can be understood by looking at Figure 10.1a. Here we show a plane in a 3d feature space going through the point $\scriptstyle { \mathbf { x } } _ { 0 }$ with surface normal $\mathbf { \boldsymbol { w } }$ . Points on the surface satisfy ${ \pmb w } ^ { \mathrm { I } } ( { \pmb x } - { \pmb x } _ { 0 } ) = 0$ . If we define $b = - \pmb { w } ^ { \top } \pmb { x } _ { 0 }$ , we can rewrite this as ${ \pmb w } ^ { \mathrm { 1 } } { \pmb x } + b = 0$ . This plane separates 3d space into two half spaces. This linear plane is known as a decision boundary. If we can perfectly separate the training examples by such a linear boundary (without making any classification errors on the training set), we say the data is linearly separable. From Figure 10.1b, we see that the two-class, two-feature version of the iris dataset is not linearly separable.

In general, there will be uncertainty about the correct class label, so we need to predict a probability distribution over labels, and not just decide which side of the decision boundary we are on. In Figure 10.2, we plot $p ( y = 1 | x _ { 1 } , x _ { 2 } ; \pmb { w } ) = \sigma ( w _ { 1 } x _ { 1 } + w _ { 2 } x _ { 2 } )$ for different weight vectors $\mathbf { \boldsymbol { w } }$ . The vector $\mathbf { \boldsymbol { w } }$ defines the orientation of the decision boundary, and its magnitude, $| | \boldsymbol { w } | | = \sqrt { \sum _ { d = 1 } ^ { D } w _ { d } ^ { 2 } }$ , controls the steepness of the sigmoid, and hence the confidence of the predictions.

# 10.2.2 Nonlinear classifiers

We can often make a problem linearly separable by preprocessing the inputs in a suitable way. In particular, let $\phi ( { \pmb x } )$ be a transformed version of the input feature vector. For example, suppose we use $\phi ( x _ { 1 } , x _ { 2 } ) = [ 1 , x _ { 1 } ^ { 2 } , x _ { 2 } ^ { 2 } ]$ , and we let ${ \pmb w } = [ - R ^ { 2 } , 1 , 1 ]$ . Then ${ \pmb w } ^ { 1 } \phi ( { \pmb x } ) = x _ { 1 } ^ { 2 } + x _ { 2 } ^ { 2 } - R ^ { 2 }$ , so the decision boundary (where $f ( { \pmb x } ) = 0$ ) defines a circle with radius $R$ , as shown in Figure 10.3. The resulting

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022 function $f$ is still linear in the parameters $\mathbf { \boldsymbol { w } }$ , which is important for simplifying the learning problem, as we will see in Section 10.2.3. However, we can gain even more power by learning the parameters of the feature extractor $\phi ( { \pmb x } )$ in addition to linear weights $\mathbf { \boldsymbol { w } }$ ; we discuss how to do this in Part III.

![](images/fc8663fe05fe766070d6ea39ff195289eaa9e7a76c4a01a953ebaa1fb0087840.jpg)  
Figure 10.2: Plots of $\sigma ( w _ { 1 } x _ { 1 } + w _ { 2 } x _ { 2 } )$ . Here $\pmb { w } = ( w _ { 1 } , w _ { 2 } )$ defines the normal to the decision boundary. Points to the right of this have $\sigma ( { \pmb w } ^ { \top } { \pmb x } ) > 0 . 5$ , and points to the left have $\sigma ( \pmb { w } ^ { \top } \pmb { x } ) < 0 . 5$ . Adapted from Figure 39.3 of [Mac03]. Generated by sigmoid_ ${ \mathit { 2 d } } _ { - }$ plot.ipynb.

![](images/3c985fa853a39435f8a4918e9fd14ebf59dea03315b92fedb2fd385a1922e692.jpg)  
Figure 10.3: Illustration of how we can transform a quadratic decision boundary into a linear one by transforming the features from ${ \pmb x } = ( x _ { 1 } , x _ { 2 } )$ to $\phi ( \pmb { x } ) = ( x _ { 1 } ^ { 2 } , x _ { 2 } ^ { 2 } )$ . Used with kind permission of Jean-Philippe Vert.

In Figure 10.3, we used a quadratic expansion of the features. We can also use a higher order polynomial, as in Section 1.2.2.2. In Figure 1.7, we show the effects of using polynomial expansion up to degree $K$ on a 2d logistic regression problem. As in Figure 1.7, we see that the model becomes more complex as the number of parameters increases, and eventually results in overfitting. We discuss ways to reduce overfitting in Section 10.2.7.

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

# 10.2.3 Maximum likelihood estimation

In this section, we discuss how to estimate the parameters of a logistic regression model using maximum likelihood estimation.

# 10.2.3.1 Objective function

The negative log likelihood (scaled by the dataset size $N$ ) is given by the following (we assume the bias term $b$ is absorbed into the weight vector $\mathbf { \boldsymbol { w } }$ ):

$$
\begin{array} { l } { { \displaystyle \mathrm { N L } ( w ) = - \frac 1 N \log p ( \mathcal { D } | w ) = - \frac 1 N \log \prod _ { n = 1 } ^ { N } \log \prod _ { n = 1 } ^ { N } \mu _ { n } ) } } \\ { ~ = - \frac 1 N \displaystyle \sum _ { n = 1 } ^ { N } \log [ \mu _ { n } ^ { y _ { n } } \times ( 1 - \mu _ { n } ) ^ { 1 - y _ { n } } ] } \\ { ~ = - \frac 1 N \displaystyle \sum _ { n = 1 } ^ { N } \left[ y _ { n } \log \mu _ { n } + ( 1 - y _ { n } ) \log ( 1 - \mu _ { n } ) \right] } \\ { ~ = \frac 1 N \displaystyle \sum _ { n = 1 } ^ { N } \mathbb { I } _ { \leq \epsilon } ( y _ { n } , \mu _ { n } ) } \end{array}
$$

where $\mu _ { n } = \sigma ( a _ { n } )$ is the probability of class $^ { 1 }$ , $a _ { n } = \pmb { w } ^ { \top } \pmb { x } _ { n }$ is the logit, and $\mathbb { H } _ { c e } ( y _ { n } , \mu _ { n } )$ is the binary cross entropy defined by

$$
\mathbb { H } _ { c e } ( p , q ) = - \left[ p \log q + ( 1 - p ) \log ( 1 - q ) \right]
$$

If we use $\tilde { y } _ { n } \in \{ - 1 , + 1 \}$ instead of $y _ { n } \in \{ 0 , 1 \}$ , then we can rewrite this as follows:

$$
\begin{array} { l } { { \displaystyle \mathrm { N L L } ( \boldsymbol { w } ) = - \frac { 1 } { N } \sum _ { n = 1 } ^ { N } \bigl [ \mathbb { I } \left( \tilde { y } _ { n } = 1 \right) \log ( \sigma ( a _ { n } ) ) + \mathbb { I } \left( \tilde { y } _ { n } = - 1 \right) \log ( \sigma ( - a _ { n } ) ) \bigr ] } \ ~ } \\ { { \displaystyle ~ = - \frac { 1 } { N } \sum _ { n = 1 } ^ { N } \log ( \sigma \bigl ( \tilde { y } _ { n } a _ { n } \bigr ) ) } \ ~ } \\ { { \displaystyle ~ = \frac { 1 } { N } \sum _ { n = 1 } ^ { N } \log ( 1 + \exp ( - \tilde { y } _ { n } a _ { n } ) ) } } \end{array}
$$

However, in this book, we will mostly use the $y _ { n } \in \{ 0 , 1 \}$ notation, since it is easier to generalize to the multiclass case (Section 10.3), and makes the connection with cross-entropy easier to see.

# 10.2.3.2 Optimizing the objective

To find the MLE, we must solve

$$
\nabla _ { \pmb { w } } \mathrm { N L L } ( \pmb { w } ) = \pmb { g } ( \pmb { w } ) = \pmb { 0 }
$$

We can use any gradient-based optimization algorithm to solve this, such as those we discuss in Chapter 8. We give a specific example in Section 10.2.4. But first we must derive the gradient, as we explain below.

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

![](images/fca86a1c0ce294c90d3fb218d96545d0e0ab3cf8486028a4cccbe6c04590f0e8.jpg)  
Figure 10.4: Polynomial feature expansion applied to a two-class, two-dimensional logistic regression problem. (a) Degree $K = 1$ . (b) Degree $K = 2$ . (c) Degree $K = 4$ . (d) Train and test error vs degree. Generated by logreg_poly_demo.ipynb.

# 10.2.3.3 Deriving the gradient

Although we can use automatic differentiation methods (Section 13.3) to compute the gradient of the NLL, it is also easy to do explicitly, as we show below. Fortunately the resulting equations will turn out to have a simple and intuitive interpretation, which can be used to derive other methods, as we will see.

To start, note that

$$
\frac { d \mu _ { n } } { d a _ { n } } = \sigma ( a _ { n } ) ( 1 - \sigma ( a _ { n } ) )
$$

where $a _ { n } = \pmb { w } ^ { 1 } \pmb { x } _ { n }$ and $\mu _ { n } = \sigma ( a _ { n } )$ . Hence by the chain rule (and the rules of vector calculus, discussed in Section 7.8) we have

$$
\frac { \partial } { \partial w _ { d } } \mu _ { n } = \frac { \partial } { \partial w _ { d } } \sigma ( \boldsymbol { w ^ { \intercal } } \mathbf { x } _ { n } ) = \frac { \partial } { \partial a _ { n } } \sigma ( a _ { n } ) \frac { \partial a _ { n } } { \partial w _ { d } } = \mu _ { n } ( 1 - \mu _ { n } ) x _ { n d }
$$

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

The gradient for the bias term can be derived in the same way, by using the input $x _ { n 0 } = 1$ in the above equation. However, we will ignore the bias term for simplicity. Hence

$$
\nabla _ { \pmb { w } } \log ( \mu _ { n } ) = \frac { 1 } { \mu _ { n } } \nabla _ { \pmb { w } } \mu _ { n } = ( 1 - \mu _ { n } ) \pmb { x } _ { n }
$$

Similarly,

$$
\nabla _ { w } \log ( 1 - \mu _ { n } ) = \frac { - \mu _ { n } ( 1 - \mu _ { n } ) { \pmb x } _ { n } } { 1 - \mu _ { n } } = - \mu _ { n } { \pmb x } _ { n }
$$

Thus the gradient vector of the NLL is given by

$$
\begin{array} { l } { \displaystyle \nabla _ { w } \mathrm { N L L } ( w ) = - \frac { 1 } { N } \sum _ { n = 1 } ^ { N } \big [ y _ { n } ( 1 - \mu _ { n } ) \pmb { x } _ { n } - ( 1 - y _ { n } ) \mu _ { n } \pmb { x } _ { n } \big ] } \\ { \displaystyle = - \frac { 1 } { N } \sum _ { n = 1 } ^ { N } \big [ y _ { n } \pmb { x } _ { n } - y _ { n } \pmb { x } _ { n } \mu _ { n } - \pmb { x } _ { n } \mu _ { n } + y _ { n } \pmb { x } _ { n } \mu _ { n } \big ) \big ] } \\ { \displaystyle = \frac { 1 } { N } \sum _ { n = 1 } ^ { N } ( \mu _ { n } - y _ { n } ) \pmb { x } _ { n } } \end{array}
$$

If we interpret $e _ { n } = \mu _ { n } - y _ { n }$ as an error signal, we can see that the gradient weights each input ${ \boldsymbol { \mathbf { \mathit { x } } } } _ { n }$ by its error, and then averages the result. Note that we can rewrite the gradient in matrix form as follows:

$$
\nabla _ { \pmb { w } } \mathrm { N L L } ( \pmb { w } ) = \frac { 1 } { N } ( \mathbf { 1 } _ { N } ^ { \top } ( \mathrm { d i a g } ( \pmb { \mu } - \pmb { y } ) \mathbf { X } ) ) ^ { \top }
$$

# 10.2.3.4 Deriving the Hessian

Gradient-based optimizers will find a stationary point where $\mathbf { \nabla } _ { \mathbf { \boldsymbol { g } } ( \mathbf { \boldsymbol { w } } ) } = \mathbf { 0 }$ . This could either be a global optimum or a local optimum. To be sure the stationary point is the global optimum, we must show that the objective is convex, for reasons we explain in Section 8.1.1.1. Intuitvely this means that the NLL has a bowl shape, with a unique lowest point, which is indeed the case, as illustrated in Figure 10.5b.

More formally, we must prove that the Hessian is positive semi-definite, which we now do. (See Chapter 7 for relevant background information on linear algebra.) One can show that the Hessian is given by

$$
\mathbf { H } ( \pmb { w } ) = \nabla _ { \pmb { w } } \nabla _ { \pmb { w } } ^ { \mathsf { T } } \mathrm { N L L } ( \pmb { w } ) = \frac { 1 } { N } \sum _ { n = 1 } ^ { N } ( \mu _ { n } ( 1 - \mu _ { n } ) \pmb { x } _ { n } ) \pmb { x } _ { n } ^ { \mathsf { T } } = \frac { 1 } { N } \pmb { X } ^ { \mathsf { T } } \mathbf { S } \mathbf { X }
$$

where

$$
\mathbf { S } \triangleq \operatorname { d i a g } ( \mu _ { 1 } ( 1 - \mu _ { 1 } ) , \dots , \mu _ { N } ( 1 - \mu _ { N } ) )
$$

We see that $\mathbf { H }$ is positive definite, since for any nonzero vector $\mathbf { \nabla } _ { \mathbf { v } }$ , we have

$$
v ^ { \mathsf { T } } \mathbf { X } ^ { \mathsf { T } } \mathbf { S } \mathbf { X } v = ( v ^ { \mathsf { T } } \mathbf { X } ^ { \mathsf { T } } \mathbf { S } ^ { \frac { 1 } { 2 } } ) ( \mathbf { S } ^ { \frac { 1 } { 2 } } \mathbf { X } v ) = | | v ^ { \mathsf { T } } \mathbf { X } ^ { \mathsf { T } } \mathbf { S } ^ { \frac { 1 } { 2 } } | | _ { 2 } ^ { 2 } > 0
$$

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

![](images/8e675e725c9de22053ca5b8077800c10ddb2d45b511f0283d3e47ed9d2af20c9.jpg)  
Figure 10.5: NLL loss surface for binary logistic regression applied to Iris dataset with 1 feature and 1 bias term. The goal is to minimize the function. Generated by iris_logreg_loss_surface.ipynb.

This follows since $\mu _ { n } > 0$ for all $n$ , because of the use of the sigmoid function. Consequently the NLL is strictly convex. However, in practice, values of $\mu _ { n }$ which are close to 0 or 1 might cause the Hessian to be close to singular. We can avoid this by using $\ell _ { 2 }$ regularization, as we discuss in Section 10.2.7.

# 10.2.4 Stochastic gradient descent

Our goal is to solve the following optimization problem

$$
\hat { \pmb { w } } \triangleq \underset { \pmb { w } } { \mathrm { a r g m i n } } \mathcal { L } ( \pmb { w } )
$$

where $\mathcal { L } ( w )$ is the loss function, in this case the negative log likelihood:

$$
\mathrm { N L L } ( \pmb { w } ) = - \frac { 1 } { N } \sum _ { n = 1 } ^ { N _ { D } } \left[ y _ { n } \log \mu _ { n } + \left( 1 - y _ { n } \right) \log ( 1 - \mu _ { n } ) \right]
$$

where $\mu _ { n } = \sigma ( a _ { n } )$ is the probability of class 1, and $a _ { n } = \pmb { w } ^ { \vert } \pmb { x } _ { n }$ is the log odds.

There are many algorithms we could use to solve Equation (10.26), as we discuss in Chapter 8. Perhaps the simplest is to use stochastic gradient descent (Section 8.4). If we use a minibatch of size $^ { 1 }$ , then we get the following simple update equation:

$$
\pmb { w } _ { t + 1 } = \pmb { w } _ { t } - \eta _ { t } \nabla _ { \pmb { w } } \mathrm { N L L } ( \pmb { w } _ { t } ) = \pmb { w } _ { t } - \eta _ { t } ( \mu _ { n } - y _ { n } ) \pmb { x } _ { n }
$$

where we replaced the average over all $N$ examples in the gradient of Equation (10.21) with a single stochastically chosen sample $n$ . (The index $n$ changes with $t$ .)

Since we know the objective is convex (see Section 10.2.3.4), then one can show that this procedure will converge to the global optimum, provided we decay the learning rate at the appropriate rate (see Section 8.4.3). We can improve the convergence speed using variance reduction techniques such as SAGA (Section 8.4.5.2).

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

# 10.2.5 Perceptron algorithm

A perceptron, first introduced in [Ros58], is a deterministic binary classifier of the following form:

$$
\begin{array} { r } { f ( \pmb { x } _ { n } ; \pmb { \theta } ) = \mathbb { I } \left( \pmb { w } ^ { \top } \pmb { x } _ { n } + b > 0 \right) } \end{array}
$$

This can be seen to be a limiting case of a binary logistic regression classifier, in which the sigmoid function $\sigma ( a )$ is replaced by the Heaviside step function $H ( a ) \triangleq \mathbb { I } ( a > 0 )$ . See Figure 2.10 for a comparison of these two functions.

Since the Heaviside function is not differentiable, we cannot use gradient-based optimization methods to fit this model. However, Rosenblatt proposed the perceptron learning algorithm instead. The basic idea is to start with random weights, and then iteratively update them whenever the model makes a prediction mistake. More precisely, we update the weights using

$$
{ \pmb w } _ { t + 1 } = { \pmb w } _ { t } - \eta _ { t } ( \hat { y } _ { n } - y _ { n } ) { \pmb x } _ { n }
$$

where $( { \pmb x } _ { n } , y _ { n } )$ is the labeled example sampled at iteration $t$ , and $\eta _ { t }$ is the learning rate or step size. (We can set the step size to 1, since the magnitude of the weights does not affect the decision boundary.) See perceptron_demo_2d.ipynb for a simple implementation of this algorithm.

The perceptron update rule in Equation (10.30) has an intuitive interpretation: if the prediction is correct, no change is made, otherwise we move the weights in a direction so as to make the correct answer more likely. More precisely, if $y _ { n } = 1$ and ${ \hat { y } } _ { n } = 0$ , we have $\pmb { w } _ { t + 1 } = \pmb { w } _ { t } + \pmb { x } _ { n }$ , and if $y _ { n } = 0$ and ${ \hat { y } } _ { n } = 1$ , we have ${ \pmb w } _ { t + 1 } = { \pmb w } _ { t } - { \pmb x } _ { n }$ .

By comparing Equation (10.30) to Equation (10.28), we see that the perceptron update rule is equivalent to the SGD update rule for binary logistic regression using the approximation where we replace the soft probabilities $\mu _ { n } = p ( y _ { n } = 1 | x _ { n } )$ with hard labels ${ \hat { y } } _ { n } = f ( \mathbf { x } _ { n } )$ . The advantage of the perceptron method is that we don’t need to compute probabilities, which can be useful when the label space is very large. The disadvantage is that the method will only converge when the data is linearly separable [Nov62], whereas SGD for minimizing the NLL for logistic regression will always converge to the globally optimal MLE, even if the data is not linearly separable.

In Section 13.2, we will generalize perceptrons to nonlinear functions, thus significantly enhancing their usefulness.

# 10.2.6 Iteratively reweighted least squares

Gradient descent is a first order optimization method, which means it only uses first order gradients to navigate through the loss landscape. This can be slow, especially when some directions of space point steeply downhill, whereas other have a shallower gradient, as is the case in Figure 10.5a. In such problems, it can be much faster to use a second order optimization method, that takes the curvature of the space into account.

We discuss such methods in more detail in Section 8.3. Here we just consider a simple second order method that works well for logistic regression. We focus on the full batch setting (so we assume $N$ is small), since it is harder to make second order methods work in the stochastic setting (see e.g., [Byr+16; Liu+18b] for some methods).

The classic second-order method is Newton’s method. This consists of updates of the form

$$
\mathbf { \boldsymbol { w } } _ { t + 1 } = \mathbf { \boldsymbol { w } } _ { t } - \eta _ { t } \mathbf { \boldsymbol { H } } _ { t } ^ { - 1 } \mathbf { \boldsymbol { g } } _ { t }
$$

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

where

$$
\mathbf { H } _ { t } \triangleq \nabla ^ { 2 } \mathcal { L } ( \pmb { w } ) | _ { \pmb { w } _ { t } } = \nabla ^ { 2 } \mathcal { L } ( \pmb { w } _ { t } ) = \mathbf { H } ( \pmb { w } _ { t } )
$$

is assumed to be positive-definite to ensure the update is well-defined. If the Hessian is exact, we can set the step size to $\eta _ { t } = 1$ .

We now apply this method to logistic regression. Recall from Section 10.2.3.3 that the gradient and Hessian are given by

$$
\begin{array} { l } { \displaystyle \nabla _ { \boldsymbol { w } } \mathrm { N L L } ( \boldsymbol { w } ) = \frac { 1 } { N } \sum _ { n = 1 } ^ { N } ( \mu _ { n } - y _ { n } ) \boldsymbol { x } _ { n } } \\ { \displaystyle \mathbf { H } = \frac { 1 } { N } \mathbf { X } ^ { \mathsf { T } } \mathbf { S } \mathbf { X } } \\ { \displaystyle \mathbf { S } \triangleq \mathrm { d i a g } ( \mu _ { 1 } ( 1 - \mu _ { 1 } ) , \dots , \mu _ { N } ( 1 - \mu _ { N } ) ) } \end{array}
$$

Hence the Newton update has the form

$$
\begin{array} { r l } & { \pmb { w } _ { t + 1 } = \pmb { w } _ { t } - \mathbf { H } ^ { - 1 } \pmb { g } _ { t } } \\ & { \qquad = \pmb { w } _ { t } + ( \mathbf { X } ^ { \mathsf { T } } \mathbf { S } _ { t } \mathbf { X } ) ^ { - 1 } \mathbf { X } ^ { \mathsf { T } } ( \pmb { y } - \pmb { \mu } _ { t } ) } \\ & { \qquad = ( \mathbf { X } ^ { \mathsf { T } } \mathbf { S } _ { t } \mathbf { X } ) ^ { - 1 } \left[ ( \mathbf { X } ^ { \mathsf { T } } \mathbf { S } _ { t } \mathbf { X } ) \pmb { w } _ { t } + \mathbf { X } ^ { \mathsf { T } } ( \pmb { y } - \pmb { \mu } _ { t } ) \right] } \\ & { \qquad = ( \mathbf { X } ^ { \mathsf { T } } \mathbf { S } _ { t } \mathbf { X } ) ^ { - 1 } \mathbf { X } ^ { \mathsf { T } } \left[ \mathbf { S } _ { t } \mathbf { X } \pmb { w } _ { t } + \pmb { y } - \pmb { \mu } _ { t } \right] } \\ & { \qquad = ( \mathbf { X } ^ { \mathsf { T } } \mathbf { S } _ { t } \mathbf { X } ) ^ { - 1 } \mathbf { X } ^ { \mathsf { T } } \mathbf { S } _ { t } z _ { t } } \end{array}
$$

where we have defined the working response as

$$
z _ { t } \triangleq \mathbf { X } w _ { t } + \mathbf { S } _ { t } ^ { - 1 } ( \pmb { y } - \pmb { \mu } _ { t } )
$$

and $\mathbf { S } _ { t } = \mathrm { d i a g } ( \mu _ { t , n } ( 1 - \mu _ { t , n } ) )$ . Since $\mathbf { S } _ { t }$ is a diagonal matrix, we can rewrite the targets in component form as follows:

$$
z _ { t , n } = { \pmb w } _ { t } ^ { \top } { \pmb x } _ { n } + \frac { y _ { n } - \mu _ { t , n } } { \mu _ { t , n } ( 1 - \mu _ { t , n } ) }
$$

Equation (10.40) is an example of a weighted least squares problem (Section 11.2.2.4), which is a minimizer of

$$
\sum _ { n = 1 } ^ { N } S _ { t , n } ( z _ { t , n } - { \pmb w } _ { t } ^ { \top } { \pmb x } _ { n } ) ^ { 2 }
$$

The overall method is therefore known as the iteratively reweighted least squares (IRLS) algorithm, since at each iteration we solve a weighted least squares problem, where the weight matrix $\mathbf { S } _ { t }$ changes at each iteration. See Algorithm 2 for some pseudocode.

Note that Fisher scoring is the same as IRLS except we replace the Hessian of the actual log-likelihood with its expectation, i.e., we use the Fisher information matrix (Section 4.7.2) instead of $\mathbf { H }$ . Since the Fisher information matrix is independent of the data, it can be precomputed, unlike the Hessian, which must be reevaluated at every iteration. This can be faster for problems with many parameters.

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

Algorithm 2: Iteratively reweighted least squares (IRLS)   

<html><body><table><tr><td colspan="2">1 w=0</td></tr><tr><td>2</td><td>repeat for n=1:N do</td></tr><tr><td>3 4</td><td>an =wTxn</td></tr><tr><td>5</td><td>μn=σ(an)</td></tr><tr><td>6</td><td>Sn=μn(1-μn)</td></tr><tr><td>7</td><td>2n=an+yn-n</td></tr><tr><td>8</td><td>Sn S = diag(s1:N)</td></tr><tr><td>9</td><td>w = (xsX)-1xSz</td></tr><tr><td colspan="2">10until converged</td></tr></table></body></html>

# 10.2.7 MAP estimation

In Figure 10.4, we saw how logistic regression can overfit when there are too many parameters compared to training examples. This is a consequence of the ability of maximum likelihood to find weights that force the decision boundary to “wiggle” in just the right way so as to curve around the examples. To get this behavior, the weights often need to be set to large values. For example, in Figure 10.4, when we use degree $K = 1$ , we find that the MLE for the two input weights (ignoring the bias) is

$$
\pmb { \hat { w } } = [ 0 . 5 1 2 9 1 7 1 2 , 0 . 1 1 8 6 6 9 3 7 ]
$$

When we use degree $K = 2$ , we get

wˆ = [2.27510513, 0.05970325, 11.84198867, 15.40355969, 2.51242311]

And when $K = 4$ , we get

$$
{ \hat { w } } = [ - 3 . 0 7 8 1 3 7 6 6 , \cdots , - 5 9 . 0 3 1 9 6 0 4 4 , 5 1 . 7 7 1 5 2 4 3 1 , 1 0 . 2 5 0 5 4 1 6 4 ]
$$

One way to reduce such overfitting is to prevent the weights from becoming so large. We can do this by using a zero-mean Gaussian prior, $p ( \pmb { w } ) = \mathcal { N } ( \pmb { w } | \mathbf { 0 } , C \mathbf { I } )$ , and then using MAP estimation, as we discussed in Section 4.5.3. The new training objective becomes

$$
\begin{array} { r } { \mathcal { L } ( \pmb { w } ) = \mathrm { N L L } ( \pmb { w } ) + \lambda | | \pmb { w } | | _ { 2 } ^ { 2 } } \end{array}
$$

lwahrgereer $\begin{array} { r } { \lvert | \boldsymbol { \mathbf { w } } \rvert | _ { 2 } ^ { 2 } = \sum _ { d = 1 } ^ { D } w _ { d } ^ { 2 } } \end{array}$ eamnodr $\lambda = 1 / C$ . mTehtiesrsisacrae lpeedn $\ell _ { 2 }$ redgfuolrarbieziantg “olnarogre w(ediegvhiat idnegcfaryo.mTthe $\lambda$ zero-mean prior), and thus the less flexible the model. See Figure 10.6 for an illustration.

We can compute the MAP estimate by slightly modifying the input to the above gradient-based optimization algorithms. The gradient and Hessian of the penalized negative log likelihood have the

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

![](images/95fbc29e25c2f95de71a99784856c30bb9a87b9150089835c833668be41ff43a.jpg)  
Figure 10.6: Weight decay with variance $C$ applied to two-class, two-dimensional logistic regression problem with a degree 4 polynomial. (a) $C = 1$ . (b) $C = 3 1 6$ . (c) $C = 1 0 0 , 0 0 0$ . (d) Train and test error vs $C$ . Generated by logreg_poly_demo.ipynb.

following forms:

$$
\begin{array} { c } { \mathrm { P N L L } ( \pmb { w } ) = \mathrm { N L L } ( \pmb { w } ) + \lambda \pmb { w } ^ { \top } \pmb { w } } \\ { \nabla _ { \pmb { w } } \mathrm { P N L L } ( \pmb { w } ) = g ( \pmb { w } ) + 2 \lambda \pmb { w } } \\ { \nabla _ { \pmb { w } } ^ { 2 } \mathrm { P N L L } ( \pmb { w } ) = \mathbf { H } ( \pmb { w } ) + 2 \lambda \mathbf { I } } \end{array}
$$

where $\mathbf g ( \pmb { w } )$ is the gradient and $\mathbf { H } ( w )$ is the Hessian of the unpenalized NLL. For an interesting exercise related to $\ell _ { 2 }$ regularized logistic regression, see Exercise 10.2.

# 10.2.8 Standardization

In Section 10.2.7, we use an isotropic prior $\mathcal { N } ( \pmb { w } | \mathbf { 0 } , \lambda ^ { - 1 } \mathbf { I } )$ to prevent overfitting. This implicitly encodes the assumption that we expect all weights to be similar in magnitude, which in turn encodes the assumption we expect all input features to be similar in magnitude. However, in many datasets, input features are on different scales. In such cases, it is common to standardize the data, to ensure

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license each feature has mean 0 and variance 1. We can do this by subtracting the mean and dividing by the standard deviation of each feature, as follows:

$$
\begin{array} { r } { \mathrm { s t a n d a r d i z e } ( x _ { n d } ) = \displaystyle \frac { x _ { n d } - \hat { \mu } _ { d } } { \hat { \sigma } _ { d } } \qquad } \\ { \hat { \mu } _ { d } = \displaystyle \frac { 1 } { N } \sum _ { n = 1 } ^ { N } x _ { n d } \qquad } \\ { \hat { \sigma } _ { d } ^ { 2 } = \displaystyle \frac { 1 } { N } \sum _ { n = 1 } ^ { N } ( x _ { n d } - \hat { \mu } _ { d } ) ^ { 2 } \qquad } \end{array}
$$

An alternative is to use min-max scaling, in which we rescale the inputs so they lie in the interval $[ 0 , 1 ]$ . Both methods ensure the features are comparable in magnitude, which can help with model fitting and inference, even if we don’t use MAP estimation. (See Section 11.7.5 for a discussion of this point.)

# 10.3 Multinomial logistic regression

Multinomial logistic regression is a discriminative classification model of the following form:

$$
p ( y | \mathbf { \boldsymbol { x } } ; \theta ) = \mathrm { C a t } ( y | \mathrm { s o f t m a x } ( \mathbf { W } \mathbf { \boldsymbol { x } } + b ) )
$$

where $\pmb { x } \in \mathbb { R } ^ { D }$ is the input vector, $y \in \{ 1 , \ldots , C \}$ is the class label, softmax() is the softmax function (Section 2.5.2), $\mathbf { W }$ is a $C \times D$ weight matrix, $^ { b }$ is $C$ -dimensional bias vector, $\pmb \theta = ( \mathbf W , \pmb b )$ are all the parameters. We will henceforth ignore the bias term $^ { b }$ ; we assume we prepend each $_ { x }$ with a $^ { 1 }$ , and add $^ { b }$ to the first column of $\mathbf { W }$ . Thus $\mathbf { \theta } \theta = \mathbf { W }$ .

If we let $\mathbf { \Delta } a = \mathbf { W } \mathbf { \Delta } x$ be the $C$ -dimensional vector of logits, then we can rewrite the above as follows:

$$
p ( y = c | \mathbf { \boldsymbol { x } } ; \mathbf { \boldsymbol { \theta } } ) = \frac { e ^ { a _ { c } } } { \sum _ { c ^ { \prime } = 1 } ^ { C } e ^ { a _ { c ^ { \prime } } } }
$$

Because of the normalization condition cC=1 p(yn = c|xn; θ) = 1, we can set wC = 0. (For example, in binary logistic regression, where $C = 2$ , we only learn a single weight vector.) Therefore the parameters $\pmb \theta$ correspond to a weight matrix $\mathbf { W }$ of size $( C - 1 ) \times D$ , where $\pmb { x } _ { n } \in \mathbb { R } ^ { D }$ .

Note that this model assumes the labels are mutually exclusive, i.e., there is only one true label. For some applications (e.g., image tagging), we want to predict one or more labels for an input; in this case, the output space is the set of subsets of $\{ 1 , \ldots , C \}$ . This is called multi-label classification, as opposed to multi-class classification. This can be viewed as a bit vector, $\mathcal { Y } = \{ 0 , 1 \} ^ { C }$ , where the $c$ ’th output is set to 1 if the $c$ ’th tag is present. We can tackle this using a modified version of binary logistic regression with multiple outputs:

$$
p ( \pmb { y } | \pmb { x } ; \pmb { \theta } ) = \prod _ { c = 1 } ^ { C } \mathrm { B e r } ( y _ { c } | \sigma ( \pmb { w } _ { c } ^ { \top } \pmb { x } ) ) \qquad \
$$

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

![](images/2d095cfe0f3aae80b6181b4fbe5f415e66b1217acaf5862ba5e0bd34a582f919.jpg)  
Figure 10.7: Example of 3-class logistic regression with 2d inputs. (a) Original features. (b) Quadratic features. Generated by logreg_multiclass_demo.ipynb.

# 10.3.1 Linear and nonlinear classifiers

Logistic regression computes linear decision boundaries in the input space, as shown in Figure 10.7(a) for the case where $\pmb { x } \in \mathbb { R } ^ { 2 }$ and we have $C = 3$ classes. However, we can always transform the inputs in some way to create nonlinear boundaries. For example, suppose we replace ${ \pmb x } = ( x _ { 1 } , x _ { 2 } )$ by

$$
\phi ( \pmb { x } ) = [ 1 , x _ { 1 } , x _ { 2 } , x _ { 1 } ^ { 2 } , x _ { 2 } ^ { 2 } , x _ { 1 } x _ { 2 } ]
$$

This lets us create quadratic decision boundaries, as illustrated in Figure 10.7(b).

# 10.3.2 Maximum likelihood estimation

In this section, we discuss how to compute the maximum likelihood estimate (MLE) by minimizing the negative log likelihood (NLL).

# 10.3.2.1 Objective

The NLL is given by

$$
\mathrm { N L L } ( \theta ) = - \frac { 1 } { N } \log \prod _ { n = 1 } ^ { N _ { \mathcal { D } } } \prod _ { c = 1 } ^ { C } \mu _ { n c } ^ { y _ { n c } } = - \frac { 1 } { N } \sum _ { n = 1 } ^ { N _ { \mathcal { D } } } \sum _ { c = 1 } ^ { C } y _ { n c } \log \mu _ { n c } = \frac { 1 } { N } \sum _ { n = 1 } ^ { N } \mathbb { H } _ { c e } ( y _ { n } , \mu _ { n c } ) \log \hat { y } _ { n c } = \frac { 1 } { N } \sum _ { i = 1 } ^ { N } \mathbb { H } _ { c e } ( y _ { i } , \mu _ { i } ) \log \hat { y } _ { i } .
$$

where $\mu _ { n c } = p ( y _ { n c } = 1 | \pmb { x } _ { n } , \pmb { \theta } ) = \mathrm { s o f t m a x } ( f ( \pmb { x } _ { n } ; \pmb { \theta } ) ) _ { c }$ , ${ \bf { \nabla } } \mathbf { \mathbf { { y } } } _ { n }$ is the one-hot encoding of the label (so $y _ { n c } = \mathbb { I } \left( y _ { n } = c \right) )$ ), and $\mathbb { H } _ { c e } ( \pmb { y } _ { n } , \pmb { \mu } _ { n } )$ is the cross-entropy:

$$
\mathbb { H } _ { c e } ( \pmb { p } , \pmb { q } ) = - \sum _ { c = 1 } ^ { C } p _ { c } \log q _ { c }
$$

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

# 10.3.2.2 Optimizing the objective

To find the optimum, we need to solve $\nabla _ { \mathbf { \boldsymbol { w } } } \mathrm { N L L } ( \mathbf { \boldsymbol { w } } ) = \mathbf { 0 }$ , where $\mathbf { \boldsymbol { w } }$ is a vectorized version of the weight matrix W, and where we are ignoring the bias term for notational simplicity. We can find such a stationary point using any gradient-based optimizer; we give some examples below. But first we derive the gradient and Hessian, and then prove that the objective is convex.

# 10.3.2.3 Deriving the gradient

To derive the gradient of the NLL, we need to use the Jacobian of the softmax function, which is as follows (see Exercise 10.1 for the proof):

$$
\frac { \partial \mu _ { c } } { \partial a _ { j } } = \mu _ { c } ( \delta _ { c j } - \mu _ { j } )
$$

where $\delta _ { c j } = \mathbb { I } \left( c = j \right)$ . For example, if we have 3 classes, the Jacobian matrix is given by

$$
\left[ \frac { \partial \mu _ { c } } { \partial a _ { j } } \right] _ { c j } = \left( \begin{array} { c c c } { \mu _ { 1 } ( 1 - \mu _ { 1 } ) } & { - \mu _ { 1 } \mu _ { 2 } } & { - \mu _ { 1 } \mu _ { 3 } } \\ { - \mu _ { 2 } \mu _ { 1 } } & { \mu _ { 2 } ( 1 - \mu _ { 2 } ) } & { - \mu _ { 2 } \mu _ { 3 } } \\ { - \mu _ { 3 } \mu _ { 1 } } & { - \mu _ { 3 } \mu _ { 2 } } & { \mu _ { 3 } ( 1 - \mu _ { 3 } ) } \end{array} \right)
$$

In matrix form, this can be written as

$$
\frac { \partial \pmb { \mu } } { \partial \pmb { a } } = ( \pmb { \mu } \mathbf { 1 } ^ { \top } ) \odot ( \mathbf { I } - \mathbf { 1 } \pmb { \mu } ^ { \top } )
$$

where $\odot$ is elementwise product, $\mu \mathbf { 1 } ^ { \mathsf { I } }$ copies $\pmb { \mu }$ across each column, and $\mathbf { 1 } \mu ^ { \prime }$ copies $\pmb { \mu }$ across each row.

We now derive the gradient of the NLL for a single example, indexed by $n$ . To do this, we flatten the $D \times C$ weight matrix into a vector $\mathbf { \boldsymbol { w } }$ of size $\boldsymbol C \boldsymbol D$ (or $( C - 1 ) D$ if we freeze one of the classes to have zero weight) by concatenating the rows, and then transposing into a column vector. We use ${ \pmb w } _ { j }$ to denote the vector of weights associated with class $j$ . The gradient wrt this vector is giving by the following (where we use the Kronecker delta notation, $\delta _ { j c }$ , which equals $^ { 1 }$ if $j = c$ and $0$ otherwise):

$$
\begin{array} { l } { \displaystyle \nabla _ { w _ { j } } \mathrm { N L L } _ { n } = \sum _ { c } \frac { \partial \mathrm { N L L } _ { n _ { c } } } { \partial \mu _ { n c } } \frac { \partial \mu _ { n c } } { \partial \alpha _ { n j } } \frac { \partial a _ { n j } } { \partial w _ { j } } } \\ { = - \sum _ { c } \frac { y _ { n c } } { \mu _ { n c } } \mu _ { n c } ( \delta _ { j c } - \mu _ { n j } ) x _ { n } } \\ { = \sum _ { c } y _ { n c } ( \mu _ { n j } - \delta _ { j c } ) x _ { n } } \\ { = ( \sum _ { c } y _ { n c } ) \mu _ { n j } x _ { n } - \sum _ { c } \delta _ { j c } y _ { n j } x _ { n } } \\ { = ( \mu _ { n j } - y _ { n j } ) x _ { n } } \end{array}
$$

We can repeat this computation for each class, to get the full gradient vector. The gradient of the overall NLL is obtained by summing over examples, to give the $D \times C$ matrix

$$
g ( \pmb { w } ) = \frac { 1 } { N } \sum _ { n = 1 } ^ { N } \pmb { x } _ { n } ( \pmb { \mu } _ { n } - \pmb { y } _ { n } ) ^ { \top } \qquad \quad 
$$

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

This has the same form as in the binary logistic regression case, namely an error term times the input.

# 10.3.2.4 Deriving the Hessian

Exercise 10.1 asks you to show that the Hessian of the NLL for multinomial logistic regression is given by

$$
\mathbf { H } ( \pmb { w } ) = \frac { 1 } { N } \sum _ { n = 1 } ^ { N _ { D } } ( \mathrm { d i a g } ( \pmb { \mu } _ { n } ) - \pmb { \mu } _ { n } \pmb { \mu } _ { n } ^ { \top } ) \otimes ( \pmb { x } _ { n } \pmb { x } _ { n } ^ { \top } )
$$

where $\mathbf { A } \otimes \mathbf { B }$ is the Kronecker product (Section 7.2.5). In other words, the block $c , c ^ { \prime }$ submatrix is given by

$$
\mathbf { H } _ { c , c ^ { \prime } } ( \pmb { w } ) = \frac { 1 } { N } \sum _ { n } \mu _ { n c } ( \delta _ { c , c ^ { \prime } } - \mu _ { n , c ^ { \prime } } ) \pmb { x } _ { n } \pmb { x } _ { n } ^ { \top }
$$

For example, if we have 3 features and 2 classes, this becomes

$$
\begin{array}{c} { \begin{array} { r l } { \mathbf { H } ( w ) = { \frac { 1 } { N } } \sum _ { n } { \binom { \mu _ { n 1 } - \mu _ { n 1 } ^ { 2 } } { - \mu _ { n 1 } \mu _ { n 2 } } } \quad - \mu _ { n 1 } \mu _ { n 2 } } \\ { = { \frac { 1 } { N } } \sum _ { n } { \binom { \mu _ { n 1 } - \mu _ { n 1 } ^ { 2 } } { n } } \mathbf { X } _ { n } \quad } & { - \mu _ { n 1 } \mu _ { n 2 } } \end{array} } { \left( \begin{array} { l l l } { x _ { n 1 } x _ { n 1 } } & { x _ { n 1 } x _ { n 2 } } & { x _ { n 1 } x _ { n 3 } } \\ { x _ { n 2 } x _ { n 1 } } & { x _ { n 2 } x _ { n 2 } } & { x _ { n 2 } x _ { n 3 } } \\ { x _ { n 3 } x _ { n 1 } } & { x _ { n 3 } x _ { n 2 } } & { x _ { n 3 } x _ { n 3 } } \end{array} \right) }  \\ { = { \frac { 1 } { N } } \sum _ { n } { \binom { \left( \mu _ { n 1 } - \mu _ { n 1 } ^ { 2 } \right) \mathbf { X } _ { n } } { - \mu _ { n 1 } \mu _ { n 2 } \mathbf { X } _ { n } } } \quad - \mu _ { n 1 } \mu _ { n 2 } \mathbf { X } _ { n } } \end{array} 
$$

where ${ \bf X } _ { n } = { \pmb x } _ { n } { \pmb x } _ { n } ^ { \sf I }$ . Exercise 10.1 also asks you to show that this is a positive definite matrix, so the objective is convex.

# 10.3.3 Gradient-based optimization

It is straightforward to use the gradient in Section 10.3.2.3 to derive the SGD algorithm. Similarly, we can use the Hessian in Section 10.3.2.4 to derive a second-order optimization method. However, computing the Hessian can be expensive, so it is common to approximate it using quasi-Newton methods, such as limited memory BFGS. (BFGS stands for Broyden, Fletcher, Goldfarb and Shanno.) See Section 8.3.2 for details. Another approach, which is similar to IRLS, is described in Section 10.3.4. All of these methods rely on computing the gradient of the log-likelihood, which in turn requires computing normalized probabilities, which can be computed from the logits vector $\mathbf { \Delta } a = \mathbf { W } \mathbf { \Delta } x$ using

$$
p ( y = c | \pmb { x } ) = \exp ( a _ { c } - \mathrm { l s e } ( \pmb { a } ) )
$$

where lse is the log-sum-exp function defined in Section 2.5.4. For this reason, many software libraries define a version of the cross-entropy loss that takes unnormalized logits as input.

# 10.3.4 Bound optimization

In this section, we consider an approach for fitting logistic regression using a class of algorithms known as bound optimization, which we describe in Section 8.7. The basic idea is to iteratively

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

construct a lower bound on the function you want to maximize, and then to update the bound, so it “pushes up” on the true function. Optimizing the bound is often easier than updating the function directly.

If $\ell ( \pmb \theta )$ is a concave function we want to maximize, then one way to obtain a valid lower bound is to use a bound on its Hessian, i.e., to find a negative definite matrix $\mathbf { B }$ such that $\mathbf { H } ( \pmb { \theta } ) \succ \mathbf { B }$ . In this case, one can show that

$$
{ \boldsymbol { \ell } } ( \pmb { \theta } ) \geq \ell ( \pmb { \theta } ^ { t } ) + ( \pmb { \theta } - \pmb { \theta } ^ { t } ) ^ { \top } \pmb { g } ( \pmb { \theta } ^ { t } ) + \frac { 1 } { 2 } ( \pmb { \theta } - \pmb { \theta } ^ { t } ) ^ { \top } \mathbf { B } ( \pmb { \theta } - \pmb { \theta } ^ { t } )
$$

where $\pmb { g } ( \pmb { \theta } ^ { t } ) = \nabla \ell ( \pmb { \theta } ^ { t } )$ . Defining $Q ( \pmb \theta , \pmb \theta ^ { t } )$ as the right-hand-side of Equation (10.74), the update becomes

$$
\pmb { \theta } ^ { t + 1 } = \pmb { \theta } ^ { t } - \mathbf { B } ^ { - 1 } \pmb { g } ( \pmb { \theta } ^ { t } )
$$

This is similar to a Newton update, except we use $\mathbf { B }$ , which is a fixed matrix, rather than $\mathbf { H } ( \pmb \theta ^ { t } )$ , which changes at each iteration. This can give us some of the advantages of second order methods at lower computational cost.

Let us now apply this to logistic regression, following [Kri+05], Let $\pmb { \mu } _ { n } ( \pmb { w } ) = [ p ( y _ { n } = 1 | \pmb { x } _ { n } , \pmb { w } ) , \dots , p ( y _ { n } =$ $C | \mathbf { \boldsymbol { x } } _ { n } , \mathbf { \boldsymbol { w } } ) ]$ and $\pmb { y } _ { n } = \mathbb { I } \left( y _ { n } = 1 \right) , \ldots , \mathbb { I } \left( y _ { n } = C \right) \mathrm { l }$ . We want to maximize the log-likelihood, which is as follows:

$$
\ell ( { \pmb w } ) = \sum _ { n = 1 } ^ { N } \left[ \sum _ { c = 1 } ^ { C } y _ { n c } { \pmb w } _ { c } ^ { \top } { \pmb x } _ { n } - \log \sum _ { c = 1 } ^ { C } \exp ( { \pmb w } _ { c } ^ { \top } { \pmb x } _ { n } ) \right]
$$

The gradient is given by the following (see Section 10.3.2.3 for details of the derivation):

$$
g ( { \pmb w } ) = \sum _ { n = 1 } ^ { N } ( { \pmb y } _ { n } - { \pmb \mu } _ { n } ( { \pmb w } ) ) \otimes { \pmb x } _ { n }
$$

where $\otimes$ denotes Kronecker product (which, in this case, is just outer product of the two vectors). The Hessian is given by the following (see Section 10.3.2.4 for details of the derivation):

$$
\mathbf { H } ( w ) = - \sum _ { n = 1 } ^ { N } ( \mathrm { d i a g } ( \pmb { \mu } _ { n } ( w ) ) - \pmb { \mu } _ { n } ( w ) \pmb { \mu } _ { n } ( w ) ^ { \top } ) \otimes ( \pmb { x } _ { n } \pmb { x } _ { n } ^ { \top } )
$$

We can construct a lower bound on the Hessian, as shown in [Boh92]:

$$
\mathbf { H } ( \pmb { w } ) \succ - \frac { 1 } { 2 } [ \mathbf { I } - \mathbf { 1 } \mathbf { 1 } ^ { \top } / C ] \otimes \left( \sum _ { n = 1 } ^ { N } \pmb { x } _ { n } \pmb { x } _ { n } ^ { \top } \right) \triangleq \mathbf { B }
$$

where $\mathbf { I }$ is a $C$ -dimensional identity matrix, and $\mathbf { 1 }$ is a $C$ -dimensional vector of all 1s.1 In the binary case, this becomes

$$
\mathbf { H } ( w ) \succ - \frac { 1 } { 2 } \left( 1 - \frac { 1 } { 2 } \right) \left( \sum _ { n = 1 } ^ { N } \pmb { x } _ { n } \pmb { x } _ { n } ^ { \top } \right) = - \frac { 1 } { 4 } \mathbf { X } ^ { \top } \mathbf { X }
$$

This follows since $\mu _ { n } \leq 0 . 5$ so $- ( \mu _ { n } - \mu _ { n } ^ { 2 } ) \ge - 0 . 2 5$ .

We can use this lower bound to construct an MM algorithm to find the MLE. The update becomes

$$
\mathbf { \boldsymbol { w } } ^ { t + 1 } = \mathbf { \boldsymbol { w } } ^ { t } - \mathbf { \boldsymbol { B } } ^ { - 1 } \mathbf { \boldsymbol { g } } ( \mathbf { \boldsymbol { w } } ^ { t } )
$$

This iteration can be faster than IRLS (Section 10.2.6) since we can precompute $\mathbf { B } ^ { - 1 }$ in time independent of $N$ , rather than having to invert the Hessian at each iteration. For example, let us consider the binary case, so $\pmb { g } ^ { t } = \nabla \ell ( \pmb { w } ^ { t } ) = \mathbf { X } ^ { 1 } \left( \pmb { y } - \pmb { \mu } ^ { t } \right)$ , where $\pmb { \mu } ^ { t } = [ p _ { n } ( \pmb { w } ^ { t } ) , ( 1 - p _ { n } ( \pmb { w } ^ { t } ) ) ] _ { n = 1 } ^ { N }$ . The update becomes

$$
\boldsymbol { \mathbf { \mathit { w } } } ^ { t + 1 } = \boldsymbol { \mathbf { \mathit { w } } } ^ { t } - 4 ( \boldsymbol { \mathbf { \mathit { X } } } ^ { \mathsf { T } } \boldsymbol { \mathbf { \mathit { X } } } ) ^ { - 1 } \boldsymbol { \mathbf { \mathit { g } } } ^ { t }
$$

Compare this to Equation (10.37), which has the following form:

$$
\pmb { w } ^ { t + 1 } = \pmb { w } ^ { t } - \mathbf { H } ^ { - 1 } \pmb { g } ( \pmb { w } ^ { t } ) = \pmb { w } ^ { t } - ( \mathbf { X } ^ { \mathsf { T } } \mathbf { S } ^ { t } \mathbf { X } ) ^ { - 1 } \pmb { g } ^ { t }
$$

where $\mathbf { S } ^ { t } = \mathrm { d i a g } ( { \pmb { \mu } } ^ { t } \odot ( 1 - { \pmb { \mu } } ^ { t } ) )$ . We see that Equation (10.82) is faster to compute, since we can precompute the constant matrix $( \mathbf { X } ^ { \mathsf { I } } \mathbf { X } ) ^ { - 1 }$ .

# 10.3.5 MAP estimation

In Section 10.2.7 we discussed the benefits of $\ell _ { 2 }$ regularization for binary logistic regression. These benefits hold also in the multi-class case. However, there is also an additional, and surprising, benefit to do with identifiability of the parameters, as pointed out in [HTF09, Ex.18.3]. (We say that the parameters are identifiable if there is a unique value that maximizes the likelihood; equivalently, we require that the NLL be strictly convex.)

To see why identifiability is an issue, recall that multiclass logistic regression has the form

$$
p ( \boldsymbol { y } = { c } | \boldsymbol { x } , \mathbf { W } ) = \frac { \exp ( { \pmb { w } } _ { c } ^ { T } { \pmb { x } } ) } { \sum _ { k = 1 } ^ { C } \exp ( { \pmb { w } } _ { k } ^ { T } { \pmb { x } } ) }
$$

where $\mathbf { W }$ is a $C \times D$ weight matrix. We can arbitrarily define ${ \pmb w } _ { c } = { \bf 0 }$ for one of the classes, say $c = C$ , since $\begin{array} { r } { p ( y = C | \pmb { x } , \mathbf { W } ) = 1 - \sum _ { c = 1 } ^ { C - 1 } p ( y = c | \pmb { x } , \pmb { w } ) } \end{array}$ . In this case, the model has the form

$$
p ( y = c | \mathbf { x } , \mathbf { W } ) = \frac { \exp ( \pmb { w } _ { c } ^ { T } \pmb { x } ) } { 1 + \sum _ { k = 1 } ^ { C - 1 } \exp ( \pmb { w } _ { k } ^ { T } \pmb { x } ) }
$$

If we don’t “clamp” one of the vectors to some constant value, the parameters will be unidentifiable. However, suppose we don’t clamp ${ \pmb w } _ { c } = { \pmb 0 }$ , so we are using Equation 10.84, but we add $\ell _ { 2 }$ regularization by optimizing

$$
\mathrm { P N L L } ( \mathbf { W } ) = - \sum _ { n = 1 } ^ { N _ { \mathcal { D } } } \log p ( y _ { n } | \pmb { x } _ { n } , \mathbf { W } ) + \lambda \sum _ { c = 1 } ^ { C } | | \pmb { w } _ { c } | | _ { 2 } ^ { 2 }
$$

where we have absorbed the $1 / N$ term into $\lambda$ . At the optimum we have $\textstyle \sum _ { c = 1 } ^ { C } \hat { w } _ { c j } = 0$ for $j = 1 : D$ , so the weights automatically satisfy a sum-to-zero constraint, thus making them uniquely identifiable.

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

To see why, note that at the optimum we have

$$
\begin{array} { c } { \displaystyle \nabla \mathrm { N L L } ( \pmb { w } ) + 2 \lambda \pmb { w } = \mathbf { 0 } } \\ { \displaystyle \sum _ { n } ( \pmb { y } _ { n } - \pmb { \mu } _ { n } ) \otimes \pmb { x } _ { n } = \lambda \pmb { w } } \end{array}
$$

Hence for any feature dimension $j$ we have

$$
\lambda \sum _ { c } w _ { c j } = \sum _ { n } \sum _ { c } ( y _ { n c } - \mu _ { n c } ) x _ { n j } = \sum _ { n } ( \sum _ { c } y _ { n c } - \sum _ { c } \mu _ { n c } ) x _ { n j } = \sum _ { n } ( 1 - 1 ) x _ { n } .
$$

Thus if $\lambda > 0$ we have $\begin{array} { r } { \sum _ { c } \hat { w } _ { c j } = 0 } \end{array}$ , so the weights will sum to zero across classes for each feature dimension.

# 10.3.6 Maximum entropy classifiers

Recall that the multinomial logistic regression model can be written as

$$
p ( y = c | \mathbf { x } , \mathbf { W } ) = \frac { \exp ( { \pmb w } _ { c } ^ { \mathsf { T } } { \pmb x } ) } { Z ( \pmb w , \pmb x ) } = \frac { \exp ( { \pmb w } _ { c } ^ { \mathsf { T } } { \pmb x } ) } { \sum _ { c ^ { \prime } = 1 } ^ { C } \exp ( { \pmb w } _ { c ^ { \prime } } ^ { \mathsf { T } } { \pmb x } ) }
$$

where $\begin{array} { r } { Z ( \pmb { w } , \pmb { x } ) = \sum _ { c } \exp ( \pmb { w } _ { c } ^ { 1 } \pmb { x } ) } \end{array}$ is the partition function (normalization constant). This uses the same features, but a different weight vector, for every class. There is a slight extension of this model that allows us to use features that are class-dependent. This model can be written as

$$
p ( y = c | \pmb { x } , \pmb { w } ) = \frac { 1 } { Z ( \pmb { w } , \pmb { x } ) } \exp ( \pmb { w } ^ { \top } \phi ( \pmb { x } , c ) )
$$

where $\phi ( { \pmb x } , c )$ is the feature vector for class $c$ . This is called a maximum entropy classifer, or maxent classifier for short. (The origin of this term is explained in Section 3.4.4.)

Maxent classifiers include multinomial logistic regression as a special case. To see this let $\mathbf { \nabla } w =$ $[ { \pmb w } _ { 1 } , \dots , { \pmb w } _ { C } ]$ , and define the feature vector as follows:

$$
\phi ( \pmb { x } , c ) = [ \mathbf 0 , \dots , \pmb { x } , \dots , \mathbf 0 ]
$$

where $_ { x }$ is embedded in the $c$ ’th block, and the remaining blocks are zero. In this case, ${ \pmb w } ^ { \scriptscriptstyle 1 } \phi ( { \pmb x } , c ) =$ ${ \pmb w } _ { c } ^ { 1 } { \pmb x }$ , so we recover multinomial logistic regression.

Maxent classifiers are very widely used in the field of natural language processing. For example, consider the problem of semantic role labeling, where we classify a word $_ { x }$ into a semantic role $y$ , such as person, place or thing. We might define (binary) features such as the following:

$$
\begin{array} { c } { \phi _ { 1 } ( \pmb { x } , y ) = \mathbb { I } \left( y = \mathrm { p e r s o n } \wedge \pmb { x } \mathrm { ~ o c c u r s ~ a f t e r ~ \% ~ M r . ' ~ o r ~ \allowdisplaybreaks Y ^ { \circ } M r s ^ { \circ } ) } \right. } \\ { \left. \phi _ { 2 } ( \pmb { x } , y ) = \mathbb { I } \left( y = \mathrm { p e r s o n } \wedge \pmb { x } \mathrm { ~ i s ~ i n ~ w h i t e l i s t ~ o f ~ c o m m o n ~ n a m e s } \right) \right. } \\ { \left. \phi _ { 3 } ( \pmb { x } , y ) = \mathbb { I } \left( y = \mathrm { p l a c e } \wedge \pmb { x } \mathrm { ~ i s ~ i n ~ G o o g l e ~ m a p s } \right) \right. } \\ { \qquad \vdots } \end{array}
$$

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

![](images/cd3794883e37232f76f4c17e4044cb752fb0f71d8f4ef0f0d3e3f92f19c42d95.jpg)  
Figure 10.8: A simple example of a label hierarchy. Nodes within the same ellipse have a mutual exclusion relationship between them.

We see that the features we use depend on the label.

There are two main ways of creating these features. The first is to manually specify many possibly useful features using various templates, and then use a feature selection algorithm, such as the group lasso method of Section 11.4.7. The second is to incrementally add features to the model, using a heuristic feature generation method.

# 10.3.7 Hierarchical classification

Sometimes the set of possible labels can be structured into a hierarchy or taxonomy. For example, we might want to predict what kind of an animal is in an image: it could be a dog or a cat; if it is a dog, it could be a golden retriever or a German shepherd, etc. Intuitively, it makes sense to try to predict the most precise label for which we are confident [Den+12], that is, the system should “hedge its bets”.

One simple way to achieve this, proposed in [RF17], is as follows. First, create a model with a binary output label for every possible node in the tree. Before training the model, we will use label smearing, so that a label is propagated to all of its parents (hypernyms). For example, if an image is labeled “golden retriever”, we will also label it “dog”. If we train a multi-label classifier (which produces a vector $p ( \pmb { y } | \pmb { x } )$ of binary labels) on such smeared data, it will perform hierarchical classification, predicting a set of labels at different levels of abstraction.

However, this method could predict “golden retriever”, “cat” and “bird” all with probability 1.0, since the model does not capture the fact that some labels are mutually exclusive. To prevent this, we can add a mutual exclusion constraint between all label nodes which are siblings, as shown in Figure 10.8. For example, this model enforces that $p ( \mathrm { m a m m a l } | \pmb { x } ) + p ( \mathrm { b i r d } | \pmb { x } ) = 1$ , since these two labels are children of the root node. We can further partition the mammal probability into dogs and cats, so we have $p ( \deg | \pmb { x } ) + p ( \mathrm { c a t } | \pmb { x } ) = p ( \mathrm { m a m m a l } | \pmb { x } )$ .

[Den+14; Din+15] generalize the above method by using a conditional graphical model where the graph structure can be more complex than a tree. In addition, they allow for soft constraints between labels, in addition to hard constraints.

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

![](images/c178a969bdece3a5551a5ec80e12710381b22f29f5ca48fcb39e6a9b4160e1ec.jpg)  
Figure 10.9: A flat and hierarchical softmax model $p ( w | C )$ , where $C$ are the input features (context) and w is the output label (word). Adapted from https: // www. quora. com/ What-is-hierarchical-softmax .

# 10.3.8 Handling large numbers of classes

In this section, we discuss some issues that arise when there are a large number of potential labels, e.g., if the labels correspond to words from a language.

# 10.3.8.1 Hierarchical softmax

In regular softmax classifiers, computing the normalization constant, which is needed to compute the gradient of the log likelihood, takes $O ( C )$ time, which can become the bottleneck if $C$ is large. However, if we structure the labels as a tree, we can compute the probability of any label in $O ( \log C )$ time, by multiplying the probabilities of each edge on the path from the root to the leaf. For example, consider the tree in Figure 10.9. We have

$$
p ( y = \mathrm { I ^ {                       } m } | C ) = 0 . 5 7 \times 0 . 6 8 \times 0 . 7 2 = 0 . 2 8
$$

Thus we replace the “flat” output softmax with a tree-structured sequence of binary classifiers. This is called hierarchical softmax [Goo01; MB05].

A good way to structure such a tree is to use Huffman encoding, where the most frequent labels are placed near the top of the tree, as suggested in [Mik+13a]. (For a different appproach, based on clustering the most common labels together, see [Gra+17]. And for yet another approach, based on sampling labels, see [Tit16].)

# 10.3.8.2 Class imbalance and the long tail

Another issue that often arises when there are a large number of classes is that for most classes, we may have very few examples. More precisely, if $N _ { c }$ is the number of examples of class $c$ , then the empirical distribution $p ( N _ { 1 } , \ldots , N _ { C } )$ may have a long tail. The result is an extreme form of class imbalance (see e.g., [ASR15]). Since the rare classes will have a smaller effect on the overall loss than the common classes, the model may “focus its attention” on the common classes.

One method that can help is to set the bias terms $^ { b }$ such that softmax $(  { b } ) _ { c } = N _ { c } / N$ ; such a model will match the empirical label prior even when using weights of $\mathbf { \nabla } { \boldsymbol { w } } = \mathbf { 0 }$ . As the weights are adjusted, the model can learn input-dependent deviations from this prior.

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

Another common approach is to resample the data to make it more balanced, before (or during) training. In particular, suppose we sample a datapoint from class $c$ with probability

$$
p _ { c } = \frac { N _ { c } ^ { q } } { \sum _ { i } ^ { C } N _ { i } ^ { q } }
$$

If we set $q = 1$ , we recover standard instance-balanced sampling, where $p _ { c } \propto N _ { c }$ ; the common classes will be sampled more than rare classes. If we set $q = 0$ , we recover class-balanced sampling, where $p _ { c } = 1 / C$ ; this can be thought of as first sampling a class uniformly at random, and then sampling an instance of this class. Finally, we can consider other options, such as $q = 0 . 5$ , which is known as square-root sampling [Mah+18].

Yet another method that is simple and can easily handle the long tail is to use the nearest class mean classifier. This has the form

$$
f ( \pmb { x } ) = \operatorname * { a r g m i n } _ { c } | | \pmb { x } - \pmb { \mu } _ { c } | | _ { 2 } ^ { 2 }
$$

where $\begin{array} { r } { \pmb { \mu } _ { c } = \frac { 1 } { N _ { c } } \sum _ { n : y _ { n } = c } \pmb { x } _ { n } } \end{array}$ is the mean of the features belonging to class $c$ . This induces a softmax posterior, as we discussed in Section 9.2.5. We can get much better results if we first use a neural network (see Part III) to learn good features, by training a DNN classifier with cross-entropy loss on the original unbalanced data. We then replace $_ { x }$ with $\phi ( { \pmb x } )$ in Equation (10.98). This simple approach can give very good performance on long-tailed distributions [Kan+20].

# 10.4 Robust logistic regression \*

Sometimes we have outliers in our data, which are often due to labeling errors, also called label noise. To prevent the model from being adversely affected by such contamination, we will use robust logistic regression. In this section, we discuss some approaches to this problem. (Note that the methods can also be applied to DNNs. For a more thorough survey of label noise, and how it impacts deep learning, see [Han+20].)

# 10.4.1 Mixture model for the likelihood

One of the simplest ways to define a robust logistic regression model is to modify the likelihood so that it predicts that each output label $y$ is generated uniformly at random with probability $\pi$ , and otherwise is generated using the usual conditional model. In the binary case, this becomes

$$
p ( y | { \boldsymbol x } ) = \pi \mathrm { B e r } ( y | 0 . 5 ) + ( 1 - \pi ) \mathrm { B e r } ( y | \sigma ( { \boldsymbol w } ^ { \top } { \boldsymbol x } ) )
$$

This approach, of using a mixture model for the observation model to make it robust, can be applied to many different models (e.g., DNNs).

We can fit this model using standard methods, such as SGD or Bayesian inference methods such as MCMC. For example, let us create a “contaminated” version of the 1d, two-class Iris dataset that we discussed in Section 4.6.7.2. We will add 6 examples of class 1 (Versicolor) with abnormally low sepal length. In Figure 10.10a, we show the results of fitting a standard (Bayesian) logistic regression model to this dataset. In Figure 10.10b, we show the results of fitting the above robust model. In the latter case, we see that the decision boundary is similar to the one we inferred from non-contaminated data, as shown in Figure 4.20b. We also see that the posterior uncertainty about the decision boundary’s location is smaller than when using a non-robust model.

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

![](images/34210adddce5792d2123382b8fbc46b29b67f9f82b0ede83b4e0da03c4e8aba4.jpg)  
Figure 10.10: (a) Logistic regression on some data with outliers (denoted by x). Training points have been (vertically) jittered to avoid overlapping too much. Vertical line is the decision boundary, and its posterior credible interval. (b) Same as (a) but using robust model, with a mixture likelihood. Adapted from Figure 4.13 of [Mar18]. Generated by logreg_iris_bayes_robust_1d_pymc3.ipynb.

# 10.4.2 Bi-tempered loss

In this section, we present an approach to robust logistic regression proposed in [Ami+19].

The first observation is that examples that are far from the decision boundary, but mislabeled, will have undue adverse affect on the model if the loss function is convex [LS10]. This can be overcome by replacing the usual cross entropy loss with a “tempered” version, that uses a temperature parameter $0 \leq t _ { 1 } < 1$ to ensure the loss from outliers is bounded. In particular, consider the standard relative entropy loss function:

$$
\mathcal { L } ( \pmb { y } , \hat { \pmb { y } } ) = \mathbb { H } _ { c e } ( \pmb { y } , \hat { \pmb { y } } ) = \sum _ { c } y _ { c } \log \hat { y } _ { c }
$$

where $\mathbf { \nabla } _ { \mathbf { \boldsymbol { y } } }$ is the true label distribution (often one-hot) and $\hat { \pmb y }$ is the predicted distribution. We define the tempered cross entropy loss as follows:

$$
\mathcal { L } ( y , \hat { y } ) = \sum _ { c } \bigg [ y _ { c } ( \log _ { t _ { 1 } } y _ { c } - \log _ { t _ { 1 } } \hat { y } _ { c } ) - \frac { 1 } { 2 - t _ { 1 } } ( y _ { c } ^ { 2 - t _ { 1 } } - \hat { y } _ { c } ^ { 2 - t _ { 1 } } ) \bigg ]
$$

which simplifes to the following when the true distribution $\pmb { y }$ is one-hot, with all its mass on class $c$ :

$$
\mathcal { L } ( c , \hat { y } ) = - \log _ { t _ { 1 } } \hat { y } _ { c } - \frac { 1 } { 2 - t _ { 1 } } \left( 1 - \sum _ { c ^ { \prime } = 1 } ^ { C } \hat { y } _ { c ^ { \prime } } ^ { 2 - t _ { 1 } } \right)
$$

Here $\log _ { t }$ is tempered version of the log function:

$$
\log _ { t } ( x ) \triangleq { \frac { 1 } { 1 - t } } ( x ^ { 1 - t } - 1 )
$$

This is mononotically increasing and concave, and reduces to the standard (natural) logarithm when $t = 1$ . (Similarly, tempered cross entropy reduces to standard cross entropy when $t = 1$ .) However,

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022 the tempered log function is bounded from below by $- 1 / ( 1 - t )$ for $0 \leq t < 1$ , and hence the cross entropy loss is bounded from above (see Figure 10.11).

![](images/f2d38e49f0f55c4d6cb2b7a288a522b427b81e29713544924850d03aeab66d0c.jpg)  
Figure 10.11: (a) Illustration of logistic and tempered logistic loss with $t _ { 1 } = 0 . 8$ . (b) Illustration of sigmoid and tempered sigmoid transfer function with $t _ { 2 } ~ = ~ 2 . 0$ . From https: // ai. googleblog. com/ 2019/ 08/ bi-tempered-logistic-loss-for-training. html . Used with kind permission of Ehsan Amid.

The second observation is that examples that are near the decision boundary, but mislabeled, need to use a transfer function (that maps from activations $\mathbb { R } ^ { C }$ to probabilities $[ 0 , 1 ] ^ { C }$ ) that has heavier tails than the softmax, which is based on the exponential, so it can “look past” the neighborhood of the immediate examples. In particular, the standard softmax is defined by

$$
\hat { y } _ { c } = \frac { a _ { c } } { \sum _ { c ^ { \prime } = 1 } ^ { C } \exp ( a _ { c ^ { \prime } } ) } = \exp \left[ a _ { c } - \log \sum _ { c ^ { \prime } = 1 } ^ { C } \exp ( a _ { c ^ { \prime } } ) \right]
$$

where $\textbf { \em a }$ is the logits vector. We can make a heavy tailed version by using the tempered softmax, which uses a temperature parameter $t _ { 2 } > 1 > t _ { 1 }$ as follows:

$$
\begin{array} { r } { \hat { y } _ { c } = \exp _ { t _ { 2 } } ( a _ { c } - \lambda _ { t _ { 2 } } ( \pmb { a } ) ) } \end{array}
$$

where

$$
\exp _ { t } ( x ) \triangleq [ 1 + ( 1 - t ) x ] _ { + } ^ { 1 / ( 1 - t ) }
$$

is a tempered version of the exponential function. (This reduces to the standard exponental function as $t \to 1$ .) In Figure $1 0 . 1 1 ( \mathrm { r i g h t } )$ , we show that the tempered softmax (in the two-class case) has heavier tails, as desired.

All that remains is a way to compute $\lambda _ { t _ { 2 } } ( \pmb { a } )$ . This must satisfy the following fixed point equation

$$
\sum _ { c = 1 } ^ { C } \exp _ { t _ { 2 } } ( a _ { c } - \lambda ( \pmb { a } ) ) = 1
$$

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

1 Input: logits   
2 $\mu : = \operatorname* { m a x } ( \pmb { a } )$   
3 $\pmb { a } : = \pmb { a } - \mu$   
4 while $\textbf { \em a }$   
5   
6   
7 Return − logt Z(1a) + µ

![](images/fd2425e925cb5396e3f95fb5097d54c5bb4c0b77523f1a7c09ed63563cc9ed50.jpg)  
Figure 10.12: Illustration of standard and bi-tempered logistic regression on data with label noise. From https: // ai. googleblog. com/ 2019/ 08/ bi-tempered-logistic-loss-for-training. html . Used with kind permission of Ehsan Amid.

We can solve for $\lambda$ using binary search, or by using the iterative procedure in Algorithm 3.

Combining the tempered softmax with the tempered cross entropy results in a method called bi-tempered logistic regression. In Figure 10.12, we show an example of this in 2d. The top row is standard logistic regression, the bottom row is bi-tempered. The first column is clean data. The second column has label noise near the boundary. The robust version uses $t _ { 1 } = 1$ (standard cross entropy) but $t _ { 2 } = 4$ (tempered softmax with heavy tails). The third column has label noise far from the boundary. The robust version uses $t _ { 1 } = 0 . 2$ (tempered cross entropy with bounded loss) but $t _ { 2 } = 1$ (standard softmax). The fourth column has both kinds of noise; in this case, the robust version uses $t _ { 1 } = 0 . 2$ and $t _ { 2 } = 4$ .

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

# 10.5 Bayesian logistic regression \*

So far we have focused on point estimates of the parameters, either the MLE or the MAP estimate. However, in some cases we want to compute the posterior, $p ( \pmb { w } | \mathcal { D } )$ , in order to capture our uncertainty. This can be particularly useful in settings where we have little data, and where choosing the wrong decision may be costly.

Unlike with linear regression, it is not possible to compute the posterior exactly for a logistic regression model. A wide range of approximate algorithms can be used,. In this section, we use one of the simplest, known as the Laplace approximation (Section 4.6.8.2). See the sequel to this book, [Mur23] for more advanced approximations.

# 10.5.1 Laplace approximation

As we discuss in Section 4.6.8.2, the Laplace approximation approximates the posterior using a Gaussian. The mean of the Gaussian is equal to the MAP estimate $\hat { \pmb w }$ , and the covariance is equal to the inverse Hessian $\mathbf { H }$ computed at the MAP estimate, i.e., $p ( \pmb { w } | \mathcal { D } ) \approx \mathcal { N } ( \pmb { w } | \hat { \pmb { w } } , \mathbf { H } ^ { - 1 } )$ , We can find the mode using a standard optimization method (see Section 10.2.7), and then we can use the results from Section 10.2.3.4 to compute the Hessian at the mode.

As an example, consider the data illustrated in Figure 10.13(a). There are many parameter settings that correspond to lines that perfectly separate the training data; we show 4 example lines. The likelihood surface is shown in Figure 10.13(b). The diagonal line connects the origin to the point in the grid with maximum likelihood, ${ \hat { w } } _ { \mathrm { m l e } } = ( 8 . 0 , 3 . 4 )$ . (The unconstrained MLE has $| | \pmb { w } | | = \infty$ , as we discussed in Section 10.2.7; this point can be obtained by following the diagonal line infinitely far to the right.)

For each decision boundary in Figure 10.13(a), we plot the corresponding parameter vector in Figure 10.13(b). These parameters values are $\pmb { w } _ { 1 } = ( 3 , 1 )$ , $\pmb { w } _ { 2 } = ( 4 , 2 )$ , $\pmb { w } _ { 3 } = ( 5 , 3 )$ , and $\pmb { w } _ { 4 } = ( 7 , 3 )$ . These points all approximately satisfy ${ \pmb w } _ { i } ( 1 ) / { \pmb w } _ { i } ( 2 ) \approx \hat { \pmb w } _ { \mathrm { m l e } } ( 1 ) / \hat { \pmb w } _ { \mathrm { m l e } } ( 2 )$ , and hence are close to the orientation of the maximum likelihood decision boundary. The points are ordered by increasing weight norm (3.16, 4.47, 5.83, and 7.62).

To ensure a unique solution, we use a (spherical) Gaussian prior centered at the origin, $\mathcal { N } ( \boldsymbol { \mathbf { \mathit { w } } } | \mathbf { \mathbf { 0 } } , \sigma ^ { \mathrm { 2 } } \mathbf { I } )$ . The value of $\sigma ^ { 2 }$ controls the strength of the prior. If we set $\sigma ^ { 2 } = 0$ , we force the MAP estimate to be $\mathbf { \nabla } { \boldsymbol { w } } = \mathbf { 0 }$ ; this will result in maximally uncertain predictions, since all points $_ { x }$ will produce a predictive distribution of the form $p ( y = 1 | \pmb { x } ) = 0 . 5$ . If we set $\sigma ^ { 2 } = \infty$ , the prior becomes uninformative, and MAP estimate becomes the MLE, resulting in minimally uncertain predictions. (In particular, all positively labeled points will have $p ( y = 1 | \pmb { x } ) = 1 . 0$ , and all negatively labeled points will have $p ( y = 1 | \pmb { x } ) = 0 . 0$ , since the data is separable.) As a compromise (to make a nice illustration), we pick the value $\sigma ^ { 2 } = 1 0 0$ .

Multiplying this prior by the likelihood results in the unnormalized posterior shown in Figure 10.13(c). The MAP estimate is shown by the blue dot. The Laplace approximation to this posterior is shown in Figure 10.13(d). We see that it gets the mode correct (by construction), but the shape of the posterior is somewhat distorted. (The southwest-northeast orientation captures uncertainty about the magnitude of $\mathbf { \boldsymbol { w } }$ , and the southeast-northwest orientation captures uncertainty about the orientation of the decision boundary.)

In Figure 10.14, we show contours of the posterior predictive distribution. Figure 10.14(a) shows the plugin approximation using the MAP estimate. We see that there is no uncertainty about the decision

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license boundary, even though we are generating probabilistic predictions over the labels. Figure 10.14(b) shows what happens when we plug in samples from the Gaussian posterior. Now we see that there is considerable uncertainty about the orientation of the “best” decision boundary. Figure 10.14(c) shows the average of these samples. By averaging over multiple predictions, we see that the uncertainty in the decision boundary “splays out” as we move further from the training data. Figure 10.14(d) shows that the probit approximation gives very similar results to the Monte Carlo approximation.

![](images/6e015284736474299a6a934f09c3de671ae684f7ff888ec22a7639927d2b7ff7.jpg)  
Figure 10.13: (a) Illustration of the data. (b) Log-likelihood for a logistic regression model. The line is drawn from the origin in the direction of the MLE (which is at infinity). The numbers correspond to 4 points in parameter space, corresponding to the lines in (a). (c) Unnormalized log posterior (assuming vague spherical prior). (d) Laplace approximation to posterior. Adapted from a figure by Mark Girolami. Generated by logreg_laplace_demo.ipynb.

# 10.5.2 Approximating the posterior predictive

The posterior $p ( \pmb { w } | \mathcal { D } )$ tells us everything we know about the parameters of the model given the data. However, in machine learning applications, the main task of interest is usually to predict an output $y$

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

![](images/1425cc4ecdad2abc8e01c754e1c00b4d16053f7e7bbc05b62948da6a5ea8bcb8.jpg)  
Figure 10.14: Posterior predictive distribution for a logistic regression model in 2d. (a): contours of $p ( y = 1 | \mathbf x , \hat { w } _ { m a p } )$ . $( b )$ : samples from the posterior predictive distribution. (c): Averaging over these samples. $( d )$ : moderated output (probit approximation). Adapted from a figure by Mark Girolami. Generated by logreg_laplace_demo.ipynb.

given an input $_ { x }$ , rather than to try to understand the parameters of our model. Thus we need to compute the posterior predictive distribution

$$
p ( y | \mathbf { x } , \mathcal { D } ) = \int p ( y | \mathbf { x } , \pmb { w } ) p ( \pmb { w } | \mathcal { D } ) d \pmb { w }
$$

As we discussed in Section 4.6.7.1, a simple approach to this is to first compute a point estimate $\hat { \pmb w }$ of the parameters, such as the MLE or MAP estimate, and then to ignore all posterior uncertainty, by assuming $p ( \pmb { w } | \mathcal { D } ) = \delta ( \pmb { w } - \hat { \pmb { w } } )$ . In this case, the above integral reduces to the following plugin approximation:

$$
p ( \pmb { y } | \pmb { x } , \mathcal { D } ) \approx \int p ( \pmb { y } | \pmb { x } , \pmb { w } ) \delta ( \pmb { w } - \hat { \pmb { w } } ) d \pmb { w } = p ( \pmb { y } | \pmb { x } , \hat { \pmb { w } } )
$$

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

However, if we want to compute uncertainty in our predictions, we should use a non-degenerate posterior. It is common to use a Gaussian posterior, as we will see. But we still need to approximate the integral in Equation (10.108). We discuss some approaches to this below.

# 10.5.2.1 Monte Carlo approximation

The simplest approach is to use a Monte Carlo approximation to the integral. This means we draw $S$ samples from the posterior, $\mathbf { \boldsymbol { w } } _ { s } \sim p ( \mathbf { \boldsymbol { w } } | \mathcal { D } )$ . and then compute

$$
p ( \boldsymbol { y } = 1 | \boldsymbol { x } , \mathcal { D } ) \approx \frac { 1 } { S } \sum _ { s = 1 } ^ { S } \sigma ( \boldsymbol { w } _ { s } ^ { \top } \boldsymbol { x } )
$$

# 10.5.2.2 Probit approximation

Although the Monte Carlo approximation is simple, it can be slow, since we need to draw $S$ samples at test time for each input $_ { x }$ . Fortunately, if $p ( \pmb { w } | \mathcal { D } ) = \mathcal { N } ( \pmb { w } | \pmb { \mu } , \pmb { \Sigma } )$ , there is a simple yet accurate deterministic approximation, first suggested in [SL90]. To explain this approximation, we follow the presentation of [Bis06, p219]. The key observation is that the sigmoid function $\sigma ( a )$ is similar in shape to the Gaussian cdf (see Section 2.6.1) $\Phi ( a )$ . In particular we have $\sigma ( a ) \approx \Phi ( \lambda a )$ , where $\lambda ^ { 2 } = \pi / 8$ ensures the two functions have the same slope at the origin. This is useful since we can integrate a Gaussian cdf wrt a Gaussian pdf exactly:

$$
\int \Phi ( \lambda a ) \mathcal { N } ( a | m , v ) d a = \Phi \left( \frac { m } { ( \lambda ^ { - 2 } + v ) ^ { \frac { 1 } { 2 } } } \right) = \Phi \left( \frac { \lambda m } { ( 1 + \lambda ^ { 2 } v ) ^ { \frac { 1 } { 2 } } } \right) \approx \sigma ( \kappa ( v ) m )
$$

where we have defined

$$
\kappa ( v ) \triangleq ( 1 + \pi v / 8 ) ^ { - \frac { 1 } { 2 } }
$$

Thus if we define $a = \pmb { x } ^ { \top } \pmb { w }$ , we have

$$
\begin{array} { r l } & { p ( \boldsymbol { y } = 1 | \boldsymbol { x } , \mathcal { D } ) \approx \sigma ( \kappa ( \boldsymbol { v } ) m ) } \\ & { \qquad m = \mathbb { E } \left[ a \right] = \boldsymbol { x } ^ { \top } \boldsymbol { \mu } } \\ & { \qquad v = \mathbb { V } \left[ a \right] = \mathbb { V } \left[ \boldsymbol { x } ^ { \top } \boldsymbol { w } \right] = \boldsymbol { x } ^ { \top } \Sigma \boldsymbol { x } } \end{array}
$$

where we used Equation (2.165) in the last line. Since $\Phi$ is the inverse of the probit function, we will call this the probit approximation.

Using Equation (10.113) results in predictions that are less extreme (in terms of their confidence) than the plug-in estimate. To see this, note that $0 < \kappa ( v ) < 1$ and hence $\kappa ( v ) m < m$ , so $\sigma ( \kappa ( v ) m )$ is closer to 0.5 than $\sigma ( m )$ is. However, the decision boundary itself will not be affected. To see this, note that the decision boundary is the set of points $_ { x }$ for which $p ( y = 1 | x , D ) = 0 . 5$ . This implies $\kappa ( v ) m = 0$ , which implies $m = \overline { { w } } ^ { 1 } x = 0$ ; but this is the same as the decision boundary from the plugin estimate. Thus “being Bayesian” doesn’t change the misclassification rate (in this case), but it does change the confidence estimates of the model, which can be important, as we illustrate in Section 10.5.1.

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

In the multiclass case we can use the generalized probit approximation [Gib97]:

$$
\begin{array} { c } { p ( { \boldsymbol y } = { \boldsymbol c } | { \boldsymbol x } , { \mathcal D } ) \approx \displaystyle \frac { \exp ( \kappa ( v _ { c } ) m _ { c } ) } { \sum _ { c ^ { \prime } } \exp ( \kappa ( v _ { c ^ { \prime } } ) m _ { c ^ { \prime } } ) } } \\ { m _ { c } = \overline { { m _ { c } ^ { \mathsf { T } } } } { \boldsymbol x } } \\ { v _ { c } = { \boldsymbol x } ^ { \mathsf { T } } { \mathbf V } _ { c , c } { \boldsymbol x } } \end{array}
$$

where $\kappa$ is defined in Equation (10.112). Unlike the binary case, taking into account posterior covariance gives different predictions than the plug-in approach (see Exercise 3.10.3 of [RW06]).

For further approximations of Gaussian integrals combined with sigmoid and softmax functions, see [Dau17].

# 10.6 Exercises

Exercise 10.1 [Gradient and Hessian of log-likelihood for multinomial logistic regression]

a. Let $\mu _ { i k } = \mathrm { s o f t m a x } ( \pmb { \eta } _ { i } ) _ { k }$ , where $\pmb { \eta } _ { i } = \pmb { w } ^ { T } \pmb { x } _ { i }$ . Show that the Jacobian of the softmax is

$$
\frac { \partial \mu _ { i k } } { \partial \eta _ { i j } } = \mu _ { i k } ( \delta _ { k j } - \mu _ { i j } )
$$

where $\delta _ { k j } = I ( k = j )$ .

b. Hence show that the gradient of the NLL is given by

$$
\nabla _ { { \pmb w } _ { c } } \ell = \sum _ { i } ( y _ { i c } - \mu _ { i c } ) { \pmb x } _ { i }
$$

Hint: use the chain rule and the fact that $\textstyle \sum _ { c } y _ { i c } = 1$ .

c. Show that the block submatrix of the Hessian for classes $c$ and $c ^ { \prime }$ is given by

$$
\mathbf { H } _ { c , c ^ { \prime } } = - \sum _ { i } \mu _ { i c } ( \delta _ { c , c ^ { \prime } } - \mu _ { i , c ^ { \prime } } ) \pmb { x } _ { i } \pmb { x } _ { i } ^ { T }
$$

Hence show that the Hessian of the NLL is positive definite.

Exercise 10.2 [Regularizing separate terms in 2d logistic regression $^ *$ ]

(Source: Jaakkola.)

a. Consider the data in Figure 10.15a, where we fit the model $p ( y = 1 | \pmb { x } , \pmb { w } ) = \sigma \big ( w _ { 0 } + w _ { 1 } x _ { 1 } + w _ { 2 } x _ { 2 } \big )$ . Suppose we fit the model by maximum likelihood, i.e., we minimize

$$
J ( \pmb { w } ) = - \ell ( \pmb { w } , \mathcal { D } _ { \mathrm { t r a i n } } )
$$

where $\ell ( { \boldsymbol { \mathbf { \mathit { w } } } } , { \mathcal { D } } _ { \mathrm { t r a i n } } )$ is the log likelihood on the training set. Sketch a possible decision boundary corresponding to $\hat { \textbf { \textit { w } } }$ . (Copy the figure first (a rough sketch is enough), and then superimpose your answer on your copy, since you will need multiple versions of this figure). Is your answer (decision boundary) unique? How many classification errors does your method make on the training set?

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license b. Now suppose we regularize only the $w _ { 0 }$ parameter, i.e., we minimize

![](images/0d92f8ddf8c950b7cc38561075982df8bd5f05d07744e432bb94cfe0439bb025.jpg)  
Figure 10.15: (a) Data for logistic regression question. (b) Plot of $\hat { w } _ { k }$ vs amount of correlation $c _ { k }$ for three different estimators.

$$
J _ { 0 } ( \pmb { w } ) = - \ell ( \pmb { w } , \mathcal { D } _ { \mathrm { t r a i n } } ) + \lambda w _ { 0 } ^ { 2 }
$$

Suppose $\lambda$ is a very large number, so we regularize $w _ { 0 }$ all the way to 0, but all other parameters are unregularized. Sketch a possible decision boundary. How many classification errors does your method make on the training set? Hint: consider the behavior of simple linear regression, $w _ { 0 } + w _ { 1 } x _ { 1 } + w _ { 2 } x _ { 2 }$ when $x _ { 1 } = x _ { 2 } = 0$ .

c. Now suppose we heavily regularize only the $w _ { 1 }$ parameter, i.e., we minimize

$$
J _ { 1 } ( \pmb { w } ) = - \ell ( \pmb { w } , \mathcal { D } _ { \mathrm { t r a i n } } ) + \lambda w _ { 1 } ^ { 2 }
$$

Sketch a possible decision boundary. How many classification errors does your method make on the training set?

d. Now suppose we heavily regularize only the $w _ { 2 }$ parameter. Sketch a possible decision boundary. How many classification errors does your method make on the training set?

Exercise 10.3 [Logistic regression vs LDA/QDA \*] (Source: Jaakkola.) Suppose we train the following binary classifiers via maximum likelihood.

a. GaussI: A generative classifier, where the class-conditional densities are Gaussian, with both covariance matrices set to I (identity matrix), i.e., $p ( \pmb { x } | y = c ) = \mathcal { N } ( \pmb { x } | \pmb { \mu } _ { c } , \mathbf { I } )$ . We assume $p ( y )$ is uniform.   
b. GaussX: as for GaussI, but the covariance matrices are unconstrained, i.e., $p ( \pmb { x } | y = c ) = \mathcal { N } ( \pmb { x } | \pmb { \mu } _ { c } , \pmb { \Sigma } _ { c } )$ .   
c. LinLog: A logistic regression model with linear features.   
d. QuadLog: A logistic regression model, using linear and quadratic features (i.e., polynomial basis function expansion of degree 2).

After training we compute the performance of each model $M$ on the training set as follows:

$$
L ( M ) = \frac { 1 } { n } \sum _ { i = 1 } ^ { n } \log p ( y _ { i } | \pmb { x } _ { i } , \hat { \pmb { \theta } } , M )
$$

(Note that this is the conditional log-likelihood $p ( \boldsymbol { y } | \boldsymbol { x } , \hat { \pmb { \theta } } )$ and not the joint log-likelihood $p ( y , x | \hat { \pmb \theta } )$ .) We now want to compare the performance of each model. We will write $L ( M ) \leq L ( M ^ { \prime } )$ if model $M$ must have lower

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022 (or equal) log likelihood (on the training set) than $M ^ { \prime }$ , for any training set (in other words, $M$ is worse than $M ^ { \prime }$ , at least as far as training set logprob is concerned). For each of the following model pairs, state whether $L ( M ) \leq L ( M ^ { \prime } ) .$ , $L ( M ) \ge L ( M ^ { \prime } )$ , or whether no such statement can be made (i.e., $M$ might sometimes be better than $M ^ { \prime }$ and sometimes worse); also, for each question, briefly (1-2 sentences) explain why.

a. GaussI, LinLog.   
b. GaussX, QuadLog.   
c. LinLog, QuadLog.   
d. GaussI, QuadLog.   
e. Now suppose we measure performance in terms of the average misclassification rate on the training set:

$$
R ( M ) = { \frac { 1 } { n } } \sum _ { i = 1 } ^ { n } I ( y _ { i } \neq { \hat { y } } ( \pmb { x } _ { i } ) )
$$

Is it true in general that $L ( M ) > L ( M ^ { \prime } )$ implies that $R ( M ) < R ( M ^ { \prime } )$ ? Explain why or why not.

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

# 11 Linear Regression

# 11.1 Introduction

In this chapter, we discuss linear regression, which is a very widely used method for predicting a real-valued output (also called the dependent variable or target) $y \in \mathbb { R }$ , given a vector of real-valued inputs (also called independent variables, explanatory variables, or covariates) $\pmb { x } \in \mathbb { R } ^ { D }$ . The key property of the model is that the expected value of the output is assumed to be a linear function of the input, $\mathbb { E } \left[ y | x \right] = w ^ { \top } x$ , which makes the model easy to interpret, and easy to fit to data. We discuss nonlinear extensions later in this book.

# 11.2 Least squares linear regression

In this section, we discuss the most common form of linear regression model.

# 11.2.1 Terminology

The term “linear regression” usually refers to a model of the following form:

$$
p ( y | \mathbf { x } , \pmb { \theta } ) = \mathcal { N } ( y | w _ { 0 } + \pmb { w } ^ { \top } \mathbf { x } , \sigma ^ { 2 } )
$$

where $\pmb \theta = ( w _ { 0 } , \pmb w , \sigma ^ { 2 } )$ are all the parameters of the model. (In statistics, the parameters $w _ { 0 }$ and $\mathbf { \boldsymbol { w } }$ are usually denoted by $\beta _ { 0 }$ and $\beta$ .)

The vector of parameters ${ \pmb w } _ { 1 : D }$ are known as the weights or regression coefficients. Each coefficient $w _ { d }$ specifies the change in the output we expect if we change the corresponding input feature $x _ { d }$ by one unit. For example, suppose $x _ { 1 }$ is the age of a person, $x _ { 2 }$ is their education level (represented as a continuous number), and $y$ is their income. Thus $w _ { 1 }$ corresponds to the increase in income we expect as someone becomes one year older (and hence get more experience), and $w _ { 2 }$ corresponds to the increase in income we expect as someone’s education level increases by one level. The term $w _ { 0 }$ is the offset or bias term, and specifies the output value if all the inputs are 0. This captures the unconditional mean of the response, $\boldsymbol { w } _ { 0 } = \mathbb { E } \left[ \boldsymbol { y } \right]$ , and acts as a baseline. We will usually assume that $_ { x }$ is written as $[ 1 , x _ { 1 } , \ldots , x _ { D } ]$ , so we can absorb the offset term $w _ { 0 }$ into the weight vector $\mathbf { \boldsymbol { w } }$ .

If the input is one-dimensional (so $D = 1$ ), the model has the form $f ( \pmb { x } ; \pmb { w } ) = a \pmb { x } + b$ , where $b = w _ { 0 }$ is the intercept, and $a = w _ { 1 }$ is the slope. This is called simple linear regression. If the input is multi-dimensional, $\pmb { x } \in \mathbb { R } ^ { D }$ where $D > 1$ , the method is called multiple linear regression. If the output is also multi-dimensional, $\pmb { y } \in \mathbb { R } ^ { J }$ , where $J > 1$ , it is called multivariate linear regression,

![](images/f1e7951a7b68d5340fd7f0a79b9e29b3ab640baf251887abebdbbdcf90146bb6.jpg)  
Figure 11.1: Polynomial of degrees 1 and 2 fit to 21 datapoints. Generated by linreg_poly_vs_degree.ipynb.

$$
p ( \pmb { y } | \pmb { x } , \mathbf { W } ) = \prod _ { j = 1 } ^ { J } \mathcal { N } ( y _ { j } | \pmb { w } _ { j } ^ { \top } \pmb { x } , \sigma _ { j } ^ { 2 } )
$$

See Exercise 11.1 for a simple numerical example.

In general, a straight line will not provide a good fit to most data sets. However, we can always apply a nonlinear transformation to the input features, by replacing $_ { x }$ with $\phi ( { \pmb x } )$ to get

$$
p ( y | \mathbf { x } , \pmb \theta ) = \mathcal { N } ( y | \pmb w ^ { \top } \phi ( \mathbf { x } ) , \sigma ^ { 2 } )
$$

As long as the parameters of the feature extractor $\phi$ are fixed, the model remains linear in the parameters, even if it is not linear in the inputs. (We discuss ways to learn the feature extractor, and the final linear mapping, in Part III.)

As a simple example of a nonlinear transformation, consider the case of polynomial regression, which we introduced in Section 1.2.2.2. If the input is 1d, and we use a polynomial expansion of degree $d$ , we get $\phi ( x ) = [ 1 , x , x ^ { 2 } , . . . , x ^ { d } ]$ . See Figure 11.1 for an example. (See also Section 11.5 where we discuss splines.)

# 11.2.2 Least squares estimation

To fit a linear regression model to data, we will minimize the negative log likelihood on the training set. The objective function is given by

$$
\begin{array} { r l } & { \displaystyle \mathrm { N L L } ( \boldsymbol { w } , \boldsymbol { \sigma ^ { 2 } } ) = - \sum _ { n = 1 } ^ { N _ { \mathcal { D } } } \log \left[ \left( \frac { 1 } { 2 \pi \sigma ^ { 2 } } \right) ^ { \frac { 1 } { 2 } } \exp \left( - \frac { 1 } { 2 \sigma ^ { 2 } } ( y _ { n } - \boldsymbol { w ^ { \mathsf { T } } } \boldsymbol { x _ { n } } ) ^ { 2 } \right) \right] } \\ & { \displaystyle \quad \quad = \frac { 1 } { 2 \sigma ^ { 2 } } \sum _ { n = 1 } ^ { N } ( y _ { n } - \hat { y } _ { n } ) ^ { 2 } + \frac { N _ { \mathcal { D } } } { 2 } \log ( 2 \pi \sigma ^ { 2 } ) } \end{array}
$$

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

where we have defined the predicted response ${ \hat { y } } _ { n } \triangleq w ^ { \prime } x _ { n }$ . The MLE is the point where $\nabla _ { \pmb { w } , \sigma } \mathrm { N L L } ( \pmb { w } , \sigma ^ { 2 } ) =$ 0. We can first optimize wrt $\mathbf { \boldsymbol { w } }$ , and then solve for the optimal $\sigma$ .

In this section, we just focus on estimating the weights $\mathbf { \boldsymbol { w } }$ . In this case, the NLL is equal (up to irrelevant constants) to the residual sum of squares, which is given by

$$
\operatorname { R S S } ( \pmb { w } ) = \frac { 1 } { 2 } \sum _ { n = 1 } ^ { N } ( y _ { n } - \pmb { w } ^ { \top } \pmb { x } _ { n } ) ^ { 2 } = \frac { 1 } { 2 } | | \mathbf { X } \pmb { w } - \pmb { y } | | _ { 2 } ^ { 2 } = \frac { 1 } { 2 } ( \mathbf { X } \pmb { w } - \pmb { y } ) ^ { \top } ( \mathbf { X } \pmb { w } - \pmb { y } )
$$

We discuss how to optimize this below.

# 11.2.2.1 Ordinary least squares

From Equation (7.264) we can show that the gradient is given by

$$
\nabla _ { \boldsymbol { w } } \mathrm { R S S } ( \boldsymbol { w } ) = \mathbf { X } ^ { \top } \mathbf { X } \boldsymbol { w } - \mathbf { X } ^ { \top } \boldsymbol { y }
$$

Setting the gradient to zero and solving gives

$$
\mathbf { X } ^ { \mathsf { T } } \mathbf { X } { \boldsymbol { w } } = \mathbf { X } ^ { \mathsf { T } } { \boldsymbol { y } } 
$$

These are known as the normal equations, since, at the optimal solution, $\mathbf { \nabla } y \mathrm { ~ - ~ } \mathbf { X } w$ is normal (orthogonal) to the range of $\mathbf { X }$ , as we explain in Section 11.2.2.2. The corresponding solution $\hat { \textbf { \textit { w } } }$ is the ordinary least squares (OLS) solution, which is given by

$$
\hat { \pmb { w } } = ( \mathbf { X } ^ { \mathsf { T } } \mathbf { X } ) ^ { - 1 } \mathbf { X } ^ { \mathsf { T } } \pmb { y }
$$

The quantity $\mathbf { X } ^ { \dagger } = ( \mathbf { X } ^ { \mathsf { T } } \mathbf { X } ) ^ { - 1 } \mathbf { X } ^ { \mathsf { T } }$ is the (left) pseudo inverse of the (non-square) matrix $\mathbf { X }$ (see Section 7.5.3 for more details).

We can check that the solution is unique by showing that the Hessian is positive definite. In this case, the Hessian is given by

$$
\mathbf { H } ( \pmb { w } ) = \frac { \partial ^ { 2 } } { \partial \pmb { x } ^ { 2 } } \mathrm { R S S } ( \pmb { w } ) = \mathbf { X } ^ { \top } \mathbf { X }
$$

If $\mathbf { X }$ is full rank (so the columns of $\mathbf { X }$ are linearly independent), then $\mathbf { H }$ is positive definite, since for any $v > 0$ , we have

$$
{ \pmb v } ^ { \top } ( { \bf X } ^ { \top } { \bf X } ) { \pmb v } = ( { \bf X } { \pmb v } ) ^ { \top } ( { \bf X } { \pmb v } ) = | | { \bf X } { \pmb v } | | ^ { 2 } > 0
$$

Hence in the full rank case, the least squares objective has a unique global minimum. See Figure 11.2 for an illustration.

# 11.2.2.2 Geometric interpretation of least squares

The normal equations have an elegant geometrical interpretation, deriving from Section 7.7, as we now explain. We will assume $N > D$ , so there are more observations than unknowns. (This is known

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

![](images/f58b153e2743bdab05fa3fd3bfc8ffa1c129d6290992fc7f98d717dbb5bc6ad3.jpg)  
Figure 11.2: (a) Contours of the RSS error surface for the example in Figure 11.1a. The blue cross represents the MLE. (b) Corresponding surface plot. Generated by linreg_contours_sse_plot.ipynb.

![](images/729ea0525ab15de4793d73cb804b7be95a29d7c1e153a775b3bf6e52792fce7c.jpg)  
Figure 11.3: Graphical interpretation of least squares for $m = 3$ equations and $n = 2$ unknowns when solving the system $\mathbf { A } { \boldsymbol { \mathbf { \mathit { x } } } } = \mathbf { \boldsymbol { \mathit { b } } }$ . $\mathbf { \delta } _ { \mathbf { a } _ { 1 } }$ and $\mathbf { \delta } \mathbf { a } _ { 2 }$ are the columns of $\mathbf { A }$ , which define a 2d linear subspace embedded in $\mathbb { R } ^ { 3 }$ . The target vector $^ { b }$ is a vector in $\mathbb { R } ^ { 3 }$ ; its orthogonal projection onto the linear subspace is denoted $\hat { b }$ . The line from $^ { b }$ to $\hat { \pmb { b } }$ is the vector of residual errors, whose norm we want to minimize.

as an overdetermined system.) We seek a vector $\hat { \pmb y } \in \mathbb { R } ^ { N }$ that lies in the linear subspace spanned by $\mathbf { X }$ and is as close as possible to $\pmb { y }$ , i.e., we want to find

$$
\underset { \pmb { \hat { y } } \in \mathrm { s p a n } ( \{ \pmb x _ { : , 1 } , . . . , \pmb x _ { : , d } \} ) } { \mathrm { a r g m i n } } \parallel \pmb { y } - \hat { \pmb y } \parallel _ { 2 } .
$$

where $\pmb { x } _ { : , d }$ is the $d$ ’th column of $\mathbf { X }$ . Since ${ \hat { \pmb y } } \in \operatorname { s p a n } ( \mathbf { X } )$ , there exists some weight vector $\mathbf { \boldsymbol { w } }$ such that

$$
\pmb { \hat { y } } = w _ { 1 } \pmb { x } _ { : , 1 } + \cdot \cdot \cdot + w _ { D } \pmb { x } _ { : , D } = \mathbf { X } \pmb { w }
$$

To minimize the norm of the residual, $\mathbf y - \hat { \mathbf y }$ , we want the residual vector to be orthogonal to every column of $\mathbf { X }$ . Hence

$$
\begin{array} { r } { { \boldsymbol x } _ { : , d } ^ { \top } ( { \boldsymbol y } - \hat { \boldsymbol y } ) = 0 \Rightarrow { \boldsymbol X } ^ { \top } ( { \boldsymbol y } - { \boldsymbol X } { \boldsymbol w } ) = \mathbf { 0 } \Rightarrow { \boldsymbol w } = ( { \boldsymbol X } ^ { \top } { \mathbf { X } } ) ^ { - 1 } { \mathbf { X } } ^ { \top } { \boldsymbol y } } \end{array}
$$

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

Hence our projected value of $\textbf {  { y } }$ is given by

$$
\ \hat { \pmb y } = \mathbf X \pmb w = \mathbf X ( \mathbf X ^ { \top } \mathbf X ) ^ { - 1 } \mathbf X ^ { \top } \pmb y
$$

This corresponds to an orthogonal projection of $\pmb { y }$ onto the column space of $\mathbf { X }$ . For example, consider the case where we have $N = 3$ training examples, each of dimensionality $D = 2$ . The training data defines a 2d linear subspace, defined by the 2 columns of $\mathbf { X }$ , each of which is a point in 3d. We project $\textbf {  { y } }$ , which is also a point in 3d, onto this 2d subspace, as shown in Figure 11.3.

The projection matrix

$$
\operatorname { P r o j } ( \mathbf { X } ) \triangleq \mathbf { X } ( \mathbf { X } ^ { \mathsf { T } } \mathbf { X } ) ^ { - 1 } \mathbf { X } ^ { \mathsf { T } }
$$

is sometimes called the hat matrix, since $\hat { \pmb { y } } = \mathrm { P r o j } ( \mathbf { X } ) \pmb { y }$ . In the special case that $\mathbf { X } = { \boldsymbol { x } }$ is a column vector, the orthogonal projection of $_ y$ onto the line $_ { x }$ becomes

$$
\mathrm { P r o j } ( x ) \pmb { y } = \pmb { x } \frac { \pmb { x } ^ { \top } \pmb { y } } { \pmb { x } ^ { \top } \pmb { x } }
$$

# 11.2.2.3 Algorithmic issues

Recall that the OLS solution is

$$
\begin{array} { r } { \hat { \pmb w } = \mathbf { X } ^ { \dagger } \pmb y = ( \mathbf { X } ^ { \mathsf { T } } \mathbf { X } ) ^ { - 1 } \mathbf { X } ^ { \mathsf { T } } \pmb y } \end{array}
$$

However, even if it is theoretically possible to compute the pseudo-inverse by inverting $\mathbf { X } ^ { \mathsf { I } } \mathbf { X }$ , we should not do so for numerical reasons, since $\mathbf { X } ^ { \mathsf { I } } \mathbf { X }$ may be ill conditioned or singular.

A better (and more general) approach is to compute the pseudo-inverse using the SVD. Indeed, if you look at the source code for the function sklearn.linear_model.fit, you will see that it uses the scipy.linalg.lstsq function, which in turns calls DGELSD, which is an SVD-based solver implemented by the LAPACK library, written in Fortran.1

However, if $\mathbf { X }$ is tall and skinny (i.e., $N \gg D$ ), it can be quicker to use QR decomposition (Section 7.6.2). To do this, let $\mathbf { X } = \mathbf { Q } \mathbf { R }$ , where $\mathbf { Q } ^ { 1 } \mathbf { Q } = \mathbf { I }$ . In Section 7.7, we show that OLS is equivalent to solving the system of linear equations $\mathbf { X } w = y$ in a way that minimizes $| | \mathbf { X } \pmb { w } - \pmb { y } | | _ { 2 } ^ { 2 }$ . (If $N = D$ and $\mathbf { X }$ is full rank, the equations have a unique solution, and the error will be $0$ .) Using QR decomposition, we can rewrite this system of equations as follows:

$$
\begin{array} { c } { ( \mathbf { Q R } ) { \boldsymbol { w } } = { \boldsymbol { y } } } \\ { \mathbf { Q } ^ { \top } \mathbf { Q R } { \boldsymbol { w } } = \mathbf { Q } ^ { \top } { \boldsymbol { y } } } \\ { { \boldsymbol { w } } = \mathbf { R } ^ { - 1 } ( \mathbf { Q } ^ { \top } { \boldsymbol { y } } ) } \end{array}
$$

Since $\mathbf { R }$ is upper triangular, we can solve this last set of equations using backsubstitution, thus avoiding matrix inversion. See linsys_solve_demo.ipynb for a demo.

An alternative to the use of direct methods based on matrix decomposition (such as SVD and QR) is to use iterative solvers, such as the conjugate gradient method (which assumes $\mathbf { X }$ is symmetric positive definite), and the GMRES (generalized minimal residual method), that works for general $\mathbf { X }$ . (In SciPy, this is implemented by sparse.linalg.gmres.) These methods just require the ability to perform matrix-vector multiplications (i.e., an implementation of a linear operator), and thus are well-suited to problems where $\mathbf { X }$ is sparse or structured. For details, see e.g., [TB97].

A final important issue is that it is usually essential to standardize the input features before fitting the model, to ensure that they are zero mean and unit variance. We can do this using Equation (10.51).

# 11.2.2.4 Weighted least squares

In some cases, we want to associate a weight with each example. For example, in heteroskedastic regression, the variance depends on the input, so the model has the form

$$
p ( y | x ; \theta ) = { \mathcal { N } } ( y | w ^ { \mathsf { T } } x , \sigma ^ { 2 } ( x ) ) = { \frac { 1 } { { \sqrt { 2 \pi \sigma ^ { 2 } ( x ) } } } } \exp \left( - { \frac { 1 } { 2 \sigma ^ { 2 } ( x ) } } ( y - w ^ { \mathsf { T } } x ) ^ { 2 } \right)
$$

Thus

$$
p ( \pmb { y } | \pmb { x } ; \pmb { \theta } ) = \mathcal { N } ( \pmb { y } | \mathbf { X } \pmb { w } , \pmb { \Lambda } ^ { - 1 } )
$$

where $\pmb { \Lambda } = \mathrm { d i a g } ( 1 / \sigma ^ { 2 } ( \pmb { x } _ { n } ) )$ . This is known as weighted linear regression. One can show that the MLE is given by

$$
\pmb { \hat { w } } = ( \mathbf { X } ^ { \top } \pmb { \Lambda } \mathbf { X } ) ^ { - 1 } \mathbf { X } ^ { \top } \pmb { \Lambda } \pmb { y }
$$

This is known as the weighted least squares estimate.

# 11.2.3 Other approaches to computing the MLE

In this section, we discuss other approaches for computing the MLE.

# 11.2.3.1 Solving for offset and slope separately

Typically we use a model of the form $p ( y | \mathbf { x } , \pmb { \theta } ) = \mathcal { N } ( y | w _ { 0 } + w ^ { \textnormal { l } } \mathbf { x } , \sigma ^ { 2 } )$ , where $w _ { 0 }$ is an offset or “bias” term. We can compute $( w _ { 0 } , \pmb { w } )$ at the same time by adding a column of 1s to $\mathbf { X }$ , and the computing the MLE as above. Alternatively, we can solve for $\mathbf { \boldsymbol { w } }$ and $w _ { 0 }$ separately. (This will be useful later.) In particular, one can show that

$$
\begin{array} { l } { { \displaystyle { \hat { w } } = ( \mathbf { X } _ { c } ^ { \mathsf { T } } \mathbf { X } _ { c } ) ^ { - 1 } \mathbf { X } _ { c } ^ { \mathsf { T } } y _ { c } = \left[ \overset { N _ { \mathcal { D } } } { \underset { i = 1 } { \sum } } ( \mathbf { x } _ { n } - \overline { { \mathbf { x } } } ) ( \mathbf { x } _ { n } - \overline { { \mathbf { x } } } ) ^ { \mathsf { T } } \right] ^ { - 1 } \left[ \overset { N _ { \mathcal { D } } } { \underset { i = 1 } { \sum } } ( y _ { n } - \overline { { y } } ) ( \mathbf { x } _ { n } - \overline { { \mathbf { x } } } ) \right] } } \\ { { \displaystyle { \hat { w } } _ { 0 } = \frac { 1 } { N } \sum _ { n } y _ { n } - \frac { 1 } { N } \sum _ { n } \mathbf { x } _ { n } ^ { \mathsf { T } } \hat { w } = \overline { { y } } - \overline { { \mathbf { x } } } ^ { \mathsf { T } } \hat { w } } } \end{array}
$$

where $\mathbf { X } _ { c }$ is the centered input matrix containing $\pmb { x } _ { n } ^ { c } = \pmb { x } _ { n } - \overline { { \pmb { x } } }$ along its rows, and ${ \pmb y } _ { c } = { \pmb y } - { \pmb y }$ is the centered output vector. Thus we can first compute $\hat { \pmb w }$ on centered data, and then estimate $w _ { 0 }$ using $\overline { { y } } - \overline { { x } } ^ { \top } \hat { w }$ .

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

# 11.2.3.2 Simple linear regression (1d inputs)

In the case of 1d (scalar) inputs, the results from Section 11.2.3.1 reduce to the following simple form, which may be familiar from basic statistics classes:

$$
\begin{array} { l } { \hat { w } _ { 1 } = \displaystyle \frac { \sum _ { n } ( x _ { n } - \overline { { x } } ) ( y _ { n } - \bar { y } ) } { \sum _ { n } ( x _ { n } - \bar { x } ) ^ { 2 } } = \frac { C _ { x y } } { C _ { x x } } } \\ { \hat { w } _ { 0 } = \bar { y } - \hat { w } _ { 1 } \bar { x } = \mathbb { E } \left[ y \right] - w _ { 1 } \mathbb { E } \left[ x \right] } \end{array}
$$

where $C _ { x y } = \mathrm { C o v } \left[ X , Y \right]$ and $C _ { x x } = \operatorname { C o v } \left[ X , X \right] = \mathbb { V } \left[ X \right]$ . We will use this result below.

# 11.2.3.3 Partial regression

From Equation (11.27), we can compute the regression coefficient of $Y$ on $X$ as follows:

$$
R _ { Y X } \triangleq \frac { \partial } { \partial x } \mathbb { E } \left[ Y | X = x \right] = w _ { 1 } = \frac { C _ { x y } } { C _ { x x } }
$$

This is the slope of the linear prediction for $Y$ given $X$ .

Now consider the case where we have 2 inputs, so $\begin{array} { r } { Y = w _ { 0 } + w _ { 1 } X _ { 1 } + w _ { 2 } X _ { 2 } + \epsilon } \end{array}$ , where $\mathbb { E } \left[ \boldsymbol { \epsilon } \right] = 0$ . One can show that the optimal regression coefficient for $w _ { 1 }$ is given by $R _ { Y X _ { 1 } \cdot X _ { 2 } }$ , which is the partial regression coefficient of $Y$ on $X _ { 1 }$ , keeping $X _ { 2 }$ constant:

$$
w _ { 1 } = R _ { Y X _ { 1 } \cdot X _ { 2 } } = \frac { \partial } { \partial x } \mathbb { E } \left[ Y | X _ { 1 } = x , X _ { 2 } \right]
$$

Note that this quantity is invariant to the specific value of $X _ { 2 }$ we condition on.

We can derive $w _ { 2 }$ in a similar manner. Indeed, we can extend this to multiple input variables. In each case, we find the optimal coefficients are equal to the partial regression coefficients. This means that we can interpret the $j$ ’th coefficient $\hat { w } _ { j }$ as the change in output $y$ we expect per unit change in input $x _ { j }$ , keeping all the other inputs constant.

# 11.2.3.4 Recursively computing the MLE

OLS is a batch method for computing the MLE. In some applications, the data arrives in a continual stream, so we want to compute the estimate online, or recursively, as we discussed in Section 4.4.2. In this section, we show how to do this for the case of simple (1d) linear regession.

Recall from Section 11.2.3.2 that the batch MLE for simple linear regression is given by

$$
\begin{array} { l l } { \hat { w } _ { 1 } = \displaystyle \frac { \sum _ { n } ( x _ { n } - \overline { { x } } ) ( y _ { n } - \bar { y } ) } { \sum _ { n } ( x _ { n } - \bar { x } ) ^ { 2 } } = \frac { C _ { x y } } { C _ { x x } } } \\ { \hat { w } _ { 0 } = \bar { y } - \hat { w } _ { 1 } \bar { x } } \end{array}
$$

where $C _ { x y } = \mathrm { C o v } \left[ X , Y \right]$ and $C _ { x x } = \operatorname { C o v } \left[ X , X \right] = \mathbb { V } \left[ X \right]$ .

We now discuss how to compute these results in a recursive fashion. To do this, let us define the

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

following sufficient statistics:

$$
{ \begin{array} { l } { { \overline { { x } } } ^ { ( n ) } = { \displaystyle { \frac { 1 } { n } } \sum _ { i = 1 } ^ { n } x _ { i } , ~ { \overline { { y } } } ^ { ( n ) } = { \frac { 1 } { n } } \sum _ { i = 1 } ^ { n } y _ { i } } } \\ { { \displaystyle C _ { x x } ^ { ( n ) } = { \frac { 1 } { n } } \sum _ { i = 1 } ^ { n } ( x _ { i } - { \overline { { x } } } ) ^ { 2 } , ~ C _ { x y } ^ { ( n ) } = { \frac { 1 } { n } } \sum _ { i = 1 } ^ { n } ( x _ { i } - { \overline { { x } } } ) ( y _ { i } - { \overline { { y } } } ) , ~ C _ { y y } ^ { ( n ) } = { \frac { 1 } { n } } \sum _ { i = 1 } ^ { n } ( y _ { i } - { \overline { { y } } } ) } } \end{array} }
$$

We can update the means online using

$$
\overline { { x } } ^ { ( n + 1 ) } = \overline { { x } } ^ { ( n ) } + \frac { 1 } { n + 1 } ( x _ { n + 1 } - \overline { { x } } ^ { ( n ) } ) , \overline { { y } } ^ { ( n + 1 ) } = \overline { { y } } ^ { ( n ) } + \frac { 1 } { n + 1 } ( y _ { n + 1 } - \overline { { y } } ^ { ( n ) } )
$$

To update the covariance terms, let us first rewrite Cx(ny as follows:

$$
\begin{array} { c l } { \displaystyle C _ { x y } ^ { ( n ) } = \frac { 1 } { n } \left[ ( \sum _ { i = 1 } ^ { n } x _ { i } y _ { i } ) + ( \sum _ { i = 1 } ^ { n } \overline { { x } } ^ { ( n ) } \overline { { y } } ^ { ( n ) } ) - \overline { { x } } ^ { ( n ) } ( \sum _ { i = 1 } ^ { n } y _ { i } ) - \overline { { y } } ^ { ( n ) } ( \sum _ { i = 1 } ^ { n } x _ { i } ) \right] } \\ { \displaystyle ~ } & { = \frac { 1 } { n } \left[ ( \sum _ { i = 1 } ^ { n } x _ { i } y _ { i } ) + n \overline { { x } } ^ { ( n ) } \overline { { y } } ^ { ( n ) } - \overline { { x } } ^ { ( n ) } n \overline { { y } } ^ { ( n ) } - \overline { { y } } ^ { ( n ) } n \overline { { x } } ^ { ( n ) } \right] } \\ { \displaystyle } & { = \frac { 1 } { n } \left[ ( \sum _ { i = 1 } ^ { n } x _ { i } y _ { i } ) - n \overline { { x } } ^ { ( n ) } \overline { { y } } ^ { ( n ) } \right] } \end{array}
$$

Hence

$$
\sum _ { i = 1 } ^ { n } x _ { i } y _ { i } = n C _ { x y } ^ { ( n ) } + n \overline { { x } } ^ { ( n ) } \overline { { y } } ^ { ( n ) }
$$

and so

$$
C _ { x y } ^ { ( n + 1 ) } = \frac { 1 } { n + 1 } \left[ x _ { n + 1 } y _ { n + 1 } + n C _ { x y } ^ { ( n ) } + n \overline { { x } } ^ { ( n ) } \overline { { y } } ^ { ( n ) } - ( n + 1 ) \overline { { x } } ^ { ( n + 1 ) } \overline { { y } } ^ { ( n + 1 ) } \right]
$$

We can derive the update for $C _ { x x } ^ { ( n + 1 ) }$ in a similar manner.

See Figure 11.4 for a simple illustration of these equations in action for a 1d regression model.

To extend the above analysis to $D$ -dimensional inputs, the easiest approach is to use SGD. The esulting algorithm is called the least mean squares algorithm; see Section 8.4.2 for details.

# 11.2.3.5 Deriving the MLE from a generative perspective

Linear regression is a discriminative model of the form $p ( \boldsymbol { y } | \boldsymbol { x } )$ . However, we can also use generative models for regression, by analogy to how we use generative models for classification in Chapter 9, The goal is to compute the conditional expectation

$$
f ( \pmb { x } ) = \mathbb { E } \left[ y | \pmb { x } \right] = \int y \ p ( y | \pmb { x } ) d y = \frac { \int y \ p ( \pmb { x } , y ) d y } { \int p ( \pmb { x } , y ) d y }
$$

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

![](images/4f6b7c7a6c13d14a857209e057b35d62e5e95cd4fc0e0272e9177d90e3f5116f.jpg)  
Figure 11.4: Regression coefficients over time for the 1d model in Figure $\boldsymbol { \mathit { 1 . 7 a ( a ) } }$ . Generated by linregOnlineDemo.ipynb.

Suppose we fit $p ( { \pmb x } , { \boldsymbol y } )$ using an MVN. The MLEs for the parameters of the joint distribution are the empiricial means and covariances (see Section 4.2.6 for a proof of this result):

$$
\begin{array} { l } { \displaystyle \mu _ { x } = \frac { 1 } { N } \sum _ { n } x _ { n } } \\ { \displaystyle \mu _ { y } = \frac { 1 } { N } \sum _ { n } y _ { n } } \\ { \displaystyle \Sigma _ { x x } = \frac { 1 } { N } \sum _ { n } ( x _ { n } - \overline { x } ) ( x _ { n } - \overline { x } ) ^ { \top } = \frac { 1 } { N } { \bf X } _ { c } ^ { \top } { \bf X } _ { c } } \\ { \displaystyle \Sigma _ { x y } = \frac { 1 } { N } \sum _ { n } ( x _ { n } - \overline { x } ) ( y _ { n } - \overline { y } ) = \frac { 1 } { N } { \bf X } _ { c } ^ { \top } y _ { c } } \end{array}
$$

Hence from Equation (3.28), we have

$$
\mathbb { E } \left[ y | { \pmb x } \right] = \mu _ { y } + \pmb { \Sigma } _ { x y } ^ { \mathsf { T } } \pmb { \Sigma } _ { x x } ^ { - 1 } ( { \pmb x } - { \pmb \mu } _ { x } )
$$

We can rewrite this as $\mathbb { E } \left[ y | \pmb { x } \right] = w _ { 0 } + \pmb { w } ^ { 1 } \pmb { x }$ by defining

$$
\begin{array} { r l } & { w _ { 0 } = \mu _ { y } - { \pmb w } ^ { \top } \pmb { \mu } _ { x } = \overline { { y } } - { \pmb w } ^ { \top } \overline { { \pmb x } } } \\ & { { \pmb w } = { \pmb \Sigma } _ { x x } ^ { - 1 } { \pmb \Sigma } _ { x y } = \left( { \pmb X } _ { c } ^ { \top } { \pmb X } _ { c } \right) ^ { - 1 } { \pmb X } _ { c } ^ { \top } { \pmb y } _ { c } } \end{array}
$$

This matches the MLEs for the discriminative model as we showed in Section 11.2.3.1. Thus we see that fitting the joint model, and then conditioning it, yields the same result as fitting the conditional model. However, this is only true for Gaussian models (see Section 9.4 for further discussion of this point).

# 11.2.3.6 Deriving the MLE for $\sigma ^ { 2 }$

After estimating $\hat { \pmb w } _ { \mathrm { m l e } }$ using one of the above methods, we can estimate the noise variance. It is easy to show that the MLE is given by

$$
\hat { \sigma } _ { \mathrm { m l e } } ^ { 2 } = \underset { \sigma ^ { 2 } } { \mathrm { a r g m i n } } \mathrm { N L L } ( \hat { w } , \sigma ^ { 2 } ) = \frac { 1 } { N } \sum _ { n = 1 } ^ { N _ { \mathcal { D } } } ( y _ { n } - x _ { n } ^ { \top } \hat { w } ) ^ { 2 }
$$

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

![](images/a87e476e5991fb67bd37f9c882c47d26b58da25f7285a0c3c46261c5a2be9e80.jpg)  
Figure 11.5: Residual plot for polynomial regression of degree 1 and 2 for the functions in Figure 1.7a(a-b). Generated by linreg_poly_vs_degree.ipynb.

![](images/fea080db833e3c12c593d15e007aaea306ee974e19cde8aa3101194a745d23ce.jpg)  
Figure 11.6: Fit vs actual plots for polynomial regression of degree 1 and 2 for the functions in Figure 1.7a(a-b). Generated by linreg_poly_vs_degree.ipynb.

This is just the MSE of the residuals, which is an intuitive result.

# 11.2.4 Measuring goodness of fit

In this section, we discuss some simple ways to assess how well a regression model fits the data (which is known as goodness of fit).

# 11.2.4.1 Residual plots

For 1d inputs, we can check the reasonableness of the model by plotting the residuals, $\boldsymbol { r } _ { n } = \boldsymbol { y } _ { n } - \boldsymbol { \hat { y } } _ { n }$ , vs the input $x _ { n }$ . This is called a residual plot. The model assumes that the residuals have a ${ \mathcal { N } } ( 0 , \sigma ^ { 2 } )$ distribution, so the residual plot should be a cloud of points more or less equally above and below the horizontal line at 0, without any obvious trends.

As an example, in Figure 11.5(a), we plot the residuals for the linear model in Figure 1.7a(a). We see that there is some curved structure to the residuals, indicating a lack of fit. In Figure 11.5(b), we plot the residuals for the quadratic model in Figure 1.7a(b). We see a much better fit.

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

To extend this approach to multi-dimensional inputs, we can plot predictions ${ \hat { y } } _ { n }$ vs the true output $y _ { n }$ , rather than plotting vs $x _ { n }$ . A good model will have points that lie on a diagonal line. See Figure 11.6 for some examples.

# 11.2.4.2 Prediction accuracy and $R ^ { 2 }$

We can assess the fit quantitatively by computing the RSS (residual sum of squares) on the dataset: $\begin{array} { r } { \operatorname { R S S } ( \pmb { w } ) = \sum _ { n = 1 } ^ { N } ( y _ { n } - \pmb { w } ^ { \top } \pmb { x } _ { n } ) ^ { 2 } } \end{array}$ . A model with lower RSS fits the data better. Another measure that is used is root mean squared error or RMSE:

$$
\mathrm { R M S E } ( \boldsymbol { w } ) \triangleq \sqrt { \frac { 1 } { N } \mathrm { R S S } ( \boldsymbol { w } ) }
$$

A more interpretable measure can be computed using the coefficient of determination, denoted by $R ^ { 2 }$ :

$$
R ^ { 2 } \triangleq 1 - \frac { \sum _ { n = 1 } ^ { N } ( \hat { y } _ { n } - y _ { n } ) ^ { 2 } } { \sum _ { n = 1 } ^ { N } ( \overline { { y } } - y _ { n } ) ^ { 2 } } = 1 - \frac { \mathrm { R S S } } { \mathrm { T S S } }
$$

where $\begin{array} { r } { \overline { { y } } = \frac { 1 } { N } \sum _ { n = 1 } ^ { N } y _ { n } } \end{array}$ is the empirical mean of the response, $\begin{array} { r } { \mathrm { R S S } = \sum _ { n = 1 } ^ { N } ( y _ { n } - \hat { y } _ { n } ) ^ { 2 } } \end{array}$ is the residual sum of squares, and $\begin{array} { r } { \mathrm { T S S } = \sum _ { n = 1 } ^ { N } ( y _ { n } - \overline { { y } } ) ^ { 2 } } \end{array}$ is the total sum of squares. Thus we see that $R ^ { 2 }$ measures the variance in the predictions relative to a simple constant prediction of ${ \hat { y } } _ { n } = { \overline { { y } } }$ . One can show that $0 \leq R ^ { 2 } \leq 1$ , where larger values imply a greater reduction in variance (better fit). This is illustrated in Figure 11.6.

# 11.3 Ridge regression

Maximum likelihood estimation can result in overfitting, as we discussed in Section 1.2.2.2. A simple solution to this is to use MAP estimation with a zero-mean Gaussian prior on the weights, $p ( \pmb { w } ) = \mathcal { N } ( \pmb { w } | \mathbf { 0 } , \lambda ^ { - 1 } \mathbf { I } )$ , as we discused in Section 4.5.3. This is called ridge regression.

In more detail, we compute the MAP estimate as follows:

$$
\begin{array} { c } { \displaystyle \pmb { \hat { w } } _ { \mathrm { m a p } } = \mathrm { a r g m i n } \frac { 1 } { 2 \sigma ^ { 2 } } ( \pmb { y } - \mathbf { X } \pmb { w } ) ^ { \top } ( \pmb { y } - \mathbf { X } \pmb { w } ) + \frac { 1 } { 2 \tau ^ { 2 } } \pmb { w } ^ { \top } \pmb { w } } \\ { \displaystyle = \mathrm { a r g m i n R S S } ( \pmb { w } ) + \lambda | | \pmb { w } | | _ { 2 } ^ { 2 } } \end{array}
$$

where λ ≜ σ2 is proportional to the strength of the prior, and

$$
| | \boldsymbol { \mathbf { w } } | | _ { 2 } \triangleq \sqrt { \sum _ { d = 1 } ^ { D } | w _ { d } | ^ { 2 } } = \sqrt { \boldsymbol { \mathbf { w } } ^ { \intercal } \boldsymbol { \mathbf { w } } }
$$

is the $\ell _ { 2 }$ norm of the vector $\mathbf { \boldsymbol { w } }$ . Thus we are penalizing weights that become too large in magnitude.   
In general, this technique is called $\ell _ { 2 }$ regularization or weight decay, and is very widely used.   
See Figure 4.5 for an illustration.

Note that we do not penalize the offset term $w _ { 0 }$ , since that only affects the global mean of the output, and does not contribute to overfitting. See Exercise 11.2.

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

# 11.3.1 Computing the MAP estimate

In this section, we discuss algorithms for computing the MAP estimate. The MAP estimate corresponds to minimizing the following penalized objective:

$$
J ( \pmb { w } ) = ( \pmb { y } - \mathbf { X } \pmb { w } ) ^ { \top } ( \pmb { y } - \mathbf { X } \pmb { w } ) + \lambda | | \pmb { w } | | _ { 2 } ^ { 2 }
$$

where $\lambda = \sigma ^ { 2 } / \tau ^ { 2 }$ is the strength of the regularizer. The derivative is given by

$$
\nabla _ { \boldsymbol { w } } J ( \boldsymbol { w } ) = 2 \left( \mathbf { X } ^ { \mathsf { T } } \mathbf { X } \boldsymbol { w } - \mathbf { X } ^ { \mathsf { T } } \boldsymbol { y } + \lambda \boldsymbol { w } \right)
$$

and hence

$$
{ \hat { w } } _ { \mathrm { m a p } } = ( \mathbf { X } ^ { \mathsf { T } } \mathbf { X } + \lambda \mathbf { I } _ { D } ) ^ { - 1 } \mathbf { X } ^ { \mathsf { T } } \pmb { y } = ( \sum _ { n } \pmb { x } _ { n } \pmb { x } _ { n } ^ { \mathsf { T } } + \lambda \mathbf { I } _ { D } ) ^ { - 1 } ( \sum _ { n } y _ { n } \pmb { x } _ { n } )
$$

# 11.3.1.1 Solving using QR

Naively computing the primal estimate ${ \pmb w } = ( { \pmb X } ^ { 1 } { \pmb X } + \lambda { \bf I } ) ^ { - 1 } { \pmb X } ^ { 1 } { \pmb y }$ using matrix inversion is a bad idea, since it can be slow and numerically unstable. In this section, we describe a way to convert the problem to a standard least squares problem, to which we can apply QR decomposition, as discussed in Section 11.2.2.3.

We assume the prior has the form $p ( \pmb { w } ) = \mathcal { N } ( \mathbf { 0 } , \pmb { \Lambda } ^ { - 1 } )$ , where $\pmb { \Lambda }$ is the precision matrix. In the case of ridge regression, $\mathbf { \Delta } \Lambda = ( 1 / \tau ^ { 2 } ) \mathbf { I }$ . We can emulate this prior by adding “virtual data” to the training set to get

$$
\tilde { \mathbf { X } } = \binom { \mathbf { X } / \sigma } { \sqrt { \Lambda } } , \tilde { \pmb { y } } = \binom { \pmb { y } / \sigma } { \mathbf { 0 } _ { D \times 1 } }
$$

where $\mathbf { \Lambda } \mathbf { \Lambda } = \sqrt { \mathbf { A } } \sqrt { \mathbf { A } } ^ { \top }$ is a Cholesky decomposition of $\pmb { \Lambda }$ . We see that $\tilde { \mathbf { X } }$ is $( N _ { D } + D ) \times D$ , where the extra rows represent pseudo-data from the prior.

We now show that the RSS on this expanded data is equivalent to penalized RSS on the original data:

$$
\begin{array} { l } { f ( w ) = ( \tilde { y } - \tilde { \mathbf { X } } w ) ^ { \mathrm { { T } } } ( \tilde { y } - \tilde { \mathbf { X } } w ) } \\ { \quad = \left( \left( \begin{array} { l } { y / \sigma } \\ { 0 } \end{array} \right) - \left( \begin{array} { l } { \mathbf { X } / \sigma } \\ { \sqrt { \Lambda } } \end{array} \right) w \right) ^ { \mathrm { { T } } } \left( \left( \begin{array} { l } { y / \sigma } \\ { 0 } \end{array} \right) - \left( \begin{array} { l } { \mathbf { X } / \sigma } \\ { \sqrt { \Lambda } } \end{array} \right) w \right) } \\ { \quad = \left( \begin{array} { l } { \frac { 1 } { \sigma } ( y - \mathbf { X } w ) } \\ { \phantom { \frac { 1 } { \sigma } } - \sqrt { \Lambda } w } \end{array} \right) ^ { \mathrm { { T } } } \left( \begin{array} { l } { \frac { 1 } { \sigma } ( y - \mathbf { X } w ) } \\ { \phantom { \frac { 1 } { \sigma } } - \sqrt { \Lambda } w } \end{array} \right) } \\ { \quad = \frac { 1 } { \sigma ^ { 2 } } ( y - \mathbf { X } w ) ^ { \mathrm { { T } } } ( y - \mathbf { X } w ) + ( \sqrt { \Lambda } w ) ^ { \mathrm { { T } } } ( \sqrt { \Lambda } w ) } \\ { \quad = \frac { 1 } { \sigma ^ { 2 } } ( y - \mathbf { X } w ) ^ { \mathrm { { T } } } ( y - \mathbf { X } w ) + w ^ { \mathrm { { T } } } \Lambda w } \end{array}
$$

Hence the MAP estimate is given by

$$
\begin{array} { r } { \hat { \pmb w } _ { \mathrm { m a p } } = ( \tilde { \mathbf X } ^ { \top } \tilde { \mathbf X } ) ^ { - 1 } \tilde { \mathbf X } ^ { \top } \tilde { \pmb y } } \end{array}
$$

which can be solved using standard OLS methods. In particular, we can compute the QR decomposition of $\ddot { \bf X }$ , and then proceed as in Section 11.2.2.3. This takes $O ( ( N + D ) D ^ { 2 } )$ time.

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

# 11.3.1.2 Solving using SVD

In this section, we assume $D > N$ , which is the usual case when using ridge regression. In this case, it is faster to use SVD than QR. To see how this works, let $\mathbf { X } = \mathbf { U S V } ^ { \mid }$ be the SVD of $\mathbf { X }$ , where $\mathbf { V } ^ { \mathsf { I } } \mathbf { V } = \mathbf { I } _ { N }$ , $\mathbf { U U } ^ { \mathsf { I } } = \mathbf { U } ^ { \mathsf { I } } \mathbf { U } = \mathbf { I } _ { N }$ , and $\mathbf { s }$ is a diagonal $N \times N$ matrix. Now let $\mathbf { R } = \mathbf { U } \mathbf { S }$ be an $N _ { \mathcal { D } } \times N _ { \mathcal { D } }$ matrix. One can show (see Exercise 18.4 of [HTF09]) that

$$
{ \hat { \boldsymbol { w } } } _ { \mathrm { m a p } } = \mathbf { V } ( \mathbf { R } ^ { \mathsf { T } } \mathbf { R } + \lambda \mathbf { I } _ { N } ) ^ { - 1 } \mathbf { R } ^ { \mathsf { T } } \boldsymbol { y }
$$

In other words, we can replace the $D$ -dimensional vectors ${ \bf { x } } _ { i }$ with the $N _ { \mathcal { D } }$ -dimensional vectors $\boldsymbol { r } _ { i }$ and perform our penalized fit as before. The overall time is now $O ( D N _ { D } { } ^ { 2 } )$ operations, which is less than $O ( D ^ { 3 } )$ if $D > N _ { \mathcal { D } }$ .

# 11.3.2 Connection between ridge regression and PCA

In this section, we discuss an interesting connection between ridge regression and PCA (which we describe in Section 20.1), in order to gain further insight into why ridge regression works well. Our discussion is based on [HTF09, p66].

Let $\mathbf { X } = \mathbf { U S V } ^ { \mathsf { T } }$ be the SVD of $\mathbf { X }$ , where $\mathbf { V } ^ { \mathsf { T } } \mathbf { V } = \mathbf { I } _ { N }$ , $\mathbf { U U } ^ { \parallel } = \mathbf { U } ^ { \parallel } \mathbf { U } = \mathbf { I } _ { N }$ , and $\mathbf { s }$ is a diagonal $N \times N$ matrix. Using Equation (11.65) we can see that the ridge predictions on the training set are given by

$$
\begin{array} { l } { { \displaystyle { \hat { \pmb y } } = \mathbf { X } { \hat { \pmb w } } _ { \mathrm { m a p } } = \mathbf { U S V } ^ { \mathsf { T } } \mathbf { V } ( \mathbf { S } ^ { 2 } + \lambda \mathbf { I } ) ^ { - 1 } \mathbf { S } \mathbf { U } ^ { \mathsf { T } } \pmb y } } \\ { ~ = \mathbf { U } \tilde { \mathbf { S } } \mathbf { U } ^ { \mathsf { T } } \pmb y = \displaystyle \sum _ { j = 1 } ^ { D } \pmb { u } _ { j } \tilde { S } _ { j j } \pmb { u } _ { j } ^ { \mathsf { T } } \pmb y } \end{array}
$$

where

$$
\tilde { S } _ { j j } \triangleq [ \mathbf { S } ( \mathbf { S } ^ { 2 } + \lambda I ) ^ { - 1 } \mathbf { S } ] _ { j j } = \frac { \sigma _ { j } ^ { 2 } } { \sigma _ { j } ^ { 2 } + \lambda }
$$

and σj are the singular values of $\mathbf { X }$ . Hence

$$
\hat { \pmb y } = { \bf X } \hat { \pmb w } _ { \mathrm { m a p } } = \sum _ { j = 1 } ^ { D } { \pmb u } _ { j } \frac { \sigma _ { j } ^ { 2 } } { \sigma _ { j } ^ { 2 } + \lambda } { \pmb u } _ { j } ^ { \top } { \pmb y }
$$

In contrast, the least squares prediction is

$$
\hat { \boldsymbol { y } } = \mathbf { X } \hat { \boldsymbol { w } } _ { \mathrm { m l e } } = ( \mathbf { U S V } ^ { \top } ) ( \mathbf { V S } ^ { - 1 } \mathbf { U } ^ { \top } \boldsymbol { y } ) = \mathbf { U U } ^ { \top } \boldsymbol { y } = \sum _ { j = 1 } ^ { D } u _ { j } u _ { j } ^ { \top } \boldsymbol { y }
$$

If $\sigma _ { j } ^ { 2 }$ is small compared to $\lambda$ , then direction $\boldsymbol { \mathbf { \mathit { u } } } _ { j }$ will not have much effect on the prediction. In view of this, we define the effective number of degrees of freedom of the model as follows:

$$
\operatorname * { d o f } ( \lambda ) = \sum _ { j = 1 } ^ { D } \frac { \sigma _ { j } ^ { 2 } } { \sigma _ { j } ^ { 2 } + \lambda }
$$

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

![](images/fa2fdb278264009ce040195b3a433f3af41a41845a6fb7018647a541c38ba180.jpg)  
Figure 11.7: Geometry of ridge regression. The likelihood is shown as an ellipse, and the prior is shown as a circle centered on the origin. Adapted from Figure 3.15 of [Bis06]. Generated by geom_ridge.ipynb.

When $\lambda = 0$ , $\operatorname* { d o f } ( \lambda ) = D$ , and as $\lambda \to \infty$ , $\operatorname* { d o f } ( \lambda )  0$ .

Let us try to understand why this behavior is desirable. In Section 11.7, we show that Cov $[ { \pmb w } | { \pmb { \mathcal D } } ] \propto$ $( \mathbf { X } ^ { \mathsf { I } } \mathbf { X } ) ^ { - 1 }$ , if we use a uniform prior for $\mathbf { \boldsymbol { w } }$ . Thus the directions in which we are most uncertain about $\mathbf { \boldsymbol { w } }$ are determined by the eigenvectors of $( \mathbf { X } ^ { \mathsf { I } } \mathbf { X } ) ^ { - 1 }$ with the largest eigenvalues, as shown in Figure 7.6; these correspond to the eigenvectors of $\mathbf { X } ^ { \mathsf { I } } \mathbf { X }$ with the smallest eigenvalues. In Section 7.5.2, we show that the squared singular values $\sigma _ { j } ^ { 2 }$ are equal to the eigenvalues of $\mathbf { X } ^ { \mathsf { I } } \mathbf { X }$ . Hence small singular values $\sigma _ { j }$ correspond to directions with high posterior variance. It is these directions which ridge shrinks the most.

This process is illustrated in Figure 11.7. The horizontal $w _ { 1 }$ parameter is not-well determined by the data (has high posterior variance), but the vertical $w _ { 2 }$ parameter is well-determined. Hence $w _ { \mathrm { m a p } } ( 2 )$ is close to $w _ { \mathrm { m l e } } ( 2 )$ , but $w _ { \mathrm { m a p } } ( 1 )$ is shifted strongly towards the prior mean, which is 0. In this way, ill-determined parameters are reduced in size towards 0. This is called shrinkage.

There is a related, but different, technique called principal components regression, which is a supervised version of PCA, which we explain in Section 20.1. The idea is this: first use PCA to reduce the dimensionality to $K$ dimensions, and then use these low dimensional features as input to regression. However, this technique does not work as well as ridge regression in terms of predictive accuracy [HTF01, p70]. The reason is that in PC regression, only the first $K$ (derived) dimensions are retained, and the remaining $D - K$ dimensions are entirely ignored. By contrast, ridge regression uses a “soft” weighting of all the dimensions.

# 11.3.3 Choosing the strength of the regularizer

To find the optimal value of $\lambda$ , we can try a finite number of distinct values, and use cross validation to estimate their expected loss, as discussed in Section 4.5.5.2. See Figure 4.5d for an example.

This approach can be quite expensive if we have many values to choose from. Fortunately, we can often warm start the optimization procedure, using the value of $\hat { \pmb w } ( \lambda _ { k } )$ as an initializer for $\hat { \pmb { w } } ( \lambda _ { k + 1 } )$ , where $\lambda _ { k + 1 } < \lambda _ { k }$ ; in other words, we start with a highly constrained model (strong regularizer), and then gradually relax the constraints (decrease the amount of regularization). The set of parameters $\hat { \pmb { w } } _ { k }$ that we sweep out in this way is known as the regularization path. See Figure 11.10(a) for an example.

We can also use an empirical Bayes approach to choose $\lambda$ . In particular, we choose the hyperpa

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022 rameter by computing $\hat { \lambda } = \operatorname { a r g m a x } _ { \lambda } \log p ( \mathcal { D } | \lambda )$ , where $p ( \mathcal { D } | \lambda )$ is the marginal likelihood or evidence. Figure 4.7b shows that this gives essentially the same result as the CV estimate. However, the Bayesian approach has several advantages: computing $p ( \mathcal { D } | \lambda )$ can be done by fitting a single model, whereas CV has to fit the same model $K$ times; and $p ( \mathcal { D } | \lambda )$ is a smooth function of $\lambda$ , so we can use gradient-based optimization instead of discrete search.

# 11.4 Lasso regression

In Section 11.3, we assumed a Gaussian prior for the regression coefficients when fitting linear regression models. This is often a good choice, since it encourages the parameters to be small, and hence prevents overfitting. However, sometimes we want the parameters to not just be small, but to be exactly zero, i.e., we want $\hat { \pmb { w } }$ to be sparse, so that we minimize the L0-norm:

$$
| | \pmb { w } | | _ { 0 } = \sum _ { d = 1 } ^ { D } \mathbb { I } \left( | w _ { d } | > 0 \right)
$$

This is useful because it can be used to perform feature selection. To see this, note that the prediction has the form $\begin{array} { r } { f ( \pmb { x } ; \pmb { w } ) = \sum _ { d = 1 } ^ { D } w _ { d } x _ { d } } \end{array}$ , so if any $w _ { d } = 0$ , we ignore the corresponding feature $x _ { d }$ . (The same idea can be applied to nonlinear models, such as DNNs, by encouraging the first layer weights to be sparse.)

# 11.4.1 MAP estimation with a Laplace prior ( $\ell _ { 1 }$ regularization)

There are many ways to compute such sparse estimates (see e.g., [Bha+19]). In this section we focus on MAP estimation using the Laplace distribution (which we discussed in Section 11.6.1) as the prior:

$$
p ( \pmb { w } | \lambda ) = \prod _ { d = 1 } ^ { D } \mathrm { L a p l a c e } ( w _ { d } | 0 , 1 / \lambda ) \propto \prod _ { d = 1 } ^ { D } e ^ { - \lambda | w _ { d } | }
$$

where $\lambda$ is the sparsity parameter, and

$$
{ \mathrm { L a p l a c e } } ( w | \mu , b ) \triangleq { \frac { 1 } { 2 b } } \exp \left( - { \frac { | w - \mu | } { b } } \right)
$$

Here $\mu$ is a location parameter and $b > 0$ is a scale parameter. Figure 2.15 shows that Laplace $( w | 0 , b )$ puts more density on 0 than $\mathcal { N } ( w | 0 , \sigma ^ { 2 } )$ , even when we fix the variance to be the same.

To perform MAP estimation of a linear regression model with this prior, we just have to minimize the following objective:

$$
\mathrm { P N L L } ( \pmb { w } ) = - \log p ( \pmb { { \cal D } } | \pmb { w } ) - \log p ( \pmb { w } | \lambda ) = | | \mathbf { X } \pmb { w } - \pmb { y } | | _ { 2 } ^ { 2 } + \lambda | | \pmb { w } | | _ { 1 }
$$

where $\begin{array} { r } { \lvert \lvert \pmb { w } \rvert \rvert _ { 1 } \triangleq \sum _ { d = 1 } ^ { D } \lvert w _ { d } \rvert } \end{array}$ is the $\ell _ { 1 }$ norm of $\mathbf { \boldsymbol { w } }$ . This method is called lasso, which stands for “least absolute shrinkage and selection operator” [Tib96]. (We explain the reason for this name below.) More generally, MAP estimation with a Laplace prior is called $\ell _ { 1 }$ -regularization.

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

![](images/b99308bb15f98913fc2d26189ceecc896cb6537558e1cf9dc6f70cf181dbc940.jpg)  
Figure 11.8: Illustration of $\ell _ { 1 }$ (left) vs $\ell _ { 2 }$ (right) regularization of a least squares problem. Adapted from Figure 3.12 of [HTF01].

Note also that we could use other norms for the weight vector. In general, the $q$ -norm is defined as follows:

$$
\| \pmb { w } \| _ { q } = \left( \sum _ { d = 1 } ^ { D } | w _ { d } | ^ { q } \right) ^ { 1 / q }
$$

For $q < 1$ , we can get even sparser solutions. In the limit where $q = 0$ , we get the $\ell _ { 0 }$ -norm:

$$
\| \pmb { w } \| _ { 0 } = \sum _ { d = 1 } ^ { D } \mathbb { I } \left( | w _ { d } | > 0 \right)
$$

However, one can show that for any $q < 1$ , the problem becomes non-convex (see e.g., [HTW15]).   
Thus $\ell _ { 1 }$ -norm is the tightest convex relaxation of the $\ell _ { 0 }$ -norm.

# 11.4.2 Why does $\ell _ { 1 }$ regularization yield sparse solutions?

We now explain why $\ell _ { 1 }$ regularization results in sparse solutions, whereas $\ell _ { 2 }$ regularization does not.   
We focus on the case of linear regression, although similar arguments hold for other models.

The lasso objective is the following non-smooth objective (see Section 8.1.4 for a discussion of smoothness):

$$
\operatorname* { m i n } _ { \pmb { w } } \mathrm { N L L } ( \pmb { w } ) + \lambda | | \pmb { w } | | _ { 1 }
$$

This is the Lagrangian for the following quadratic program (see Section 8.5.4):

$$
\operatorname* { m i n } _ { \pmb { w } } \mathrm { N L L } ( \pmb { w } ) \mathrm { s . t . } | | \pmb { w } | | _ { 1 } \leq B
$$

where $B$ is an upper bound on the $\ell _ { 1 }$ -norm of the weights: a small (tight) bound $B$ corresponds to a large penalty $\lambda$ , and vice versa.

Similarly, we can write the ridge regression objective min $\mathbf { \boldsymbol { w } }$ $\mathrm { N L L } ( \pmb { w } ) + \lambda | | \pmb { w } | | _ { 2 } ^ { 2 }$ in bound constrained form:

$$
\operatorname* { m i n } _ { \pmb { w } } \mathrm { N L L } ( \pmb { w } ) \quad \mathrm { s . t . } \quad | | \pmb { w } | | _ { 2 } ^ { 2 } \leq B
$$

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

In Figure 11.8, we plot the contours of the NLL objective function, as well as the contours of the $\ell _ { 2 }$ and $\ell _ { 1 }$ constraint surfaces. From the theory of constrained optimization (Section 8.5) we know that the optimal solution occurs at the point where the lowest level set of the objective function intersects the constraint surface (assuming the constraint is active). It should be geometrically clear that as we relax the constraint $B$ , we “grow” the $\ell _ { 1 }$ “ball” until it meets the objective; the corners of the ball are more likely to intersect the ellipse than one of the sides, especially in high dimensions, because the corners “stick out” more. The corners correspond to sparse solutions, which lie on the coordinate axes. By contrast, when we grow the $\ell _ { 2 }$ ball, it can intersect the objective at any point; there are no “corners”, so there is no preference for sparsity.

# 11.4.3 Hard vs soft thresholding

The lasso objective has the form $\mathcal { L } ( \pmb { w } ) = \mathrm { N L L } ( \pmb { w } ) + \lambda | | \pmb { w } | | _ { 1 }$ . One can show (Exercise 11.3) that the gradient for the smooth NLL part is given by

$$
\begin{array} { r } { \displaystyle \frac { \partial } { \partial w _ { d } } \mathrm { N L L } ( { \boldsymbol { w } } ) = a _ { d } w _ { d } - c _ { d } } \\ { a _ { d } = \displaystyle \sum _ { n = 1 } ^ { N } x _ { n d } ^ { 2 } } \\ { c _ { d } = \displaystyle \sum _ { n = 1 } ^ { N } x _ { n d } ( y _ { n } - { \boldsymbol { w } } _ { - d } ^ { \top } { \boldsymbol { x } } _ { n , - d } ) } \end{array}
$$

where ${ \pmb w } _ { - d }$ is $\mathbf { \boldsymbol { w } }$ without component $d$ , and similarly ${ \boldsymbol { \mathbf { \mathit { x } } } } _ { n , - d }$ is feature vector ${ \boldsymbol { \mathbf { \mathit { x } } } } _ { n }$ without component $d$ . We see that $c _ { d }$ is proportional to the correlation between $d { \mathrm { ~ } }$ ’th column of features, $\pmb { x } _ { : , d }$ , and the residual error obtained by predicting using all the other features, $\pmb { r } _ { - d } = \pmb { y } - \pmb { X }$ :, ${ } _ { , - d } \pmb { w } _ { - d }$ . Hence the magnitude of $c _ { d }$ is an indication of how relevant feature $d$ is for predicting $\pmb { y }$ , relative to the other features and the current parameters. Setting the gradient to 0 gives the optimal update for $w _ { d }$ , keeping all other weights fixed:

$$
w _ { d } = c _ { d } / a _ { d } = \frac { \pmb { x } _ { : , d } ^ { \top } \pmb { r } _ { - d } } { | | \pmb { x } _ { : , d } | | _ { 2 } ^ { 2 } }
$$

The corresponding new prediction for $\pmb { r } _ { - d }$ becomes $\hat { \pmb { r } } _ { - d } = w _ { d } \pmb { x } _ { : , d }$ , which is the orthogonal projection of the residual onto the column vector $\pmb { x } _ { : , d }$ , consistent with Equation (11.15).

Now we add in the $\ell _ { 1 }$ term. Unfortunately, the $| | \pmb { w } | | _ { 1 }$ term is not differentiable whenever $w _ { d } = 0$ Fortunately, we can still compute a subgradient at this point. Using Equation (8.14) we find that

$$
\begin{array} { r l } & { \partial _ { w _ { d } } \mathcal { L } ( \pmb { w } ) = ( a _ { d } w _ { d } - c _ { d } ) + \lambda \partial _ { w _ { d } } | | \pmb { w } | | _ { 1 } } \\ & { \qquad = \left\{ \begin{array} { l l } { \{ a _ { d } w _ { d } - c _ { d } - \lambda \} } & { \mathrm { i f ~ } w _ { d } < 0 } \\ { \left[ - c _ { d } - \lambda , - c _ { d } + \lambda \right] } & { \mathrm { i f ~ } w _ { d } = 0 } \\ { \{ a _ { d } w _ { d } - c _ { d } + \lambda \} } & { \mathrm { i f ~ } w _ { d } > 0 } \end{array} \right. } \end{array}
$$

Depending on the value of $c _ { d }$ , the solution to $\partial _ { w _ { d } } \mathcal { L } ( \pmb { w } ) = 0$ can occur at 3 different values of $w _ { d }$ , as follows:

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

![](images/54c29bbe63dcc7237b302fd22d7d46f0e8857a645728197c00ab5136dd9e6648.jpg)  
Figure 11.9: Left: soft thresholding. Right: hard thresholding. In both cases, the horizontal axis is the residual error incurred by making predictions using all the coefficients except for $w _ { k }$ , and the vertical axis is the estimated coefficient $\hat { w } _ { k }$ that minimizes this penalized residual. The flat region in the middle is the interval $[ - \lambda , + \lambda ]$ .

1. If $c _ { d } < - \lambda$ , so the feature is strongly negatively correlated with the residual, then the subgradient is zero at $\begin{array} { r } { \hat { w } _ { d } = \frac { c _ { d } + \lambda } { a _ { d } } < 0 } \end{array}$ .   
2. If $c _ { d } \in [ - \lambda , \lambda ]$ , so the feature is only weakly correlated with the residual, then the subgradient is zero at $\hat { w } _ { d } = 0$ .   
3. If $c _ { d } > \lambda$ , so the feature is strongly positively correlated with the residual, then the subgradient is zero at $\begin{array} { r } { \hat { w } _ { d } = \frac { c _ { d } - \lambda } { a _ { d } } > 0 } \end{array}$ .

In summary, we have

$$
\hat { w } _ { d } ( c _ { d } ) = \left\{ \begin{array} { l l } { ( c _ { d } + \lambda ) / a _ { d } } & { \mathrm { i f } \ c _ { d } < - \lambda } \\ { \ 0 } & { \mathrm { i f } \ c _ { d } \in [ - \lambda , \lambda ] } \\ { ( c _ { d } - \lambda ) / a _ { d } } & { \mathrm { i f } \ c _ { d } > \lambda } \end{array} \right.
$$

We can write this as follows:

$$
\hat { w } _ { d } = \mathrm { S o f t T h r e s h o l d } ( \frac { c _ { d } } { a _ { d } } , \lambda / a _ { d } )
$$

where

$$
\mathrm { S o f t T h r e s h o l d } ( x , \delta ) \triangleq \mathrm { s i g n } ( x ) \left( | x | - \delta \right) _ { + }
$$

and $x _ { + } = \operatorname* { m a x } ( x , 0 )$ is the positive part of $x$ . This is called soft thresholding (see also Section 8.6.2). This is illustrated in Figure 11.9(a), where we plot $\hat { w } _ { d }$ vs $c _ { d }$ . The dotted black line is the line ${ w _ { d } } = { c _ { d } } / { a _ { d } }$ corresponding to the least squares fit. The solid red line, which represents the regularized estimate $\hat { w } _ { d }$ , shifts the dotted line down (or up) by $\lambda$ , except when $- \lambda \leq c _ { d } \leq \lambda$ , in which case it sets $w _ { d } = 0$ .

By contrast, in Figure 11.9(b), we illustrate hard thresholding. This sets values of $w _ { d }$ to $0$ if $- \lambda \leq c _ { d } \leq \lambda$ , but it does not shrink the values of $w _ { d }$ outside of this interval. The slope of the soft

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022 thresholding line does not coincide with the diagonal, which means that even large coefficients are shrunk towards zero. This is why lasso stands for “least absolute selection and shrinkage operator”. Consequently, lasso is a biased estimator (see Section 4.7.6.1).

![](images/20fe2096cf3fd2151ad44790d9bdf8a91e582640bd41b041a32bb31fa2244790.jpg)  
Figure 11.10: (a) Profiles of ridge coefficients for the prostate cancer example vs bound $B$ on $\ell _ { 2 }$ norm of $\mathbf { \boldsymbol { w } }$ , so small $B$ (large $\lambda$ ) is on the left. The vertical line is the value chosen by 5-fold $C V$ using the 1 standard error rule. Adapted from Figure 3.8 of [HTF09]. Generated by ridgePathProstate.ipynb. (b) Same as (a) but using $\ell _ { 1 }$ norm of w. The x-axis shows the critical values of $\lambda = 1 / B$ , where the regularization path is discontinuous. Adapted from Figure 3.10 of [HTF09]. Generated by lassoPathProstate.ipynb.

A simple solution to the biased estimate problem, known as debiasing, is to use a two-stage estimation process: we first estimate the support of the weight vector (i.e., identify which elements are non-zero) using lasso; we then re-estimate the chosen coefficients using least squares. For an example of this in action, see Figure 11.13.

# 11.4.4 Regularization path

If $\lambda = 0$ , we get the OLS solution. which will be dense. As we increase $\lambda$ , the solution vector $\hat { \pmb { w } } ( \lambda )$ will tend to get sparser. If $\lambda$ is bigger than some critical value, we get $\hat { \mathbf { \Omega } } \hat { \mathbf { \Omega } } \vec { \mathbf { \Omega } } \hat { \mathbf { \Omega } } \vec { \mathbf { \Omega } } \hat { \mathbf { \Omega } } \vec { \mathbf { \Omega } } \hat { \mathbf { \Omega } } \mathrm { ~ \Omega ~ } \hat { \mathbf { \Omega } } \left. \hat { \mathbf { \Omega } } \right.$ . This critical value is obtained when the gradient of the NLL cancels out with the gradient of the penalty:

$$
\lambda _ { \operatorname* { m a x } } = \operatorname* { m a x } _ { d } | \nabla _ { w _ { d } } \mathrm { N L L } ( \mathbf { 0 } ) | = \operatorname* { m a x } _ { d } c _ { d } ( \pmb { w } = 0 ) = \operatorname* { m a x } _ { d } | \pmb { y } ^ { \mathsf { T } } \pmb { x } _ { : , d } | = | | \mathbf { X } ^ { \mathsf { T } } \pmb { y } | | _ { \infty }
$$

Alternatively, we can work with the bound $B$ on the $\ell _ { 1 }$ norm. When $B = 0$ , we get $\hat { \mathbf { \Omega } } \hat { \mathbf { \Omega } } \hat { \mathbf { \Omega } } \hat { \mathbf { \Omega } } \hat { \mathbf { \Omega } } \hat { \mathbf { \Omega } } \hat { \mathbf { \Omega } } \hat { \mathbf { \Omega } } \hat { \mathbf { \Omega } } \hat { \mathbf { \Omega } } \mathrm { ~ \Omega ~ } \hat { \mathbf { \Omega } } \hat { \mathbf { \Omega } } \mathrm { ~ \Omega ~ } \hat { \mathbf { \Omega } } \mathrm { ~ \Omega ~ }$ . As we increase $B$ , the solution becomes denser. The largest value of $B$ for which any component is zero is given by $B _ { \mathrm { m a x } } = | | \hat { \pmb w } _ { \mathrm { m l e } } | | _ { 1 }$ .

As we increase $\lambda$ , the solution vector $\hat { \textbf { \textit { w } } }$ gets sparser, although not necessarily monotonically. We can plot the values $\hat { w } _ { d }$ vs $\lambda$ (or vs the bound $B$ ) for each feature $d$ ; this is known as the regularization path. This is illustrated in Figure 11.10(b), where we apply lasso to the prostate cancer regression dataset from [HTF09]. (We treat features gleason and svi as numeric, not categorical.) On the left,

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

<html><body><table><tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>0.4279</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>0.5015</td><td>0.0735</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>0.5610</td><td>0.1878</td><td>0</td><td>0</td><td>0.0930</td><td>0</td><td>0</td><td>0</td></tr><tr><td>0.5622</td><td>0.1890</td><td>0</td><td>0.0036</td><td>0.0963</td><td>0</td><td>0</td><td>0</td></tr><tr><td>0.5797</td><td>0.2456</td><td>0</td><td>0.1435</td><td>0.2003</td><td>0</td><td>0</td><td>0.0901</td></tr><tr><td>0.5864</td><td>0.2572</td><td>-0.0321</td><td>0.1639</td><td>0.2082</td><td>0</td><td>0</td><td>0.1066</td></tr><tr><td>0.6994</td><td>0.2910</td><td>-0.1337</td><td>0.2062</td><td>0.3003</td><td>-0.2565</td><td>0</td><td>0.2452</td></tr><tr><td>0.7164</td><td>0.2926</td><td>-0.1425</td><td>0.2120</td><td>0.3096</td><td>-0.2890</td><td>-0.0209</td><td>0.2773</td></tr></table></body></html>

Table 11.1: Values of the coefficients for linear regression model fit to prostate cancer dataset as we vary the strength of the $\ell _ { 1 }$ regularizer. These numbers are plotted in Figure 11.10(b).

when $B = 0$ , all the coefficients are zero. As we increase $B$ , the coefficients gradually “turn on”.2 The analogous result for ridge regression is shown in Figure 11.10(a). For ridge, we see all coefficients are non-zero (assuming $\lambda > 0$ ), so the solution is not sparse.

Remarkably, it can be shown that the lasso solution path is a piecewise linear function of $\lambda$ [Efr+04; GL15]. That is, there are a set of critical values of $\lambda$ where the active set of non-zero coefficients changes. For values of $\lambda$ between these critical values, each non-zero coefficient increases or decreases in a linear fashion. This is illustrated in Figure 11.10(b). Furthermore, one can solve for these critical values analytically [Efr+04]. In Table 11.1. we display the actual coefficient values at each of these critical steps along the regularization path (the last line is the least squares solution).

By changing $\lambda$ from $\lambda _ { \mathrm { m a x } }$ to 0, we can go from a solution in which all the weights are zero to a solution in which all weights are non-zero. Unfortunately, not all subset sizes are achievable using lasso. In particular, one can show that, if $D > N _ { \mathcal { D } }$ , the optimal solution can have at most $N _ { \mathcal { D } }$ variables in it, before reaching the complete set corresponding to the OLS solution of minimal $\ell _ { 1 }$ norm. In Section 11.4.8, we will see that by using an $\ell _ { 2 }$ regularizer as well as an $\ell _ { 1 }$ regularizer (a method known as the elastic net), we can achieve sparse solutions which contain more variables than training cases. This lets us explore model sizes between $N _ { \mathcal { D } }$ and $D$ .

# 11.4.5 Comparison of least squares, lasso, ridge and subset selection

In this section, we compare least squares, lasso, ridge and subset selection. For simplicity, we assume all the features of $\mathbf { X }$ are orthonormal, so $\mathbf { X } ^ { \mid } \mathbf { X } = \mathbf { I }$ . In this case, the NLL is given by

$$
\begin{array} { l } { \displaystyle \mathrm { N L L } ( \boldsymbol { w } ) = | | \boldsymbol { y } - \mathbf { X } \boldsymbol { w } | | ^ { 2 } = \boldsymbol { y } ^ { \top } \boldsymbol { y } + \boldsymbol { w } ^ { \top } \mathbf { X } ^ { \top } \mathbf { X } \boldsymbol { w } - 2 \boldsymbol { w } ^ { \top } \mathbf { X } ^ { \top } \boldsymbol { y } } \\ { \displaystyle = \mathrm { c o n s t } + \sum _ { d } w _ { d } ^ { 2 } - 2 \sum _ { d } \sum _ { n } w _ { d } x _ { n d } y _ { n } } \end{array}
$$

so we see this factorizes into a sum of terms, one per dimension. Hence we can write down the MAP and ML estimates analytically for each $w _ { d }$ separately, as given below.

• MLE From Equation (11.85), the OLS solution is given by

$$
\hat { w } _ { d } ^ { \mathrm { m l e } } = c _ { d } / a _ { d } = x _ { : d } ^ { \top } y
$$

where $\pmb { x } _ { : d }$ is the $d ^ { \prime }$ th column of $\mathbf { X }$ .

<html><body><table><tr><td>Term</td><td>OLS</td><td>Best Subset</td><td>Ridge</td><td>Lasso</td></tr><tr><td>intercept</td><td>2.465</td><td>2.477</td><td>2.467</td><td>2.465</td></tr><tr><td>lcalvol</td><td>0.676</td><td>0.736</td><td>0.522</td><td>0.548</td></tr><tr><td>lweight</td><td>0.262</td><td>0.315</td><td>0.255</td><td>0.224</td></tr><tr><td>age</td><td>-0.141</td><td>0.000</td><td>-0.089</td><td>0.000</td></tr><tr><td>lbph</td><td>0.209</td><td>0.000</td><td>0.186</td><td>0.129</td></tr><tr><td>svi</td><td>0.304</td><td>0.000</td><td>0.259</td><td>0.186</td></tr><tr><td>lcp</td><td>-0.287</td><td>0.000</td><td>-0.095</td><td>0.000</td></tr><tr><td>gleason</td><td>-0.021</td><td>0.000</td><td>0.025</td><td>0.000</td></tr><tr><td>pgg45</td><td>0.266</td><td>0.000</td><td>0.169</td><td>0.083</td></tr><tr><td>Test error</td><td>0.521</td><td>0.492</td><td>0.487</td><td>0.457</td></tr><tr><td>Std error</td><td>0.176</td><td>0.141</td><td>0.157</td><td>0.146</td></tr></table></body></html>

Figure 11.11: Results of different methods on the prostate cancer data, which has 8 features and 67 training cases. Methods are: $O L S =$ ordinary least squares, Subset = best subset regression, Ridge, Lasso. Rows represent the coefficients; we see that subset regression and lasso give sparse solutions. Bottom row is the mean squared error on the test set (30 cases). Adapted from Table 3.3. of [HTF09]. Generated by prostate_comparison.ipynb.

• Ridge One can show that the ridge estimate is given by

$$
\hat { w } _ { d } ^ { \mathrm { r i d g e } } = \frac { \hat { w } _ { d } ^ { \mathrm { m l e } } } { 1 + \lambda }
$$

• Lasso From Equation (11.88), and using the fact that $\hat { w } _ { d } ^ { \mathrm { m l e } } = c _ { d } / a _ { d }$ , we have

$$
\hat { w } _ { d } ^ { \mathrm { l a s s o } } = \mathrm { s i g n } ( \hat { w } _ { d } ^ { \mathrm { m l e } } ) \left( | \hat { w } _ { d } ^ { \mathrm { m l e } } | - \lambda \right) _ { + }
$$

This corresponds to soft thresholding, shown in Figure 11.9(a).

• Subset selection If we pick the best $K$ features using subset selection, the parameter estimate is as follows

$$
\hat { w } _ { d } ^ { \mathrm { s s } } = \left\{ \begin{array} { c c } { \hat { w } _ { d } ^ { \mathrm { m l e } } } & { \mathrm { i f } \ \mathrm { r a n k } ( | \hat { w } _ { d } ^ { \mathrm { m l e } } | ) \leq K } \\ { 0 } & { \mathrm { o t h e r w i s e } } \end{array} \right.
$$

where rank refers to the location in the sorted list of weight magnitudes. This corresponds to hard thresholding, shown in Figure 11.9(b).

We now experimentally compare the prediction performance of these methods on the prostate cancer regression dataset from [HTF09]. (We treat features gleason and svi as numeric, not categorical.) Figure 11.11 shows the estimated coefficients at the value of $\lambda$ (or $K$ ) chosen by cross-validation; we see that the subset method is the sparsest, then lasso. In terms of predictive performance, all methods are very similar, as can be seen from Figure 11.12.

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

![](images/3094bf598d2cae266e4b19cc44f348acd774c81e26a10d89d8c1b96a08c63ba3.jpg)  
Figure 11.12: Boxplot displaying (absolute value of) prediction errors on the prostate cancer test set for different regression methods. Generated by prostate_comparison.ipynb.

# 11.4.6 Variable selection consistency

It is common to use $\ell _ { 1 }$ regularization to estimate the set of relevant variables, a process known as variable selection. A method that can recover the true set of relevant variables (i.e., the support of $\boldsymbol { w } ^ { * }$ ) in the $N  \infty$ limit is called model selection consistent. (This is a theoretical notion that assumes the data comes from the model.)

Let us give an example. We first generate a sparse signal $\boldsymbol { w } ^ { * }$ of size $D = 4 0 9 6$ , consisting of 160 randomly placed $\pm 1$ spikes. Next we generate a random design matrix $\mathbf { X }$ of size $N \times D$ , where $N = 1 0 2 4$ . Finally we generate a noisy observation $\pmb { y } = \mathbf { X } \pmb { w } ^ { \ast } + \pmb { \epsilon }$ , where $\epsilon _ { n } \sim \mathcal { N } ( 0 , 0 . 0 1 ^ { 2 } )$ . We then estimate $\mathbf { \boldsymbol { w } }$ from $\pmb { y }$ and $\mathbf { X }$ . The original $\boldsymbol { w } ^ { * }$ is shown in the first row of Figure 11.13. The second row is the $\ell _ { 1 }$ estimate $\hat { \pmb { w } } _ { L 1 }$ using $\lambda = 0 . 1 \lambda _ { \operatorname* { m a x } }$ . We see that this has “spikes” in the right places, so it has correctly identified the relevant variables. However, although we see that $\hat { \pmb { w } } _ { L 1 }$ has correctly identified the non-zero components, but they are too small, due to shrinkage. In the third row, we show the results of using the debiasing technique discussed in Section 11.4.3. This shows that we can recover the original weight vector. By contrast, the final row shows the OLS estimate, which is dense. Furthermore, it is visually clear that there is no single threshold value we can apply to $\hat { \pmb w } _ { \mathrm { m l e } }$ to recover the correct sparse weight vector.

To use lasso to perform variable selection, we have to pick $\lambda$ . It is common to use cross validation to pick the optimal value on the regularization path. However, it is important to note that cross validation is picking a value of $\lambda$ that results in good predictive accuracy. This is not usually the same value as the one that is likely to recover the “true” model. To see why, recall that $\ell _ { 1 }$ regularization performs selection and shrinkage, that is, the chosen coefficients are brought closer to 0. In order to prevent relevant coefficients from being shrunk in this way, cross validation will tend to pick a value of $\lambda$ that is not too large. Of course, this will result in a less sparse model which contains irrelevant variables (false positives). Indeed, it was proved in [MB06] that the prediction-optimal value of $\lambda$ does not result in model selection consistency. However, various extensions to the basic method have been devised that are model selection consistent (see e.g., [BG11; HTW15]).

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

Original $\mathrm { ( D = 4 0 9 6 }$ , number of nonzeros $= 1 6 0$ ) 1 □ □□ 1 0 1000 2000 3000 4000 L1 reconstruction $\mathrm { ~ K 0 } = 1 0 2 4$ , lambda = 0.0516, MSE = 0.0027) L 0 1000 2000 3000 4000 Debiased (MSE = 3.26e−005) □ 中 1 0 1000 2000 3000 4000 Minimum norm solution $( \mathbf { M S E } = 0 . 0 2 9 2 )$   
0.5 0   
−0.5 0 1000 2000 3000 4000

# 11.4.7 Group lasso

In standard $\ell _ { 1 }$ regularization, we assume that there is a 1:1 correspondence between parameters and variables, so that if $\hat { w } _ { d } = 0$ , we interpret this to mean that variable $d$ is excluded. But in more complex models, there may be many parameters associated with a given variable. In particular, each variable $d$ may have a vector of weights ${ \pmb w } _ { d }$ associated with it, so the overall weight vector has block structure, ${ \pmb w } = [ { \pmb w } _ { 1 } , { \pmb w } _ { 2 } , \dots , { \pmb w } _ { D } ]$ . If we want to exclude variable $d$ , we have to force the whole subvector ${ \pmb w } _ { d }$ to go to zero. This is called group sparsity.

# 11.4.7.1 Applications

Here are some examples where group sparsity is useful:

• Linear regression with categorical inputs: If the $d$ ’th variable is categorical with $K$ possible levels, then it will be represented as a one-hot vector of length $K$ (Section 1.5.3.1), so to exclude variable $d$ , we have to set the whole vector of incoming weights to $0$ .   
• Multinomial logistic regression: The $d$ ’th variable will be associated with $C$ different weights, one per class (Section 10.3), so to exclude variable $d$ , we have to set the whole vector of outgoing weights to 0.   
• Neural networks: the $k$ ’th neuron will have multiple inputs, so if we want to “turn the neuron off”, we have to set all the incoming weights to zero. This allows us to use group sparsity to learn neural network structure (for details, see e.g., [GEH19]).

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license • Multi-task learning: each input feature is associated with $C$ different weights, one per output task. If we want to use a feature for all of the tasks or none of the tasks, we should select weights at the group level [OTJ07].

# 11.4.7.2 Penalizing the two-norm

To encourage group sparsity, we partition the parameter vector into $G$ groups, $\pmb { w } = [ \pmb { w } _ { 1 } , \dots , \pmb { w } _ { G } ]$ . Then we minimize the following objective

$$
\mathrm { P N L L } ( \pmb { w } ) = \mathrm { N L L } ( \pmb { w } ) + \lambda \sum _ { g = 1 } ^ { G } | | \pmb { w } _ { g } | | _ { 2 }
$$

where $\begin{array} { r } { \vert \vert \pmb { w } _ { g } \vert \vert _ { 2 } = \sqrt { \sum _ { d \in g } w _ { d } ^ { 2 } } } \end{array}$ is the 2-norm of the group weight vector. If the NLL is least squares, this method is called group lasso [YL06; Kyu+10].

Note that if we had used the sum of the squared 2-norms in Equation (11.97), then the model would become equivalent to ridge regression, since

$$
\sum _ { g = 1 } ^ { G } | | w _ { g } | | _ { 2 } ^ { 2 } = \sum _ { g } \sum _ { d \in g } w _ { d } ^ { 2 } = | | w | | _ { 2 } ^ { 2 }
$$

By using the square root, we are penalizing the radius of a ball containing the group’s weight vector: the only way for the radius to be small is if all elements are small.

Another way to see why the square root version enforces sparsity at the group level is to consider the gradient of the objective. Suppose there is only one group of two variables, so the penalty has the form $\sqrt { w _ { 1 } ^ { 2 } + w _ { 2 } ^ { 2 } }$ . The derivative wrt $w _ { 1 }$ is

$$
\frac { \partial } { \partial w _ { 1 } } ( w _ { 1 } ^ { 2 } + w _ { 2 } ^ { 2 } ) ^ { \frac { 1 } { 2 } } = \frac { w _ { 1 } } { \sqrt { w _ { 1 } ^ { 2 } + w _ { 2 } ^ { 2 } } }
$$

If $w _ { 2 }$ is close to zero, then the derivative approaches 1, and $w _ { 1 }$ is driven to zero as well, with force proportional to $\lambda$ . If, however, $w _ { 2 }$ is large, the derivative approaches $0$ , and $w _ { 1 }$ is free to stay large as well. So all the coefficients in the group will have similar size.

# 11.4.7.3 Penalizing the infinity norm

A variant of this technique replaces the 2-norm with the infinity-norm [TVW05; ZRY05]:

$$
| | \pmb { w } _ { g } | | _ { \infty } = \operatorname* { m a x } _ { d \in g } | w _ { d } |
$$

It is clear that this will also result in group sparsity, since if the largest element in the group is forced to zero, all the smaller ones will be as well.

# 11.4.7.4 Example

An illustration of these techniques is shown in Figure 11.14 and Figure 11.15. We have a true signal $\mathbf { \boldsymbol { w } }$ of size $D = 2 ^ { 1 2 } = 4 0 9 6$ , divided into 64 groups each of size 64. We randomly choose 8 groups

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022 of $\mathbf { \boldsymbol { w } }$ and assign them non-zero values. In Figure 11.14 the values are drawn from a $\mathcal { N } ( 0 , 1 )$ ; in Figure 11.15, the values are all set to 1. We then sample a random design matrix $\mathbf { X }$ of size $N \times D$ , where $N = 2 ^ { 1 0 } = 1 0 2 4$ . Finally, we generate $\pmb { y } = \mathbf { X } \pmb { w } + \pmb { \epsilon }$ , where $\epsilon \sim \mathcal { N } ( \mathbf { 0 } , 1 0 ^ { - 4 } \mathbf { I } _ { N } )$ . Given this data, we estimate the support of $\mathbf { \boldsymbol { w } }$ using $\ell _ { 1 }$ or group $\ell _ { 1 }$ , and then estimate the non-zero values using least squares (debiased estimate).

![](images/3c91ab6ba8b72dfc75e41a0b96986b45dbbbf8c8af5ab6f2e311cb65ad7d1d0e.jpg)  
Figure 11.14: Illustration of group lasso where the original signal is piecewise Gaussian. (a) Original signal. (b) Vanilla lasso estimate. (c) Group lasso estimate using an $\ell _ { 2 }$ norm on the blocks. (d) Group lasso estimate using an $\ell _ { \infty }$ norm on the blocks. Adapted from Figures 3-4 of [WNF09]. Generated by groupLassoDemo.ipynb.

We see from the figures that group lasso does a much better job than vanilla lasso, since it respects the known group structure. We also see that the $\ell _ { \infty }$ norm has a tendency to make all the elements within a block to have similar magnitude. This is appropriate in the second example, but not the first. (The value of $\lambda$ was the same in all examples, and was chosen by hand.)

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

![](images/268b088e84de74777a01dfff813d7eae80c7699a4ec8692aa3820cf736c1832d.jpg)  
Figure 11.15: Same as Figure 11.14, except the original signal is piecewise constant. Generated by groupLassoDemo.ipynb.

# 11.4.8 Elastic net (ridge and lasso combined)

In group lasso, we need to specify the group structure ahead of time. For some problems, we don’t know the group structure, and yet we would still like highly correlated coefficients to be treated as an implicit group. One way to achieve this effect, proposed in [ZH05], is to use the elastic net, which is a hybrid between lasso and ridge regression.3 This corresponds to minimizing the following objective:

$$
\begin{array} { r } { \mathcal { L } ( \pmb { w } , \lambda _ { 1 } , \lambda _ { 2 } ) = | | \pmb { y } - \mathbf { X } \pmb { w } | | ^ { 2 } + \lambda _ { 2 } | | \pmb { w } | | _ { 2 } ^ { 2 } + \lambda _ { 1 } | | \pmb { w } | | _ { 1 } } \end{array}
$$

This penalty function is strictly convex (assuming $\lambda _ { 2 } > 0$ ) so there is a unique global minimum, even if $\mathbf { X }$ is not full rank. It can be shown [ZH05] that any strictly convex penalty on $\pmb { w }$ will exhibit a grouping effect, which means that the regression coefficients of highly correlated variables tend to be equal. In particular, if two features are identically equal, so ${ \bf { X } } _ { : j } = { \bf { X } } _ { : k }$ , one can show that their estimates are also equal, $\hat { w } _ { j } = \hat { w } _ { k }$ . By contrast, with lasso, we may have that $\hat { w } _ { j } = 0$ and $\hat { w } _ { k } \neq 0$ or vice versa, resulting in less stable estimates.

In addition to its soft grouping behavior, elastic net has other advantages. In particular, if $D > N _ { \mathcal { D } }$ , the maximum number of non-zero elements that can be selected (excluding the MLE, which has $D$ non-zero elements) is $N _ { \mathcal { D } }$ . By contrast, elastic net can select more than $N _ { \mathcal { D } }$ non-zero variables on its path to the dense estimate, thus exploring more possible subsets of variables.

# 11.4.9 Optimization algorithms

A large variety of algorithms have been proposed to solve the lasso problem, and other $\ell _ { 1 }$ -regularized convex objectives. In this section, we briefly mention some of the most popular methods.

# 11.4.9.1 Coordinate descent

Sometimes it is hard to optimize all the variables simultaneously, but it easy to optimize them one by one. In particular, we can solve for the $j$ ’th coefficient with all the others held fixed as follows:

$$
w _ { j } ^ { * } = \underset { \eta } { \mathrm { a r g m i n } } \mathcal { L } ( \pmb { w } + \eta \pmb { e } _ { j } )
$$

where $e _ { j }$ is the $j$ ’th unit vector. This is called coordinate descent. We can either cycle through the coordinates in a deterministic fashion, or we can sample them at random, or we can choose to update the coordinate for which the gradient is steepest.

This method is particularly appealing if each one-dimensional optimization problem can be solved analytically, as is the case for lasso (see Equation (11.87)). This is known as the shooting algorithm [Fu98; WL08]. (The term “shooting” is a reference to cowboy theme inspired by the term “lasso”.) See Algorithm 4 for details.

This coordinate descent method has been generalized to the GLM case in [FHT10], and is the basis of the popular glmnet software library.

<html><body><table><tr><td colspan="2">Algorithm 4: Coordinate descent for lasso (aka shooting algorithm)</td></tr><tr><td colspan="2">1 Initialize w = (XTX+ λI)-1XTy</td></tr><tr><td colspan="2">2 repeat</td></tr><tr><td>３４</td><td></td></tr><tr><td></td><td>ford=2Ddo</td></tr><tr><td>5</td><td>Cn=1xnd(yn-wTxn+wdxnd) Cd=∑N1</td></tr><tr><td>6</td><td>wd = SoftThreshold(dd,λ/ad)</td></tr><tr><td colspan="2">7until converged</td></tr></table></body></html>

# 11.4.9.2 Projected gradient descent

In this section, we convert the non-differentiable $\ell _ { 1 }$ penalty into a smooth regularizer. To do this, we first use the split variable trick to define $\pmb { w } = \pmb { w } ^ { + } - \pmb { w } ^ { - }$ , where ${ \pmb w } ^ { + } = \operatorname* { m a x } \{ { \pmb w } , 0 \}$ and

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

${ \pmb w } ^ { - } = - \operatorname* { m i n } \{ { \pmb w } , 0 \}$ . Now we can replace $| | \pmb { w } | | _ { 1 }$ with $\textstyle \sum _ { d } ( w _ { d } ^ { + } + w _ { d } ^ { - } )$ . We also have to replace $\mathrm { N L L } ( w )$ with $\mathrm { N L L } ( w ^ { + } + w ^ { - } )$ . Thus we get the following smooth, but constrained, optimization problem:

$$
\operatorname* { m i n } _ { \substack { w ^ { + } \geq 0 , w ^ { - } \geq 0 } } \mathrm { N L L } ( w ^ { + } - w ^ { - } ) + \lambda \sum _ { d = 1 } ^ { D } ( w _ { d } ^ { + } + w _ { d } ^ { - } )
$$

In this case of a Gaussian likelihood, the NLL becomes a least squares loss, and the objective becomes a quadratic program (Section 8.5.4). One way to solve such problems is to use projected gradient descent (Section 8.6.1). Specifically, we can enforce the constraint by projecting onto the positive orthant, which we can do using $w _ { d } : = \operatorname* { m a x } ( w _ { d } , 0 )$ ; this operation is denoted by $P _ { + }$ . Thus the projected gradient update takes the following form:

$$
\begin{array} { r } { \left( \begin{array} { c } { \pmb { w } _ { t + 1 } ^ { + } } \\ { \pmb { w } _ { t + 1 } ^ { - } } \end{array} \right) = P _ { + } \left( \left[ \begin{array} { c } { \pmb { w } _ { t } ^ { + } - \eta _ { t } \nabla \mathrm { N L L } ( \pmb { w } _ { t } ^ { + } - \pmb { w } _ { t } ^ { - } ) - \eta _ { t } \lambda e } \\ { \pmb { w } _ { t } ^ { - } + \eta _ { t } \nabla \mathrm { N L L } ( \pmb { w } _ { t } ^ { + } - \pmb { w } _ { t } ^ { - } ) - \eta _ { t } \lambda e } \end{array} \right] \right) } \end{array}
$$

where $e$ is the unit vector of all ones.

# 11.4.9.3 Proximal gradient descent

In Section 8.6, we introduced proximal gradient descent, which can be used to optimize smooth functions with non-smooth penalties, such as $\ell _ { 1 }$ . In Section 8.6.2, we showed that the proximal operator for the $\ell _ { 1 }$ penalty corresponds to soft thresholding. Thus the proximal gradient descent update can be written as

$$
\pmb { w } _ { t + 1 } = \mathrm { S o f t T h r e s h o l d } ( \pmb { w } _ { t } - \eta _ { t } \nabla \mathrm { N L L } ( \pmb { w } _ { t } ) , \eta _ { t } \lambda )
$$

where the soft thresholding operator (Equation (8.134)) is applied elementwise. This is called the iterative soft thresholding algorithm or ISTA [DDDM04; Don95]. If we combine this with Nesterov acceleration, we get the method known as “fast ISTA” or FISTA [BT09], which is widely used to fit sparse linear models.

# 11.4.9.4 LARS

In this section, we discuss methods that can generate a set of solutions for different values of $\lambda$ , starting with the empty set, i.e., they compute the full regularization path (Section 11.4.4). These algorithms exploit the fact that one can quickly compute $\hat { \pmb w } ( \lambda _ { k } )$ from $\hat { w } ( \lambda _ { k - 1 } )$ if $\lambda _ { k } \approx \lambda _ { k - 1 }$ ; this is known as warm starting. In fact, even if we only want the solution for a single value of $\lambda$ , call it $\lambda _ { * }$ , it can sometimes be computationally more efficient to compute a set of solutions, from $\lambda _ { \mathrm { m a x } }$ down to $\lambda _ { * }$ , using warm-starting; this is called a continuation method or homotopy method. This is often much faster than directly “cold-starting” at $\lambda _ { * }$ ; this is particularly true if $\lambda _ { * }$ is small.

The LARS algorithm [Efr+04], which stands for “least angle regression and shrinkage”, is an example of a homotopy method for the lasso problem. This can compute $\hat { \pmb { w } } ( \lambda )$ for all possible values of $\lambda$ in an efficient manner. (A similar algorithm was independently invented in [OPT00b; OPT00a]). LARS works as follows. It starts with a large value of $\lambda$ , such that only the variable that is most correlated with the response vector $\mathbf { \nabla } _ { \mathbf { \boldsymbol { y } } }$ is chosen. Then $\lambda$ is decreased until a second variable is found which has the same correlation (in terms of magnitude) with the current residual as the first variable,

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022 where the residual at step $k$ on the path is defined as $\pmb { r } _ { k } = \pmb { y } - \pmb { X }$ :, ${ F _ { k } } ^ { w _ { k } }$ , where $F _ { k }$ is the current active set (cf., Equation (11.83)). Remarkably, one can solve for this new value of $\lambda$ analytically, by using a geometric argument (hence the term “least angle”). This allows the algorithm to quickly “jump” to the next point on the regularization path where the active set changes. This repeats until all the variables are added.

It is necessary to allow variables to be removed from the current active set, even as we increase $\lambda$ , if we want the sequence of solutions to correspond to the regularization path of lasso. If we disallow variable removal, we get a slightly different algorithm called least angle regression or LAR. LAR is very similar to greedy forward selection, and a method known as least squares boosting (see e.g., [HTW15]).

# 11.5 Regression splines \*

We have seen how we can use polynomial basis functions to create nonlinear mappings from input to output, even though the model remains linear in the parameters. One problem with polynomials is that they are a global approximation to the function. We can achieve more flexibility by using a series of local approximations. To do this, we just need to define a set of basis functions that have local support. The notion of “locality” is hard to define in high-dimensional input spaces, so in this section, we restrict ourselves to 1d inputs. We can then approximate the function using

$$
f ( x ; \pmb \theta ) = \sum _ { i = 1 } ^ { m } w _ { i } B _ { i } ( x )
$$

where $B _ { i }$ is the $\textit { \textbf { \ i } }$ ’th basis function.

A common way to define such basis functions is to use $\mathbf { B }$ -splines. (“B” stands for “basis”, and the term “spline” refers to a flexible piece of material used by artists to draw curves.) We discuss this in more detail in Section 11.5.1.

# 11.5.1 B-spline basis functions

A spline is a piecewise polynomial of degree $D$ , where the locations of the pieces are defined by a set of knots, $t _ { 1 } < \cdots < t _ { m }$ . More precisely, the polynomial is defined on each of the intervals $( - \infty , t _ { 1 } )$ , $[ t _ { 1 } , t _ { 2 } ]$ , , $[ t _ { m } , \infty )$ . The function is continuous and has continuous derivatives of orders $1 , \ldots , D - 1$ at its knot points. It is common to use cubic splines, in which $D = 3$ . This ensures the function is continuous, and has continuous first and second derivatives at each knot.

We will skip the details on how B-splines are computed, since it is not relevant to our purposes. Suffice it to say that we can call the patsy.bs function to convert the $N \times 1$ data matrix $\mathbf { X }$ into an $N \times ( K + D + 1 )$ design matrix $\mathbf { B }$ , where $K$ is the number of knots and $D$ is the degree. (Alternatively, you can specify the desired number of basis functions, and let patsy work out the number and locations of the knots.)

Figure 11.16 illustrates this approach, where we use B-splines of degree 0, 1 and 3, with 3 knots. By taking a weighted combination of these basis functions, we can get increasingly smooth functions, as shown in the bottom row.

We see from Figure 11.16 that each individual basis function has local support. At any given input point $x$ , only $D + 1$ basis functions will be “active”. This is more obvious if we plot the design matrix

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license $\mathbf { B }$ itself. Let us first consider the piecewise constant spline, shown in Figure 11.17(a). The first B-spline (column 1) is 1 for the first 5 observations, and otherwise 0. The second B-spline (column $0$ ) is 0 for the first 5 observations, 1 for the second 5, and then 0 again. And so on. Now consider the linear spline, shown in Figure 11.17(b). The first B-spline (column 0) goes from 1 to 0, the next three splines go from 0 to 1 and back to 0; and the last spline (column 4) goes from 0 to 1; this reflects the triangular shapes shown in the top middle panel of Figure 11.16. Finally consider the cubic spline, shown in Figure 11.17(c). Here the pattern of activations is smoother, and the resulting model fits will be smoother too.

![](images/17b37cd06dda0abaa32dee548ec931098f7d33893122d6c878ef5b2d2ab7308b.jpg)  
Figure 11.16: Illustration of $B$ -splines of degree 0, 1 and 3. Top row: unweighted basis functions. Dots mark the locations of the 3 internal knots at [0.25, 0.5, 0.75]. Bottom row: weighted combination of basis functions using random weights. Generated by splines_basis_weighted.ipynb. Adapted from Figure 5.4 of [MKL11]. Used with kind permission of Osvaldo Martin.

![](images/32d3991db1f72baae3e567723d0beb8ea7e280e00f2a85e2cc023b598be63c77.jpg)  
Figure 11.17: Design matrix for $B$ -splines of degree (a) 0, (b) 1 and (c) 3. We evaluate the splines on 20 inputs ranging from 0 to 1. Generated by splines_basis_heatmap.ipynb. Adapted from Figure 5.6 of [MKL11]. Used with kind permission of Osvaldo Martin.

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

![](images/024f8089932f3601ef3f322d6e0ab0a95b3417ed5c2c6409c5e48b0bd1091efc.jpg)  
Figure 11.18: Fitting a cubic spline regression model with 15 knots to a 1d dataset. Generated by splines_cherry_blossoms.ipynb. Adapted from Figure 5.3 of [McE20].

# 11.5.2 Fitting a linear model using a spline basis

Once we have computed the design matrix $\mathbf { B }$ , we can use it to fit a linear model using least squares or ridge regression. (It is usually best to use some regularization.) As an example, we consider a dataset from [McE20, Sec 4.5], which records the the first day of the year, and the corresponding temperature, that marks the start of the cherry blossom season in Japan. (We use this dataset since it has interesting semi-periodic structure.) We fit the data using a cubic spline. We pick 15 knots, spaced according to quantiles of the data. The results are shown in Figure 11.18. We see that the fit is reasonable. Using more knots would improve the quality of the fit, but would eventually result in overfitting. We can select the number of knots using a model selection method, such as grid search plus cross validation.

# 11.5.3 Smoothing splines

Smoothing splines are related to regression splines, but use $N$ knots, where $N$ is the number of datapoints. That is, they are non-parametric models, since the number of parameters grows with the size of the data, rather than being fixed a priori. To avoid overfitting, smoothing splines rely on $\ell _ { 2 }$ regularization. This technique is closely related to Gaussian process regression, which we discuss in Section 17.2.

# 11.5.4 Generalized additive models

A generalized additive model or GAM extends spline regression to the case of multidimensional inputs [HT90]. It does this by ignoring interactions between the inputs, and assuming the function has the following additive form:

$$
f ( \pmb { x } ; \pmb { \theta } ) = \alpha + \sum _ { d = 1 } ^ { D } f _ { d } ( x _ { d } )
$$

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license where each $f _ { d }$ is a regression or smoothing spline. This model can be fit using backfitting, which iteratively fits each $f _ { d }$ to the partial residuals generated by the other terms. We can extend GAMs beyond the regression case (e.g., to classification) by using a link function, as in generalized linear models (Chapter 12).

![](images/b20e7632782cfdfafefc5c48ca0d60e9ddb1d57c19fa74950e314b2326146498.jpg)  
Figure 11.19: (a) Illustration of robust linear regression. Generated by linregRobustDemoCombined.ipynb. (b) Illustration of $\ell _ { 2 }$ , $\ell _ { 1 }$ , and Huber loss functions with $\delta = 1 . 5$ . Generated by huberLossPlot.ipynb.

# 11.6 Robust linear regression \*

It is very common to model the noise in regression models using a Gaussian distribution with zero mean and constant variance, $r _ { n } \sim \mathcal { N } ( 0 , \sigma ^ { 2 } )$ , where $r _ { n } = y _ { n } - w ^ { \mathrm { { I } } } x _ { n }$ . In this case, maximizing likelihood is equivalent to minimizing the sum of squared residuals, as we have seen. However, if we have outliers in our data, this can result in a poor fit, as illustrated in Figure 11.19(a). (The outliers are the points on the bottom of the figure.) This is because squared error penalizes deviations quadratically, so points far from the line have more effect on the fit than points near to the line.

One way to achieve robustness to outliers is to replace the Gaussian distribution for the response variable with a distribution that has heavy tails. Such a distribution will assign higher likelihood to outliers, without having to perturb the straight line to “explain” them. We discuss several possible alternative probability distributions for the response variable below; see Table 11.2 for a summary.

# 11.6.1 Laplace likelihood

In Section 2.7.3, we noted that the Laplace distribution is also robust to outliers. If we use this as our observation model for regression, we get the following likelihood:

$$
p ( y | \mathbf { x } , \pmb { w } , b ) = \mathrm { L a p l a c e } ( y | \pmb { w } ^ { \top } \pmb { x } , b ) \propto \exp ( - \frac { 1 } { b } | y - \pmb { w } ^ { \top } \pmb { x } | )
$$

The robustness arises from the use of $| y - w ^ { \boldsymbol { \mathsf { I } } } \boldsymbol { x } |$ instead of $( y - w ^ { \mathsf { I } } x ) ^ { 2 }$ . Figure 11.19(a) gives an example of the method in action.

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

<html><body><table><tr><td>Likelihood</td><td>Prior</td><td>Posterior</td><td>Name</td><td>Section</td></tr><tr><td>Gaussian</td><td>Uniform</td><td>Point</td><td>Least squares</td><td>11.2.2</td></tr><tr><td>Student</td><td>Uniform</td><td>Point</td><td>Robust regression</td><td>11.6.2</td></tr><tr><td>Laplace</td><td>Uniform</td><td>Point</td><td>Robust regression</td><td>11.6.1</td></tr><tr><td>Gaussian</td><td>Gaussian</td><td>Point</td><td>Ridge</td><td>11.3</td></tr><tr><td>Gaussian</td><td>Laplace</td><td>Point</td><td>Lasso</td><td>11.4</td></tr><tr><td>Gaussian</td><td>Gauss-Gamma</td><td>Gauss-Gamma</td><td>Bayesian lin. reg</td><td>11.7</td></tr></table></body></html>

Table 11.2: Summary of various likelihoods, priors and posteriors used for linear regression. The likelihood refers to the distributional form of $p ( \boldsymbol { y } | \boldsymbol { \mathbf { x } } , \boldsymbol { w } , \sigma ^ { 2 } )$ , and the prior refers to the distributional form of $p ( \pmb { w } )$ . The posterior refers to the distributional form of $p ( \pmb { w } | \mathcal { D } )$ . “Point” stands for the degenerate distribution $\delta ( \boldsymbol { w } - \hat { \boldsymbol { w } } )$ , where wˆ is the MAP estimate. MLE is equivalent to using a point posterior and a uniform prior.

# 11.6.1.1 Computing the MLE using linear programming

We can compute the MLE for this model using linear programming. As we explain in Section 8.5.3, this is a way to solve a constrained optimization problems of the form

$$
\operatorname { a r g m i n } _ { \pmb { v } } c ^ { \top } \pmb { v } \ \mathrm { ~ s . t . ~ } \ \mathbf { A } \pmb { v } \leq \pmb { b }
$$

where $\pmb { v } \in \mathbb { R } ^ { n }$ is the set of $n$ unknown parameters, $\boldsymbol { c } ^ { \flat } \boldsymbol { v }$ is the linear objective function we want to minimize, and $\mathbf {  { a } } _ { i } ^ { \top } \mathbf {  { v } } \le b _ { i }$ is a set of $m$ linear constraints we must satisfy. To apply this to our problem, let us define $\pmb { v } = ( w _ { 1 } , \dots , w _ { D } , e _ { 1 } , \dots , e _ { N } ) \in \mathbb { R } ^ { D + N }$ , where $e _ { i } = | y _ { i } - { \hat { y } } _ { i } |$ is the residual error for example $i$ . We want to minimize the sum of the residuals, so we define $\pmb { c } = ( 0 , \cdots , 0 , 1 , \cdots , 1 ) \in \mathbb { R } ^ { D + N }$ , where the first $D$ elements are 0, and the last $N$ elements are 1.

We need to enforce the constraint that $e _ { i } = | \hat { y } _ { i } - y _ { i } |$ . In fact it is sufficient to enforce the constraint that $| w ^ { \mathsf { I } } x _ { i } - y _ { i } | \leq e _ { i }$ , since minimizing the sum of the $e _ { i }$ ’s will “push down” on this constraint and make it tight. Since $| a | \leq b \implies - b \leq a \leq b$ , we can encode $| \boldsymbol { w } ^ { \intercal } \boldsymbol { x } _ { i } - y _ { i } | \leq e _ { i }$ as two linear constraints:

$$
\begin{array} { r l } & { e _ { i } \geq \pmb { w } ^ { \mathsf { T } } \pmb { x } _ { i } - y _ { i } } \\ & { e _ { i } \geq - ( \pmb { w } ^ { \mathsf { T } } \pmb { x } _ { i } - y _ { i } ) } \end{array}
$$

We can write Equation (11.110) as

$$
\left( x _ { i } , 0 , \cdots , 0 , - 1 , 0 , \cdots , 0 \right) ^ { \top } \pmb { v } \leq y _ { i }
$$

where the first $D$ entries are filled with ${ \bf { x } } _ { i }$ , and the $- 1$ is in the $( D + i )$ ’th entry of the vector. Similarly we can write Equation (11.111) as

$$
\left( - \pmb { x } _ { i } , 0 , \cdots , 0 , - 1 , 0 , \cdots , 0 \right) ^ { \top } \pmb { v } \leq - y _ { i }
$$

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

We can write these constraints in the form $\mathbf { A } v \leq b$ by defining $\mathbf { A } \in \mathbb { R } ^ { 2 N \times ( N + D ) }$ as follows:

$$
\mathbf { A } = { \left( \begin{array} { l l l l l } { x _ { 1 } } & { - 1 } & { 0 } & { 0 \cdots } & { 0 } \\ { - x _ { 1 } } & { - 1 } & { 0 } & { 0 \cdots } & { 0 } \\ { x _ { 2 } } & { 0 } & { - 1 } & { 0 \cdots } & { 0 } \\ { - x _ { 2 } } & { 0 } & { - 1 } & { 0 \cdots } & { 0 } \\ & & { \vdots } & & { } \end{array} \right) }
$$

and defining $\pmb { b } \in \mathbb { R } ^ { 2 N }$ as

$$
\pmb { b } = \left( y _ { 1 } , - y _ { 1 } , y _ { 2 } , - y _ { 2 } , \cdots , y _ { N } , - y _ { N } \right)
$$

# 11.6.2 Student- $\scriptstyle t$ likelihood

In Section 2.7.1, we discussed the robustness properties of the Student distribution. To use this in a regression context, we can just make the mean be a linear function of the inputs, as proposed in [Zel76]:

$$
p ( y | \mathbf x , \pmb w , \sigma ^ { 2 } , \nu ) = \mathscr { T } ( y | \pmb w ^ { \top } \pmb x , \sigma ^ { 2 } , \nu )
$$

We can fit this model using SGD or EM (see [Mur23] for details).

# 11.6.3 Huber loss

An alternative to minimizing the NLL using a Laplace or Student likelihood is to use the Huber loss, which is defined as follows:

$$
\ell _ { \mathrm { h u b e r } } ( r , \delta ) = \left\{ \begin{array} { l l } { { r ^ { 2 } / 2 } } & { { \mathrm { i f ~ } | r | \leq \delta } } \\ { { \delta | r | - \delta ^ { 2 } / 2 } } & { { \mathrm { i f ~ } | r | > \delta } } \end{array} \right.
$$

This is equivalent to $\ell _ { 2 }$ for errors that are smaller than $\delta$ , and is equivalent to $\ell _ { 1 }$ for larger errors.   
See Figure 5.3 for a plot.

The advantage of this loss function is that it is everywhere differentiable. Consequently optimizing the Huber loss is much faster than using the Laplace likelihood, since we can use standard smooth optimization methods (such as SGD) instead of linear programming. Figure 11.19 gives an illustration of the Huber loss function in action. The results are qualitatively similiar to the Laplace and Student methods.

The parameter $\delta$ , which controls the degree of robustness, is usually set by hand, or by crossvalidation. However, [Bar19] shows how to approximate the Huber loss such that we can optimize $\delta$ by gradient methods.

# 11.6.4 RANSAC

In the computer vision community, a common approach to robust regression is to use RANSAC, which stands for “random sample consensus” [FB81]. This works as follows: we sample a small initial set of points, fit the model to them, identify outliers wrt this model (based on large residuals), remove

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022 the outliers, and then refit the model to the inliers. We repeat this for many random initial sets and pick the best model.

A deterministic alternative to RANSAC is the following iterative scheme: intially we assume that all datapoints are inliers, and we fit the model to compute $\hat { \pmb { w } } _ { 0 }$ ; then, for each iteration $t$ , we identify the outlier points as those with large residual under the model $\hat { \mathbf { \Omega } } \hat { \mathbf { \Omega } } ^ { \hat { \mathbf { \Omega } } } \hat { \mathbf { \Omega } } ^ { \hat { \mathbf { \Omega } } }$ , remove them, and refit the model to the remaining points to get $\hat { \pmb { w } } _ { t + 1 }$ . Even though this hard thresholding scheme makes the problem nonconvex, this simple scheme can be proved to rapidly converge to the optimal estimate under some reasonable assumptions [Muk+19; Sug+19].

# 11.7 Bayesian linear regression \*

We have seen how to compute the MLE and MAP estimate for linear regression models under various priors. In this section, we discuss how to compute the posterior over the parameters, $p ( \pmb { \theta } | \mathcal { D } )$ . For simplicity, we assume the variance is known, so we just want to compute $p ( { \pmb w } | \mathcal { D } , \sigma ^ { 2 } )$ . See the sequel to this book, [Mur23], for the general case.

# 11.7.1 Priors

For simplicity, we will use a Gaussian prior:

$$
p ( \pmb { w } ) = \mathcal { N } ( \pmb { w } | \breve { \pmb { w } } , \breve { \Sigma } )
$$

This is a small generalization of the prior that we use in ridge regression (Section 11.3). See the sequel to this book, [Mur23], for a discussion of other priors.

# 11.7.2 Posteriors

We can rewrite the likelihood in terms of an MVN as follows:

$$
p ( \mathcal { D } | \boldsymbol { w } , \boldsymbol { \sigma } ^ { 2 } ) = \prod _ { n = 1 } ^ { N } p ( y _ { n } | \boldsymbol { w } ^ { \top } \boldsymbol { x } , \boldsymbol { \sigma } ^ { 2 } ) = \mathcal { N } ( y | \mathbf { X } \boldsymbol { w } , \boldsymbol { \sigma } ^ { 2 } \mathbf { I } _ { N } )
$$

where ${ \mathbf { I } } _ { N }$ is the $N \times N$ identity matrix. We can then use Bayes rule for Gaussians (Equation (3.37)) to derive the posterior, which is as follows:

$$
\begin{array} { r l } & { p ( \pmb { w } | \mathbf { X } , \pmb { y } , \sigma ^ { 2 } ) \propto \mathcal { N } ( \pmb { w } | \ \check { \boldsymbol { w } } , \check { \Sigma } ) \mathcal { N } ( \pmb { y } | \mathbf { X } \pmb { w } , \sigma ^ { 2 } \mathbf { I } _ { N } ) = \mathcal { N } ( \pmb { w } | \ \hat { \boldsymbol { w } } , \hat { \pmb { \Sigma } } ) } \\ & { \qquad \quad \widehat { \pmb { w } } \triangleq \hat { \boldsymbol { \Sigma } } \ ( \check { \Sigma } ^ { - 1 } \check { \pmb { w } } + \frac { 1 } { \sigma ^ { 2 } } \mathbf { X } ^ { \top } \pmb { y } ) } \\ & { \qquad \quad \hat { \pmb { \Sigma } } \triangleq ( \check { \Sigma } ^ { - 1 } + \frac { 1 } { \sigma ^ { 2 } } \mathbf { X } ^ { \top } \mathbf { X } ) ^ { - 1 } } \end{array}
$$

where $\dot { \pmb w }$ is the posterior mean, and $\hat { \Sigma }$ is the posterior covariance.

If $\stackrel { \triangledown } { \mathbf { \nabla } } \psi = { \bf 0 }$ and $\breve { \Sigma } = \tau ^ { 2 } \mathbf { I }$ , then the posterior mean becomes ${ \widehat { \pmb w } } = { \frac { 1 } { \sigma ^ { 2 } } } \ { \widehat { \pmb x } } ^ { \top } { \pmb y }$ . If we define $\begin{array} { r } { \lambda = \frac { \sigma ^ { 2 } } { \tau ^ { 2 } } } \end{array}$ , we recover the ridge regression estimate, ${ \pmb w } = ( \lambda { \bf I } + { \bf X } ^ { \mathsf { I } } { \bf X } ) ^ { - 1 } { \bf X } ^ { \mathsf { I } } { \pmb y }$ , which matches Equation (11.57).

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

# 11.7.3 Example

Suppose we have a 1d regression model of the form $f ( x ; \pmb { w } ) = { w } _ { 0 } + { w } _ { 1 } x _ { 1 }$ , where the true parameters are $w _ { 0 } = - 0 . 3$ and $w _ { 1 } = 0 . 5$ . We now perform inference $p ( \pmb { w } | \mathcal { D } )$ and visualize the 2d prior and posterior as the size of the training set $N$ increases.

In particular, in Figure 11.20 (which inspired the front cover of this book), we plot the likelihood, the posterior, and an approximation to the posterior predictive distribution.4 Each row plots these distributions as we increase the amount of training data, $N$ . We now explain each row:

• In the first row, $N = 0$ , so the posterior is the same as the prior. In this case, our predictions are “all over the place”, since our prior is essentially uniform.   
• In the second row, $N = 1$ , so we have seen one data point (the blue circle in the plot in the third column). Our posterior becomes constrained by the corresponding likelihood, and our predictions pass close to the observed data. However, we see that the posterior has a ridge-like shape, reflecting the fact that there are many possible solutions, with different slopes/intercepts. This makes sense since we cannot uniquely infer two parameters ( $w _ { 0 }$ and $w _ { 1 }$ ) from one observation.   
• In the third row, $N = 2$ . In this case, the posterior becomes much narrower since we have two constraints from the likelihood. Our predictions about the future are all now closer to the training data.   
• In the fourth (last) row, $N = 1 0 0$ . Now the posterior is essentially a delta function, centered on the true value of ${ \pmb w } _ { \ast } = ( - 0 . 3 , 0 . 5 )$ , indicated by a white cross in the plots in the first and second columns. The variation in our predictions is due to the inherent Gaussian noise with magnitude $\sigma ^ { 2 }$ .

This example illustrates that, as the amount of data increases, the posterior mean estimate, $\scriptstyle { \widehat { \pmb { \mu } } } = \mathbb { E } \left[ \pmb { w } | \mathcal { D } \right]$ , converges to the true value $^ { w _ { * } }$ that generated the data. We thus say that the Bayesian estimate is a consistent estimator (see Section 5.3.2 for more details). We also see that our posterior uncertainty decreases over time. This is what we mean when we say we are “learning” about the parameters as we see more data.

# 11.7.4 Computing the posterior predictive

We have discussed how to compute our uncertainty about the parameters of the model, $p ( \pmb { w } | \mathcal { D } )$ . But what about the uncertainty associated with our predictions about future outputs? Using Equation (3.38), we can show that the posterior predictive distribution at a test point $_ { x }$ is also Gaussian:

$$
\begin{array} { c } { { p ( y | { \pmb x } , { \mathcal D } , \sigma ^ { 2 } ) = \displaystyle \int \mathcal { N } ( y | { \pmb x } ^ { \top } { \pmb w } , \sigma ^ { 2 } ) { \mathcal N } ( { \pmb w } | \hat { \pmb \mu } , \widehat { \pmb \Sigma } ) d { \pmb w } } } \\ { { = { \mathcal N } ( y | \hat { \pmb \mu } ^ { \top } { \pmb x } , \widehat \sigma ^ { 2 } ( { \pmb x } ) ) } } \end{array}
$$

![](images/829b3606b197ec265620f482ff8b6bc9d08f5f68c4825c8d45a9568c754bd5ce.jpg)  
Figure 11.20: Sequential Bayesian inference of the parameters of a linear regression model $p ( y | \mathbf { x } ) = \mathcal { N } ( y | w _ { 0 } +$ $w _ { 1 } x _ { 1 } , \sigma ^ { 2 } )$ . Left column: likelihood function for current data point. Middle column: posterior given first $N$ data points, $p ( w _ { 0 } , w _ { 1 } | { \pmb x } _ { 1 : N } , y _ { 1 : N } , \sigma ^ { 2 } )$ . Right column: samples from the current posterior predictive distribution. Row 1: prior distribution $N = 0$ ). Row 2: after 1 data point. Row 3: after 2 data points. Row 4: after 100 data points. The white cross in columns $^ { 1 }$ and 2 represents the true parameter value; we see that the mode of the posterior rapidly converges to this point. The blue circles in column 3 are the observed data points. Adapted from Figure 3.7 of [Bis06]. Generated by linreg_2d_bayes_demo.ipynb.

where ${ \widehat { \sigma } } ^ { 2 } \ ( { \pmb x } ) \triangleq \sigma ^ { 2 } + { \pmb x } ^ { \top } \ { \widehat { \Sigma } } \ { \pmb x }$ is the variance of the posterior predictive distribution at point $_ x$ after seeing the $N$ training examples. The predicted variance depends on two terms: the variance of the observation noise, $\sigma ^ { 2 }$ , and the variance in the parameters, $\hat { \Sigma }$ . The latter translates into variance about observations in a way which depends on how close $_ { x }$ is to the training data $\mathcal { D }$ . This is illustrated in Figure 11.21(b), where we see that the error bars get larger as we move away from the training points, representing increased uncertainty. This can be important for certain applications, such as active learning, where we choose where to collect training data (see Section 19.4).

In some cases, it is computationally intractable to compute the parameter posterior, $p ( \pmb { w } | \mathcal { D } )$ . In such cases, we may choose to use a point estimate, $\hat { \pmb { w } }$ , and then to use the plugin approximation. This gives

$$
p ( y | \boldsymbol { x } , \mathcal { D } , \sigma ^ { 2 } ) = \int \mathcal { N } ( y | \boldsymbol { x } ^ { \top } w , \sigma ^ { 2 } ) \delta ( w - \hat { w } ) d w = p ( y | \boldsymbol { x } ^ { \top } \hat { w } , \sigma ^ { 2 } ) .
$$

We see that the posterior predictive variance is constant, and independent of the data, as illustrated in Figure 11.21(a). If we sample a parameter from this posterior, we will always recover a single function, as shown in Figure 11.21(c). By contrast, if we sample from the true posterior, $\mathbf { w } _ { s } \sim p ( \mathbf { w } | \mathcal { D } , \sigma ^ { 2 } )$ , we will get a range of different functions, as shown in Figure 11.21(d), which more accurately reflects our uncertainty.

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

![](images/3b9eaaff642cae56f48e9374d78f50688cfaf2efdeb176024cd9a99e040bdc16.jpg)  
Figure 11.21: (a) Plugin approximation to predictive density (we plug in the MLE of the parameters) when fitting a second degree polynomial to some 1d data. (b) Posterior predictive density, obtained by integrating out the parameters. Black curve is posterior mean, error bars are 2 standard deviations of the posterior predictive density. (c) 10 samples from the plugin approximation to posterior predictive distribution. (d) 10 samples from the true posterior predictive distribution. Generated by linreg_post_pred_plot.ipynb.

# 11.7.5 The advantage of centering

The astute reader might notice that the shape of the 2d posterior in Figure 11.20 is an elongated ellipse (which eventually collapses to a point as $N  \infty$ ). This implies that there is a lot of posterior correlation between the two parameters, which can cause computational difficulties.

To understand why this happens, note that each data point induces a likelihood function corresponding to a line which goes through that data point. When we look at all the data together, we see that predictions with maximum likelihood must correspond to lines that go through the mean of the data, $( { \overline { { x } } } , { \overline { { y } } } )$ . There are many such lines, but if we increase the slope, we must decrease the intercept. Thus we can think of the set of high probability lines as spinning around the data mean, like a wheel of fortune.5 This correlation between $w _ { 0 }$ and $w _ { 1 }$ is why the posterior has the form of a diagonal line. (The Gaussian prior converts this into an elongated ellipse, but the posterior correlation still persists until the sample size causes the posterior to shrink to a point.)

It can be hard to compute such elongated posteriors. One simple solution is to center the input data, i.e., by using $x _ { n } ^ { \prime } = x _ { n } - { \overline { { x } } }$ . Now the lines can pivot around the origin, reducing the posterior correlation between $w _ { 0 }$ and $w _ { 1 }$ . See Figure 11.22 for an illustration. (We may also choose to divide each $x _ { n }$ by the standard deviation of that feature, as discussed in Section 10.2.8.)

![](images/55b284e178b3f942fbf2c7a4091e4c06bd99c7de44cf6f7de93fd36fa90596a5.jpg)  
Figure 11.22: Posterior samples of $p ( w _ { 0 } , w _ { 1 } | \mathcal { D } )$ for 1d linear regression model $p ( y | x , \pmb \theta ) \ = \ \mathcal N ( y | w _ { 0 } \ +$ $w _ { 1 } x , \sigma ^ { 2 } )$ with a Gaussian prior. (a) Original data. (b) Centered data. Generated by linreg_2d_bayes_centering_pymc3.ipynb.

Note that we can convert the posterior derived from fitting to the centered data back to the original coordinates by noting that

$$
y ^ { \prime } = w _ { 0 } ^ { \prime } + w _ { 1 } ^ { \prime } x ^ { \prime } = w _ { 0 } ^ { \prime } + w _ { 1 } ^ { \prime } ( x - \overline { { x } } ) = ( w _ { 0 } ^ { \prime } - w _ { 1 } ^ { \prime } \overline { { x } } ) + w _ { 1 } ^ { \prime } x
$$

Thus the parameters on the uncentered data are $w _ { 0 } = w _ { 0 } ^ { \prime } - w _ { 1 } ^ { \prime } \overline { { x } }$ and $w _ { 1 } = w _ { 1 } ^ { \prime }$ .

# 11.7.6 Dealing with multicollinearity

In many datasets, the input variables can be highly correlated with each other. Including all of them does not generally harm predictive accuracy (provided you use a suitable prior or regularizer to prevent overfitting). However, it can make interpretation of the coefficients more difficult.

To illustrate this, we use a toy example from [McE20, Sec 6.1]. Suppose we have a dataset of $N$ people in which we record their heights $h _ { i }$ , as well as the length of their left legs $\boldsymbol { l } _ { i }$ and right legs $r _ { i }$ . Suppose $h _ { i } \sim \mathcal { N } ( 1 0 , 2 )$ , so the average height is $\overline { { h } } = 1 0$ (in unspecified units). Suppose the length of the legs is some fraction $\rho _ { i } \sim \mathrm { U n i f } ( 0 . 4 , 0 . 5 )$ of the height, plus a bit of Gaussian noise, specifically $l _ { i } \sim \mathcal { N } ( \rho _ { i } h _ { i } , 0 . 0 2 )$ and $r _ { i } \sim \mathcal { N } ( \rho _ { i } h _ { i } , 0 . 0 2 )$ .

Now suppose we want to predict the height of a person given measurement of their leg lengths. (I did mention this is a toy example!) Since both left and right legs are noisy measurements of the unknown quantity, it is useful to use both of them. So we use linear regression to fit $p ( h | l , r ) = \mathcal { N } ( h | \alpha + \beta _ { l } l + \beta _ { r } r , \sigma ^ { 2 } )$ . We use vague priors, $\alpha , \beta _ { l } , \beta _ { r } \sim \mathcal { N } ( 0 , 1 0 0 )$ , and $\sigma \sim \mathrm { E x p o n } ( 1 )$ .

Since the average leg length is $\bar { l } = 0 . 4 5 \bar { h } = 4 . 5$ , we might expect each $\beta$ coefficient to be around $\overline { { h } } / \overline { { l } } = 1 0 / 4 . 5 = 2 . 2$ . However, the posterior marginals shown in Figure 11.23 tell a different story: we see that the posterior mean of $\beta _ { l }$ is near 2.6, but $\beta _ { r }$ is near -0.6. Thus it seems like the right leg feature is not needed. This is because the regression coefficient for feature $j$ encodes the value of knowing $x _ { j }$ given that all the other features $\mathbf { \delta } _ { \mathbf { x } _ { - } j }$ are already known, as we discussed in Section 11.2.2.1. If we already know the left leg, the marginal value of also knowing the right leg is small. However, if we

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license rerun this example with slightly different data, we may reach the opposite conclusion, and favor the right leg over the left.

![](images/5cc36fe5f61ad9045ed7805fa600de44564fb3283707e608776305f2d3d93071.jpg)  
Figure 11.23: Posterior marginals for the parameters in the multi-leg example. Generated by multi_collinear_legs_numpyro.ipynb.

![](images/615f65408cf46473305bb01b031922bb697a4ae4299959af8b2088dadb44b171.jpg)  
Figure 11.24: Posteriors for the multi-leg example. (a) Joint posterior $p ( \beta _ { l } , \beta _ { r } | \mathcal { D } )$ (b) Posterior of $p ( \beta _ { l } +$ $\beta _ { r } | d a t a )$ . Generated by multi_collinear_legs_numpyro.ipynb.

We can gain more insight by looking at the joint distribution $p ( \beta _ { l } , \beta _ { r } | \mathcal { D } )$ , shown in Figure 11.24a. We see that the parameters are very highly correlated, so if $\beta _ { r }$ is large, then $\beta _ { l }$ is small, and vice versa. The marginal distribution for each parameter does not capture this. However, it does show that there is a lot of uncertainty about each parameter, showing that they are non-identifiable. However, their sum is well-determined, as can be seen from Figure 11.24b, where we plot $p ( \beta _ { l } + \beta _ { r } | \mathcal { D } )$ ; this is centered on 2.2, as we might expect.

This example goes to show that we must be careful trying to interpret the significance of individua coefficient estimates in a model, since they do not mean much in isolation.

# 11.7.7 Automatic relevancy determination (ARD) \*

Consider a linear regression model with known observation noise but unknown regression weights, $\mathcal { N } ( \pmb { y } | \mathbf { X } \pmb { w } , \sigma ^ { 2 } \mathbf { I } )$ . Suppose we use a Gaussian prior for the weights, $w _ { j } \sim \mathcal { N } ( 0 , 1 / \alpha _ { j } )$ , where $\alpha _ { j }$ is the

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

precision of the $j$ ’th parameter. Now suppose we estimate the prior precisions as follows:

$$
\hat { \pmb { \alpha } } = \underset { \pmb { \alpha } } { \arg \operatorname* { m a x } } p ( \pmb { y } | \mathbf { X } , \pmb { \alpha } )
$$

where

$$
p ( { \pmb y } | { \bf X } , { \pmb \alpha } ) = \int p ( { \pmb y } | { \bf X } { \pmb w } , \sigma ^ { 2 } ) p ( { \pmb w } | { \bf 0 } , \mathrm { d i a g } ( { \pmb \alpha } ) ^ { - 1 } ) d { \pmb w }
$$

is the marginal likelihood. This is an example of empirical Bayes, since we are estimating the prior from data. We can view this as a computational shortcut to a fully Bayesian approach. However, there are additional advantages. In particular, suppose, after estimating $\pmb { \alpha }$ , we compute the MAP estimate

$$
\hat { \pmb w } = \underset { \pmb w } { \mathrm { a r g m a x } } \mathcal { N } ( \pmb w | \mathbf 0 , \hat { \pmb \alpha } ^ { - 1 } )
$$

This results in a sparse estimate for $\hat { \pmb { w } }$ , which is perhaps surprising given that the Gaussian prior for $\mathbf { \boldsymbol { w } }$ is not sparsity promoting. The reasons for this are explained in the sequel to this book.

This technique is known as sparse Bayesian learning [Tip01] or automatic relevancy determination (ARD) [Mac95; Nea96]. It was originally developed for neural networks (where sparsity is applied to the first layer weights), but here we apply it to linear models. See also Section 17.4.1, where we apply it kernelized linear models.

# 11.8 Exercises

Exercise 11.1 [Multi-output linear regression \*]

(Source: Jaakkola.)

Consider a linear regression model with a 2 dimensional response vector $\pmb { y } _ { i } \in \mathbb { R } ^ { 2 }$ . Suppose we have some binary input data, $x _ { i } \in \{ 0 , 1 \}$ . The training data is as follows:

<html><body><table><tr><td>X</td><td>y</td></tr><tr><td>0</td><td>(-1,-1)T</td></tr><tr><td>0 0</td><td>(-1,-2)T (-2,-1)T</td></tr><tr><td>1</td><td>(1,1)T</td></tr><tr><td>1</td><td>(1,2)T</td></tr><tr><td>1</td><td>(2,1)T</td></tr></table></body></html>

Let us embed each $x _ { i }$ into 2d using the following basis function:

$$
\phi ( 0 ) = ( 1 , 0 ) ^ { T } , \phi ( 1 ) = ( 0 , 1 ) ^ { T }
$$

The model becomes

$$
\hat { \pmb y } = { \mathbf W } ^ { T } \phi ( x )
$$

where $\mathbf { W }$ is a $2 \times 2$ matrix. Compute the MLE for $\mathbf { W }$ from the above data.

Exercise 11.2 [Centering and ridge regression] Assume that $\overline { { \boldsymbol { x } } } = 0$ , so the input data has been centered. Show that the optimizer of

$$
J ( { \pmb w } , { \pmb w } _ { 0 } ) = \left( { \pmb y } - { \pmb X } { \pmb w } - { w } _ { 0 } { \bf 1 } \right) ^ { T } ( { \pmb y } - { \pmb X } { \pmb w } - { w } _ { 0 } { \bf 1 } ) + \lambda { \pmb w } ^ { T } { \pmb w }
$$

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

is

$$
\begin{array} { r l } & { \hat { w } _ { 0 } = \overline { { y } } } \\ & { \pmb { w } = ( \mathbf { X } ^ { T } \mathbf { X } + \lambda \mathbf { I } ) ^ { - 1 } \mathbf { X } ^ { T } \pmb { y } } \end{array}
$$

Exercise 11.3 [Partial derivative of the RSS \*]

Let $R S S ( \pmb { w } ) = | | \mathbf { X } \pmb { w } - \pmb { y } | | _ { 2 } ^ { 2 }$ be the residual sum of squares.

a. Show that

$$
\begin{array} { c } { \displaystyle \frac { \partial } { \partial w _ { k } } R S S ( { \boldsymbol w } ) = a _ { k } w _ { k } - c _ { k } } \\ { a _ { k } = 2 \displaystyle \sum _ { i = 1 } ^ { n } x _ { i k } ^ { 2 } = 2 | | { \boldsymbol x } _ { \cdot , { k } } | | ^ { 2 } } \\ { c _ { k } = 2 \displaystyle \sum _ { i = 1 } ^ { n } x _ { i k } ( y _ { i } - { \boldsymbol w } _ { - k } ^ { T } x _ { i , - k } ) = 2 { \boldsymbol x } _ { \cdot , k } ^ { T } r _ { k } } \end{array}
$$

where ${ \pmb w } _ { - k } = { \pmb w }$ without component $k$ , ${ \bf { x } } _ { i , - k }$ is ${ \pmb x } _ { i }$ without component $k$ , and $\pmb { r } _ { k } = \pmb { y } - \pmb { w } _ { - k } ^ { T } \pmb { x } _ { : , - k }$ is the residual due to using all the features except feature $k$ . Hint: Partition the weights into those involving $k$ and those not involving $k$ .

b. Show that if $\begin{array} { r } { \frac { \partial } { \partial w _ { k } } R S S ( { \pmb w } ) = 0 } \end{array}$ , then

$$
\hat { w } _ { k } = \frac { \pmb { x } _ { : , k } ^ { T } \pmb { r } _ { k } } { | | \pmb { x } _ { : , k } | | ^ { 2 } }
$$

Hence when we sequentially add features, the optimal weight for feature $k$ is computed by computing orthogonally projecting $\scriptstyle { \pmb { x } } _ { : , k }$ onto the current residual.

Exercise 11.4 [Reducing elastic net to lasso]

Define

$$
J _ { 1 } ( { \pmb w } ) = | { \pmb y } - { \bf X } { \pmb w } | ^ { 2 } + \lambda _ { 2 } | { \pmb w } | ^ { 2 } + \lambda _ { 1 } | { \pmb w } | _ { 1 }
$$

and

$$
J _ { 2 } ( \pmb { w } ) = | \tilde { \pmb { y } } - \tilde { \mathbf { X } } \tilde { \pmb { w } } | ^ { 2 } + c \lambda _ { 1 } | \pmb { w } | _ { 1 }
$$

where $c = ( 1 + \lambda _ { 2 } ) ^ { - \frac { 1 } { 2 } }$ and

$$
\tilde { \mathbf { X } } = c \left( \begin{array} { c } { \mathbf { X } } \\ { \sqrt { \lambda } _ { 2 } \mathbf { I } _ { d } } \end{array} \right) , \quad \tilde { \pmb { y } } = \left( \begin{array} { c } { \pmb { y } } \\ { \mathbf { 0 } _ { d \times 1 } } \end{array} \right)
$$

Show

$$
\mathrm { a r g m i n } J _ { 1 } ( \pmb { w } ) = c ( \arcsin i n J _ { 2 } ( \pmb { w } ) )
$$

i.e.

$$
{ \cal J } _ { 1 } ( c w ) = { \cal J } _ { 2 } ( w )
$$

and hence that one can solve an elastic net problem using a lasso solver on modified data.

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

Exercise 11.5 [Shrinkage in linear regression $^ * ]$

(Source: Jaakkola.) Consider performing linear regression with an orthonormal design matrix, so $| | \pmb { x } _ { : , k } | | _ { 2 } ^ { 2 } = 1$ for each column (feature) $k$ , and $\pmb { x } _ { : , k } ^ { T } \pmb { x } _ { : , j } = 0$ , so we can estimate each parameter $w _ { k }$ separately.

Figure 10.15b plots $\hat { w } _ { k }$ vs $c _ { k } = 2 y ^ { T } x _ { : , k }$ , the correlation of feature $k$ with the response, for 3 different estimation methods: ordinary least squares (OLS), ridge regression with parameter $\lambda _ { 2 }$ , and lasso with parameter $\lambda _ { 1 }$ .

a. Unfortunately we forgot to label the plots. Which method does the solid (1), dotted (2) and dashed (3) line correspond to?   
b. What is the value of $\lambda _ { 1 }$ ?   
c. What is the value of $\lambda _ { 2 }$ ?

Exercise 11.6 [EM for mixture of linear regression experts] Derive the EM equations for fitting a mixture of linear regression experts.

# 12 Generalized Linear Models \*

# 12.1 Introduction

In Chapter 10, we discussed logistic regression, which, in the binary case, corresponds to the model $p ( y | \mathbf x , \pmb w ) = \mathrm { B e r } ( y | \sigma ( \pmb w ^ { \top } \pmb x ) )$ . In Chapter 11, we discussed linear regression, which corresponds to the model $p ( y | \mathbf { x } , \pmb { w } ) = \mathcal { N } ( y | \pmb { w } ^ { \prime } \mathbf { x } , \sigma ^ { 2 } )$ . These are obviously very similar to each other. In particular, the mean of the output, $\mathbb { E } \left[ \boldsymbol { y } | \boldsymbol { x } , \boldsymbol { w } \right]$ , is a linear function of the inputs $_ { x }$ in both cases.

It turns out that there is a broad family of models with this property, known as generalized linear models or GLMs [MN89].

A GLM is a conditional version of an exponential family distribution (Section 3.4), in which the natural parameters are a linear function of the input. More precisely, the model has the following form:

$$
p ( y _ { n } | x _ { n } , w , \sigma ^ { 2 } ) = \mathrm { e x p } \left[ \frac { y _ { n } \eta _ { n } - A ( \eta _ { n } ) } { \sigma ^ { 2 } } + \log h ( y _ { n } , \sigma ^ { 2 } ) \right]
$$

where $\eta _ { n } \triangleq w ^ { \mathsf { I } } \pmb { x } _ { n }$ is the (input dependent) natural parameter, $A ( \eta _ { n } )$ is the log normalizer, $\boldsymbol { \mathcal { T } } ( \boldsymbol { y } ) = \boldsymbol { y }$ is the sufficient statistic, and $\sigma ^ { 2 }$ is the dispersion term.1

We will denote the mapping from the linear inputs to the mean of the output using $\mu _ { n } = \ell ^ { - 1 } ( \eta _ { n } )$ where the function $\ell$ is known as the link function, and $\ell ^ { - 1 }$ is known as the mean function.

Based on the results in Section 3.4.3, we can show that the mean and variance of the response variable are as follows:

$$
\begin{array} { r l } & { \mathbb { E } \left[ y _ { n } \vert \pmb { x } _ { n } , \pmb { w } , \sigma ^ { 2 } \right] = A ^ { \prime } ( \eta _ { n } ) \triangleq \ell ^ { - 1 } ( \eta _ { n } ) } \\ & { \mathbb { V } \left[ y _ { n } \vert \pmb { x } _ { n } , \pmb { w } , \sigma ^ { 2 } \right] = A ^ { \prime \prime } ( \eta _ { n } ) \sigma ^ { 2 } } \end{array}
$$

# 12.2 Examples

In this section, we give some examples of widely used GLMs.

# 12.2.1 Linear regression

Recall that linear regression has the form

$$
p ( y _ { n } | \mathbf x _ { n } , w , \sigma ^ { 2 } ) = \frac { 1 } { \sqrt { 2 \pi \sigma ^ { 2 } } } \exp ( - \frac { 1 } { 2 \sigma ^ { 2 } } ( y _ { n } - \mathbf w ^ { \mathsf { T } } \mathbf x _ { n } ) ^ { 2 } )
$$

Hence

$$
\log p ( y _ { n } | \pmb { x } _ { n } , \pmb { w } , \sigma ^ { 2 } ) = - \frac { 1 } { 2 \sigma ^ { 2 } } ( y _ { n } - \eta _ { n } ) ^ { 2 } - \frac { 1 } { 2 } \log ( 2 \pi \sigma ^ { 2 } )
$$

where $\eta _ { n } = { \pmb w } ^ { 1 } { \pmb x } _ { n }$ . We can write this in GLM form as follows:

$$
\log p ( y _ { n } | \mathbf x _ { n } , \mathbf w , \sigma ^ { 2 } ) = \frac { y _ { n } \eta _ { n } - \frac { \eta _ { n } ^ { 2 } } { 2 } } { \sigma ^ { 2 } } - \frac { 1 } { 2 } \left( \frac { y _ { n } ^ { 2 } } { \sigma ^ { 2 } } + \log ( 2 \pi \sigma ^ { 2 } ) \right)
$$

We see that $A ( \eta _ { n } ) = \eta _ { n } ^ { 2 } / 2$ and hence

$$
\begin{array} { r l } & { \mathbb { E } \left[ y _ { n } \right] = \eta _ { n } = \pmb { w } ^ { \mathsf { T } } \pmb { x } _ { n } } \\ & { \mathbb { V } \left[ y _ { n } \right] = \sigma ^ { 2 } } \end{array}
$$

# 12.2.2 Binomial regression

If the response variable is the number of successes in $N _ { n }$ trials, $y _ { n } \in \{ 0 , \ldots , N _ { n } \}$ , we can use binomial regression, which is defined by

$$
p ( y _ { n } | \pmb { x } _ { n } , N _ { n } , \pmb { w } ) = \mathrm { B i n } ( y _ { n } | \sigma ( \pmb { w } ^ { \top } \pmb { x } _ { n } ) , N _ { n } )
$$

We see that binary logistic regression is the special case when $N _ { n } = 1$ . The log pdf is given by

$$
\begin{array} { r } { \log p ( y _ { n } | x _ { n } , N _ { n } , \pmb { w } ) = y _ { n } \log \mu _ { n } + ( N _ { n } - y _ { n } ) \log ( 1 - \mu _ { n } ) + \log \binom { N _ { n } } { y _ { n } } } \\ { = y _ { n } \log ( \cfrac { \mu _ { n } } { 1 - \mu _ { n } } ) + N _ { n } \log ( 1 - \mu _ { n } ) + \log \binom { N _ { n } } { y _ { n } } } \end{array}
$$

where $\mu _ { n } = \sigma ( \eta _ { n } )$ . To rewrite this in GLM form, let us define

$$
\eta _ { n } \triangleq \log \left[ \frac { \mu _ { n } } { \left( 1 - \mu _ { n } \right) } \right] = \log \left[ \frac { 1 } { 1 + e ^ { - w ^ { \boldsymbol { \mathsf { T } } } x _ { n } } } \frac { 1 + e ^ { - w ^ { \boldsymbol { \mathsf { T } } } x _ { n } } } { e ^ { - w ^ { \boldsymbol { \mathsf { T } } } x _ { n } } } \right] = \log \frac { 1 } { e ^ { - w ^ { \boldsymbol { \mathsf { T } } } x _ { n } } } = w ^ { \boldsymbol { \mathsf { T } } } x _ { n }
$$

Hence we can write binomial regression in GLM form as follows

$$
\log p ( y _ { n } | \pmb { x } _ { n } , N _ { n } , \pmb { w } ) = y _ { n } \eta _ { n } - A ( \eta _ { n } ) + h ( y _ { n } )
$$

where $h ( y _ { n } ) = \log \binom { N _ { n } } { y _ { n } }$ and

$$
A ( \eta _ { n } ) = - N _ { n } \log ( 1 - \mu _ { n } ) = N _ { n } \log ( 1 + e ^ { \eta _ { n } } )
$$

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

Hence

$$
\mathbb { E } \left[ y _ { n } \right] = \frac { d A } { d \eta _ { n } } = \frac { N _ { n } e ^ { \eta _ { n } } } { 1 + e ^ { \eta _ { n } } } = \frac { N _ { n } } { 1 + e ^ { - \eta _ { n } } } = N _ { n } \mu _ { n }
$$

and

$$
\mathbb { V } \left[ y _ { n } \right] = \frac { d ^ { 2 } A } { d \eta _ { n } ^ { 2 } } = N _ { n } \mu _ { n } ( 1 - \mu _ { n } )
$$

# 12.2.3 Poisson regression

If the response variable is an integer count, $y _ { n } \in \{ 0 , 1 , . . . \}$ , we can use Poisson regression, which is defined by

$$
p ( y _ { n } | \pmb { x } _ { n } , \pmb { w } ) = \mathrm { P o i } ( y _ { n } | \exp ( \pmb { w } ^ { \top } \pmb { x } _ { n } ) )
$$

where

$$
\operatorname { P o i } ( y | \mu ) = e ^ { - \mu } ~ { \frac { \mu ^ { y } } { y ! } }
$$

is the Poisson distribution. Poisson regression is widely used in bio-statistical applications, where $y _ { n }$ might represent the number of diseases of a given person or place, or the number of reads at a genomic location in a high-throughput sequencing context (see e.g., [Kua+09]).

The log pdf is given by

$$
\log p ( y _ { n } | \pmb { x } _ { n } , \pmb { w } ) = y _ { n } \log \mu _ { n } - \mu _ { n } - \log ( y _ { n } ! )
$$

where $\mu _ { n } = \exp ( w ^ { \boldsymbol { \mathsf { I } } } \mathbf { x } _ { n } )$ . Hence in GLM form we have

$$
\log p ( y _ { n } | \pmb { x } _ { n } , \pmb { w } ) = y _ { n } \eta _ { n } - A ( \eta _ { n } ) + h ( y _ { n } )
$$

where $\eta _ { n } = \log ( \mu _ { n } ) = w ^ { \mathsf { I } } x _ { n }$ , $A ( \eta _ { n } ) = \mu _ { n } = e ^ { \eta _ { n } }$ , and $h ( y _ { n } ) = - \log ( y _ { n } ! )$ . Hence

$$
\mathbb { E } \left[ y _ { n } \right] = \frac { d A } { d \eta _ { n } } = e ^ { \eta _ { n } } = \mu _ { n }
$$

and

$$
\mathbb { V } \left[ { y _ { n } } \right] = \frac { { d ^ { 2 } } A } { { d \eta _ { n } ^ { 2 } } } = e ^ { \eta _ { n } } = \mu _ { n }
$$

# 12.3 GLMs with non-canonical link functions

We have seen how the mean parameters of the output distribution are given by $\mu = \ell ^ { - 1 } ( \eta )$ , where the function $\ell$ is the link function. There are several choices for this function, as we now discuss.

The canonical link function $\ell$ satisfies the property that $\theta = \ell ( \mu )$ , where $\theta$ are the canonical (natural) parameters. Hence

$$
\theta = \ell ( \mu ) = \ell ( \ell ^ { - 1 } ( \eta ) ) = \eta
$$

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

This is what we have assumed so far. For example, for the Bernoulli distribution, the canonical parameter is the log-odds $\theta = \log ( \mu / ( 1 - \mu ) )$ , which is given by the logit transform

$$
\theta = \ell ( \mu ) = \mathrm { l o g i t } ( \mu ) = \log \left( { \frac { \mu } { 1 - \mu } } \right)
$$

The inverse of this is the sigmoid or logistic function $\mu = \sigma ( \theta ) = 1 / ( 1 + e ^ { - \theta } )$ .

However, we are free to use other kinds of link function. For example, the probit link function has the form

$$
\eta = \ell ( \mu ) = \Phi ^ { - 1 } ( \mu )
$$

Another link function that is sometimes used for binary responses is the complementary log-log function

$$
\eta = \ell ( \mu ) = \log ( - \log ( 1 - \mu ) )
$$

This is used in applications where we either observe 0 events (denoted by $y = 0$ ) or one or more (denoted by $y = 1$ ), where events are assumed to be governed by a Poisson distribution with rate $\lambda$ . Let $E$ be the number of events. The Poisson assumption means $p ( E = 0 ) = \exp ( - \lambda )$ and hence

$$
p ( y = 0 ) = ( 1 - \mu ) = p ( E = 0 ) = \exp ( - \lambda )
$$

Thus $\lambda = - \log ( 1 - \mu )$ . When $\lambda$ is a function of covariates, we need to ensure it is positive, so we use $\lambda = e ^ { \eta }$ , and hence

$$
\eta = \log ( \lambda ) = \log ( - \log ( 1 - \mu ) )
$$

# 12.4 Maximum likelihood estimation

GLMs can be fit using similar methods to those that we used to fit logistic regression. In particular, the negative log-likelihood has the following form (ignoring constant terms):

$$
\mathrm { N L L } ( \boldsymbol { w } ) = - \log p ( \mathcal { D } | \boldsymbol { w } ) = - \frac { 1 } { \sigma ^ { 2 } } \sum _ { n = 1 } ^ { N } \ell _ { n }
$$

where

$$
\ell _ { n } \triangleq \eta _ { n } y _ { n } - A ( \eta _ { n } )
$$

where $\eta _ { n } = { \pmb w } ^ { \vert } { \pmb x } _ { n }$ . For notational simplicity, we will assume $\sigma ^ { 2 } = 1$ .

We can compute the gradient for a single term as follows:

$$
{ \bf g } _ { n } \triangleq \frac { \partial \ell _ { n } } { \partial { \pmb w } } = \frac { \partial \ell _ { n } } { \partial \eta _ { n } } \frac { \partial \eta _ { n } } { \partial { \pmb w } } = ( y _ { n } - A ^ { \prime } ( \eta _ { n } ) ) { \pmb x } _ { n } = ( y _ { n } - \mu _ { n } ) { \pmb x } _ { n }
$$

where $\mu _ { n } = f ( { \pmb w } ^ { 1 } { \pmb x } )$ , and $f$ is the inverse link function that maps from canonical parameters to mean parameters. For example, in the case of logistic regression, $f ( \eta _ { n } ) = \sigma ( \eta _ { n } )$ , so we recover

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

![](images/08c9a559cd7f2c991bd17f68ee713996a10dc9fee5c024baf414085f5234865c.jpg)  
Figure 12.1: Predictions of insurance claim rates on the test set. (a) Data. (b) Constant predictor. (c) Linear regression. (d) Poisson regression. Generated by poisson_regression_insurance.ipynb.

Equation (10.21). This gradient expression can be used inside SGD, or some other gradient method, in the obvious way.

The Hessian is given by

$$
\mathbf { H } = { \frac { \partial ^ { 2 } } { \partial { \pmb w } \partial { \pmb w } ^ { \mathsf { T } } } } \mathrm { N L L } ( { \pmb w } ) = - \sum _ { n = 1 } ^ { N } { \frac { \partial { \pmb g } _ { n } } { \partial { \pmb w } ^ { \mathsf { T } } } }
$$

where

$$
\frac { \partial g _ { n } } { \partial \pmb { w } ^ { \top } } = \frac { \partial \pmb { g } _ { n } } { \partial \mu _ { n } } \frac { \partial \mu _ { n } } { \partial \pmb { w } ^ { \top } } = - \pmb { x } _ { n } f ^ { \prime } ( \pmb { w } ^ { \top } \pmb { x } _ { n } ) \pmb { x } _ { n } ^ { \top }
$$

Hence

$$
\mathbf { H } = \sum _ { n = 1 } ^ { N } f ^ { \prime } ( \eta _ { n } ) \pmb { x } _ { n } \pmb { x } _ { n } ^ { \top }
$$

For example, in the case of logistic regression, $f ( \eta _ { n } ) = \sigma ( \eta _ { n } )$ , and $f ^ { \prime } ( \eta _ { n } ) = \sigma ( \eta _ { n } ) ( 1 - \sigma ( \eta _ { n } ) )$ , so we recover Equation (10.23). In general, we see that the Hessian is positive definite, since $f ^ { \prime } ( \eta _ { n } ) > 0$ ; hence the negative log likelihood is convex, so the MLE for a GLM is unique (assuming $f ( \eta _ { n } ) > 0$ for all $n$ ).

Based on the above results, we can fit GLMs using gradient based solvers in a manner that is very similar to how we fit logistic regression models.

# 12.5 Worked example: predicting insurance claims

In this section, we give an example of predicting insurance claims using linear and Poisson regression.2. The goal is to predict the expected number of insurance claims per year following car accidents. The dataset consists of 678k examples with 9 features, such as driver age, vehicle age, vehicle power,

<html><body><table><tr><td>Name</td><td>MSE</td><td>MAE</td><td>Deviance</td></tr><tr><td>Dummy</td><td>0.564</td><td>0.189</td><td>0.625</td></tr><tr><td>Ridge</td><td>0.560</td><td>0.177</td><td>0.601</td></tr><tr><td>Poisson</td><td>0.560</td><td>0.186</td><td>0.594</td></tr></table></body></html>

Table 12.1: Performance metrics on the test set. MSE = mean squared error. MAE = mean absolute error.   
Deviance = Poisson deviance.

etc. The target is the frequency of claims, which is the number of claims per policy divided by the exposure (i.e., the duration of the policy in years).

We plot the test set in Figure 12.1(a). We see that for 94% of the policies, no claims are made, so the data has lots of 0s, as is typical for count and rate data. The average frequency of claims is $1 0 \%$ . This can be converted into a dummy model, which always predicts this constant. This results in the predictions shown in Figure 12.1(b). The goal is to do better than this.

A simple approach is to use linear regression, combined with some simple feature engineering (binning the continuous values, and one-hot encoding the categoricals). (We use a small amount of $\ell _ { 2 }$ regularization, so technically this is ridge regression.) This gives the results shown in Figure 12.1(c). This is better than the baseline, but still not very good. In particular, it can predict negative outcomes, and fails to capture the long tail.

We can do better using Poisson regression, using the same features but a log link function. The results are shown in Figure 12.1(d). We see that predictions are much better.

An interesting question is how to quantify performance in this kind of problem. If we use mean squared error, or mean absolute error, we may conclude from Table 12.1 that ridge regression is better than Poisson regression, but this is clearly not true, as shown in Figure 12.1. Instead it is more common to measure performance using the deviance, which is defined as

$$
D ( y , { \hat { \mu } } ) = 2 \sum _ { i } \left( \log p ( y _ { i } | \mu _ { i } ^ { * } ) - \log p ( y _ { i } | \mu _ { i } ) \right)
$$

where $\mu _ { i }$ is the predicted parameters for the $i$ ’th example (based on the input features ${ \boldsymbol { \mathbf { \mathit { x } } } } _ { i }$ and the training set $\mathcal { D }$ ), and $\mu _ { i } ^ { * }$ is the optimal parameter estimated by fitting the model just to the true output $y _ { i }$ . (This is the so-called saturated model, that perfectly fits the test set.) In the case of Poisson regression, we have $\mu _ { i } ^ { * } = y _ { i }$ . Hence

$$
\begin{array} { l } { { \displaystyle { \cal D } ( y , \mu ) = 2 \sum _ { i } \left[ ( y _ { i } \log y _ { i } - y _ { i } - \log ( y _ { i } ! ) ) - ( y _ { i } \log \hat { \mu } _ { i } - \hat { \mu } _ { i } - \log ( y _ { i } ! ) ) \right] } } \\ { { \displaystyle ~ = 2 \sum _ { i } \left[ ( y _ { i } \log \frac { y _ { i } } { \hat { \mu } _ { i } } + \hat { \mu } _ { i } - y _ { i } \right] } } \end{array}
$$

By this metric, the Poisson model is clearly better (see last column of Table 12.1).

We can also compute a calibration plot, which plots the actual frequency vs the predicted frequency. To compute this, we bin the predictions into intervals, and then count the empirical frequency of claims for all examples whose predicted frequency falls into that bin. The results are shown in Figure 12.2. We see that the constant baseline is well calibrated, but of course it is not very accurate. The ridge model is miscalibrated in the low frequency regime. In particular, it

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022 underestimates the total number of claims in the test set to be 10,693, whereas the truth is 11,935. The Poisson model is better calibrated (i.e., when it predicts examples will have a high claim rate, they do in fact have a high claim rate), and it predicts the total number of claims to be 11,930.

![](images/69b2cfc5cca80d951574acfeaad2bf35b48ef91b8bbfad891bddf59abdd123c2.jpg)  
Figure 12.2: Calibration plot for insurance claims prediction. Generated by poisson_regression_insurance.ipynb.

# Part III

# Deep Neural Networks

# 13 Neural Networks for Tabular Data

# 13.1 Introduction

In Part II, we discussed linear models for regression and classification. In particular, in Chapter 10, we discussed logistic regression, which, in the binary case, corresponds to the model $p ( y | \mathbf { \boldsymbol { x } } , \mathbf { \boldsymbol { w } } ) = \mathrm { B e r } ( y | \sigma ( \mathbf { \boldsymbol { w } } ^ { \mathrm { { I } } } \mathbf { \boldsymbol { x } } ) )$ , and in the multiclass case corresponds to the model $p ( y | \mathbf { x } , \mathbf { W } ) =$ $\mathrm { C a t } ( y | \mathrm { s o f t m a x } ( \mathbf { W } x ) )$ . In Chapter 11, we discussed linear regression, which corresponds to the model $p ( y | \mathbf { x } , \pmb { w } ) = \mathcal { N } ( y | \pmb { w } ^ { \mathrm { { I } } } \mathbf { x } , \sigma ^ { 2 } )$ . And in Chapter 12, we discussed generalized linear models, which generalizes these models to other kinds of output distributions, such as Poisson. However, all these models make the strong assumption that the input-output mapping is linear.

A simple way of increasing the flexibility of such models is to perform a feature transformation, by replacing $_ { x }$ with $\phi ( { \pmb x } )$ . For example, we can use a polynomial transform, which in 1d is given by $\phi ( x ) = [ 1 , x , x ^ { 2 } , x ^ { 3 } , . . . ]$ , as we discussed in Section 1.2.2.2. This is sometimes called basis function expansion. The model now becomes

$$
f ( \pmb { x } ; \pmb { \theta } ) = \mathbf { W } \phi ( \pmb { x } ) + b
$$

This is still linear in the parameters $\pmb \theta = ( \mathbf W , \pmb b )$ , which makes model fitting easy (since the negative log-likelihood is convex). However, having to specify the feature transformation by hand is very limiting.

A natural extension is to endow the feature extractor with its own parameters, $\pmb { \theta } _ { 2 }$ , to get

$$
f ( \pmb { x } ; \pmb { \theta } ) = \mathbf { W } \phi ( \pmb { x } ; \pmb { \theta } _ { 2 } ) + b
$$

where $\pmb { \theta } = ( \theta _ { 1 } , \theta _ { 2 } )$ and $\pmb { \theta } _ { 1 } = ( \mathbf { W } , \pmb { b } )$ . We can obviously repeat this process recursively, to create more and more complex functions. If we compose $L$ functions, we get

$$
f ( \pmb { x } ; \pmb { \theta } ) = f _ { L } \big ( f _ { L - 1 } \big ( \cdot \cdot \cdot ( f _ { 1 } ( \pmb { x } ) ) \cdot \cdot \cdot \big ) \big )
$$

where $f _ { \ell } ( \pmb { x } ) = f ( \pmb { x } ; \pmb { \theta } _ { \ell } )$ is the function at layer $\ell$ . This is the key idea behind deep neural networks or DNNs.

The term “DNN” actually encompasses a larger family of models, in which we compose differentiable functions into any kind of DAG (directed acyclic graph), mapping input to output. Equation (13.3) is the simplest example where the DAG is a chain. This is known as a feedforward neural network (FFNN) or multilayer perceptron (MLP).

An MLP assumes that the input is a fixed-dimensional vector, say $\pmb { x } \in \mathbb { R } ^ { D }$ . It is common to call such data “structured data” or “tabular data”, since the data is often stored in an $N \times D$ design matrix, where each column (feature) has a specific meaning, such as height, weight, age, etc. In later chapters, we discuss other kinds of DNNs that are more suited to “unstructured data” such as images and text, where the input data is variable sized, and each individual element (e.g., pixel or word) is often meaningless on its own.1 In particular, in Chapter 14, we discuss convolutional neural networks (CNN), which are designed to work with images; in Chapter 15, we discuss recurrent neural networks (RNN) and transformers, which are designed to work with sequences; and in Chapter 23, we discuss graph neural networks (GNN), which are designed to work with graphs.

Table 13.1: Truth table for the XOR (exclusive OR) function, $y = x _ { 1 } \veebar { x } x _ { 2 }$ .   

<html><body><table><tr><td>X1</td><td>x2</td><td>y</td></tr><tr><td>0</td><td>0</td><td>0</td></tr><tr><td>0</td><td>1</td><td>1</td></tr><tr><td>1</td><td>0</td><td>1</td></tr><tr><td></td><td></td><td></td></tr><tr><td>1</td><td>1</td><td>0</td></tr></table></body></html>

Although DNNs can work well, there are often a lot of engineering details that need to be addressed to get good performance. Some of these details are discussed in the supplementary material to this book, available at probml.ai. There are also various other books that cover this topic in more depth (e.g., [Zha+20; Cho21; Gér19; GBC16]), as well as a multitude of online courses. For a more theoretical treatment, see e.g., [Ber+21; Cal20; Aro+21; RY21].

# 13.2 Multilayer perceptrons (MLPs)

In Section 10.2.5, we explained that a perceptron is a deterministic version of logistic regression. Specifically, it is a mapping of the following form:

$$
f ( \pmb { x } ; \pmb { \theta } ) = \mathbb { I } \left( \pmb { w } ^ { \top } \pmb { x } + b \geq 0 \right) = H ( \pmb { w } ^ { \top } \pmb { x } + b )
$$

where $H ( a )$ is the heaviside step function, also known as a linear threshold function. Since the decision boundaries represented by perceptrons are linear, they are very limited in what they can represent. In 1969, Marvin Minsky and Seymour Papert published a famous book called Perceptrons [MP69] in which they gave numerous examples of pattern recognition problems which perceptrons cannot solve. We give a specific example below, before discussing how to solve the problem.

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

![](images/bbd3ec199e7b21214620f6c12e1f1498f60e30de6ad693b7446ddb8446764de8.jpg)  
Figure 13.1: (a) Illustration of the fact that the XOR function is not linearly separable, but can be separated by the two layer model using Heaviside activation functions. Adapted from Figure 10.6 of [Gér19]. Generated by xor_heaviside.ipynb. (b) A neural net with one hidden layer, whose weights have been manually constructed to implement the XOR function. $h _ { 1 }$ is the AND function and $h _ { 2 }$ is the OR function. The bias terms are implemented using weights from constant nodes with the value 1.

# 13.2.1 The XOR problem

One of the most famous examples from the Perceptrons book is the XOR problem. Here the goal is to learn a function that computes the exclusive OR of its two binary inputs. The truth table for this function is given in Table 13.1. We visualize this function in Figure 13.1a. It is clear that the data is not linearly separable, so a perceptron cannot represent this mapping.

However, we can overcome this problem by stacking multiple perceptrons on top of each other. This is called a multilayer perceptron (MLP). For example, to solve the XOR problem, we can use the MLP shown in Figure 13.1b. This consists of 3 perceptrons, denoted $h _ { 1 }$ , $h _ { 2 }$ and $y$ . The nodes marked $x$ are inputs, and the nodes marked 1 are constant terms. The nodes $h _ { 1 }$ and $h _ { 2 }$ are called hidden units, since their values are not observed in the training data.

The first hidden unit computes $h _ { 1 } = x _ { 1 } \wedge x _ { 2 }$ by using appropriately set weights. (Here $\wedge$ is the AND operation.) In particular, it has inputs from $x _ { 1 }$ and $x _ { 2 }$ , both weighted by 1.0, but has a bias term of -1.5 (this is implemented by a “wire” with weight -1.5 coming from a dummy node whose value is fixed to 1). Thus $h _ { 1 }$ will fire iff $x _ { 1 }$ and $x _ { 2 }$ are both on, since then

$$
\pmb { w } _ { 1 } ^ { \top } \pmb { x } - b _ { 1 } = [ 1 . 0 , 1 . 0 ] ^ { \top } [ 1 , 1 ] - 1 . 5 = 0 . 5 > 0
$$

Similarly, the second hidden unit computes $h _ { 2 } = x _ { 1 } \vee x _ { 2 }$ , where ∨ is the OR operation, and the third computes the output $y = \overline { { h _ { 1 } } } \wedge h _ { 2 }$ , where $\overline { { h } } = \neg h$ is the NOT (logical negation) operation. Thus $y$ computes

$$
y = f ( x _ { 1 } , x _ { 2 } ) = { \overline { { ( x _ { 1 } \wedge x _ { 2 } ) } } } \wedge ( x _ { 1 } \vee x _ { 2 } )
$$

This is equivalent to the XOR function.

By generalizing this example, we can show that an MLP can represent any logical function. However, we obviously want to avoid having to specify the weights and biases by hand. In the rest of this chapter, we discuss ways to learn these parameters from data.

# 13.2.2 Differentiable MLPs

The MLP we discussed in Section 13.2.1 was defined as a stack of perceptrons, each of which involved the non-differentiable Heaviside function. This makes such models difficult to train, which is why they were never widely used. However, suppose we replace the Heaviside function $H : \mathbb { R }  \{ 0 , 1 \}$ with a differentiable activation function $\varphi : \mathbb { R }  \mathbb { R }$ . More precisely, we define the hidden units $z _ { l }$ at each layer $\it { l }$ to be a linear transformation of the hidden units at the previous layer passed elementwise through this activation function:

$$
z _ { l } = f _ { l } ( z _ { l - 1 } ) = \varphi _ { l } ( \pmb { b } _ { l } + \mathbf { W } _ { l } z _ { l - 1 } )
$$

or, in scalar form,

$$
z _ { k l } = \varphi _ { l } \left( b _ { k l } + \sum _ { j = 1 } ^ { K _ { l - 1 } } w _ { j k l } z _ { j l - 1 } \right)
$$

The quantity that is passed to the activation function is called the pre-activations:

$$
\pmb { a } _ { l } = \pmb { b } _ { l } + \mathbf { W } _ { l } \pmb { z } _ { l - 1 }
$$

so $z _ { l } = \varphi _ { l } ( a _ { l } )$ .

If we now compose $L$ of these functions together, as in Equation (13.3), then we can compute the gradient of the output wrt the parameters in each layer using the chain rule, also known as backpropagation, as we explain in Section 13.3. (This is true for any kind of differentiable activation function, although some kinds work better than others, as we discuss in Section 13.2.3.) We can then pass the gradient to an optimizer, and thus minimize some training objective, as we discuss in Section 13.4. For this reason, the term “MLP” almost always refers to this differentiable form of the model, rather than the historical version with non-differentiable linear threshold units.

# 13.2.3 Activation functions

We are free to use any kind of differentiable activation function we like at each layer. However, if we use a linear activation function, $\varphi _ { \ell } ( a ) = c _ { \ell } a$ , then the whole model reduces to a regular linear model. To see this, note that Equation (13.3) becomes

$$
f ( \pmb { x } ; \pmb { \theta } ) = \mathbf { W } _ { L } c _ { L } \big ( \mathbf { W } _ { L - 1 } c _ { L - 1 } \big ( \cdot \cdot \cdot ( \mathbf { W } _ { 1 } \pmb { x } ) \cdot \cdot \cdot \big ) \big ) \propto \mathbf { W } _ { L } \mathbf { W } _ { L - 1 } \cdot \cdot \cdot \mathbf { W } _ { 1 } \pmb { x } = \mathbf { W } ^ { \prime } \pmb { x }
$$

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

![](images/0ff6e2888d21dbc3e882e76603844ebbea562b8b27f801f8a835599675865508.jpg)  
Figure 13.2: (a) Illustration of how the sigmoid function is linear for inputs near 0, but saturates for large positive and negative inputs. Adapted from 11.1 of [Gér19]. (b) Plots of some neural network activation functions. Generated by activation_fun_plot.ipynb.

where we dropped the bias terms for notational simplicity. For this reason, it is important to use nonlinear activation functions.

In the early days of neural networks, a common choice was to use a sigmoid (logistic) function, which can be seen as a smooth approximation to the Heaviside function used in a perceptron:

$$
\sigma ( a ) = \frac { 1 } { 1 + e ^ { - a } }
$$

However, as shown in Figure 13.2a, the sigmoid function saturates at 1 for large positive inputs, and at 0 for large negative inputs. Another common choice is the tanh function, which has a similar shape, but saturates at -1 and $+ 1$ . See Figure 13.2b.

In the saturated regimes, the gradient of the output wrt the input will be close to zero, so any gradient signal from higher layers will not be able to propagate back to earlier layers. This is called the vanishing gradient problem, and it makes it hard to train the model using gradient descent (see Section 13.4.2 for details). One of the keys to being able to train very deep models is to use non-saturating activation functions. Several different functions have been proposed. The most common is rectified linear unit or ReLU, proposed in [GBB11; KSH12]. This is defined as

$$
\mathrm { R e L U } ( a ) = \operatorname* { m a x } ( a , 0 ) = a \mathbb { I } \left( a > 0 \right)
$$

The ReLU function simply “turns off” negative inputs, and passes positive inputs unchanged: see Figure 13.2b for a plot, and Section 13.4.3 for more details.

# 13.2.4 Example models

MLPs can be used to perform classification and regression for many kinds of data. We give some examples below.

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

![](images/cb5e10b9b8ee580765b44bc0f97acd37cf5eda6220ace4356dcfcd20f5143460.jpg)  
Figure 13.3: An MLP with 2 hidden layers applied to a set of 2d points from 2 classes, shown in the top left corner. The visualizations associated with each hidden unit show the decision boundary at that part of the network. The final output is shown on the right. The input is $\pmb { x } \in \mathbb { R } ^ { 2 }$ , the first layer activations are $z _ { 1 } \in \mathbb { R } ^ { 4 }$ , the second layer activations are $z _ { 2 } \in \mathbb { R } ^ { 2 }$ , and the final logit is $a _ { 3 } \in \mathbb { R }$ , which is converted to a probability using the sigmoid function. This is a screenshot from the interactive demo at http: // playground. tensorflow. org .

# 13.2.4.1 MLP for classifying 2d data into 2 categories

Figure 13.3 gives an illustration of an MLP with two hidden layers applied to a 2d input vector, corresponding to points in the plane, coming from two concentric circles. This model has the following form:

$$
\begin{array} { r } { p ( y | \mathbf { \boldsymbol { x } } ; \mathbf { \boldsymbol { \theta } } ) = \mathrm { B e r } ( y | \sigma ( a _ { 3 } ) ) \qquad } \\ { a _ { 3 } = w _ { 3 } ^ { \top } z _ { 2 } + b _ { 3 } \qquad } \\ { z _ { 2 } = \varphi ( \mathbf { W } _ { 2 } z _ { 1 } + b _ { 2 } ) \qquad } \\ { z _ { 1 } = \varphi ( \mathbf { W } _ { 1 } \mathbf { \boldsymbol { x } } + b _ { 1 } ) \qquad } \end{array}
$$

Here $a _ { 3 }$ is the final logit score, which is converted to a probability via the sigmoid (logistic) function. The value $a _ { 3 }$ is computed by taking a linear combination of the 2 hidden units in layer 2, using $a _ { 3 } = { \pmb w } _ { 3 } ^ { 1 } z _ { 2 } + b _ { 3 }$ . In turn, layer 2 is computed by taking a nonlinear combination of the 4 hidden units in layer 1, using $z _ { \mathrm { 2 } } = \varphi ( \mathbf { W } _ { \mathrm { 2 } } z _ { \mathrm { 1 } } + b _ { \mathrm { 2 } } )$ . Finally, layer 1 is computed by taking a nonlinear combination of the 2 input units, using $z _ { 1 } = \varphi ( \mathbf { W } _ { 1 } \pmb { x } + b _ { 1 } )$ . By adjusting the parameters, $\pmb { \theta } = ( \mathbf { W } _ { 1 } , b _ { 1 } , \mathbf { W } _ { 2 } , b _ { 2 } , \pmb { w } _ { 3 } , b _ { 3 } )$ , to minimize the negative log likelihood, we can fit the training data very well, despite the highly nonlinear nature of the decision boundary. (You can find an interactive version of this figure at http://playground.tensorflow.org.)

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

Model: "sequential"

Layer (type) Output Shape Param #   
flatten (Flatten) (None, 784) 0   
dense (Dense) (None, 128) 100480   
dense_1 (Dense) (None, 128) 16512   
dense_2 (Dense) (None, 10) 1290

Table 13.2: Structure of the MLP used for MNIST classification. Note that 1 $0 0 , 4 8 0 = ( 7 8 4 + 1 ) \times 1 2 8$ , and $1 6 , 5 1 2 = ( 1 2 8 + 1 ) \times 1 2 8$ . mlp_mnist_tf.ipynb.

# 13.2.4.2 MLP for image classification

To apply an MLP to image classification, we need to “flatten” the 2d input into 1d vector. We can then use a feedforward architecture similar to the one described in Section 13.2.4.1. For example, consider building an MLP to classifiy MNIST digits (Section 3.5.2). These are $2 8 \times 2 8 = 7 8 4 -$ dimensional. If we use 2 hidden layers with 128 units each, followed by a final 10 way softmax layer, we get the model shown in Table 13.2.

We show some predictions from this model in Figure 13.4. We train it for just two “epochs” (passes over the dataset), but already the model is doing quite well, with a test set accuracy of $9 7 . 1 \%$ . Furthermore, the errors seem sensible, e.g., 9 is mistaken as a 3. Training for more epochs can further improve test accuracy.

In Chapter 14 we discuss a different kind of model, called a convolutional neural network, which is better suited to images. This gets even better performance and uses fewer parameters, by exploiting prior knowledge about the spatial structure of images. By contrast, with an MLP, we can randomly shuffle (permute) the pixels without affecting the output (assuming we use the same random permutation for all inputs).

# 13.2.4.3 MLP for text classification

To apply MLPs to text classification, we need to convert the variable-length sequence of words $\pmb { v } _ { 1 } , \ldots , \pmb { v } _ { T }$ (where each ${ \mathbf { } } _ { { \mathbf { } } } \mathbf { \Delta } \mathbf { v } _ { t }$ is a one-hot vector of length $V$ , where $V$ is the vocabulary size) into a fixed dimensional vector $_ { x }$ . The easiest way to do this is as follows. First we treat the input as an unordered bag of words (Section 1.5.4.1), $\left\{ \pmb { v } _ { t } \right\}$ . The first layer of the model is a $E \times V$ embedding matrix $\mathbf { W } _ { 1 }$ , which converts each sparse $V$ -dimensional vector to a dense $E$ -dimensional embedding, $e _ { t } = \mathbf { W } _ { 1 } \mathbf { v } _ { t }$ (see Section 20.5 for more details on word embeddings). Next we convert this set of $T$

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

![](images/40525b7c310d95cc89e3b1716955fcff304aa16232b2dc35e275ac9986ce3cd3.jpg)  
Figure 13.4: Results of applying an MLP (with 2 hidden layers with 128 units and 1 output layer with 10 units) to some MNIST images (cherry picked to include some errors). Red is incorrect, blue is correct. (a) After 1 epoch of training. (b) After 2 epochs. Generated by mlp_mnist_tf.ipynb.

$E$ -dimensional embeddings into a fixed-sized vector using global average pooling, $\textstyle { \overline { { e } } } = { \frac { 1 } { T } } \sum _ { t = 1 } ^ { T } e _ { t }$ . This can then be passed as input to an MLP. For example, if we use a single hidden layer, and a logistic output (for binary classification), we get

$$
\begin{array} { c } { p ( \boldsymbol { y } | \boldsymbol { x } ; \boldsymbol { \theta } ) = \displaystyle \mathrm { B e r } ( \boldsymbol { y } | \sigma ( \boldsymbol { w } _ { 3 } ^ { \top } h + b _ { 3 } ) ) } \\ { h = \varphi ( \mathbf { W } _ { 2 } \boldsymbol { \overline { { e } } } + b _ { 2 } ) } \\ { \displaystyle \boldsymbol { \overline { { e } } } = \frac { 1 } { T } \sum _ { t = 1 } ^ { T } e _ { t } } \\ { e _ { t } = \mathbf { W } _ { 1 } \boldsymbol { v } _ { t } } \end{array}
$$

If we use a vocabulary size of $V = 1 0 , 0 0 0$ , an embedding size of $E = 1 6$ , and a hidden layer of size 16, we get the model shown in Table 13.3. If we apply this to the IMDB movie review sentiment classification dataset discussed in Section 1.5.2.1, we get 86% on the validation set.

We see from Table 13.3 that the model has a lot of parameters, which can result in overfitting, since the IMDB training set only has 25k examples. However, we also see that most of the parameters are in the embedding matrix, so instead of learning these in a supervised way, we can perform unsupervised pre-training of word embedding models, as we discuss in Section 20.5. If the embedding matrix $\mathbf { W } _ { 1 }$ is fixed, we just have to fine-tune the parameters in layers 2 and 3 for this specific labeled task, which requires much less data. (See also Chapter 19, where we discuss general techniques for training with limited labeled data.)

# 13.2.4.4 MLP for heteroskedastic regression

We can also use MLPs for regression. Figure 13.5 shows how we can make a model for heteroskedastic nonlinear regression. (The term “heteroskedastic” just means that the predicted output variance is input-dependent, as discussed in Section 2.6.3.) This function has two outputs which compute $f _ { \mu } ( \pmb { x } ) = \mathbb { E } \left[ y | \pmb { x } , \pmb { \theta } \right]$ and $f _ { \sigma } ( \pmb { x } ) = \sqrt { \mathbb { V } \left[ y | \pmb { x } , \pmb { \theta } \right] }$ . We can share most of the layers (and hence parameters) between these two functions by using a common “backbone” and two output “heads”, as shown in

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

Model: "sequential"

Layer (type) Output Shape Param #   
embedding (Embedding) (None, None, 16) 160000   
global_average_pooling1d (Gl (None, 16) 0   
dense (Dense) (None, 16) 272   
dense_1 (Dense) (None, 1) 17   
Total params: 160,289   
Trainable params: 160,289   
Non-trainable params: 0

Table 13.3: Structure of the MLP used for IMDB review classification. We use a vocabulary size of $V = 1 0 , 0 0 0$ , an embedding size of $E = 1 6$ , and a hidden layer of size 16. The embedding matrix $\mathbf { W } _ { 1 }$ has size $1 0 , 0 0 0 \times 1 6$ , the hidden layer (labeled “dense”) has a weight matrix $\mathbf { W } _ { 2 }$ of size $1 6 \times 1 6$ and bias $\scriptstyle b _ { 2 }$ of size 16 (note that $1 6 \times 1 6 + 1 6 = 2 7 2$ ), and the final layer (labeled “dense_1”) has a weight vector ${ \pmb w } _ { 3 }$ of size 16 and a bias $b _ { 3 }$ of size 1. The global average pooling layer has no free parameters. mlp_imdb_tf.ipynb.

![](images/1a5adc4dd2446eb76e5f5643b612afcad50277f1df42d3dc8744969442ae84bb.jpg)  
Figure 13.5: Illustration of an MLP with a shared “backbone” and two output “heads”, one for predicting the mean and one for predicting the variance. From https: // brendanhasz. github. io/ 2019/ 07/ 23/ bayesian-density-net. html . Used with kind permission of Brendan Hasz.

Figure 13.5. For the $\mu$ head, we use a linear activation, $\varphi ( a ) = a$ . For the $\sigma$ head, we use a softplus activation, $\varphi ( a ) = \sigma _ { + } ( a ) = \log ( 1 + e ^ { a } )$ . If we use linear heads and a nonlinear backbone, the overall model is given by

$$
p ( y | \mathbf { x } , \pmb { \theta } ) = \mathcal { N } \left( y | \pmb { w } _ { \mu } ^ { \top } f ( \mathbf { x } ; \pmb { w } _ { \mathrm { s h a r e d } } ) , \sigma _ { + } ( \pmb { w } _ { \sigma } ^ { \top } f ( \pmb { x } ; \pmb { w } _ { \mathrm { s h a r e d } } ) ) \right)
$$

Figure 13.6 shows the advantage of this kind of model on a dataset where the mean grows linearly over time, with seasonal oscillations, and the variance increases quadratically. (This is a simple example of a stochastic volatility model; it can be used to model financial data, as well as the

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license global temperature of the earth, which (due to climate change) is increasing in mean and in variance.) We see that a regression model where the output variance $\sigma ^ { 2 }$ is treated as a fixed (input-independent) parameter will sometimes be underconfident, since it needs to adjust to the overall noise level, and cannot adapt to the noise level at each point in input space.

![](images/886465a83fc291bb79c081e8d1a0c232d870dbe8210efc532802b96c5ff37f90.jpg)  
Figure 13.6: Illustration of predictions from an MLP fit using MLE to a 1d regression dataset with growing noise. (a) Output variance is input-dependent, as in Figure 13.5. (b) Mean is computed using same model as in (a), but output variance is treated as a fixed parameter $\sigma ^ { 2 }$ , which is estimated by MLE after training, as in Section 11.2.3.6. Generated by mlp_1d_regression_hetero_tfp.ipynb.

![](images/48f7132531f88d2cb01d6ac97cdf92ee7d7f50df6cd0f5e3f63e86b6f93d1323.jpg)  
Figure 13.7: A decomposition of $\mathbb { R } ^ { 2 }$ into a finite set of linear decision regions produced by an MLP with ReLU activations with (a) one hidden layer of 25 hidden units and (b) two hidden layers. From Figure 1 of [HAB19]. Used with kind permission of Maksym Andriuschenko.

# 13.2.5 The importance of depth

One can show that an MLP with one hidden layer is a universal function approximator, meaning it can model any suitably smooth function, given enough hidden units, to any desired level of accuracy [HSW89; Cyb89; Hor91]. Intuitively, the reason for this is that each hidden unit can specify a half plane, and a sufficiently large combination of these can “carve up” any region of space, to which we can associate any response (this is easiest to see when using piecewise linear activation functions, as shown in Figure 13.7).

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

However, various arguments, both experimental and theoretical (e.g., [Has87; Mon+14; Rag+17; Pog+17]), have shown that deep networks work better than shallow ones. The reason is that later layers can leverage the features that are learned by earlier layers; that is, the function is defined in a compositional or hierarchical way. For example, suppose we want to classify DNA strings, and the positive class is associated with the regular expression \*AA??CGCG??AA\*. Although we could fit this with a single hidden layer model, intuitively it will be easier to learn if the model first learns to detect the AA and CG “motifs” using the hidden units in layer 1, and then uses these features to define a simple linear classifier in layer 2, analogously to how we solved the XOR problem in Section 13.2.1.

# 13.2.6 The “deep learning revolution”

Although the ideas behind DNNs date back several decades, it was not until the 2010s that they started to become very widely used. The first area to adopt these methods was the field of automatic speech recognition (ASR), based on breakthrough results in [Dah+11]. This approach rapidly became the standard paradigm, and was widely adopted in academia and industry [Hin+12].

However, the moment that got the most attention was when [KSH12] showed that deep CNNs could significantly improve performance on the challenging ImageNet image classification benchmark, reducing the error rate from 26% to $1 6 \%$ in a single year (see Figure 1.14b); this was a huge jump compared to the previous rate of progress of about 2% reduction per year.

The “explosion” in the usage of DNNs has several contributing factors. One is the availability of cheap GPUs (graphics processing units); these were originally developed to speed up image rendering for video games, but they can also massively reduce the time it takes to fit large CNNs, which involve similar kinds of matrix-vector computations. Another is the growth in large labeled datasets, which enables us to fit complex function approximators with many parameters without overfitting. (For example, ImageNet has 1.3M labeled images, and is used to fit models that have millions of parameters.) Indeed, if deep learning systems are viewed as “rockets”, then large datasets have been called the fuel.2

Motivated by the outstanding empirical success of DNNs, various companies started to become interested in this technology. This had led to the development of high quality open-source software libraries, such as Tensorflow (made by Google), PyTorch (made by Facebook), and MXNet (made by Amazon). These libraries support automatic differentiation (see Section 13.3) and scalable gradient-based optimization (see Section 8.4) of complex differentiable functions. We will use some of these libraries in various places throughout the book to implement a variety of models, not just DNNs.3

More details on the history of the “deep learning revolution” can be found in e.g., [Sej18; Met21].

# 13.2.7 Connections with biology

In this section, we discuss the connections between the kinds of neural networks we have discussed above, known as artificial neural networks or ANNs, and real neural networks. The details on how real biological brains work are quite complex (see e.g., [Kan+12]), but we can give a simple “cartoon”.

![](images/9f223a5346921e4c5b33fc26ad30c107e5666f7c9729dd777abaaac269e92e72.jpg)  
Figure 13.8: Illustration of two neurons connected together in a “circuit”. The output axon of the left neuron makes a synaptic connection with the dendrites of the cell on the right. Electrical charges, in the form of ion flows, allow the cells to communicate. From https: // en. wikipedia. org/ wiki/ Neuron . Used with kind permission of Wikipedia author BruceBlaus.

We start by considering a model of a single neuron. To a first approximation, we can say that whether neuron $k$ fires, denoted by $h _ { k } \in \{ 0 , 1 \}$ , depends on the activity of its inputs, denoted by $\pmb { x } \in \mathbb { R } ^ { D }$ , as well as the strength of the incoming connections, which we denote by ${ \pmb w } _ { k } \in \mathbb { R } ^ { D }$ . We can compute a weighted sum of the inputs using $a _ { k } = \pmb { w } _ { k } ^ { 1 } \pmb { x }$ . These weights can be viewed as “wires” connecting the inputs $x _ { d }$ to neuron $h _ { k }$ ; these are analogous to dendrites in a real neuron (see Figure 13.8). This weighted sum is then compared to a threshold, $b _ { k }$ , and if the activation exceeds the threshold, the neuron fires; this is analogous to the neuron emitting an electrical output or action potential. Thus we can model the behavior of the neuron using $h _ { k } ( \pmb { x } ) = H ( \pmb { w } _ { k } ^ { \top } \pmb { x } - b _ { k } )$ , where $H ( a ) = \mathbb { I } ( a > 0 )$ is the Heaviside function. This is called the McCulloch-Pitts model of the neuron, and was proposed in 1943 [MP43].

We can combine multiple such neurons together to make an ANN. The result has sometimes been viewed as a model of the brain. However, ANNs differs from biological brains in many ways, including the following:

• Most ANNs use backpropagation to modify the strength of their connections (see Section 13.3). However, real brains do not use backprop, since there is no way to send information backwards along an axon [Ben+15b; BS16; KH19]. Instead, they use local update rules for adjusting synaptic strengths. • Most ANNs are strictly feedforward, but real brains have many feedback connections. It is believed that this feedback acts like a prior, which can be combined with bottom up likelihoods from the sensory system to compute a posterior over hidden states of the world, which can then be used for

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022 optimal decision making (see e.g., [Doy+07]).

![](images/d20a25e495d586d928fd0891b2defb8d26978e76554a734587fdff434f001b19.jpg)  
Figure 13.9: Plot of neural network sizes over time. Models 1, 2, 3 and 4 correspond to the perceptron [Ros58], the adaptive linear unit [WH60] the neocognitron [Fuk80], and the first MLP trained by backprop [RHW86]. Approximate number of neurons for some living organisms are shown on the right scale (the sponge has 0 neurons), based on https: // en. wikipedia. org/ wiki/ List_ of_ animals_ by_ number_ of_ neurons . From Figure 1.11 of [GBC16]. Used with kind permission of Ian Goodfellow.

• Most ANNs use simplified neurons consisting of a weighted sum passed through a nonlinearity, but real biological neurons have complex dendritic tree structures (see Figure 13.8), with complex spatio-temporal dynamics.   
• Most ANNs are smaller in size and number of connections than biological brains (see Figure 13.9). Of course, ANNs are getting larger every week, fueled by various new hardware accelerators, such as GPUs and TPUs (tensor processing units), etc. However, even if ANNs match biological brains in terms of number of units, the comparison is misleading since the processing capability of a biological neuron is much higher than an artificial neuron (see point above).   
• Most ANNs are designed to model a single function, such as mapping an image to a label, or a sequence of words to another sequence of words. By contrast, biological brains are very complex systems, composed of multiple specialized interacting modules, which implement different kinds of functions or behaviors such as perception, control, memory, language, etc (see e.g., [Sha88; Kan+12]).

Of course, there are efforts to make realistic models of biological brains (e.g., the Blue Brain Project [Mar06; Yon19]). However, an interesting question is whether studying the brain at this level of detail is useful for “solving AI”. It is commonly believed that the low level details of biological brains do not matter if our goal is to build “intelligent machines”, just as aeroplanes do not flap their wings. However, presumably “AIs” will follow similar “laws of intelligence” to intelligent biological agents, just as planes and birds follow the same laws of aerodynamics.

Unfortunately, we do not yet know what the “laws of intelligence” are, or indeed if there even are such laws. In this book we make the assumption that any intelligent agent should follow the basic

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license principles of information processing and Bayesian decision theory, which is known to be the optimal way to make decisions under uncertainty (see Section 5.1).

In practice, the optimal Bayesian approach is often computationally intractable. In the natural world, biological agents have evolved various algorithmic “shortcuts” to the optimal solution; this can explain many of the heuristics that people use in everyday reasoning [KST82; GTA00; Gri20]. As the tasks we want our machines to solve become harder, we may be able to gain insights from neuroscience and cognitive science for how to solve such tasks in an approximate way (see e.g., [MWK16; Has+17; Lak+17; HG21]). However, we should also bear in mind that AI/ML systems are increasingly used for safety-critical applications, in which we might want and expect the machine to do better than a human. In such cases, we may want more than just heuristic solutions that often work; instead we may want provably reliable methods, similar to other engineering fields (see Section 1.6.3 for further discussion).

# 13.3 Backpropagation

# This section is coauthored with Mathieu Blondel.

In this section, we describe the famous backpropagation algorithm, which can be used to compute the gradient of a loss function applied to the output of the network wrt the parameters in each layer. This gradient can then be passed to a gradient-based optimization algorithm, as we discuss in Section 13.4.

The backpropagation algorithm was originally discovered in [BH69], and independently in [Wer74]. However, it was [RHW86] that brought the algorithm to the attention of the “mainstream” ML community. See the wikipedia page $^ 4$ for more historical details.

We initially assume the computation graph is a simple linear chain of stacked layers, as in an MLP. In this case, backprop is equivalent to repeated applications of the chain rule of calculus (see Equation (7.261)). However, the method can be generalized to arbitrary directed acyclic graphs (DAGs), as we discuss in Section 13.3.4. This general procedure is often called automatic differentiation or autodiff.

# 13.3.1 Forward vs reverse mode differentiation

Consider a mapping of the form $\mathbf { \delta } _ { \mathbf { \boldsymbol { o } } } = \mathbf { \mathcal { f } } ( \mathbf { \boldsymbol { x } } )$ , where $\pmb { x } \in \mathbb { R } ^ { n }$ and $\pmb { o } \in \mathbb { R } ^ { r n }$ . We assume that $f$ is defined as a composition of functions:

$$
f = f _ { 4 } \circ f _ { 3 } \circ f _ { 2 } \circ f _ { 1 }
$$

where $f _ { 1 } : \mathbb { R } ^ { n } \to \mathbb { R } ^ { m _ { 1 } }$ , $f _ { 2 } : \mathbb { R } ^ { m _ { 1 } } \to \mathbb { R } ^ { m _ { 2 } }$ , $f _ { 3 } : \mathbb { R } ^ { m _ { 2 } } \to \mathbb { R } ^ { m _ { 3 } }$ , and $f _ { 4 } : \mathbb { R } ^ { m _ { 3 } }  \mathbb { R } ^ { m }$ . The intermediate steps needed to compute $\mathbf { \delta } _ { \mathbf { \boldsymbol { o } } } = \mathbf { \mathcal { f } } ( \mathbf { \boldsymbol { x } } )$ are ${ \pmb x } _ { 2 } = { \pmb f } _ { 1 } ( { \pmb x } )$ , ${ \pmb x } _ { 3 } = { \pmb f } _ { 2 } ( { \pmb x } _ { 2 } )$ , ${ \pmb x } _ { 4 } = { \pmb f } _ { 3 } ( { \pmb x } _ { 3 } )$ , and $\pmb { o } = f _ { 4 } ( \pmb { x } _ { 4 } )$ .

We can compute the Jacobian $\begin{array} { r } { \mathbf { J } _ { f } ( \pmb { x } ) = \frac { \partial \pmb { o } } { \partial \pmb { x } } \in \mathbb { R } ^ { m \times n } } \end{array}$ using the chain rule:

$$
{ \begin{array} { c } { { \cfrac { \partial o } { \partial \mathbf { x } } } = { \cfrac { \partial o } { \partial \mathbf { x } _ { 4 } } } { \cfrac { \partial \mathbf { x } _ { 4 } } { \partial \mathbf { x } _ { 3 } } } { \cfrac { \partial \mathbf { x } _ { 3 } } { \partial \mathbf { x } _ { 2 } } } { \cfrac { \partial \mathbf { x } _ { 2 } } { \partial \mathbf { x } } } = { \cfrac { \partial f _ { 4 } ( \mathbf { x } _ { 4 } ) } { \partial \mathbf { x } _ { 4 } } } { \cfrac { \partial f _ { 3 } ( \mathbf { x } _ { 3 } ) } { \partial \mathbf { x } _ { 3 } } } { \cfrac { \partial f _ { 2 } ( \mathbf { x } _ { 2 } ) } { \partial \mathbf { x } _ { 2 } } } { \cfrac { \partial f _ { 1 } ( \mathbf { x } ) } { \partial \mathbf { x } } } } \\ { = \mathbf { J } _ { f _ { 4 } } ( \mathbf { x } _ { 4 } ) \mathbf { J } _ { f _ { 3 } } ( \mathbf { x } _ { 3 } ) \mathbf { J } _ { f _ { 2 } } ( \mathbf { x } _ { 2 } ) \mathbf { J } _ { f _ { 1 } } ( \mathbf { x } ) } \end{array} }
$$

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

![](images/8811a004b89867a5a34662633cc26b8be72d805fbbe4c867feb386ca340bc07c.jpg)  
Figure 13.10: A simple linear-chain feedforward model with 4 layers. Here x is the input and o is the output. From [Blo20].

We now discuss how to compute the Jacobian $\mathbf { J } _ { f } ( \pmb { x } )$ efficiently. Recall that

$$
) = { \frac { \partial f ( \mathbf { x } ) } { \partial \mathbf { x } } } = { \left( \begin{array} { l l l } { { \frac { \partial f _ { 1 } } { \partial x _ { 1 } } } } & { \cdots } & { { \frac { \partial f _ { 1 } } { \partial x _ { n } } } } \\ { \vdots } & { \ddots } & { \vdots } \\ { { \frac { \partial f _ { m } } { \partial x _ { 1 } } } } & { \cdots } & { { \frac { \partial f _ { m } } { \partial x _ { n } } } } \end{array} \right) } = { \left( \begin{array} { l } { \nabla f _ { 1 } ( \mathbf { x } ) ^ { \operatorname { T } } } \\ { \vdots } \\ { \nabla f _ { m } ( \mathbf { x } ) ^ { \operatorname { T } } } \end{array} \right) } = { \left( \begin{array} { l } { \partial f } \\ { \partial x _ { 1 } } \end{array} , \cdots , { \frac { \partial f } { \partial x _ { n } } } \right) } \in \mathbb { R } ^ { m \times 1 } .
$$

where $\nabla f _ { i } ( \pmb { x } ) ^ { \mathsf { T } } \in \mathbb { R } ^ { 1 \times n }$ is the $i$ ’th row (for $i = 1 : m$ ) and $\frac { \partial \pmb { f } } { \partial x _ { j } } \in \mathbb { R } ^ { m }$ is the $j$ ’th column (for $j = 1 : n$ ). Note that, in our notation, when $m = 1$ , the gradient, denoted $\nabla f ( { \pmb x } )$ , has the same shape as $_ { x }$ . It is therefore a column vector, while $\mathbf { J } _ { f } ( \pmb { x } )$ is a row vector. In this case, we therefore technically have $\nabla f ( { \pmb x } ) = { \bf J } _ { f } ( { \pmb x } ) ^ { \scriptscriptstyle 1 }$ .

We can extract the $i$ ’th row from $\mathbf { J } _ { f } ( \pmb { x } )$ by using a vector Jacobian product (VJP) of the form $e _ { i } ^ { \top } \mathbf { J } _ { f } ( { \pmb x } )$ , where $e _ { i } \in \mathbb { R } ^ { m }$ is the unit basis vector. Similarly, we can extract the $j$ ’th column from $\mathbf { J } _ { f } ( \pmb { x } )$ by using a Jacobian vector product (JVP) of the form ${ \bf J } _ { f } ( { \pmb x } ) e _ { j }$ , where $\boldsymbol { e } _ { j } \in \mathbb { R } ^ { n }$ . This shows that the computation of $\mathbf { J } _ { f } ( \pmb { x } )$ reduces to either $n$ JVPs or $m$ VJPs.

If $n < m$ , it is more efficient to compute $\mathbf { J } _ { f } ( \pmb { x } )$ for each column $j = 1 : n$ by using JVPs in a right-to-left manner. The right multiplication with a column vector $_ { v }$ is

$$
{ \bf J } _ { f } ( { \pmb x } ) { \pmb v } = \underbrace { { \bf J } _ { f _ { 4 } } ( { \pmb x } _ { 4 } ) } _ { m \times m _ { 3 } } \underbrace { { \bf J } _ { f _ { 3 } } ( { \pmb x } _ { 3 } ) } _ { m _ { 3 } \times m _ { 2 } } \underbrace { { \bf J } _ { f _ { 2 } } ( { \pmb x } _ { 2 } ) } _ { m _ { 2 } \times m _ { 1 } } \underbrace { { \bf J } _ { f _ { 1 } } ( { \pmb x } _ { 1 } ) } _ { m _ { 1 } \times n } \underbrace { { \pmb v } } _ { n \times 1 }
$$

This can be computed using forward mode differentiation; see Algorithm 5 for the pseudocode.   
Assuming $m = 1$ and $n = \prime n _ { 1 } = \prime n _ { 2 } = \prime n _ { 3 }$ , the cost of computing $\mathbf { J } _ { f } ( \pmb { x } )$ is $O ( n ^ { 3 } )$ .

# Algorithm 5: Foward mode differentiation

1 $\pmb { x } _ { 1 } : = \pmb { x }$   
2 $\pmb { v } _ { j } : = \pmb { e } _ { j } \in \mathbb { R } ^ { n }$ for $j = 1 : n$   
3 for $k = 1 : K$ do   
4 ${ \pmb x } _ { k + 1 } = { \pmb f } _ { k } ( { \pmb x } _ { k } )$   
5 $\pmb { v } _ { j } : = \mathbf { J } _ { \pmb { f } _ { k } } ( \pmb { x } _ { k } ) \pmb { v } _ { j }$ for $j = 1 : n$   
6 Return $\begin{array} { r } { \pmb { \omega } = \pmb { x } _ { K + 1 } } \end{array}$ , $[ \mathbf { J } _ { f } ( \pmb { x } ) ] _ { : , j } = \pmb { v } _ { j }$ for $j = 1 : n$

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

If $n > m$ (e.g., if the output is a scalar), it is more efficient to compute $\mathbf { J } _ { f } ( \pmb { x } )$ for each row $i = 1 : m$ by using VJPs in a left-to-right manner. The left multiplication with a row vector $\boldsymbol { u } ^ { \intercal }$ is

$$
\pmb { u } ^ { \mathsf { T } } \mathbf { J } _ { f } ( \pmb { x } ) = \underbrace { \pmb { u } ^ { \mathsf { T } } } _ { 1 \times m } \underbrace { \mathbf { J } _ { f _ { 4 } } ( \pmb { x } _ { 4 } ) } _ { m \times m _ { 3 } } \underbrace { \mathbf { J } _ { f _ { 3 } } ( \pmb { x } _ { 3 } ) } _ { m _ { 3 } \times m _ { 2 } } \underbrace { \mathbf { J } _ { f _ { 2 } } ( \pmb { x } _ { 2 } ) } _ { m _ { 2 } \times m _ { 1 } } \underbrace { \mathbf { J } _ { f _ { 1 } } ( \pmb { x } _ { 1 } ) } _ { m _ { 1 } \times n }
$$

This can be done using reverse mode differentiation; see Algorithm 6 for the pseudocode.   
Assuming $m = 1$ and $n = \prime n _ { 1 } = \prime n _ { 2 } = \prime n _ { 3 }$ , the cost of computing $\mathbf { J } _ { f } ( \pmb { x } )$ is $O ( n ^ { 2 } )$ .

Algorithm 6: Reverse mode differentiation

1 $\pmb { x } _ { 1 } : = \pmb { x }$   
2 for $k = 1 : K$ do   
3 ${ \pmb x } _ { k + 1 } = { \pmb f } _ { k } ( { \pmb x } _ { k } )$   
4 $\pmb { u } _ { i } : = \pmb { e } _ { i } \in \mathbb { R } ^ { m }$ for $i = 1 : m$   
5 for $k = K : 1$ do   
6 $\mathbf { \Xi } \perp \mathbf { \Xi } \mathbf { { \boldsymbol { u } } } _ { i } ^ { \mathsf { T } } : = \mathbf { \boldsymbol { u } } _ { i } ^ { \mathsf { T } } \mathbf { \mathbf { J } } _ { f _ { k } } ( \mathbf { \boldsymbol { x } } _ { k } )$ for $i = 1 : m$   
7 Return $\pmb { o } = \pmb { x } _ { K + 1 }$ , $[ \mathbf { J } _ { f } ( \pmb { x } ) ] _ { i , : } = \pmb { u } _ { i } ^ { 1 }$ for $i = 1 : m$

Both Algorithms 5 and 6 can be adapted to compute JVPs and VJPs against any collection of input vectors, by accepting $\{ \pmb { v } _ { j } \} _ { j = 1 , . . . , n }$ and $\{ \pmb { u } _ { i } \} _ { i = 1 , . . . , m }$ as respective inputs. Initializing these vectors to the standard basis is useful specifically for producing the complete Jacobian as output.

# 13.3.2 Reverse mode differentiation for multilayer perceptrons

In the previous section, we considered a simple linear-chain feedforward model where each layer does not have any learnable parameters. In this section, each layer can now have (optional) parameters $\pmb { \theta } _ { 1 } , \ldots , \pmb { \theta } _ { 4 }$ . See Figure 13.10 for an illustration. We focus on the case where the mapping has the form $\mathcal { L } : \mathbb { R } ^ { n }  \mathbb { R }$ , so the output is a scalar. For example, consider $\ell _ { 2 }$ loss for a MLP with one hidden layer:

$$
\mathcal { L } ( ( \pmb { x } , \pmb { y } ) , \pmb { \theta } ) = \frac { 1 } { 2 } | | \pmb { y } - \mathbf { W } _ { 2 } \varphi ( \mathbf { W } _ { 1 } \pmb { x } ) | | _ { 2 } ^ { 2 }
$$

we can represent this as the following feedforward model:

$$
\begin{array} { r l r } {  { \mathcal { L } = f _ { 4 } \circ f _ { 3 } \circ f _ { 2 } \circ f _ { 1 } } } \\ & { } & \\ & { } & { \displaystyle x _ { 2 } = f _ { 1 } ( x , \theta _ { 1 } ) = \mathbf { W } _ { 1 } x } \\ & { } & { \displaystyle x _ { 3 } = f _ { 2 } ( x _ { 2 } , \emptyset ) = \varphi ( x _ { 2 } ) } \\ & { } & { \displaystyle x _ { 4 } = f _ { 3 } ( x _ { 3 } , \theta _ { 3 } ) = \mathbf { W } _ { 2 } x _ { 3 } } \\ & { } & { \displaystyle \mathcal { L } = f _ { 4 } ( x _ { 4 } , y ) = \frac { 1 } { 2 } | | x _ { 4 } - y | | ^ { 2 } } \end{array}
$$

We use the notation $f _ { k } ( \pmb { x } _ { k } , \pmb { \theta } _ { k } )$ to denote the function at layer $k$ , where ${ \boldsymbol { x } } _ { k }$ is the previous output and $\pmb { \theta } _ { k }$ are the optional parameters for this layer.

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

In this example, the final layer returns a scalar, since it corresponds to a loss function ${ \mathcal { L } } \in \mathbb { R }$ . Therefore it is more efficient to use reverse mode differentation to compute the gradient vectors.

We first discuss how to compute the gradient of the scalar output wrt the parameters in each layer. We can easily compute the gradient wrt the predictions in the final layer ∂xL4 . For the gradient wrt the parameters in the earlier layers, we can use the chain rule to get

$$
\begin{array} { r l } & { \frac { \partial \mathcal { L } } { \partial \theta _ { 3 } } = \frac { \partial \mathcal { L } } { \partial x _ { 4 } } \frac { \partial x _ { 4 } } { \partial \theta _ { 3 } } } \\ & { \frac { \partial \mathcal { L } } { \partial \theta _ { 2 } } = \frac { \partial \mathcal { L } } { \partial x _ { 4 } } \frac { \partial x _ { 4 } } { \partial x _ { 3 } } \frac { \partial x _ { 3 } } { \partial \theta _ { 2 } } } \\ & { \frac { \partial \mathcal { L } } { \partial \theta _ { 1 } } = \frac { \partial \mathcal { L } } { \partial x _ { 4 } } \frac { \partial x _ { 4 } } { \partial x _ { 3 } } \frac { \partial x _ { 3 } } { \partial x _ { 2 } } \frac { \partial x _ { 2 } } { \partial \theta _ { 1 } } } \end{array}
$$

where each $\begin{array} { r } { \frac { \partial \mathcal { L } } { \partial \pmb { \theta } _ { \underline { { k } } } } = ( \nabla _ { \pmb { \theta } _ { \underline { { k } } } } \mathcal { L } ) ^ { \top } } \end{array}$ is a $d _ { k }$ -dimensional gradient row vector, where $d _ { k }$ is the number of parameters in layer $k$ . We see that these can be computed recursively, by multiplying the gradient row vector at layer k by the Jacobian ∂∂xxkk1 which is an $n _ { k } \times n _ { k - 1 }$ matrix, where $n _ { k }$ is the number of hidden units in layer $k$ . See Algorithm 7 for the pseudocode.

This algorithm computes the gradient of the loss wrt the parameters at each layer. It also computes the gradient of the loss wrt the input, $\nabla _ { \pmb { x } } { \mathcal { L } } \in \mathbb { R } ^ { n }$ , where $n$ is the dimensionality of the input. This latter quantity is not needed for parameter learning, but can be useful for generating inputs to a model (see Section 14.6 for some applications).

Algorithm 7: Backpropagation for an MLP with $K$ layers   

<html><body><table><tr><td></td><td>1 //Forward pass</td></tr><tr><td>2 x1:=x</td><td></td></tr><tr><td></td><td>3 fork=1:Kdo</td></tr><tr><td>4</td><td>xk+1=fk(xk,0k)</td></tr><tr><td></td><td>5//Backward pass</td></tr><tr><td>6 uK+1:=1</td><td></td></tr><tr><td>7fork=K:1do</td><td></td></tr><tr><td>89</td><td></td></tr><tr><td></td><td></td></tr><tr><td>10//Output</td><td></td></tr><tr><td></td><td>11 Return L=xK+1,VxL=u1,{VθkL=gk : k=1: K}</td></tr></table></body></html>

All that remains is to specify how to compute the vector Jacobian product (VJP) of all supported layers. The details of this depend on the form of the function at each layer. We discuss some examples below.

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

# 13.3.3 Vector-Jacobian product for common layers

Recall that the Jacobian for a layer of the form $f : \mathbb { R } ^ { n }  \mathbb { R } ^ { m }$ . is defined by

$$
) = { \frac { \partial f ( \mathbf { x } ) } { \partial \mathbf { x } } } = { \left( \begin{array} { l l l } { { \frac { \partial f _ { 1 } } { \partial x _ { 1 } } } } & { \cdots } & { { \frac { \partial f _ { 1 } } { \partial x _ { n } } } } \\ { \vdots } & { \ddots } & { \vdots } \\ { { \frac { \partial f _ { m } } { \partial x _ { 1 } } } } & { \cdots } & { { \frac { \partial f _ { m } } { \partial x _ { n } } } } \end{array} \right) } = { \left( \begin{array} { l } { \nabla f _ { 1 } ( \mathbf { x } ) ^ { \operatorname { T } } } \\ { \vdots } \\ { \nabla f _ { m } ( \mathbf { x } ) ^ { \operatorname { T } } } \end{array} \right) } = { \left( \begin{array} { l } { \partial f } \\ { \partial x _ { 1 } } \end{array} , \cdots , { \frac { \partial f } { \partial x _ { n } } } \right) } \in \mathbb { R } ^ { m \times 1 } .
$$

where $\nabla f _ { i } ( \pmb { x } ) ^ { \sf I } \in \mathbb { R } ^ { n }$ is the $i$ ’th row (for $i = 1 : m$ ) and $\frac { \partial \pmb { f } } { \partial x _ { j } } \in \mathbb { R } ^ { m }$ is the $j$ ’th column (for $j = 1 : n$ In this section, we describe how to compute the VJP ${ \pmb u } ^ { 1 } { \bf J } _ { f } ( { \pmb x } )$ for common layers.

# 13.3.3.1 Cross entropy layer

Consider a cross-entropy loss layer taking logits $_ { x }$ and target labels $\mathbf { \Delta } _ { \mathbf { \mathcal { Y } } }$ as input, and returning a scalar:

$$
\mathbf { \Psi } : \mathbf { \Psi } : \mathbf { \mathrm { ) } } = \mathrm { C r o s s E n t r o p y W i t h L o g i t s } ( \pmb { y } , \pmb { x } ) = - \sum _ { c } y _ { c } \log ( \operatorname { s o f t m a x } ( \pmb { x } ) _ { c } ) = - \sum _ { c } y _ { c } \log ( \operatorname { s o f t m a x } ( \pmb { x } ) _ { c } ) .
$$

where $\begin{array} { r } { \pmb { p } = \mathrm { s o f t m a x } ( \pmb { x } ) = \frac { e ^ { x _ { c } } } { \sum _ { c ^ { \prime } = 1 } ^ { C } e ^ { x _ { c ^ { \prime } } } } } \end{array}$ Cexcexc′ are the predicted class probabilites, and y is the true distribution over labels (often a one-hot vector). The Jacobian wrt the input is

$$
\mathbf { J } = \frac { \partial z } { \partial \pmb { x } } = ( \pmb { p } - \pmb { y } ) ^ { \top } \in \mathbb { R } ^ { 1 \times C }
$$

To see this, assume the target label is class $c$ . We have

$$
z = f ( \pmb { x } ) = - \log ( p _ { c } ) = - \log \left( \frac { e ^ { x _ { c } } } { \sum _ { j } e ^ { x _ { j } } } \right) = \log \left( \sum _ { j } e ^ { x _ { j } } \right) - x _ { c }
$$

Hence

$$
{ \frac { \partial z } { \partial x _ { i } } } = { \frac { \partial } { \partial x _ { i } } } \log \sum _ { j } { e ^ { x _ { j } } } - { \frac { \partial } { \partial x _ { i } } } x _ { c } = { \frac { e ^ { x _ { i } } } { \sum _ { j } { e ^ { x _ { j } } } } } - { \frac { \partial } { \partial x _ { i } } } x _ { c } = p _ { i } - \mathbb { I } \left( i = c \right)
$$

If we define $\pmb { y } = [ \mathbb { I } \left( i = c \right) ]$ , we recover Equation (13.39). Note that the Jacobian of this layer is a row vector, since the output is a scalar.

# 13.3.3.2 Elementwise nonlinearity

Consider a layer that applies an elementwise nonlinearity, $z = f ( \pmb { x } ) = \varphi ( \pmb { x } )$ , so $z _ { i } = \varphi ( x _ { i } )$ . The $( i , j )$ element of the Jacobian is given by

$$
{ \frac { \partial z _ { i } } { \partial x _ { j } } } = { \left\{ \begin{array} { l l } { \varphi ^ { \prime } ( x _ { i } ) } & { { \mathrm { i f ~ } } i = j } \\ { 0 } & { { \mathrm { o t h e r w i s e } } } \end{array} \right. }
$$

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

where $\begin{array} { r } { \varphi ^ { \prime } ( a ) = \frac { d } { d a } \varphi ( a ) } \end{array}$ . In other words, the Jacobian wrt the input is

$$
\mathbf { J } = { \frac { \partial { \boldsymbol { f } } } { \partial \mathbf { x } } } = \operatorname { d i a g } ( \varphi ^ { \prime } ( \mathbf { x } ) )
$$

For an arbitrary vector $\mathbf { \Delta } _ { \mathbf { u } }$ , we can compute $\mathbf { \nabla } _ { \mathbf { \boldsymbol { u } } } \mathbf { \cdot } \mathbf { J }$ by elementwise multiplication of the diagonal elements of $\mathbf { J }$ with $\mathbf { \Delta } _ { \mathbf { u } }$ . For example, if

$$
\varphi ( a ) = \operatorname { R e L U } ( a ) = \operatorname* { m a x } ( a , 0 )
$$

we have

$$
\varphi ^ { \prime } ( a ) = { \left\{ \begin{array} { l l } { 0 } & { a < 0 } \\ { 1 } & { a > 0 } \end{array} \right. }
$$

The subderivative (Section 8.1.4.1) at $a = 0$ is any value in $\lfloor 0 , 1 \rfloor$ . It is often taken to be 0. Hence

$$
\mathrm { R e L U } ^ { \prime } ( a ) = H ( a )
$$

where $H$ is the Heaviside step function.

# 13.3.3.3 Linear layer

Now consider a linear layer, $z = f ( x , \mathbf { W } ) = \mathbf { W } x$ , where $\mathbf { W } \in \mathbb { R } ^ { m \times n }$ , so $\pmb { x } \in \mathbb { R } ^ { n }$ and $z \in \mathbb { R } ^ { m }$ . We can compute the Jacobian wrt the input vector, $\begin{array} { r } { \mathbf { J } = \frac { \partial z } { \partial x } \in \mathbb { R } ^ { m \times n } } \end{array}$ , as follows. Note that

$$
z _ { i } = \sum _ { k = 1 } ^ { n } W _ { i k } x _ { k }
$$

So the $( i , j )$ entry of the Jacobian will be

$$
{ \frac { \partial z _ { i } } { \partial x _ { j } } } = { \frac { \partial } { \partial x _ { j } } } \sum _ { k = 1 } ^ { n } W _ { i k } x _ { k } = \sum _ { k = 1 } ^ { n } W _ { i k } { \frac { \partial } { \partial x _ { j } } } x _ { k } = W _ { i j }
$$

since $\begin{array} { r } { \frac { \partial } { \partial x _ { j } } x _ { k } = \mathbb { I } \left( k = j \right) } \end{array}$ . Hence the Jacobian wrt the input is

$$
\mathbf { J } = { \frac { \partial z } { \partial x } } = \mathbf { W }
$$

The VJP between $\pmb { u } ^ { \vert } \in \mathbb { R } ^ { 1 \times m }$ and $\mathbf { J } \in \mathbb { R } ^ { m \times n }$ is

$$
\boldsymbol { \mathbf { \mathit { u } } } ^ { \top } \frac { \partial \boldsymbol { z } } { \partial \boldsymbol { \mathbf { \mathit { x } } } } = \boldsymbol { \mathbf { \mathit { u } } } ^ { \top } \boldsymbol { \mathbf { \mathit { W } } } \in \mathbb { R } ^ { 1 \times n }
$$

Now consider the Jacobian wrt the weight matrix, $\begin{array} { r } { \mathbf { J } = \frac { \partial z } { \partial \mathbf { W } } } \end{array}$ . This can be represented as a $m \times ( m \times n )$ matrix, which is complex to deal with. So instead, let us focus on taking the gradient wrt a single

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

![](images/6b657ebecc0513e7b949a3e7f7afa7281b55094ec7fa35fc6e4e568802bc7f36.jpg)  
Figure 13.11: An example of a computation graph with 2 (scalar) inputs and 1 (scalar) output. From [Blo20]

weight, Wij. This is easier to compute, since ∂∂Wz is a vector. To compute this, note that

$$
\begin{array} { r l r } { \displaystyle } & { } & { \displaystyle z _ { k } = \sum _ { l = 1 } ^ { m } W _ { k l } x _ { l } } \\ { \displaystyle } & { } & { \displaystyle \frac { \partial z _ { k } } { \partial W _ { i j } } = \sum _ { l = 1 } ^ { m } x _ { l } \frac { \partial } { \partial W _ { i j } } W _ { k l } = \sum _ { l = 1 } ^ { m } x _ { l } \mathbb { I } \left( i = k \mathrm { ~ a n d ~ } j = l \right) } \end{array}
$$

Hence

$$
\frac { \partial \boldsymbol { z } } { \partial W _ { i j } } = \left( 0 \quad \cdot \cdot \cdot \quad 0 \quad x _ { j } \quad 0 \quad \cdot \cdot \quad 0 \right) ^ { \top }
$$

where the non-zero entry occurs in location $i$ . The VJP between $\pmb { u } ^ { \vert } \in \mathbb { R } ^ { 1 \times m }$ and $\frac { \partial \boldsymbol { z } } { \partial \mathbf { W } } \in \mathbb { R } ^ { m \times ( m \times n ) }$ can be represented as a matrix of shape $1 \times ( m \times n )$ . Note that

$$
\boldsymbol { u } ^ { \intercal } \frac { \partial \boldsymbol { z } } { \partial W _ { i j } } = \sum _ { k = 1 } ^ { m } u _ { k } \frac { \partial \boldsymbol { z } _ { k } } { \partial W _ { i j } } = u _ { i } \boldsymbol { x } _ { j }
$$

Therefore

$$
\bigg [ \pmb { u } ^ { \top } \frac { \partial \pmb { z } } { \partial \mathbf { W } } \bigg ] _ { 1 , : } = \pmb { u } \pmb { x } ^ { \top } \in \mathbb { R } ^ { m \times n }
$$

# 13.3.3.4 Putting it all together

For an exercise that puts this all together, see Exercise 13.1.

# 13.3.4 Computation graphs

MLPs are a simple kind of DNN in which each layer feeds directly into the next, forming a chain structure, as shown in Figure 13.10. However, modern DNNs can combine differentiable components in much more complex ways, to create a computation graph, analogous to how programmers combine elementary functions to make more complex ones. (Indeed, some have suggested that “deep learning”

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022 be called “differentiable programming”.) The only restriction is that the resulting computation graph corresponds to a directed acyclic graph (DAG), where each node is a differentiable function of all its inputs.

For example, consider the function

$$
f ( x _ { 1 } , x _ { 2 } ) = x _ { 2 } e ^ { x _ { 1 } } { \sqrt { x _ { 1 } + x _ { 2 } e ^ { x _ { 1 } } } }
$$

We can compute this using the DAG in Figure 13.11, with the following intermediate functions:

$$
\begin{array} { r l } & { x _ { 3 } = f _ { 3 } ( x _ { 1 } ) = e ^ { x _ { 1 } } } \\ & { x _ { 4 } = f _ { 4 } ( x _ { 2 } , x _ { 3 } ) = x _ { 2 } x _ { 3 } } \\ & { x _ { 5 } = f _ { 5 } ( x _ { 1 } , x _ { 4 } ) = x _ { 1 } + x _ { 4 } } \\ & { x _ { 6 } = f _ { 6 } ( x _ { 5 } ) = \sqrt { x _ { 5 } } } \\ & { x _ { 7 } = f _ { 7 } ( x _ { 4 } , x _ { 6 } ) = x _ { 4 } x _ { 6 } } \end{array}
$$

Note that we have numbered the nodes in topological order (parents before children). During the backward pass, since the graph is no longer a chain, we may need to sum gradients along multiple paths. For example, since $x _ { 4 }$ influences $x _ { 5 }$ and $x _ { 7 }$ , we have

$$
\frac { \partial \pmb { o } } { \partial \pmb { x } _ { 4 } } = \frac { \partial \pmb { o } } { \partial \pmb { x } _ { 5 } } \frac { \partial \pmb { x } _ { 5 } } { \partial \pmb { x } _ { 4 } } + \frac { \partial \pmb { o } } { \partial \pmb { x } _ { 7 } } \frac { \partial \pmb { x } _ { 7 } } { \partial \pmb { x } _ { 4 } }
$$

We can avoid repeated computation by working in reverse topological order. For example,

$$
\begin{array} { l } { \displaystyle { \frac { \partial o } { \partial x _ { \tau } } = \frac { \partial x _ { \tau } } { \partial x _ { \tau } } = \mathbf { I } _ { m } } } \\ { \displaystyle { \frac { \partial o } { \partial x _ { 6 } } = \frac { \partial o } { \partial x _ { \tau } } \frac { \partial x _ { \tau } } { \partial x _ { 6 } } } } \\ { \displaystyle { \frac { \partial o } { \partial x _ { 5 } } = \frac { \partial o } { \partial x _ { 6 } } \frac { \partial x _ { 6 } } { \partial x _ { 5 } } } } \\ { \displaystyle { \frac { \partial o } { \partial x _ { 4 } } = \frac { \partial o } { \partial x _ { 5 } } \frac { \partial x _ { 5 } } { \partial x _ { 4 } } + \frac { \partial o } { \partial x _ { 7 } } \frac { \partial x _ { 7 } } { \partial x _ { 4 } } } } \end{array}
$$

In general, we use

$$
\frac { \partial \pmb { o } } { \partial \pmb { x } _ { j } } = \sum _ { k \in \mathrm { C h } ( j ) } \frac { \partial \pmb { o } } { \partial \pmb { x } _ { k } } \frac { \partial \pmb { x } _ { k } } { \partial \pmb { x } _ { j } }
$$

where the sum is over all children $k$ of node $j$ , as shown in Figure 13.12. The $\frac { \partial o } { \partial { \bf x } _ { k } }$ gradient vector has already been computed for each child $k$ ; this quantity is called the adjoint. This gets multiplied by the Jacobian $\frac { \partial \pmb { x } _ { k } } { \partial \pmb { x } _ { j } }$ of each child.

The computation graph can be computed ahead of time, by using an API to define a static graph. (This is how Tensorflow 1 worked.) Alternatively, the graph can be computed “just in time”, by tracing the execution of the function on an input argument. (This is how Tensorflow eager mode works, as well as JAX and PyTorch.) The latter approach makes it easier to work with a dynamic graph, whose shape can change depending on the values computed by the function.

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

![](images/647bbdcfcdf769cb94bab137ba33a3a85f19c51433d9565a6034601c290d8c20.jpg)  
Figure 13.12: Notation for automatic differentiation at node $j$ in a computation graph. From [Blo20].

![](images/a5dd4b265775846ceef169f42cddd83c9d3d7476d39d622c9929503a3c0301e9.jpg)  
Figure 13.13: Computation graph for an MLP with input $_ { x }$ , hidden layer $\mathbf { \delta } _ { h }$ , output $\textbf { \em o }$ , loss function $L = \ell ( o , y )$ , an $\ell _ { 2 }$ regularizer s on the weights, and total loss $\boldsymbol { J } = \boldsymbol { L } + \boldsymbol { s }$ . From Figure 4.7.1 of [Zha+20]. Used with kind permission of Aston Zhang.

Figure 13.13 shows a computation graph corresponding to an MLP with one hidden layer with weight decay. More precisely, the model computes the linear pre-activations $z = \mathbf { W } ^ { ( 1 ) } x$ , the hidden activations $h = \phi ( z )$ , the linear outputs ${ \mathbf o } = { \mathbf W } ^ { ( 2 ) } { \mathbf h }$ , the loss $L = \ell ( o , y )$ , the regularizer $\begin{array} { r } { s = \frac { \lambda } { 2 } ( | | \mathbf { W } ^ { ( 1 ) } | | _ { F } ^ { 2 } + | | \mathbf { W } ^ { ( 2 ) } | | _ { F } ^ { 2 } ) } \end{array}$ , and the total loss $\boldsymbol { J } = \boldsymbol { L } + \boldsymbol { s }$ .

# 13.4 Training neural networks

In this section, we discuss how to fit DNNs to data. The standard approach is to use maximum likelihood estimation, by minimizing the NLL:

$$
\mathcal { L } ( \pmb { \theta } ) = - \log p ( \mathcal { D } | \pmb { \theta } ) = - \sum _ { n = 1 } ^ { N } \log p ( \pmb { y } _ { n } | \pmb { x } _ { n } ; \pmb { \theta } )
$$

It is also common to add a regularizer (such as the negative log prior), as we discuss in Section 13.5. In principle we can just use the backprop algorithm (Section 13.3) to compute the gradient of this loss and pass it to an off-the-shelf optimizer, such as those discussed in Chapter 8. (The Adam optimizer of Section 8.4.6.3 is a popular choice, due to its ability to scale to large datasets (by virtue of being an SGD-type algorithm), and to converge fairly quickly (by virtue of using diagonal

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022 preconditioning and momentum).) However, in practice this may not work well. In this section, we discuss various problems that may arise, as well as some solutions. For more details on the practicalities of training DNNs, see various other books, such as [HG20; Zha+20; Gér19].

In addition to practical issues, there are important theoretical issues. In particular, we note that the DNN loss is not a convex objective, so in general we will not be able to find the global optimum. Nevertheless, SGD can often find suprisingly good solutions. The research into why this is the case is still being conducted; see [Bah+20] for a recent review of some of this work.

# 13.4.1 Tuning the learning rate

It is important to tune the learning rate (step size), to ensure convergence to a good solution. We discuss this issue in Section 8.4.3.

# 13.4.2 Vanishing and exploding gradients

When training very deep models, the gradient tends to become either very small (this is called the vanishing gradient problem) or very large (this is called the exploding gradient problem), because the error signal is being passed through a series of layers which either amplify or diminish it [Hoc+01]. (Similar problems arise in RNNs on long sequences, as we explain in Section 15.2.6.)

To explain the problem in more detail, consider the gradient of the loss wrt a node at layer $\it { l }$ :

$$
\frac { \partial \mathcal { L } } { \partial z _ { l } } = \frac { \partial \mathcal { L } } { \partial z _ { l + 1 } } \frac { \partial z _ { l + 1 } } { \partial z _ { l } } = \mathbf { J } _ { l } \mathbf { g } _ { l + 1 }
$$

where Jl = ∂∂zlz+l1 is the Jacobian matrix, and gl+1 = ∂z∂lL+1 is the gradient at the next layer. If $\mathbf { J } _ { l }$ is constant across layers, it is clear that the contribution of the gradient from the final layer, $_ { g L }$ , to layer $\it { l }$ will be $\mathbf { J } ^ { L - l } { g _ { L } }$ . Thus the behavior of the system depends on the eigenvectors of $\mathbf { J }$ .

Although $\mathbf { J }$ is a real-valued matrix, it is not (in general) symmetric, so its eigenvalues and eigenvectors can be complex-valued, with the imaginary components corresponding to oscillatory behavior. Let $\lambda$ be the spectral radius of $\mathbf { J }$ , which is the maximum of the absolute values of the eigenvalues. If this is greater than 1, the gradient can explode; if this is less than 1, the gradient can vanish. (Similarly, the spectral radius of $\mathbf { W }$ , connecting $_ { z _ { l } }$ to $z _ { l + 1 }$ , determines the stability of the dynamical system when run in forwards mode.)

The exploding gradient problem can be ameliorated by gradient clipping, in which we cap the magnitude of the gradient if it becomes too large, i.e., we use

$$
\pmb { g } ^ { \prime } = \operatorname* { m i n } ( 1 , \frac { c } { | | \pmb { g } | | } ) \pmb { g }
$$

This way, the norm of $g ^ { \prime }$ can never exceed $c$ , but the vector is always in the same direction as $\pmb { g }$ . However, the vanishing gradient problem is more difficult to solve. There are various solutions, such as the following:

• Modify the the activation functions at each layer to prevent the gradient from becoming too large or too small; see Section 13.4.3.   
• Modify the architecture so that the updates are additive rather than multiplicative; see Section 13.4.4.

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license • Modify the architecture to standardize the activations at each layer, so that the distribution of activations over the dataset remains constant during training; see Section 14.2.4.1.

<html><body><table><tr><td>Name</td><td>Definition</td><td>Range</td><td>Reference</td></tr><tr><td>Sigmoid</td><td>σ(a)=1+e-a</td><td>[0,1]</td><td></td></tr><tr><td>Hyperbolic tangent</td><td>tanh(a)= 2σ(2a) -1</td><td>[-1,1]</td><td></td></tr><tr><td>Softplus</td><td>σ+(a)= log(1+ ea)</td><td>[0,00]</td><td>[GBB11]</td></tr><tr><td>Rectified linear unit</td><td>ReLU(a)= max(a,0)</td><td>[0,00]</td><td>GBB11; KSH12]</td></tr><tr><td>Leaky ReLU</td><td>max(a,O) +αmin(a,0)</td><td>[1,8]</td><td>[MHN13]</td></tr><tr><td>Exponential linear unit</td><td>max(a,O) +min(α(ea -1),0)</td><td>[18,8]</td><td>[CUH16]</td></tr><tr><td>Swish</td><td>aσ(a)</td><td>[18,8]</td><td>[RZL17]</td></tr><tr><td>GELU</td><td>a(a）</td><td>[18,8]</td><td>[HG16]</td></tr></table></body></html>

![](images/9d71042d7af875dbf39e24923050a776456d8204565f801f1038681497317cf0.jpg)  
Table 13.4: List of some popular activation functions for neural networks.   
Figure 13.14: (a) Some popular activation functions. (b) Plot of their gradients. Generated by activaion_fun_deriv_jax.ipynb.

• Carefully choose the initial values of the parameters; see Section 13.4.5.

# 13.4.3 Non-saturating activation functions

In Section 13.2.3, we mentioned that the sigmoid activation function saturates at 0 for large negative inputs, and at 1 for large positive inputs. It turns out that the gradient signal in these regimes is $0$ , preventing backpropagation from working.

To see why the gradient vanishes, consider a layer which computes $z = \sigma ( \mathbf { W } \mathbf { x } )$ , where

$$
\varphi ( a ) = \sigma ( a ) = { \frac { 1 } { 1 + \exp ( - a ) } }
$$

If the weights are initialized to be large (positive or negative), then it becomes very easy for $\mathbf { \Delta } a = \mathbf { W } \mathbf { \Delta } x$ to take on large values, and hence for $\mathscr { z }$ to saturate near 0 or $\mathbf { 1 }$ , since the sigmoid saturates, as shown in Figure 13.14a. Now let us consider the gradient of the loss wrt the inputs $_ { x }$ (from an earlier layer)

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

and the parameters $\mathbf { W }$ . The derivative of the activation function is given by

$$
\varphi ^ { \prime } ( a ) = \sigma ( a ) ( 1 - \sigma ( a ) )
$$

See Figure 13.14b for a plot. In Section 13.3.3, we show that the gradient of the loss wrt the inputs is

$$
\frac { \partial \mathcal { L } } { \partial \mathbf { \boldsymbol { x } } } = \mathbf { W } ^ { \top } \delta = \mathbf { W } ^ { \top } \boldsymbol { z } ( 1 - \boldsymbol { z } )
$$

and the gradient of the loss wrt the parameters is

$$
\frac { \partial \mathcal { L } } { \partial \mathbf { W } } = \delta \mathbf { \boldsymbol { x } } ^ { \mathsf { T } } = z ( 1 - z ) \mathbf { \boldsymbol { x } } ^ { \mathsf { T } }
$$

Hence, if $\textit { \textbf { z } }$ is near 0 or 1, the gradients will go to 0.

One of the keys to being able to train very deep models is to use non-saturating activation functions. Several different functions have been proposed: see Table 13.4 for a summary, and https://mlfromscratch.com/activation-functions-explained for more details.

# 13.4.3.1 ReLU

The most common is rectified linear unit or ReLU, proposed in [GBB11; KSH12]. This is defined as

$$
\mathrm { R e L U } ( a ) = \operatorname* { m a x } ( a , 0 ) = a \mathbb { I } \left( a > 0 \right)
$$

The ReLU function simply “turns off” negative inputs, and passes positive inputs unchanged. The gradient has the following form:

$$
\mathrm { R e L U } ^ { \prime } ( a ) = \mathbb { I } \left( a > 0 \right)
$$

Now suppose we use this in a layer to compute $z = \mathrm { R e L U } ( \mathbf { W } x )$ . In Section 13.3.3, we show that the gradient wrt the inputs has the form

$$
\frac { \partial \mathcal { L } } { \partial \mathbf { x } } = \mathbf { W } ^ { \mathsf { T } } \mathbb { I } \left( \mathbf { \mathscr { z } } > \mathbf { 0 } \right)
$$

and wrt the parameters has the form

$$
\frac { \partial \mathcal { L } } { \partial \mathbf { W } } = \mathbb { I } \left( \boldsymbol { z } > \mathbf { 0 } \right) \boldsymbol { x } ^ { \intercal }
$$

Hence the gradient will not vanish, as long a $\mathscr { z }$ is positive.

Unfortunately, if the weights are initialized to be large and negative, then it becomes very easy for (some components of) $\mathbf { \Delta } a = \mathbf { W } \mathbf { \Delta } x$ to take on large negative values, and hence for $\boldsymbol { z }$ to go to 0. This will cause the gradient for the weights to go to 0. The algorithm will never be able to escape this situation, so the hidden units (components of $_ { z }$ ) will stay permanently off. This is called the “dead ReLU” problem [Lu+19].

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

# 13.4.3.2 Non-saturating ReLU

The problem of dead ReLU’s can be solved by using non-saturating variants of ReLU. One alternate is the leaky ReLU, proposed in [MHN13]. This is defined as

$$
\mathrm { L R e L U } ( a ; \alpha ) = \operatorname* { m a x } ( \alpha a , a )
$$

where $0 < \alpha < 1$ . The slope of this function is 1 for positive inputs, and $\alpha$ for negative inputs, thus ensuring there is some signal passed back to earlier layers, even when the input is negative. See Figure 13.14b for a plot. If we allow the parameter $\alpha$ to be learned, rather than fixed, the leaky ReLU is called parametric ReLU [He+15].

Another popular choice is the ELU, proposed in [CUH16]. This is defined by

$$
{ \mathrm { E L U } } ( a ; \alpha ) = { \left\{ \begin{array} { l l } { \alpha ( e ^ { a } - 1 ) } & { { \mathrm { i f ~ } } a \leq 0 } \\ { a } & { { \mathrm { i f ~ } } a > 0 } \end{array} \right. }
$$

This has the advantage over leaky ReLU of being a smooth function. See Figure 13.14 for plot. A slight variant of ELU, known as SELU (self-normalizing ELU), was proposed in [Kla+17]. This has the form

$$
\mathrm { S E L U } ( a ; \alpha , \lambda ) = \lambda \mathrm { E L U } ( a ; \alpha )
$$

Surprisingly, they prove that by setting $\alpha$ and $\lambda$ to carefully chosen values, this activation function is guaranteed to ensure that the output of each layer is standardized (provided the input is also standardized), even without the use of techniques such as batchnorm (Section 14.2.4.1). This can help with model fitting.

# 13.4.3.3 Other choices

As an alternative to manually discovering good activation functions, we can use blackbox optimization methods to search over the space of functional forms. Such an approach was used in [RZL17], where they discovered a function they call swish that seems to do well on some image classification benchmarks. It is defined by

$$
\operatorname { s w i s h } ( a ; \beta ) = a \sigma ( \beta a )
$$

(The same function, under the name SiLU (for Sigmoid Linear Unit), was independently proposed in [HG16].) See Figure 13.14 for plot.

Another popular activation function is GELU, which stands for “Gaussian Error Linear Unit” [HG16]. This is defined as follows:

$$
\mathrm { G E L U } ( a ) = a \Phi ( a )
$$

where $\Phi ( a )$ is the cdf of a standard normal:

$$
\Phi ( a ) = { \mathrm { P r } } ( { \mathcal { N } } ( 0 , 1 ) \leq a ) = { \frac { 1 } { 2 } } \left( 1 + \operatorname { e r f } ( a / { \sqrt { 2 } } ) \right)
$$

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

![](images/65d0e1981ee0b84510e1b2638d9ef203edab203bc82268d0ff1a2769151f4e58.jpg)  
Figure 13.15: (a) Illustration of a residual block. (b) Illustration of why adding residual connections can help when training a very deep model. Adapted from Figure 14.16 of [Gér19].

We see from Figure 13.14 that this is not a convex or monontonic function, unlike most other activation functions.

We can think of GELU as a “soft” version of ReLU, since it replaces the step function $\mathbb { I } \left( a > 0 \right)$ with the Gaussian cdf, $\Phi ( a )$ . Alternatively, the GELU can be motivated as an adaptive version of dropout (Section 13.5.4), where we multiply the input by a binary scalar mask, $m \sim \operatorname { B e r } ( \Phi ( a ) )$ , where the probability of being dropped is given by $1 - \Phi ( a )$ . Thus the expected output is

$$
\operatorname { \mathbb { E } } [ a ] = \Phi ( a ) \times a + ( 1 - \Phi ( a ) ) \times 0 = a \Phi ( a )
$$

We can approximate GELU using swish with a particular parameter setting, namely

$$
\mathrm { G E L U } ( a ) \approx a \sigma ( 1 . 7 0 2 a )
$$

# 13.4.4 Residual connections

One solution to the vanishing gradient problem for DNNs is to use a residual network or ResNet [He+16a]. This is a feedforward model in which each layer has the form of a residual block, defined by

$$
\mathcal { F } _ { l } ^ { \prime } ( \pmb { x } ) = \mathcal { F } _ { l } ( \pmb { x } ) + \pmb { x }
$$

where $\mathcal { F } _ { l }$ is a standard shallow nonlinear mapping (e.g., linear-activation-linear). The inner $\mathcal { F } _ { l }$ function computes the residual term or delta that needs to be added to the input $_ { x }$ to generate the desired output; it is often easier to learn to generate a small perturbation to the input than to directly predict the output. (Residual connections are usually used in conjunction with CNNs, as discussed in Section 14.3.4, but can also be used in MLPs.)

A model with residual connections has the same number of parameters as a model without residual connections, but it is easier to train. The reason is that gradients can flow directly from the output

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license to earlier layers, as sketched in Figure 13.15b. To see this, note that the activations at the output layer can be derived in terms of any previous layer $\it { l }$ using

$$
z _ { L } = z _ { l } + \sum _ { i = l } ^ { L - 1 } \mathcal { F } _ { i } ( z _ { i } ; \pmb \theta _ { i } ) .
$$

We can therefore compute the gradient of the loss wrt the parameters of the $\it { \Delta } l$ ’th layer as follows:

$$
\begin{array} { r l } { \displaystyle \frac { \partial \mathcal { L } } { \partial \theta _ { l } } = \frac { \partial z _ { l } } { \partial \theta _ { l } } \frac { \partial \mathcal { L } } { \partial z _ { l } } } \\ { = \displaystyle \frac { \partial z _ { l } } { \partial \theta _ { l } } \frac { \partial \mathcal { L } } { \partial z _ { L } } \frac { \partial z _ { L } } { \partial z _ { l } } } \\ { = \displaystyle \frac { \partial z _ { l } } { \partial \theta _ { l } } \frac { \partial \mathcal { L } } { \partial z _ { L } } \left( 1 + \sum _ { i = l } ^ { L - 1 } \frac { \partial \mathcal { F } _ { i } ( z _ { i } ; \theta _ { i } ) } { \partial z _ { l } } \right) } \\ { = \displaystyle \frac { \partial z _ { l } } { \partial \theta _ { l } } \frac { \partial \mathcal { L } } { \partial z _ { L } } + \mathrm { o t h e r t e r m s } } \end{array}
$$

Thus we see that the gradient at layer $\it { l }$ depends directly on the gradient at layer $L$ in a way that is independent of the depth of the network.

# 13.4.5 Parameter initialization

Since the objective function for DNN training is non-convex, the way that we initialize the parameters of a DNN can play a big role on what kind of solution we end up with, as well as how easy the function is to train (i.e., how well information can flow forwards and backwards through the model). In the rest of this section, we present some common heuristic methods that are used for initializing parameters.

# 13.4.5.1 Heuristic initialization schemes

In [GB10], they show that sampling parameters from a standard normal with fixed variance can result in exploding activations or gradients. To see why, consider a linear unit with no activation function given by $\begin{array} { r } { o _ { i } = \sum _ { j = 1 } ^ { n _ { \mathrm { i n } } } w _ { i j } x _ { j } } \end{array}$ ; suppose $w _ { i j } \sim \mathcal { N } ( 0 , \sigma ^ { 2 } )$ , and $\mathbb { E } \left[ x _ { j } \right] = 0$ and $\mathbb { V } \left[ x _ { j } \right] = \gamma ^ { 2 }$ , where we assume $x _ { j }$ are independent of $w _ { i j }$ . The mean and variance of the output is given by

$$
\begin{array} { l l l } & { \displaystyle \mathbb { E } \left[ o _ { i } \right] = \sum _ { j = 1 } ^ { n _ { \mathrm { i n } } } \mathbb { E } \left[ w _ { i j } x _ { j } \right] = \sum _ { j = 1 } ^ { n _ { \mathrm { i n } } } \mathbb { E } \left[ w _ { i j } \right] \mathbb { E } \left[ x _ { j } \right] = 0 } \\ & { \displaystyle \mathbb { V } \left[ o _ { i } \right] = \mathbb { E } \left[ o _ { i } ^ { 2 } \right] - \left( \mathbb { E } \left[ o _ { i } \right] \right) ^ { 2 } = \sum _ { j = 1 } ^ { n _ { \mathrm { i n } } } \mathbb { E } \left[ w _ { i j } ^ { 2 } x _ { j } ^ { 2 } \right] - 0 = \sum _ { j = 1 } ^ { n _ { \mathrm { i n } } } \mathbb { E } \left[ w _ { i j } ^ { 2 } \right] \mathbb { E } \left[ x _ { j } ^ { 2 } \right] = n _ { \mathrm { i n } } \sigma ^ { 2 } \gamma ^ { 2 } } \end{array}
$$

To keep the output variance from blowing up, we need to ensure $n _ { \mathrm { i n } } \sigma ^ { 2 } = 1$ (or some other constant), where $n _ { \mathrm { i n } }$ is the fan-in of a unit (number of incoming connections).

Now consider the backwards pass. By analogous reasoning, we see that the variance of the gradients can blow up unless $n _ { \mathrm { o u t } } \sigma ^ { 2 } = 1$ , where $n _ { \mathrm { o u t } }$ is the fan-out of a unit (number of outgoing connections).

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

To satisfy both requirements at once, we set $\textstyle { \frac { 1 } { 2 } } ( n _ { \mathrm { i n } } + n _ { \mathrm { o u t } } ) \sigma ^ { 2 } = 1$ , or equivalently

$$
\sigma ^ { 2 } = \frac { 2 } { n _ { \mathrm { { i n } } } + n _ { \mathrm { { o u t } } } }
$$

This is known as Xavier initialization or Glorot initialization, named after the first author of [GB10].

A special case arises if we use $\sigma ^ { 2 } = 1 / n _ { \mathrm { i n } }$ ; this is known as LeCun initialization, named after Yann LeCun, who proposed it in the 1990s. This is equivalent to Glorot initialization when $r  { \mathrm { = } } \pi  { \mathrm { i n } } = r  { \mathrm { = } }  { \mathrm { i } _ { \mathrm { o u t } } }$ . If we use $\sigma ^ { 2 } = 2 / n _ { \mathrm { i n } }$ , the method is called He initialization, named after Ximing He, who proposed it in [He+15].

Note that it is not necessary to use a Gaussian distribution. Indeed, the above derivation just worked in terms of the first two moments (mean and variance), and made no assumptions about Gaussianity. For example, suppose we sample weights from a uniform distribution, $w _ { i j } \sim \mathrm { U n i f } ( - a , a )$ . The mean is 0, and the variance is $\sigma ^ { 2 } = a ^ { 2 } / 3$ . Hence we should set $\begin{array} { r } { a = \sqrt { \frac { 6 } { n _ { \mathrm { i n } } + n _ { \mathrm { o u t } } } } } \end{array}$

Although the above derivation assumes a linear output unit, the technique works well empirically even for nonlinear units. The best choice of initialization method depends on which activation function you use. For linear, tanh, logistic, and softmax, Glorot is recommended. For ReLU and variants, He is recommended. For SELU, LeCun is recommended. See e.g., [Gér19] for more heuristics, and e.g., [HDR19] for some theory.

# 13.4.5.2 Data-driven initializations

We can also adopt a data-driven approach to parameter initialization. For example, [MM16] proposed a simple but effective scheme known as layer-sequential unit-variance (LSUV) initialization, which works as follows. First we initialize the weights of each (fully connected or convolutional) layer with orthonormal matrices, as proposed in [SMG14]. (This can be achieved by drawing from ${ \pmb w } \sim \mathcal { N } ( { \bf 0 } , { \bf I } )$ , reshaping to $\mathbf { \boldsymbol { w } }$ to a matrix $\mathbf { W }$ , and then computing an orthonormal basis using QR or SVD decomposition.) Then, for each layer $\it { l }$ , we compute the variance ${ \boldsymbol { v } } _ { l }$ of the activations across a minibatch; we then rescale using $\mathbf { W } _ { l } : = \mathbf { W } _ { l } / \sqrt { v _ { l } }$ . This scheme can be viewed as an orthonormal initialization combined with batch normalization performed only on the first mini-batch. This is faster than full batch normalization, but can sometimes work just as well.

# 13.4.6 Parallel training

It can be quite slow to train large models on large datasets. One way to speed this process up is to use specialized hardware, such as graphics processing units (GPUs) and tensor processing units (TPUs), which are very efficient at performing matrix-matrix multiplication. If we have multiple GPUs, we can sometimes further speed things up. There are two main approaches: model parallelism, in which we partition the model between machines, and data parallelism, in which each machine has its own copy of the model, and applies it to a different set of data.

Model parallelism can be quite complicated, since it requires tight communication between machines to ensure they compute the correct answer. We will not discuss this further. Data parallelism is generally much simpler, since it is embarassingly parallel. To use this to speed up training, at each training step $t$ , we do the following: 1) we partition the minibatch across the $K$ machines to get $\mathcal { D } _ { t } ^ { k }$ ; 2) each machine $k$ computes its own gradient, $\pmb { g } _ { t } ^ { k } = \nabla _ { \pmb { \theta } } \mathcal { L } ( \pmb { \theta } ; \mathcal { D } _ { t } ^ { k } ) ; 3$ ) we collect all the local gradients

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license on a central machine (e.g., device $0$ ) and sum them using $\begin{array} { r } { \pmb { g } _ { t } = \sum _ { k = 1 } ^ { K } \pmb { g } _ { t } ^ { k } ; } \end{array}$ 4) we broadcast the summed gradient back to all devices, so $\tilde { \pmb { g } } _ { t } ^ { k } = \pmb { g } _ { t }$ ; 5) each machine updates its own copy of the parameters using $\pmb { \theta } _ { t } ^ { k } : = \pmb { \theta } _ { t } ^ { k } - \eta _ { t } \tilde { \pmb { g } } _ { t } ^ { k }$ . See Figure 13.16 for an illustration and multi_gpu_training_jax.ipynb for some sample code.

![](images/4d080c25871a836bebded7c4680b6c4ecef9ade4c640ef792af71414bd407b97.jpg)  
Figure 13.16: Calculation of minibatch stochastic gradient using data parallelism and two GPUs. From Figure 12.5.2 of [Zha+20]. Used with kind permission of Aston Zhang.

Note that steps 3 and 4 are usually combined into one atomic step; this is known as an all-reduce operation (where we use sum to reduce the set of (gradient) vectors into one). If each machine blocks until receiving the centrally aggregated gradient, $\mathbf { \nabla } _ { \mathbf { \boldsymbol { \mathcal { G } } } t }$ , the method is known as synchronous training. This will give the same results as training with one machine (with a larger batchsize), only faster (assuming we ignore any batch normalization layers). If we let each machine update its parameters using its own local gradient estimate, and not wait for the broadcast to/from the other machines, the method is called asynchronous training. This is not guaranteed to work, since the different machines may get out of step, and hence will be updating different versions of the parameters; this approach has therefore been called hogwild training [Niu+11]. However, if the updates are sparse, so each machine “touches” a different part of the parameter vector, one can prove that hogwild training behaves like standard synchronous SGD.

# 13.5 Regularization

In Section 13.4 we discussed computational issues associated with training (large) neural networks. In this section, we discuss statistical issues. In particular, we focus on ways to avoid overfitting. This is crucial, since large neural networks can easily have millions of parameters.

# 13.5.1 Early stopping

Perhaps the simplest way to prevent overfitting is called early stopping, which refers to the heuristic of stopping the training procedure when the error on the validation set starts to increase (see Figure 4.8 for an example). This method works because we are restricting the ability of the optimization algorithm to transfer information from the training examples to the parameters, as explained in [AS19].

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

![](images/db6c0ae18747ef0b80ddebb289a2c54d87f161c144590881ad881b07c05d4173.jpg)  
Figure 13.17: (a) A deep but sparse neural network. The connections are pruned using $\ell _ { 1 }$ regularization. At each level, nodes numbered 0 are clamped to 1, so their outgoing weights correspond to the offset/bias terms. (b) Predictions made by the model on the training set. Generated by sparse_mlp.ipynb.

# 13.5.2 Weight decay

A common approach to reduce overfitting is to impose a prior on the parameters, and then use MAP estimation. It is standard to use a Gaussian prior for the weights $\mathcal { N } ( \boldsymbol { \mathbf { \mathit { w } } } | \mathbf { \mathbf { 0 } } , \alpha ^ { 2 } \mathbf { I } )$ and biases, $\mathcal { N } ( b | \mathbf { 0 } , \beta ^ { 2 } \mathbf { I } )$ . This is equivalent to $\ell _ { 2 }$ regularization of the objective. In the neural networks literature, this is called weight decay, since it encourages small weights, and hence simpler models, as in ridge regression (Section 11.3).

# 13.5.3 Sparse DNNs

Since there are many weights in a neural network, it is often helpful to encourage sparsity. This allows us to perform model compression, which can save memory and time. To do this, we can use $\ell _ { 1 }$ regularization (as in Section 11.4), or ARD (as in Section 11.7.7), or several other methods (see e.g., [Hoe+21; Bha+20] for recent reviews). As a simple example, Figure 13.17 shows a 5 layer MLP which has been fit to some 1d regression data using an $\ell _ { 1 }$ regularizer on the weights. We see that the resulting graph topology is sparse.

Despite the intuitive appeal of sparse topology, in practice these methods are not widely used, since modern GPUs are optimized for dense matrix multiplication, and there are few computational benefits to sparse weight matrices. However, if we use methods that encourage group sparsity, we can prune out whole layers of the model. This results in block sparse weight matrices, which can result in speedups and memory savings (see e.g., [Sca+17; Wen+16; MAV17; LUW17]).

# 13.5.4 Dropout

Suppose that we randomly (on a per-example basis) turn off all the outgoing connections from each neuron with probability $p$ , as illustrated in Figure 13.18. This technique is known as dropout [Sri+14].

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

![](images/529815378654650d6dcf428ff1cb8e9f7aa08e64b524d89b86bdd61a9b3371d2.jpg)  
Figure 13.18: Illustration of dropout. (a) $A$ standard neural net with 2 hidden layers. (b) An example of a thinned net produced by applying dropout with $p _ { 0 } = 0 . 5$ . Units that have been dropped out are marked with an x. From Figure 1 of [Sri+14]. Used with kind permission of Geoff Hinton.

Dropout can dramatically reduce overfitting and is very widely used. Intuitively, the reason dropout works well is that it prevents complex co-adaptation of the hidden units. In other words, each unit must learn to perform well even if some of the other units are missing at random. This prevents the units from learning complex, but fragile, dependencies on each other.5 A more formal explanation, in terms of Gaussian scale mixture priors, can be found in [NHLS19].

We can view dropout as estimating a noisy version of the weights, $\begin{array} { r } { \theta _ { l i j } = w _ { l i j } \epsilon _ { l i } } \end{array}$ , where $\epsilon _ { l i } \sim$ $\operatorname { B e r } ( 1 - p )$ is a Bernoulli noise term. (So if we sample $\epsilon _ { l i } = 0$ , then all of the weights going out of unit $i$ in layer ${ \mathit { l } } - 1$ into any $j$ in layer $\it l$ will be set to 0.) At test time, we usually turn the noise off. To ensure the weights have the same expectation at test time as they did during training (so the input activation to the neurons is the same, on average), at test time we should use $w _ { l i j } = \theta _ { l i j } \mathbb { E } \left[ \epsilon _ { l i } \right]$ . For Bernoulli noise, we have $\mathbb { E } \left[ \epsilon \right] = 1 - p$ , so we should multiply the weights by the keep probability, $1 - p$ , before making predictions.

We can, however, use dropout at test time if we wish. The result is an ensemble of networks, each with slightly different sparse graph structures. This is called Monte Carlo dropout [GG16; KG17], and has the form

$$
p ( \pmb { y } | \pmb { x } , \mathcal { D } ) \approx \frac { 1 } { S } \sum _ { s = 1 } ^ { S } p ( \pmb { y } | \pmb { x } , \hat { \mathbf { W } } \epsilon ^ { s } + \hat { \pmb { b } } )
$$

where $S$ is the number of samples, and we write $\hat { \mathbf { W } } \epsilon ^ { s }$ to indicate that we are multiplying all the estimated weight matrices by a sampled noise vector. This can sometimes provide a good approximation to the Bayesian posterior predictive distribution $p ( \pmb { y } | \pmb { x } , \mathcal { D } )$ , especially if the noise rate is optimized [GHK17].

![](images/67e06f3a0087c2a4f3c9af2be1372a9820543367f4189ef63ef0fe9d23762ee7.jpg)  
Figure 13.19: Flat vs sharp minima. From Figures 1 and 2 of [HS97a]. Used with kind permission of Jürgen Schmidhuber.

# 13.5.5 Bayesian neural networks

Modern DNNs are usually trained using a (penalized) maximum likelihood objective to find a single setting of parameters. However, with large models, there are often many more parameters than data points, so there may be multiple possible models which fit the training data equally well, yet which generalize in different ways. It is often useful to capture the induced uncertainty in the posterior predictive distribution. This can be done by marginalizing out the parameters by computing

$$
p ( \pmb { y } | \pmb { x } , \mathcal { D } ) = \int p ( \pmb { y } | \pmb { x } , \pmb { \theta } ) p ( \pmb { \theta } | \mathcal { D } ) d \pmb { \theta }
$$

The result is known as a Bayesian neural network or BNN. It can be thought of as an infinite ensemble of differently weight neural networks. By marginalizing out the parameters, we can avoid overfitting [Mac95]. Bayesian marginalization is challenging for large neural networks, but also can lead to significant performance gains [WI20]. For more details on the topic of Bayesian deep learning, see the sequel to this book, [Mur23].

# 13.5.6 Regularization effects of (stochastic) gradient descent \*

Some optimization methods (in particular, second-order batch methods) are able to find “needles in haystacks”, corresponding to narrow but deep “holes” in the loss landscape, corresponding to parameter settings with very low loss. These are known as sharp minima, see Figure 13.19(right). From the point of view of minimizing the empirical loss, the optimizer has done a good job. However, such solutions generally correspond to a model that has overfit the data. It is better to find points that correspond to flat minima, as shown in Figure 13.19(left); such solutions are more robust and generalize better. To see why, note that flat minima correspond to regions in parameter space where there is a lot of posterior uncertainty, and hence samples from this region are less able to precisely memorize irrelevant details about the training set [AS17]. SGD often finds such flat minima by virtue of the addition of noise, which prevents it from “entering” narrow regions of the loss landscape (see e.g., [SL18]). This is called implicit regularization. It is also possible to explicitly encourage SGD to find such flat minima, using entropy SGD [Cha+17], sharpness aware minimization [For+21], stochastic weight averaging (SWA) [Izm+18], and other related techniques.

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

![](images/b6cf999e822d23d67249135053f1415368b7643915e2fa4e8c83944f0f3ae735.jpg)  
Figure 13.20: Each curve shows how the loss varies across parameter values for a given minibatch. (a) A stable local minimum. (b) An unstable local minimum. Generated by sgd_minima_variance.ipynb. Adapted from https: // bit. ly/ 3wTc1L6 .

Of course, the loss landscape depends not just on the parameter values, but also on the data. Since we usually cannot afford to do full-batch gradient descent, we will get a set of loss curves, one per minibatch. If each one of these curves corresponds to a wide basin, as shown in Figure 13.20a, we are at a point in parameter space that is robust to perturbations, and will likely generalize well. However, if the overall wide basin is the result of averaging over many different narrow basins, as shown in Figure 13.20b, the resulting estimate will likely generalize less well.

This can be formalized using the analysis in [Smi+21; BD21]. Specifically, they consider continuous time gradient flow which approximates the behavior of (S)GD. In [BD21], they consider full-batch GD, and show that the flow has the form $\pmb { \dot { w } } = - \nabla _ { \pmb { w } } \mathcal { \bar { L } } _ { G D } ( \pmb { w } )$ , where

$$
\tilde { \mathcal { L } } _ { G D } ( { \mathbf { \boldsymbol { w } } } ) = \mathcal { L } ( { \mathbf { \boldsymbol { w } } } ) + \frac { \epsilon } { 4 } | | \nabla \mathcal { L } ( { \mathbf { \boldsymbol { w } } } ) | | ^ { 2 }
$$

where $\mathcal { L } ( w )$ is the original loss, $\epsilon$ is the learning rate, and the second term is an implicit regularization term that penalizes solutions with large gradients (high curvature).

In [Smi+21], they extend this analysis to the SGD case. They show that the flow has the form $\begin{array} { r } { \dot { \pmb w } = - \nabla _ { \pmb w } \dot { \mathcal { L } } _ { S G D } ( \pmb w ) } \end{array}$ , where

$$
\tilde { \mathcal { L } } _ { S G D } ( \pmb { w } ) = \mathcal { L } ( \pmb { w } ) + \frac { \epsilon } { 4 } \sum _ { k = 1 } ^ { m } | | \nabla \mathcal { L } _ { k } ( \pmb { w } ) | | ^ { 2 }
$$

where $m$ is the number of minibatches, and $\mathcal { L } _ { k } ( w )$ is the loss on the $k$ ’th such minibatch. Comparing this to the full-batch GD loss, we see

$$
\tilde { \mathcal { L } } _ { S G D } ( \boldsymbol { w } ) = \tilde { \mathcal { L } } _ { G D } ( \boldsymbol { w } ) + \frac { \epsilon } { 4 } \sum _ { k = 1 } ^ { m } | | \nabla \mathcal { L } _ { k } ( \boldsymbol { w } ) - \mathcal { L } ( \boldsymbol { w } ) | | ^ { 2 }
$$

The second term estimates the variance of the minibatch gradients, which is a measure of stability, and hence of generalization ability.

The above analysis shows that SGD not only has computational advantages (since it is faster than full-batch GD or second-order methods), but also statistical advantages.

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

# 13.6 Other kinds of feedforward networks \*

# 13.6.1 Radial basis function networks

Consider a 1 layer neural net where the hidden layer is given by the feature vector

$$
\pmb { \phi } ( \pmb { x } ) = [ \mathcal { K } ( \pmb { x } , \pmb { \mu } _ { 1 } ) , \dots , \mathcal { K } ( \pmb { x } , \pmb { \mu } _ { K } ) ]
$$

where $\pmb { \mu _ { k } } \in \mathcal X$ are a set of $K$ centroids or exemplars, and $\mathcal { K } ( { \pmb x } , { \pmb \mu } ) \ge 0$ is a kernel function. We describe kernel functions in detail in Section 17.1. Here we just give an example, namely the Gaussian kernel

$$
\mathcal { K } _ { \mathrm { g a u s s } } ( \pmb { x } , \pmb { c } ) \triangleq \exp \left( - \frac { 1 } { 2 \sigma ^ { 2 } } | | \pmb { c } - \pmb { x } | | _ { 2 } ^ { 2 } \right)
$$

The parameter $\sigma$ is known as the bandwidth of the kernel. Note that this kernel is shift invariant, meaning it is only a function of the distance $r = | | { \pmb x } - { \pmb c } | | _ { 2 }$ , so we can equivalently write this as

$$
\mathcal { K } _ { \mathrm { g a u s s } } ( r ) \triangleq \exp \left( - \frac { 1 } { 2 \sigma ^ { 2 } } r ^ { 2 } \right)
$$

This is therefore called a radial basis function kernel or RBF kernel.

A 1 layer neural net in which we use Equation (13.101) as the hidden layer, with RBF kernels, is called an RBF network [BL88]. This has the form

$$
p ( y | \mathbf { \boldsymbol { x } } ; \pmb { \theta } ) = p ( y | \mathbf { \boldsymbol { w } } ^ { \top } \phi ( \pmb { x } ) )
$$

where $\theta = ( \mu , w )$ . If the centroids $\pmb { \mu }$ are fixed, we can solve for the optimal weights $\mathbf { \boldsymbol { w } }$ using (regularized) least squares, as discussed in Chapter 11. If the centroids are unknown, we can estimate them by using an unsupervised clustering method, such as K-means (Section 21.3). Alternatively, we can associate one centroid per data point in the training set, to get ${ \pmb { \mu } } _ { n } = { \pmb x } _ { n }$ , where now $K = N$ . This is an example of a non-parametric model, since the number of parameters grows (in this case linearly) with the amount of data, and is not independent of $N$ . If $K = N$ , the model can perfectly interpolate the data, and hence may overfit. However, by ensuring that the output weight vector $\mathbf { \boldsymbol { w } }$ is sparse, the model will only use a finite subset of the input examples; this is called a sparse kernel machine, and will be discussed in more detail in Section 17.4.1 and Section 17.3. Another way to avoid overfitting is to adopt a Bayesian approach, by integrating out the weights $\mathbf { \boldsymbol { w } }$ ; this gives rise to a model called a Gaussian process, which will be discussed in more detail in Section 17.2.

# 13.6.1.1 RBF network for regression

We can use RBF networks for regression by defining $p ( y | \mathbf { x } , \pmb { \theta } ) = \mathcal { N } ( \pmb { w } ^ { T } \mathbf { \phi } ( \mathbf { x } ) , \sigma ^ { 2 } )$ . For example, Figure 13.22 shows a 1d data set fit with $K = 1 0$ uniformly spaced RBF prototypes, but with the bandwidth ranging from small to large. Small values lead to very wiggly functions, since the predicted function value will only be non-zero for points $_ { x }$ that are close to one of the prototypes $\pmb { \mu } _ { k }$ . If the bandwidth is very large, the design matrix reduces to a constant matrix of 1’s, since each point is equally close to every prototype; hence the corresponding function is just a straight line.

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

![](images/427b7cbd27e2825228ab44b7e6e2eaaa13c45be4d0bf01ff09364e994f27cbf0.jpg)  
Figure 13.21: (a) xor truth table. (b) Fitting a linear logistic regression classifier using degree 10 polynomial expansion. (c) Same model, but using an RBF kernel with centroids specified by the 4 black crosses. Generated by logregXorDemo.ipynb.

# 13.6.1.2 RBF network for classification

We can use RBF networks for binary classification by defining $p ( \boldsymbol { y } | \mathbf { \boldsymbol { x } } , \pmb { \theta } ) = \mathrm { B e r } \big ( \sigma ( \mathbf { \boldsymbol { w } } ^ { T } \boldsymbol { \phi } ( \mathbf { \boldsymbol { x } } ) ) \big )$ . As an example, consider the data coming from the exclusive or function. This is a binary-valued function of two binary inputs. Its truth table is shown in Figure 13.21(a). In Figure 13.21(b), we have shown some data labeled by the xor function, but we have jittered the points to make the picture clearer.6 We see we cannot separate the data even using a degree 10 polynomial. However, using an RBF kernel and just 4 prototypes easily solves the problem as shown in Figure 13.21(c).

# 13.6.2 Mixtures of experts

When considering regression problems, it is common to assume a unimodal output distribution, such as a Gaussian or Student distribution, where the mean and variance is some function of the input, i.e.,

$$
p ( { \pmb y } | { \pmb x } ) = \mathcal { N } ( { \pmb y } | f _ { \mu } ( { \pmb x } ) , \mathrm { d i a g } ( \sigma _ { + } ( f _ { \sigma } ( { \pmb x } ) ) ) )
$$

where the $f$ functions may be MLPs (possibly with some shared hidden units, as in Figure 13.5). However, this will not work well for one-to-many functions, in which each input can have multiple possible outputs.

Figure 13.23a gives a simple example of such a function. We see that in the middle of the plot there are certain $x$ values for which there are two equally probable $y$ values. There are many real world problems of this form, e.g., 3d pose prediction of a person from a single image [Bo+08], colorization of a black and white image [Gua+17], predicting future frames of a video sequence [VT17], etc. Any model which is trained to maximize likelihood using a unimodal output density — even if the model is a flexible nonlinear model, such as neural network — will work poorly on one-to-many functions such as these, since it will just produce a blurry average output.

![](images/a4e4fd067f88b763f1454e35791d7a167d3d9c9b79a3712619f2af75307a092a.jpg)  
Figure 13.22: Linear regression using 10 equally spaced RBF basis functions in 1d. Left column: fitted function. Middle column: basis functions evaluated on a grid. Right column: design matrix. Top to bottom we show different bandwidths for the kernel function: $\sigma = 0 . 5 , 1 0 , 5 0$ . Generated by linregRbfDemo.ipynb.

To prevent this problem of regression to the mean, we can use a conditional mixture model. That is, we assume the output is a weighted mixture of $K$ different outputs, corresponding to different modes of the output distribution for each input $_ { x }$ . In the Gaussian case, this becomes

$$
\begin{array} { c l c r } { { \displaystyle p ( { \pmb y } | { \pmb x } ) = \sum _ { k = 1 } ^ { K } p ( { \pmb y } | { \pmb x } , { \boldsymbol z } = k ) p ( { \boldsymbol z } = k | { \pmb x } ) } } \\ { { \displaystyle p ( { \pmb y } | { \pmb x } , { \boldsymbol z } = k ) = \mathcal { N } ( { \pmb y } | f _ { \mu , k } ( { \pmb x } ) , \mathrm { d i a g } ( f _ { \sigma , k } ( { \pmb x } ) ) ) } } \\ { { \displaystyle p ( { \boldsymbol z } = k | { \pmb x } ) = \mathrm { C a t } ( { \boldsymbol z } | \mathrm { s o f t m a x } ( f _ { \boldsymbol z } ( { \pmb x } ) ) ) } } \end{array}
$$

Here $f _ { \mu , k }$ predicts the mean of the $k$ ’th Gaussian, $f _ { \sigma , k }$ predicts its variance terms, and $f _ { z }$ predicts which mixture component to use. This model is called a mixture of experts (MoE) [Jac+91; JJ94; YWG12; ME14]. The idea is that the $k$ ’th submodel $p ( { \pmb y } | { \pmb x } , z = k )$ is considered to be an “expert” in a certain region of input space. The function $p ( z = k | \pmb { x } )$ is called a gating function, and decides which expert to use, depending on the input values. By picking the most likely expert for a given input $_ { x }$ , we can “activate” just a subset of the model. This is an example of conditional computation, since we decide what expert to run based on the results of earlier computations from the gating network [Sha+17].

We can train this model using SGD, or using the EM algorithm (see Section 8.7.3 for details on the latter method).

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

![](images/9a6df3b7d974381ecab5dde09ae2438c4e9500119b9b3f1729982a80df1e2647.jpg)  
Figure 13.23: (a) Some data from a one-to-many function. Horizontal axis is the input $x$ , vertical axis is the target $y = f ( x )$ . (b) The responsibilities of each expert for the input domain. (c) Prediction of each expert (colored lines) superimposed on the training data. (d) Overall prediction. Mean is red cross, mode is black square. Adapted from Figures 5.20 and 5.21 of [Bis06]. Generated by mixexpDemoOneToMany.ipynb.

# 13.6.2.1 Mixture of linear experts

In this section, we consider a simple example in which we use linear regression experts and a linear classification gating function, i.e., the model has the form:

$$
\begin{array} { r l } & { p ( \boldsymbol { y } | \boldsymbol { \mathbf { x } } , \boldsymbol { z } = k , \pmb { \theta } ) = \mathcal { N } ( \boldsymbol { y } | \boldsymbol { w } _ { k } ^ { \top } \boldsymbol { x } , \sigma _ { k } ^ { 2 } ) } \\ & { \quad p ( \boldsymbol { z } = k | \boldsymbol { x } , \pmb { \theta } ) = \mathrm { C a t } ( \boldsymbol { z } | \mathrm { s o f t m a x } _ { k } ( \boldsymbol { \mathbf { V } } \pmb { x } ) ) } \end{array}
$$

where softmax $k$ is the $k$ ’th output from the softmax function. The individual weighting term $p ( z = k | \pmb { x } )$ is called the responsibility for expert $k$ for input $_ { x }$ . In Figure 13.23b, we see how the gating networks softly partitions the input space amongst the $K = 3$ experts.

Each expert $p ( y | \mathbf { \boldsymbol { x } } , z = k )$ corresponds to a linear regression model with different parameters. These are shown in Figure 13.23c.

If we take a weighted combination of the experts as our output, we get the red curve in Figure 13.23a, which is clearly is a bad predictor. If instead we only predict using the most active expert (i.e., the one with the highest responsibility), we get the discontinuous black curve, which is a much better predictor.

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

![](images/e14dba8194bec31fc76536f0687d3e34d55258869232442d226a5aeef52dd90d.jpg)  
Figure 13.24: Deep MOE with m experts, represented as a neural network. From Figure 1 of [CGG17]. Used with kind permission of Jacob Goldberger.

# 13.6.2.2 Mixture density networks

The gating function and experts can be any kind of conditional probabilistic model, not just a linear model. If we make them both DNNs, then resulting model is called a mixture density network (MDN) [Bis94; ZS14] or a deep mixture of experts [CGG17]. See Figure 13.24 for a sketch of the model.

# 13.6.2.3 Hierarchical MOEs

If each expert is itself an MoE model, the resulting model is called a hierarchical mixture of experts [JJ94]. See Figure 13.25 for an illustration of such a model with a two level hierarchy.

An HME with $L$ levels can be thought of as a “soft” decision tree of depth $L$ , where each example is passed through every branch of the tree, and the final prediction is a weighted average. (We discuss decision trees in Section 18.1.)

# 13.7 Exercises

Exercise 13.1 [Backpropagation for a MLP]

(Based on an exercise by Kevin Clark.)

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

![](images/a9d64a79f462128c028f68c756ab5f0e3392ea7948d5709efd2f6b78ecade8ff.jpg)  
Figure 13.25: A 2-level hierarchical mixture of experts as a neural network. The top gating network chooses between the left and right expert, shown by the large boxes; the left and right experts themselves choose between their left and right sub-experts.

Consider the following classification MLP with one hidden layer:

$$
\begin{array} { r l } & { x = \mathrm { i n p u t } \in \mathbb { R } ^ { D } } \\ & { z = \mathbf { W } x + b _ { 1 } \in \mathbb { R } ^ { K } } \\ & { h = \mathrm { R e L U } ( z ) \in \mathbb { R } ^ { K } } \\ & { a = \mathbf { V } h + b _ { 2 } \in \mathbb { R } ^ { C } } \\ & { \mathcal { L } = \mathrm { C r o s s E n t r o p y } ( y , \mathrm { s o f t m a x } ( a ) ) \in \mathbb { R } } \end{array}
$$

where $\pmb { x } \in \mathbb { R } ^ { D }$ , $\pmb { b } _ { 1 } \in \mathbb { R } ^ { K }$ , $\mathbf { W } \in \mathbb { R } ^ { K \times D }$ , $\pmb { b } _ { 2 } \in \mathbb { R } ^ { C }$ , $\mathbf { V } \in \mathbb { R } ^ { C \times K }$ , where $\mathcal { D }$ is the size of the input, $K$ is the number of hidden units, and $C$ is the number of classes. Show that the gradients for the parameters and input are as follows:

$$
\begin{array} { r l } & { \mathrm { V w } \mathscr { L } = \left[ \frac { \partial \mathscr { L } } { \partial \mathbf { V } } \right] _ { 1 , : } = u _ { 2 } h ^ { \top } \in \mathbb { R } ^ { C \times K } } \\ & { \mathrm { V } _ { b _ { 2 } } \mathscr { L } = \left( \frac { \partial \mathscr { L } } { \partial b _ { 2 } } \right) ^ { \top } = u _ { 2 } \in \mathbb { R } ^ { C } } \\ & { \mathrm { V w } \mathscr { L } = \left[ \frac { \partial \mathscr { L } } { \partial \mathbf { V } } \right] _ { 1 , : } = u _ { 1 } x ^ { \top } \in \mathbb { R } ^ { K \times D } } \\ & { \mathrm { V } _ { b _ { 1 } } \mathscr { L } = \left( \frac { \partial \mathscr { L } } { \partial b _ { 1 } } \right) ^ { \top } = u _ { 1 } \in \mathbb { R } ^ { K } } \\ & { \mathrm { V } _ { a } \mathscr { L } = \left( \frac { \partial \mathscr { L } } { \partial x } \right) ^ { \top } = \mathbf { W } ^ { \top } \ u _ { 1 } \in \mathbb { R } ^ { D } } \end{array}
$$

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

where the gradients of the loss wrt the two layers (logit and hidden) are given by the following:

$$
\begin{array} { l } { { \displaystyle { \pmb u } _ { 2 } = \nabla _ { \pmb a } { \mathcal L } = \left( \frac { \partial { \mathcal L } } { \partial \pmb a } \right) ^ { \top } = ( { \pmb p } - { \pmb y } ) \in \mathbb R ^ { C } } } \\ { ~ } \\ { { \displaystyle { \pmb u } _ { 1 } = \nabla _ { z } { \mathcal L } = \left( \frac { \partial { \mathcal L } } { \partial z } \right) ^ { \top } = ( { \bf V } ^ { \top } ~ { \pmb u } _ { 2 } ) \odot } H ( z ) \in \mathbb R ^ { K } }  \end{array}
$$

with $H$ is the Heaviside function. Note that, in our notation, the gradient (which has the same shape as the variable with respect to which we differentiate) is equal to the Jacobian’s transpose when the variable is a vector and to the first slice of the Jacobian when the variable is a matrix.

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

# 14 Neural Networks for Images

# 14.1 Introduction

In Chapter 13, we discussed multilayered perceptrons (MLPs) as a way to learn functions mapping “unstructured” input vectors $\pmb { x } \in \mathbb { R } ^ { D }$ to outputs. In this chapter, we extend this to the case where the input $_ { x }$ has 2d spatial structure. (Similar ideas apply to 1d temporal structure, or 3d spatio-temporal structure.)

To see why it is not a good idea to apply MLPs directly to image data, recall that the core operation in an MLP at each hidden layer is computing the activations $z = \varphi ( \mathbf { W } \mathbf { x } )$ , where $_ { x }$ is the input to a layer, W are the weights, and $\varphi ( )$ is the nonlinear activation function. Thus the $j$ ’th element of the hidden layer has value $z _ { j } = \varphi ( w _ { j } ^ { 1 } \pmb { x } )$ . We can think of this inner product operation as comparing the input $_ { x }$ to a learned template or pattern ${ \pmb w } _ { j }$ ; if the match is good (large positive inner product), the activation of that unit will be large (assuming a ReLU nonlinearity), signalling that the $j$ ’th pattern is present in the input.

However, this does not work well if the input is a variable-sized image, $\pmb { x } \in \mathbb { R } ^ { W H C }$ , where $W$ is the width, $H$ is the height, and $C$ is the number of input channels (e.g., $C = 3$ for RGB color). The problem is that we would need to learn a different-sized weight matrix $\mathbf { W }$ for every size of input image. In addition, even if the input was fixed size, the number of parameters needed would be prohibitive for reasonably sized images, since the weight matrix would have size $( W \times H \times C ) \times D$ , where $D$ is the number of outputs (hidden units). The final problem is that a pattern that occurs in one location may not be recognized when it occurs in a different location — that is, the model may not exhibit translation invariance — because the weights are not shared across locations (see Figure 14.1).

To solve these problems, we will use convolutional neural networks (CNNs), in which we replace matrix multiplication with a convolution operation. We explain this in detail in Section 14.2, but the basic idea is to divide the input into overlapping 2d image patches, and to compare each patch with a set of small weight matrices, or filters, which represent parts of an object; this is illustrated in Figure 14.2. We can think of this as a form of template matching. We will learn these templates from data, as we explain below. Because the templates are small (often just 3x3 or 5x5), the number of parameters is significantly reduced. And because we use convolution to do the template matching, instead of matrix multiplication, the model will be translationally invariant. This is useful for tasks such as image classification, where the goal is to classify if an object is present, regardless of its location.

CNNs have many other applications besides image classification, as we will discuss later in this chapter. They can also be applied to 1d inputs (see Section 15.3) and 3d inputs; however, we mostly

![](images/868c2a60d0b1682e2bc1105b61f73b5df709e7ac3f34c2dad343382330f119a0.jpg)  
Figure 14.1: Detecting patterns in 2d images using unstructured MLPs does not work well, because the method is not translation invariant. We can design a weight vector to act as a matched filter for detecting the desired cross-shape. This will give a strong response of 5 if the object is on the left, but a weak response of 1 if the object is shifted over to the right. Adapted from Figure 7.16 of [SAV20].

![](images/72c008888198a82c602c448ceb23ca78fd7fbc68b385294f885e10d151566b5e.jpg)  
Figure 14.2: We can classify a digit by looking for certain discriminative features (image templates) occuring in the correct (relative) locations. From Figure 5.1 of [Cho17]. Used with kind permission of Francois Chollet.

focus on the 2d case in this chapter.

# 14.2 Common layers

In this section, we discuss the basics of CNNs.

# 14.2.1 Convolutional layers

We start by describing the basics of convolution in 1d, and then in 2d, and then describe how they are used as a key component of CNNs.

# 14.2.1.1 Convolution in 1d

The convolution between two functions, say $f , g : \mathbb { R } ^ { D }  \mathbb { R }$ , is defined as

$$
[ f \circledast g ] ( z ) = \int _ { \mathbb { R } ^ { D } } f ( \pmb { u } ) g ( z - \pmb { u } ) d \pmb { u }
$$

Now suppose we replace the functions with finite-length vectors, which we can think of as functions defined on a finite set of points. For example, suppose $f$ is evaluated at the points $\{ - L , - L +$

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

<html><body><table><tr><td></td><td>1</td><td>1</td><td>2</td><td>3</td><td>4</td><td></td><td></td><td></td></tr><tr><td>7</td><td>6</td><td>5</td><td>1</td><td>1</td><td></td><td></td><td></td><td>20=xowo=5</td></tr><tr><td></td><td>7</td><td>6</td><td>5</td><td></td><td>1</td><td></td><td></td><td>z1= xow1+x1wo=16</td></tr><tr><td></td><td></td><td>7</td><td>6</td><td>5</td><td></td><td></td><td></td><td>22 = xoW2+x1wi +x2wo =34</td></tr><tr><td></td><td></td><td>=</td><td>7</td><td>6</td><td>5</td><td>=</td><td>1</td><td>Z3 = x1W2+x2w1 +x3Wo =52</td></tr><tr><td></td><td></td><td></td><td>=</td><td>7</td><td>6</td><td>5</td><td>1</td><td>24 = x2W2 +x3W1 = 45</td></tr><tr><td></td><td></td><td></td><td>1</td><td></td><td>7</td><td>6</td><td>5</td><td>25 = x3W2 = 28</td></tr></table></body></html>

Figure 14.3: Discrete convolution of $\pmb { x } = [ 1 , 2 , 3 , 4 ]$ with $\pmb { w } = [ 5 , 6 , 7 ]$ to yield $\boldsymbol { z } = [ 5 , 1 6 , 3 4 , 5 2 , 4 5 , 2 8 ]$ . We see that this operation consists of “flipping” $\textbf { \em w }$ and then “dragging” it over $\textbf { \em x }$ , multiplying elementwise, and adding up the results.

![](images/b7ad39543caf6df6e7ac692be5efa77e34b9c86770915444389b0bd5ab7cf971.jpg)  
Figure 14.4: 1d cross correlation. From Figure 15.3.2 of [Zha+20]. Used with kind permission of Aston Zhang.

as

$1 , \ldots , 0 , 1 , \ldots , L \}$ to yield the weight vector (also called a filter or kernel) $w _ { - L } = f ( - L )$ up to $w _ { L } = f ( L )$ . Now let $g$ be evaluated at points $\{ - N , \ldots , N \}$ to yield the feature vector $x _ { - N } = g ( - N )$ up to $x _ { N } = g ( N )$ . Then the above equation becomes

$$
[ { \pmb w } \circledast { \pmb x } ] ( i ) = { w } _ { - L } { x } _ { i + L } + \cdot \cdot \cdot + { w } _ { - 1 } { x } _ { i + 1 } + { w } _ { 0 } { x } _ { i } + { w } _ { 1 } { x } _ { i - 1 } + \cdot \cdot \cdot + { w } _ { L } { x } _ { i - L }
$$

(We discuss boundary conditions (edge effects) later on.) We see that we “flip” the weight vector $\mathbf { \Delta } _ { \mathbf { w } }$ + (since indices of $\mathbf { \boldsymbol { w } }$ are reversed), and then “drag” it over the $_ { x }$ vector, summing up the local windows at each point, as illustrated in Figure 14.3.

There is a very closely related operation, in which we do not flip $\mathbf { \boldsymbol { w } }$ first:

$$
[ { \pmb w } * { \pmb x } ] ( i ) = w _ { - L } x _ { i - L } + \cdot \cdot \cdot + w _ { - 1 } x _ { i - 1 } + w _ { 0 } x _ { i } + w _ { 1 } x _ { i + 1 } + \cdot \cdot \cdot + w _ { L } x _ { i + L }
$$

This is called cross correlation; If the weight vector is symmetric, as is often the case, then cross correlation and convolution are the same. In the deep learning literature, the term “convolution” is usually used to mean cross correlation; we will follow this convention.

We can also evaluate the weights $\mathbf { \boldsymbol { w } }$ on domain $\{ 0 , 1 , \ldots , L - 1 \}$ and the features $_ { x }$ on domain $\{ 0 , 1 , \ldots , N - 1 \}$ , to eliminate negative indices. Then the above equation becomes

$$
[ { \pmb w } \circledast { \pmb x } ] ( i ) = \sum _ { u = 0 } ^ { L - 1 } w _ { u } x _ { i + u }
$$

See Figure 14.4 for an example.

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

![](images/e5586ea3852ae6c82087d57deca0ea4467c3789613e94a05347a31660c0780a6.jpg)  
Figure 14.5: Illustration of 2d cross correlation. Generated by conv2d_jax.ipynb. Adapted from Figure 6.2.1 of [Zha+20].

![](images/c6011ca62f39a23e0d65300dfbea4b562e4af75b010ad1082a6f1dcab7d2ed81.jpg)  
Figure 14.6: Convolving a 2d image (left) with a $3 \times 3$ filter (middle) produces a 2d response map (right). The bright spots of the response map correspond to locations in the image which contain diagonal lines sloping down and to the right. From Figure 5.3 of [Cho17]. Used with kind permission of Francois Chollet.

# 14.2.1.2 Convolution in 2d

In 2d, Equation (14.4) becomes

$$
[ \mathbf { W } \circledast \mathbf { X } ] ( i , j ) = \sum _ { u = 0 } ^ { H - 1 } \sum _ { v = 0 } ^ { W - 1 } w _ { u , v } x _ { i + u , j + v }
$$

where the 2d filter $\mathbf { W }$ has size $H \times W$ . For example, consider convolving a $3 \times 3$ input $\mathbf { X }$ with a $2 \times 2$ kernel $\mathbf { W }$ to compute a $2 \times 2$ output $\mathbf { Y }$ :

$$
{ \begin{array} { r l } { \mathbf { Y } = { \binom { w _ { 1 } } { w _ { 3 } } } \ \mathbf { \# } { \frac { x _ { 2 } } { x _ { 4 } } } \ \mathbf { \# } { \binom { x _ { 1 } } { x _ { 4 } } } \ \mathbf { \# } } & { } \\ { x _ { 7 } } & { } \\ { = \left( { \binom { w _ { 1 } x _ { 1 } + w _ { 2 } x _ { 2 } + w _ { 3 } x _ { 4 } + w _ { 4 } x _ { 5 } } { \binom { x _ { 1 } x _ { 4 } + w _ { 2 } x _ { 6 } + w _ { 3 } x _ { 5 } + w _ { 4 } x _ { 6 } } } } \right) \ \mathbf { \# } \left( w _ { 1 } x _ { 5 } + w _ { 2 } x _ { 6 } + w _ { 3 } x _ { 8 } + w _ { 4 } x _ { 9 } \right) } \\ & { } \end{array} }
$$

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

See Figure 14.5 for a visualization of this process.

We can think of 2d convolution as template matching, since the output at a point $( i , j )$ will be large if the corresponding image patch centered on $( i , j )$ is similar to $\mathbf { W }$ . If the template $\mathbf { W }$ corresponds to an oriented edge, then convolving with it will cause the output heat map to “light up” in regions that contain edges that match that orientation, as shown in Figure 14.6. More generally, we can think of convolution as a form of feature detection. The resulting output $\mathbf { Y } = \mathbf { W } \circledast \mathbf { X }$ is therefore called a feature map.

# 14.2.1.3 Convolution as matrix-vector multiplication

Since convolution is a linear operator, we can represent it by matrix multiplication. For example, consider Equation (14.7). We can rewrite this as matrix-vector mutiplication by flattening the 2d matrix $\mathbf { X }$ into a 1d vector $_ { x }$ , and multiplying by a Toeplitz-like matrix $\mathbf { C }$ derived from the kernel $\mathbf { W }$ , as follows:

$$
\begin{array}{c} \begin{array} { r l } & { y = \mathbf { C } x = ( \begin{array} { l l l l l l l } { w _ { 1 } } & { w _ { 2 } } & { 0 } & { | w _ { 3 } } & { w _ { 4 } } & { 0 } \\ { 0 } & { w _ { 1 } } & { w _ { 2 } } & { 0 } \\ { 0 } & { 0 } & { 0 } & { | w _ { 1 } } & { w _ { 2 } } & { 0 } \\ { 0 } & { 0 } & { 0 } & { | w _ { 1 } } & { w _ { 2 } } & { 0 } \\ { 0 } & { 0 } & { 0 } & { 0 } & { w _ { 1 } } & { w _ { 2 } } \end{array} | w _ { 3 } } & { w _ { 4 } } & { 0 } \\ { 0 } & { 0 } & { 0 } & { | \begin{array} { l l l l l } { w _ { 3 } } & { w _ { 3 } } & { w _ { 4 } } & { w _ { 5 } } \\ { 0 } & { w _ { 2 } } & { 0 } & { w _ { 3 } } & { w _ { 4 } } \end{array} | w _ { 4 } } & { 0 } \\ { 0 } & { 0 } & { 0 } & { w _ { 3 } } & { w _ { 5 } } \end{array} ) ( \begin{array} { l l l l } { x _ { 1 } } \\ { x _ { 2 } } \\ { x _ { 3 } } \\ { x _ { 4 } } \\ { x _ { 5 } } \\ { 0 } & { w _ { 3 } } & { w _ { 4 } } \end{array} ) ) ( \begin{array} { l } { x _ { 1 } } \\ { x _ { 2 } } \\ { x _ { 4 } } \\ { x _ { 5 } } \\ { x _ { 7 } } \\ { x _ { 8 } } \\ { x _ { 9 } } \end{array} )  \\ & { = ( \begin{array} { l } { w _ { 1 } x _ { 1 } + w _ { 2 } x _ { 2 } + w _ { 3 } x _ { 4 } + w _ { 4 } x _ { 5 } } \\ { w _ { 1 } x _ { 2 } + w _ { 2 } x _ { 3 } + w _ { 3 } x _ { 5 } + w _ { 4 } x _ { 6 } } \\ { w _ { 1 } x _ { 4 } + w _ { 2 } x _ { 9 } + w _ { 3 } x _ { 7 } + w _ { 4 } x _ { 8 } } \\ { w _ { 1 } x _ { 9 } + w _ { 2 } x _ { 9 } + w _ { 4 } x _ { 9 } } \\ { w _ { 1 } x _ { 9 } + w _ { 2 } x _ { 9 } + w _ { 3 } x _ { 9 } + w _ { 4 } x _ { 9 } } \\ { w _ { 1 } x _ { 9 } + w _ { 2 } x _ { 9 } + w _ { 3 } x _ { 9 } } \end{array} ) } \end{array}
$$

We can recover the $2 \times 2$ output by reshaping the $4 \times 1$ vector $\pmb { y }$ back to $\mathbf { Y }$ .1

Thus we see that CNNs are like MLPs where the weight matrices have a special sparse structure, and the elements are tied across spatial locations. This implements the idea of translation invariance, and massively reduces the number of parameters compared to a weight matrix in a standard fully connected or dense layer, as used in MLPs.

# 14.2.1.4 Boundary conditions and padding

In Equation (14.7), we saw that convolving a $3 \times 3$ image with a $2 \times 2$ filter resulted in a $2 \times 2$ output. In general, convolving a $f _ { h } \times f _ { w }$ filter over an image of size $x _ { h } \times x _ { w }$ produces an output of size $( x _ { h } - f _ { h } + 1 ) \times ( x _ { w } - f _ { w } + 1 )$ ; this is called valid convolution, since we only apply the filter to “valid” parts of the input, i.e., we don’t let it “slide off the ends”. If we want the output to have the same size as the input, we can use zero-padding, which means we add a border of 0s to the image, as illustrated in Figure 14.7. This is called same convolution.

![](images/ce8d09a8b6f3050fffd3b3c51f70c1f7722aee0d64bef3d2161b06cb32166015.jpg)  
Figure 14.7: Same-convolution (using zero-padding) ensures the output is the same size as the input. Adapted from Figure 8.3 of [SAV20].

![](images/5ff9563e23152cbd8538bb4f879083bd977a521943d16c4123d2873f474fb5ef.jpg)  
Figure 14.8: Illustration of padding and strides in 2d convolution. (a) We apply “same convolution” to a $5 \times 7$ input (with zero padding) using a $3 \times 3$ filter to create a $5 \times 7$ output. (b) Now we use a stride of 2, so the output has size $3 \times 4$ . Adapted from Figures 14.3–14.4 of [Gér19].

In general, if the input has size $x _ { h } \times x _ { w }$ , we use a kernel of size $f _ { h } \times f _ { w }$ , we use zero padding on each side of size $p _ { h }$ and $p _ { w }$ , then the output has the following size [DV16]:

$$
\left( x _ { h } + 2 p _ { h } - f _ { h } + 1 \right) \times \left( x _ { w } + 2 p _ { w } - f _ { w } + 1 \right)
$$

For example, consider Figure 14.8a. We have $p = 1$ , $f = 3$ , $x _ { h } = 5$ and $x _ { w } = 7$ , so the output has size

$$
( 5 + 2 - 3 + 1 ) \times ( 7 + 2 - 3 + 1 ) = 5 \times 7
$$

If we set $2 p = f - 1$ , then the output will have the same size as the input.

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

![](images/6695116ddff9c7ee6ae364f677023b6c45dab0f864c59a60c190dc3c7d9f5082.jpg)  
Figure 14.9: Illustration of 2d convolution applied to an input with 2 channels. Generated by conv2d_jax.ipynb. Adapted from Figure 6.4.1 of [Zha+20].

# 14.2.1.5 Strided convolution

Since each output pixel is generated by a weighted combination of inputs in its receptive field (based on the size of the filter), neighboring outputs will be very similar in value, since their inputs are overlapping. We can reduce this redundancy (and speedup computation) by skipping every $s$ ’th input. This is called strided convolution. This is illustrated in Figure 14.8b, where we convolve a $5 \times 7$ image with a $3 \times 3$ filter with stride 2 to get a $3 \times 4$ output.

In general, if the input has size $x _ { h } \times x _ { w }$ , we use a kernel of size $f _ { h } \times f _ { w }$ , we use zero padding on each side of size $p _ { h }$ and $p _ { w }$ , and we use strides of size $s _ { h }$ and $s _ { w }$ , then the output has the following size [DV16]:

$$
\left\lfloor \frac { x _ { h } + 2 p _ { h } - f _ { h } + s _ { h } } { s _ { h } } \right\rfloor \times \left\lfloor \frac { x _ { w } + 2 p _ { w } - f _ { w } + s _ { w } } { s _ { w } } \right\rfloor
$$

For example, consider Figure 14.8b, where we set the stride to $s = 2$ . Now the output is smaller than the input.

$$
\left( { \bigl \lfloor } { \frac { 5 + 2 - 3 + 2 } { 2 } } { \bigr \rfloor } , { \bigl \lfloor } { \frac { 7 + 2 - 3 + 2 } { 2 } } { \bigr \rfloor } \right) = \left( { \bigl \lfloor } { \frac { 6 } { 2 } } { \bigr \rfloor } , { \bigl \lfloor } { \frac { 4 } { 1 } } { \bigr \rfloor } \right) = 3 \times 4
$$

# 14.2.1.6 Multiple input and output channels

In Figure 14.6, the input was a gray-scale image. In general, the input will have multiple channels (e.g., RGB, or hyper-spectral bands for satellite images). We can extend the definition of convolution to this case by defining a kernel for each input channel; thus now $\mathbf { W }$ is a 3d weight matrix or tensor. We compute the output by convolving channel $c$ of the input with kernel $\mathbf { W } _ { : , : , c }$ , and then summing over channels:

$$
z _ { i , j } = b + \sum _ { u = 0 } ^ { H - 1 } \sum _ { v = 0 } ^ { W - 1 } \sum _ { c = 0 } ^ { C - 1 } x _ { s i + u , s j + v , c } w _ { u , v , c }
$$

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license where $s$ is the stride (which we assume is the same for both height and width, for simplicity), and $b$ is the bias term. This is illustrated in Figure 14.9.

![](images/db788f288c0471a53a9b3deb7899d418d1c95298806a7970400313f4f4bb5b41.jpg)  
Figure 14.10: Illustration of a CNN with 2 convolutional layers. The input has 3 color channels. The feature maps at internal layers have multiple channels. The cylinders correspond to hypercolumns, which are feature vectors at a certain location. Adapted from Figure 14.6 of [Gér19].

Each weight matrix can detect a single kind of feature. We typically want to detect multiple kinds of features, as illustrated in Figure 14.2. We can do this by making $\mathbf { W }$ into a 4d weight matrix. The filter to detect feature type $d$ in input channel $c$ is stored in $\mathbf { W } _ { : , : , c , d }$ . We extend the definition of convolution to this case as follows:

$$
z _ { i , j , d } = b _ { d } + \sum _ { u = 0 } ^ { H - 1 } \sum _ { v = 0 } ^ { W - 1 } \sum _ { c = 0 } ^ { C - 1 } x _ { s i + u , s j + v , c } w _ { u , v , c , d }
$$

This is illustrated in Figure 14.10. Each vertical cylindrical column denotes the set of output features at a given location, $z _ { i , j , 1 : D }$ ; this is sometimes called a hypercolumn. Each element is a different weighted combination of the $C$ features in the receptive field of each of the feature maps in the layer below.2

# 14.2.1.7 $\mathbf { 1 } \times \mathbf { 1 }$ (pointwise) convolution

Sometimes we just want to take a weighted combination of the features at a given location, rather than across locations. This can be done using 1x1 convolution, also called pointwise convolution.

![](images/c91f55c1309b7e23cf4e5acd4ec24157c0076718314ce7e50f0d8adb98456831.jpg)  
Figure 14.11: Mapping $\mathcal { B }$ channels to 2 using convolution with a filter of size $1 \times 1 \times 3 \times 2$ . Adapted from Figure 6.4.2 of [Zha+20].

![](images/6cf4e3377cf84592ed182ba125211a35dcb3af8bf51060673db23f3c06a12926.jpg)  
Figure 14.12: Illustration of maxpooling with a 2x2 filter and a stride of 1. Adapted from Figure 6.5.1 of [Zha+20].

This changes the number of channels from $C$ to $D$ , without changing the spatial dimensionality:

$$
z _ { i , j , d } = b _ { d } + \sum _ { c = 0 } ^ { C - 1 } x _ { i , j , c } w _ { 0 , 0 , c , d }
$$

This can be thought of as a single layer MLP applied to each feature column in parallel.

# 14.2.2 Pooling layers

Convolution will preserve information about the location of input features (modulo reduced resolution), a property known as equivariance. In some case we want to be invariant to the location. For example, when performing image classification, we may just want to know if an object of interest (e.g., a face) is present anywhere in the image.

One simple way to achieve this is called max pooling, which just computes the maximum over its incoming values, as illustrated in Figure 14.12. An alternative is to use average pooling, which replaces the max by the mean. In either case, the output neuron has the same response no matter

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license where the input pattern occurs within its receptive field. (Note that we apply pooling to each feature channel independently.)

![](images/a20205b9041169f9fcec8686a46beb30c264e198522b888f690c6999d3042fa7.jpg)  
Figure 14.13: A simple CNN for classifying images. Adapted from https: // blog. floydhub. com/ building-your-first-convnet/ .

If we average over all the locations in a feature map, the method is called global average pooling. Thus we can convert a $H \times W \times D$ feature map into a $1 \times 1 \times D$ dimensional feature map; this can be reshaped to a $D$ -dimensional vector, which can be passed into a fully connected layer to map it to a $C$ -dimensional vector before passing into a softmax output. The use of global average pooling means we can apply the classifier to an image of any size, since the final feature map will always be converted to a fixed $D$ -dimensional vector before being mapped to a distribution over the $C$ classes.

# 14.2.3 Putting it all together

A common design pattern is to create a CNN by alternating convolutional layers with max pooling layers, followed by a final linear classification layer at the end. This is illustrated in Figure 14.13. (We omit normalization layers in this example, since the model is quite shallow.) This design pattern first appeared in Fukushima’s neocognitron [Fuk75], and was inspired by Hubel and Wiesel’s model of simple and complex cells in the human visual cortex [HW62]. In 1998 Yann LeCun used a similar design in his eponynous LeNet model [LeC+98], which used backpropagation and SGD to estimate the parameters. This design pattern continues to be popular in neurally-inspired models of visual object recognition [RP99], as well as various practical applications (see Section 14.3 and Section 14.5).

# 14.2.4 Normalization layers

The basic design in Figure 14.13 works well for shallow CNNs, but it can be difficult to scale it to deeper models, due to problems with vanishing or exploding gradients, as explained in Section 13.4.2. A common solution to this problem is to add extra layers to the model, to standardize the statistics of the hidden units (i.e., to ensure they are zero mean and unit variance), just like we do to the inputs of many models. We discuss various kinds of normalization layers below.

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

# 14.2.4.1 Batch normalization

The most popular normalization layer is called batch normalization (BN) [IS15]. This ensures the distribution of the activations within a layer has zero mean and unit variance, when averaged across the samples in a minibatch. More precisely, we replace the activation vector $z _ { n }$ (or sometimes the pre-activation vector $\mathbf { \Delta } _ { \mathbf { u } }$ ) for example $n$ (in some layer) with $\tilde { z } _ { n }$ , which is computed as follows:

$$
\begin{array} { r l } & { \tilde { z } _ { n } = \gamma \odot \hat { z } _ { n } + \beta } \\ & { \hat { z } _ { n } = \cfrac { z _ { n } - \mu _ { B } } { \sqrt { \sigma _ { B } ^ { 2 } + \epsilon } } } \\ & { \mu _ { B } = \cfrac { 1 } { | \mathcal { B } | } \displaystyle \sum _ { z \in \mathcal { B } } z } \\ & { \sigma _ { \mathcal { B } } ^ { 2 } = \cfrac { 1 } { | \mathcal { B } | } \displaystyle \sum _ { z \in \mathcal { B } } ( z - \mu _ { \mathcal { B } } ) ^ { 2 } } \end{array}
$$

where $\boldsymbol { B }$ is the minibatch containing example $n$ , $\pmb { \mu } _ { B }$ is the mean of the activations for this batch3, ${ \pmb { \sigma } } _ { B } ^ { 2 }$ is the corresponding variance, $\hat { z } _ { n }$ is the standardized activation vector, $\tilde { z } _ { n }$ is the shifted and scaled version (the output of the BN layer), $\beta$ and $\gamma$ are learnable parameters for this layer, and $\epsilon > 0$ is a small constant. Since this transformation is differentiable, we can easily pass gradients back to the input of the layer and to the BN parameters $\beta$ and $\gamma$ .

When applied to the input layer, batch normalization is equivalent to the usual standardization procedure we discussed in Section 10.2.8. Note that the mean and variance for the input layer can be computed once, since the data is static. However, the empirical means and variances of the internal layers keep changing, as the parameters adapt. (This is sometimes called “internal covariate shift”.) This is why we need to recompute $\pmb { \mu }$ and $\sigma ^ { 2 }$ on each minibatch.

At test time, we may have a single input, so we cannot compute batch statistics. The standard solution to this is as follows: after training, compute $\pmb { \mu } _ { l }$ and $\sigma _ { l } ^ { 2 }$ for layer $\it { l }$ across all the examples in the training set (i.e. using the full batch), and then “freeze” these parameters, and add them to the list of other parameters for the layer, namely $\beta _ { l }$ and $\gamma _ { l }$ . At test time, we then use these frozen training values for $\pmb { \mu } _ { l }$ and $\sigma _ { l } ^ { 2 }$ , rather than computing statistics from the test batch. Thus when using a model with BN, we need to specify if we are using it for inference or training. (See batchnorm_jax.ipynb for some sample code.)

For speed, we can combine a frozen batch norm layer with the previous layer. In particular suppose the previous layer computes $\mathbf { X } \mathbf { W } + \pmb { b }$ ; combining this with BN gives $\gamma \odot ( \mathbf { X } \mathbf { W } + \pmb { b } - \pmb { \mu } ) / \pmb { \sigma } + \beta$ . If we define $\mathbf { W } ^ { \prime } = \gamma \odot \mathbf { W } / \sigma$ and $b ^ { \prime } = \gamma \odot ( b - \pmb { \mu } ) / \pmb { \sigma } + \beta$ , then we can write the combined layers as $\mathbf { X } \mathbf { W } ^ { \prime } + \pmb { b } ^ { \prime }$ . This is called fused batchnorm. Similar tricks can be developed to speed up BN during training [Jun+19].

The benefits of batch normalization (in terms of training speed and stability) can be quite dramatic, especially for deep CNNs. The exact reasons for this are still unclear, but BN seems to make the optimization landscape significantly smoother [San+18b]. It also reduces the sensitivity to the learning rate [ALL18]. In addition to computational advantages, it has statistical advantages. In particular, BN acts like a regularizer; indeed it can be shown to be equivalent to a form of approximate Bayesian inference [TAS18; Luo+19].

![](images/edfc1085964bab6418508cb4d3958bc48d5a388e26209c4089ca02708c10449d.jpg)  
Figure 14.14: Illustration of different activation normalization methods for a CNN. Each subplot shows a feature map tensor, with N as the batch axis, $C$ as the channel axis, and (H, W) as the spatial axes. The pixels in blue are normalized by the same mean and variance, computed by aggregating the values of these pixels. Left to right: batch norm, layer norm, instance norm, and group norm (with 2 groups of 3 channels). From Figure 2 of [WH18]. Used with kind permission of Kaiming He.

However, the reliance on a minibatch of data causes several problems. In particular, it can result in unstable estimates of the parameters when training with small batch sizes, although a more recent version of the method, known as batch renormalization [Iof17], partially addresses this. We discuss some other alternatives to batch norm below.

# 14.2.4.2 Other kinds of normalization layer

In Section 14.2.4.1 we discussed batch normalization, which standardizes all the activations within a given feature channel to be zero mean and unit variance. This can significantly help with training, and allow for a larger learning rate. (See batchnorm_jax.ipynb for some sample code.)

Although batch normalization works well, it struggles when the batch size is small, since the estimated mean and variance parameters can be unreliable. One solution is to compute the mean and variance by pooling statistics across other dimensions of the tensor, but not across examples in the batch. More precisely, let $z _ { i }$ refer to the $i$ ’th element of a tensor; in the case of 2d images, the index $i$ has 4 components, indicating batch, height, width and channel, $i = ( i _ { N } , i _ { H } , i _ { W } , i _ { C } )$ . We compute the mean and standard deviation for each index $z _ { i }$ as follows:

$$
\mu _ { i } = \frac { 1 } { | S _ { i } | } \sum _ { k \in S _ { i } } z _ { k } , \sigma _ { i } = \sqrt { \frac { 1 } { | S _ { i } | } \sum _ { k \in S _ { i } } ( z _ { k } - \mu _ { i } ) ^ { 2 } + \epsilon }
$$

where $S _ { i }$ is the set of elements we average over. We then compute $\hat { z } _ { i } = ( z _ { i } - \mu _ { i } ) / \sigma _ { i }$ and $\widetilde z _ { i } = \gamma _ { c } \hat { z } _ { i } + \beta _ { c }$ , where $c$ is the channel corresponding to index $i$ .

In batch norm, we pool over batch, height, width, so $S _ { i }$ is the set of all location in the tensor that match the channel index of $i$ . To avoid problems with small batches, we can instead pool over channel, height and width, but match on the batch index. This is known as layer normalization [BKH16]. (See layer_norm_jax.ipynb for some sample code.) Alternatively, we can have separate normalization parameters for each example in the batch and for each channel. This is known as instance normalization [UVL16].

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

A natural generalization of the above methods is known as group normalization [WH18], where we pool over all locations whose channel is in the same group as $i$ ’s. This is illustrated in Figure 14.14. Layer normalization is a special case in which there is a single group, containing all the channels. Instance normalization is a special case in which there are $C$ groups, one per channel. In [WH18], they show experimentally that it can be better (in terms of training speed, as well as training and test accuracies) to use groups that are larger than individual channels, but smaller than all the channels.

More recently, [SK20] proposed filter response normalization which is an alternative to batch norm that works well even with a minibatch size of 1. The idea is to define each group as all locations with a single channel and batch sample (as in instance normalization), but then to just divide by the mean squared norm instead of standardizing. That is, if the input (for a given channel and batch entry) is $\boldsymbol { z } = \mathbf { Z } _ { b , : , : , c } \in \mathbb { R } ^ { N }$ , we compute $\hat { z } = z / \sqrt { \nu ^ { 2 } + \epsilon }$ , where $\begin{array} { r } { \nu ^ { 2 } = \sum _ { i j } z _ { b i j c } ^ { 2 } / N } \end{array}$ , and then $\tilde { z } = \gamma _ { c } \hat { z } + \beta _ { c }$ . Since there is no mean centering, the activations can drift away from $0$ , which can have detrimental effects, especially with ReLU activations. To compensate for this, the authors propose to add a thresholded linear unit at the output. This has the form ${ \pmb y } = \operatorname* { m a x } ( { \pmb x } , \tau )$ , where $\tau$ is a learnable offset. The combination of FRN and TLU results in good performance on image classification and object detection even with a batch size of 1.

# 14.2.4.3 Normalizer-free networks

Recently, [Bro+21] have proposed a method called normalizer-free networks, which is a way to train deep residual networks without using batchnorm or any other form of normalization layer. The key is to replace it with adaptive gradient clipping, as an alternative way to avoid training instabilities. That is, we use Equation (13.70), but adapt the clipping strength dynamically. The resulting model is faster to train, and more accurate, than other competitive models trained with batchnorm.

# 14.3 Common architectures for image classification

It is common to use CNNs to perform image classification, which is the task of estimating the function $f : \mathbb { R } ^ { H \times W \times K }  \{ 0 , 1 \} ^ { C }$ , where $K$ is the number of input channels (e.g., $K = 3$ for RGB images), and $C$ is the number of class labels.

In this section, we briefly review various CNNs that have been developed over the years to solve image classification tasks. See e.g., [Kha+20] for a more extensive review of CNNs, and e.g., https://github.com/rwightman/pytorch-image-models for an up-to-date repository of code and models (in PyTorch).

# 14.3.1 LeNet

One of the earliest CNNs, created in 1998, is known as LeNet [LeC+98], named after its creator, Yann LeCun. It was designed to classify images of handwritten digits, and was trained on the MNIST dataset introduced in Section 3.5.2. The model is shown in Figure 14.15. (See also Figure 14.16a for a more compact representation of the model.) Some predictions of this model are shown in Figure 14.17. After just 1 epoch, the test accuracy is already 98.8%. By contrast, the MLP in Section 13.2.4.2 had an accuracy of $9 5 . 9 \%$ after 1 epoch. More rounds of training can further increase accuracy to a point where performance is indistinguishable from label noise. (See lenet_jax.ipynb for some sample code.)

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

![](images/9b367d6648eb9d19d1524a8c89ebbfceb18035a2df7e2ef3fa474b738667136f.jpg)  
Figure 14.15: LeNet5, a convolutional neural net for classifying handwritten digits. From Figure 6.6.1 of [Zha+20]. Used with kind permission of Aston Zhang.

![](images/28f0c6eb5b3cad890dab4e1ea26ce3d9e9f5aa3350275589b23a45116c146db6.jpg)  
Figure 14.16: (a) LeNet5. We assume the input has size $1 \times 2 8 \times 2 8$ , as is the case for MNIST. From Figure 6.6.2 of [Zha+20]. Used with kind permission of Aston Zhang. (b) AlexNet. We assume the input has size $3 \times 2 2 4 \times 2 2 4$ , as is the case for (cropped and rescaled) images from ImageNet. From Figure 7.1.2 of [Zha+20]. Used with kind permission of Aston Zhang.

![](images/3897672ecc7bc6f811ee4b858e618d74f52302f473b2d25a47478f9851f0e6d8.jpg)  
Figure 14.17: Results of applying a CNN to some MNIST images (cherry picked to include some errors). Red is incorrect, blue is correct. (a) After 1 epoch of training. (b) After 2 epochs. Generated by cnn_mnist_tf.ipynb.

Of course, classifying isolated digits is of limited applicability: in the real world, people usually write strings of digits or other letters. This requires both segmentation and classification. LeCun and colleagues devised a way to combine convolutional neural networks with a model similar to a conditional random field to solve this problem. The system was deployed by the US postal service. See [LeC+98] for a more detailed account of the system.

# 14.3.2 AlexNet

Although CNNs have been around for many years, it was not until the paper of [KSH12] in 2012 that mainstream computer vision researchers paid attention to them. In that paper, the authors showed how to reduce the (top 5) error rate on the ImageNet challenge (Section 1.5.1.2) from the previous best of 26% to $1 5 \%$ , which was a dramatic improvement. This model became known as AlexNet model, named after its creator, Alex Krizhevsky.

Figure 14.16b(b) shows the architecture. It is very similar to LeNet, shown in Figure 14.16a, with the following differences: it is deeper (8 layers of adjustable parameters (i.e., excluding the pooling layers) instead of 5); it uses ReLU nonlinearities instead of tanh (see Section 13.2.3 for why this is important); it uses dropout (Section 13.5.4) for regularization instead of weight decay; and it stacks several convolutional layers on top of each other, rather than strictly alternating between convolution and pooling. Stacking multiple convolutional layers together has the advantage that the receptive fields become larger as the output of one layer is fed into another (for example, three $3 \times 3$ filters in a row will have a receptive field size of $7 \times 7$ ). This is better than using a single layer with a larger receptive field, since the multiple layers also have nonlinearities in between. Also, three $3 \times 3$ filters have fewer parameters than one $7 \times 7$ .

Note that AlexNet has 60M free parameters (which is much more than the 1M labeled examples), mostly due to the three fully connected layers at the output. Fitting this model relied on using two GPUs (due to limited memory of GPUs at that time), and is widely considered an engineering tour de force.4 Figure 1.14a shows some predictions made by the model on some images from ImageNet.

![](images/e408007a4765955afe766c66a5776d6fe3ddda0ac9d88f61d2bb09f4b69b43ac.jpg)  
Figure 14.18: Inception module. The $1 \times 1$ convolutional layers reduce the number of channels, keeping the spatial dimensions the same. The parallel pathways through convolutions of different sizes allows the model to learn which filter size to use for each layer. The final depth concatenation block combines the outputs of all the different pathways (which all have the same spatial size). From Figure 7.4.1 of [Zha+20]. Used with kind permission of Aston Zhang.   
Figure 14.19: GoogLeNet (slightly simplified from the original). Input is on the left. From Figure 7.4.2 of [Zha+20]. Used with kind permission of Aston Zhang.

双 5 又2 + + F + SES → + GrRf

# 14.3.3 GoogLeNet (Inception)

Google who developed a model known as GoogLeNet [Sze+15a]. (The name is a pun on Google and LeNet.) The main difference from earlier models is that GoogLeNet used a new kind of block, known as an inception block $^ { 5 }$ , that employs multiple parallel pathways, each of which has a convolutional filter of a different size. See Figure 14.18 for an illustration. This lets the model learn what the optimal filter size should be at each level. The overall model consists of 9 inception blocks followed by global average pooling. See Figure 14.19 for an illustration. Since this model first came out, various extensions were proposed; details can be found in [IS15; Sze+15b; SIV17].

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

![](images/5c8ae4c21e417d25e51e3de2e838279a2e93819cc11aec8c52e7e77fb05a72b5.jpg)  
Figure 14.20: A residual block for a CNN. Left: standard version. Right: version with 1x1 convolution, to allow a change in the number of channels between the input to the block and the output. From Figure 7.6.3 of [Zha+20]. Used with kind permission of Aston Zhang   
Figure 14.21: The ResNet-18 architecture. Each dotted module is a residual block shown in Figure 14.20. From Figure 7.6.4 of [Zha+20]. Used with kind permission of Aston Zhang

2 DT II-1I-I-- T

# 14.3.4 ResNet

The winner of the 2015 ImageNet classification challenge was a team at Microsoft, who proposed a model known as ResNet [He+16a]. The key idea is to replace ${ \pmb x } _ { l + 1 } = \mathcal { F } _ { l } ( { \pmb x } _ { l } )$ with

$$
{ \pmb x } _ { l + 1 } = \varphi ( { \pmb x } _ { l } + \mathcal { F } _ { l } ( { \pmb x } _ { l } ) )
$$

This is known as a residual block, since $\mathcal { F } _ { l }$ only needs to learn the residual, or difference, between input and output of this layer, which is a simpler task. In [He+16a], $\mathcal { F }$ has the form conv-BN-reluconv-BN, where conv is a convolutional layer, and BN is a batch norm layer (Section 14.2.4.1). See Figure 14.20(left) for an illustration.

We can ensure the spatial dimensions of the output $\mathcal { F } _ { l } ( \pmb { x } _ { l } )$ of the convolutional layer match those of the input ${ \boldsymbol { \mathbf { \mathit { x } } } } _ { l }$ by using padding. However, if we want to allow for the output of the convolutional layer to have a different number of channels, we need to add $1 \times 1$ convolution to the skip connection on $\boldsymbol { x } _ { l }$ . See Figure 14.20(right) for an illustration.

The use of residual blocks allows us to train very deep models. The reason this is possible is that gradient can flow directly from the output to earlier layers, via the skip connections, for reasons explained in Section 13.4.4.

In [He+16a] trained a 152 layer ResNet on ImageNet. However, it is common to use shallower models. For example, Figure 14.21 shows the ResNet-18 architecture, which has 18 trainable layers: there are 2 3x3 conv layers in each residual block, and there are 8 such blocks, with an initial 7x7 conv (stride 2) and a final fully connected layer. Symbolically, we can define the model as follows:

(Conv : BN : Max) : (R : R) : (R’ : R) : (R’ : R) : (R’ : R) : Avg : FC where R is a residual block, R’ is a residual block with skip connection (due to the change in the number of channels) with stride 2, FC is fully connected (dense) layer, and : denotes concatenation. Note that the input size gets reduced spatially by a factor of $2 ^ { 5 } = 3 2$ (factor of 2 for each R’ block, plus the initial Conv-7x7(2) and Max-pool), so a 224x224 images becomes a 7x7 image before going into the global average pooling layer.

Some code to fit these models can be found online.6

In [He+16b], they showed how a small modification of the above scheme allows us to train models with up to 1001 layers. The key insight is that the signal on the skip connections is still being attentuated due to the use of the nonlinear activation function after the addition step, $\pmb { x } _ { l + 1 } = \varphi ( \pmb { x } _ { l } + \mathcal { F } ( \pmb { x } _ { l } ) )$ . They showed that it is better to use

$$
\pmb { x } _ { l + 1 } = \pmb { x } _ { l } + \varphi ( \mathcal { F } _ { l } ( \pmb { x } _ { l } ) )
$$

This is called a preactivation resnet or PreResnet for short. Now it is very easy for the network to learn the identity function at a given layer: if we use ReLU activations, we just need to ensure that $\mathcal { F } _ { l } ( \pmb { x } _ { l } ) = \mathbf { 0 }$ , which we can do by setting the weights and biases to 0.

An alternative to using a very deep model is to use a very “wide” model, with lots of feature channels per layer. This is the idea behind the wide resnet model [ZK16], which is quite popular.

# 14.3.5 DenseNet

In a residual net, we add the output of each function to its input. An alternative approach would be to concatenate the output with the input, as illustrated in Figure 14.22a. If we stack a series of such blocks, we can get an architecture similar to Figure 14.22b. This is known as a DenseNets [Hua+17a], since each layer densely depends on all previous layers. Thus the overall model is computing a function of the form

$$
{ \pmb x }  [ { \pmb x } , f _ { 1 } ( { \pmb x } ) , f _ { 2 } ( { \pmb x } , f _ { 1 } ( { \pmb x } ) ) , f _ { 3 } ( { \pmb x } , f _ { 1 } ( { \pmb x } ) , f _ { 2 } ( { \pmb x } , f _ { 1 } ( { \pmb x } ) ) ) , . . . ]
$$

![](images/be5cfc82136c86af9f86b8851a42edf4ae7a29e3943353684a58127f82dbf08e.jpg)  
Figure 14.22: (a) Left: a residual block adds the output to the input. Right: a densenet block concatenates the output with the input. (b) Illustration of a densenet. From Figures 7.7.1–7.7.2 of [Zha+20]. Used with kind permission of Aston Zhang.

The dense connectivity increases the number of parameters, since the channels get stacked depthwise. We can compensate for this by adding $1 \times 1$ convolution layers in between. We can also add pooling layers with a stride of 2 to reduce the spatial resolution. (See densenet_jax.ipynb for some sample code.)

DenseNets can perform better than ResNets, since all previously computed features are directly accessible to the output layer. However, they can be more computationally expensive.

# 14.3.6 Neural architecture search

We have seen how many CNNs are fairly similar in their design, and simply rearrange various building blocks (such as convolutional or pooling layers) in different topologies, and adjust various parameter settings (e.g., stride, number of channels, or learning rate). Indeed, the recent ConvNeXt model of [Liu+22] — which, at the time of writing (April 2022) is considered the state of the art CNN architecture for a wide variety of vision tasks — was created by combining multiple such small improvements on top of a standard ResNet architecture.

We can automate this design process using blackbox (derivative free) optimization methods to find architectures that minimize the validation loss. This is called Auto-ML; in the context of neural nets, it is called neural architecture search (NAS).

When performing NAS, we can optimize for multiple objectives at the same time, such as accuracy, model size, training or inference speed, etc (this is how EfficientNetv2 is created [TL21]). The main challenge arises due to the expense of computing the objective (since it requires training each candidate point in model space). One way to reduce the number of calls to the objective function is to use Bayesian optimization (see e.g., [WNS19]). Another approach is to create differentiable approximations to the loss (see e.g., [LSY19; Wan+21]), or to convert the architecture into a kernel function (using the neural tangent kernel method, Section 17.2.8), and then to analyze properties of its eigenvalues, which can predict performance without actually training the model [CGW21]. The field of NAS is very large and still growing. See [EMH19] for a more thorough review.

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

![](images/5017a845f2cf2546cdebb27daeefc91cb9da39e0240f78f18789247671fb6c16.jpg)  
Figure 14.23: Dilated convolution with a 3x3 filter using rate 1, 2 and 3. From Figure 1 of [Cui+19]. Used with kind permission of Ximin Cui.

# 14.4 Other forms of convolution \*

We discussed the basics of convolution in Section 14.2. In this section, we discuss some extensions, which are needed for applications such as image segmentation and image generation.

# 14.4.1 Dilated convolution

Convolution is an operation that combines the pixel values in a local neighborhood. By using striding, and stacking many layers of convolution together, we can enlarge the receptive field of each neuron, which is the region of input space that each neuron responds to. However, we would need many layers to give each neuron enough context to cover the entire image (unless we used very large filters, which would be slow and require too many parameters).

As an alternative, we can use convolution with holes [Mal99], sometimes known by the French term à trous algorithm, and recently renamed dilated convolution [YK16]. This method simply takes every $r$ ’th input element when performing convolution, where $r$ is known as the rate or dilation factor. For example, in 1d, convolving with filter $\mathbf { \boldsymbol { w } }$ using rate $r = 2$ is equivalent to regular convolution using the filter $\tilde { \pmb { w } } = [ w _ { 1 } , 0 , w _ { 2 } , 0 , w _ { 3 } ]$ , where we have inserted 0s to expand the receptive field (hence the term “convolution with holes”). This allows us to get the benefit of increased receptive fields without increasing the number of parameters or the amount of compute. See Figure 14.23 for an illustration.

More precisely, dilated convolution in 2d is defined as follows:

$$
z _ { i , j , d } = b _ { d } + \sum _ { u = 0 } ^ { H - 1 } \sum _ { v = 0 } ^ { W - 1 } \sum _ { c = 0 } ^ { C - 1 } x _ { i + r u , j + r v , c } w _ { u , v , c , d }
$$

where we assume the same rate $r$ for both height and width, for simplicity. Compare this to Equation (14.15), where the stride parameter uses xsi+u,sj+v,c.

# 14.4.2 Transposed convolution

In convolution, we reduce from a large input $\mathbf { X }$ to a small output $\mathbf { Y }$ by taking a weighted combination of the input pixels and the convolutional kernel $\mathbf { K }$ . This is easiest to explain in code:

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022 def conv(X, K): h, $\texttt { w } = \texttt { K }$ .shape $\textsf { Y } =$ zeros((X.shape[0] - $\texttt { h + 1 }$ , X.shape[1] - w + 1)) for i in range(Y.shape[0]): for j in range(Y.shape[1]): Y[i, j] $\mathbf { \Sigma } = \mathbf { \Sigma }$ (X[i:i + h, j:j + w] \* K).sum() return Y

![](images/78e3e97b0ded1b42bee20d6d406dea159c4820c3dde19a47e295a5d946dbb7fb.jpg)  
Figure 14.24: Transposed convolution with 2x2 kernel. From Figure 13.10.1 of [Zha+20]. Used with kind permission of Aston Zhang.

In transposed convolution, we do the opposite, in order to produce a larger output from a smaller input:

def trans_conv(X, K): h, $\texttt { w } = \texttt { K }$ .shape $\textsf { Y } =$ zeros((X.shape[0] + h - 1, X.shape[1] + w - 1)) for i in range(X.shape[0]): for j in range(X.shape[1]): $\texttt { Y } [ \texttt { i : i } + \texttt { h }$ , j:j + w] += X[i, j] \* K return Y

This is equivalent to padding the input image with $( h - 1 , w - 1 )$ 0s (on the bottom right), where $( h , w )$ is the kernel size, then placing a weighted copy of the kernel on each one of the input locations, where the weight is the corresponding pixel value, and then adding up. This process is illustrated in Figure 14.24. We can think of the kernel as a “stencil” that is used to generate the output, modulated by the weights in the input.

The term “transposed convolution” comes from the interpretation of convolution as matrix multiplication, which we discussed in Section 14.2.1.3. If $\mathbf { W }$ is the matrix derived from kernel $\mathbf { K }$ using the process illustrated in Equation (14.9), then one can show that Y = transposed- $\mathrm { c o n v } ( \mathbf { X } , \mathbf { K } )$ is equivalent to $\mathbf { Y } = \mathrm { r e s h a p e } ( \mathbf { W } ^ { \mathsf { T } } \mathrm { v e c } ( \mathbf { X } ) )$ . See transposed_conv_jax.ipynb for a demo.

Note that transposed convolution is also sometimes called deconvolution, but this is an incorrect usage of the term: deconvolution is the process of “undoing” the effect of convolution with a known filter, such as a blur filter, to recover the original input, as illustrated in Figure 14.25.

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

![](images/f72c880a731dd05bc5861bdf270dbea95a80277b1e69fc9ad254200bacdcedce.jpg)  
Figure 14.25: Convolution, deconvolution and transposed convolution. Here s is the stride and p is the padding. From https: // tinyurl. com/ ynxcxsut . Used with kind permission of Aqeel Anwar.

# 14.4.3 Depthwise separable convolution

Standard convolution uses a filter of size $H \times W \times C \times D$ , which requires a lot of data to learn and a lot of time to compute with. A simplification, known as depthwise separable convolution, first convolves each input channel by a corresponding 2d filter $\mathbf { \boldsymbol { w } }$ , and then maps these $C$ channels to $D$ channels using $1 \times 1$ convolution $\mathbf { \Delta } \mathbf { w ^ { \prime } }$ :

$$
z _ { i , j , d } = b _ { d } + w _ { c , d } ^ { \prime } \sum _ { c = 0 } ^ { C - 1 } \left( \sum _ { u = 0 } ^ { H - 1 } \sum _ { v = 0 } ^ { W - 1 } x _ { i + u , j + v , c } w _ { u , v } \right)
$$

See Figure 14.26 for an illustration.

To see the advantage of this, let us consider a simple numerical example.7 Regular convolution of a $1 2 \times 1 2 \times 3$ input with a $5 \times 5 \times 3 \times 2 5 6$ filter gives a $8 \times 8 \times 2 5 6$ output (assuming valid convolution: 12-5+1=8), as illustrated in Figure 14.13. With separable convolution, we start with $1 2 \times 1 2 \times 3$ input, convolve with a $5 \times 5 \times 1 \times 1$ filter (across space but not channels) to get $8 \times 8 \times 3$ , then pointwise convolve (across channels but not space) with a $1 \times 1 \times 3 \times 2 5 6$ filter to get a $8 \times 8 \times 2 5 6$ output. So the output has the same size as before, but we used many fewer parameters to define the layer, and used much less compute. For this reason, separable convolution is often used in lightweight CNN models, such as the MobileNet model [How+17; San+18a] and other edge devices.

# 14.5 Solving other discriminative vision tasks with CNNs \*

In this section, we briefly discuss how to tackle various other vision tasks using CNNs. Each task also introduces a new architectural innovation to the library of basic building blocks we have already seen. More details on CNNs for computer vision can be found in e.g., [Bro19].

# 14.5.1 Image tagging

Image classification associates a single label with the whole image, i.e., the outputs are assumed to be mutually exclusive. In many problems, there may be multiple objects present, and we want to label all of them. This is known as image tagging, and is an application of multi-label prediction. In this case, we define the output space as $\mathcal { Y } = \{ 0 , 1 \} ^ { C }$ , where $C$ is the number of tag types. Since the output bits are independent (given the image), we should replace the final softmax with a set of $C$ logistic units.

![](images/35cf305049796b8ac9a0406dd9e3b6c5b2a7d5f9016dba1bbdd6b1ef5d337857.jpg)  
Figure 14.26: Depthwise separable convolutions: each of the $C$ input channels undergoes a 2d convolution to produce $C$ output channels, which get combined pointwise (via 1x1 convolution) to produce D output channels. From https: // bit. ly/ 2L9fm2o . Used with kind permission of Eugenio Culurciello.

Users of social media sites like Instagram often create hashtags for their images; this therefore provides a “free” way of creating large supervised datasets. Of course, many tags may be quite sparsely used, and their meaning may not be well-defined visually. (For example, someone may take a photo of themselves after they get a COVID test and tag the image “#covid”; however, visually it just looks like any other image of a person.) Thus this kind of user-generated labeling is usually considered quite noisy. However, it can be useful for “pre-training”, as discussed in [Mah+18].

Finally, it is worth noting that image tagging is often a much more sensible objective than image classification, since many images have multiple objects in them, and it can be hard to know which one we should be labeling. Indeed, Andrej Karpathy, who created the “human performance benchmark” on ImageNet, noted the following:8

Both [CNNs] and humans struggle with images that contain multiple ImageNet classes (usually many more than five), with little indication of which object is the focus of the image. This error is only present in the classification setting, since every image is constrained to have exactly one correct label. In total, we attribute 16% of human errors to this category.

# 14.5.2 Object detection

In some cases, we want to produce a variable number of outputs, corresponding to a variable number of objects of interest that may be present in the image. (This is an example of an open world problem, with an unknown number of objects.)

A canonical example of this is object detection, in which we must return a set of bounding boxes representing the locations of objects of interest, together with their class labels. A special case of this is face detection, where there is only one class of interest. This is illustrated in Figure 14.27a.9

![](images/2a7d26123646f1b357e3c471daa8f15745ad043878fb5be056652e5e459e0f84.jpg)  
Figure 14.27: (a) Illustration of face detection, a special case of object detection. (Photo of author and his wife Margaret, taken at Filoli in California in Feburary, 2018. Image processed by Jonathan Huang using SSD face model.) (b) Illustration of anchor boxes. Adapted from [Zha+20, Sec 12.5].

The simplest way to tackle such detection problems is to convert it into a closed world problem, in which there is a finite number of possible locations (and orientations) any object can be in. These candidate locations are known as anchor boxes. We can create boxes at multiple locations, scales and aspect ratios, as illustrated in Figure 14.27b. For each box, we train the system to predict what category of object it contains (if any); we can also perform regression to predict the offset of the object location from the center of the anchor. (These residual regression terms allow sub-grid spatial localization.)

Abstractly, we are learning a function of the form

$$
f _ { \pmb { \theta } } : \mathbb { R } ^ { H \times W \times K }  [ 0 , 1 ] ^ { A \times A } \times \{ 1 , . . . , C \} ^ { A \times A } \times ( \mathbb { R } ^ { 4 } ) ^ { A \times A }
$$

where $K$ is the number of input channels, $A$ is the number of anchor boxes in each dimension, and $C$ is the number of object types (class labels). For each box location $( i , j )$ , we predict three outputs: an object presence probability, $p _ { i j } \in [ 0 , 1 ]$ , an object category, $y _ { i j } \in \{ 1 , \ldots , C \}$ , and two 2d offset vectors, $\pmb { \delta } _ { i j } \in \mathbb { R } ^ { 4 }$ , which can be added to the centroid of the box to get the top left and bottom right corners.

Several models of this type have been proposed, including the single shot detector model of [Liu+16], and the YOLO (you only look once) model of [Red+16]. Many other methods for object detection have been proposed over the years. These models make different tradeoffs between speed, accuracy, simplicity, etc. See [Hua+17b] for an empirical comparison, and [Zha+18] for a more recent review.

# 14.5.3 Instance segmentation

In object detection, we predict a label and bounding box for each object. In instance segmentation, the goal is to predict the label and 2d shape mask of each object instance in the image, as illustrated in Figure 14.28. This can be done by applying a semantic segmentation model to each detected box,

14.5. Solving other discriminative vision tasks with CNNs \*

![](images/9e3609d0a2df226c93ed4a7e7a66f26a761c8218b987a19329eeea9d1431c17f.jpg)  
Figure 14.28: Illustration of object detection and instance segmentation using Mask R-CNN. From https: // github. com/ matterport/ Mask_ RCNN . Used with kind permission of Waleed Abdulla.

![](images/4a4566357f693964cf717796b5c3df963bbe7ab4e1c2b20ee73817639ab649cd.jpg)  
Figure 14.29: Illustration of an encoder-decoder (aka U-net) CNN for semantic segmentation. The encoder uses convolution (which downsamples), and the decoder uses transposed convolution (which upsamples). From Figure 1 of [BKC17]. Used with kind permission of Alex Kendall.

which has to label each pixel as foreground or background. (See Section 14.5.4 for more details on semantic segmentation.)

# 14.5.4 Semantic segmentation

In semantic segmentation, we have to predict a class label $y _ { i } \in \{ 1 , \ldots , C \}$ for each pixel, where the classes may represent things like sky, road, car, etc. In contrast to instance segmentation, which we discussed in Section 14.5.3, all car pixels get the same label, so semantic segmentation does not differentiate between objects. We can combine semantic segmentation of “stuff” (like sky, road) and instance segmentation of “things” (like car, person) into a coherent framework called “panoptic segmentation” [Kir+19].

A common way to tackle semantic segmentation is to use an encoder-decoder architecture, as illustrated in Figure 14.29. The encoder uses standard convolution to map the input into a small 2d bottleneck, which captures high level properties of the input at a coarse spatial resolution. (This typically uses a technique called dilated convolution that we explain in Section 14.4.1, to capture a

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license large field of view, i.e., more context.) The decoder maps the small 2d bottleneck back to a full-sized output image using a technique called transposed convolution that we explain in Section 14.4.2. Since the bottleneck loses information, we can also add skip connections from input layers to output layers. We can redraw this model as shown in Figure 14.30. Since the overall structure resembles the letter U, this is also known as a U-net [RFB15].

![](images/57607239bd21a13916bc816327b151a6a9c014ae4fa496dfe63ba2eb147a90fa.jpg)  
Figure 14.30: Illustration of the U-Net model for semantic segmentation. Each blue box corresponds to a multi-channel feature map. The number of channels is shown on the top of the box, and the height/width is shown in the bottom left. White boxes denote copied feature maps. The different colored arrows correspond to different operations. From Figure 1 from [RFB15]. Used with kind permission of Olaf Ronenberg.

![](images/73fbd2ccc83bbb99fb1279631dc3f1e5ed92774943afb2f53d048853b4e79372.jpg)  
Figure 14.31: Illustration of a multi-task dense prediction problem. From Figure 1 of [EF15]. Used with kind permission of Rob Fergus.

A similar encoder-decoder architecture can be used for other dense prediction or image-toimage tasks, such as depth prediction (predict the distance from the camera, $z _ { i } \in \mathbb { R }$ , for each pixel $\textit { \textbf { l } }$ ), surface normal prediction (predict the orientation of the surface, $z _ { i } \in \mathbb { R } ^ { 3 }$ , at each image patch), etc. We can of course train one model to solve all of these tasks simultaneously, using multiple output heads, as illustrated in Figure 14.31. (See e.g., [Kok17] for details.)

# 14.5.5 Human pose estimation

We can train an object detector to detect people, and to predict their 2d shape, as represented by a mask. However, we can also train the model to predict the location of a fixed set of skeletal keypoints,

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022 e.g., the location of the head or hands. This is called human pose estimation. See Figure 14.32 for an example. There are several techniques for this, e.g., PersonLab [Pap+18] and OpenPose [Cao+18]. See [Bab19] for a recent review.

![](images/bf1eba933d6bb82c4169839136f4f1dd47dfd6ff7cadaf4bdeba312edb87577e.jpg)  
Figure 14.32: Illustration of keypoint detection for body, hands and face using the OpenPose system. From Figure 8 of [Cao+18]. Used with kind permission of Yaser Sheikh.

We can also predict 3d properties of each detected object. The main limitation is the ability to collect enough labeled training data, since it is difficult for human annotators to label things in 3d. However, we can use computer graphics engines to create simulated images with infinite ground truth 3d annotations (see e.g., [GNK18]).

# 14.6 Generating images by inverting CNNs \*

A CNN trained for image classification is a discriminative model of the form $p ( \boldsymbol { y } | \boldsymbol { x } )$ , which takes as input an image, and returns as output a probability distribution over $C$ class labels. In this section we discuss how to “invert” this model, by converting it into a (conditional) generative image model of the form $p ( { \pmb x } | y )$ . This will allow us to generate images that belong to a specific class. (We discuss more principled approaches to creating generative models for images in the sequel to this book, [Mur23].)

# 14.6.1 Converting a trained classifier into a generative model

We can define a joint distribution over images and labels using $p ( \pmb { x } , y ) = p ( \pmb { x } ) p ( y | \pmb { x } )$ , where $p ( \boldsymbol { y } | \boldsymbol { x } )$ is the CNN classifier, and $p ( { \pmb x } )$ is some prior over images. If we then clamp the class label to a specific value, we can create a conditional generative model using $p ( { \pmb x } | y ) \propto p ( { \pmb x } ) p ( y | { \pmb x } )$ . Note that the discriminative classifier $p ( \boldsymbol { y } | \boldsymbol { x } )$ was trained to “throw away” information, so $p ( \boldsymbol { y } | \boldsymbol { x } )$ is not an invertible function. Thus the prior term $p ( { \pmb x } )$ will play an important role in regularizing this process, as we see in Section 14.6.2.

One way to sample from this model is to use the Metropolis Hastings algorithm (Section 4.6.8.4), treating $\begin{array} { r } { \mathcal { E } _ { c } ( \pmb { x } ) = \log p ( y = c \vert \pmb { x } ) + \log p ( \pmb { x } ) } \end{array}$ as the energy function. Since gradient information is available, we can use a proposal of the form $q ( \pmb { x } ^ { \prime } | \pmb { x } ) = \mathcal { N } ( \pmb { \mu } ( \pmb { x } ) , \epsilon \mathbf { I } )$ , where $\begin{array} { r } { \pmb { \mu } ( \pmb { x } ) = \pmb { x } + \frac { \epsilon } { 2 } \nabla \log \mathcal { E } _ { c } ( \pmb { x } ) } \end{array}$ . This is called the Metropolis-adjusted Langevin algorithm (MALA). As an approximation, we can ignore the rejection step, and accept every proposal. This is called the unadjusted Langevin algorithm, and was used in [Ngu+17] for conditional image generation. In addition, we can scale

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license the gradient of the log prior and log likelihood independently. Thus we get an update over the space of images that looks like a noisy version of SGD, except we take derivatives wrt the input pixels (using Equation (13.50)), instead of the parameters:

$$
{ \pmb x } _ { t + 1 } = { \pmb x } _ { t } + \epsilon _ { 1 } \frac { \partial \log p ( { \pmb x } _ { t } ) } { \partial { \pmb x } _ { t } } + \epsilon _ { 2 } \frac { \partial \log p ( y = c | { \pmb x } _ { t } ) } { \partial { \pmb x } _ { t } } + \mathcal { N } ( \mathbf { 0 } , \epsilon _ { 3 } ^ { 2 } { \mathbf I } )
$$

We can interpret each term in this equation as follows: the $\epsilon _ { 1 }$ term ensures the image is plausible under the prior, the $\epsilon _ { 2 }$ term ensures the image is plausible under the likelihood, and the $\epsilon _ { 3 }$ term is a noise term, in order to generate diverse samples. If we set $\epsilon _ { 3 } = 0$ , the method becomes a deterministic algorithm to (approximately) generate the “most likely image” for this class.

# 14.6.2 Image priors

In this section, we discuss various kinds of image priors that we can use to regularize the ill-posed problem of inverting a classifier. These priors, together with the image that we start the optimization from, will determine the kinds of outputs that we generate.

# 14.6.2.1 Gaussian prior

Just specifying the class label is not enough information to specify the kind of images we want. We also need a prior $p ( { \pmb x } )$ over what constitutes a “plausible” image. The prior can have a large effect on the quality of the resulting image, as we show below.

Arguably the simplest prior is $p ( \pmb { x } ) = \mathcal { N } ( \pmb { x } | \mathbf { 0 } , \mathbf { I } )$ , as suggested in [SVZ14]. (This assumes the image pixels have been centered.) This can prevent pixels from taking on extreme values. In this case, the update due to the prior term has the form

$$
\nabla _ { \pmb { x } } \log { p ( \pmb { x } _ { t } ) } = \nabla _ { \pmb { x } } \left[ - \frac { 1 } { 2 } | | \pmb { x } _ { t } - \pmb { 0 } | | _ { 2 } ^ { 2 } \right] = - \pmb { x } _ { t }
$$

Thus the overall update (assuming $\epsilon _ { 2 } = 1$ and $\epsilon _ { 3 } = 0$ ) has the form

$$
\mathbf { \Delta } \mathbf { x } _ { t + 1 } = ( 1 - \epsilon _ { 1 } ) \mathbf { \Delta } \mathbf { x } _ { t } + { \frac { \partial \log p ( y = c | \mathbf { \Delta } \mathbf { x } _ { t } ) } { \partial \mathbf { \Delta } \mathbf { x } _ { t } } }
$$

See Figure 14.33 for some samples generated by this method.

# 14.6.2.2 Total variation (TV) prior

We can generate slightly more realistic looking images if we use additional regularizers. [MV15; MV16] suggested computing the total variation or TV norm of the image. This is equal to the integral of the per-pixel gradients, which can be approximated as follows:

$$
\mathrm { T V } ( \boldsymbol { x } ) = \sum _ { i j k } ( x _ { i j k } - x _ { i + 1 , j , k } ) ^ { 2 } + ( x _ { i j k } - x _ { i , j + 1 , k } ) ^ { 2 }
$$

where $x _ { i j k }$ is the pixel value in row $i$ , column $j$ and channel $k$ (for RGB images). We can rewrite this in terms of the horizontal and vertical Sobel edge detector applied to each channel:

$$
\mathrm { T V } ( \pmb { x } ) = \sum _ { k } | | \mathbf { H } ( \pmb { x } _ { : , : , k } ) | | _ { F } ^ { 2 } + | | \mathbf { V } ( \pmb { x } _ { : , : , k } ) | | _ { F } ^ { 2 }
$$

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

![](images/37bd5e12f0d7298ec170546a0390e42172ef52edb615bf66e7d80b3419438a44.jpg)  
Figure 14.34: Illustration of total variation norm. (a) Input image: a green sea turtle (Used with kind permission of Wikimedia author P. Lindgren). (b) Horizontal deltas. (c) Vertical deltas. Adapted from https: // www. tensorflow. org/ tutorials/ generative/ style_ transfer .

![](images/e8631eb96ccd8495a600990c6a2d0e6a0df70ed2ccbf17b4336d09fd5db6b578.jpg)  
Figure 14.33: Images that maximize the probability of ImageNet classes “goose” and “ostrich” under a simple Gaussian prior. From http: // yosinski. com/ deepvis . Used with kind permission of Jeff Clune.

See Figure 14.34 for an illustration of these edge detectors. Using $p ( \pmb { x } ) \propto \exp ( - \mathrm { T V } ( \pmb { x } ) )$ discourages images from having high frequency artefacts. In [Yos+15], they use Gaussian blur instead of TV norm, but this has a similar effect.

In Figure 14.35 we show some results of optimizing $\log p ( y = c , \pmb { x } )$ using a TV prior and a CNN likelihood for different class labels $c$ starting from random noise.

# 14.6.3 Visualizing the features learned by a CNN

It is interesting to ask what the “neurons” in a CNN are learning. One way to do this is to start with a random image, and then to optimize the input pixels so as to maximize the average activation of a particular neuron. This is called activation maximization (AM), and uses the same technique as in Section 14.6.1 but fixes an internal node to a specific value, rather than clamping the output class label.

Figure 14.36 illustrates the output of this method (with the TV prior) when applied to the AlexNet CNN trained on Imagenet classification. We see that, as the depth increases, neurons are learning to recognize simple edges/blobs, then texture patterns, then object parts, and finally whole objects. This is believed to be roughly similar to the hierarchical structure of the visual cortex (see e.g., [Kan+12]).

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

![](images/fe938391290f0edbf23d799545ad0e59bfc604abe4f8aaef2b4c8f21f59622d9.jpg)  
Figure 14.35: Images that maximize the probability of certain ImageNet classes under a TV prior. From https: // research. googleblog. com/ 2015/ 06/ inceptionism-going-deeper-into-neural. html . Used with kind permission of Alexander Mordvintsev.

![](images/1577b6d5c0981480b22e67c4f55512e3725141e356177e26fe0dc9baf9b1685f.jpg)  
Figure 14.36: We visualize “optimal stimuli” for neurons in layers Conv 1, 3, 5 and fc8 in the AlexNet architecture, trained on the ImageNet dataset. For Conv5, we also show retrieved real images (under the column “data driven”) that produce similar activations. Based on the method in [MV16]. Used with kind permission of Donglai Wei.

An alternative to optimizing in pixel space is to search the training set for images that maximally activate a given neuron. This is illustrated in Figure 14.36 for the Conv5 layer. For more information on feature visualization see e.g., [OMS17].

# 14.6.4 Deep Dream

So far we have focused on generating images which maximize the class label or some other neuron of interest. In this section we tackle a more artistic application, in which we want to generate versions of an input image that emphasize certain features.

To do this, we view our pre-trained image classifier as a feature extractor. Based on the results in Section 14.6.3, we know the activity of neurons in different layers correspond to different kinds

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022 of features in the image. Suppose we are interested in “amplifying” features from layers $\textit { l } \in \textit { L }$ . We can do this by defining an energy or loss function of the form $\begin{array} { r } { \mathcal { L } ( \pmb { x } ) = \sum _ { l \in \mathcal { L } } \overline { { \phi } } _ { l } ( \pmb { x } ) } \end{array}$ , where $\begin{array} { r } { \overline { { \phi } } _ { l } = \frac { 1 } { H W C } \sum _ { h w c } \phi _ { l h w c } ( { \pmb x } ) } \end{array}$ is the feature vector for layer $\it { l }$ . We can now use gradient descent to optimize this energy. The resulting process is called DeepDream [MOT15], since the model amplifies features that were only hinted at in the original image and then creates images with more and more of them.10

![](images/2bac21914cd26c7e34c1a957cda8a0fe9b3d17b1eb7d4922266bdfcc1b796d14.jpg)  
Figure 14.37: Illustration of DeepDream. The CNN is an Inception classifier trained on ImageNet. (a) Starting image of an Aurelia aurita (also called moon jelly). (b) Image generated after 10 iterations. (c) Image generated after 50 iterations. From https: // en. wikipedia. org/ wiki/ DeepDream . Used with kind permission of Wikipedia author Martin Thoma.

Figure 14.37 shows an example. We start with an image of a jellyfish, which we pass into a CNN that was trained to classify ImageNet images. After several iterations, we generate some image which is a hybrid of the input and the kinds of “hallucinations” we saw in Figure 14.33; these hallucinations involve dog parts, since ImageNet has so many kinds of dogs in its label set. See [Tho16] for details, and https://deepdreamgenerator.com for a fun web-based demo.

# 14.6.5 Neural style transfer

The DeepDream system in Figure 14.37 shows one way that CNNs can be used to create “art”. However, it is rather creepy. In this section, we discuss a related approach that gives the user more control. In particular, the user has to specify a reference “style image” $\scriptstyle { \mathbf { x } } _ { s }$ and “content image” $x _ { c }$ . The system will then try to generate a new image $_ { x }$ that “re-renders” $x _ { c }$ in the style of $x _ { s }$ . This is called neural style transfer, and is illustrated in Figure 14.38 and Figure 14.39. This technique was first proposed in [GEB16], and there are now many papers on this topic; see [Jin+17] for a recent review.

# 14.6.5.1 How it works

Style transfer works by optimizing the following energy function:

$$
\begin{array} { r } { \mathcal { L } ( \pmb { x } | \pmb { x } _ { s } , \pmb { x } _ { c } ) = \lambda _ { T V } \mathcal { L } _ { \mathrm { T V } } ( \pmb { x } ) + \lambda _ { c } \mathcal { L } _ { \mathrm { c o n t e n t } } ( \pmb { x } , \pmb { x } _ { c } ) + \lambda _ { s } \mathcal { L } _ { \mathrm { s t y l e } } ( \pmb { x } , \pmb { x } _ { s } ) } \end{array}
$$

See Figure 14.40 for a high level illustration.

![](images/c4f07b67aa2e0ddc165ed7a40910926886925d7efa9e13470400b13c56082ce9.jpg)  
Figure 14.38: Example output from a neural style transfer system. (a) Content image: a green sea turtle (Used with kind permission of Wikimedia author P. Lindgren). (b) Style image: a painting by Wassily Kandinsky called “Composition 7”. (c) Output of neural style generation. Adapted from https: // www. tensorflow. org/ tutorials/ generative/ style_ transfer .

![](images/0b9562f3a7cd6fbfe57535dccd86b6d3c07465843d7951145f6f3cdc0a565a1e.jpg)  
Figure 14.39: Neural style transfer applied to photos of the “production team”, who helped create code and demos for this book and its sequel. From top to bottom, left to right: Kevin Murphy (the author), Mahmoud Soliman, Aleyna Kara, Srikar Jilugu, Drishti Patel, Ming Liang Ang, Gerardo Durán-Martín, Coco (the team dog). Each content photo used a different artistic style. Adapted from https: // www. tensorflow. org/ tutorials/ generative/ style_ transfer .

![](images/a71eb953c0af4b29f30e7582bb1c9bc1b8899180f32bc13715947e9a66676e5a.jpg)  
Figure 14.40: Illustration of how neural style transfer works. Adapted from Figure 12.12.2 of [Zha+20].

![](images/ad4c463d4fe439430345167405bccbb86ef2625748d31a15e19b76b6fbb97ea8.jpg)  
Figure 14.41: Schematic representation of 3 kinds of feature maps for 3 different input images. Adapted from Figure 5.16 of [Fos19].

The first term in Equation (14.33) is the total variation prior discussed in Section 14.6.2.2. The second term measures how similar $_ { x }$ is to $x _ { c }$ by comparing feature maps of a pre-trained CNN $\phi ( { \pmb x } )$ in the relevant “content layer” $\it { l }$ :

$$
\mathcal { L } _ { \mathrm { c o n t e n t } } ( { \pmb x } , { \pmb x } _ { c } ) = \frac { 1 } { C _ { \ell } H _ { \ell } W _ { \ell } } | | \phi _ { \ell } ( { \pmb x } ) - \phi _ { \ell } ( { \pmb x } _ { c } ) | | _ { 2 } ^ { 2 }
$$

Finally we have to define the style term. We can interpret visual style as the statistical distribution of certain kinds of image features. The location of these features in the image may not matter, but their co-occurence does. This is illustrated in Figure 14.41. It is clear (to a human) that image 1 is more similar in style to image 2 than to image 3. Intuitively this is because both image 1 and image 2 have spiky green patches in them, whereas image 3 has spiky things that are not green.

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

To capture the co-occurence statistics we compute the Gram matrix for an image using feature maps from a specific layer $\ell$ :

$$
G _ { \ell } ( { \pmb x } ) _ { c , d } = \frac { 1 } { H _ { \ell } W _ { \ell } } \sum _ { h = 1 } ^ { H _ { \ell } } \sum _ { w = 1 } ^ { W _ { \ell } } \phi _ { \ell } ( { \pmb x } ) _ { h , w , c } \phi _ { \ell } ( { \pmb x } ) _ { h , w , d }
$$

The Gram matrix is a $C _ { \ell } \times C _ { \ell }$ matrix which is proportional to the uncentered covariance of the $C _ { \ell }$ -dimensional feature vectors sampled over each of the $H _ { \ell } W _ { \ell }$ locations.

Given this, we define the style loss for layer $\ell$ as follows:

$$
\mathcal { L } _ { \mathrm { s t y l e } } ^ { \ell } ( { \pmb x } , { \pmb x } _ { s } ) = | | { \bf G } _ { \ell } ( { \pmb x } ) - { \bf G } _ { \ell } ( { \pmb x } _ { s } ) | | _ { F } ^ { 2 }
$$

Finally, we define the overall style loss as a sum over the losses for a set $\boldsymbol { S }$ of layers:

$$
\mathcal { L } _ { \mathrm { s t y l e } } ( { \pmb x } , { \pmb x } _ { s } ) = \sum _ { \ell \in S } \mathcal { L } _ { \mathrm { s t y l e } } ^ { \ell } ( { \pmb x } , { \pmb x } _ { s } )
$$

For example, in Figure 14.40, we compute the style loss at layers 1 and 3. (Lower layers will capture visual texture, and higher layers will capture object layout.)

# 14.6.5.2 Speeding up the method

In [GEB16], they used L-BFGS (Section 8.3.2) to optimize Equation (14.33), starting from white noise. We can get faster results if we use an optimizer such as Adam instead of BFGS, and initialize from the content image instead of white noise. Nevertheless, running an optimizer for every new style and content image is slow. Several papers (see e.g., [JAFF16; Uly+16; UVL16; LW16]) have proposed to train a neural network to directly predict the outcome of this optimization, rather than solving it for each new image pair. (This can be viewed as a form of amortized optimization.) In particular, for every style image $\mathbf { \boldsymbol { x } } _ { s }$ , we fit a model $f _ { s }$ such that $f _ { s } ( \pmb { x } _ { c } ) = \mathrm { a r g m i n } _ { \pmb { x } } \mathcal { L } ( \pmb { x } | \pmb { x } _ { s } , \pmb { x } _ { c } )$ . We can then apply this model to new content images without having to reoptimize.

More recently, [DSK16] has shown how it is possible to train a single network that takes as input both the content and a discrete representation $s$ of the style, and then produces $f ( { \pmb x } _ { c } , s ) =$ argminx $\mathcal { L } ( \pmb { x } | s , \pmb { x } _ { c } )$ as the output. This avoids the need to train a separate network for every style image. The key idea is to standardize the features at a given layer using scale and shift parameters that are style specific. In particular, we use the following conditional instance normalization transformation:

$$
\mathrm { C I N } ( \phi ( \pmb { x } _ { c } ) , s ) = \gamma _ { s } \left( \frac { \phi ( \pmb { x } _ { c } ) - \mu ( \phi ( \pmb { x } _ { c } ) ) } { \sigma ( \phi ( \pmb { x } _ { c } ) ) } \right) + \beta _ { s }
$$

where $\mu ( \phi ( { \pmb x } _ { c } ) )$ is the mean of the features in a given layer, $\sigma ( \phi ( { \pmb x } _ { c } ) )$ is the standard deviation, and $\beta _ { s }$ and $\gamma _ { s }$ are parameters for style type $s$ . (See Section 14.2.4.2 for more details on instance normalization.) Surprisingly, this simple trick is enough to capture many kinds of styles.

The drawback of the above technique is that it only works for a fixed number of discrete styles. [HB17] proposed to generalize this by replacing the constants $\beta _ { s }$ and $\gamma _ { s }$ by the output of another CNN, which takes an arbitrary style image $\scriptstyle { \mathbf { x } } _ { s }$ as input. That is, in Equation (14.38), we set $\beta _ { s } = f _ { \beta } ( \phi ( \pmb { x } _ { s } ) )$

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

and $\gamma _ { s } = f _ { \gamma } ( \phi ( \pmb { x } _ { s } ) )$ , and we learn the parameters $\beta$ and $\gamma$ along with all the other parameters. The model becomes

$$
\mathrm { A I N } ( \phi ( \pmb { x } _ { c } ) , \phi ( \pmb { x } _ { s } ) ) = f _ { \gamma } ( \phi ( \pmb { x } _ { s } ) ) \left( \frac { \phi ( \pmb { x } _ { c } ) - \mu ( \phi ( \pmb { x } _ { c } ) ) } { \sigma ( \phi ( \pmb { x } _ { c } ) ) } \right) + f _ { \beta } ( \phi ( \pmb { x } _ { s } ) )
$$

They call their method adaptive instance normalization.

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

# 15 Neural Networks for Sequences

# 15.1 Introduction

In this chapter, we discuss various kinds of neural networks for sequences. We will consider the case where the input is a sequence, the output is a sequence, or both are sequences. Such models have many applications, such as machine translation, speech recognition, text classification, image captioning, etc. Our presentation borrows from parts of [Zha+20], which should be consulted for more details.

# 15.2 Recurrent neural networks (RNNs)

A recurrent neural network or RNN is a neural network which maps from an input space of sequences to an output space of sequences in a stateful way. That is, the prediction of output ${ \mathbf { } } _ { \mathbf { } } \mathbf { \nabla } _  \mathbf { } \mathbf { } \mathbf { } \mathbf { } \mathbf { } \mathbf { } \mathbf { } \mathbf { } \mathbf { } \mathbf { } \mathbf { } \mathbf { } \mathbf { } \mathbf { } \mathbf { } \mathbf { } \mathbf { } \mathbf { } \mathbf { } \mathbf { } \mathbf { } \mathbf { } \mathbf { } \mathbf { } \mathbf { } \mathbf { } \mathbf { } \mathbf { } \mathbf { } \mathbf { } \mathbf { } \mathbf { } \mathbf { } \mathbf { } \mathbf { } \nabla _  \mathbf { } \mathbf { } \mathbf { } \mathbf { } \mathbf { } \mathbf { } \nabla _  \mathbf { } \mathbf { } \mathbf { } \mathbf { } \mathbf { } \mathbf { } \mathbf { } \nabla _  \mathbf { } \mathbf { } \mathbf { } \mathbf { } \mathbf { } \mathbf { } \nabla _  \mathbf { } \mathbf { } \mathbf { } \mathbf { } \mathbf { } \nabla \mathbf { } \mathbf { } \mathbf { } \mathbf { } \nabla \mathbf { } \mathbf { } \mathbf { } \nabla \mathbf { } \mathbf { } \mathbf { } \nabla \mathbf { } \mathbf { } \nabla \mathbf { } \mathbf { } \nabla \mathbf { } \mathbf { } \nabla \mathbf { } \mathbf { } \nabla \mathbf { } \nabla \mathbf { } \mathbf { } \nabla \mathbf { } \nabla \mathbf { } \nabla \mathbf { } \mathbf { } \nabla \mathbf { } \nabla \mathbf { } \mathbf { } \nabla \mathbf { } \nabla \mathbf { } \nabla \mathbf { } \nabla \mathbf { } \nabla \mathbf { } \nabla \mathbf { } \nabla \mathbf { } \nabla \mathbf { } \nabla \nabla \mathbf { } \nabla \mathbf { } \nabla \nabla \mathbf { } \nabla \nabla \mathbf  \nabla \nabla \nabla \nabla \mathbf { } \nabla \mathbf { } \nabla \nabla \mathbf \nabla \nabla \mathbf { } \nabla \nabla \mathbf  \nabla \nabla \nabla \nabla \mathbf { } \nabla \nabla \mathbf \nabla \nabla \nabla \mathbf { } \nabla \nabla \nabla \mathbf \nabla \nabla \nabla \nabla \mathbf \nabla \nabla \nabla \nabla \nabla \mathbf \nabla \nabla \nabla \nabla \mathbf \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla$ depends not only on the input $\scriptstyle { \mathbf { x } } _ { t }$ , but also on the hidden state of the system, $\boldsymbol { h } _ { t }$ , which gets updated over time, as the sequence is processed. Such models can be used for sequence generation, sequence classification, and sequence translation, as we explain below.1

# 15.2.1 Vec2Seq (sequence generation)

In this section, we discuss how to learn functions of the form $f _ { \pmb \theta } : \mathbb R ^ { D }  \mathbb R ^ { N _ { \infty } C }$ , where $D$ is the size of the input vector, and the output is an arbitrary-length sequence of vectors, each of size $C$ . (Note that words are discrete tokens, but can be converted to real-valued vectors as we discuss in Section 1.5.4.) We call these vec2seq models, since they map a vector to a sequence.

The output sequence $\mathbf { \pmb { y } } _ { 1 : T }$ is generated one token at a time. At each step we sample $\tilde { y } _ { t }$ from the hidden state $\mathbf { } h _ { t }$ of the model, and then “feed it back in” to the model to get the new state $\boldsymbol { h } _ { t + 1 }$ (which also depends on the input $_ { x }$ ). See Figure 15.1 for an illustration. In this way the model defines a conditional generative model of the form $p ( { \pmb y } _ { 1 : T } | { \pmb x } )$ , which captures dependencies between the output tokens. We explain this in more detail below.

![](images/3b1b7bb0e3e0aceb7009110f10a3dccaa745587db0eea00b20f398ea80d62736.jpg)  
Figure 15.1: Recurrent neural network (RNN) for generating a variable length output sequence y1:T given an optional fixed length input vector $_ { \pmb { x } }$ .

# 15.2.1.1 Models

For notational simplicity, let $T$ be the length of the output (with the understanding that this is chosen dynamically). The RNN then corresponds to the following conditional generative model:

$$
p ( { \boldsymbol y } _ { 1 : T } | { \boldsymbol x } ) = \sum _ { h _ { 1 : T } } p ( { \boldsymbol y } _ { 1 : T } , h _ { 1 : T } | { \boldsymbol x } ) = \sum _ { h _ { 1 : T } } \prod _ { t = 1 } ^ { T } p ( { \boldsymbol y } _ { t } | h _ { t } ) p ( h _ { t } | h _ { t - 1 } , { \boldsymbol y } _ { t - 1 } , { \boldsymbol x } )
$$

where $\mathbf { } h _ { t }$ is the hidden state, and where we define $p ( h _ { 1 } | h _ { 0 } , y _ { 0 } , x ) = p ( h _ { 1 } | x )$ as the initial hidden state distribution (often deterministic).

The output distribution is usually given by

$$
p ( \pmb { y } _ { t } | \pmb { h } _ { t } ) = \mathrm { C a t } ( \pmb { y } _ { t } | \mathrm { s o f t m a x } ( \mathbf { W } _ { h y } \pmb { h } _ { t } + \pmb { b } _ { y } ) )
$$

where $\mathbf { W } _ { h y }$ are the hidden-to-output weights, and $b _ { y }$ is the bias term. However, for real-valued outputs, we can use

$$
p ( \pmb { y } _ { t } | \pmb { h } _ { t } ) = \mathcal { N } ( \pmb { y } _ { t } | \mathbf { W } _ { h y } \pmb { h } _ { t } + \pmb { b } _ { y } , \sigma ^ { 2 } \mathbf { I } )
$$

We assume the hidden state is computed deterministically as follows:

$$
p ( h _ { t } | h _ { t - 1 } , y _ { t - 1 } , x ) = \mathbb { I } \left( h _ { t } = f ( h _ { t - 1 } , y _ { t - 1 } , x ) \right)
$$

for some deterministic function $f$ . The update function $f$ is usually given by

$$
\begin{array} { r } { \pmb { h } _ { t } = \varphi ( \mathbf { W } _ { x h } [ \pmb { x } ; \pmb { y } _ { t - 1 } ] + \mathbf { W } _ { h h } \pmb { h } _ { t - 1 } + \pmb { b } _ { h } ) } \end{array}
$$

where $\mathbf { W } _ { h h }$ are the hidden-to-hidden weights, $\mathbf { W } _ { x h }$ are the input-to-hidden weights, and $ { \boldsymbol { b } } _ { h }$ are the bias terms. See Figure 15.1 for an illustration, and rnn_jax.ipynb for some code.

Note that ${ \mathbf { } } _ { \mathbf { } } \mathbf { \mathcal { { y } } } _ { t }$ depends on $\mathbf { } h _ { t }$ , which depends on ${ \mathbf { } } ^ { y _ { t - 1 } }$ , which depends on $\pmb { h } _ { t - 1 }$ , and so on. Thus ${ \mathbf { } } _ { \mathbf { } } \mathbf { \nabla } _  \mathbf { } \mathbf { } \mathbf { } \mathbf { } \mathbf { } \mathbf { } \mathbf { } \mathbf { } \mathbf { } \mathbf { } \mathbf { } \mathbf { } \mathbf { } \mathbf { } \mathbf { } \mathbf { } \mathbf { } \mathbf { } \mathbf { } \mathbf { } \mathbf { } \mathbf { } \mathbf { } \mathbf { } \mathbf { } \mathbf { } \mathbf { } \mathbf { } \mathbf { } \mathbf { } \mathbf { } \mathbf { } \mathbf { } \mathbf { } \mathbf { } \nabla _  \mathbf { } \mathbf { } \mathbf { } \mathbf { } \mathbf { } \mathbf { } \nabla _  \mathbf { } \mathbf { } \mathbf { } \mathbf { } \mathbf { } \mathbf { } \mathbf { } \nabla _  \mathbf { } \mathbf { } \mathbf { } \mathbf { } \mathbf { } \mathbf { } \nabla _  \mathbf { } \mathbf { } \mathbf { } \mathbf { } \mathbf { } \nabla \mathbf { } \mathbf { } \mathbf { } \mathbf { } \nabla \mathbf { } \mathbf { } \mathbf { } \nabla \mathbf { } \mathbf { } \mathbf { } \nabla \mathbf { } \mathbf { } \nabla \mathbf { } \mathbf { } \nabla \mathbf { } \mathbf { } \nabla \mathbf { } \mathbf { } \nabla \mathbf { } \nabla \mathbf { } \mathbf { } \nabla \mathbf { } \nabla \mathbf { } \nabla \mathbf { } \mathbf { } \nabla \mathbf { } \nabla \mathbf { } \mathbf { } \nabla \mathbf { } \nabla \mathbf { } \nabla \mathbf { } \nabla \mathbf { } \nabla \mathbf { } \nabla \mathbf { } \nabla \mathbf { } \nabla \mathbf { } \nabla \nabla \mathbf { } \nabla \mathbf { } \nabla \nabla \mathbf { } \nabla \nabla \mathbf  \nabla \nabla \nabla \nabla \mathbf { } \nabla \mathbf { } \nabla \nabla \mathbf \nabla \nabla \mathbf { } \nabla \nabla \mathbf  \nabla \nabla \nabla \nabla \mathbf { } \nabla \nabla \mathbf \nabla \nabla \nabla \mathbf { } \nabla \nabla \nabla \mathbf \nabla \nabla \nabla \nabla \mathbf \nabla \nabla \nabla \nabla \nabla \mathbf \nabla \nabla \nabla \nabla \mathbf \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla$ implicitly depends on all past observations (as well as the optional fixed input $_ { x }$ ). Thus an RNN overcomes the limitations of standard Markov models, in that they can have unbounded memory. This makes RNNs theoretically as powerful as a Turing machine [SS95; PMB19]. In practice,

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

the githa some thong the time traveller held in his hand was a glitteringmetallic framework scarcely larger than a small clock and verydelicately made there was ivory in it and the latter than s bettyre tat howhong s ie time thave ler simk you a dimensions le ghat dionthat shall travel indifferently in any direction of space and timeas the driver determinesfilby contented himself with laughterbut i have experimental verification said the time travellerit would be remarkably convenient for the histo

Figure 15.2: Example output of length 500 generated from a character level RNN when given the prefix “the”. We use greedy decoding, in which the most likely character at each step is computed, and then fed back into the model. The model is trained on the book The Time Machine by H. G. Wells. Generated by rnn_jax.ipynb.

however, the memory length is determined by the size of the latent state and the strength of the parameters; see Section 15.2.7 for further discussion of this point.

When we generate from an RNN, we sample from $\tilde { \pmb { y } } _ { t } \sim p ( \pmb { y } _ { t } | \pmb { h } _ { t } )$ , and then “feed in” the sampled value into the hidden state, to deterministically compute $h _ { t + 1 } = f ( h _ { t } , \tilde { y } _ { t } , \boldsymbol { x } )$ , from which we sample $\tilde { \pmb { y } } _ { t + 1 } \sim p ( \pmb { y } _ { t + 1 } | \pmb { h } _ { t + 1 } )$ , etc. Thus the only stochasticity in the system comes from the noise in the observation (output) model, which is fed back to the system in each step. (However, there is a variant, known as a variational RNN [Chu+15], that adds stochasticity to the dynamics of $\mathbf { } h _ { t }$ independent of the observation noise.)

# 15.2.1.2 Applications

RNNs can be used to generate sequences unconditionally (by setting ${ \pmb x } = \emptyset$ ) or conditionally on $_ { x }$ . Unconditional sequence generation is often called language modeling; this refers to learning joint probability distributions over sequences of discrete tokens, i.e., models of the form $p ( y _ { 1 } , \dots , y _ { T } )$ . (See also Section 3.6.1.2, where we discuss using Markov chains for language modeling.)

Figure 15.2 shows a sequence generated from a simple RNN trained on the book The Time Machine by H. G. Wells. (This is a short science fiction book, with just 32,000 words and 170k characters.) We see that the generated sequence looks plausible, even though it is not very meaningful. By using more sophisticated RNN models (such as those that we discuss in Section 15.2.7.1 and Section 15.2.7.2), and by training on more data, we can create RNNs that give state-of-the-art performance on the language modeling task [CNB17]. (In the language modeling community, performance is usually measured by perplexity, which is just the exponential of the average per-token negative log likelihood; see Section 6.1.5 for more information.)

We can also make the generated sequence depend on some kind of input vector $_ { x }$ . For example, consider the task of image captioning: in this case, $_ { x }$ is some embedding of the image computed by a CNN, as illustrated in Figure 15.3. See e.g., [Hos+19; LXW19] for a review of image captioning methods, and https://bit.ly/2Wvs1GK for a tutorial with code.

It is also possible to use RNNs to generate sequences of real-valued feature vectors, such as pen strokes for hand-written characters [Gra13] and hand-drawn shapes [HE18]. This can also be useful for time series forecasting real-value sequences.

# 15.2.2 Seq2Vec (sequence classification)

In this section, we assume we have a single fixed-length output vector $\mathbf { \nabla } _ { \mathbf { \boldsymbol { y } } }$ we want to predict, given a variable length sequence as input. Thus we want to learn a function of the form $f _ { \pmb \theta } : \mathbb R ^ { T ^ { \smash { \prime } } D }  \mathbb R ^ { C }$ . We

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

![](images/8a4664e717c92138c93bff23db4ce2eecb2e4f88e147b6b1988cdef4dc760c3f.jpg)  
Figure 15.3: Illustration of a CNN-RNN model for image captioning. The pink boxes labeled “LSTM” refer to a specific kind of RNN that we discuss in Section 15.2.7.2. The pink boxes labeled $W _ { e m b }$ refer to embedding matrices for the (sampled) one-hot tokens, so that the input to the model is a real-valued vector. From https: // bit. ly/ 2FKnqHm . Used with kind permission of Yunjey Choi.

![](images/740f1f9723fe72b9a91b472795849553a1196ee82b303ecc26ffd7191da489f7.jpg)  
Figure 15.4: (a) RNN for sequence classification. (b) Bi-directional RNN for sequence classification.

call this a seq2vec model. We will focus on the case where the output is a class label, $y \in \{ 1 , \ldots , C \}$ , for notational simplicity.

The simplest approach is to use the final state of the RNN as input to the classifier:

$$
p ( y | { \bf x } _ { 1 : T } ) = \mathrm { C a t } ( y | \mathrm { s o f t m a x } ( \mathbf { W } h _ { T } ) )
$$

See Figure 15.4a for an illustration.

We can often get better results if we let the hidden states of the RNN depend on the past and future context. To do this, we create two RNNs, one which recursively computes hidden states in the forwards direction, and one which recursively computes hidden states in the backwards direction. This is called a bidirectional RNN [SP97].

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

![](images/ea3b2533d88c6b6ac5407219236bce17011ff4287804b5de26bf041fb253ea2c.jpg)  
Figure 15.5: (a) RNN for transforming a sequence to another, aligned sequence. (b) Bi-directional RNN for the same task.

More precisely, the model is defined as follows:

$$
\begin{array} { r } { \pmb { h } _ { t } ^ { \right. } = \varphi ( \mathbf { W } _ { x h } ^ { \right. } \pmb { x } _ { t } + \mathbf { W } _ { h h } ^ { \right. } \pmb { h } _ { t - 1 } ^ { \right. } + \pmb { b } _ { h } ^ { \right. } ) } \\ { \pmb { h } _ { t } ^ { \left. } = \varphi ( \mathbf { W } _ { x h } ^ { \left. } \pmb { x } _ { t } + \mathbf { W } _ { h h } ^ { \left. } \pmb { h } _ { t + 1 } ^ { \left. } + \pmb { b } _ { h } ^ { \left. } ) } \end{array}
$$

We can then define ${ \pmb h } _ { t } = [ { \pmb h } _ { t } ^ { \right. } , { \pmb h } _ { t } ^ { \left. } ]$ to be the representation of the state at time $t$ , taking into account past and future information. Finally we average pool over these hidden states to get the final classifier:

$$
\begin{array} { c } { \displaystyle p ( { \boldsymbol y } | { \boldsymbol x } _ { 1 : T } ) = \mathrm { C a t } ( { \boldsymbol y } | { \bf W } \mathrm { s o f t m a x } ( \overline { { { \boldsymbol h } } } ) ) } \\ { \overline { { { \boldsymbol h } } } = \frac { 1 } { T } \displaystyle \sum _ { t = 1 } ^ { T } h _ { t } } \end{array}
$$

See Figure 15.4b for an illustration, and rnn_sentiment_jax.ipynb for some code. (This is similar to the 1d CNN text classifier1 in Section 15.3.1.)

# 15.2.3 Seq2Seq (sequence translation)

In this section, we consider learning functions of the form $f _ { \pmb { \theta } } : \mathbb { R } ^ { T D }  \mathbb { R } ^ { T ^ { \prime } C }$ . We consider two cases: one in which $T ^ { \prime } = T$ , so the input and output sequences have the same length (and hence are aligned), and one in which $T ^ { \prime } \neq T$ , so the input and output sequences have different lengths. This is called a seq2seq problem.

# 15.2.3.1 Aligned case

In this section, we consider the case where the input and output sequences are aligned. We can also think of it as dense sequence labeling, since we predict one label per location. It is straightforward to modify an RNN to solve this task, as shown in Figure 15.5a. This corresponds to

$$
p ( \pmb { y } _ { 1 : T } | \pmb { x } _ { 1 : T } ) = \sum _ { \pmb { h } _ { 1 : T } } \prod _ { t = 1 } ^ { T } p ( \pmb { y } _ { t } | \pmb { h } _ { t } ) \mathbb { I } \left( \pmb { h } _ { t } = f ( \pmb { h } _ { t - 1 } , \pmb { x } _ { t } ) \right)
$$

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

![](images/dafa83a89c623d7d98584032505325bd1c4af4d2be9952ce393e8167ae3b507f.jpg)  
Figure 15.6: Illustration of a deep RNN. Adapted from Figure 9.3.1 of [Zha+20].

![](images/677a4184c39100f0edba3175e9485ca40fd444b7143eb92298bbb393bae5a7a7.jpg)  
Figure 15.7: Encoder-decoder RNN architecture for mapping sequence ${ \pmb x } _ { 1 : T }$ to sequence $\mathbf { \mathit { y } } _ { 1 : T ^ { \prime } }$ .

where we define $h _ { 1 } = f ( h _ { 0 } , x _ { 1 } ) = f _ { 0 } ( { \pmb x } _ { 1 } )$ to be the initial state.

Note that ${ \mathbf { } } _ { \mathbf { } } \mathbf { \nabla } _  \mathbf { } \mathbf { } \mathbf { } \mathbf { } \mathbf { } \mathbf { } \mathbf { } \mathbf { } \mathbf { } \mathbf { } \mathbf { } \mathbf { } \mathbf { } \mathbf { } \mathbf { } \mathbf { } \mathbf { } \mathbf { } \mathbf { } \mathbf { } \mathbf { } \mathbf { } \mathbf { } \mathbf { } \mathbf { } \mathbf { } \mathbf { } \mathbf { } \mathbf { } \mathbf { } \mathbf { } \mathbf { } \mathbf { } \nabla _  \mathbf { } \mathbf { } \mathbf { } \mathbf { } \mathbf { } \mathbf { } \nabla _  \mathbf { } \mathbf { } \mathbf { } \mathbf { } \mathbf { } \mathbf { } \nabla _  \mathbf { } \mathbf { } \mathbf { } \mathbf { } \mathbf { } \mathbf { } \nabla _  \mathbf { } \mathbf { } \mathbf { } \mathbf { } \mathbf { } \mathbf { } \nabla \mathbf { } \mathbf { } \mathbf { } \mathbf { } \nabla \mathbf { } \mathbf { } \mathbf { } \nabla \mathbf { } \mathbf { } \mathbf { } \nabla \mathbf { } \mathbf { } \nabla \mathbf { } \mathbf { } \nabla \mathbf { } \mathbf { } \nabla \mathbf { } \mathbf { } \nabla \mathbf { } \nabla \mathbf { } \mathbf { } \nabla \mathbf { } \nabla \mathbf { } \nabla \mathbf { } \mathbf { } \nabla \mathbf { } \nabla \mathbf { } \nabla \mathbf { } \nabla \mathbf { } \nabla \mathbf { } \nabla \mathbf { } \nabla \mathbf { } \nabla \mathbf { } \nabla \mathbf { } \nabla \mathbf { } \nabla \nabla \mathbf { } \nabla \mathbf { } \nabla \nabla \mathbf { } \nabla \nabla \mathbf { } \nabla \nabla \mathbf { } \nabla \nabla \nabla \mathbf  \nabla \nabla \nabla \mathbf { } \nabla \nabla \mathbf { } \nabla \nabla \mathbf { \nabla \nabla \nabla \nabla \nabla \mathbf { } \nabla \nabla \mathbf \nabla \nabla \nabla \mathbf { } \nabla \nabla \nabla \nabla \nabla \mathbf \nabla \nabla \nabla \nabla \mathbf } \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla \nabla$ depends on $\mathbf { } h _ { t }$ which only depends on the past inputs, ${ \boldsymbol { x } } _ { 1 : t }$ . We can get better results if we let the decoder look into the “future” of $_ { x }$ as well as the past, by using a bidirectional RNN, as shown in Figure 15.5b.

We can create more expressive models by stacking multiple hidden chains on top of each other, as shown in Figure 15.6. The hidden units for layer $\it { l }$ at time $t$ are computed using

$$
{ \pmb h } _ { t } ^ { l } = \varphi _ { l } ( { \mathbf W } _ { x h } ^ { l } { \pmb h } _ { t } ^ { l - 1 } + { \mathbf W } _ { h h } ^ { l } { \pmb h } _ { t - 1 } ^ { l } + { \pmb b } _ { h } ^ { l } )
$$

The output is given by

$$
\pmb { o } _ { t } = \mathbf { W } _ { h o } \pmb { h } _ { t } ^ { L } + \pmb { b } _ { o }
$$

# 15.2.3.2 Unaligned case

In this section, we discuss how to learn a mapping from one sequence of length $T$ to another of length $T ^ { \prime }$ . We first encode the input sequence to get the context vector ${ \pmb { c } } = f _ { e } ( { \pmb { x } } _ { 1 : T } )$ , using the last state of an RNN (or average pooling over a biRNN). We then generate the output sequence using an RNN

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022 decoder ${ \pmb y } _ { 1 : T ^ { \prime } } = f _ { d } ( { \pmb c } )$ . This is called an encoder-decoder architecture [SVL14; Cho+14a]. See Figure 15.7 for an illustration.

![](images/c31f910e7065c87cb0fd99865c0b16bfe27cbd03152c461f33ac3ff4b3c002c9.jpg)  
Figure 15.8: (a) Illustration of a seq2seq model for translating English to French. The - character represents the end of a sentence. From Figure 2.4 of [Luo16]. Used with kind permission of Minh-Thang Luong. (b) Illustration of greedy decoding. The most likely French word at each step is highlighted in green, and then fed in as input to the next step of the decoder. From Figure 2.5 of [Luo16]. Used with kind permission of Minh-Thang Luong.

An important application of this is machine translation. When this is tackled using RNNs, it is called neural machine translation (as opposed to the older approach called statistical machine translation, that did not use neural networks). See Figure 15.8a for the basic idea, and nmt_jax.ipynb for some code which has more details. For a review of the NMT literature, see [Luo16; Neu17].

# 15.2.4 Teacher forcing

When training a language model, the likelihood of a sequence of words $w _ { 1 } , w _ { 2 } , \ldots , w _ { T }$ , is given by

$$
p ( \pmb { w } _ { 1 : T } ) = \prod _ { t = 1 } ^ { T } p ( w _ { t } | \pmb { w } _ { 1 : t - 1 } )
$$

In an RNN, we therefore set the input to $x _ { t } = w _ { t - 1 }$ and the output to $y _ { t } = w _ { t }$ . Note that we condition on the ground truth labels from the past, $\pmb { w } _ { 1 : t - 1 }$ , not labels generated from the model. This is called teacher forcing, since the teacher’s values are “force fed” into the model as input at each step (i.e., $x _ { t }$ is set to $w _ { t - 1 }$ ).

Unfortunately, teacher forcing can sometimes result in models that perform poorly at test time. The reason is that the model has only ever been trained on inputs that are “correct”, so it may not know what to do if, at test time, it encounters an input sequence $\pmb { w } _ { 1 : t - 1 }$ generated from the previous step that deviates from what it saw in training.

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

![](images/4bbaf05a40faa9b32998eb3c0003840393e2e871c87f38748fbf6777e2553285.jpg)  
Figure 15.9: An RNN unrolled (vertically) for 3 time steps, with the target output sequence and loss node shown explicitly. From Figure 8.7.2 of [Zha+20]. Used with kind permission of Aston Zhang.

A common solution to this is known as scheduled sampling [Ben+15a]. This starts off using teacher forcing, but at random time steps, feeds in samples from the model instead; the fraction of time this happens is gradually increased.

An alternative solution is to use other kinds of models where MLE training works better, such as 1d CNNs (Section 15.3) and transformers (Section 15.5).

# 15.2.5 Backpropagation through time

We can compute the maximum likelihood estimate of the parameters for an RNN by solving $\pmb { \theta } ^ { * } = \mathrm { a r g m a x } _ { \pmb { \theta } } p ( \pmb { y } _ { 1 : T } | \pmb { x } _ { 1 : T } , \pmb { \theta } )$ , where we have assumed a single training sequence for notational simplicity. To compute the MLE, we have to compute gradients of the loss wrt the parameters. To do this, we can unroll the computation graph, as shown in Figure 15.9, and then apply the backpropagation algorithm. This is called backpropagation through time (BPTT) [Wer90].

More precisely, consider the following model:

$$
\begin{array} { r l } & { { \pmb h } _ { t } = { \mathbf W } _ { h x } { \pmb x } _ { t } + { \mathbf W } _ { h h } { \pmb h } _ { t - 1 } } \\ & { { \pmb o } _ { t } = { \mathbf W } _ { h o } { \pmb h } _ { t } } \end{array}
$$

where $\mathbf { } _ { \mathbf { } } \mathbf { o } _ { t }$ are the output logits, and where we drop the bias terms for notational simplicity. We assume $y _ { y }$ are the true target labels for each time step, so we define the loss to be

$$
L = \frac { 1 } { T } \sum _ { t = 1 } ^ { T } \ell ( y _ { t } , \pmb { o } _ { t } )
$$

We need to compute the derivatives ∂ ∂WLhx , ∂ ∂WLhh , and ∂ ∂WL . The latter term is easy, since it is local to each time step. However, the first two terms depend on the hidden state, and thus require working backwards in time.

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

We simplify the notation by defining

$$
\begin{array} { l } { h _ { t } = f ( { \pmb x } _ { t } , { \pmb h } _ { t - 1 } , { \pmb w } _ { h } ) } \\ { { \pmb o } _ { t } = g ( { \pmb h } _ { t } , { \pmb w } _ { o } ) } \end{array}
$$

where wh is the flattened version of Whh and Whx stacked together. We focus on computing ∂wLh . By the chain rule, we have

$$
\frac { \partial L } { \partial w _ { h } } = \frac { 1 } { T } \sum _ { t = 1 } ^ { T } \frac { \partial \ell ( y _ { t } , \pmb { o } _ { t } ) } { \partial \pmb { w } _ { h } } = \frac { 1 } { T } \sum _ { t = 1 } ^ { T } \frac { \partial \ell ( y _ { t } , \pmb { o } _ { t } ) } { \partial \pmb { o } _ { t } } \frac { \partial g ( h _ { t } , \pmb { w } _ { o } ) } { \partial \pmb { h } _ { t } } \frac { \partial h _ { t } } { \partial \pmb { w } _ { h } }
$$

We can expand the last term as follows:

$$
\frac { \partial h _ { t } } { \partial w _ { h } } = \frac { \partial f ( x _ { t } , h _ { t - 1 } , w _ { h } ) } { \partial w _ { h } } + \frac { \partial f ( x _ { t } , h _ { t - 1 } , w _ { h } ) } { \partial h _ { t - 1 } } \frac { \partial h _ { t - 1 } } { \partial w _ { h } }
$$

If we expand this recursively, we find the following result (see the derivation in [Zha+20, Sec 8.7])

$$
\frac { \partial h _ { t } } { \partial w _ { h } } = \frac { \partial f ( x _ { t } , h _ { t - 1 } , w _ { h } ) } { \partial w _ { h } } + \sum _ { i = 1 } ^ { t - 1 } \left( \prod _ { j = i + 1 } ^ { t } \frac { \partial f ( x _ { j } , h _ { j - 1 } , w _ { h } ) } { \partial h _ { j - 1 } } \right) \frac { \partial f ( x _ { i } , h _ { i - 1 } , w _ { h } ) } { \partial w _ { h } }
$$

Unfortunately, this takes $O ( T )$ time to compute per time step, for a total of $O ( T ^ { 2 } )$ overall. It is therefore standard to truncate the sum to the most recent $K$ terms. It is possible to adaptively pick a suitable truncation parameter $K$ [AFF19]; however, it is usually set equal to the length of the subsequence in the current minibatch.

When using truncated BPTT, we can train the model with batches of short sequences, usually created by extracting non-overlapping subsequences (windows) from the original sequence. If the previous subsequence ends at time $t - 1$ , and the current subsequence starts at time $t$ , we can “carry over” the hidden state of the RNN across batch updates during training. However, if the subsequences are not ordered, we need to reset the hidden state. See rnn_jax.ipynb for some sample code that illustrates these details.

# 15.2.6 Vanishing and exploding gradients

Unforunately, the activations in an RNN can decay or explode as we go forwards in time, since we multiply by the weight matrix ${ \mathbf W } _ { h h }$ at each time step. Similarly, the gradients in an RNN can decay or explode as we go backwards in time, since we multiply the Jacobians at each time step (see Section 13.4.2 for details). A simple heuristic is to use gradient clipping (Equation (13.70)). More sophisticated methods attempt to control the spectral radius $\lambda$ of the forward mapping, ${ \mathbf W } _ { h h }$ , as well as the backwards mapping, given by the Jacobian $\mathbf { J } _ { h h }$ .

The simplest way to control the spectral radius is to randomly initialize $\mathbf { W } _ { h h }$ in such a way as to ensure $\lambda \approx 1$ , and then keep it fixed (i.e., we do not learn ${ \mathbf W } _ { h h }$ ). In this case, only the output matrix $\mathbf { W } _ { h o }$ needs to be learned, resulting in a convex optimization problem. This is called an echo state network [JH04]. A closely related approach, known as a liquid state machine [MNM02], uses binary-valued (spiking) neurons instead of real-valued neurons. A generic term for both ESNs

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license and LSMs is reservoir computing [LJ09]. Another approach to this problem is use constrained optimization to ensure the $\mathbf { W } _ { h h }$ matrix remains orthogonal [Vor+17].

![](images/069117a2dbd0ca311e6379e5f64c3b030c3075c47c53351ec8473b2f512f0719.jpg)  
Figure 15.10: Illustration of a GRU. Adapted from Figure 9.1.3 of [Zha+20].

An alternative to explicitly controlling the spectral radius is to modify the RNN architecture itself, to use additive rather than multiplicative updates to the hidden states, as we discuss in Section 15.2.7. This significantly improves training stability.

# 15.2.7 Gating and long term memory

RNNs with enough hidden units can in principle remember inputs from long in the past. However, in practice “vanilla” RNNs fail to do this because of the vanishing gradient problem (Section 13.4.2). In this section we give a solution to this in which we update the hidden state in an additive way, similar to a residual net (Section 14.3.4).

# 15.2.7.1 Gated recurrent units (GRU)

In this section, we discuss models which use gated recurrent units (GRU), as proposed in [Cho+14a]. The key idea is to learn when to update the hidden state, by using a gating unit. This can be used to selectively “remember” important pieces of information when they are first seen. The model can also learn when to reset the hidden state, and thus forget things that are no longer useful. To explain the model in more detail, we present it in two steps, following the presentation of [Zha+20, Sec 8.8]. We assume $\mathbf { X } _ { t }$ is a $N \times D$ matrix, where $N$ is the batch size, and $D$ is the vocabulary size. Similarly, $\mathbf { H } _ { t }$ is a $N \times H$ matrix, where $H$ is the number of hidden units at time $t$ .

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

The reset gate ${ \bf R } _ { t } \in { \mathbb R } ^ { N \times H }$ and update gate ${ \bf Z } _ { t } \in \mathbb { R } ^ { N \times H }$ are computed using

$$
\begin{array} { r } { \mathbf { R } _ { t } = \sigma ( \mathbf { X } _ { t } \mathbf { W } _ { x r } + \mathbf { H } _ { t - 1 } \mathbf { W } _ { h r } + \pmb { b } _ { r } ) } \\ { \mathbf { Z } _ { t } = \sigma ( \mathbf { X } _ { t } \mathbf { W } _ { x z } + \mathbf { H } _ { t - 1 } \mathbf { W } _ { h z } + \pmb { b } _ { z } ) } \end{array}
$$

where the weight matrix Note that each element of $\mathbf { R } _ { t }$ and $\mathbf { Z } _ { t }$ is in $[ 0 , 1 ]$ , because of the sigmoid function.

Given this, we we define a “candidate” next state vector using

$$
\begin{array} { r } { \tilde { \mathbf { H } } _ { t } = \operatorname { t a n h } ( \mathbf { X } _ { t } \mathbf { W } _ { x h } + ( \mathbf { R } _ { t } \odot \mathbf { H } _ { t - 1 } ) \mathbf { W } _ { h h } + b _ { h } ) } \end{array}
$$

This combines the old memories that are not reset (computed using $\mathbf { R } _ { t } \odot \mathbf { H } _ { t - 1 }$ ) with the new inputs $\mathbf { X } _ { t }$ . We pass the resulting linear combination through a tanh function to ensure the hidden units remain in the interval $( - 1 , 1 )$ . If the entries of the reset gate $\mathbf { R } _ { t }$ are close to 1, we recover the standard RNN update rule. If the entries are close to 0, the model acts more like an MLP applied to $\mathbf { X } _ { t }$ . Thus the reset gate can capture new, short-term information.

Once we have computed the candidate new state, the model computes the actual new state by using the dimensions from the candidate state $\tilde { \mathbf { H } } _ { t }$ chosen by the update gate, $\mathbf { l } - \mathbf { Z } _ { t }$ , and keeping the remaining dimensions at their old values of $\mathbf { H } _ { t - 1 }$ :

$$
\mathbf { H } _ { t } = \mathbf { Z } _ { t } \odot \mathbf { H } _ { t - 1 } + \left( 1 - \mathbf { Z } _ { t } \right) \odot { \tilde { \mathbf { H } } } _ { t }
$$

When $Z _ { t d } = 1$ , we pass $H _ { t - 1 , d }$ through unchanged, and ignore $\mathbf { X } _ { t }$ . Thus the update gate can capture long-term dependencies.

See Figure 15.10 for an illustration of the overall architecture, and gru_jax.ipynb for some sample code.

# 15.2.7.2 Long short term memory (LSTM)

In this section, we discuss the long short term memory (LSTM) model of [HS97b], which is a more sophisticated version of the GRU (and pre-dates it by almost 20 years). For a more detailed introduction, see https://colah.github.io/posts/2015-08-Understanding-LSTMs.

The basic idea is to augment the hidden state $\pmb { h } _ { t }$ with a memory cell $\boldsymbol { c } _ { t }$ . We need three gates to control this cell: the output gate $\mathbf { O } _ { t }$ determines what gets read out; the input gate $\mathbf { I } _ { t }$ determines what gets read in; and the forget gate $\mathbf { F } _ { t }$ determines when we should reset the cell. These gates are computed as follows:

$$
\begin{array} { r l } & { \mathbf { O } _ { t } = \sigma ( \mathbf { X } _ { t } \mathbf { W } _ { x o } + \mathbf { H } _ { t - 1 } \mathbf { W } _ { h o } + b _ { o } ) } \\ & { \mathbf { I } _ { t } = \sigma ( \mathbf { X } _ { t } \mathbf { W } _ { x i } + \mathbf { H } _ { t - 1 } \mathbf { W } _ { h i } + b _ { i } ) } \\ & { \mathbf { F } _ { t } = \sigma ( \mathbf { X } _ { t } \mathbf { W } _ { x f } + \mathbf { H } _ { t - 1 } \mathbf { W } _ { h f } + b _ { f } ) } \end{array}
$$

We then compute a candidate cell state:

$$
\tilde { \mathbf { C } } _ { t } = \operatorname { t a n h } ( \mathbf { X } _ { t } \mathbf { W } _ { x c } + \mathbf { H } _ { t - 1 } \mathbf { W } _ { h c } + \pmb { b } _ { c } )
$$

The actual update to the cell is either the candidate cell (if the input gate is on) or the old cell (if the not-forget gate is on):

$$
\mathbf { C } _ { t } = \mathbf { F } _ { t } \odot \mathbf { C } _ { t - 1 } + \mathbf { I } _ { t } \odot { \tilde { \mathbf { C } } } _ { t }
$$

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

![](images/f01ae1ecc4e36f2217f7f72f99f18c12f3a655717fd11d7e8cf0f1e964b3fc54.jpg)  
Figure 15.11: Illustration of an LSTM. Adapted from Figure 9.2.4 of [Zha+20].

If $\mathbf { F } _ { t } = 1$ and $\mathbf I _ { t } = 0$ , this can remember long term memories.2

Finally, we compute the hidden state to be a transformed version of the cell, provided the output gate is on:

$$
\mathbf { H } _ { t } = \mathbf { O } _ { t } \odot \operatorname { t a n h } ( \mathbf { C } _ { t } )
$$

Note that $\mathbf { H } _ { t }$ is used as the output of the unit as well as the hidden state for the next time step. This lets the model remember what it has just output (short-term memory), whereas the cell $\mathbf { C } _ { t }$ acts as a long-term memory. See Figure 15.11 for an illustration of the overall model, and lstm_jax.ipynb for some sample code.

Sometimes we add peephole connections, where we pass the cell state as an additional input to the gates. Many other variants have been proposed. In fact, [JZS15] used genetic algorithms to test over 10,000 different architectures. Some of these worked better than LSTMs or GRUs, but in general, LSTMs seemed to do consistently well across most tasks. Similar conclusions were reached in [Gre+17]. More recently, [ZL17] used an RNN controller to generate strings which specify RNN architectures, and then trained the controller using reinforcement learning. This resulted in a novel cell structure that outperformed LSTM. However, it is rather complex and has not been adopted by the community.

Time step 1 2 3 4 Time step 1 2 3 4   
A 0.5 0.1 0.2 0.0 A 0.5 0.1 0.1 0.1   
B 0.2 0.4 0.2 0.2 B 0.2 0.4 0.6 0.2   
C 0.2 0.3 0.4 0.2 C 0.2 0.3 0.2 0.1   
<eos> 0.1 0.2 0.2 0.6 <eos> 0.1 0.2 0.1 0.6   
(a) (b)

# 15.2.8 Beam search

The simplest way to generate from an RNN is to use greedy decoding, in which we compute $\hat { y } _ { t } = \operatorname { a r g m a x } _ { y } p ( y _ { t } = y | \hat { y } _ { 1 : t } , \pmb { x } )$ at each step. We can repeat this process until we generate the end-of-sentence token. See Figure 15.8b for an illustration of this method applied to NMT.

Unfortunately greedy decoding will not generate the MAP sequence, which is defined by $y _ { 1 : T } ^ { * } =$ argmaxy1:T p(y1:T |x). The reason is that the locally optimal symbol at step t might not be on the globally optimal path.

As an example, consider Figure 15.12a. We greedily pick the MAP symbol at step 1, which is A. Conditional on this, suppose we have $p ( y _ { 2 } | y _ { 1 } = A ) = [ 0 . 1 , 0 . 4 , 0 . 3 , 0 . 2 ]$ , as shown. We greedily pick the MAP symbol from this, which is B. Conditional on this, suppose we have $p ( y _ { 3 } | y _ { 1 } = A , y _ { 2 } = B ) =$ [0.2, 0.2, 0.4, 0.2], as shown. We greedily pick the MAP symbol from this, which is C. Conditional on this, suppose we have $p ( y _ { 4 } | y _ { 1 } = A , y _ { 2 } = B , y _ { 3 } = C ) = [ 0 . 0 , 0 . 2 , 0 . 2 , 0 . 6 ]$ , as shown. We greedily pick the MAP symbol from this, which is eos (end of sentence), so we stop generating. The overall probability of the generated sequence is $0 . 5 \times 0 . 4 \times 0 . 4 \times 0 . 6 = 0 . 0 4 8$ .

Now consider Figure 15.12b. At step 2, suppose we pick the second most probable token, namely C. Conditional on this, suppose we have $p ( y _ { 3 } | y _ { 1 } = A , y _ { 2 } = C ) \ = \ [ 0 . 1 , 0 . 6 , 0 . 2 , 0 . 1 ]$ , as shown. We greedily pick the MAP symbol from this, which is $\mathrm { B }$ . Conditional on this, suppose we have $p ( y _ { 4 } | y _ { 1 } = A , y _ { 2 } = C , y _ { 3 } = B ) = [ 0 . 1 , 0 . 2 , 0 . 1 , 0 . 6 ]$ , as shown. We greedily pick the MAP symbol from this, which is eos (end of sentence), so we stop generating. The overall probability of the generated sequence is $0 . 5 \times 0 . 3 \times 0 . 6 \times 0 . 6 = 0 . 0 5 4$ . So by being less greedy, we found a sequence with overall higher likelihood.

For hidden Markov models, we can use an algorithm called Viterbi decoding (which is an example of dynamic programming) to compute the globally optimal sequence in $O ( T V ^ { 2 } )$ time, where $V$ is the number of words in the vocabulary. (See [Mur23] for details.) But for RNNs, computing the global optimum takes $O ( V ^ { T } )$ , since the hidden state is not a sufficient statistic for the data.

Beam search is a much faster heuristic method. In this approach, we compute the top $K$ candidate outputs at each step; we then expand each one in all $V$ possible ways, to generate $V K$ candidates, from which we pick the top $K$ again. This process is illustrated in Figure 15.13.

It is also possible to extend the algorithm to sample the top $K$ sequences without replacement

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license (i.e., pick the top one, renormalize, pick the new top one, etc.), using a method called stochastic beam search. This perturbs the model’s partial probabilities at each step with Gumbel noise. See [KHW19] for details. and [SBS20] for a sequential alternative. These sampling methods can improve diversity of the outputs. (See also the deterministic diverse beam search method of [Vij+18].)

![](images/7ad711fd140dbb95d67c301c7e8ad55689c97688ad9ade142b67c123afc2e20f.jpg)  
Figure 15.13: Illustration of beam search using a beam of size $K = 2$ . The vocabulary is $\mathcal { Y } = \{ A , B , C , D , E \}$ , with size $V = 5$ . We assume the top $\mathcal { Q }$ symbols at step $^ { 1 }$ are $A , C$ . At step $\mathcal { L }$ , we evaluate $p ( y _ { 1 } = A , y _ { 2 } = y )$ and $p ( y _ { 1 } = C , y _ { 2 } = y )$ for each $y \in \mathcal { V }$ . This takes $O ( K V )$ time. We then pick the top $\mathcal { Z }$ partial paths, which are $y _ { 1 } = A , y _ { 2 } = B $ ) and ( $y _ { 1 } = C , y _ { 2 } = E$ ), and continue in the obvious way. Adapted from Figure 9.8.3 of [Zha+20].

# 15.3 1d CNNs

Convolutional neural networks (Chapter 14) compute a function of some local neighborhood for each input using tied weights, and return an output. They are usually used for 2d inputs, but can also be applied in the 1d case, as we discuss below. They are an interesting alternative to RNNs that are much easier to train, because they don’t have to maintain long term hidden state.

# 15.3.1 1d CNNs for sequence classification

In this section, we discuss the use of 1d CNNs for learning a mapping from variable-length sequences to a fixed length output, i.e., a function of the form $f _ { \pmb \theta } : \mathbb { R } ^ { D T }  \mathbb { R } ^ { C }$ , where $T$ is the length of the input, $D$ is the number of features per input, and $C$ is the size of the output vector (e.g., class logits). A basic 1d convolution operation applied to a 1d sequence is shown in Figure 14.4. Typically the input sequence will have $D > 1$ input channels (feature dimensions). In this case, we can convolve each channel separately and add up the result, using a different 1d filter (kernel) for each input channel to get $\begin{array} { r } { \boldsymbol { z } _ { i } = \sum _ { d } \pmb { x } _ { i - k : i + k , d } ^ { \mathsf { T } } \mathbf { w } _ { d } } \end{array}$ , where $k$ is size of the 1d receptive field, and ${ \pmb w } _ { d }$ is the filter for input channel $d$ . This produces a 1d vector $z \in \mathbb { R } ^ { T }$ encoding the input (ignoring boundary effects). We can create a vector representation for each location using a different weight vector for each output channel $c$ to get $\begin{array} { r } { z _ { i c } = \sum _ { d } \pmb { x } _ { i - k : i + k , d } ^ { 1 } \pmb { w } _ { d , c } } \end{array}$ . This implements a mapping from $T D$ to $T C$ . To reduce this to a fixed sized vector, $z \in \mathbb { R } ^ { C }$ , we can use max-pooling over time to get $z _ { c } = \mathrm { m a x } _ { i } z _ { i c }$ . We can

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

![](images/303b91d00bf16733ed2a7f96dab4914207d1885fc9fbadf0e011faca448f9013.jpg)  
Figure 15.14: Illustration of the TextCNN model for binary sentiment classification. Adapted from Figure 15.3.5 of [Zha+20].

then pass this into a softmax layer.

In [Kim14], they applied this model to sequence classification. The idea is to embed each word using an embedding layer, and then to compute various features using 1d kernels of different widths, to capture patterns of different length scales. We then apply max pooling over time, and concatenate the results, and pass to a fully connected layer. See Figure 15.14 for an illustration, and cnn1d_sentiment_jax.ipynb for some code.

# 15.3.2 Causal 1d CNNs for sequence generation

To use 1d CNNs in a generative setting, we must convert them to a causal CNN, in which each output variable only depends on previously generated variables. (This is also called a convolutional Markov model.) In particular, we define the model as follows:

$$
p ( \pmb { y } ) = \prod _ { t = 1 } ^ { T } p ( y _ { t } | \pmb { y } _ { 1 : t - 1 } ) = \prod _ { t = 1 } ^ { T } \mathrm { C a t } ( y _ { t } | \mathrm { s o f t m a x } ( \varphi ( \sum _ { \tau = 1 } ^ { t - k } \pmb { w } ^ { \top } \pmb { y } _ { \tau : \tau + k } ) ) )
$$

where is the convolutional filter of size $k$ , and we have assumed a single nonlinearity and $\mathbf { \boldsymbol { w } }$ $\varphi$ categorical output, for notational simplicity. This is like regular 1d convolution except we “mask out” future inputs, so that $y _ { t }$ only depends on the past values, rather than past and future values. This is

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license called causal convolution. ,W2e, 4c,a. .n ,of51c2o, u1,rs2,e 4,u.s.e ,d5e1e2p,e1r, 2m, 4o,d. .el.s,,51a2n.d we can condition on input features $_ { x }$ .e

![](images/c7799aee4d0719583041ea69c595da11988c9e9823858ae8c684874617e3dc01.jpg)  
Figure 15.15: IllustratFiiognu oef3t:heViswuavlieznaetitonmodfeal sutasicnkgofdidlialtaetded(actaruosuasl)coconnvovloultuitoinoanlsl,ayweitrsh dilation factors of 1, 2, 4 and 8. From Figure 3 of [oor+16]. Used with kind permission of Aaron van den Oord.

In ordresrultos icnaepxtpuorneelnotinalg-rreacenpgteivedefipeledndgreonwctihes,witwhe dceapnthu(sYeud&i aKtoeldtucn,on20v1ol6)u. Foon (eSxeacmtiploene1ac4.h4.1), as illustrat1e,d2,i4n .F.i.g,u5r1e2 1bl5o.c1k5.haTshriescepmtiovdeelfiehldasofbseiezen 1s0u2c4c,easnsfduclalyn buesesedetnoascraeamtoereaefsfitcaitentoafntdhde sa-rt text to speech (TTS) synthesis system known1a⇥s1w02a4venet [oor+16]. In particular, they stack 10 causal 1d convolutional layers with dilation rates $1 , 2 , 4 , \ldots , 2 5 6 , 5 1 2$ to get a convolutional block with an effective receptive field of 1024. (They left-padded the input sequences with a number of zeros equal to the dilation rate before every layer, so that every layer has the same length.) They then repeat this blocOkne3 atpipmroeasctho ocomopdeultiengdtehepceronfdeiatitounraels.d

In wavuednioets,atmhpelescownoduiltdiobneitnoguisenfaormixattuiroenm $_ { x }$ diesl saucshetasoaf lmiinxgturiestdiecnfsietaytnuertewsordker(iBvieshdofpr,o19m94a)n input sequenceo ofmiwxtourdeso; tchoendmitioodneal tGhaeunssgiaenesrcaltesmrixatwu easu(diMoCuGsSinMg t(hTeheaisbo&veBemthogde,el2.0I1t5)i. aHloswoepveors,sible to create adfatualliys iemnpdl-itciot-lyencdontaipnuporousac(ahs, swthiecchasetafrotrs mwaigtehpriaxewl iwntoerndsist resatohrearudtihoasna lmipnlgeuviasltuiecs)f.eaOtnueres (see [Wan+1o7f]t)h.

Althoduisgtrhibuwtaiovnesnbeet apursoeditucmeaskehsingoh sqsuamliptiyonsspaebeocuht, hite rishtaopoe slow for use in production systems. However, it can be “distilled” into a parallel generative model [Oor+18]. We discuss these kinds of parallel sgoeftnmearxatliavye mwoduledlsnienedtthoeosuetqputel65t,o53t6hips oboaobikl,i i[eMs puerr2t3i]m.

# 15.4 Attention

In all of the neural networks we have considered so far, the hidden activations are a linear combination of the input activations, followed by a nonlinearity: $z = \varphi ( \mathbf { W } v )$ , where $\pmb { v } \in \mathbb { R } ^ { v }$ are the hidden feature vectors, and $\mathbf { W } \in \mathbb { R } ^ { v ^ { \prime } \times v }$ are a fixed set of weights3that are learned on a training set.

However, we can imagine a more flexible model in which we have a set of $m$ feature vectors or values $\mathbf { V } \in \mathbb { R } ^ { m \times v }$ , and the model dynamically decides (in an input dependenent way) which one to use, based on how similar the input query vector $\pmb q \in \mathbb { R } ^ { q }$ is to a set of $m$ keys $\mathbf { K } \in \mathbb { R } ^ { m \times k }$ . If $\mathbf { \pmb { q } }$ is most similar to key $i$ , then we use value ${ \pmb v } _ { i }$ . This is the basic idea behind attention mechanisms. This idea was originally developed for sequence models, and we will therefore explain it in this context. However, it can be more generally applied. Our presentation in the following sections is based on [Zha+20, Chap 10.].

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

![](images/7e0278c2f663daaaf27be7f7b2e5c6ad1dbe4c17af899d2c44067bd8472efb88.jpg)  
Figure 15.16: Attention computes a weighted average of a set of values, where the weights are derived by comparing the query vector to a set of keys. From Figure 10.3.1 of [Zha+20]. Used with kind permission of Aston Zhang.

# 15.4.1 Attention as soft dictionary lookup

We can think of attention as a dictionary lookup, in which we compare the query $\mathbf { \pmb { q } }$ to each key $\pmb { k } _ { i }$ , and then retrieve the corresponding value ${ \pmb v } _ { i }$ . To make this lookup operation differentiable, instead of retrieving a single value ${ \pmb v } _ { i }$ , we compute a convex combination of the values, as follows:

$$
{ \bf \mathrm { \Sigma } } ^ { \prime } q , ( k _ { 1 } , v _ { 1 } ) , \ldots , ( k _ { m } , v _ { m } ) ) = \mathrm { A t t n } ( { \bf q } , ( k _ { 1 : m } , v _ { 1 : m } ) ) = \sum _ { i = 1 } ^ { m } \alpha _ { i } ( { \bf q } , k _ { 1 : m } ) { \pmb v } _ { i } \in \mathbb { R } ^ { v }
$$

where $\alpha _ { i } ( \pmb q , \pmb k _ { 1 : m } )$ is the $i$ ’th attention weight; these weights satisfy $0 \leq \alpha _ { i } ( \pmb { q } , \pmb { k } _ { 1 : m } ) \leq 1$ for each $i$ and $\begin{array} { r } { \sum _ { i } \alpha _ { i } ( { \pmb q } , { \pmb k } _ { 1 : m } ) = 1 } \end{array}$ .

The attention weights can be computed from an attention score function $a ( \pmb q , \pmb k _ { i } ) \in \mathbb { R }$ , that computes the similarity of query $\pmb q$ to key $\pmb { k } _ { i }$ . We will discuss several such score function below. Given the scores, we can compute the attention weights using the softmax function:

$$
\alpha _ { i } ( \pmb { q } , \pmb { k } _ { 1 : m } ) = \mathrm { s o f t m a x } _ { i } ( [ a ( \pmb { q } , \pmb { k } _ { 1 } ) , \dots , a ( \pmb { q } , \pmb { k } _ { m } ) ] ) = \frac { \exp ( a ( \pmb { q } , \pmb { k } _ { i } ) ) } { \sum _ { j = 1 } ^ { m } \exp ( a ( \pmb { q } , \pmb { k } _ { j } ) ) }
$$

See Figure 15.16 for an illustration.

In some cases, we want to restrict attention to a subset of the dictionary, corresponding to valid entries. For example, we might want to pad sequences to a fixed length (for efficient minibatching), in which case we should “mask out” the padded locations. This is called masked attention. We can implement this efficiently by setting the attention score for the masked entries to a large negative number, such as $- 1 0 ^ { 6 }$ , so that the corresponding softmax weights will be 0. (This is analogous to causal convolution, discussed in Section 15.3.2.)

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

# 15.4.2 Kernel regression as non-parametric attention

In Section 16.3.5, we discuss kernel regression, which is a nonparametric model of the form

$$
f ( \boldsymbol { x } ) = \sum _ { i = 1 } ^ { n } \alpha _ { i } ( \boldsymbol { x } , \boldsymbol { x } _ { 1 : n } ) y _ { i }
$$

where $\alpha _ { i } ( x , x _ { 1 : n } ) \geq 0$ measures the normalized similarity of test input $x$ to training input $x _ { i }$ . This similarity measure is usually computed by defining the attention score in terms of a density kernel, such as the Gaussian:

$$
\displaystyle { \mathcal { K } } _ { \sigma } ( u ) = { \frac { 1 } { \sqrt { 2 \pi \sigma ^ { 2 } } } } e ^ { - { \frac { 1 } { 2 \sigma ^ { 2 } } } u ^ { 2 } }
$$

where $\sigma$ is called the bandwidth. We then define $a ( x , x _ { i } ) = K _ { \sigma } ( x - x _ { i } )$ .

Because the scores are normalized, we can drop the √21πσ2 term. In addition, to maintain notation consistency with [Zha+20, Ch. 10], we rewrite the term inside the exponential as follows:

$$
K ( u ; w ) = \exp ( - \frac { w ^ { 2 } } { 2 } u ^ { 2 } )
$$

Plugging this in to Equation (15.36), we get

$$
{ \begin{array} { r l } & { f ( { \boldsymbol { x } } ) = \displaystyle \sum _ { i = 1 } ^ { n } \alpha _ { i } ( { \boldsymbol { x } } , { \boldsymbol { x } } _ { 1 : n } ) y _ { i } } \\ & { \qquad = \displaystyle \sum _ { i = 1 } ^ { n } { \frac { \exp [ - { \frac { 1 } { 2 } } ( ( { \boldsymbol { x } } - { \boldsymbol { x } } _ { i } ) w ) ^ { 2 } ] } { \sum _ { j = 1 } ^ { n } \exp [ - { \frac { 1 } { 2 } } ( ( { \boldsymbol { x } } - { \boldsymbol { x } } _ { j } ) w ) ^ { 2 } ] } } y _ { i } } \\ & { \qquad = \displaystyle \sum _ { i = 1 } ^ { n } \mathrm { { s o f t m a x } } _ { i } \left[ - { \frac { 1 } { 2 } } ( ( { \boldsymbol { x } } - { \boldsymbol { x } } _ { 1 } ) w ) ^ { 2 } , \cdots , - { \frac { 1 } { 2 } } ( ( { \boldsymbol { x } } - { \boldsymbol { x } } _ { n } ) w ) ^ { 2 } \right] y _ { i } } \end{array} }
$$

We can interpret this as a form of nonparametric attention, where the queries are the test points $x$ , the keys are the training inputs $x _ { i }$ , and the values are the training labels $y _ { i }$ .

If we set $w = 1$ , the resulting attention matrix $A _ { j i } = \alpha _ { i } ( x _ { j } , x _ { 1 : n } )$ for test input $j$ is shown in Figure 15.17a. The resulting predicted curve is shown in Figure 15.17b.

The size of the diagonal band in Figure 15.17a, and hence the sparsity of the attention mechanism, dependends on the parameter $w$ . If we increase $w$ , corresponding to reducing the kernel bandwidth, the band will get narrower, but the model will start to overfit.

# 15.4.3 Parametric attention

In Section 15.4.2, we defined the attention score in terms of the Gaussian kernel, comparing a scalar query (test point) to each of the scalar values in the training set. This does not scale well to large training sets, or high-dimensional inputs. We will therefore turn our attention to parametric models, where we have a fixed set of keys and values, and where we compare queries and keys in a learned embedding space.

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

![](images/164bee0aaebc4885909b8e9dc2b2f38705245a2ad0c2799df8a54ddbc1ba9829.jpg)  
Figure 15.17: Kernel regression in 1d. (a) Kernel weight matrix. (b) Resulting predictions on a dense grid of test points. Generated by kernel_regression_attention.ipynb.

There are several ways to do this. In the general case, the query $q \in \mathbb { R } ^ { q }$ and the key $\boldsymbol { k } \in \mathbb { R } ^ { k }$ may have different sizes. To compare them, we can map them to a common embedding space of size $h$ by computing $\mathbf { W } _ { q } \pmb { q }$ and ${ \bf W } _ { k } { \bf k }$ . where $\mathbf { W } _ { q } \in \mathbb { R } ^ { h \times q }$ and $\mathbf { W } _ { k } \in \mathbb { R } ^ { h \times k }$ . We can then pass these into an MLP to get the following additive attention scoring function:

$$
a ( \pmb { q } , \pmb { k } ) = \pmb { w } _ { v } ^ { \top } \operatorname { t a n h } ( \mathbf { W } _ { q } \pmb { q } + \mathbf { W } _ { k } \pmb { k } ) \in \mathbb { R }
$$

A more computationally efficient approach is to assume the queries and keys both have length $d$ , so we can compute $\pmb { q } ^ { \top } \pmb { k }$ directly. If we assume these are independent random variables with $0$ mean and unit variance, the mean of their inner product is $0$ , and the variance is $d$ . (This follows from Equation (2.34) and Equation (2.39).) To ensure the variance of the inner product remains 1 regardless of the size of the inputs, it is standard to divide by $\sqrt { d }$ . This gives rise to the scaled dot-product attention:

$$
\boldsymbol { a } ( \boldsymbol { \mathbf { \mathscr { q } } } , \boldsymbol { \mathbf { k } } ) = \boldsymbol { \mathbf { \mathscr { q } } } ^ { \intercal } \boldsymbol { k } / \sqrt { d } \in \mathbb { R }
$$

In practice, we usually deal with minibatches of $n$ vectors at a time. Let the corresponding matrices of queries, keys and values be denoted by $\mathbf { Q } \in \mathbb { R } ^ { n \times d }$ , $\mathbf { K } \in \mathbb { R } ^ { m \times d }$ , $\mathbf { V } \in \mathbb { R } ^ { m \times v }$ . Then we can compute the attention-weighted outputs as follows:

$$
{ \mathrm { A t t n } } ( \mathbf { Q } , \mathbf { K } , \mathbf { V } ) = { \mathrm { s o f t m a x } } ( { \frac { \mathbf { Q } \mathbf { K } ^ { \mathsf { T } } } { { \sqrt { d } } } } ) \mathbf { V } \in \mathbb { R } ^ { n \times v }
$$

where the softmax function softmax is applied row-wise. See attention_jax.ipynb for some sample code.

# 15.4.4 Seq2Seq with attention

Recall the seq2seq model from Section 15.2.3. This uses an RNN decoder of the form $h _ { t } ^ { d } \ =$ $f _ { d } ( \pmb { h } _ { t - 1 } ^ { d } , \pmb { y } _ { t - 1 } , \pmb { c } )$ , where $\mathbf { \nabla } c$ is a fixed-length context vector, representing the encoding of the input $\pmb { x } _ { 1 : T }$ . Usually we set ${ \bf c } = { \bf h } _ { T } ^ { e }$ , which is the final state of the encoder RNN (or we use a bidirectional

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

![](images/a082beab3c197d93a9d11753ded7d982c3fa99cd2e8922483961e25acd8e8ea3.jpg)  
Figure 15.18: Illustration of seq2seq with attention for English to French translation. Used with kind permission of Minh-Thang Luong.

![](images/e473cb1bf768adb212c196b3d616da53908a1df3585f9345c27f2919e396fef2.jpg)  
Figure 15.19: Illustration of the attention heatmaps generated while translating two sentences from Spanish to English. (a) Input is “hace mucho frio aqui.”, output is “it is very cold here.”. (b) Input is “¿todavia estan en casa?”, output is “are you still at home?”. Note that when generating the output token “home”, the model should attend to the input token “casa”, but in fact it seems to attend to the input token “?”. Adapted from https: // www. tensorflow. org/ tutorials/ text/ nmt_ with_ attention .

RNN with average pooling). However, for tasks such as machine translation, this can result in poor performance, since the output does not have access to the input words themselves. We can avoid this bottleneck by allowing the output words to directly “look at” the input words. But which inputs should it look at? After all, word order is not always preserved across languages (e.g., German often puts verbs at the end of a sentence), so we need to infer the alignment between source and target. We can solve this problem (in a differentiable way) by using (soft) attention, as first proposed in [BCB15; LPM15]. In particular, we can replace the fixed context vector $_ c$ in the decoder with a dynamic context vector $\mathbf { \Delta } \mathbf { c } _ { t }$ computed as follows:

$$
\pmb { c } _ { t } = \sum _ { i = 1 } ^ { T } \alpha _ { i } ( \pmb { h } _ { t - 1 } ^ { d } , \pmb { h } _ { 1 : T } ^ { e } ) \pmb { h } _ { i } ^ { e }
$$

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

# PatientTimeline

![](images/72923d9463c15fcaf314068ffc343c7c4be6a93d0138e2b77ed61057b2c417f0.jpg)  
Figure 15.20: Example of an electronic health record. In this example, 24h after admission to the hospital, the RNN classifier predicts the risk of death as $\it 1 9 . 9 \%$ ; the patient ultimately died 10 days after admission. The “relevant” keywords from the input clinical notes are shown in red, as identified by an attention mechanism. From Figure 3 of [Raj+18]. Used with kind permission of Alvin Rakomar.

This uses attention where the query is the hidden state of the decoder at the previous step, $h _ { t - 1 } ^ { d }$ , the keys are all the hidden states from the encoder, and the values are also the hidden states from the encoder. (When the RNN has multiple hidden layers, we usually take the top layer from the encoder, as the keys and values, and the top layer of the decoder as the query.) This context vector is concatenated with the input vector of the decoder, ${ \mathbf { } } _ { { \mathbf { } } } { \mathbf { } } _ { { \mathbf { } } _ { \mathbf { } } } { \mathbf { } } _ { { \mathbf { } } _ { \mathbf { } } } { \mathbf { } } _ { { \mathbf { } } _ { \mathbf { } } } { \mathbf { } } _ { { \mathbf { } } _ { \mathbf { } } } { \mathbf { } } _ { \mathbf { } } { \mathbf { } } _ { \mathbf { } } { \mathbf { } } _ { \mathbf { } } { \mathbf { } } _ { \mathbf { } } { \mathbf { } } _ { \mathbf { } } { \mathbf { } } _ { \mathbf { } } { \mathbf { } } _ { \mathbf { } } { \mathbf { } } _ { \mathbf { } } { \mathbf { } } _ { \mathbf { } } { \mathbf { } } _ { \mathbf { } } { \mathbf { } } _ { \mathbf { } } { \mathbf { } } _ { \mathbf { } } { \mathbf { } } _ { \mathbf { } } { \mathbf { } } _ { \mathbf { } } { \mathbf { } } _ { \mathbf { } } { \mathbf { } } _ { \mathbf { } } { \mathbf { } } _ { \mathbf { } } { \mathbf { } } _ { \mathbf { } } { \mathbf { } } _ { \mathbf { } } _ { \mathbf { } } { \mathbf { } } _ { \mathbf { } } _ { \mathbf { } } { \mathbf } _ { \mathbf { } } _ { \mathbf { } } _ { \mathbf { } \mathbf { } } _ { \mathbf { } } _ { \mathbf } { \mathbf { } } _ { \mathbf } { \mathbf } _ { } \mathbf { } _ { \mathbf } { } \mathbf { } _ { \mathbf }  _ { \mathbf { } \mathbf { } \mathbf } _ { } _ { \mathbf } { \mathbf } _ { \mathbf } { \mathbf } _ { \mathbf } _ { \mathbf } { } _ { \mathbf } _ { \mathbf } \mathbf { } _ { \mathbf } _ { \mathbf } \mathbf { } _ \mathbf { } _ \mathbf { } \mathbf \mathbf { } _ \mathbf { } \mathbf _ { } \mathbf \mathbf { } _ \mathbf { } \mathbf \mathbf \mathbf { } _ \mathbf { } \mathbf \mathbf \mathbf { } _ \mathbf \mathbf { } \mathbf \mathbf \mathbf { } _ \mathbf \mathbf \mathbf { } \mathbf \mathbf \mathbf \mathbf { } \mathbf \mathbf \mathbf \mathbf \mathbf { } \mathbf \mathbf \mathbf \mathbf \mathbf \mathbf { } \mathbf \mathbf \mathbf \mathbf \mathbf \mathbf \mathbf \mathbf \mathbf \mathbf { } \mathbf \mathbf \mathbf \mathbf \mathbf \mathbf \mathbf \mathbf \mathbf \mathbf \mathbf \mathbf \mathbf \mathbf \mathbf \mathbf \mathbf \mathbf \mathbf \mathbf \mathbf \mathbf \mathbf \mathbf \mathbf \mathbf \mathbf \mathbf \mathbf \mathbf \mathbf \mathbf \mathbf \mathbf \mathbf \mathbf \mathbf \mathbf \mathbf \mathbf \mathbf \mathbf \mathbf \mathbf \mathbf \mathbf \mathbf \mathbf \mathbf \mathbf \mathbf \mathbf \mathbf \mathbf \mathbf \mathbf \mathbf \mathbf \mathbf \mathbf \mathbf \mathbf \mathbf \mathbf \mathbf \mathbf \mathbf \mathbf \mathbf \mathbf \mathbf \mathbf \mathbf \mathbf \mathbf \mathbf \mathbf \mathbf \mathbf \mathbf \mathbf \mathbf \mathbf \mathbf \mathbf \mathbf \mathbf \mathbf \mathbf \mathbf \mathbf \mathbf \mathbf \mathbf \mathbf \mathbf \mathbf \mathbf \mathbf \mathbf \mathbf \mathbf \mathbf \mathbf \mathbf \mathbf \mathbf \mathbf \mathbf$ , and fed into the decoder, along with the previous hidden state $h _ { t - 1 } ^ { d }$ , to create $\mathbf { \delta } _ { h _ { t } ^ { d } }$ . See Figure 15.18 for an illustration of the overall model.

We can train this model in the usual way on sentence pairs, and then use it to perform machine translation. (See nmt_attention_jax.ipynb for some sample code.) We can also visualize the attention weights computed at each step of decoding, to get an idea of which parts of the input the model thinks are most relevant for generating the corresponding output. Some examples are shown in Figure 15.19.

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

![](images/cf7147f87ffc1b45a359e5f4455b64f8d6d367376b805ac9d2836ee95502a576.jpg)  
Figure 15.21: Illustration of sentence pair entailment classification using an MLP with attention to align the premise (“I do need sleep”) with the hypothesis (“I am tired”). White squares denote active attention weights, blue squares are inactive. (We are assuming hard $\theta / 1$ attention for simplicity.) From Figure 15.5.2 of [Zha+20]. Used with kind permission of Aston Zhang.

# 15.4.5 Seq2vec with attention (text classification)

We can also use attention with sequence classifiers. For example [Raj+18] apply an RNN classifier to the problem of predicting if a patient will die or not. The input is a set of electronic health records, which is a time series containing structured data, as well as unstructured text (clinical notes). Attention is useful for identifying “relevant” parts of the input, as illustrated in Figure 15.20.

# 15.4.6 Seq+Seq2Vec with attention (text pair classification)

Suppose we see the sentence “A person on a horse jumps over a log” (call this the premise) and then we later read “A person is outdoors on a horse” (call this the hypothesis). We may reasonably say that the premise entails the hypothesis, meaning that the hypothesis is more likely given the premise.3 Now suppose the hypothesis is “A person is at a diner ordering an omelette”. In this case, we would say that the premise contradicts the hypothesis, since the hypothesis is less likely given the premise. Finally, suppose the hypothesis is “A person is training his horse for a competition”. In this case, we see that the relationship between premise and hypothesis is neutral, since the hypothesis may or may not follow from the premise. The task of classifying a sentence pair into these three categories is known as textual entailment or “natural language inference”. A standard benchmark in this area is the Stanford Natural Language Inference or SNLI corpus [Bow+15]. This consists of 550,000 labeled sentence pairs.

An interesting solution to this classification problem was presented in [Par+16a]; at the time, it was the state of the art on the SNLI dataset. The overall approach is sketched in Figure 15.21. Let $\mathbf { A } = ( \pmb { a } _ { 1 } , \dots , \pmb { a } _ { m } )$ be the premise and $\mathbf { B } = ( b _ { 1 } , \ldots , b _ { n } )$ be the hypothesis, where $\mathbf { \boldsymbol { a } } _ { i } , \mathbf { \boldsymbol { b } } _ { j } \in \mathbb { R } ^ { E }$ are embedding vectors for the words. The model has 3 steps. First, each word in the premise, $\mathbf { \Delta } \mathbf { a } _ { i }$ , attends to each word in the hypothesis, $b _ { j }$ , to compute an attention weight

$$
e _ { i j } = f ( \pmb { a } _ { i } ) ^ { \top } f ( \pmb { b } _ { j } )
$$

where $f : \mathbb { R } ^ { E } \to \mathbb { R } ^ { D }$ is an MLP; we then compute a weighted average of the matching words in the hypothesis,

$$
\beta _ { i } = \sum _ { j = 1 } ^ { n } \frac { \exp ( e _ { i j } ) } { \sum _ { k = 1 } ^ { n } \exp ( e _ { i k } ) } b _ { j }
$$

Next, we compare $\mathbf { \mu } _ { \mathbf { \mu } } \mathbf { \mu } _ { \mathbf { \mu } } \mathbf { \Lambda } _ { \mathbf { \mu } } \mathbf { \Lambda } _ { \mathbf { \mu } } \mathbf { \Lambda } _ { \mathbf { \mu } } \mathbf { \Lambda } _ { \mathbf { \mu } } \mathbf { \Lambda } _ { \mathrm { ~ \mu ~ } } \mathbf { \Lambda } _ { \mathrm { ~ \mu ~ } } \mathbf { \Lambda } _ { \mathrm { ~ \mu ~ } } \mathrm { ~ \bf ~ \Lambda ~ } _ { \mathrm { ~ \mu ~ } } \mathrm { ~ \bf ~ \Lambda ~ } _ { \mathrm { ~ \mu ~ } }$ with $\beta _ { i }$ by mapping their concatenation to a hidden space using an MLP $g : \mathbb { R } ^ { 2 E }  \mathbb { R } ^ { H }$ :

$$
\pmb { v } _ { A , i } = g ( [ \pmb { a } _ { i } , \beta _ { i } ] ) , i = 1 , \ldots , m
$$

Finally, we aggregate over the comparisons to get an overall similarity of premise to hypothesis:

$$
{ \pmb v } _ { A } = \sum _ { i = 1 } ^ { m } { \pmb v } _ { A , i }
$$

We can similarly compare the hypothesis to the premise using

$$
\begin{array} { c } { { \displaystyle \alpha _ { j } = \sum _ { i = 1 } ^ { m } \frac { \exp ( e _ { i j } ) } { \sum _ { k = 1 } ^ { m } \exp ( e _ { k j } ) } a _ { i } } } \\ { { { \displaystyle v _ { B , j } = g ( [ b _ { j } , \alpha _ { j } ] ) , ~ j = 1 , \ldots , n } } } \\ { { { \displaystyle v _ { B } = \sum _ { j = 1 } ^ { n } v _ { B , j } } } } \end{array}
$$

At the end, we classify the output using another MLP $h : \mathbb { R } ^ { 2 H }  \mathbb { R } ^ { 3 }$ :

$$
{ \hat { y } } = h ( [ { \pmb v } _ { A } , { \pmb v } _ { B } ] )
$$

See entailment_attention_mlp_jax.ipynb for some sample code.

We can modify this model to learn other kinds of mappings from sentence pairs to output labels. For example, in the semantic textual similarity task, the goal is to predict how semantically related two input sentences are. A standard dataset for this is the STS Benchmark [Cer+17], where relatedness ranges from 0 (meaning unrelated) to 5 (meaning maximally related).

# 15.4.7 Soft vs hard attention

If we force the attention heatmap to be sparse, so that each output can only attend to one input location instead of a weighted combination of all of them, the method is called hard attention. We compare these two approaches for an image captioning problem in Figure 15.22. Unfortunately, hard attention results in a nondifferentiable training objective, and requires methods such as reinforcement learning to fit the model. See [Xu+15] for the details.

It seems from the above examples that these attention heatmaps can “explain” why the model generates a given output. However, the interpretability of attention is controversial (see e.g., [JW19; WP19; SS19; Bru+19] for discussion).

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

![](images/2a54b6a24214a5645a101b758725680fd3bff5db2193ec63c88d0447997a1aba.jpg)  
Figure 15.22: Image captioning using attention. (a) Soft attention. Generates “a woman is throwing a frisbee in a park”. (b) Hard attention. Generates “a man and a woman playing frisbee in a field”. From Figure 6 of [Xu+15]. Used with kind permission of Kelvin Xu.

# 15.5 Transformers

The transformer model [Vas+17] is a seq2seq model which uses attention in the encoder as well as the decoder, thus eliminating the need for RNNs, as we explain below. Transformers have been used for many (conditional) sequence generation tasks, such as machine translation [Vas+17], constituency parsing [Vas+17], music generation [Hua+18], protein sequence generation [Mad+20; Cho+20b], abstractive text summarization [Zha+19a], image generation [Par+18] (treating the image as a rasterized 1d sequence), etc.

The transformer is a rather complex model that uses several new kinds of building blocks or layers. We introduce these new blocks below, and then discuss how to put them all together.4

# 15.5.1 Self-attention

In Section 15.4.4 we showed how the decoder of an RNN could use attention to the input sequence in order to capture contexual embeddings of each input. However, rather than the decoder attending to the encoder, we can modify the model so the encoder attends to itself. This is called self attention [CDL16; Par+16b].

In more detail, given a sequence of input tokens $\pmb { x } _ { 1 } , \ldots , \pmb { x } _ { n }$ , where $\pmb { x } _ { i } \in \mathbb { R } ^ { d }$ , self-attention can generate a sequence of outputs of the same size using

$$
{ \pmb y } _ { i } = \mathrm { A t t n } ( { \pmb x } _ { i } , ( { \pmb x } _ { 1 } , { \pmb x } _ { 1 } ) , \dots , ( { \pmb x } _ { n } , { \pmb x } _ { n } ) )
$$

where the query is ${ \boldsymbol { x } } _ { i }$ , and the keys and values are all the (valid) inputs $\pmb { x } _ { 1 } , \ldots , \pmb { x } _ { n }$ .

To use this in a decoder, we can set ${ \pmb x } _ { i } = { \pmb y } _ { i - 1 }$ , and $n = i - 1$ , so all the previously generated outputs are available. At training time, all the outputs are already known, so we can evaluate the above function in parallel, overcoming the sequential bottleneck of using RNNs.

In addition to improved speed, self-attention can give improved representations of context. As an example, consider translating the English sentences “The animal didn’t cross the street because it was too tired” and “The animal didn’t cross the street because it was too wide” into French. To generate a pronoun of the correct gender in French, we need to know what “it” refers to (this is called coreference resolution). In the first case, the word “it” refers to the animal. In the second case, the word “it” now refers to the street.

![](images/d78afb518c45a6ad1c496a85b8061249803b49267d1f66d8711f14a1f7ef9ff7.jpg)  
Figure 15.23: Illustration of how encoder self-attention for the word “it” differs depending on the input context. From https: // ai. googleblog. com/ 2017/ 08/ transformer-novel-neural-network. html . Used with kind permission of Jakob Uszkoreit.

![](images/8f8057702377246766d418e67acb329a39c121594fce9ddd54868460586be90d.jpg)  
Figure 15.24: Multi-head attention. Adapted from Figure 9.3.3 of [Zha+20].

Figure 15.23 illustrates how self attention applied to the English sentence is able to resolve this ambiguity. In the first sentence, the representation for “it” depends on the earlier representations of “animal”, whereas in the latter, it depends on the earlier representations of “street”.

# 15.5.2 Multi-headed attention

If we think of an attention matrix as like a kernel matrix (as discussed in Section 15.4.2), it is natural to want to use multiple attention matrices, to capture different notions of similarity. This is the basic idea behind multi-headed attention (MHA). In more detail, query a given $\pmb q \in \mathbb { R } ^ { d _ { q } }$ , keys $\boldsymbol { k } _ { j } \in \mathbb { R } ^ { d _ { k } }$ , and values $\pmb { v } _ { j } \in \mathbb { R } ^ { d _ { v } }$ , we define the $i$ ’th attention head to be

$$
\pmb { h } _ { i } = \mathrm { A t t n } ( \mathbf { W } _ { i } ^ { ( q ) } \pmb { q } , \{ \mathbf { W } _ { i } ^ { ( k ) } \pmb { k } _ { j } , \mathbf { W } _ { i } ^ { ( v ) } \pmb { v } _ { j } \} ) \in \mathbb { R } ^ { p _ { v } }
$$

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

where $\mathbf { W } _ { i } ^ { ( q ) } \in \mathbb { R } ^ { p _ { q } \times d _ { q } }$ , $\mathbf { W } _ { i } ^ { ( k ) } \in \mathbb { R } ^ { p _ { k } \times d _ { k } }$ , and $\mathbf { W } _ { i } ^ { ( v ) } \in \mathbb { R } ^ { p _ { v } \times d _ { v } }$ are projection matrices. We then stack the $h$ heads together, and project to $\mathbb { R } ^ { p _ { o } }$ using

$$
\boldsymbol { h } = \mathrm { M H A } ( \boldsymbol { q } , \left\{ k _ { j } , v _ { j } \right\} ) = \mathbf { W } _ { o } \left( \begin{array} { c } { h _ { 1 } } \\ { \vdots } \\ { h _ { h } } \end{array} \right) \in \mathbb { R } ^ { p _ { o } }
$$

where $\boldsymbol { h } _ { i }$ is defined in Equation (15.55), and $\mathbf { W } _ { o } \in \mathbb { R } ^ { p _ { o } \times h p _ { v } }$ . If we set $p _ { q } h = p _ { k } h = p _ { v } h = p _ { o }$ , we can compute all the output heads in parallel. See multi_head_attention_jax.ipynb for some sample code.

# 15.5.3 Positional encoding

The performance of “vanilla” self-attention can be low, since attention is permutation invariant, and hence ignores the input word ordering. To overcome this, we can concatenate the word embeddings with a positional embedding, so that the model knows what order the words occur in.

One way to do this is to represent each position by an integer. However, neural networks cannot natively handle integers. To overcome this, we can encode the integer in binary form. For example, if we assume the sequence length is $n = 3$ , we get the following sequence of $d = 3$ -dimensional bit vectors for each location: 000, 001, 010, 011, 100, 101, 110, 111. We see that the right most index toggles the fastest (has highest frequency), whereas the left most index (most significant bit) toggles the slowest. (We could of course change this, so that the left most bit toggles fastest.) We can represent this as a position matrix P ∈ Rn×d.

We can think of the above representation as using a set of basis functions (corresponding to powers of 2), where the coefficients are 0 or 1. We can obtain a more compact code by using a different set of basis functions, and real-valued weights. [Vas+17] propose to use a sinusoidal basis, as follows:

$$
p _ { i , 2 j } = \sin \left( \frac { i } { C ^ { 2 j / d } } \right) , p _ { i , 2 j + 1 } = \cos \left( \frac { i } { C ^ { 2 j / d } } \right) ,
$$

where $C = 1 0 , 0 0 0$ corresponds to some maximum sequence length. For example, if $d = 4$ , the $i$ ’t row is

$$
\mathbf { \mathit { p } } _ { i } = [ \sin ( \frac { i } { C ^ { 0 / 4 } } ) , \cos ( \frac { i } { C ^ { 0 / 4 } } ) , \sin ( \frac { i } { C ^ { 2 / 4 } } ) , \cos ( \frac { i } { C ^ { 2 / 4 } } ) ]
$$

Figure 15.25a shows the corresponding position matrix for $n = 6 0$ and $d = 3 2$ . In this case, the left-most columns toggle fastest. We see that each row has a real-valued “fingerprint” representing its location in the sequence. Figure 15.25b shows some of the basis functions (column vectors) for dimensions 6 to 9.

The advantage of this representation is two-fold. First, it can be computed for arbitrary length inputs (up to $T \leq C$ ), unlike a learned mapping from integers to vectors. Second, the representation of one location is linearly predictable from any other, given knowledge of their relative distance. In

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022 particular, we have $\pmb { p } _ { t + \phi } = f ( \pmb { p } _ { t } )$ , where $f$ is a linear transformation. To see this, note that

![](images/7d43b6371830456a69a938159f52e7d4545dee35530220097ee11037f402ee6d.jpg)  
Figure 15.25: (a) Positional encoding matrix for a sequence of length $n = 6 0$ and an embedding dimension of size $d = 3 2$ . (b) Basis functions for columns $\boldsymbol { \mathscr { \sigma } }$ to 9. Generated by positional_encoding_jax.ipynb.

$$
\begin{array} { r } { \Big ( \mathrm { s i n } ( \omega _ { k } ( t + \phi ) ) \Big ) = \Big ( \mathrm { s i n } ( \omega _ { k } t ) \mathrm { c o s } ( \omega _ { k } \phi ) + \mathrm { c o s } ( \omega _ { k } t ) \mathrm { s i n } ( \omega _ { k } \phi ) \Big ) } \\ { \mathrm { c o s } ( \omega _ { k } ( t + \phi ) ) \Big ) = \Big ( \mathrm { s i n } ( \omega _ { k } t ) \mathrm { c o s } ( \omega _ { k } \phi ) - \mathrm { s i n } ( \omega t ) \mathrm { s i n } ( \omega _ { k } \phi ) \Big ) } \\ { = \Big ( \mathrm { c o s } ( \omega _ { k } \phi ) \mathrm { s i n } ( \omega _ { k } \phi ) \Big ) \Big ( \mathrm { s i n } ( \omega _ { k } t ) \Big ) } \\ { - \mathrm { s i n } ( \omega _ { k } \phi ) \mathrm { c o s } ( \omega _ { k } \phi ) \Big ) \Big ( \mathrm { c o s } ( \omega _ { k } t ) \Big ) } \end{array}
$$

So if $\phi$ is small, then $p _ { t + \phi } \approx p _ { t }$ . This provides a useful form of inductive bias.

Once we have computed the positional emebddings $\mathbf { P }$ , we need to combine them with the original word embeddings $\mathbf { X }$ using the following:

$$
\operatorname { P O S } ( \operatorname { E m b e d } ( \mathbf { X } ) ) = \mathbf { X } + \mathbf { P } .
$$

# 15.5.4 Putting it all together

A transformer is a seq2seq model that uses self-attention for the encoder and decoder rather than an RNN. The encoder uses a series of encoder blocks, each of which uses multi-headed attention (Section 15.5.2), residual connections (Section 13.4.4), and layer normalization (Section 14.2.4.2). More precisely, the encoder block can be defined as follows:

def EncoderBlock(X): $Z \ =$ LayerNorm(MultiHeadAttn( $\sf { Q } = \bf { X }$ , $\mathtt { K } \mathrm { = } \mathtt { X }$ , V=X) + X) $\tt { E } =$ LayerNorm(FeedForward(Z) + Z) return E

The overall encoder is defined by applying positional encoding to the embedding of the input sequence, following by $N$ copies of the encoder block, where $N$ controls the depth of the block:

![](images/3b4d0e427d2bd92db9c9e7007f65244f9d5382bccb5e8997188ae200aed7bc48.jpg)  
Figure 15.26: The transformer. From [Wen18]. Used with kind permission of Lilian Weng. Adapted from Figures 1–2 of [Vas+17].

def Encoder(X, N): E = POS(Embed(X)) for n in range(N): $\tt { E } =$ EncoderBlock(E) return E

See the LHS of Figure 15.26 for an illustration.

The decoder has a somewhat more complex structure. It is given access to the encoder via another multi-head attention block. But it is also given access to previously generated outputs: these are shifted, and then combined with a positional embedding, and then fed into a masked (causal) multi-head attention model. Finally the output distribution over tokens at each location is computed in parallel.

In more detail, the decoder block is defined as follows:

def DecoderBlock(Y, E): $Z \ =$ LayerNorm(MultiHeadAttn( $\mathsf { Q } \mathrm { = Y }$ , ${ \sf K } = { \sf Y }$ , V=Y) + Y) $z ^ { , } ~ =$ LayerNorm(MultiHeadAttn( $\scriptstyle { \mathsf { Q } } = { \mathsf { Z } }$ , $\mathtt { K } \mathrm { = } \mathtt { E }$ , V=E) + Z) $\textsf { D } =$ LayerNorm(FeedForward(Z’) + Z’) return D

The overall decoder is defined by $N$ copies of the decoder block:

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

![](images/0ef76921045e067ee4a606093ec81df462b5e06805fb9d0df4ae8ff9cccc268a.jpg)  
Figure 15.27: Comparison of (1d) CNNs, RNNs and self-attention models. From Figure 10.6.1 of [Zha+20]. Used with kind permission of Aston Zhang.

def Decoder(Y, E, N): D = POS(Embed(Y)) for n in range(N): $\textsf { D } =$ DecoderBlock(D,E) return D

See the RHS of Figure 15.26 for an illustration.

During training time, all the inputs $\mathbf { Y }$ to the decoder are known in advance, since they are derived from embedding the lagged target output sequence. During inference (test) time, we need to decode sequentially, and use masked attention, where we feed the generated output into the embedding layer, and add it to the set of keys/values that can be attended to. (We initialize by feeding in the start-of-sequence token.) See transformers_jax.ipynb for some sample code, and [Rus18; Ala18] for a detailed tutorial on this model.

# 15.5.5 Comparing transformers, CNNs and RNNs

In Figure 15.27, we visually compare three different architectures for mapping a sequence ${ \pmb x } _ { 1 : n }$ to another sequence $\pmb { y } _ { 1 : n }$ : a 1d CNN, an RNN, and an attention-based model. Each model makes different tradeoffs in terms of speed and expressive power, where the latter can be quantified in terms of the maximum path length between any two inputs. See Table 15.1 for a summary.

For a 1d CNN with kernel size $k$ and $d$ feature channels, the time to compute the output is $O ( k n d ^ { 2 } )$ , which can be done in parallel. We need a stack of $n / k$ layers, or $\log _ { k } ( n )$ if we use dilated convolution, to ensure all pairs can communicate. For example, in Figure 15.27, we see that $x _ { 1 }$ and $x _ { 5 }$ are initially

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

Table 15.1: Comparison of the transformer with other neural sequential generative models. n is the sequence length, d is the dimensionality of the input features, and $k$ is the kernel size for convolution. Based on Table 1 of [Vas+17].   

<html><body><table><tr><td>Layer type</td><td>Complexity</td><td>Sequential ops.</td><td>Max. path length</td></tr><tr><td>Self-attention</td><td>O(n²d)</td><td>0(1)</td><td>0(1)</td></tr><tr><td>Recurrent</td><td>O(nd²)</td><td>O(n)</td><td>O(n)</td></tr><tr><td>Convolutional</td><td>O(knd²)</td><td>0(1)</td><td>O(logk n)</td></tr></table></body></html>

5 apart, and then 3 apart in layer 1, and then connected in layer 2.

For an RNN, the computational complexity is $O ( n d ^ { 2 } )$ , for a hidden state of size $d$ , since we have to perform matrix-vector multiplication at each step. This is an inherently sequential operation. The maximum path length is $O ( n )$ .

Finally, for self-attention models, every output is directly connected to every input, so the maximum path length is $O ( 1 )$ . However, the computational cost is $O ( n ^ { 2 } d )$ . For short sequences, we typically have $n \ll d$ , so this is fine. For longer sequences, we discuss various fast versions of attention in Section 15.6.

# 15.5.6 Transformers for images \*

CNNs (Chapter 14) are the most common model type for processing image data, since they have useful built-in inductive bias, such as locality (due to small kernels), equivariance (due to weight tying), and invariance (due to pooling). Suprisingly, it has been found that transformers can also do well at image classification [Rag+21], at least if trained on enough data. (They need a lot of data to overcome their lack of relevant inductive bias.)

The first model of this kind, known as ViT (vision transformer) [Dos+21], chops the input up into 16x16 patches, projects each patch into an embedding space, and then passes this set of embeddings ${ \pmb x } _ { 1 : T }$ to a transformer, analogous to the way word embeddings are passed to a transformer. The input is also prepended with a special [CLASS] embedding, $\scriptstyle { \mathbf { x } } _ { 0 }$ . The output of the transformer is a set of encodings $e _ { 0 : T }$ ; the model maps $e _ { 0 }$ to the target class label $y$ , and is trained in a supervised way. See Figure 15.28 for an illustration.

After supervised pretraining, the model is fine-tuned on various downstream classification tasks, an approach known as transfer learning (see Section 19.2 for more details). When trained on “small” datasets such as ImageNet (which has 1k classes and 1.3M images), they find that they cannot outperform a pretrained CNN ResNet model (Section 14.3.4) known as BiT (big transfer) [Kol+20]. However, when trained on larger datasets, such as ImageNet-21k (with 21k classes and 14M images), or the Google-internal JFT dataset (with 18k classes and 303M images), they find that ViT does better than BiT at transfer learning.6 ViT is also cheaper to train than ResNet at this scale. (However, training is still expensive: the large ViT model on ImageNet-21k takes 30 days on a Google Cloud TPUv3 with 8 cores!)

![](images/ed84b11d8aab6e81bbaf50931d677382b15b14a3aa8d8b6abf72543c5031198f.jpg)  
Figure 15.28: The Vision Transformer (ViT) model. This treats an image as a set of input patches. The input is prepended with the special CLASS embedding vector (denoted by \*) in location 0. The class label for the image is derived by applying softmax to the final ouput encoding at location 0. From Figure 1 of [Dos+21]. Used with kind permission of Alexey Dosovitskiy

# 15.5.7 Other transformer variants \*

Many extensions of transformers have been published in the last few years. For example, the Gshard paper [Lep+21] shows how to scale up transformers to even more parameters by replacing some of the feed forward dense layers with a mixture of experts (Section 13.6.2) regression module. This allows for sparse conditional computation, in which only a subset of the model capacity (chosen by the gating network) is used for any given input.

As another example, the conformer paper [Gul+20] showed how to add convolutional layers inside the transformer architecture, which was shown to be helpful for various speech recognition tasks.

# 15.6 Efficient transformers \*

This section is written by Krzysztof Choromanski.

Regular transformers take $O ( N ^ { 2 } )$ time and space complexity, for a sequence of length $N$ , which makes them impractical to apply to long sequences. In the past few years, researchers have proposed several more efficient variants of transformers to bypass this difficulty. In this section, we give a brief survey of some of these methods (see Figure 15.29 for a summary). For more details, see e.g., [Tay+20b; Tay+20a; Lin+21].

# 15.6.1 Fixed non-learnable localized attention patterns

The simplest modification of the attention mechanism is to constrain it to a fixed non-learnable localized window, in other words restrict each token to attend only to a pre-selected set of other tokens. If for instance, each sequence is chunked into $K$ blocks, each of length $\textstyle { \frac { N } { K } }$ , and attention is conducted only within a block, then space/time complexity is reduced from $O ( N ^ { 2 } )$ to $\textstyle { \frac { N ^ { 2 } } { K } }$ . For

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

![](images/8a899a680b9a59e3fc47928cfb85ecaee891dc2ce5a4c0e2b056ec677436a818.jpg)  
Figure 15.29: Venn diagram presenting the taxonomy of different efficient transformer architectures. From [Tay+20b]. Used with kind permission of Yi Tay.

$K \gg 1$ this constitutes substantial overall computational improvements. Such an approach is applied in particular in [Qiu+19b; Par+18]. The attention patterns do not need to be in the form of blocks. Other approaches involve strided / dilated windows, or hybrid patterns, where several fixed attention patterns are combined together [Chi+19b; BPC20].

# 15.6.2 Learnable sparse attention patterns

A natural extension of the above approach is to allow the above compact patterns to be learned. The attention is still restricted to pairs of tokens within a single partition of some partitioning of the set of all the tokens, but now those partitionings are trained. In this class of methods we can distinguish two main approaches: based on hashing and clustering. In the hashing scenario all tokens are hashed and thus different partitions correspond to different hashing-buckets. This is the case for instance for the Reformer architecture [KKL20], where locality sensitive hashing (LSH) is applied. That leads to time complexity $O ( N M ^ { 2 } \log ( M ) )$ of the attention module, where $M$ stands for the dimenionsality of tokens’ embeddings.

Hashing approaches require the set of queries to be identical to the set of keys. Furthermore,

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022 the number of hashes needed for precise partitioning (which in the above expression is treated as a constant) can be a large constant. In the clustering approach, tokens are clustered using standard clustering algorithms such as K-means (Section 21.3); this is known as the “clustering transformer” [Roy+20]. As in the block-case, if $K$ equal-size clusters are used then space complexity of the attention module is reduced to $O ( \frac { N ^ { 2 } } { K } )$ . In practice $K$ is often taken to be of order $K = \Theta ( \sqrt { N } )$ , yet imposing that the clusters be similar in size is in practice difficult.

# 15.6.3 Memory and recurrence methods

In some approaches, a side memory module can access several tokens simultaneously. This method is often instantiated in the form of a global memory algorithm as used in [Lee+19; Zah+20].

Another approach is to connect different local blocks via recurrence. A flagship example of this approach is the class of Transformer-XL methods [Dai+19].

# 15.6.4 Low-rank and kernel methods

In this section, we discuss methods that approximate attention using low rank matrices. In [She+18; Kat+20] they approximate the attention matrix A directly by a low rank matrix, so that

$$
A _ { i j } = \phi ( { \pmb q } _ { i } ) ^ { \top } \phi ( { \pmb k } _ { j } )
$$

where $\pmb { \phi } ( \pmb { x } ) \in \mathbb { R } ^ { M }$ is some finite-dimensional vector with $M < D$ . One can leverage this structure to compute AV in $O ( N )$ time. Unfortunately, for softmax attention, the A is not low rank.

In Linformer [Wan+20a], they instead transform the keys and values via random Gaussian projections. They then apply the theory of the Johnson-Lindenstrauss Transform [AL13] to approximate softmax attention in this lower dimensional space.

In Performer [Cho+20a; Cho+20b], they show that the attention matrix can be computed using a (positive definite) kernel function. We define kernel functions in Section 17.1, but the basic idea is that ${ \cal K } ( { \pmb q } , { \pmb k } ) \geq 0$ is some measure of similarity between $\pmb q \in \mathbb { R } ^ { D }$ and $\pmb { k } \in \mathbb { R } ^ { D }$ . For example, the Gaussian kernel, also called the radial basis function kernel, has the form

$$
{ \mathcal { K } } _ { \mathrm { g a u s s } } ( \pmb { q } , \pmb { k } ) = \exp \left( - \frac { 1 } { 2 \sigma ^ { 2 } } | | \pmb { q } - \pmb { k } | | _ { 2 } ^ { 2 } \right)
$$

To see how this can be used to compute an attention matrix, note that [Cho+20a] show the following:

$$
A _ { i , j } = \exp ( \frac { q _ { i } ^ { \top } k _ { j } } { \sqrt { D } } ) = \exp ( \frac { - \| q _ { i } - k _ { j } \| _ { 2 } ^ { 2 } } { 2 \sqrt { D } } ) \times \exp ( \frac { \| q _ { i } \| _ { 2 } ^ { 2 } } { 2 \sqrt { D } } ) \times \exp ( \frac { \| k _ { j } \| _ { 2 } ^ { 2 } } { 2 \sqrt { D } } ) .
$$

The first term in the above expression is equal to $K _ { \mathrm { g a u s s } } ( \pmb q _ { i } D ^ { - 1 / 4 }$ , $k _ { j } D ^ { - 1 / 4 } )$ with $\sigma = 1$ , and the other two terms are just independent scaling factors.

So far we have not gained anything computationally. However, we will show in Section 17.2.9.3 that the Gaussian kernel can be written as the expectation of a set of random features:

$$
K _ { \mathrm { g a u s s } } ( \pmb { x } , \pmb { y } ) = \mathbb { E } \left[ \pmb { \eta } ( \pmb { x } ) ^ { \top } \pmb { \eta } ( \pmb { y } ) \right]
$$

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license where $\pmb { \eta } ( \pmb { x } ) \in \mathbb { R } ^ { M }$ is a random feature vector derived from $_ { x }$ , either based on trigonometric functions Equation (17.60) or exponential functions Equation (17.61). (The latter has the advantage that all the features are positive, which gives much better results [Cho+20b].) Therefore for the regular softmax attention, $A _ { i , j }$ can be rewritten as

![](images/695bc4bae9f28a1f3c6872b7eb5f678ca9a50641f886cc8500524bf36c6cdc78.jpg)  
Figure 15.30: Attention matrix $\mathbf { A }$ rewritten as a product of two lower rank matrices $\mathbf { Q } ^ { \prime }$ and $\mathbf { \Sigma } ( \mathbf { K } ^ { \prime } ) ^ { \top }$ with random feature maps $\pmb { \phi } ( \pmb { q } _ { i } ) \in \mathbb { R } ^ { M }$ and $\boldsymbol { \phi } ( \boldsymbol { v } _ { k } ) \in \mathbb { R } ^ { M }$ for the corresponding queries/keys stored in the rows/columns. Used with kind permission of Krzysztof Choromanski.

$$
A _ { i , j } = \mathbb { E } [ \phi ( { \pmb q } _ { i } ) ^ { \top } \phi ( { \pmb k } _ { j } ) ]
$$

where $\phi$ is defined as:

$$
\phi ( \pmb { x } ) \triangleq \exp \left( \frac { \| \pmb { x } \| _ { 2 } ^ { 2 } } { 2 \sqrt { D } } \right) \eta \left( \frac { \pmb { x } } { D ^ { \frac { 1 } { 4 } } } \right) .
$$

We can write the full attention matrix as follows

$$
\mathbf { A } = \mathbb { E } [ \mathbf { Q } ^ { \prime } ( \mathbf { K } ^ { \prime } ) ^ { \mathsf { T } } ]
$$

where $\mathbf { Q } ^ { \prime } , \mathbf { K } ^ { \prime } \in \mathbb { R } ^ { N \times M }$ have rows encoding random feature maps corresponding to the queries and keys. (Note that we can get better performance if we ensure these random features are orthogonal, see [Cho+20a] for the details.) See Figure 15.30 for an illustration.

We can create an approximation to $\mathbf { A }$ by using a single sample of the random features $\phi ( { \pmb q } _ { i } )$ and $\phi ( k _ { j } )$ , and using a small value of $M$ , say $M = O ( D \log ( D ) )$ . We can then approximate the entire attention operator in $O ( N )$ time using

$$
\widehat { \mathrm { a t t e n t i o n } } ( \mathbf { Q } , \mathbf { K } , \mathbf { V } ) = \mathrm { d i a g } ^ { - 1 } ( \mathbf { Q } ^ { \prime } ( ( \mathbf { K } ^ { \prime } ) ^ { \mathsf { T } } \mathbf { 1 } _ { N } ) ) ( \mathbf { Q } ^ { \prime } ( ( \mathbf { K } ^ { \prime } ) ^ { \mathsf { T } } \mathbf { V } ) )
$$

This can be shown to be an unbiased approximation to the exact softmax attention operator. See Figure 15.31 for an illustration. (For details on how to generalize this to masked (causal) attention, see [Cho+20a].)

# 15.7 Language models and unsupervised representation learning

We have discussed how RNNs and autoregressive (decoder-only) transformers can be used as language models, which are generative sequence models of the form $\begin{array} { r } { p ( x _ { 1 } , . . . , x _ { T } ) = \prod _ { t = 1 } ^ { T } p ( x _ { t } | \pmb { x } _ { 1 : t - 1 } ) } \end{array}$ , where

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022 each $x _ { t }$ is a discrete token, such as a word or wordpiece. (See Section 1.5.4 for a discussion of text preprocessing methods.) The latent state of these models can then be used as a continuous vector representation of the text. That is, instead of using the one-hot vector $\scriptstyle { \mathbf { x } } _ { t }$ , or a learned embedding of it (such as those discussed in Section 20.5), we use the hidden state $\mathbf { } h _ { t }$ , which depends on all the previous words in the sentence. These vectors can then be used as contextual word embeddings, for purposes such as text classification or seq2seq tasks (see e.g. [LKB20] for a review). The advantage of this approach is that we can pre-train the language model in an unsupervised way, on a large corpus of text, and then we can fine-tune the model in a supervised way on a small labeled task-specific dataset. (This general approach is called transfer learning, see Section 19.2 for details.)

![](images/492316bbfd98af3b94675bd21957c56b3a3e2b3ea8fb65946e5425c453e30629.jpg)  
Figure 15.31: Decomposition of the attention matrix A can be leveraged to improve attention computations via matrix associativity property. To compute AV, we first calculate $\mathbf { G } = ( k ^ { \prime } ) ^ { \mathsf { T } } \mathbf { V }$ and then $\pmb { q } ^ { \prime } \mathbf { G }$ , resulting in linear in N space and time complexity. Used with kind permission of Krzysztof Choromanski.

If our primary goal is to compute useful representations for transfer learning, as opposed to generating text, we can replace the generative sequence model with non-causal models that can compute a representation of a sentence, but cannot generate it. These models have the advantage that now the hidden state $\mathbf { } h _ { t }$ can depend on the past, $\pmb { y } _ { 1 : t - 1 }$ , present ${ \mathbf { } } _ { \mathbf { } } \mathbf { \mathbf { } } _ { \mathbf { } } \mathbf { \mathbf { } } \mathbf { \mathbf { } } \mathbf { \mathbf { } } \mathbf { \mathbf { } } \mathbf { \mathbf { } } \mathbf { \mathbf { } } \mathbf { \mathbf { } } \mathbf { \mathbf { } } \mathbf { \mathbf { } } \mathbf { \mathbf { } \mathbf { } } \mathbf { \mathbf { } \mathbf { } } \mathbf { \mathbf { } \mathbf { } } \mathbf { \Xi } \mathbf { \mathbf { } } \mathbf { \Xi } \mathbf { \mathbf { } \mathbf { } } \mathbf { \Xi } \mathbf { \mathbf { } \Xi } \mathbf { \Xi } \mathbf { \Xi } \mathbf { \Xi } \mathbf { \Xi } \mathbf { \Xi } \mathbf { \Xi } \mathbf { \Xi } \mathbf { \Xi }$ , and future, $\mathbf { \mathscr { y } } _ { t + 1 : T }$ . This can sometimes result in better representations, since it takes into account more context.

In the sections below, we briefly discuss some unsupervised models for representation learning on text, using both causal and non-causal models.

# 15.7.1 ELMo

In [Pet+18], they present a method called ELMo, which is short for “Embeddings from Language Model”. The basic idea is to fit two RNN language models, one left-to-right, and one right-to-left, and then to combine their hidden state representations to come up with an embedding for each word. Unlike a biRNN (Section 15.2.2), which needs an input-output pair, ELMo is trained in an unsupervised way, to minimize the negative log likelihood of the input sentence $\pmb { x } _ { 1 : T }$ :

$$
\mathcal { L } ( \pmb { \theta } ) = - \sum _ { t = 1 } ^ { T } [ \log p ( x _ { t } | \pmb { x } _ { 1 : t - 1 } ; \pmb { \theta } _ { e } , \pmb { \theta } ^ { \right. } , \pmb { \theta } _ { s } ) + \log p ( x _ { t } | \pmb { x } _ { t + 1 : T } ; \pmb { \theta } _ { e } , \pmb { \theta } ^ { \left. } , \pmb { \theta } _ { s } ) ]
$$

where $\pmb { \theta } _ { e }$ are the shared parameters of the embedding layer, $\pmb { \theta } _ { s }$ are the shared parameters of the softmax output layer, and $\theta ^ {  }$ and $\mathbf { \nabla } \theta ^ {  }$ are the parameters of the two RNN models. (They use LSTM

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

U 0 Θ Softmax 中串电串 S'o S Θ Embedding

RNNs, described in Section 15.2.7.2.) See Figure 15.32 for an illustration.

After training, we define the contextual representation ${ \pmb r } _ { t } = [ e _ { t } , h _ { t , 1 : L } ^ { \right. } , h _ { t , 1 : L } ^ { \left. } ]$ , where $L$ is the number of layers in the LSTM. We then learn a task-specific set of linear weights to map this to the final context-specific embedding of each token: $\boldsymbol { r } _ { t } ^ { j } = \boldsymbol { r } _ { t } ^ { \intercal } \boldsymbol { w } ^ { j }$ , where $j$ is the task id. If we are performing a syntactic task like part-of-speech (POS) tagging (i.e., labeling each word as a noun, verb, adjective, etc), then the task will learn to put more weight on lower layers. If we are performing a semantic task like word sense disambiguation (WSD), then the task will learn to put more weight on higher layers. In both cases, we only need a small amount of task-specific labeled data, since we are just learning a single weight vector, to map from $r _ { 1 : T }$ to the target labels $\mathbf { \pmb { y } } _ { 1 : T }$ .

# 15.7.2 BERT

In this section, we describe the BERT model (Bidirectional Encoder Representations from Transformers) of [Dev+19]. Like ELMo, this is a non-causal model, that can be used to create representations of text, but not to generate text. In particular, it uses a transformer model to map a modified version of a sequence back to the unmodified form. The modified input at location $t$ omits all words except for the $t$ ’th, and the task is to predict the missing word. This is called the fill-in-the-blank or cloze task.

# 15.7.2.1 Masked language model task

More precisely, the model is trained to minimize the negative log pseudo-likelihood:

$$
\mathcal { L } = \mathbb { E } _ { { \pmb x } \sim \mathcal { D } } \mathbb { E } _ { m } \sum _ { i \in m } - \log p ( x _ { i } | \pmb x _ { - m } )
$$

where $_ { m }$ is a random binary mask. For example, if we train the model on transcripts from cooking videos, we might create a training sentence of the form

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

![](images/78bd42996819069b8d1196a6aa218ecf8ef7d4a8e4de6056767103fe3df51c02.jpg)  
Figure 15.33: Illustration of (a) BERT and (b) GPT. $E _ { t }$ is the embedding vector for the input token at location $t$ , and $T _ { t }$ is the output target to be predicted. From Figure $\mathcal { B }$ of [Dev+19]. Used with kind permission of Ming-Wei Chang.

Let’s make [MASK] chicken! [SEP] It [MASK] great with orange sauce.

where [SEP] is a separator token inserted between two sentences. The desired target labels for the masked words are “some” and “tastes”. (This example is from [Sun+19a].)

The conditional probability is given by applying a softmax to the final layer hidden vector at location $i$ :

$$
p ( x _ { i } | \hat { \mathbf { x } } ) = \frac { \exp ( { h ( \hat { \mathbf { x } } ) } _ { i } ^ { \top } e ( x _ { i } ) ) } { \sum _ { x ^ { \prime } } \exp ( { h ( \hat { \mathbf { x } } ) } _ { i } ^ { \top } e ( x ^ { \prime } ) ) }
$$

where $\hat { \pmb x } = { \pmb x } _ { - m }$ is the masked input sentence, and $e ( x )$ is the embedding for token $x$ . This is used to compute the loss at the masked locations; this is therefore called a masked language model. (This is similar to a denoising autoencoder, Section 20.3.2). See Figure 15.33a for an illustration of the model.

# 15.7.2.2 Next sentence prediction task

In addition to the masked language model objective, the original BERT paper added an additional objective, in which the model is trained to classify if one sentence follows another. More precisely, the model is fed as input

CLS $A _ { 1 }$ $A _ { 2 }$ ; . . . $A _ { m }$ ; SEP $B _ { 1 } \ B _ { 2 } ; \ldots ; B _ { n }$ SEP

where SEP is a special separator token, and CLS is a special token marking the class. If sentence B follows A in the original text, we set the target label to $y = 1$ , but if B is a randomly chosen sentence, we set the target label to $y = 0$ . This is called the next sentence prediction task. This kind of pre-training can be useful for sentence-pair classification tasks, such as textual entailment or textual similarity, which we discussed in Section 15.4.6. (Note that this kind of pre-training is considered unsupervised, or self-supervised, since the target labels are automatically generated.)

When performing next sentence prediction, the input to the model is specified using 3 different embeddings: one per token, one for each segment label (sentence A or B), and one per location

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license (using a learned positional embedding). These are then added. See Figure 15.34 for an illustration. BERT then uses a transformer encoder to learn a mapping from this input embedding sequence to an output embedding sequence, which gets decoded into word labels (for the masked locations) or a class label (for the CLS location).

![](images/53a0d02105f8ab0019a9bda6ed8278d71daa9f97c18db749387fe41f35d22266.jpg)  
Figure 15.34: Illustration of how a pair of input sequences, denoted A and $B$ , are encoded before feeding to BERT. From Figure 14.8.2 of [Zha+20]. Used with kind permission of Aston Zhang.

# 15.7.2.3 Fine-tuning BERT for NLP applications

After pre-training BERT in an unsupervised way, we can use it for various downtream tasks by performing supervised fine-tuning. (See Section 19.2 for more background on such transfer learning methods.) Figure 15.35 illustrates how we can modify a BERT model to perform different tasks, by simply adding one or more new output heads to the final hidden layer. See bert_jax.ipynb for some sample code.

In Figure 15.35(a), we show how we can tackle single sentence classification (e.g., sentiment analysis): we simply take the feature vector associated with the dummy CLS token and feed it into an MLP. Since each output attends to all inputs, this hidden vector will summarize the entire sentence. The MLP then learns to map this to the desired label space.

In Figure 15.35(b), we show how we can tackle sentence-pair classification (e.g., textual entailment, as discussed in Section 15.4.6): we just feed in the two input sentences, formatted as in Equation (15.73), and then classify the CLS token.

In Figure 15.35(c), we show how we can tackle single sentence tagging, in which we associate a label or tag with each word, instead of just the entire sentence. A common application of this is part of speech tagging, in which we annotate each words a noun, verb, adjective, etc. Another application of this is noun phrase chunking, also called shallow parsing, in which we must annotate the span of each noun phrase. The span is encoded using the BIO notation, in which B is the beginning of an entity, I-x is for inside, and O is for outside any entity. For example, consider the following sentence:

B I O O O B I O B I I

British Airways rose after announcing its withdrawl from the UAI deal

We see that there are 3 noun phrases, “British Airways”, “its withdrawl” and “the UAI deal”. (We require that the B, I and O labels occur in order, so this a prior constraint that can be included in the model.)

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

![](images/47be4887420761a3d2f08c52f64b6c368c1a098b387b1600e6b87dcafe1e5b6e.jpg)  
Figure 15.35: Illustration of how BERT can be used for different kinds of supervised NLP tasks. (a) Single sentence classification (e.g., sentiment analysis); (b) Sentence-pair classification (e.g., textual entailment); (d) Single sentence tagging (e.g., shallow parsing); (d) Question answering. From Figure 4 of [Dev+19]. Used with kind permission of Ming-Wei Chang.

We can also associate types with each noun phrase, for example distinguishing person, location, organization, and other. Thus the label space becomes {B-Per, I-Per, B-Loc, I-Loc, B-Org, I-Org, Outside $\}$ . This is called named entity recognition, and is a key step in information extraction. For example, consider the following sentence:

BP IP O O O BL IL BP O O O O Mrs Green spoke today in New York. Green chairs the finance committee.

From this, we infer that the first sentence has two named entities, namely “Mrs Green” (of type Person) and “New York” (of type Location). The second sentence mentions another person, “Green”, that most likely is the same as the first person, although this across-sentence entity resolution is not part of the basic NER task.

Finally, in Figure 15.35(d), we show how we can tackle question answering. Here the first input sentence is the question, the second is the background text, and the output is required to specifying the start and end locations of the relevant part of the background that contains the answer (see Table 1.4). The start location $s$ and end location $e$ are computed by applying 2 different MLPs to a pooled version of the output encodings for the background text; the output of the MLPs is a softmax over all locations. At test time, we can extract the span $( i , j )$ which maximizes the sum of scores $s _ { i } + e _ { j }$ for $i \leq j$ .

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

BERT achieves state-of-the-art performance on many NLP tasks. Interestingly, [TDP19] shows that BERT implicitly rediscovers the standard NLP pipeline, in which different layers perform tasks such as part of speech (POS) tagging, parsing, named entity relationship (NER) detection, semantic role labeling (SRL), coreference resolution, etc. More details on NLP can be found in [JM20].

# 15.7.3 GPT

In [Rad+18], they propose a model called GPT, which is short for “Generative Pre-training Transformer”. This is a causal (generative) model, that uses a masked transformer as the decoder. See Figure 15.33b for an illustration.

In the original GPT paper, they jointly optimize on a large unlabeled dataset, and a small labeled dataset. In the classification setting, the loss is given by $\mathcal { L } = \mathcal { L } _ { \mathrm { c l s } } + \lambda \mathcal { L } _ { \mathrm { L M } }$ , where ${ \mathcal { L } } _ { \mathrm { c l s } } =$ $- \sum _ { ( \pmb { x } , y ) \in \mathcal { D } _ { L } } \log p ( y | \pmb { x } )$ is the classification loss on the labeled data, and $\begin{array} { r } { \mathcal { L } _ { \mathrm { L M } } = - \sum _ { \mathbf { \boldsymbol { x } } \in \mathcal { D } _ { U } } \sum _ { t } p ( x _ { t } | \mathbf { \boldsymbol { x } } _ { 1 : t - 1 } ) } \end{array}$ is the language modeling loss on the unlabeled data.

In [Rad+19], they propose GPT-2, which is a larger version of GPT, trained on a large web corpus called WebText. They also eliminate any task-specific training, and instead just train it as a language model. More recently, OpenAI released GPT-3 [Bro+20], which is an even larger version of GPT-2, but based on the same principles. An open-source version of the model is available at https://huggingface.co/EleutherAI, which was trained on an 800GB English-language web corpus called “The Pile” [Gao+20].

# 15.7.3.1 Applications of GPT

GPT can generate text given an initial input prompt. The prompt can specify a task; if the generated response fulfills the task “out of the box”, we say the model is performing zero-shot task transfer (see Section 19.6 for details).

For example, to perform abstractive summarization of some input text $\pmb { x } _ { 1 : T }$ (as opposed to extractive summarization, which just selects a subset of the input words), we sample from $p ( { \pmb x } _ { T + 1 : T + 1 0 0 } | [ { \pmb x } _ { 1 : T } ; \mathrm { T L } ; \mathrm { D R } ] ,$ , where TL;DR is a special token added to the end of the input text, which tells the system the user wants a summary. TL;DR stands for “too long; didn’t read” and frequently occurs in webtext followed by a human-created summary. By adding this token to the input, the user hopes to “trigger” the transformer decoder into a state in which it enters summarization mode. (A better way to tell the model what task to perform is to train it on input-output pairs, as discussed in Section 15.7.4.)

# 15.7.4 T5

Many models are trained in an unsupervised way, and then fine-tuned on specific tasks. It is also possible to train a single model to perform multiple tasks, by telling the system what task to perform as part of the input sentence, and then training it as a seq2seq model, as illustrated in Figure 15.36. This is the approach used in T5 [Raf+20], which stands for “Text-to-text Transfer Transformer”. The model is a standard seq2seq transformer, that is pretrained on unsupervised $( { \pmb x } ^ { \prime } , { \pmb x } ^ { \prime \prime } )$ pairs, where $\mathbf { { x } ^ { \prime } }$ is a masked version of $_ { x }$ and ${ \pmb x } ^ { \prime \prime }$ are the missing tokens that need to be predicted, and then fine-tuned on multiple supervised $( { \pmb x } , { \pmb y } )$ pairs.

The unsupervised data comes from C4, or the “Colossal Clean Crawled Corpus”, a 750GB corpus of web text. This is used for pretraining using a BERT-like denoising objective. For example, the

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022 "translate English to German: That is good. "cola sentence: The "Das ist gut." course is jumping well. T5 "not acceptable" "stsb sentence1: The rhino grazed on the grass. sentence2: A rhino is grazing in a field." "3.8" "summarize: state authorities "six people hospitalized after dispatched emergency crews tuesday to a storm in attala county." survey the damage after an onslaught of severe weather in mississippi…"

sentence ${ \bf \mathcal { x } } =$ “Thank you for inviting me to your party last week” may get converted to the input $\pmb { x } ^ { \prime } =$ “Thank you $<$ <X $>$ me to your party $<$ <Y $>$ week” and the output (target) $\pmb { x } ^ { \prime \prime } = \mathbf { \lambda } ^ { 6 } <$ <X $>$ for inviting $<$ <Y $>$ last $<$ <EOS $>$ ”, where $< X >$ and $< Y >$ are tokens that are unique to this example. The supervised datasets are manually created, and are taken from the literature. This approach is currently the state-of-the-art on many NLP tasks.

# 15.7.5 Discussion

Giant language models, such as BERT and GPT-3, have recently generated a lot of interest, and have even made their way into the mainstream media.7 However, there is some doubt about whether such systems “understand” language in any meaningful way, beyond just rearranging word patterns seen in their massive training sets. For example, [NK19] show that the ability of BERT to perform almost as well as humans on the Argument Reasoning Comprehension Task is “entirely accounted for by exploitation of spurious statistical cues in the dataset”. By slightly tweaking the dataset, performance can be reduced to chance levels. For other criticisms of such models, see e.g., [BK20; Mar20].

# Part IV

# Nonparametric Models

# 16 Exemplar-based Methods

So far in this book, we have mostly focused on parametric models, either unconditional $p ( \pmb { y } | \pmb { \theta } )$ or conditional $p ( \pmb { y } | \pmb { x } , \pmb { \theta } )$ , where $\pmb \theta$ is a fixed-dimensional vector of parameters. The parameters are estimated from a variable-sized dataset, $\mathcal { D } = \{ ( \boldsymbol { x } _ { n } , \boldsymbol { y } _ { n } ) : n = 1 : N \}$ , but after model fitting, the data is thrown away.

In this section we consider various kinds of nonparametric models, that keep the training data around. Thus the effective number of parameters of the model can grow with $| \mathcal D |$ . We focus on models that can be defined in terms of the similarity between a test input, $_ { x }$ , and each of the training inputs, ${ \boldsymbol { \mathbf { \mathit { x } } } } _ { n }$ . Alternatively, we can define the models in terms of a dissimilarity or distance function $d ( { \pmb x } , { \pmb x } _ { n } )$ . Since the models keep the training examples around at test time, we call them exemplar-based models. (This approach is also called instance-based learning [AKA91], or memory-based learning.)

# 16.1 K nearest neighbor (KNN) classification

In this section, we discuss one of the simplest kind of classifier, known as the $\mathbf { K }$ nearest neighbor (KNN) classifier. The idea is as follows: to classify a new input $_ { x }$ , we find the $K$ closest examples to $_ { x }$ in the training set, denoted $N _ { K } ( { \pmb x } , { \mathcal { D } } )$ , and then look at their labels, to derive a distribution over the outputs for the local region around $_ { x }$ . More precisely, we compute

$$
p ( y = c | \pmb { x } , \mathcal { D } ) = \frac { 1 } { K } \sum _ { n \in N _ { K } ( \pmb { x } , \mathcal { D } ) } \mathbb { I } \left( y _ { n } = c \right)
$$

We can then return this distribution, or the majority label.

The two main parameters in the model are the size of the neighborhood, $K$ , and the distance metric $d ( { \pmb x } , { \pmb x } ^ { \prime } )$ . For the latter, it is common to use the Mahalanobis distance

$$
d _ { \mathbf { M } } ( \mathbf { \boldsymbol { x } } , \mu ) = \sqrt { ( \mathbf { \boldsymbol { x } } - \mu ) ^ { \top } \mathbf { \mathbf { M } } ( \mathbf { \boldsymbol { x } } - \mu ) }
$$

where $\mathbf { M }$ is a positive definite matrix. If $\mathbf M = \mathbf I$ , this reduces to Euclidean distance. We discuss how to learn the distance metric in Section 16.2.

Despite the simplicity of KNN classifiers, it can be shown that this approach becomes within a factor of 2 of the Bayes error (which measures the performance of the best possible classifier) if $N  \infty$ [CH67; CD14]. (Of course the convergence rate to this optimal performance may be poor in practice, for reasons we discuss in Section 16.1.2.)

![](images/d0a431f75bc3b8946327507e02a16224c44e3b5e2ed4c364856ebb1c4b949b00.jpg)  
Figure 16.1: (a) Illustration of a $K$ -nearest neighbors classifier in 2d for $K = 5$ . The nearest neighbors of test point x have labels $\{ 1 , 1 , 1 , 0 , 0 \}$ , so we predict $p ( y = 1 | \mathbf { x } , D ) = 3 / 5$ . (b) Illustration of the Voronoi tessellation induced by 1-NN. Adapted from Figure 4.13 of [DHS01]. Generated by knn_voronoi_plot.ipynb.

# 16.1.1 Example

We illustrate the KNN classifier in 2d in Figure 16.1(a) for $K = 5$ . The test point is marked as an “x”. 3 of the 5 nearest neighbors have label 1, and 2 of the 5 have label 0. Hence we predict $p ( y = 1 | x , \mathcal { D } ) = 3 / 5 = 0 . 6$ .

If we use $K = 1$ , we just return the label of the nearest neighbor, so the predictive distribution becomes a delta function. A KNN classifier with $K = 1$ induces a Voronoi tessellation of the points (see Figure 16.1(b)). This is a partition of space which associates a region $V ( \pmb { x } _ { n } )$ with each point ${ \boldsymbol { \mathbf { \mathit { x } } } } _ { n }$ in such a way that all points in $V ( \pmb { x } _ { n } )$ are closer to ${ \boldsymbol { \mathbf { \mathit { x } } } } _ { n }$ than to any other point. Within each cell, the predicted label is the label of the corresponding training point. Thus the training error will be 0 when $K = 1$ . However, such a model is usually overfitting the training set, as we show below.

Figure 16.2 gives an example of KNN applied to a 2d dataset, in which we have three classes. We see how, with $K = 1$ , the method makes zero errors on the training set. As $K$ increases, the decision boundaries become smoother (since we are averaging over larger neighborhoods), so the training error increases, as we start to underfit. This is shown in Figure 16.2(d). The test error shows the usual U-shaped curve.

# 16.1.2 The curse of dimensionality

The main statistical problem with KNN classifiers is that they do not work well with high dimensional inputs, due to the curse of dimensionality.

The basic problem is that the volume of space grows exponentially fast with dimension, so you might have to look quite far away in space to find your nearest neighbor. To make this more precise, consider this example from [HTF09, p22]. Suppose we apply a KNN classifier to data where the inputs are uniformly distributed in the $D$ -dimensional unit cube. Suppose we estimate the density of class labels around a test point $_ { x }$ by “growing” a hyper-cube around $_ { x }$ until it contains a desired fraction $p$ of the data points. The expected edge length of this cube will be $e _ { D } ( s ) \triangleq p ^ { 1 / D }$ ; this function is plotted in Figure 16.3(b). If $D = 1 0$ , and we want to base our estimate on $1 0 \%$ of the

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

![](images/8e17b1fd5e38e529069547d6c8ad8feaefda11b67393ee16a289436cd7523ef7.jpg)  
Figure 16.2: Decision boundaries induced by a KNN classifier. (a) $K = 1$ . (b) $K = 2$ . (c) $K = 5$ . (d) Train and test error vs $K$ . Generated by knn_classify_demo.ipynb.

![](images/cbfb42c859dd97ae69118f21da322edda3ecf967249745e1f01fc6e8af486b1b.jpg)  
Figure 16.3: Illustration of the curse of dimensionality. (a) We embed a small cube of side s inside a larger unit cube. (b) We plot the edge length of a cube needed to cover a given volume of the unit cube as a function of the number of dimensions. Adapted from Figure 2.6 from [HTF09]. Generated by curse_dimensionality_plot.ipynb.

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license data, we have $e _ { 1 0 } ( 0 . 1 ) = 0 . 8$ , so we need to extend the cube 80% along each dimension around $_ { x }$ . Even if we only use $1 \%$ of the data, we find $e _ { 1 0 } ( 0 . 0 1 ) = 0 . 6 3$ . Since the range of the data is only 0 to 1 along each dimension, we see that the method is no longer very local, despite the name “nearest neighbor”. The trouble with looking at neighbors that are so far away is that they may not be good predictors about the behavior of the function at a given point.

There are two main solutions to the curse: make some assumptions about the form of the function (i.e., use a parametric model), and/or use a metric that only cares about a subset of the dimensions (see Section 16.2).

# 16.1.3 Reducing the speed and memory requirements

KNN classifiers store all the training data. This is obviously very wasteful of space. Various heuristic pruning techniques have been proposed to remove points that do not affect the decision boundaries, see e.g., [WM00]. In Section 17.4, we discuss a more principled approach based on a sparsity promoting prior; the resulting method is called a sparse kernel machine, and only keeps a subset of the most useful exemplars.

In terms of running time, the challenge is to find the $K$ nearest neighbors in less than $O ( N )$ time, where $N$ is the size of the training set. Finding exact nearest neighbors is computationally intractable when the dimensionality of the space goes above about 10 dimensions, so most methods focus on finding the approximate nearest neighbors. There are two main classes of techniques, based on partitioning space into regions, or using hashing.

For partitioning methods, one can either use some kind of k-d tree, which divides space into axis-parallel regions, or some kind of clustering method, which uses anchor points. For hashing methods, locality sensitive hashing (LSH) [GIM99] is widely used, although more recent methods learn the hashing function from data (see e.g., [Wan+15]). See [LRU14] for a good introduction to hashing methods.

An open-source library called FAISS, for efficient exact and approximate nearest neighbor search (and K-means clustering) of dense vectors, is available at https://github.com/facebookresearch/ faiss, and described in [JDJ17].

# 16.1.4 Open set recognition

Ask not what this is called, ask what this is like. — Moshe Bar.[Bar09]

In all of the classification problems we have considered so far, we have assumed that the set of classes $\boldsymbol { \mathcal { C } }$ is fixed. (This is an example of the closed world assumption, which assumes there is a fixed number of (types of) things.) However, many real world problems involve test samples that come from new categories. This is called open set recognition, as we discuss below.

# 16.1.4.1 Online learning, OOD detection and open set recognition

For example, suppose we train a face recognition system to predict the identity of a person from a fixed set or gallery of face images. Let $\mathcal { D } _ { t } = \{ ( \boldsymbol { x } _ { n } , y _ { n } ) : \boldsymbol { x } _ { n } \in \mathcal { X } , y _ { n } \in \mathcal { C } _ { t } , n = 1 : N _ { t } \}$ be the labeled dataset at time $t$ , where $\mathcal { X }$ is the set of (face) images, and $\mathcal { C } _ { t } = \{ 1 , \ldots , C _ { t } \}$ is the set of people known to the system at time $t$ (where $C _ { t } \leq t$ ). At test time, the system may encounter a new person that it has not seen before. Let $\boldsymbol { x } _ { t + 1 }$ be this new image, and $y _ { t + 1 } = C _ { t + 1 }$ be its new label. The system

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022 needs to recognize that the input is from a new category, and not accidentally classify it with a label from $\scriptstyle { \mathcal { C } } _ { t }$ . This is called novelty detection. In this case, the input is being generated from the distribution $p ( \pmb { x } | y = C _ { t + 1 } )$ , where $C _ { t + 1 } \notin \mathcal { C } _ { t }$ is the new “class label”. Detecting that $\boldsymbol { x } _ { t + 1 }$ is from a novel class may be hard if the appearance of this new image is similar to the appearance of any of the existing images in $\mathcal { D } _ { t }$ .

If the system is successful at detecting that $\boldsymbol { x } _ { t + 1 }$ is novel, then it may ask for the id of this new instance, call it $C _ { t + 1 }$ . It can then add the labeled pair $( \pmb { x } _ { t + 1 } , C _ { t + 1 } )$ to the dataset to create $\mathcal { D } _ { t + 1 }$ , and can grow the set of unique classes by adding $C _ { t + 1 }$ to $\mathit { \check { C } } _ { t }$ (c.f., [JK13]). This is called incremental learning, online learning, life-long learning, or continual learning. At future time points, the system may encounter an image sampled from $p ( { \pmb x } | y = c )$ , where $c$ is an existing class, or where $c$ is a new class, or the image may be sampled from some entirely different kind of distribution $p ^ { \prime } ( { \pmb x } )$ unrelated to faces (e.g., someone uploads a photo of their dog). (Detecting this latter kind of event is called out-of-distribution or OOD detection.)

In this online setting, we often only get a few (sometimes just one) example of each class. Prediction in this setting is known as few-shot classification, and is discussed in more detail in Section 19.6. KNN classifiers are well-suited to this task. For example, we can just store all the instances of each class in a gallery of examples, as we explained above. At time $t + 1$ , when we get input $\pmb { x } _ { t + 1 }$ , rather than predicting a label for $\pmb { x } _ { t + 1 }$ by comparing it to some parametric model for each class, we just find the example in the gallery that is nearest (most similar) to $\pmb { x } _ { t + 1 }$ , call it $\mathbf { { x } ^ { \prime } }$ . We then need to determine if $\mathbf { { x } ^ { \prime } }$ and are sufficiently similar to constitute a match. (In the context of person $\boldsymbol { x } _ { t + 1 }$ classification, this is known as person re-identification or face verification, see e.g., [WSH16]).) If there is no match, we can declare the input to be novel or OOD.

The key ingredient for all of the above problems is the (dis)similarity metric between inputs. We discuss ways to learn this in Section 16.2.

# 16.1.4.2 Other open world problems

The problem of open-set recognition, and incremental learning, are just examples of problems that require the open world assumption c.f., [Rus15]. There are many other examples of such problems. For example, consider the problem of entity resolution, called entity linking. In this problem, we need to determine if different strings (e.g., “John Smith” and “Jon Smith”) refer to the same entity or not. See e.g. [SHF15] for details.

Another important application is in multi-object tracking. For example, when a radar system detects a new “blip”, is it due to an existing missile that is being tracked, or is it a new objective that has entered the airspace? An elegant mathematical framework for dealing with such problems, known as random finite sets, is described in [Mah07; Mah13; Vo+15].

# 16.2 Learning distance metrics

Being able to compute the “semantic distance” between a pair of points, $d ( { \pmb x } , { \pmb x } ^ { \prime } ) \in \mathbb { R } ^ { + }$ for $\pmb { x } , \pmb { x } ^ { \prime } \in \mathcal { X }$ , or equivalently their similarity $s ( \pmb { x } , \pmb { x } ^ { \prime } ) \in \mathbb { R } ^ { + }$ , is of crucial importance to tasks such as nearest neighbor classification (Section 16.1), self-supervised learning (Section 19.2.4.4), similarity-based clustering (Section 21.5), content-based retrieval, visual tracking, etc.

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

When the input space is $\chi = \mathbb { R } ^ { D }$ , the most common distance metric is the Mahalanobis distance

$$
d _ { \bf M } ( { \pmb x } , { \pmb x } ^ { \prime } ) = \sqrt { ( { \pmb x } - { \pmb x } ^ { \prime } ) ^ { \top } { \bf M } ( { \pmb x } - { \pmb x } ^ { \prime } ) }
$$

We discuss some methods to learn the matrix $\mathbf { M }$ in Section 16.2.1. For high dimensional inputs, or structured inputs, it is better to first learn an embedding $e = f ( { \pmb x } )$ , and then to compute distances in embedding space. When $f$ is a DNN, this is called deep metric learning; we discuss this in Section 16.2.2.

# 16.2.1 Linear and convex methods

In this section, we discuss some methods that try to learn the Mahalanobis distance matrix M, either directly (as a convex problem), or indirectly via a linear projection. For other approaches to metric learning, see e.g., [Kul13; Kim19] for more details.

# 16.2.1.1 Large margin nearest neighbors

In [WS09], they propose to learn the Mahalanobis matrix M so that the resulting distance metric works well when used by a nearest neighbor classifier. The resulting method is called large margin nearest neighbor or LMNN.

This works as follows. For each example data point $i$ , let $N _ { i }$ be a set of target neighbors; these are usually chosen to be the set of $K$ points with the same class label that are closest in Euclidean distance. We now optimize $\mathbf { M }$ so that we minimize the distance between each point $i$ and all of its target neighbors $j \in N _ { i }$ :

$$
\mathcal { L } _ { \mathrm { p u l l } } ( \mathbf { M } ) = \sum _ { i = 1 } ^ { N } \sum _ { j \in N _ { i } } d _ { \mathbf { M } } ( \mathbf { x } _ { i } , \mathbf { x } _ { j } ) ^ { 2 }
$$

We also want to ensure that examples with incorrect labels are far away. To do this, we ensure that each example $i$ is closer (by some margin $m \geq 0$ ) to its target neighbors $j$ than to other points $\it l$ with different labels (so-called impostors). We can do this by minimizing

$$
\mathcal { L } _ { \mathrm { p u s h } } ( \mathbf { M } ) = \sum _ { i = 1 } ^ { N } \sum _ { j \in N _ { i } } \sum _ { l = 1 } ^ { N } \mathbb { I } \left( y _ { i } \neq y _ { l } \right) \left[ m + d _ { \mathbf { M } } ( \pmb { x } _ { i } , \pmb { x } _ { j } ) ^ { 2 } - d _ { \mathbf { M } } ( \pmb { x } _ { i } , \pmb { x } _ { l } ) ^ { 2 } \right] +
$$

where $[ z ] _ { + } = \operatorname* { m a x } ( z , 0 )$ is the hinge loss function (Section 4.3.2). The overall objective is ${ \mathcal { L } } ( \mathbf { M } ) =$ $( 1 - \lambda ) \mathcal { L } _ { \mathrm { p u l l } } ( \mathbf { M } ) + \lambda \mathcal { L } _ { \mathrm { p u s h } } ( \mathbf { M } )$ , where $0 < \lambda < 1$ . This is a convex function defined over a convex set, which can be minimized using semidefinite programming. Alternatively, we can parameterize the problem using $\mathbf { M } = \mathbf { W } ^ { \parallel } \mathbf { W }$ , and then minimize wrt $\mathbf { W }$ using unconstrained gradient methods. This is no longer convex, but allows us to use a low-dimensional mapping $\mathbf { W }$ .

For large datasets, we need to tackle the $O ( N ^ { 3 } )$ cost of computing Equation (16.5). We discuss some speedup tricks in Section 16.2.5.

# 16.2.1.2 Neighborhood components analysis

Another way to learn a linear mapping W such that $\mathbf { M } = \mathbf { W } ^ { \sf I } \mathbf { W }$ is known as neighborhood components analysis or NCA [Gol+05]. This defines the probability that sample ${ \boldsymbol { x } } _ { i }$ has $\boldsymbol { x } _ { j }$ as its

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

![](images/056e54449ccd74455558380bcb9c08f2e2e11e4844cdba66dea70c97f55e0514.jpg)  
Figure 16.4: Illustration of latent coincidence analysis (LCA) as a directed graphical model. The inputs ${ \pmb x } , { \pmb x } ^ { \prime } \in \mathbb { R } ^ { D }$ are mapped into Gaussian latent variables $z , z ^ { \prime } \in \mathbb { R } ^ { L }$ via a linear mapping W. If the two latent points coincide (within length scale $\kappa$ ) then we set the similarity label to $y = 1$ , otherwise we set it to $y = 0$ . From Figure 1 of [DS12]. Used with kind permission of Lawrence Saul.

nearest neighbor using the linear softmax function

$$
p _ { i j } ^ { \mathbf { W } } = \frac { \exp ( - | | \mathbf { W } x _ { i } - \mathbf { W } x _ { j } | | _ { 2 } ^ { 2 } ) } { \sum _ { l \neq i } \exp ( - | | \mathbf { W } x _ { i } - \mathbf { W } x _ { l } | | _ { 2 } ^ { 2 } ) }
$$

(This is a supervised version of stochastic neighborhood embeddings discussed in Section 20.4.10.1.) W is given by J(W) = PiN=1 Pj̸=i:yj= The expected number of correctly classified examples according for a 1NN classifier using distance . Let $\mathcal { L } ( \mathbf { W } ) = 1 - J ( \mathbf { W } ) / N$ be the leave one out error. We can minimize $\mathcal { L }$ wrt $\mathbf { W }$ using gradient methods.

# 16.2.1.3 Latent coincidence analysis

Yet another way to learn a linear mapping W such that $\mathbf { M } = \mathbf { W } ^ { \parallel } \mathbf { W }$ is known as latent coincidence analysis or LCA [DS12]. This defines a conditional latent variable model for mapping a pair of inputs, $_ { x }$ and $\mathbf { { x } ^ { \prime } }$ , to a label $y \in \{ 0 , 1 \}$ , which specifies if the inputs are similar (e.g., have same class label) or dissimilar. Each input $\pmb { x } \in \mathbb { R } ^ { D }$ is mapped to a low dimensional latent point $z \in \mathbb { R } ^ { L }$ using a stochastic mapping $p ( z | \mathbf { \boldsymbol { x } } ) = \mathcal { N } ( z | \mathbf { W } \mathbf { \boldsymbol { x } } , \sigma ^ { 2 } \mathbf { I } )$ , and $p ( z ^ { \prime } | x ^ { \prime } ) = \mathcal { N } ( z ^ { \prime } | \mathbf { W } x ^ { \prime } , \sigma ^ { 2 } \mathbf { I } )$ . (Compare this to factor analysis, discussed in Section 20.2.) We then define the probability that the two inputs are similar using $\begin{array} { r } { p ( y = 1 | z , z ^ { \prime } ) = \exp ( - \frac { 1 } { 2 \kappa ^ { 2 } } | | z - z ^ { \prime } | | ) } \end{array}$ . See Figure 16.4 for an illustration of the modeling assumptions.

We can maximize the log marginal likelihood $\begin{array} { r } { \ell ( \mathbf { W } , \sigma ^ { 2 } , \kappa ^ { 2 } ) = \sum _ { n } \log p ( y _ { n } | \pmb { x } _ { n } , \pmb { x } _ { n } ^ { \prime } ) } \end{array}$ using the EM algorithm (Section 8.7.2). (We can set $\kappa = 1$ WLOG, since it just changes the scale of W.) More precisely, in the E step, we compute the posterior $p ( z , z ^ { \prime } | \mathbf { x } , \mathbf { x } ^ { \prime } , y )$ (which can be done in closed form), and in the M step, we solve a weighted least squares problem (c.f., Section 13.6.2). EM will monotonically increase the objective, and does not need step size adjustment, unlike the gradient based methods used in NCA (Section 16.2.1.2). (It is also possible to use variational Bayes (Section 4.6.8.3) to fit this model, as well as various sparse and nonlinear extensions, as discussed in [ZMY19].)

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

# 16.2.2 Deep metric learning

When measuring the distance between high-dimensional or structured inputs, it is very useful to first learn an embedding to a lower dimensional “semantic” space, where distances are more meaningful, and less subject to the curse of dimensionality (Section 16.1.2). Let $\pmb { e } = f ( \pmb { x } ; \pmb { \theta } ) \in \mathbb { R } ^ { L }$ be an embedding of the input that preserves the “relevant” semantic aspects of the input, and let $\hat { \pmb { e } } = \pmb { e } / | | \pmb { e } | | _ { 2 }$ be the $\ell _ { 2 }$ -normalized version. This ensures that all points lie on a hyper-sphere. We can then measure the distance between two points using the normalized Euclidean distance

$$
d ( \pmb { x } _ { i } , \pmb { x } _ { j } ; \pmb { \theta } ) = | | \hat { \pmb { e } } _ { i } - \hat { \pmb { e } } _ { j } | | _ { 2 } ^ { 2 }
$$

where smaller values means more similar, or the cosine similarity

$$
d ( \pmb { x } _ { i } , \pmb { x } _ { j } ; \pmb { \theta } ) = \hat { e } _ { i } ^ { \top } \hat { e } _ { j }
$$

where larger values means more similar. (Cosine similarity measures the angle between the two vectors, as illustrated in Figure 20.43.) These quantities are related via

$$
| | \hat { e } _ { i } - \hat { e } _ { j } | | _ { 2 } ^ { 2 } = ( \hat { e } _ { i } - \hat { e } _ { j } ) ^ { \mathsf { T } } ( \hat { e } _ { i } - \hat { e } _ { j } ) = 2 - 2 \hat { e } _ { i } ^ { \mathsf { T } } \hat { e } _ { j }
$$

This overall approach is called deep metric learning or DML.

The basic idea in DML is to learn the embedding function such that similar examples are closer than dissimilar examples. More precisely, we assume we have a labeled dataset, $\mathcal { D } = \{ ( x _ { i } , y _ { i } ) : i = 1 : N \}$ , from which we can derive a set of similar pairs, $S = \{ ( i , j ) : y _ { i } = y _ { j } \}$ . If $( i , j ) \in S$ but $( i , k ) \notin S$ , then we assume that ${ \bf { x } } _ { i }$ and $\boldsymbol { \mathscr { x } } _ { j }$ should be close in embedding space, whereas ${ \boldsymbol { x } } _ { i }$ and ${ \boldsymbol { x } } _ { k }$ should be far. We discuss various ways to enforce this property below. Note that these methods also work when we do not have class labels, provided we have some other way of defining similar pairs. For example, in Section 19.2.4.3, we discuss self-supervised approaches to representation learning, that automatically create semantically similar pairs, and learn embeddings to force these pairs to be closer than unrelated pairs.

Before discussing DML in more detail, it is worth mentioning that many recent approaches to DML are not as good as they claim to be, as pointed out in [MBL20; Rot+20]. (The claims in some of these papers are often invalid due to improper experimental comparisons, a common flaw in contemporary ML research, as discussed in e.g., [BLV19; LS19b].) We therefore focus on (slightly) older and simpler methods, that tend to be more robust.

# 16.2.3 Classification losses

Suppose we have labeled data with $C$ classes. Then we can fit a classification model in $O ( N C )$ time, and then reuse the hidden features as an embedding function. (It is common to use the second-to-last layer, since it generalizes better to new classes than the final layer.) This approach is simple and scalable. However, it only learns to embed examples on the correct side of a decision boundary, which does not necessarily result in similar examples being placed close together and dissimilar examples being placed far apart. In addition, this method cannot be used if we do not have labeled training data.

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

![](images/3cb2aa6728b7fa1dd9a4385d2753dc446e415fd453ba253a80a20ce46c2d218e.jpg)  
Figure 16.5: Networks for deep metric learning. (a) Siamese network. (b) Triplet network. Adapted from Figure 5 of [KB19].

# 16.2.4 Ranking losses

In this section, we consider minimizing ranking loss, to ensure that similar examples are closer than dissimilar examples. Most of these methods do not need class labels (although we sometimes assume that labels exist as a notationally simple way to define similarity).

# 16.2.4.1 Pairwise (contrastive) loss and Siamese networks

One of the earliest approaches to representation learning from similar/dissimilar pairs was based on minimizing the following contrastive loss [CHL05]:

$$
\mathcal { L } ( \pmb { \theta } ; \pmb { x } _ { i } , \pmb { x } _ { j } ) = \mathbb { I } \left( y _ { i } = y _ { j } \right) d ( \pmb { x } _ { i } , \pmb { x } _ { j } ) ^ { 2 } + \mathbb { I } \left( y _ { i } \neq y _ { j } \right) [ m - d ( \pmb { x } _ { i } , \pmb { x } _ { j } ) ] _ { + } ^ { 2 }
$$

where $[ z ] _ { + } = \operatorname* { m a x } ( 0 , z )$ is the hinge loss and $m > 0$ is a margin parameter. Intuitively, we want to force positive pairs (with the same label) to be close, and negative pairs (with different labels) to be further apart than some minimal safety margin. We minimize this loss over all pairs of data. Naively this takes $O ( N ^ { 2 } )$ time; see Section 16.2.5 for some speedups.

Note that we use the same feature extractor $f ( \cdot ; \theta )$ for both inputs, ${ \bf { \sigma } } _ { { \bf { \mathcal { X } } } _ { i } }$ and $\boldsymbol { x } _ { j }$ . when computing the distance, as illustrated in Figure 16.5a. The resulting network is therefore called a Siamese network (named after Siamese twins).

# 16.2.4.2 Triplet loss

One disadvantage of pairwise losses is that the optimization of the positive pairs is independent of the negative pairs, which can make their magnitudes incomparable. A solution to this is to use the triplet loss [SKP15]. This is defined as follows. For each example $i$ (known as an anchor), we find a similar (positive) example $\boldsymbol { x } _ { i } ^ { + }$ and a dissimilar (negative) example $\pmb { x } _ { i } ^ { - }$ . We then minimize the following loss, averaged overall all triples:

$$
\mathcal { L } ( \pmb { \theta } ; \pmb { x } _ { i } , \pmb { x } _ { i } ^ { + } , \pmb { x } _ { i } ^ { - } ) = [ d _ { \pmb { \theta } } ( \pmb { x } _ { i } , \pmb { x } _ { i } ^ { + } ) ^ { 2 } - d _ { \pmb { \theta } } ( \pmb { x } _ { i } , \pmb { x } _ { i } ^ { - } ) ^ { 2 } + m ] _ { + }
$$

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

Intuitively this says we want the distance from the anchor to the positive to be less (by some safety margin $m$ ) than the distance from the anchor to the negative. We can compute the triplet loss using a triplet network as shown in Figure 16.5b.

Naively minimizing triplet loss takes $O ( N ^ { 3 } )$ time. In practice we compute the loss on a minibatch (chosen so that there is at least one similar and one dissimilar example for the anchor point, often taken to be the first entry in the minibatch). Nevertheless the method can be slow. We discuss some speedups in Section 16.2.5.

# 16.2.4.3 N-pairs loss

One problem with the triplet loss is that each anchor is only compared to one negative example at a time. This might not provide a strong enough learning signal. One solution to this is to create a multi-class classification problem in which we create a set of $N - 1$ negatives and 1 positive for every anchor. This is called the N-pairs loss [Soh16]. More precisely, we define the following loss for each set:

$$
\begin{array} { r } { \theta ; x , x ^ { + } , \{ x _ { k } ^ { - } \} _ { k = 1 } ^ { N - 1 } ) = \log \left( 1 + \left[ \displaystyle \sum _ { k = 1 } ^ { N - 1 } \exp ( \hat { e } _ { \theta } ( x ) ^ { \top } \hat { e } _ { \theta } ( x _ { k } ^ { - } ) ) \right] - \hat { e } _ { \theta } ( x ) ^ { \top } \hat { e } _ { \theta } ( x ^ { + } ) \right) } \\ { = - \log \frac { \exp ( \hat { e } _ { \theta } ( x ) ^ { \top } \hat { e } _ { \theta } ( x ^ { + } ) ) } { \exp ( \hat { e } _ { \theta } ( x ) ^ { \top } \hat { e } _ { \theta } ( x ^ { + } ) ) + \sum _ { k = 1 } ^ { N - 1 } \exp ( \hat { e } _ { \theta } ( x ) ^ { \top } \hat { e } _ { \theta } ( x _ { k } ^ { - } ) ) } } \end{array}
$$

Note that the N-pairs loss is the same as the InfoNCE loss used in the CPC paper [OLV18]. In [Che+20a], they propose a version where they scale the similarities by a temperature term; they call this the NT-Xent (normalized temperature-scaled cross-entropy) loss. We can view the temperature parameter as scaling the radius of the hypersphere on which the data lives.

When $N = 2$ , the loss reduces to the logistic loss

$$
\mathcal { L } ( \pmb { \theta } ; \pmb { x } , \pmb { x } ^ { + } , \pmb { x } ^ { - } ) = \log \left( 1 + \exp ( \hat { e } _ { \pmb { \theta } } ( \pmb { x } ) ^ { \top } \hat { e } _ { \pmb { \theta } } ( \pmb { x } ^ { - } ) - \hat { e } _ { \pmb { \theta } } ( \pmb { x } ) ^ { \top } \hat { e } _ { \pmb { \theta } } ( \pmb { x } ^ { + } ) ) \right)
$$

Compare this to the margin loss used by triplet learning (when $m = 1$ ):

$$
\mathcal { L } ( \pmb { \theta } ; \pmb { x } , \pmb { x } ^ { + } , \pmb { x } ^ { - } ) = \operatorname* { m a x } \left( 0 , \hat { e } ( \pmb { x } ) ^ { \top } \hat { e } ( \pmb { x } ^ { - } ) - \hat { e } ( \pmb { x } ) ^ { \top } \hat { e } ( \pmb { x } ^ { + } ) + 1 \right)
$$

See Figure 4.2 for a comparison of these two functions.

# 16.2.5 Speeding up ranking loss optimization

The main disadvantage of ranking loss is the $O ( N ^ { 2 } )$ or $O ( N ^ { 3 } )$ cost of computing the loss function, due to the need to compare all pairs or triples of examples. In this section, we discuss various speedup tricks.

# 16.2.5.1 Mining techniques

A key insight is that we don’t need to consider all negative examples for each anchor, since most will be uninformative (i.e., will incur zero loss). Instead we can focus attention on negative examples which are closer to the anchor than its nearest positive example. These are called hard negatives, and are particularly useful for speeding up triplet loss.

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

![](images/6f6f83ddeeffbcb79837c8e09db34d7cf0367333ba703726b1bbc0ad02a27d0f.jpg)  
Figure 16.6: Speeding up triplet loss minimization. (a) Illustration of hard vs easy negatives. Here a is the anchor point, $p$ is a positive point, and $_ { n _ { i } }$ are negative points. Adapted from Figure 4 of [KB19]. (b) Standard triplet loss would take $8 \times 3 \times 4 = 9 6$ calculations, whereas using a proxy loss (with one proxy per class) takes $8 \times 2 = 1 6$ calculations. From Figure 1 of [Do+19]. Used with kind permission of Gustavo Cerneiro.

More precisely, if $a$ is an anchor and $p$ is its nearest positive example, we say that $n$ is a hard negative (for $u$ ) if $d ( \pmb { x } _ { a } , \pmb { x } _ { n } ) < d ( \pmb { x } _ { a } , \pmb { x } _ { p } )$ and $y _ { n } \neq y _ { a }$ . Sometimes an anchor may not have any hard negatives. We can therefore increase the pool of candidates by considering semi-hard negatives, for which

$$
d ( { \pmb x } _ { a } , { \pmb x } _ { p } ) < d ( { \pmb x } _ { a } , { \pmb x } _ { n } ) < d ( { \pmb x } _ { a } , { \pmb x } _ { p } ) + m
$$

where $m > 0$ is a margin parameter. See Figure 16.6a for an illustration. This is the technique used by Google’s FaceNet model [SKP15], which learns an embedding function for faces, so it can cluster similar looking faces together, to which the user can attach a name.

In practice, the hard negatives are usually chosen from within the minibatch. This therefore requires large batch sizes to ensure sufficient diversity. Alternatively, we can have a separate process that continually updates the set of candidate hard negatives, as the distance measure evolves during training.

# 16.2.5.2 Proxy methods

Triplet loss minimization is expensive even with hard negative mining (Section 16.2.5.1). Ideally we can find a method that is $O ( N )$ time, just like classification loss.

One such method, proposed in [MA+17], measures the distance between each anchor and a set of $P$ proxies that represent each class, rather than directly measuring distance between examples. These proxies need to be updated online as the distance metric evolves during learning. The overall procedure takes $O ( N P ^ { 2 } )$ time, where $P \sim C$ .

More recently, [Qia+19] proposed to represent each class with multiple prototypes, while still achieving linear time complexity, using a soft triple loss.

# 16.2.5.3 Optimizing an upper bound

[Do+19] proposed a simple and fast method for optimizing the triplet loss. The key idea is to define one fixed proxy or centroid per class, and then to use distance to the proxy as an upper bound on

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

the triplet loss.

More precisely, consider a simplified form of the triplet loss, without the margin term:

$$
\ell _ { t } ( \pmb { x } _ { i } , \pmb { x } _ { j } , \pmb { x } _ { k } ) = | | \hat { \pmb { e } } _ { i } - \hat { \pmb { e } } _ { j } | | - | | \hat { \pmb { e } } _ { i } - \hat { \pmb { e } } _ { k } | |
$$

where $\hat { \pmb { e } } _ { i } = \hat { \pmb { e } } _ { \pmb { \theta } } ( { \pmb { x } } _ { i } )$ , etc. Using the triangle inequality we have

$$
\begin{array} { r l } & { \quad \hat { e } _ { j } | | \leq | | \hat { e } _ { i } - c _ { y _ { i } } | | + | | \hat { e } _ { j } - c _ { y _ { i } } | | } \\ & { \quad \hat { e } _ { k } | | \geq | | \hat { e } _ { i } - c _ { y _ { k } } | | - | | \hat { e } _ { k } - c _ { y _ { k } } | | } \\ & { \quad \quad , } \\ & { \quad \quad , x _ { j } , x _ { k } ) \leq \ell _ { u } ( x _ { i } , x _ { j } , x _ { k } ) \triangleq | | \hat { e } _ { i } - c _ { y _ { i } } | | - | | \hat { e } _ { i } - c _ { y _ { k } } | | + | | \hat { e } _ { j } - c _ { y _ { i } } | | + | | \hat { e } _ { k } - c _ { y _ { i } } | | } \end{array}
$$

Hence

We can use this to derive a tractable upper bound on the triplet loss as follows:

$$
( \mathcal D , \mathcal S ) = \sum _ { \substack { ( i , j ) \in S , ( i , k ) \notin { \mathcal S } , i , j , k \in \{ 1 , \dots , N \} } } \ell _ { t } ( x _ { i } , x _ { j } , x _ { k } ) \leq \sum _ { \substack { ( i , j ) \in S , ( i , k ) \notin { \mathcal S } , i , j , k \in \{ 1 , \dots , N \} } }
$$

$$
= C ^ { \prime } \sum _ { i = 1 } ^ { N } \left( | | \boldsymbol { x } _ { i } - \boldsymbol { c } _ { y _ { i } } | | - \frac { 1 } { 3 ( C - 1 ) } \sum _ { m = 1 , m \neq y _ { i } } ^ { C } | | \boldsymbol { x } _ { i } - \boldsymbol { c } _ { m } | | \right) \triangleq \mathcal { L } _ { \boldsymbol { u } } ( \boldsymbol { D } , \boldsymbol { S } )
$$

where $\begin{array} { r } { C ^ { \prime } = 3 ( C - 1 ) ( \frac { N } { C } - 1 ) \frac { N } { C } } \end{array}$ is a constant. It is clear that $\mathcal { L } _ { u }$ can be computed in $O ( N C )$ time See Figure 16.6b for an illustration.

In [Do+19], they show that $\begin{array} { r } { 0 \leq \mathcal { L } _ { t } - \mathcal { L } _ { u } \leq \frac { N ^ { 3 } } { C ^ { 2 } } K } \end{array}$ , where $K$ is some constant that depends on the spread of the centroids. To ensure the bound is tight, the centroids should be as far from each other as possible, and the distances between them should be as similar as possible. An easy way to ensure is to define the $\mathbf { c } _ { m }$ vectors to be one-hot vectors, one per class. These vectors already have unit norm, and are orthogonal to each other. The distance between each pair of centroids is $\sqrt { 2 }$ , which ensures the upper bound is fairly tight.

The downside of this approach is that it assumes the embedding layer is $L = C$ dimensional. There are two solutions to this. First, after training, we can add a linear projection layer to map from $C$ to $L \neq C$ , or we can take the second-to-last layer of the embedding network. The second approach is to sample a large number of points on the $L$ -dimensional unit hyper-sphere (which we can do by sampling from the standard normal, and then normalizing [Mar72]), and then running K-means clustering (Section 21.3) with $K = C$ . In the experiments reported in [Do+19], these two approaches give similar results.

Interestingly, in [Rot+20], they show that increasing $\pi _ { \mathrm { i n t r a } } / \pi _ { \mathrm { i n t e r } }$ results in improved downstream performance on various retrieval tasks, where

$$
\pi _ { \mathrm { i n t r a } } = \frac { 1 } { Z _ { \mathrm { i n t r a } } } \sum _ { c = 1 } ^ { C } \sum _ { \substack { i \neq j : y _ { i } = y _ { j } = c } } d ( \pmb { x } _ { i } , \pmb { x } _ { j } )
$$

is the average intra-class distance, and

$$
\pi _ { \mathrm { i n t e r } } = { \frac { 1 } { Z _ { \mathrm { i n t e r } } } } \sum _ { c = 1 } ^ { C } \sum _ { c ^ { \prime } = 1 } ^ { C } d ( { \pmb \mu } _ { c } , { \pmb \mu } _ { c ^ { \prime } } )
$$

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022 is the average inter-class distance, where $\begin{array} { r } { \pmb { \mu } _ { c } = \frac { 1 } { Z _ { c } } \sum _ { i : y _ { i } = c } \hat { \pmb { e } } _ { i } } \end{array}$ is the mean embedding for examples from class $c$ . This suggests that we should not only keep the centroids far apart (in order to maximize the numerator), but we should also prevent examples from getting too close to their centroids (in order to minimize the denominator); this latter term is not captured in the method of [Do+19].

![](images/512b9556302ec6fbe4f1671303ef4806ddc9a597907777da7dd42ed760d5bdd3.jpg)  
Figure 16.7: Adding spherical embedding constraint to a deep metric learning method. Used with kind permission of Dingyi Zhang.

# 16.2.6 Other training tricks for DML

Besides the speedup tricks in Section 16.2.5, there are a lot of other details that are important to get right in order to ensure good DML performance. Many of these details are discussed in [MBL20; Rot+20]. Here we just briefly mention a few.

One important issue is how the minibatches are created. In classification problems (at least with balanced classes), selecting examples at random from the training set is usually sufficient. However, for DML, we need to ensure that each example has some other examples in the minibatch that are similar to it, as well as some others that are dissimilar to it. One approach is to use hard mining techniques (Section 16.2.5.1). Another idea is to use coreset methods applied to previously learned embeddings to select a diverse minibatch at each step [Sin+20]. However, [Rot+20] show that the following simple strategy also works well for creating each batch: pick $B / n$ classes, and then pick $N _ { c }$ examples randomly from each class, where $B$ is the batch size, and $N _ { c } = 2$ is a tuning parameter.

Another important issue is avoiding overfitting. Since most datasets used in the DML literature are small, it is standard to use an image classifier, such as GoogLeNet (Section 14.3.3) or ResNet (Section 14.3.4), which has been pre-trained on ImageNet, and then to fine-tune the model using the DML loss. (See Section 19.2 for more details on this kind of transfer learning.) In addition, it is standard to use data augmentation (see Section 19.1). (Indeed, with some self-supervised learning methods, data aug is the only way to create similar pairs.)

In [ZLZ20], they propose to add a spherical embedding constraint (SEC), which is an additional batchwise regularization term, which encourages all the examples to have the same norm. That is, the regularizer is just the empirical variance of the norms of the (unnormalized) embeddings in that batch. See Figure 16.7 for an illustration. This regularizer can be added to any of the existing DML losses to modestly improve training speed and stability, as well as final performance, analogously to how batchnorm (Section 14.2.4.1) is used.

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

# 16.3 Kernel density estimation (KDE)

In this section, we consider a form of non-parametric density estimation known as kernel density estimation or KDE. This is a form of generative model, since it defines a probability distribution $p ( { \pmb x } )$ that can be evaluated pointwise, and which can be sampled from to generate new data.

# 16.3.1 Density kernels

Before explaining KDE, we must define what we mean by a “kernel”. This term has several different meanings in machine learning and statistics.1 In this section, we use a specific kind of kernel which we refer to as a density kernel. This is a function $K : \mathbb { R }  \mathbb { R } _ { + }$ such that $\textstyle \int K ( x ) d x = 1$ and $\begin{array} { r } { { \cal { K } } ( - x ) = { \cal { K } } ( x ) } \end{array}$ . This latter symmetry property implies the $\textstyle \int x K ( x ) d x = 0$ , and hence

$$
\int x K ( x - x _ { n } ) d x = x _ { n }
$$

A simple example of such a kernel is the boxcar kernel, which is the uniform distribution within the unit interval around the origin:

$$
{ K ( x ) \triangleq 0 . 5 \mathbb { I } \left( \left| x \right| \le 1 \right) }
$$

Another example is the Gaussian kernel:

$$
{ \mathcal K } ( x ) = \frac { 1 } { ( 2 \pi ) ^ { \frac { 1 } { 2 } } } e ^ { - x ^ { 2 } / 2 }
$$

We can control the width of the kernel by introducing a bandwidth parameter $h$ :

$$
{ K } _ { h } ( x ) \triangleq \frac { 1 } { h } { K } ( \frac { x } { h } )
$$

We can generalize to vector valued inputs by defining a radial basis function or RBF kernel:

$$
{ \cal K } _ { h } ( { \pmb x } ) \propto { \cal K } _ { h } ( | | { \pmb x } | | )
$$

In the case of the Gaussian kernel, this becomes

$$
\mathcal { K } _ { h } ( { \pmb x } ) = \frac { 1 } { h ^ { D } ( 2 \pi ) ^ { D / 2 } } \prod _ { d = 1 } ^ { D } \exp ( - \frac { 1 } { 2 h ^ { 2 } } x _ { d } ^ { 2 } )
$$

Although Gaussian kernels are popular, they have unbounded support. Some alternative kernels, which have compact support (which can be computationally faster), are listed in Table 16.1. See Figure 16.8 for a plot of these kernel functions.

![](images/a79498c06791f7dfa5f1b34b48a713131b3c8120dda87720bf07f4ebe1e4763f.jpg)

Figure 16.8: A comparison of some popular normalized kernels. Generated by smoothingKernelPlot.ipynb.   

<html><body><table><tr><td>Name</td><td>Definition</td><td>Compact</td><td>Smooth</td><td>Boundaries</td></tr><tr><td>Gaussian</td><td>K(x)=(2π)-²e-x²/2</td><td>0</td><td>1</td><td>1</td></tr><tr><td>Boxcar</td><td>K(x)=¹Π(|x|≤1)</td><td>1</td><td>0</td><td>0</td></tr><tr><td>Epanechnikov kernel</td><td>K(x)=(1-x²）I(x|≤1)</td><td>1</td><td>1</td><td>0</td></tr><tr><td>Tri-cube kernel</td><td>K(x）=(1-|x|)Π（lx|≤1)</td><td>1</td><td>1</td><td>1</td></tr></table></body></html>

Table 16.1: List of some popular normalized kernels in 1d. Compact=1 means the function is non-zero for a finite range of inputs. Smooth=1 means the function is differentiable over the range of its support. Boundaries=1 means the function is also differentiable at the boundaries of its support.

# 16.3.2 Parzen window density estimator

To explain how to use kernels to define a nonparametric density estimate, recall the form of the Gaussian mixture model from Section 3.5.1. If we assume a fixed spherical Gaussian covariance and uniform mixture weights, we get

$$
p ( { \pmb x } | { \pmb \theta } ) = \frac { 1 } { K } \sum _ { k = 1 } ^ { K } \mathcal { N } ( { \pmb x } | { \pmb \mu } _ { k } , \sigma ^ { 2 } { \bf I } )
$$

One problem with this model is that it requires specifying the number $K$ of clusters, as well as their locations $\pmb { \mu } _ { k }$ . An alternative to estimating these parameters is to allocate one cluster center per data point. In this case, the model becomes

$$
p ( \pmb { x } | \pmb { \theta } ) = \frac { 1 } { N } \sum _ { n = 1 } ^ { N } \mathcal { N } ( \pmb { x } | \pmb { x } _ { n } , \sigma ^ { 2 } \mathbf { I } )
$$

We can generalize Equation (16.32) by writing

$$
p ( \pmb { x } | \mathcal { D } ) = \frac { 1 } { N } \sum _ { n = 1 } ^ { N } \mathcal { K } _ { h } \left( \pmb { x } - \pmb { x } _ { n } \right)
$$

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license where $\boldsymbol { \mathcal { K } } _ { h }$ is a density kernel. This is called a Parzen window density estimator, or kernel density estimator (KDE).

![](images/c2f5688a4dd5a5fe13189faf5938ca7949f38723dcc4d81cbbfc1ed239b860dc.jpg)  
Figure 16.9: A nonparametric (Parzen) density estimator in 1d estimated from 6 data points, denoted by x. Top row: uniform kernel. Bottom row: Gaussian kernel. Left column: bandwidth parameter $h = 1$ . Right column: bandwidth parameter $h = 2$ . Adapted from http: // en. wikipedia. org/ wiki/ Kernel_ density_ estimation . Generated by parzen_window_demo2.ipynb.

The advantage over a parametric model is that no model fitting is required (except for choosing $h$ , discussed in Section 16.3.3), and there is no need to pick the number of cluster centers. The disadvantage is that the model takes a lot of memory (you need to store all the data) and a lot of time to evaluate.

Figure 16.9 illustrates KDE in 1d for two kinds of kernel. On the top, we use a boxcar kernel; the resulting model just counts how many data points land within an interval of size $h$ around each $x _ { n }$ to get a piecewise constant density. On the bottom, we use a Gaussian kernel, which results in a smoother density.

# 16.3.3 How to choose the bandwidth parameter

We see from Figure 16.9 that the bandwidth parameter $h$ has a large effect on the learned distribution.   
We can view this as controlling the complexity of the model.

In the case of 1d data, where the “true” data generating distribution is assumed to be a Gaussian, one can show [BA97a] that the optimal bandwidth for a Gaussian kernel (from the point of view of

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022 minimizing frequentist risk) is given by h = σ   4N 1/5. We can compute a robust approximation to the standard deviation by first computing the median absolute deviation, median( $| { \pmb x } - \mathrm { m e d i a n } ( { \pmb x } ) | )$ , and then using $\hat { \sigma } = 1 . 4 8 2 6$ MAD. If we have $D$ dimensions, we can estimate $h _ { d }$ separately for each dimension, and then set $\textstyle h = ( \prod _ { d = 1 } ^ { D } h _ { d } ) ^ { 1 / D }$ .

# 16.3.4 From KDE to KNN classification

In Section 16.1, we discussed the K nearest neighbor classifier as a heuristic approach to classification. Interestingly, we can derive it as a generative classifier in which the class conditional densities $p ( { \pmb x } | y = c )$ are modeled using KDE. Rather than using a fixed bandwidth and counting how many data points fall within the hyper-cube centered on a datapoint, we will allow the bandwidth or volume to be different for each data point. Specifically, we will “grow” a volume around $_ { x }$ until we encounter $K$ data points, regardless of their class label. This is called a balloon kernel density estimator [TS92]. Let the resulting volume have size $V ( { \pmb x } )$ (this was previously $h ^ { D }$ ), and let there be $N _ { c } ( { \pmb x } )$ examples from class $c$ in this volume. Then we can estimate the class conditional density as follows:

$$
p ( \pmb { x } | y = c , \mathcal { D } ) = \frac { N _ { c } ( \pmb { x } ) } { N _ { c } V ( \pmb { x } ) }
$$

where $N _ { c }$ is the total number of examples in class $c$ in the whole data set. If we take the class prior to be $p ( y = c ) = N _ { c } / N$ , then the class posterior is given by

$$
p ( y = c | \pmb { x } , \mathcal { D } ) = \frac { \frac { N _ { c } ( \pmb { x } ) } { N _ { c } V ( \pmb { x } ) } \frac { N _ { c } } { N } } { \sum _ { c ^ { \prime } } \frac { N _ { c ^ { \prime } } ( \pmb { x } ) } { N _ { c ^ { \prime } } V ( \pmb { x } ) } \frac { N _ { c ^ { \prime } } } { N } } = \frac { N _ { c } ( \pmb { x } ) } { \sum _ { c ^ { \prime } } N _ { c ^ { \prime } } ( \pmb { x } ) } = \frac { N _ { c } ( \pmb { x } ) } { K } = \frac { 1 } { K } \sum _ { n \in N _ { K } ( \pmb { x } , \mathcal { D } ) } \mathbb { I } \left( \pmb { x } \right) ,
$$

where we used the fact that $\begin{array} { r } { \sum _ { c } N _ { c } ( \pmb { x } ) = K } \end{array}$ , since we choose a total of $K$ points (regardless of class) around every point. This matches 16.1.

# 16.3.5 Kernel regression

Just as KDE can be used for generative classifiers (see Section 16.1), it can also be used for generative models for regression, as we discuss below.

# 16.3.5.1 Nadaraya-Watson estimator for the mean

In regression, our goal is to compute the conditional expectation

$$
\mathbb { E } \left[ y | \pmb { x } , \mathcal { D } \right] = \int y \ p ( y | \pmb { x } , \mathcal { D } ) d y = \frac { \int y \ p ( \pmb { x } , y | \mathcal { D } ) d y } { \int p ( \pmb { x } , y | \mathcal { D } ) d y }
$$

If we use an MVN for $p ( \boldsymbol { y } , \pmb { x } | \mathcal { D } )$ , we derive a result which is equivalent to linear regression, as we showed in Section 11.2.3.5. However, the assumption that $p ( \boldsymbol { y } , \pmb { x } | \mathcal { D } )$ is Gaussian is rather limiting. We can use KDE to more accurately approximate the joint density $p ( \boldsymbol { x } , \boldsymbol { y } | \mathcal { D } )$ as follows:

$$
p ( y , \pmb { x } | \mathcal { D } ) \approx \frac { 1 } { N } \sum _ { n = 1 } ^ { N } \mathcal { K } _ { h } ( \pmb { x } - \pmb { x } _ { n } ) \mathcal { K } _ { h } ( y - y _ { n } )
$$

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

![](images/ca300cbf907df582f7b5991778e91d40afbe91a490c98b4bae9af36e3b0cbe52.jpg)  
Figure 16.10: An example of kernel regression in 1d using a Gaussian kernel. Generated by kernelRegressionDemo.ipynb.

Hence

$$
\mathbb { E } \left[ y | { \pmb x } , \mathcal { D } \right] = \frac { \frac { 1 } { N } \sum _ { n = 1 } ^ { N } { K _ { h } ( \pmb x } - { \pmb x } _ { n } ) \int y K _ { h } ( y - y _ { n } ) d y } { \frac { 1 } { N } \sum _ { n = 1 } ^ { N } { K _ { h } ( \pmb x } - { \pmb x } _ { n } ) \int { K _ { h } ( y - y _ { n } ) d y } }
$$

We can simplify the numerator using the fact that $\begin{array} { r } { \int y K _ { h } ( y - y _ { n } ) d y = y _ { n } } \end{array}$ (from Equation (16.25)). We can simplify the denominator using the fact that density kernels integrate to one, i.e., $\begin{array} { r l } { \int \mathcal { K } _ { h } ( y - y _ { n } ) d y = } \end{array}$ 1. Thus

$$
\begin{array} { c l c r } { \displaystyle \mathbb { E } \left[ y | \pmb { x } , \mathcal { D } \right] = \frac { \sum _ { n = 1 } ^ { N } K _ { h } ( \pmb { x } - \pmb { x } _ { n } ) y _ { n } } { \sum _ { n = 1 } ^ { N } K _ { h } ( \pmb { x } - \pmb { x } _ { n } ) } = \sum _ { n = 1 } ^ { N } y _ { n } w _ { n } ( \pmb { x } ) } \\ { w _ { n } ( \pmb { x } ) \triangleq \frac { K _ { h } ( \pmb { x } - \pmb { x } _ { n } ) } { \sum _ { n ^ { \prime } = 1 } ^ { N } K _ { h } ( \pmb { x } - \pmb { x } _ { n ^ { \prime } } ) } } \end{array}
$$

We see that the prediction is just a weighted sum of the outputs at the training points, where the weights depend on how similar $_ { x }$ is to the stored training points. This method is called kernel regression, kernel smoothing, or the Nadaraya-Watson (N-W) model. See Figure 16.10 for an example, where we use a Gaussian kernel.

In Section 17.2.3, we discuss the connection between kernel regression and Gaussian process regression.

# 16.3.5.2 Estimator for the variance

Sometimes it is useful to compute the predictive variance, as well as the predictive mean. We can do this by noting that

$$
\mathbb { V } \left[ y | \pmb { x } , \pmb { \mathcal { D } } \right] = \mathbb { E } \left[ y ^ { 2 } | \pmb { x } , \pmb { \mathcal { D } } \right] - \mu ( \pmb { x } ) ^ { 2 }
$$

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

where $\begin{array} { r } { \mu ( \pmb { x } ) = \mathbb { E } \left[ y | \pmb { x } , \mathcal { D } \right] } \end{array}$ is the N-W estimate. If we use a Gaussian kernel with variance $\sigma ^ { 2 }$ , we can compute $\mathbb { E } \left\lfloor y ^ { 2 } \vert x , \mathcal { D } \right\rfloor$ as follows:

$$
\begin{array} { c } { { \displaystyle \mathbb { E } \left[ y ^ { 2 } | { \pmb x } , { \mathcal { D } } \right] = \frac { \sum _ { n = 1 } ^ { N } K _ { h } ( { \pmb x } - { \pmb x } _ { n } ) \int y ^ { 2 } \mathcal { K } _ { h } ( y - y _ { n } ) d y } { \sum _ { n = 1 } ^ { N } \mathcal { K } _ { h } ( { \pmb x } - { \pmb x } _ { n } ) \int \mathcal { K } _ { h } ( y - y _ { n } ) d y } } } \\ { { = \frac { \sum _ { n = 1 } ^ { N } K _ { h } ( { \pmb x } - { \pmb x } _ { n } ) ( \sigma ^ { 2 } + y _ { n } ^ { 2 } ) } { \sum _ { n = 1 } ^ { N } \mathcal { K } _ { h } ( { \pmb x } - { \pmb x } _ { n } ) } } } \end{array}
$$

where we used the fact that

$$
\int y ^ { 2 } \mathcal { N } ( y | y _ { n } , \sigma ^ { 2 } ) d y = \sigma ^ { 2 } + y _ { n } ^ { 2 }
$$

Combining Equation (16.43) with Equation (16.41) gives

$$
\mathbb { V } \left[ y | x , \mathcal { D } \right] = \sigma ^ { 2 } + \sum _ { n = 1 } ^ { N } w _ { n } ( \pmb { x } ) y _ { n } ^ { 2 } - \mu ( \pmb { x } ) ^ { 2 }
$$

This matches Eqn. 8 of [BA10] (modulo the initial $\sigma ^ { 2 }$ term).

# 16.3.5.3 Locally weighted regression

We can drop the normalization term from Equation (16.39) to get

$$
\mu ( { \pmb x } ) = \sum _ { n = 1 } ^ { N } y _ { n } \mathcal { K } _ { h } ( { \pmb x } - { \pmb x } _ { n } )
$$

This is just a weighted sum of the observed responses, where the weights depend on how similar the test input $_ { x }$ is to the training points ${ \boldsymbol { \mathbf { \mathit { x } } } } _ { n }$ .

Rather than just interpolating the stored responses $y _ { n }$ , we can fit a locally linear model around each training point:

$$
\mu ( { \pmb x } ) = \operatorname* { m i n } _ { { \pmb \beta } } \sum _ { n = 1 } ^ { N } [ y _ { n } - { \pmb \beta } ^ { \top } { \phi } ( { \pmb x } _ { n } ) ] ^ { 2 } ~ \mathcal { K } _ { h } ( { \pmb x } - { \pmb x } _ { n } )
$$

where $\phi ( \pmb { x } ) = [ 1 , \pmb { x } ]$ . This is called locally linear regression (LRR) or locally-weighted scatterplot smoothing, and is commonly known by the acronym LOWESS or LOESS [CD88]. This is often used when annotating scatter plots with local trend lines.

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

# 17 Kernel Methods \*

In this chapter, we consider nonparametric methods for regression and classification. Such methods do not assume a fixed parametric form for the prediction function, but instead try to estimate the function itself (rather than the parameters) directly from data. The key idea is that we observe the function value at a fixed set of $N$ points, namely $y _ { n } = f ( \pmb { x } _ { n } )$ for $n = 1 : N$ , where $f$ is the unknown function, so to predict the function value at a new point, say $x _ { * }$ , we just have to compare how “similar” ${ \pmb x } _ { \ast }$ is to each of the $N$ training points, $\{ { \pmb x } _ { n } \}$ , and then we can predict that $f ( { \pmb x } _ { * } )$ is some weighted combination of the $\{ f ( { \pmb x } _ { n } ) \}$ values. Thus we may need to “remember” the entire training set, $\mathcal { D } = \{ ( { \pmb x } _ { n } , y _ { n } ) \}$ , in order to make predictions at test time — we cannot “compress” $\mathcal { D }$ into a fixed-sized parameter vector.

The weights that are used for prediction are determined by the similarity between ${ \pmb x } _ { \ast }$ and each ${ \boldsymbol { \mathbf { \mathit { x } } } } _ { n }$ , which is computed using a special kind of function known as kernel function, $K ( \pmb { x } _ { n } , \pmb { x } _ { \ast } ) \geq 0$ , which we explain in Section 17.1. This approach is similar to RBF networks (Section 13.6.1), except we use the datapoints ${ \boldsymbol { \mathbf { \mathit { x } } } } _ { n }$ themselves as the “anchors”, rather than learning centroid ${ \pmb \mu } _ { n }$ .

In Section 17.2, we discuss an approach called Gaussian processes, which allows us to use the kernel to define a prior over functions, which we can update given data to get a posterior over functions. Alternatively we can use the same kernel with a method called Support Vector Machines to compute a MAP estimate of the function, as we explain in Section 17.3.

# 17.1 Mercer kernels

The key to nonparametric methods is that we need a way to encode prior knowledge about the similarity of two input vectors. If we know that ${ \boldsymbol { x } } _ { i }$ is similar to $\boldsymbol { x } _ { j }$ , then we can encourage the model to make the predicted output at both locations (i.e., $f ( \pmb { x } _ { i } )$ and $f ( \pmb { x } _ { j } )$ ) to be similar.

To define similarity, we introduce the notion of a kernel function. The word “kernel” has many different meanings in mathematics, including density kernels (Section 16.3.1), transition kernels of a Markov chain (Section 3.6.1.2), and convolutional kernels (Section 14.1). Here we consider a Mercer kernel, also called a positive definite kernel. This is any symmetric function $K : \mathcal { X } \times \mathcal { X }  \mathbb { R } ^ { + }$ such that

$$
\sum _ { i = 1 } ^ { N } \sum _ { j = 1 } ^ { N } \boldsymbol { K } ( \pmb { x } _ { i } , \pmb { x } _ { j } ) c _ { i } c _ { j } \geq 0
$$

for any set of $N$ (unique) points $\pmb { x } _ { i } \in \mathcal { X }$ , and any choice of numbers $c _ { i } \in \mathbb { R }$ . (We assume $\mathscr { K } ( \pmb { x } _ { i } , \pmb { x } _ { j } ) > 0$ , so that we can only achieve equality in the above equation if $c _ { i } = 0$ for all $i$ .)

Another way to understand this condition is the following. Given a set of $N$ datapoints, let us define the Gram matrix as the following $N \times N$ similarity matrix:

$$
\mathbf { K } = \left( \begin{array} { c c c } { K ( \pmb { x } _ { 1 } , \pmb { x } _ { 1 } ) } & { \cdot \cdot \cdot } & { K ( \pmb { x } _ { 1 } , \pmb { x } _ { N } ) } \\ & { \vdots } \\ { K ( \pmb { x } _ { N _ { D } } , \pmb { x } _ { 1 } ) } & { \cdot \cdot \cdot } & { K ( \pmb { x } _ { N } , \pmb { x } _ { N } ) } \end{array} \right)
$$

We say that $\mathcal { K }$ is a Mercer kernel iff the Gram matrix is positive definite for any set of (distinct) inputs $\{ { \pmb x } _ { i } \} _ { i = 1 } ^ { N }$ .

The most widely used kernel for real-valued inputs is the squared exponential kernel (SE kernel), also called the exponentiated quadratic, Gaussian kernel RBF kernel. It is defined by

$$
\mathcal { K } ( \pmb { x } , \pmb { x } ^ { \prime } ) = \exp \left( - \frac { | | \pmb { x } - \pmb { x } ^ { \prime } | | ^ { 2 } } { 2 \ell ^ { 2 } } \right)
$$

Here $\ell$ corresponds to the length scale of the kernel, i.e., the distance over which we expect differences to matter. This is known as the bandwidth parameter. The RBF kernel measures similarity between two vectors in $\mathbb { R } ^ { D }$ using (scaled) Euclidean distance. In Section 17.1.2, we will discuss several other kinds of kernel.

In Section 17.2, we show how to use kernels to define priors and posteriors over functions. The basic idea is this: if $\kappa ( \pmb { x } , \pmb { x } ^ { \prime } )$ is large, meaning the inputs are similar, then we expect the output of the function to be similar as well, so $f ( \pmb { x } ) \approx f ( \pmb { x } ^ { \prime } )$ . More precisely, information we learn about $f ( { \pmb x } )$ will help us predict $f ( \pmb { x } ^ { \prime } )$ for all $\mathbf { { x } ^ { \prime } }$ which are correlated with $_ { x }$ , and hence for which $\boldsymbol { \kappa } ( \boldsymbol { \mathbf { \mathit { x } } } , \boldsymbol { \mathbf { \mathit { x } } } ^ { \prime } )$ is large.

In Section 17.3, we show how to use kernels to generalize from Euclidean distance to a more general notion of distance, so that we can use geometric methods such as linear discriminant analysis in an implicit feature space instead of input space.

# 17.1.1 Mercer’s theorem

Recall from Section 7.4 that any positive definite matrix $\mathbf { K }$ can be represented using an eigendecomposition of the form $\mathbf { K } = \mathbf { U } ^ { \top } \mathbf { A } \mathbf { U }$ , where $\pmb { \Lambda }$ is a diagonal matrix of eigenvalues $\lambda _ { i } > 0$ , and $\mathbf { U }$ is a matrix containing the eigenvectors. Now consider element $( i , j )$ of $\mathbf { K }$ :

$$
k _ { i j } = ( \mathbf { A } ^ { \frac { 1 } { 2 } } \mathbf { U } _ { : i } ) ^ { \top } ( \mathbf { A } ^ { \frac { 1 } { 2 } } \mathbf { U } _ { : j } )
$$

where $\mathbf { U } _ { : i }$ is the $i$ ’th column of $\mathbf { U }$ . If we define $\phi ( \mathbf { x } _ { i } ) = \Lambda ^ { \frac { 1 } { 2 } } \mathbf { U } _ { : i }$ , then we can write

$$
k _ { i j } = \phi ( \pmb { x } _ { i } ) ^ { \top } \phi ( \pmb { x } _ { j } ) = \sum _ { m } \phi _ { m } ( \pmb { x } _ { i } ) \phi _ { m } ( \pmb { x } _ { j } )
$$

Thus we see that the entries in the kernel matrix can be computed by performing an inner product of some feature vectors that are implicitly defined by the eigenvectors of the kernel matrix. This idea can be generalized to apply to kernel functions, not just kernel matrices; this result is known as Mercer’s theorem.

For example, consider the quadratic kernel $K ( { \pmb x } , { \pmb x } ^ { \prime } ) = \langle { \pmb x } , { \pmb x } ^ { \prime } \rangle ^ { 2 }$ . In 2d, we have

$$
K ( { \pmb x } , { \pmb x } ^ { \prime } ) = ( x _ { 1 } x _ { 1 } ^ { \prime } + x _ { 2 } x _ { 2 } ^ { \prime } ) ^ { 2 } = x _ { 1 } ^ { 2 } ( x _ { 1 } ^ { \prime } ) ^ { 2 } + 2 x _ { 1 } x _ { 2 } x _ { 1 } ^ { \prime } x _ { 2 } ^ { \prime } + x _ { 2 } ^ { 2 } ( x _ { 2 } ^ { \prime } ) ^ { 2 }
$$

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

![](images/d2a452cbb88952c860433bfa47de4da835028f81636d938199543cc1dfd721b4.jpg)  
Figure 17.1: Function samples from a GP with an ARD kernel. (a) $\ell _ { 1 } = \ell _ { 2 } = 1$ . Both dimensions contribute to the response. (b) $\ell _ { 1 } = 1$ , $\ell _ { 2 } = 5$ . The second dimension is essentially ignored. Adapted from Figure 5.1 of [RW06]. Generated by gprDemoArd.ipynb.

We can write this as ${ \mathcal K } ( { \pmb x } , { \pmb x } ^ { \prime } ) = \phi ( { \pmb x } ) ^ { \prime } \phi ( { \pmb x } )$ if we define $\phi ( x _ { 1 } , x _ { 2 } ) = [ x _ { 1 } ^ { 2 } , \sqrt { 2 } x _ { 1 } x _ { 2 } , x _ { 2 } ^ { 2 } ] \in \mathbb { R } ^ { 3 }$ . So we embed the 2d inputs $_ { x }$ into a 3d feature space $\phi ( { \pmb x } )$ .

Now consider the RBF kernel. In this case, the corresponding feature representation is infinite dimensional (see Section 17.2.9.3 for details). However, by working with kernel functions, we can avoid having to deal with infinite dimensional vectors.

# 17.1.2 Some popular Mercer kernels

In the sections below, we describe some popular Mercer kernels. More details can be found at [Wil14] and https://www.cs.toronto.edu/\~duvenaud/cookbook/.

# 17.1.2.1 Stationary kernels for real-valued vectors

For real-valued inputs, $\boldsymbol { \mathcal { X } } = \mathbb { R } ^ { D }$ , it is common to use stationary kernels, which are functions of the form $\begin{array} { r } { K ( \pmb { x } , \pmb { x } ^ { \prime } ) = K ( | | \pmb { x } - \pmb { x } ^ { \prime } | | ) } \end{array}$ ; thus the value only depends on the elementwise difference between the inputs. The RBF kernel is a stationary kernel. We give some other examples below.

# ARD kernel

We can generalize the RBF kernel by replacing Euclidean distance with Mahalanobis distance, as follows:

$$
K ( \pmb { r } ) = \sigma ^ { 2 } \exp \left( - \frac { 1 } { 2 } \pmb { r } ^ { \top } \pmb { \Sigma } ^ { - 1 } \pmb { r } \right)
$$

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

![](images/480281c08e78350613cae60ed5b64795a00a4f2c1552c09802d08518ddbfa0df.jpg)  
Figure 17.2: Functions sampled from a GP with a Matern kernel. (a) $\nu = 5 / 2$ . (b) $\nu = 1 / 2$ . Generated by gpKernelPlot.ipynb.

where $\pmb { r } = \pmb { x } - \pmb { x } ^ { \prime }$ . If $\pmb { \Sigma }$ is diagonal, this can be written as

$$
\mathcal { K } ( r ; \ell , \sigma ^ { 2 } ) = \sigma ^ { 2 } \exp \left( - \frac { 1 } { 2 } \sum _ { d = 1 } ^ { D } \frac { 1 } { \ell _ { d } ^ { 2 } } r _ { d } ^ { 2 } \right) = \prod _ { d = 1 } ^ { D } \mathcal { K } ( r _ { d } ; \ell _ { d } , \sigma ^ { 2 / d } )
$$

where

$$
K ( r ; \ell , \tau ^ { 2 } ) = \tau ^ { 2 } \exp \left( - { \frac { 1 } { 2 } } { \frac { 1 } { \ell ^ { 2 } } } r ^ { 2 } \right)
$$

We can interpret $\sigma ^ { 2 }$ as the overall variance, and $\ell _ { d }$ as defining the characteristic length scale of dimension $d$ . If $d$ is an irrelevant input dimension, we can set $\ell _ { d } = \infty$ , so the corresponding dimension will be ignored. This is known as automatic relevancy determination or ARD (Section 11.7.7). Hence the corresponding kernel is called the ARD kernel. See Figure 17.1 for an illustration of some 2d functions sampled from a GP using this prior.

# Matern kernels

The SE kernel gives rise to functions that are infinitely differentiable, and therefore are very smooth. For many applications, it is better to use the Matern kernel, which gives rise to “rougher” functions, which can better model local “wiggles” without having to make the overall length scale very small. The Matern kernel has the following form:

$$
{ \ K } ( r ; \nu , \ell ) = \frac { 2 ^ { 1 - \nu } } { \Gamma ( \nu ) } \left( \frac { \sqrt { 2 \nu } r } { \ell } \right) ^ { \nu } { K } _ { \nu } \left( \frac { \sqrt { 2 \nu } r } { \ell } \right)
$$

where $K _ { \nu }$ is a modified Bessel function and $\ell$ is the length scale. Functions sampled from this GP are $k$ -times differentiable iff $\nu > k$ . As $\nu \to \infty$ , this approaches the SE kernel.

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

![](images/511df3498b8bd76c7c7ab95a222335eb73f5133da71e1db7ba375e9e8b11bd08.jpg)

Figure 17.3: Functions sampled from a GP using various stationary periodic kernels. Generated by gpKernelPlot.ipynb.

For values $\nu \in \{ { \textstyle { \frac { 1 } { 2 } } } , { \frac { 3 } { 2 } } , { \frac { 5 } { 2 } } \}$ , the function simplifies as follows:

$$
\begin{array} { l } { \displaystyle \mathcal { K } ( r ; \frac { 1 } { 2 } , \ell ) = \exp ( - \frac { r } { \ell } ) } \\ { \displaystyle \mathcal { K } ( r ; \frac { 3 } { 2 } , \ell ) = \left( 1 + \frac { \sqrt { 3 } r } { \ell } \right) \exp \left( - \frac { \sqrt { 3 } r } { \ell } \right) } \\ { \displaystyle \mathcal { K } ( r ; \frac { 5 } { 2 } , \ell ) = \left( 1 + \frac { \sqrt { 5 } r } { \ell } + \frac { 5 r ^ { 2 } } { 3 \ell ^ { 2 } } \right) \exp \left( - \frac { \sqrt { 5 } r } { \ell } \right) } \end{array}
$$

The value $\begin{array} { r } { \nu = \frac { 1 } { 2 } } \end{array}$ corresponds to the Ornstein-Uhlenbeck process, which describes the velocity of a particle undergoing Brownian motion. The corresponding function is continuous but not differentiable, and hence is very “jagged”. See Figure 17.2b for an illustration.

# Periodic kernels

The periodic kernel captures repeating structure, and has the form

$$
\mathcal { K } _ { \mathrm { p e r } } ( r ; \ell , p ) = \exp \left( - \frac { 2 } { \ell ^ { 2 } } \sin ^ { 2 } ( \pi \frac { r } { p } ) \right)
$$

where $p$ is the period. See Figure 17.3a for an illustration.

A related kernel is the cosine kernel:

$$
\mathcal { K } ( r ; p ) = \cos \left( 2 \pi \frac { r } { p } \right)
$$

See Figure 17.3b for an illustration.

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

# 17.1.2.2 Making new kernels from old

Given two valid kernels ${ \cal { K } } _ { 1 } ( { \pmb x } , { \pmb x } ^ { \prime } )$ and ${ \ K } _ { 2 } ( { \pmb x } , { \pmb x } ^ { \prime } )$ , we can create a new kernel using any of the following methods:

${ \ K } ( { \pmb x } , { \pmb x } ^ { \prime } ) = q ( { \ K } _ { 1 } ( { \pmb x } , { \pmb x } ^ { \prime } ) )$ for any function polynomial $q$ with nonneg. coef.

$K ( { \pmb x } , { \pmb x } ^ { \prime } ) = { \pmb x } ^ { \top } { \pmb \mathrm { A } } { \pmb x } ^ { \prime }$ , for any psd matrix A

For example, suppose we start with the linear kernel $K ( { \pmb x } , { \pmb x } ^ { \prime } ) = { \pmb x } ^ { \top } { \pmb x } ^ { \prime }$ . We know this is a valid Mercer kernel, since the corresponding Gram matrix is just the (scaled) covariance matrix of the data. From the above rules, we can see that the polynomial kernel $\begin{array} { r } { \mathcal { K } ( \pmb { x } , \pmb { x } ^ { \prime } ) = ( \pmb { x } ^ { \prime } \pmb { x } ^ { \prime } ) ^ { M } } \end{array}$ is a valid Mercer kernel. This contains all monomials of order $M$ . For example, if $M = 2$ and the inputs are 2d, we have

$$
( x ^ { \mathsf { T } } x ^ { \prime } ) ^ { 2 } = ( x _ { 1 } x _ { 1 } ^ { \prime } + x _ { 2 } x _ { 2 } ^ { \prime } ) ^ { 2 } = ( x _ { 1 } x _ { 1 } ^ { \prime } ) ^ { 2 } + ( x _ { 2 } x _ { 2 } ) ^ { 2 } + ( x _ { 1 } x _ { 1 } ^ { \prime } ) ( x _ { 2 } x _ { 2 } ^ { \prime } )
$$

We can generalize this to contain all terms up to degree $M$ by using the kernel $\mathcal { K } ( \pmb { x } , \pmb { x } ^ { \prime } ) = ( \pmb { x } ^ { \top } \pmb { x } ^ { \prime } + c ) ^ { M }$ . For example, if $M = 2$ and the inputs are 2d, we have

$$
\begin{array} { r l } & { ( \boldsymbol { x } ^ { \top } \boldsymbol { x } ^ { \prime } + 1 ) ^ { 2 } = ( x _ { 1 } x _ { 1 } ^ { \prime } ) ^ { 2 } + ( x _ { 1 } x _ { 1 } ^ { \prime } ) ( x _ { 2 } x _ { 2 } ^ { \prime } ) + ( x _ { 1 } x _ { 1 } ^ { \prime } ) } \\ & { \phantom { ( \boldsymbol { x } ^ { \top } \boldsymbol { x } ^ { \prime } + 1 ) ^ { 2 } } + ( x _ { 2 } x _ { 2 } ) ( x _ { 1 } x _ { 1 } ^ { \prime } ) + ( x _ { 2 } x _ { 2 } ^ { \prime } ) ^ { 2 } + ( x _ { 2 } x _ { 2 } ^ { \prime } ) } \\ & { \phantom { ( \boldsymbol { x } ^ { \top } \boldsymbol { x } ^ { \prime } + 1 ) ^ { 2 } } + ( x _ { 1 } x _ { 1 } ^ { \prime } ) + ( x _ { 2 } x _ { 2 } ^ { \prime } ) + 1 } \end{array}
$$

We can also use the above rules to establish that the Gaussian kernel is a valid kernel. To see this, note that

an

$$
\begin{array} { r l } & { | | x - x ^ { \prime } | | ^ { 2 } = x ^ { \mathsf { T } } x + ( x ^ { \prime } ) ^ { \mathsf { T } } x ^ { \prime } - 2 x ^ { \mathsf { T } } x ^ { \prime } } \\ & { \mathrm { 1 ~ h e n c e } } \\ & { K ( x , x ^ { \prime } ) = \exp ( - | | x - x ^ { \prime } | | ^ { 2 } / 2 \sigma ^ { 2 } ) = \exp ( - x ^ { \mathsf { T } } x / 2 \sigma ^ { 2 } ) \exp ( x ^ { \mathsf { T } } x ^ { \prime } / \sigma ^ { 2 } ) \exp ( - ( x ^ { \prime } - x ^ { \prime } ) / \sigma ^ { 2 } ) } \end{array}
$$

is a valid kernel.

# 17.1.2.3 Combining kernels by addition and multiplication

We can also combine kernels using addition or multiplication:

$$
\begin{array} { r l } & { \ K ( { \pmb x } , { \pmb x } ^ { \prime } ) = { \mathcal K } _ { 1 } ( { \pmb x } , { \pmb x } ^ { \prime } ) + { \mathcal K } _ { 2 } ( { \pmb x } , { \pmb x } ^ { \prime } ) } \\ & { \ K ( { \pmb x } , { \pmb x } ^ { \prime } ) = { \mathcal K } _ { 1 } ( { \pmb x } , { \pmb x } ^ { \prime } ) \times { \mathcal K } _ { 2 } ( { \pmb x } , { \pmb x } ^ { \prime } ) } \end{array}
$$

Multiplying two positive-definite kernels together always results in another positive definite kernel. This is a way to get a conjunction of the individual properties of each kernel, as illustrated in Figure 17.4.

In addition, adding two positive-definite kernels together always results in another positive definite kernel. This is a way to get a disjunction of the individual properties of each kernel, as illustrated in Figure 17.5.

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

![](images/eac428660a29afec410bfc27009c9cdd51454876bc7f238a33a36af8788fb323.jpg)  
Figure 17.4: Examples of 1d structures obtained by multiplying elementary kernels. Top row shows $\begin{array} { r } { K ( x , x ^ { \prime } = 1 ) } \end{array}$ . Bottom row shows some functions sampled from $G P ( f | 0 , \mathcal { K } )$ . From Figure 2.2 of [Duv14]. Used with kind permission of David Duvenaud.

![](images/1ce9e33ddeb70302dfa1941bb9955512e23175e2072c44cc2902ce0b5eee70d8.jpg)  
Figure 17.5: Examples of 1d structures obtained by adding elementary kernels. Here SE(short) and $\mathrm { S E ^ { ( l o n g ) } }$ are two SE kernels with different length scales. From Figure 2.4 of [Duv14]. Used with kind permission of David Duvenaud.

# 17.1.2.4 Kernels for structured inputs

Kernels are particularly useful when the inputs are structured objects, such as strings and graphs, since it is often hard to “featurize” variable-sized inputs. For example, we can define a string kernel which compares strings in terms of the number of n-grams they have in common [Lod+02; BC17].

We can also define kernels on graphs [KJM19]. For example, the random walk kernel conceptually performs random walks on two graphs simultaneously, and then counts the number of paths that were produced by both walks. This can be computed efficiently as discussed in [Vis+10]. For more details on graph kernels, see [KJM19].

For a review of kernels on structured objects, see e.g., [Gär03].

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

![](images/c8df7e5c102f094ffe5e6ccc5ef370b880e30c1263d5b5268964db00c5e81817.jpg)

Figure 17.6: A Gaussian process for $\boldsymbol { \mathcal { Z } }$ training points, ${ \bf { x } } _ { 1 }$ and ${ \bf { \sigma } } ^ { x _ { 2 } }$ , and $^ { 1 }$ testing point, ${ \pmb x } _ { \ast }$ , represented as a graphical model representing $p ( { \pmb y } , { \pmb f } _ { X } | { \bf X } ) = \mathcal { N } ( { \pmb f } _ { X } | m ( { \bf X } ) , \mathcal { K } ( { \bf X } ) ) \prod _ { i } p ( { \pmb y }$ i|fi). The hidden nodes $f _ { i } = f ( \pmb { x } _ { i } )$ represent the value of the function at each of the data points. Th ese hidden nodes are fully interconnected by undirected edges, forming a Gaussian graphical model; the edge strengths represent the covariance terms $\Sigma _ { i j } = { \cal K } ( { \pmb x } _ { i } , { \pmb x } _ { j } )$ . If the test point $^ { \mathbf { \nabla } _ { \mathbf { x } } }$ is similar to the training points $\pmb { x } _ { 1 }$ and $\scriptstyle { \pmb x } _ { 2 }$ , then the value of the hidden function $f _ { * }$ will be similar to $f _ { 1 }$ and $f _ { 2 }$ , and hence the predicted output $y _ { * }$ will be similar to the training values $_ { y _ { 1 } }$ and $_ { y _ { 2 } }$ .

# 17.2 Gaussian processes

In this section, we discuss Gaussian processes, which is a way to define distributions over functions of the form $f : \mathcal { X } \to \mathbb { R }$ , where $\mathcal { X }$ is any domain. The key assumption is that the function values at a set of $M > 0$ inputs, $\pmb { f } = [ f ( \pmb { x } _ { 1 } ) , \dots , f ( \pmb { x } _ { M } ) ]$ , is jointly Gaussian, with mean ${ \pmb \mu } = m ( { \pmb x } _ { 1 } ) , \dots , m ( { \pmb x } _ { M } ) )$ and covariance $\pmb { \Sigma } _ { i j } = \mathcal { K } ( \pmb { x } _ { i } , \pmb { x } _ { j } )$ , where $m$ is a mean function and $\mathcal { K }$ is a positive definite (Mercer) kernel. Since we assume this holds for any $M \ > \ 0$ , this includes the case where $M = N + 1$ , containing $N$ training points ${ \boldsymbol { \mathbf { \mathit { x } } } } _ { n }$ and 1 test point $x _ { * }$ . Thus we can infer $f ( { \pmb x } _ { * } )$ from knowledge of $f ( \pmb { x } _ { 1 } ) , \dotsc , f ( \pmb { x } _ { n } )$ by manipulating the joint Gaussian distribution $p ( f ( \pmb { x } _ { 1 } ) , \ldots , f ( \pmb { x } _ { N } ) , f ( \pmb { x } _ { * } ) )$ , as we explain below. We can also extend this to work with the case where we observe noisy functions of $f ( { \pmb x } _ { n } )$ , such as in regression or classification problems.

# 17.2.1 Noise-free observations

Suppose we observe a training set $\mathcal { D } = \{ ( \boldsymbol { x } _ { n } , y _ { n } ) : n = 1 : N \}$ , where $y _ { n } = f ( \pmb { x } _ { n } )$ is the noise-free observation of the function evaluated at ${ \boldsymbol { \mathbf { \mathit { x } } } } _ { n }$ . If we ask the GP to predict $f ( { \pmb x } )$ for a value of $_ { x }$ that it has already seen, we want the GP to return the answer $f ( { \pmb x } )$ with no uncertainty. In other words, it should act as an interpolator of the training data.

Now we consider the case of predicting the outputs for new inputs that may not be in $\mathcal { D }$ . Specifically, given a test set ${ \mathbf { X } } _ { * }$ of size $N _ { * } \times D$ , we want to predict the function outputs $\pmb { f } _ { * } = [ f ( \pmb { x } _ { 1 } ) , \dots , f ( \pmb { x } _ { N _ { * } } ) ]$ . By definition of the GP, the joint distribution $p ( { f } _ { X } , { f } _ { * } | \mathbf { X } , \mathbf { X } _ { * } )$ has the following form

$$
\left( \mathbf { \Sigma } _ { \mathbf { f } _ { X } } ^ { \mathbf { f } _ { X } } \right) \sim \mathcal { N } \left( \left( \begin{array} { l } { \pmb { \mu } _ { X } } \\ { \pmb { \mu } _ { * } } \end{array} \right) , \left( \begin{array} { l l } { \mathbf { K } _ { X , X } } & { \mathbf { K } _ { X , * } } \\ { \mathbf { K } _ { X , * } ^ { \top } } & { \mathbf { K } _ { * , * } } \end{array} \right) \right)
$$

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

![](images/92764ef9a6097504e4b5505af939e555095bfd0ef240f005b80d4e482603d3ab.jpg)  
Figure 17.7: (a) some functions sampled from a $G P$ prior with squared exponential kernel. (b-d) : some samples from a $G P$ posterior, after conditioning on 1,2, and 4 noise-free observations. The shaded area represents $\mathbb { E } \left[ f ( \pmb { x } ) \right] \pm 2 \mathrm { s t d } \left[ f ( \pmb { x } ) \right]$ . Adapted from Figure 2.2 of [RW06]. Generated by gprDemoNoiseFree.ipynb.

where ${ \pmb \mu } _ { X } = [ m ( { \pmb x } _ { 1 } ) , \dots , m ( { \pmb x } _ { N _ { D } } ) ]$ , $\pmb { \mu } _ { * } = [ m ( \pmb { x } _ { 1 } ^ { * } ) , \dots , m ( \pmb { x } _ { N _ { * } } ^ { * } ) ]$ , $\mathbf { K } _ { X , X } = \mathcal { K } ( \mathbf { X } , \mathbf { X } )$ is $N _ { \mathcal { D } } \times N _ { \mathcal { D } }$ , ${ \bf K } _ { X , * } = \mathcal { K } ( { \bf X } , { \bf X } _ { * } )$ is $N _ { \cal D } \times N _ { \ast }$ , and $\mathbf { K } _ { * , * } = \mathcal { K } ( \mathbf { X } _ { * } , \mathbf { X } _ { * } )$ is $N _ { * } \times N _ { * }$ . See Figure 17.6 for an illustration. By the standard rules for conditioning Gaussians (Section 3.2.3), the posterior has the following form

$$
\begin{array} { r l } & { p ( { \pmb f } _ { * } | { \pmb X } _ { * } , { \mathcal { D } } ) = { \mathcal { N } } ( f _ { * } | { \pmb \mu } _ { * } , { \pmb \Sigma } _ { * } ) } \\ & { ~ { \pmb \mu } _ { * } = m ( { \pmb X } _ { * } ) + { \pmb { \mathrm { K } } } _ { X , * } ^ { \mathsf { T } } { \pmb \mathrm { K } } _ { X , X } ^ { - 1 } ( f _ { X } - m ( { \pmb X } ) ) } \\ & { ~ { \pmb \Sigma } _ { * } = { \pmb { \mathrm { K } } } _ { * , * } - { \pmb { \mathrm { K } } } _ { X , * } ^ { \mathsf { T } } { \pmb \mathrm { K } } _ { X , X } ^ { - 1 } { \pmb \mathrm { K } } _ { X , * } } \end{array}
$$

This process is illustrated in Figure 17.7. On the left we show some samples from the prior, $p ( f )$ , where we use an RBF kernel (Section 17.1) and a zero mean function. On the right, we show samples from the posterior, $p ( f | \mathcal { D } )$ . We see that the model perfectly interpolates the training data, and that the predictive uncertainty increases as we move further away from the observed data.

# 17.2.2 Noisy observations

Now let us consider the case where what we observe is a noisy version of the underlying function, $y _ { n } = f ( \pmb { x } _ { n } ) + \epsilon _ { n }$ , where $\epsilon _ { n } \sim \mathcal { N } ( 0 , \sigma _ { y } ^ { 2 } )$ . In this case, the model is not required to interpolate the data,

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

but it must come “close” to the observed data. The covariance of the observed noisy responses is

$$
\operatorname { C o v } \left[ y _ { i } , y _ { j } \right] = \operatorname { C o v } \left[ f _ { i } , f _ { j } \right] + \operatorname { C o v } \left[ \epsilon _ { i } , \epsilon _ { j } \right] = K ( \pmb { x } _ { i } , \pmb { x } _ { j } ) + \sigma _ { y } ^ { 2 } \delta _ { i j }
$$

where $\delta _ { i j } = \mathbb { I } \left( i = j \right)$ . In other words

$$
\mathrm { C o v } [ { \pmb y } | \mathbf { X } ] = \mathbf { K } _ { X , X } + \sigma _ { y } ^ { 2 } { \mathbf { I } } _ { N } \triangleq \mathbf { K } _ { \sigma }
$$

The joint density of the observed data and the latent, noise-free function on the test points is given by

$$
( \mathbf { \frac { \partial y } { \partial t _ { * } } } ) \sim \mathcal { N } ( ( \mathbf { \frac { \mu _ { X } } { \mu _ { * } } } ) , ( \mathbf { K } _ { X }    \mathbf { K } _ { X , * } ) )
$$

Hence the posterior predictive density at a set of test points ${ \bf X } _ { * }$ is

$$
\begin{array} { r l } & { p ( \pmb { f } _ { * } | \mathcal { D } , \pmb { \mathrm { X } } _ { * } ) = \mathcal { N } ( \pmb { f } _ { * } | \pmb { \mu } _ { * | X } , \pmb { \Sigma } _ { * | X } ) } \\ & { ~ \qquad \pmb { \mu } _ { * | X } = \pmb { \mu } _ { * } + \pmb { \mathrm { K } } _ { X , * } ^ { \top } \pmb { \mathrm { K } } _ { \sigma } ^ { - 1 } ( \pmb { y } - \pmb { \mu } _ { X } ) } \\ & { ~ \pmb { \Sigma } _ { * | X } = \pmb { \mathrm { K } } _ { * , * } - \pmb { \mathrm { K } } _ { X , * } ^ { \top } \pmb { \mathrm { K } } _ { \sigma } ^ { - 1 } \pmb { \mathrm { K } } _ { X , * } } \end{array}
$$

In the case of a single test input, this simplifies as follows

$$
p ( f _ { * } | D , \pmb { x } _ { * } ) = \mathcal { N } ( f _ { * } | m _ { * } + \pmb { k } _ { * } ^ { \mathsf { T } } \mathbf { K } _ { \sigma } ^ { - 1 } ( \pmb { y } - \pmb { \mu } _ { X } ) , \ k _ { * * } - \pmb { k } _ { * } ^ { \mathsf { T } } \mathbf { K } _ { \sigma } ^ { - 1 } k _ { * } )
$$

where $\pmb { k } _ { * } = [ \mathcal { K } ( \pmb { x } _ { * } , \pmb { x } _ { 1 } ) , \dots , \mathcal { K } ( \pmb { x } _ { * } , \pmb { x } _ { N } ) ]$ and $k _ { * * } = \mathcal { K } ( \pmb { x } _ { * } , \pmb { x } _ { * } )$ . If the mean function is zero, we can write the posterior mean as follows:

$$
\mu _ { * | X } = k _ { * } ^ { \mathsf { T } } ( \mathbf { K } _ { \sigma } ^ { - 1 } \pmb { y } ) \triangleq k _ { * } ^ { \mathsf { T } } \pmb { \alpha } = \sum _ { n = 1 } ^ { N } K ( \pmb { x } _ { * } , \pmb { x } _ { n } ) \alpha _ { n }
$$

This is identical to the predictions from kernel ridge regression in Equation (17.108).

# 17.2.3 Comparison to kernel regression

In Section 16.3.5, we discussed kernel regression, which is a generative approach to regression in which we approximate $p ( \boldsymbol { y } , \pmb { x } )$ using kernel density estimation. In particular, Equation (16.39) gives us

$$
\begin{array} { c l c r } { \displaystyle \mathbb { E } \left[ y | { \pmb x } , \mathcal { D } \right] = \frac { \sum _ { n = 1 } ^ { N } K _ { h } ( { \pmb x } - { \pmb x } _ { n } ) y _ { n } } { \sum _ { n = 1 } ^ { N } K _ { h } ( { \pmb x } - { \pmb x } _ { n } ) } = \sum _ { n = 1 } ^ { N } y _ { n } w _ { n } ( { \pmb x } ) } \\ { w _ { n } ( { \pmb x } ) \triangleq \frac { K _ { h } ( { \pmb x } - { \pmb x } _ { n } ) } { \sum _ { n ^ { \prime } = 1 } ^ { N } K _ { h } ( { \pmb x } - { \pmb x } _ { n ^ { \prime } } ) } } \end{array}
$$

This is very similar to Equation (17.38). However, there are a few important differences. Firstly, in a GP, we use a positive definite (Mercer) kernel instead of a density kernel; Mercer kernels can be defined on structured objects, such as strings and graphs, which is harder to do for density kernels.

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

Second, a GP is an interpolator (at least when $\sigma ^ { 2 } = 0$ ), so $\mathbb { E } \left[ y | { \pmb x } _ { n } , { \pmb D } \right] = y _ { n }$ . By contrast, kernel regression is not an interpolator (although it can be made into one by iteratively fitting the residuals, as in [KJ16]). Third, a GP is a Bayesian method, which means we can estimate hyperparameters (of the kernel) by maximizing the marginal likelihood; by contrast, in kernel regression we must use cross-validation to estimate the kernel parameters, such as the bandwidth. Fourth, computing the weights $w _ { n }$ for kernel regression takes $O ( N )$ time, where $N = | \mathcal { D } |$ , whereas computing the weights $\alpha _ { n }$ for GP regression takes $O ( N ^ { 3 } )$ time (although there are approximation methods that can reduce this to $O ( N M ^ { 2 } )$ , as we discuss in Section 17.2.9).

# 17.2.4 Weight space vs function space

In this section, we show how Bayesian linear regression is a special case of a GP.

Consider the linear regression model $y = f ( \pmb { x } ) + \epsilon$ , where $f ( \pmb { x } ) = \pmb { w } ^ { 1 } \phi ( \pmb { x } )$ and $\epsilon \sim \mathcal { N } ( 0 , \sigma _ { y } ^ { 2 } )$ . If we use a Gaussian prior $p ( \pmb { w } ) = \mathcal { N } ( \pmb { w } | \mathbf { 0 } , \pmb { \Sigma } _ { w } )$ , then the posterior is as follows (see Section 11.7.2 for the derivation):

$$
p ( \pmb { w } | \mathcal { D } ) = \mathcal { N } ( \pmb { w } | \frac { 1 } { \sigma _ { y } ^ { 2 } } \mathbf { A } ^ { - 1 } \pmb { \Phi } ^ { T } \pmb { y } , \mathbf { A } ^ { - 1 } )
$$

where $\Phi$ is the $N \times D$ design matrix, and

$$
\mathbf { A } = \sigma _ { y } ^ { - 2 } \boldsymbol { \Phi } ^ { \mathsf { T } } \boldsymbol { \Phi } + \boldsymbol { \Sigma } _ { w } ^ { - 1 }
$$

The posterior predictive distribution for $f _ { * } = f ( \pmb { x } _ { * } )$ is therefore

$$
p ( f _ { * } | \mathcal { D } , \pmb { x } _ { * } ) = \mathcal { N } ( f _ { * } | \frac { 1 } { \sigma _ { y } ^ { 2 } } \phi _ { * } ^ { \top } \mathbf { A } ^ { - 1 } \Phi ^ { \top } y , \ \phi _ { * } ^ { \top } \mathbf { A } ^ { - 1 } \phi _ { * } )
$$

where $\phi _ { * } = \phi ( \pmb { x } _ { * } )$ . This views the problem of inference and prediction in weight space.

We now show that this is equivalent to the predictions made by a GP using a kernel of the form $\begin{array} { r } { \mathcal { K } ( \pmb { x } , \pmb { x } ^ { \prime } ) = \phi ( \pmb { x } ) ^ { 1 } \pmb { \Sigma } _ { w } \phi ( \pmb { x } ^ { \prime } ) } \end{array}$ . To see this, let $\mathbf { K } = \Phi \pmb { \Sigma } _ { w } \pmb { \Phi } ^ { \mathsf { I } }$ , $\pmb { k } _ { * } = \pmb { \Phi } \pmb { \Sigma } _ { w } \pmb { \phi } _ { * }$ , and $k _ { * * } = \phi _ { * } ^ { 1 } \pmb { \Sigma } _ { w } \phi _ { * }$ . Using this notation, and the matrix inversion lemma, we can rewrite Equation (17.43) as follows

$$
\begin{array} { r l } & { p ( f _ { * } | \mathcal { D } , \boldsymbol { x } _ { * } ) = \mathcal { N } ( f _ { * } | \mu _ { * | X } , \Sigma _ { * | X } ) } \\ & { \qquad \mu _ { * | X } = \phi _ { * } ^ { \mathsf { T } } \Sigma _ { w } \Phi ^ { \mathsf { T } } ( \mathbf { K } + \sigma _ { y } ^ { 2 } \mathbf { I } ) ^ { - 1 } y = k _ { * } ^ { \mathsf { T } } \mathbf { K } _ { \sigma } ^ { - 1 } y } \\ & { \qquad \Sigma _ { * | X } = \phi _ { * } ^ { \mathsf { T } } \Sigma _ { w } \phi _ { * } - \phi _ { * } ^ { \mathsf { T } } \Sigma _ { w } \Phi ^ { \mathsf { T } } ( \mathbf { K } + \sigma _ { y } ^ { 2 } \mathbf { I } ) ^ { - 1 } \Phi \Sigma _ { w } \phi _ { * } = k _ { * * } - k _ { * } ^ { \mathsf { T } } \mathbf { K } _ { \sigma } ^ { - 1 } k _ { * } } \end{array}
$$

which matches the results in Equation (17.37), assuming $m ( { \pmb x } ) = 0$ . (Non-zero mean can be captured by adding a constant feature with value $1$ to $\phi ( { \pmb x } )$ .)

Thus we can derive a GP from Bayesian linear regression. Note, however, that linear regression assumes $\phi ( { \pmb x } )$ is a finite length vector, whereas a GP allows us to work directly in terms of kernels, which may correspond to infinite length feature vectors (see Section 17.1.1). That is, a GP works in function space.

# 17.2.5 Numerical issues

In this section, we discuss computational and numerical issues which arise when implementing the above equations. For notational simplicity, we assume the prior mean is zero, $m ( { \pmb x } ) = 0$ .

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

![](images/1b8988d970f2287196632ab88dfa8189d0271e7a23efdb984d84b429df457536.jpg)  
Figure 17.8: Some 1d GPs with $S E$ kernels but different hyper-parameters fit to 20 noisy observations. The hyper-parameters $( \ell , \sigma _ { f } , \sigma _ { y } )$ are as follows: (a) $( 1 , 1 , 0 . 1 )$ (b) (3.0, 1.16, 0.89). Adapted from Figure 2.5 of [RW06]. Generated by gprDemoChangeHparams.ipynb.

The posterior predictive mean is given by $\mu _ { * } = k _ { * } ^ { \mathrm { I } } \mathbf { K } _ { \sigma } ^ { - 1 } \pmb { y }$ . For reasons of numerical stability, it is unwise to directly invert ${ \bf K } _ { \sigma }$ . A more robust alternative is to compute a Cholesky decomposition, ${ \bf K } _ { \sigma } = { \bf L L } ^ { \sf I }$ , which takes $O ( N ^ { 3 } )$ time. Then we compute ${ \pmb { \alpha } } = { \bf L } ^ { 1 } \setminus ( { \bf L } \setminus { \pmb { y } } )$ , where we have used the backslash operator to represent backsubstitution (Section 7.7.1). Given this, we can compute the posterior mean for each test case in $O ( N )$ time using

$$
\mu _ { * } = k _ { * } ^ { \mathsf { T } } \mathbf { K } _ { \sigma } ^ { - 1 } \pmb { y } = k _ { * } ^ { \mathsf { T } } \mathbf { L } ^ { - \mathsf { T } } ( \mathbf { L } ^ { - 1 } \pmb { y } ) = k _ { * } ^ { \mathsf { T } } \pmb { \alpha }
$$

We can compute the variance in $O ( N ^ { 2 } )$ time for each test case using

$$
\sigma _ { * } ^ { 2 } = k _ { * * } - k _ { * } ^ { \mathsf { T } } { \mathbf { L } } ^ { - T } { \mathbf { L } } ^ { - 1 } k _ { * } = k _ { * * } - v ^ { \mathsf { T } } v
$$

where ${ \pmb v } = { \bf L } \backslash { \pmb k } _ { * }$ .

Finally, the log marginal likelihood (needed for kernel learning, Section 17.2.6) can be computed using

$$
\log p ( \pmb { y } | \mathbf { X } ) = - \frac { 1 } { 2 } \pmb { y } ^ { \top } \pmb { \alpha } - \sum _ { n = 1 } ^ { N } \log L _ { n n } - \frac { N } { 2 } \log ( 2 \pi )
$$

# 17.2.6 Estimating the kernel

Most kernels have some free parameters, which can have a large effect on the predictions from the model. For example, suppose we are performing 1d regression using a GP with an RBF kernel of the form

$$
K ( x _ { p } , x _ { q } ) = \sigma _ { f } ^ { 2 } \exp ( - \frac { 1 } { 2 \ell ^ { 2 } } ( x _ { p } - x _ { q } ) ^ { 2 } )
$$

Here $\ell$ is the horizontal scale over which the function changes, $\sigma _ { f } ^ { 2 }$ controls the vertical scale of the function. We assume observation noise with variance $\sigma _ { y } ^ { 2 }$ .

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

We sampled 20 observations from an MVN with a covariance given by $\pmb { \Sigma } = \mathcal { K } ( x _ { i } , x _ { j } )$ for a grid of points $\{ x _ { i } \}$ , and added observation noise of value $\sigma _ { y }$ . We then fit this data using a GP with the same kernel, but with a range of hyperparmameters. Figure 17.8 illustrates the effects of changing these parameters. In Figure 17.8(a), we use $( \ell , \sigma _ { f } , \sigma _ { y } ) = ( 1 , 1 , 0 . 1 )$ , and the result is a good fit. In Figure 17.8(b), we increase the length scale to $\ell = 3$ ; now the function looks overly smooth.

# 17.2.6.1 Empirical Bayes

To estimate the kernel parameters $\pmb \theta$ (sometimes called hyperparameters), we could use exhaustive search over a discrete grid of values, with validation loss as an objective, but this can be quite slow. (This is the approach used by nonprobabilistic methods, such as SVMs (Section 17.3) to tune kernels.) Here we consider an empirical Bayes approach (Section 4.6.5.3), which will allow us to use gradient-based optimization methods, which are much faster. In particular, we will maximize the marginal likelihood

$$
p ( { \pmb y } | { \bf X } , { \pmb \theta } ) = \int p ( { \pmb y } | { \pmb f } , { \bf X } ) p ( { \pmb f } | { \bf X } , { \pmb \theta } ) d { \pmb f }
$$

(The reason it is called the marginal likelihood, rather than just likelihood, is because we have marginalized out the latent Gaussian vector $f$ .)

For notational simplicity, we assume the mean function is $0$ . Since $p ( f | \mathbf { X } ) = { \mathcal { N } } ( f | \mathbf { 0 } , \mathbf { K } )$ , and $\begin{array} { r } { p ( { \pmb y } | { \pmb f } ) = \prod _ { n = 1 } ^ { N } \mathcal { N } ( y _ { n } | f _ { n } , \sigma _ { y } ^ { 2 } ) } \end{array}$ , the marginal likelihood is given by

$$
\log p ( { \pmb y } | { \bf X } , { \pmb \theta } ) = \log \mathcal { N } ( { \pmb y } | { \bf 0 } , { \bf K } _ { \sigma } ) = - \frac { 1 } { 2 } { \pmb y } ^ { \top } { \bf K } _ { \sigma } ^ { - 1 } { \pmb y } - \frac { 1 } { 2 } \log | { \bf K } _ { \sigma } | - \frac { N _ { \mathcal { D } } } { 2 } \log ( 2 \pi )
$$

where the dependence of $\mathbf { K } _ { \sigma } = \mathbf { K } _ { X , X } + \sigma _ { 2 } ^ { 2 } \mathbf { I } _ { N }$ on $\pmb \theta$ is implicit. The first term is a data fit term, the second term is a model complexity term, and the third term is just a constant. To understand the tradeoff between the first two terms, consider a SE kernel in 1D, as we vary the length scale $\ell$ and hold $\sigma _ { y } ^ { 2 }$ fixed. For short length scales, the fit will be good, so ${ \pmb y } ^ { \mathrm { | } } { \bf K } _ { \sigma } ^ { - 1 } { \pmb y }$ will be small. However, the model complexity will be high: $\mathbf { K }$ will be almost diagonal, (as in Figure 13.22, top right), since most points will not be considered “near” any others, so the $\mathrm { l o g } \left| { \bf K } _ { \sigma } \right|$ term will be large. For long length scales, the fit will be poor but the model complexity will be low: $\mathbf { K }$ will be almost all 1’s, (as in Figure 13.22, bottom right), so $\log | \mathbf { K } _ { \sigma } |$ will be small.

We now discuss how to maximize the marginal likelihood. One can show that

$$
\begin{array} { c } { \displaystyle \frac { \partial } { \partial \theta _ { j } } \log p ( { \pmb y } | { \bf X } , { \pmb \theta } ) = \frac { 1 } { 2 } { \pmb y } ^ { \top } \mathbf { K } _ { \sigma } ^ { - 1 } \frac { \partial \mathbf { K } _ { \sigma } } { \partial \theta _ { j } } \mathbf { K } _ { \sigma } ^ { - 1 } { \pmb y } - \frac { 1 } { 2 } \mathrm { t r } ( \mathbf { K } _ { \sigma } ^ { - 1 } \frac { \partial \mathbf { K } _ { \sigma } } { \partial \theta _ { j } } ) } \\ { = \frac { 1 } { 2 } \mathrm { t r } \left( ( \pmb { \alpha } \pmb { \alpha } ^ { \top } - \mathbf { K } _ { \sigma } ^ { - 1 } ) \frac { \partial \mathbf { K } _ { \sigma } } { \partial \theta _ { j } } \right) } \end{array}
$$

where $\pmb { \alpha } = \mathbf { K } _ { \sigma } ^ { - 1 } \pmb { y }$ . It takes $O ( N ^ { 3 } )$ time to compute ${ \bf K } _ { \sigma } ^ { - 1 }$ , and then $O ( N ^ { 2 } )$ time per hyper-parameter to compute the gradient.

The form of $\frac { \partial \mathbf { K } _ { \sigma } } { \partial \theta _ { j } }$ depends on the form of the kernel, and which parameter we are taking derivatives with respect to. Often we have constraints on the hyper-parameters, such as $\sigma _ { y } ^ { 2 } \geq 0$ . In this case, we can define $\theta = \log ( \sigma _ { y } ^ { 2 } )$ , and then use the chain rule.

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

![](images/15313d736396a5cea245acef0c122c8ac554555a91155ec06b308dc713767fa0.jpg)  
Figure 17.9: Illustration of local minima in the marginal likelihood surface. (a) We plot the log marginal likelihood vs kernel length scale $\ell$ and observation noise $\sigma _ { y }$ , for fixed signal level $\sigma _ { f } ~ = ~ 1$ , using the 7 data points shown in panels $b$ and c. (b) The function corresponding to the lower left local minimum, $( \ell , \sigma _ { y } ) \approx ( 1 , 0 . 2 )$ . This is quite “wiggly” and has low noise. (c) The function corresponding to the top right local minimum, $( \ell , \sigma _ { y } ) \approx ( 1 0 , 0 . 8 )$ . This is quite smooth and has high noise. The data was generated using $( \ell , \sigma _ { f } , \sigma _ { y } ) = ( 1 , 1 , 0 . 1 )$ . Adapted from Figure 5.5 of [RW06]. Generated by gpr_demo_marglik.ipynb.

Given an expression for the log marginal likelihood and its derivative, we can estimate the kernel parameters using any standard gradient-based optimizer. However, since the objective is not convex, local minima can be a problem, as we illustrate below, so we may need to use multiple restarts.

As an example, consider the RBF in Equation (17.50) with $\sigma _ { f } ^ { 2 } = 1$ . In Figure 17.9(a), we plot $\log p ( \pmb { y } | \mathbf { X } , \ell , \sigma _ { y } ^ { 2 } )$ (where $\mathbf { X }$ and $\pmb { y }$ are the 7 data points shown in panels b and c) as we vary $\ell$ and $\sigma _ { y } ^ { 2 }$ . The two local optima are indicated by $^ +$ . The bottom left optimum corresponds to a low-noise, short-length scale solution (shown in panel b). The top right optimum corresponds to a high-noise, long-length scale solution (shown in panel c). With only 7 data points, there is not enough evidence to confidently decide which is more reasonable, although the more complex model (panel b) has a marginal likelihood that is about $6 0 \%$ higher than the simpler model (panel c). With more data, the more complex model would become even more preferred.

Figure 17.9 illustrates some other interesting (and typical) features. The region where $\sigma _ { y } ^ { 2 } \approx 1$ (top of panel a) corresponds to the case where the noise is very high; in this regime, the marginal likelihood is insensitive to the length scale (indicated by the horizontal contours), since all the data is explained as noise. The region where $\ell \approx 0 . 5$ (left hand side of panel a) corresponds to the case where the length scale is very short; in this regime, the marginal likelihood is insensitive to the noise level (indicated by the vertical contours), since the data is perfectly interpolated. Neither of these regions would be chosen by a good optimizer.

# 17.2.6.2 Bayesian inference

When we have a small number of datapoints (e.g., when using GPs for Bayesian optimization), using a point estimate of the kernel parameters can give poor results [Bul11; WF14]. In such cases, we may wish to approximate the posterior over the kernel parameters. Several methods can be used. For example, [MA10] shows how to use slice sampling, [Hen+15] shows how to use Hamiltonian Monte Carlo, and [BBV11] shows how to use sequential Monte Carlo.

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

![](images/2de1b5add912ccfd407e9b8702994d7b7d51d7f74ce78c1ee299b41c3377a63e.jpg)  
Figure 17.10: GP classifier for a binary classification problem on Iris flowers (Setosa vs Versicolor) using a single input feature (sepal length). The fat vertical line is the credible interval for the decision boundary. (a) SE kernel. (b) SE plus linear kernel. Adapted from Figures 7.11–7.12 of [Mar18]. Generated by gp_classify_iris_1d_pymc3.ipynb.

# 17.2.7 GPs for classification

So far, we have focused on GPs for regression using Gaussian likelihoods. In this case, the posterior is also a GP, and all computation can be performed analytically. However, if the likelihood is non-Gaussian, such as the Bernoulli likelihood for binary classification, we can no longer compute the posterior exactly.

There are various approximations we can make. some of which we discuss in the sequel to this book, [Mur23]. In this section, we use the Hamiltonian Monte Carlo method (Section 4.6.8.4), both for the latent Gaussian function $f$ as well as the kernel hyperparameters $\pmb \theta$ . The basic idea is to specify the negative log joint

$$
\begin{array} { r } { \boldsymbol { \eta } ) = \log p ( f , \theta | \mathbf { X } , \boldsymbol { y } ) = \log \mathcal { N } ( f | \mathbf { 0 } , \mathbf { K } ( \mathbf { X } , \mathbf { X } ) ) + \displaystyle \sum _ { n = 1 } ^ { N } \log \mathrm { B e r } ( y _ { n } | f _ { n } ( \boldsymbol { x } _ { n } ) ) + \log p ( f _ { n } | \boldsymbol { y } , \boldsymbol { y } ) , } \end{array}
$$

We then use autograd to compute $\nabla _ { f } \mathcal { E } ( f , \theta )$ and $\nabla _ { \boldsymbol { \theta } } \mathcal { E } ( \boldsymbol { f } , \boldsymbol { \theta } )$ , and use these gradients as inputs to a Gaussian proposal distribution.

Let us consider a 1d example from [Mar18]. This is similar to the Bayesian logistic regression example from Figure 4.20, where the goal is to classify iris flowers as being Setosa or Versicolor, $y _ { n } \in \{ 0 , 1 \}$ , given information about the sepal length, $x _ { n }$ . We will use an SE kernel with length scale $\ell$ . We put a $\mathrm { G a ( 2 , 0 . 5 ) }$ prior on $\ell$ .

Figure 17.10a shows the results using the SE kernel. This is similar to the results of linear logistic regression (see Figure 4.20), except that at the edges (away from the data), the probability curves towards 0.5. This is because the prior mean function is $m ( x ) = 0$ , and $\sigma ( 0 ) = 0 . 5$ . We can eliminate this artefact by using a more flexible kernel, which encodes the prior knowledge that we expect the output to be monotonically increasing or decreasing in the input. We can do this using a linear kernel,

$$
\mathcal { K } ( x , x ^ { \prime } ) = ( x - c ) ( x ^ { \prime } - c )
$$

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

![](images/de5cf6287536c9043c3cfd4fbc3143a74fbb1c97ecc52360784221d53fe1cfe6.jpg)  
Figure 17.11: (a) Fictitious “space flu” binary classification problem. (b) Fit from a $G P$ with $S E$ kernel. Adapted from Figures 7.13–7.14 of [Mar18]. Generated by gp_classify_spaceflu_1d_pymc3.ipynb.

We can scale and add this to the SE kernel to get

$$
{ \ K ( x , x ^ { \prime } ) = \tau ( x - c ) ( x ^ { \prime } - c ) + \exp \left[ - { \frac { ( x - x ^ { \prime } ) ^ { 2 } } { 2 \ell ^ { 2 } } } \right] }
$$

The results are shown in Figure 17.10b, and look more reasonable.

One might wonder why we bothered to use a GP, when the results are no better than a simple linear logistic regression model. The reason is that the GP is much more flexible, and makes fewer a priori assumptions, beyond smoothness. For example, suppose the data looked like Figure 17.11a. In this case, a linear logistic regression model could not fit the data. We could in principle use a neural network, but it may not work well since we only have 60 data points. However, GPs are well designed to handle the small sample setting. In Figure 17.11b, we show the results of fitting a GP with an SE kernel to this data. The results look reasonable.

# 17.2.8 Connections with deep learning

It turns out that there are many interesting connections and similarities between GPs and deep neural networks. For example, one can show that a neural network with a single, infinitely wide layer of RBF units is equivalent to a GP with an RBF kernel. (This follows from the fact that the RBF kernel can be expressed as the inner product of an infinite number of features.) In fact, many kinds of DNNs (in the infinite limit) can be converted to an equivalent GP using a specific kind of kernel known as the neural tangent kernel [JGH18]. See the sequel to this book, [Mur23], for details.

# 17.2.9 Scaling GPs to large datasets

The main disadvantage of GPs (and other kernel methods, such as SVMs, which we discuss in Section 17.3) is that inverting the $N \times N$ kernel matrix takes $O ( N ^ { 3 } )$ time, making the method too

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

slow for big datasets. Many different approximate schemes have been proposed to speedup GPs (see e.g., [Liu+18a] for a review). In this section, we briefly mention some of them. For more details, see the sequel to this book, [Mur23].

# 17.2.9.1 Sparse (inducing-point) approximations

A simple approach to speeding up GP inference is to use less data. A better approach is to try to “summarize” the $N$ training points $\mathbf { X }$ into $M \ll N$ inducing points or pseudo inputs $\mathbf { Z }$ . This lets us replace $p ( f | f _ { X } )$ with $p ( f | f _ { Z } )$ , where ${ \pmb f } _ { X } = \{ f ( { \pmb x } ) : { \pmb x } \in { \pmb Z } \}$ is the vector of observed function values at the training points, and ${ \pmb f } _ { Z } = \{ f ( { \pmb x } ) : { \pmb x } \in { \pmb Z } \}$ is the vector of estimated function values at the inducing points. By optimizing $( \mathbf { Z } , f _ { Z } )$ we can learn to “compress” the training data $( \mathbf { X } , f _ { X } )$ into a “bottleneck” $( \mathbf { Z } , f _ { Z } )$ , thus speeding up computation from $O ( N ^ { 3 } )$ to $O ( M ^ { 3 } )$ . This is called a sparse GP. This whole process can be made rigorous using the framework of variational inference. For details, see the sequel to this book, [Mur23].

# 17.2.9.2 Exploiting parallelization and kernel matrix structure

It takes $O ( N ^ { 3 } )$ time to compute the Cholesky decomposition of $\mathbf { K } _ { X , X }$ , which is needed to solve the linear system $\mathbf { K } _ { \sigma } \mathbf { \alpha } \alpha = \mathbf { \mathscr { y } }$ and to compute $| \mathbf { K } _ { X , X } |$ , where ${ \mathbf K } _ { \sigma } = { \mathbf K } _ { X , X } + \sigma ^ { 2 } { \mathbf I } _ { N }$ . An alternative to Cholesky decomposition is to use linear algebra methods, often called Krylov subspace methods, which are based just on matrix vector multiplication or MVM. These approaches are often much faster, since they can naturally exploit structure in the kernel matrix. Moreover, even if the kernel matrix does not have special structure, matrix multiplies are trivial to parallelize, and can thus be greatly accelerated by GPUs, unlike Cholesky based methods which are largely sequential. This is the basis of the popular GPyTorch package [Gar+18]. For more details, see the sequel to this book, [Mur23].

# 17.2.9.3 Random feature approximation

Although the power of kernels resides in the ability to avoid working with featurized representations of the inputs, such kernelized methods take $O ( N ^ { 3 } )$ time, in order to invert the Gram matrix $\mathbf { K }$ . This can make it difficult to use such methods on large scale data. Fortunately, we can approximate the feature map for many (shift invariant) kernels using a randomly chosen finite set of $M$ basis functions, thus reducing the cost to $O ( N M + M ^ { 3 } )$ . We briefly discuss this idea below. For more details, see e.g., [Liu+20].

# Random features for RBF kernel

We will focus on the case of the Gaussian RBF kernel. One can show that

$$
{ \mathcal K } ( \pmb x , \pmb x ^ { \prime } ) \approx \phi ( \pmb x ) ^ { \top } \phi ( \pmb x ^ { \prime } )
$$

where the (real-valued) feature vector is given by

$$
\begin{array} { l } { \displaystyle \phi ( \boldsymbol { x } ) \triangleq \frac { 1 } { \sqrt { T } } [ ( \sin ( \omega _ { 1 } ^ { \top } \boldsymbol { x } ) , . . . , \sin ( \omega _ { T } ^ { \top } \boldsymbol { x } ) , \cos ( \omega _ { 1 } ^ { \top } \boldsymbol { x } ) , . . . , \cos ( \omega _ { T } ^ { \top } \boldsymbol { x } ) ) ] } \\ { \displaystyle = \frac { 1 } { \sqrt { T } } \left[ \sin ( \Omega \boldsymbol { x } ) , \cos ( \Omega \boldsymbol { x } ) \right] } \end{array}
$$

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license where $T = M / 2$ , and $\pmb { \Omega } \in \mathbb { R } ^ { T \times D }$ is a random Gaussian matrix, where the entries are sampled iid from $\mathcal { N } ( 0 , 1 / \sigma ^ { 2 } )$ , where $\sigma$ is the kernel bandwidth. The bias of the approximation decreases as we increase $M$ . In practice, we use a finite $M$ , and compute a single sample Monte Carlo approximation to the expectation by drawing a single random matrix. The features in Equation (17.60) are called random Fourier features (RFF) [RR08] or “weighted sums of random kitchen sinks” [RR09].

We can also use positive random features, rather than trigonometric random features, which can be preferable in some applications, such as models which use attention (see Section 15.6.4). In particular, we can use

$$
\phi ( \pmb { x } ) \triangleq e ^ { - | | \pmb { x } | | ^ { 2 } / 2 } \frac { 1 } { \sqrt { M } } \left[ ( \exp ( \omega _ { 1 } ^ { \mathsf { T } } \pmb { x } ) , \cdots , ( \exp ( \omega _ { M } ^ { \mathsf { T } } \pmb { x } ) \big ] \right.
$$

where $\omega _ { m }$ are sampled as before. For details, see [Cho+20b].

Regardless of whether we use trigonometric or positive features, we can obtain a lower variance estimate by ensuring that the rows of $\mathbf { Z }$ are random but orthogonal; these are called orthogonal random features. Such sampling can be conducted efficiently via Gram-Schmidt orthogonalization of the unstructured Gaussian matrices [Yu+16], or several approximations that are even faster (see [CRW17; Cho+19]).

# Fastfood approximation

Unfortunately, storing the random matrix $\Omega$ takes $O ( D M )$ space, and computing $\Omega x$ takes $O ( D M )$ time, where $D$ is the input dimensionality, and $M$ is the number of random features. This can be prohibitive if $M \gg D$ , which it may need to be in order to get any benefits over using the original set of features. Fortunately, we can use the fast Hadamard transform to reduce the memory from $O ( M D )$ to $O ( M )$ , and reduce the time from $O ( M D )$ to $O ( M \log D )$ . This approach has been called fastfood [LSS13], a reference to the original term “kitchen sinks”.

# Extreme learning machines

We can use the random features approximation to the kernel to convert a GP into a linear model of the form

$$
f ( \pmb { x } ; \pmb { \theta } ) = \mathbf { W } \phi ( \pmb { x } ) = \mathbf { W } h ( \mathbf { Z } \pmb { x } )
$$

where $h ( a ) = \sqrt { 1 / M } [ \sin ( a ) , \cos ( a ) ]$ for RBF kernels. This is equivalent to a one-layer MLP with random (and fixed) input-to-hidden weights. When $M > N$ , this corresponds to an over-parameterized model, which can perfectly interpolate the training data.

In [Cur+17], they apply this method to fit a logistic regression model of the form $f ( { \pmb x } ; { \pmb \theta } ) =$ $\mathbf { W } ^ { \top } h ( \widehat { \mathbf { Z } } \mathbf { x } ) + b$ using SGD; they call the resulting method “McKernel”. We can also optimize $\mathbf { Z }$ as well as $\mathbf { W }$ , as discussed in [Alb+17], although now the problem is no longer convex.

Alternatively, we can use $M < N$ , but stack many such random nonlinear layers together, and just optimize the output weights. This has been called an extreme learning machine or ELM (see e.g., [Hua14]), although this work is controversial.1

![](images/366be1079bf0133909be76c3f615d02c82f04f57daae15a89c229a05ef1135c7.jpg)  
Figure 17.12: Illustration of the large margin principle. Left: a separating hyper-plane with large margin. Right: a separating hyper-plane with small margin.

# 17.3 Support vector machines (SVMs)

In this section, we discuss a form of (non-probabilistic) predictors for classification and regression problems which have the form

$$
f ( { \pmb x } ) = \sum _ { i = 1 } ^ { N } \alpha _ { i } { \mathcal { K } } ( { \pmb x } , { \pmb x } _ { i } )
$$

By adding suitable constraints, we can ensure that many of the $\alpha _ { i }$ coefficients are $0$ , so that predictions at test time only depend on a subset of the training points. The surving points are called “support vectors”, and the resulting model is called a support vector machine or SVM. We give a brief summary below. More details, can be found in e.g., [VGS97; SS01],

# 17.3.1 Large margin classifiers

Consider a binary classifier of the form $h ( { \pmb x } ) = \mathrm { s i g n } ( f ( { \pmb x } ) )$ , where the decision boundary is given by the following linear function:

$$
f ( \pmb { x } ) = \pmb { w } ^ { \top } \pmb { x } + w _ { 0 }
$$

(In the SVM literature, it is common to assume the class labels are $- 1$ and $+ 1$ , rather than 0 and $1$ . To avoid confusion, we denote such target labels by $\tilde { y }$ rather than $y$ .) There may be many lines that separate the data. However, intuitively we would like to pick the one that has maximum margin, which is the distance of the closest point to the decision boundary, since this will give us the most robust solution. This idea is illustrated in Figure 17.12: the solution on the left has larger margin than the one on the right, and intuitively is is better, since it will be less sensitive to perturbations of the data.

How can we compute such a large margin classifier? First we need to derive an expression for the distance of a point to the decision boundary. Referring to Figure 17.13(a), we see that

$$
\pmb { x } = \pmb { x } _ { \perp } + r \frac { \pmb { w } } { | | \pmb { w } | | }
$$

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

![](images/8ea9671ad934e83f9fa3ab33ed75f871c142cb783404b07625ef1c1d9085f204.jpg)  
Figure 17.13: (a) Illustration of the geometry of a linear decision boundary in 2d. A point $_ { \ast }$ is classified as belonging in decision region $\mathcal { R } _ { 1 }$ if $f ( { \pmb x } ) > 0$ , otherwise it belongs in decision region $\mathcal { R } _ { 0 }$ ; $\mathbf { \boldsymbol { w } }$ is a vector which is perpendicular to the decision boundary. The term $_ { w _ { 0 } }$ controls the distance of the decision boundary from the origin. ${ \pmb x } _ { \bot }$ is the orthogonal projection of $_ { \pmb { x } }$ onto the boundary. The signed distance of $_ { \ast }$ from the boundary is given by $f ( { \pmb x } ) / | | { \pmb w } | |$ . Adapted from Figure 4.1 of [Bis06]. (b) Points with circles around them are support vectors, and have dual variables $\alpha _ { n } > 0$ . In the soft margin case, we associate a slack variable $\xi _ { n }$ with each example. If $0 < \xi _ { n } < 1$ , the point is inside the margin, but on the correct side of the decision boundary. If $\xi _ { n } > 1$ , the point is on the wrong side of the boundary. Adapted from Figure 7.3 of [Bis06].

where $r$ is the distance of $_ { x }$ from the decision boundary whose normal vector is $\mathbf { \boldsymbol { w } }$ , and ${ \pmb x } _ { \bot }$ is the orthogonal projection of $_ { x }$ onto this boundary.

We would like to maximize $r$ , so we need to express it as a function of $\mathbf { \boldsymbol { w } }$ . First, note that

$$
f ( \pmb { x } ) = \pmb { w } ^ { \mathsf { T } } \pmb { x } + w _ { 0 } = ( \pmb { w } ^ { \mathsf { T } } \pmb { x } _ { \bot } + w _ { 0 } ) + r \frac { \pmb { w } ^ { \mathsf { T } } \pmb { w } } { \lVert \pmb { w } \rVert } = ( \pmb { w } ^ { \mathsf { T } } \pmb { x } _ { \bot } + w _ { 0 } ) + r | | \pmb { w } | |
$$

Since $0 = f ( \pmb { x } _ { \bot } ) = \pmb { w } ^ { \top } \pmb { x } _ { \bot } + w _ { 0 }$ , we have $f ( \pmb { x } ) = r | | \pmb { w } | |$ and hence $\begin{array} { r } { r = \frac { f ( \pmb { x } ) } { | | \pmb { w } | | } } \end{array}$

Since we want to ensure each point is on the correct side of the boundary, we also require $f ( { \pmb x } _ { n } ) { \widetilde y } _ { n } > 0$ . We want to maximize the distance of the closest point, so our final objective becomes

$$
\operatorname* { m a x } _ { \pmb { w } , \pmb { w } _ { 0 } } \frac { 1 } { \lvert \lvert \pmb { w } \rvert \rvert } \operatorname* { m i n } _ { n = 1 } \left[ \tilde { y } _ { n } ( \pmb { w } ^ { \top } \pmb { x } _ { n } + w _ { 0 } ) \right]
$$

Note that by rescaling the parameters using ${ \pmb w }  k { \pmb w }$ and $w _ { 0 } \to k w _ { 0 }$ , we do not change the distance of any point to the boundary, since the $k$ factor cancels out when we divide by $| | \pmb { w } | |$ . Therefore let

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

![](images/737923d4916fbeabd859a9a82e617fa8ac16945aeda5c101dc1a2f4231bce03a.jpg)  
Figure 17.14: Illustration of the benefits of scaling the input features before computing a max margin classifier. Adapted from Figure 5.2 of [Gér19]. Generated by svm_classifier_feature_scaling.ipynb.

us define the scale factor such that $\tilde { y } _ { n } f _ { n } = 1$ for the point that is closest to the decision boundary. Hence we require $\tilde { y } _ { n } f _ { n } \ge 1$ for all $n$ . Finally, note that maximizing $1 / | | w | |$ is equivalent to minimizing $| | \boldsymbol { w } | | ^ { 2 }$ . Thus we get the new objective

$$
\operatorname* { m i n } _ { \pmb { w } , \pmb { w } _ { 0 } } \frac { 1 } { 2 } | | \pmb { w } | | ^ { 2 } \mathrm { s . t . } \tilde { y } _ { n } ( \pmb { w } ^ { \mathsf { T } } \pmb { x } _ { n } + \pmb { w } _ { 0 } ) \geq 1 , n = 1 : N _ { \mathscr D }
$$

(The factor of $\textstyle { \frac { 1 } { 2 } }$ is added for convenience and doesn’t affect the optimal parameters.) The constraint says that we want all points to be on the correct side of the decision boundary with a margin of at least 1.

Note that it is important to scale the input variables before using an SVM, otherwise the margin measures distance of a point to the boundary using all input dimensions equally. See Figure 17.14 for an illustration.

# 17.3.2 The dual problem

The objective in Equation (17.68) is a standard quadratic programming problem (Section 8.5.4), since we have a quadratic objective subject to linear constraints. This has $N + D + 1$ variables subject to $N$ constraints, and is known as a primal problem.

In convex optimization, for every primal problem we can derive a dual problem. Let ${ \pmb { \alpha } } \in \mathbb { R } ^ { N }$ be the dual variables, corresponding to Lagrange multipliers that enforce the $N$ inequality constraints. The generalized Lagrangian is given below (see Section 8.5.2 for relevant background information on constrained optimization):

$$
\mathcal { L } ( \boldsymbol { w } , \boldsymbol { w } _ { 0 } , \alpha ) = \frac { 1 } { 2 } \boldsymbol { w } ^ { \mathsf { T } } \boldsymbol { w } - \sum _ { n = 1 } ^ { N } \alpha _ { n } \big ( \tilde { y } _ { n } ( \boldsymbol { w } ^ { \mathsf { T } } x _ { n } + w _ { 0 } ) - 1 \big )
$$

To optimize this, we must find a stationary point that satisfies

$$
( \hat { \pmb w } , \hat { w } _ { 0 } , \hat { \pmb \alpha } ) = \operatorname* { m i n } _ { { \pmb w } , { w } _ { 0 } } \operatorname* { m a x } _ { \pmb { \alpha } } \mathcal { L } ( { \pmb w } , { w } _ { 0 } , { \pmb \alpha } )
$$

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

We can do this by computing the partial derivatives wrt $\mathbf { \boldsymbol { w } }$ and $w _ { 0 }$ and setting to zero. We have

$$
\begin{array} { r l } & { \displaystyle \nabla _ { \boldsymbol { w } } \mathcal { L } \big ( \boldsymbol { w } , \boldsymbol { w _ { 0 } } , \alpha \big ) = \boldsymbol { w } - \sum _ { n = 1 } ^ { N } \alpha _ { n } \tilde { y } _ { n } \mathbf { x } _ { n } } \\ & { \displaystyle \frac { \partial } { \partial w _ { 0 } } \mathcal { L } \big ( \boldsymbol { w } , \boldsymbol { w _ { 0 } } , \alpha \big ) = - \sum _ { n = 1 } ^ { N } \alpha _ { n } \tilde { y } _ { n } } \end{array}
$$

and hence

$$
\begin{array} { c } { { \displaystyle { \hat { w } } = \sum _ { n = 1 } ^ { N } { \hat { \alpha } } _ { n } { \tilde { y } } _ { n } { \pmb x } _ { n } } } \\ { { 0 = \displaystyle \sum _ { n = 1 } ^ { N } { \hat { \alpha } } _ { n } { \tilde { y } } _ { n } } } \end{array}
$$

Plugging these into the Lagrangian yields the following

$$
\begin{array} { l } { \displaystyle \mathcal { L } ( \hat { w } , \hat { w } _ { 0 } , \alpha ) = \frac 1 2 \hat { w } ^ { \top } \hat { w } - \sum _ { n = 1 } ^ { N } \alpha _ { n } \tilde { y } _ { n } \hat { w } ^ { \top } x _ { n } - \sum _ { n = 1 } ^ { N } \alpha _ { n } \tilde { y } _ { n } w _ { 0 } + \sum _ { n = 1 } ^ { N } \alpha _ { n } } \\ { \displaystyle \qquad = \frac 1 2 \hat { w } ^ { \top } \hat { w } - \hat { w } ^ { \top } \hat { w } - 0 + \sum _ { n = 1 } ^ { N } \alpha _ { n } } \\ { \displaystyle \qquad = - \frac 1 2 \sum _ { i = 1 } ^ { N } \sum _ { j = 1 } ^ { N } \alpha _ { i } \alpha _ { j } \tilde { y } _ { i } \tilde { y } _ { j } x _ { i } ^ { \top } x _ { j } + \sum _ { n = 1 } ^ { N } \alpha _ { n } } \end{array}
$$

constraints that This is called the dual form of the objective. We want to maximize this wrt $\begin{array} { r } { \sum _ { n = 1 } ^ { N } \alpha _ { n } \tilde { y } _ { n } = 0 } \end{array}$ and $0 \leq \alpha _ { n }$ for $n = 1 : N$ . $\alpha$ subject to the

The above ob ective is a quadratic problem in $N$ variables. Standard QP solvers take $O ( N ^ { 3 } )$ time. However, specialized algorithms, which avoid the use of generic QP solvers, have been developed for this problem, such as the sequential minimal optimization or SMO algorithm [Pla98], which takes $O ( N )$ to $O ( N ^ { 2 } )$ time.

Since this is a convex objective, the solution must satisfy the KKT conditions (Section 8.5.2), which tell us that the following properties hold:

$$
\begin{array} { r l r } & { } & { \alpha _ { n } \geq 0 } \\ & { } & { \qquad \tilde { y } _ { n } f ( { \pmb x } _ { n } ) - 1 \geq 0 } \\ & { } & { \qquad \alpha _ { n } ( \tilde { y } _ { n } f ( { \pmb x } _ { n } ) - 1 ) = 0 } \end{array}
$$

Hence either $\alpha _ { n } = 0$ (in which case example $n$ is ignored when computing $\hat { \textbf { \textit { w } } }$ ) or the constraint $\tilde { y } _ { n } ( \hat { w } ^ { \top } x _ { n } + \hat { w } _ { 0 } ) = 1$ is active. This latter condition means that example $n$ lies on the decision boundary; these points are known as the support vectors, as shown in Figure 17.13(b). We denote the set of support vectors by $\boldsymbol { S }$ .

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

To perform prediction, we use

$$
\boldsymbol { f } ( \boldsymbol { x } ; \hat { \boldsymbol { w } } , \hat { w } _ { 0 } ) = \hat { \boldsymbol { w } } ^ { \top } \boldsymbol { x } + \hat { w } _ { 0 } = \sum _ { n \in S } \alpha _ { n } \tilde { y } _ { n } \boldsymbol { x } _ { n } ^ { \top } \boldsymbol { x } + \hat { w } _ { 0 }
$$

To solve for $\hat { w } _ { 0 }$ we can use the fact that for any support vector, we have $\tilde { y } _ { n } f ( \pmb { x } ; \hat { \pmb { w } } , \hat { w } _ { 0 } ) = 1$ . Multiplying both sides by $\tilde { y } _ { n }$ , and exploiting the fact that $\tilde { y } _ { n } ^ { 2 } = 1$ , we get $\hat { w } _ { 0 } = \tilde { y } _ { n } - \hat { w } ^ { \prime } x _ { n }$ . In practice we get better results by averaging over all the support vectors to get

$$
\hat { w } _ { 0 } = \frac { 1 } { | \mathcal S | } \sum _ { n \in \mathcal S } ( \tilde { y } _ { n } - \hat { w } ^ { \top } \pmb x _ { n } ) = \frac { 1 } { | \mathcal S | } \sum _ { n \in \mathcal S } ( \tilde { y } _ { n } - \sum _ { m \in \mathcal S } \alpha _ { m } \tilde { y } _ { m } \pmb x _ { m } ^ { \top } \pmb x _ { n } )
$$

# 17.3.3 Soft margin classifiers

If the data is not linearly separable, there will be no feasible solution in which $\tilde { y } _ { n } f _ { n } \ge 1$ for all $n$ . We therefore introduce slack variables $\xi _ { n } \geq 0$ and replace the hard constraints that $\tilde { y } _ { n } f _ { n } \ge 0$ with the soft margin constraints that $\tilde { y } _ { n } f _ { n } \geq 1 - \xi _ { n }$ . The new objective becomes

$$
\operatorname* { m i n } _ { w , w _ { 0 } , \xi } \frac { 1 } { 2 } | | w | | ^ { 2 } + C \sum _ { n = 1 } ^ { N _ { \mathcal { D } } } \xi _ { n } \mathrm { ~ s . t . ~ } \xi _ { n } \geq 0 , \tilde { y } _ { n } ( x _ { n } ^ { \mathsf { T } } w + w _ { 0 } ) \geq 1 - \xi _ { n }
$$

where $C \geq 0$ is a hyper parameter controlling how many points we allow to violate the margin constraint. (If $C = \infty$ , we recover the unregularized, hard-margin classifier.)

The corresponding Lagrangian for the soft margin classifier becomes

$$
\boldsymbol { w } , w _ { 0 } , \alpha , \xi , \mu ) = \frac { 1 } { 2 } \boldsymbol { w } ^ { \mathsf { T } } \boldsymbol { w } + C \sum _ { n = 1 } ^ { N } \xi _ { n } - \sum _ { n = 1 } ^ { N } \alpha _ { n } \big ( \widetilde { y } _ { n } ( \boldsymbol { w } ^ { \mathsf { T } } x _ { n } + w _ { 0 } ) - 1 + \xi _ { n } \big ) - \sum _ { n = 1 } ^ { N } \xi _ { n } \big ( \widetilde { y } _ { n } ( \boldsymbol { w } ^ { \mathsf { T } } x _ { n } + w _ { 0 } ) - 1 + \xi _ { n } \big ) .
$$

where $\alpha _ { n } \geq 0$ and $\mu _ { n } \geq 0$ are the Lagrange multipliers. Optimizing out $\mathbf { \boldsymbol { w } }$ , $w _ { 0 }$ and $\xi$ gives the dual form

$$
\mathcal { L } ( \alpha ) = \sum _ { i = 1 } ^ { N } \alpha _ { i } - \frac { 1 } { 2 } \sum _ { i = 1 } ^ { N } \sum _ { j = 1 } ^ { N } \alpha _ { i } \alpha _ { j } \tilde { y } _ { i } \tilde { y } _ { j } \pmb { x } _ { i } ^ { \top } \pmb { x } _ { j }
$$

This is identical to the hard margin case; however, the constraints are different. In particular, the KKT conditions imply

$$
\begin{array} { c } { 0 \leq \alpha _ { n } \leq C } \\ { \displaystyle \sum _ { n = 1 } ^ { N } \alpha _ { n } \tilde { y } _ { n } = 0 } \end{array}
$$

If $\alpha _ { n } = 0$ , the point is ignored. If $0 < \alpha _ { n } < C$ then $\xi _ { n } = 0$ , so the point lies on the margin. If $\alpha _ { n } = C$ , the point can lie inside the margin, and can either be correctly classified if $\xi _ { n } \leq 1$ , or misclassified if $\xi _ { n } > 1$ . See Figure 17.13(b) for an illustration. Hence $\textstyle \sum _ { n } \xi _ { n }$ is an upper bound on the number of misclassified points.

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

As before, the bias term can be computed using

$$
\hat { w } _ { 0 } = \frac { 1 } { | \mathcal { M } | } \sum _ { n \in \mathcal { M } } \big ( \tilde { y } _ { n } - \sum _ { m \in \mathcal { S } } \alpha _ { m } \tilde { y } _ { m } \pmb { x } _ { m } ^ { \top } \pmb { x } _ { n } \big )
$$

where $\mathcal { M }$ is the set of points having $0 < \alpha _ { n } < C$ .

There is an alternative formulation of the soft margin SVM known as the $\nu$ -SVM classifier [Sch+00]. This involves maximizing

$$
\mathcal { L } ( \alpha ) = - \frac { 1 } { 2 } \sum _ { i = 1 } ^ { N } \sum _ { j = 1 } ^ { N } \alpha _ { i } \alpha _ { j } \tilde { y } _ { i } \tilde { y } _ { j } \pmb { x } _ { i } ^ { \top } \pmb { x } _ { j }
$$

subject to the constraints that

$$
\begin{array} { c } { { ) \leq \alpha _ { n } \leq 1 / N } } \\ { { \ \sum _ { n = 1 } ^ { N } \alpha _ { n } \tilde { y } _ { n } = 0 } } \\ { { \ \sum _ { n = 1 } ^ { M } \alpha _ { n } \geq \nu } } \end{array}
$$

This has the advantage that the parameter $\nu$ , which replaces $C$ , can be interpreted as an upper bound on the fraction of margin errors (points for which $\xi _ { n } > 0$ ), as well as a lower bound on the number of support vectors.

# 17.3.4 The kernel trick

So far we have converted the large margin binary classification problem into a dual problem in $N$ unknowns $( \alpha )$ which (in general) takes $O ( N ^ { 3 } )$ time to solve, which can be slow. However, the principal benefit of the dual problem is that we can replace all inner product operations ${ \pmb x } ^ { 1 } { \pmb x } ^ { \prime }$ with a call to a positive definite (Mercer) kernel function, $\kappa ( \pmb { x } , \pmb { x } ^ { \prime } )$ . This is called the kernel trick.

In particular, we can rewrite the prediction function in Equation (17.81) as follows:

$$
f ( { \pmb x } ) = \hat { \pmb w } ^ { \mathsf T } { \pmb x } + \hat { w } _ { 0 } = \sum _ { n \in \mathcal S } \alpha _ { n } \widetilde y _ { n } { \pmb x } _ { n } ^ { \mathsf T } { \pmb x } + \hat { w } _ { 0 } = \sum _ { n \in \mathcal S } \alpha _ { n } \widetilde y _ { n } K ( { \pmb x } _ { n } , { \pmb x } ) + \hat { w } _ { 0 }
$$

We also need to kernelize the bias term. This can be done by kernelizing Equation (17.82) as follows:

$$
\hat { w } _ { 0 } = \frac { 1 } { | S | } \sum _ { i \in S } \left( \tilde { y } _ { i } - ( \sum _ { j \in S } \hat { \alpha } _ { j } \tilde { y } _ { j } x _ { j } ) ^ { \top } x _ { i } \right) = \frac { 1 } { | S | } \sum _ { i \in S } \left( \tilde { y } _ { i } - \sum _ { j \in S } \hat { \alpha } _ { j } \tilde { y } _ { j } K ( x _ { j } , x _ { i } ) \right)
$$

The kernel trick allows us to avoid having to deal with an explicit feature representation of our data, and allows us to easily apply classifiers to structured objects, such as strings and graphs.

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

![](images/6663036ebe04c6c3302a8e6377360edf9b0e5155c2988536fc812672430de985.jpg)  
Figure 17.15: Log-odds vs x for 3 different methods. Adapted from Figure 10 of [Tip01]. Used with kind permission of Mike Tipping.

# 17.3.5 Converting SVM outputs into probabilities

An SVM classifier produces a hard-labeling, ${ \hat { y } } ( \pmb { x } ) = \operatorname { s i g n } ( f ( \pmb { x } ) )$ . However, we often want a measure .ceWine ocaurn tphredn ctoinovne. tOtnhe hoeutrpiust cofaapnprSoVacMh itso taopirnotebrapbrileit $f ( { \pmb x } )$ nags the log-odds ratio, $\log { \frac { p ( y = 1 | \mathbf { x } ) } { p ( y = 0 | \mathbf { x } ) } }$

$$
p ( y = 1 | \mathbf { \boldsymbol { x } } , \pmb { \theta } ) = \sigma ( a f ( \mathbf { \boldsymbol { x } } ) + b )
$$

where $a$ , $b$ can be estimated by maximum likelihood on a separate validation set. (Using the training set to estimate $a$ and $b$ leads to severe overfitting.) This technique was first proposed in [Pla00], and is known as Platt scaling.

However, the resulting probabilities are not particularly well calibrated, since there is nothing in the SVM training procedure that justifies interpreting $f ( { \pmb x } )$ as a log-odds ratio. To illustrate this, consider an example from [Tip01]. Suppose we have 1d data where $p ( x | y = 0 ) = \mathrm { U n i f } ( 0 , 1 )$ and $p ( x | y = 1 ) = \mathrm { U n i f } ( 0 . 5 , 1 . 5 )$ . Since the class-conditional distributions overlap in the [0.5, 1] range, the log-odds of class 1 over class 0 should be zero in this region, and infinite outside this region. We sampled 1000 points from the model, and then fit a probabilistic kernel classifier (an RVM, described in Section 17.4.1) and an SVM with a Gaussian kernel of width 0.1. Both models can perfectly capture the decision boundary, and achieve a generalization error of $2 5 \%$ , which is Bayes optimal in this problem. The probabilistic output from the RVM is a good approximation to the true log-odds, but this is not the case for the SVM, as shown in Figure 17.15.

# 17.3.6 Connection with logistic regression

We have seen that data points that are on the correct side of the decision boundary have $\xi _ { n } = 0$ ; for the others, we have $\xi _ { n } = 1 - \tilde { y } _ { n } f ( { \pmb x } _ { n } )$ . Therefore we can rewrite the objective in Equation (17.83) as follows:

$$
\mathcal { L } ( \pmb { w } ) = \sum _ { n = 1 } ^ { N } \ell _ { \mathrm { h i n g e } } \big ( \tilde { y } _ { n } , f ( \pmb { x } _ { n } ) \big ) \big ) + \lambda | \pmb { w } | | ^ { 2 }
$$

where $\lambda = ( 2 C ) ^ { - 1 }$ and $\ell _ { \mathrm { h i n g e } } ( y , \eta )$ is the hinge loss function defined by

$$
\ell _ { \mathrm { h i n g e } } ( \tilde { y } , \eta ) = \mathrm { m a x } ( 0 , 1 - \tilde { y } \eta )
$$

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

![](images/ac3c3554470ba512f5dc6947b755b974ceaa4b0005440da9d2a48c79567287aa.jpg)  
Figure 17.16: (a) The one-versus-rest approach. The green region is predicted to be both class 1 and class 2. (b) The one-versus-one approach. The label of the green region is ambiguous. Adapted from Figure 4.2 of [Bis06].

As we see from Figure 4.2, this is a convex, piecewise differentiable upper bound to the 0-1 loss, that has the shape of a partially open door hinge.

By contrast, (penalized) logistic regression optimizes

$$
\mathcal { L } ( \pmb { w } ) = \sum _ { n = 1 } ^ { N } \ell _ { l l } ( \tilde { y } _ { n } , f ( \pmb { x } _ { n } ) ) ) + \lambda | \pmb { w } | | ^ { 2 }
$$

where the log loss is given by

$$
\ell _ { l l } ( \tilde { y } , \eta ) = - \log p ( y | \eta ) = \log ( 1 + e ^ { - \tilde { y } \eta } )
$$

This is also plotted in Figure 4.2. We see that it is similar to the hinge loss, but with two important differences. First the hinge loss is piecewise linear, so we cannot use regular gradient methods to optimize it. (We can, however, compute the subgradient at $\tilde { y } \eta = 1$ .) Second, the hinge loss has a region where it is strictly 0; this results in sparse estimates.

We see that both functions are convex upper bounds on the 0-1 loss, which is given by

$$
\ell _ { 0 1 } ( \tilde { y } , \hat { y } ) = \mathbb { I } \left( \tilde { y } \neq \hat { y } \right) = \mathbb { I } \left( \tilde { y } \ \hat { y } < 0 \right)
$$

These upper bounds are easier to optimize and can be viewed as surrogates for the 0-1 loss. See Section 4.3.2 for details.

# 17.3.7 Multi-class classification with SVMs

SVMs are inherently a binary classifier. One way to convert them to a multi-class classification model is to train $C$ binary classifiers, where the data from class $c$ is treated as positive, and the data from all the other classes is treated as negative. We then use the rule ${ \hat { y } } ( \pmb { x } ) = \arg \operatorname* { m a x } _ { c } f _ { c } ( \pmb { x } )$ to

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022 predict the final label, where $\begin{array} { r } { f _ { c } ( \pmb { x } ) = \log \frac { p ( c = 1 | \pmb { x } ) } { p ( c = 0 | \pmb { x } ) } } \end{array}$ is the score given by classifier $c$ . This is known as the one-versus-the-rest approach (also called one-vs-all).

![](images/881ce96ab3a86af7569ad8a4ba63583b1d9138cb93a5be59af7ec68120bbc816.jpg)  
Figure 17.17: SVM classifier with RBF kernel with precision $\gamma$ and regularizer $C$ applied to two moons data. Adapted from Figure 5.9 of [Gér19]. Generated by svm_classifier_2d.ipynb.

Unfortunately, this approach has several problems. First, it can result in regions of input space which are ambiguously labeled. For example, the green region at the top of Figure 17.16(a) is predicted to be both class 2 and class 1. A second problem is that the magnitude of the $f _ { c }$ ’s scores are not calibrated with each other, so it is hard to compare them. Finally, each binary subproblem is likely to suffer from the class imbalance problem (Section 10.3.8.2). For example, suppose we have 10 equally represented classes. When training $f _ { 1 }$ , we will have 10% positive examples and 90% negative examples, which can hurt performance.

Another approach is to use the one-versus-one or OVO approach, also called all pairs, in which we train $C ( C - 1 ) / 2$ classifiers to discriminate all pairs $f _ { c , c ^ { \prime } }$ . We then classify a point into the class which has the highest number of votes. However, this can also result in ambiguities, as shown in Figure 17.16(b). Also, this requires fitting $O ( C ^ { 2 } )$ models.

# 17.3.8 How to choose the regularizer $C$

SVMs require that you specify the kernel function and the parameter $C$ . Typically $C$ is chosen by cross-validation. Note, however, that $C$ interacts quite strongly with the kernel parameters. For example, suppose we are using an RBF kernel with precision $\textstyle \gamma = { \frac { 1 } { 2 \sigma ^ { 2 } } }$ . If $\gamma$ is large, corresponding to narrow kernels, we may need heavy regularization, and hence small $C$ . If is small, a larger value of $\gamma$ $C$ should be used. So we see that $\gamma$ and $C$ are tightly coupled, as illustrated in Figure 17.17.

The authors of libsvm [HCL09] recommend using CV over a 2d grid with values $C \in \{ 2 ^ { - 5 } , 2 ^ { - 3 } , \dots , 2 ^ { 1 5 } \}$

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license and $\gamma \in \{ 2 ^ { - 1 5 } , 2 ^ { - 1 3 } , . . . , 2 ^ { 3 } \}$ . See Figure 17.18 which shows the CV estimate of the 0-1 risk as a function of $C$ and $\gamma$ .

![](images/aa9cc5d2c3ec946fa0e4a45f16d98edbdea99cc1b65ab942fad001093e47795d.jpg)  
Figure 17.18: (a) $A$ cross validation estimate of the 0-1 error for an $S V M$ classifier with RBF kernel with different precisions $\gamma = 1 / ( 2 \sigma ^ { 2 } )$ and different regularizer $\lambda = 1 / C$ , applied to a synthetic data set drawn from a mixture of 2 Gaussians. (b) $A$ slice through this surface for $\gamma = 5$ The red dotted line is the Bayes optimal error, computed using Bayes rule applied to the model used to generate the data. Adapted from Figure 12.6 of [HTF09]. Generated by svmCgammaDemo.ipynb.

To choose $C$ efficiently, one can develop a path following algorithm in the spirit of lars (Section 11.4.4). The basic idea is to start with $C$ small, so that the margin is wide, and hence all points are inside of it and have $\alpha _ { i } = 1$ . By slowly increasing $C$ , a small set of points will move from inside the margin to outside, and their $\alpha _ { i }$ values will change from 1 to $0$ , as they cease to be support vectors. When $C$ is maximal, the margin becomes empty, and no support vectors remain. See [Has+04] for the details.

# 17.3.9 Kernel ridge regression

Recall the equation for ridge regression from Equation (11.55):

$$
\hat { w } _ { \mathrm { m a p } } = ( \mathbf { X } ^ { \mathsf { T } } \mathbf { X } + \lambda \mathbf { I } _ { D } ) ^ { - 1 } \mathbf { X } ^ { \mathsf { T } } \pmb { y } = ( \sum _ { n } \pmb { x } _ { n } \pmb { x } _ { n } ^ { \mathsf { T } } + \lambda \mathbf { I } _ { D } ) ^ { - 1 } ( \sum _ { n } \tilde { y } _ { n } \pmb { x } _ { n } )
$$

Using the matrix inversion lemma (Section 7.3.3), we can rewrite the ridge estimate as follows

$$
{ \pmb w } = { \bf X } ^ { \top } ( { \bf X } { \bf X } ^ { \top } + \lambda { \bf I } _ { N } ) ^ { - 1 } { \pmb y } = \sum _ { n } { \pmb x } _ { n } ( ( \sum _ { n } { \pmb x } _ { n } ^ { \top } { \pmb x } _ { n } + \lambda { \bf I } _ { N } ) ^ { - 1 } { \pmb y } ) _ { n }
$$

Let us define the following dual variables:

$$
\pmb { \alpha } \triangleq ( \mathbf { X } \mathbf { X } ^ { \mathsf { T } } + \lambda \mathbf { I } _ { N } ) ^ { - 1 } \pmb { y } = ( \sum _ { n } \pmb { x } _ { n } ^ { \mathsf { T } } \pmb { x } _ { n } + \lambda \mathbf { I } _ { N } ) ^ { - 1 } \pmb { y }
$$

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

Then we can rewrite the primal variables as follows

$$
{ \pmb w } = { \bf X } ^ { \top } { \pmb \alpha } = \sum _ { n = 1 } ^ { N _ { D } } \alpha _ { n } { \pmb x } _ { n }
$$

This tells us that the solution vector is just a linear sum of the $N _ { \mathcal { D } }$ training vectors. When we plug this in at test time to compute the predictive mean, we get

$$
f ( \pmb { x } ; \pmb { w } ) = \pmb { w } ^ { \top } \pmb { x } = \sum _ { n = 1 } ^ { N } \alpha _ { n } \pmb { x } _ { n } ^ { \top } \pmb { x }
$$

We can then use the kernel trick to rewrite this as

$$
f ( { \pmb x } ; { \pmb w } ) = \sum _ { n = 1 } ^ { N } \alpha _ { n } { \mathcal K } ( { \pmb x } _ { n } , { \pmb x } )
$$

where

$$
{ \pmb { \alpha } } = ( \mathbf { K } + \lambda \mathbf { I } _ { N } ) ^ { - 1 } { \pmb { y } }
$$

In other words,

$$
f ( \pmb { x } ; \pmb { w } ) = \pmb { k } ^ { \top } ( \mathbf { K } + \lambda \mathbf { I } _ { N } ) ^ { - 1 } \pmb { y }
$$

where $\pmb { k } = [ \mathcal { K } ( \pmb { x } , \pmb { x } _ { 1 } ) , \dots , \mathcal { K } ( \pmb { x } , \pmb { x } _ { N } ) ]$ . This is called kernel ridge regression.

The trouble with the above approach is that the solution vector $\alpha$ is not sparse, so predictions at test time will take $O ( N )$ time. We discuss a solution to this in Section 17.3.10.

# 17.3.10 SVMs for regression

Consider the following $\ell _ { 2 }$ -regularized ERM problem:

$$
J ( \pmb { w } , \lambda ) = \lambda | | \pmb { w } | | ^ { 2 } + \sum _ { n = 1 } ^ { N _ { D } } \ell ( \tilde { y } _ { n } , \hat { y } _ { n } )
$$

where $\hat { y } _ { n } = w ^ { 1 } x _ { n } + w _ { 0 }$ . If we use the quadratic loss, $\ell ( y , \hat { y } ) = ( y - \hat { y } ) ^ { 2 }$ , where $y , \hat { y } \in \mathbb R$ , we recover ridge regression (Section 11.3). If we then apply the kernel trick, we recover kernel ridge regression (Section 17.3.9).

The problem with kernel ridge regression is that the solution depends on all $N$ training points, which makes it computationally intractable. However, by changing the loss function, we can make the optimal set of basis function coefficients, $\alpha ^ { * }$ , be sparse, as we show below.

In particular, consider the following variant of the Huber loss function (Section 5.1.5.3) called the epsilon insensitive loss function:

$$
L _ { \epsilon } ( y , \hat { y } ) \triangleq \left\{ \begin{array} { c l } { 0 } & { \mathrm { i f ~ } | y - \hat { y } | < \epsilon } \\ { | y - \hat { y } | - \epsilon } & { \mathrm { o t h e r w i s e } } \end{array} \right.
$$

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

![](images/eee79a3034c0465fd96abd945d4db6c988410fa4b34a417a68bd3f87c34cf453.jpg)  
Figure 17.19: (a) Illustration of $\ell _ { 2 }$ , Huber and $\epsilon$ -insensitive loss functions, where $\epsilon = 1 . 5$ . Generated by huberLossPlot.ipynb. (b) Illustration of the $\epsilon$ -tube used in SVM regression. Points above the tube have $\xi _ { i } ^ { + } > 0$ and $\xi _ { i } ^ { - } = 0$ . Points below the tube have $\xi _ { i } ^ { + } = 0$ and $\xi _ { i } ^ { - } > 0$ . Points inside the tube have $\xi _ { i } ^ { + } = \xi _ { i } ^ { - } = 0$ . Adapted from Figure 7.7 of [Bis06].

This means that any point lying inside an $\epsilon$ -tube around the prediction is not penalized, as in Figure 17.19.

The corresponding objective function is usually written in the following form

$$
J = \frac { 1 } { 2 } | | \pmb { w } | | ^ { 2 } + C \sum _ { n = 1 } ^ { N _ { D } } L _ { \epsilon } ( \tilde { y } _ { n } , \hat { y } _ { n } )
$$

where $\hat { y } _ { n } = f ( \pmb { x } _ { n } ) = \pmb { w } ^ { 1 } \pmb { x } _ { n } + w _ { 0 }$ and $C = 1 / \lambda$ is a regularization constant. This objective is convex and unconstrained, but not differentiable, because of the absolute value function in the loss term. As in Section 11.4.9, where we discussed the lasso problem, there are several possible algorithms we could use. One popular approach is to formulate the problem as a constrained optimization problem. In particular, we introduce slack variables to represent the degree to which each point lies outside the tube:

$$
\begin{array} { c } { { \tilde { y } _ { n } \leq f ( { \pmb x } _ { n } ) + \epsilon + \xi _ { n } ^ { + } } } \\ { { \tilde { y } _ { n } \geq f ( { \pmb x } _ { n } ) - \epsilon - \xi _ { n } ^ { - } } } \end{array}
$$

Given this, we can rewrite the objective as follows:

$$
J = \frac { 1 } { 2 } | | \pmb { w } | | ^ { 2 } + C \sum _ { n = 1 } ^ { N _ { D } } ( \xi _ { n } ^ { + } + \xi _ { n } ^ { - } )
$$

This is a quadratic function of $\mathbf { \boldsymbol { w } }$ , and must be minimized subject to the linear constraints in Equations 17.112-17.113, as well as the positivity constraints $\xi _ { n } ^ { + } \ge 0$ and $\xi _ { n } ^ { - } \geq 0$ . This is a standard quadratic program in $2 N + D + 1$ variables.

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

By forming the Lagrangian and optimizing, as we did above, one can show that the optimal solution has the following form

$$
\hat { \pmb w } = \sum _ { n } \alpha _ { n } { \pmb x } _ { n }
$$

where $\alpha _ { n } \geq 0$ are the dual variables. (See e.g., [SS02] for details.) Fortunately, the $\alpha$ vector is sparse, meaning that many of its entries are equal to 0. This is because the loss doesn’t care about errors which are smaller than $\epsilon$ . The degree of sparsity is controlled by $C$ and $\epsilon$ .

The ${ \boldsymbol { \mathbf { \mathit { x } } } } _ { n }$ for which $\alpha _ { n } > 0$ are called the support vectors; these are points for which the errors lie on or outside the $\epsilon$ tube. These are the only training examples we need to keep for prediction at test time, since

$$
f ( \pmb { x } ) = \hat { w } _ { 0 } + \hat { \pmb { w } } ^ { \top } \pmb { x } = \hat { w } _ { 0 } + \sum _ { n : \alpha _ { n } > 0 } \alpha _ { n } \pmb { x } _ { n } ^ { \top } \pmb { x }
$$

Finally, we can use the kernel trick to get

$$
f ( \pmb { x } ) = \hat { w } _ { 0 } + \sum _ { n : \alpha _ { n } > 0 } \alpha _ { n } \mathcal { K } ( \pmb { x } _ { n } , \pmb { x } )
$$

This overall technique is called support vector machine regression or SVM regression for short, and was first proposed in [VGS97].

In Figure 17.20, we give an example where we use an RBF kernel with $\gamma = 1$ . When $C$ is small, the model is heavily regularized; when $C$ is large, the model is less regularized and can fit the data better. We also see that when $\epsilon$ is small, the tube is smaller, so there are more support vectors.

# 17.4 Sparse vector machines

GPs are very flexible models, but incur an $O ( N )$ time cost at prediction time, which can be prohibitive. SVMs solve that problem by estimating a sparse weight vector. However, SVMs do not give calibrated probabilistic outputs.

We can get the best of both worlds by using parametric models, where the feature vector is defined using basis functions centered on each of the training points, as follows:

$$
\pmb { \phi } ( \pmb { x } ) = [ \mathcal { K } ( \pmb { x } , \pmb { x } _ { 1 } ) , \dots , \mathcal { K } ( \pmb { x } , \pmb { x } _ { N } ) ]
$$

where $\mathcal { K }$ is any similarity kernel, not necessarily a Mercer kernel. Equation (17.118) maps $\mathbf { \boldsymbol { x } } \in \mathcal { X }$ into $\pmb { \phi } ( \pmb { x } ) \in \mathbb { R } ^ { N }$ . We can plug this new feature vector into any discriminative model, such as logistic regression. Since we have $D = N$ parameters, we need to use some kind of regularization, to prevent overfitting. If we fit such a model using $\ell _ { 2 }$ regularization (which we will call L2VM, for $\ell _ { 2 }$ -vector machine), the result often has good predictive performance, but the weight vector $\mathbf { \boldsymbol { w } }$ will be dense, and will depend on all $N$ training points. A natural solution is to impose a sparsity-promoting prior on $\mathbf { \boldsymbol { w } }$ , so that not all the exemplars need to be kept. We call such methods sparse vector machines.

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

![](images/fcab220a4acae8c478169a43f8a7d72bf0496a0e8f082dbbc0cb133afc771c91.jpg)  
Figure 17.20: Illustration of support vector regression. Adapted from Figure 5.11 of [Gér19]. Generated by svm_regression_1d.ipynb.

# 17.4.1 Relevance vector machines (RVMs)

The simplest way to ensure $\mathbf { \boldsymbol { w } }$ is sparse is to use $\ell _ { 1 }$ regularization, as in Section 11.4. We call this L1VM or Laplace vector machine, since this approach is equivalent to using MAP estimation with a Laplace prior for $\mathbf { \boldsymbol { w } }$ .

However, sometimes $\ell _ { 1 }$ regularization does not result in a sufficient level of sparsity for a given level of accuracy. An alternative approach is based on the use of ARD or automatic relevancy determination, which uses type II maximum likelihood (aka empirical Bayes) to estimate a sparse weight vector [Mac95; Nea96]. If we apply this technique to a feature vector defined in terms of kernels, as in Equation (17.118), we get a method called the relevance vector machine or RVM [Tip01; TF03].

# 17.4.2 Comparison of sparse and dense kernel methods

In Figure 17.21, we compare L2VM, L1VM, RVM and an SVM using an RBF kernel on a binary classification problem in 2d. We use cross validation to pick $C = 1 / \lambda$ for the SVM (see Section 17.3.8),

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022 and then use the same value of the regularizer for L2VM and L1VM. We see that all the methods give similar predictive performance. However, we see that the RVM is the sparsest model, so it will be the fastest at run time.

![](images/1ab85ed4d5741c73361cc56e6e1abbb0bc97b8c3549fe5f85fca56450cccb5dc.jpg)  
Figure 17.21: Example of non-linear binary classification using an RBF kernel with bandwidth $\sigma = 0 . 3$ . (a) L2VM. (b) L1VM. (c) RVM. (d) SVM. Black circles denote the support vectors. Generated by kernelBinaryClassifDemo.ipynb.

In Figure 17.22, we compare L2VM, L1VM, RVM and an SVM using an RBF kernel on a 1d regression problem. Again, we see that predictions are quite similar, but RVM is the sparsest, then L1VM, then SVM. This is further illustrated in Figure 17.23.

Beyond these small empirical examples, we provide a more general summary of the differen methods in Table 17.1. The columns of this table have the following meaning:

• Optimize w: a key question is whether the objective $\mathcal { L } ( \pmb { w } ) = - \log p ( \mathcal { D } | \pmb { w } ) - \log p ( \pmb { w } )$ is convex or not. L2VM, L1VM and SVMs have convex objectives. RVMs do not. GPs are Bayesian methods that integrate out the weights $\mathbf { \boldsymbol { w } }$ .

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

![](images/0c9214b80cc2447d5ab8bc2ba404db492aaf54e3a4f30945f2f1d66d7601263c.jpg)  
Figure 17.22: Model fits for kernel based regression on the noisy sinc function using an RBF kernel with bandwidth $\sigma = 0 . 3$ . (a) L2VM with $\lambda = 0 . 5$ . (b) L1VM with $\lambda = 0 . 5$ . (c) RVM. (d) SVM regression with $C = 1 / \lambda$ . chosen by cross validation. Red circles denote the retained training exemplars. Generated by rvm_regression_1d.ipynb.

• Optimize kernel: all the methods require that we “tune” the kernel parameters, such as the bandwidth of the RBF kernel, as well as the level of regularization. For methods based on Gaussian priors, including L2VM, RVMs and GPs, we can use efficient gradient based optimizers to maximize the marginal likelihood. For SVMs and L1VMs, we must use cross validation, which is slower (see Section 17.3.8). Sparse: L1VM, RVMs and SVMs are sparse kernel methods, in that they only use a subset of the training examples. GPs and L2VM are not sparse: they use all the training examples. The principle advantage of sparsity is that prediction at test time is usually faster. However, this usually results in overconfidence in the predictions.   
• Probabilistic: All the methods except for SVMs produce probabilistic output of the form $p ( \boldsymbol { y } | \boldsymbol { x } )$ . SVMs produce a “confidence” value that can be converted to a probability, but such probabilities are usually very poorly calibrated (see Section 17.3.5).   
• Multiclass: All the methods except for SVMs naturally work in the multiclass setting, by using a categorical distribution instead of a Bernoulli. The SVM can be made into a multiclass classifier, but there are various difficulties with this approach, as discussed in Section 17.3.7.

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022 • Mercer kernel: SVMs and GPs require that the kernel is positive definite; the other techniques do not, since the kernel function in Equation (17.118) can be an arbitrary function of two inputs.

![](images/9acbc9cd33147cf71a804f49c78a067a32742e415f982f391331c5857f47f5f8.jpg)  
Figure 17.23: Estimated coefficients for the models in Figure 17.22. Generated by rvm_regression_1d.ipynb.

Table 17.1: Comparison of various kernel based classifiers. EB = empirical Bayes, CV = cross validation. See text for details.   

<html><body><table><tr><td>Method</td><td>Opt. w</td><td>Opt.kernel</td><td>Sparse</td><td>Prob.</td><td>Multiclass</td><td>Non-Mercer</td><td>Section</td></tr><tr><td>SVM</td><td>Convex</td><td>CV</td><td>Yes</td><td>No</td><td>Indirectly</td><td>No</td><td>17.3</td></tr><tr><td>L2VM</td><td>Convex</td><td>EB</td><td>No</td><td>Yes</td><td>Yes</td><td>Yes</td><td>17.4.1</td></tr><tr><td>L1VM</td><td>Convex</td><td>CV</td><td>Yes</td><td>Yes</td><td>Yes</td><td>Yes</td><td>17.4.1</td></tr><tr><td>RVM</td><td>Not convex</td><td>EB</td><td>Yes</td><td>Yes</td><td>Yes</td><td>Yes</td><td>17.4.1</td></tr><tr><td>GP</td><td>N/A</td><td>EB</td><td>No</td><td>Yes</td><td>Yes</td><td>No</td><td>17.2.7</td></tr></table></body></html>

# 17.5 Exercises

Exercise 17.1 [Fitting an SVM classifier by hand $^ *$ ]

(Source: Jaakkola.) Consider a dataset with 2 points in 1d: ( $x _ { 1 } = 0 , y _ { 1 } = - 1 .$ ) and $x _ { 2 } = { \sqrt { 2 } } , y _ { 2 } = 1$ ). Consider mapping each point to 3d using the feature vector $\phi ( x ) = [ 1 , \sqrt { 2 } x , x ^ { 2 } ] ^ { T }$ . (This is equivalent to using

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

a second order polynomial kernel.) The max margin classifier has the form

$$
\begin{array} { c } { \operatorname* { m i n } \left| \left| \pmb { w } \right| \right| ^ { 2 } \ \mathrm { s . t . } } \\ { y _ { 1 } ( \pmb { w } ^ { T } \phi ( \pmb { x } _ { 1 } ) + w _ { 0 } ) \geq 1 } \\ { y _ { 2 } ( \pmb { w } ^ { T } \phi ( \pmb { x } _ { 2 } ) + w _ { 0 } ) \geq 1 } \end{array}
$$

a. Write down a vector that is parallel to the optimal vector $\mathbf { \Delta } _ { \mathbf { w } }$ . Hint: recall from Figure 7.8 (12Apr10 version) that $\mathbf { \Delta } _ { \mathbf { w } }$ is perpendicular to the decision boundary between the two points in the 3d feature space.   
b. What is the value of the margin that is achieved by this $\mathbf { \boldsymbol { w } }$ ? Hint: recall that the margin is the distance from each support vector to the decision boundary. Hint 2: think about the geometry of 2 points in space, with a line separating one from the other.   
c. Solve for $\mathbf { \boldsymbol { w } }$ , using the fact that the margin is equal to $1 / | | w | |$ .   
d. Solve for $w _ { 0 }$ using your value for $\mathbf { \Delta } _ { \mathbf { w } }$ and Equations 17.119 to 17.121. Hint: the points will be on the decision boundary, so the inequalities will be tight.   
e. Write down the form of the discriminant function $f ( x ) = w _ { 0 } + \pmb { w } ^ { T } \phi ( x )$ as an explicit function of $x$ .

# 18 Trees, Forests, Bagging, and Boosting

# 18.1 Classification and regression trees (CART)

Classification and regression trees or CART models [BFO84], also called decision trees [Qui86; Qui93], are defined by recursively partitioning the input space, and defining a local model in each resulting region of input space. The overall model can be represented by a tree, with one leaf per region, as we explain below.

# 18.1.1 Model definition

We start by considering regression trees, where all inputs are real-valued. The tree consists of a set of nested decision rules. At each node $i$ , the feature dimension $d _ { i }$ of the input vector $_ { x }$ is compared to a threshold value $t _ { i }$ , and the input is then passed down to the left or right branch, depending on whether it is above or below threshold. At the leaves of the tree, the model specifies the predicted output for any input that falls into that part of the input space.

For example, consider the regression tree in Figure 18.1(a). The first node asks if $x _ { 1 }$ is less than some threshold $t _ { 1 }$ . If yes, we then ask if $x _ { 2 }$ is less than some other threshold $t _ { 2 }$ . If yes, we enter the bottom left leaf node. This corresponds to the region of space defined by

$$
R _ { 1 } = \{ { \pmb x } : x _ { 1 } \leq t _ { 1 } , x _ { 2 } \leq t _ { 2 } \}
$$

We can associate this region with the predicted output computing using other branches of the tree define different regions in terms of axis parallel splits. The overall result is that we partition the 2d input space into 5 regions, as shown in Figure 18.1(b).1 We can now associate a mean response with each of these regions, resulting in the piecewise constant surface shown in Figure 18.1(b). For example, the output for region 1 can be estimated using

$$
w _ { 1 } = \frac { \sum _ { n = 1 } ^ { N } y _ { n } \mathbb { I } \left( \pmb { x } _ { n } \in R _ { 1 } \right) } { \sum _ { n = 1 } ^ { N } \mathbb { I } \left( \pmb { x } _ { n } \in R _ { 1 } \right) }
$$

Formally, a regression tree can be defined by

$$
f ( \pmb { x } ; \pmb { \theta } ) = \sum _ { j = 1 } ^ { J } w _ { j } \mathbb { I } \left( \pmb { x } \in R _ { j } \right)
$$

![](images/f7594587240b93345ca6293509035cfa260d63d964368c87c9499cde26384e23.jpg)  
Figure 18.1: (a) A regression tree on two inputs. (b) Corresponding piecewise constant surface. Adapted from Figure 9.2 of [HTF09]. Generated by regtreeSurfaceDemo.ipynb.

![](images/d2ffd1dd0f4246d0b761ee2a84fe16e35f75a5048ee282de7ac99c78298263ff.jpg)  
Figure 18.2: (a) $A$ set of shapes with corresponding binary labels. The features are: color (values “blue”, “red”, “other”), shape (values “ellipse”, “other”), and size (real-valued). (b) A hypothetical classification tree fitted to this data. A leaf labeled as $( n _ { 1 } , n _ { 0 } )$ means that there are $n _ { 1 }$ positive examples that fall into this partition, and $n _ { 0 }$ negative examples.

where $R _ { j }$ is the region specified by the $j$ ’th leaf node, $w _ { j }$ is the predicted output for that node, and $\pmb \theta = \{ ( R _ { j } , w _ { j } ) : j = 1 : J \}$ , where $J$ is the number of nodes. The regions themselves are defined by the feature dimensions that are used in each split, and the corresponding thresholds, on the path from the root to the leaf. For example, in Figure 18.1(a), we have $R _ { 1 } = [ ( d _ { 1 } \leq t _ { 1 } ) , ( d _ { 2 } \leq t _ { 2 } ) ]$ , $R _ { 2 } = [ ( d _ { 1 } \leq t _ { 1 } ) , ( d _ { 2 } > t _ { 2 } ) , ( d _ { 3 } \leq t _ { 3 } ) ]$ , etc. (For categorical inputs, we can define the splits based on comparing feature $d _ { i }$ to each of the possible values for that feature, rather than comparing to a numeric threshold.) We discuss how to learn these regions in Section 18.1.2.

For classification problems, the leaves contain a distribution over the class labels, rather than just the mean response. See Figure 18.2 for an example of a classification tree.

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

# 18.1.2 Model fitting

To fit the model, we need to minimize the following loss:

$$
\mathcal { L } ( \pmb { \theta } ) = \sum _ { n = 1 } ^ { N } \ell ( y _ { n } , f ( \pmb { x } _ { n } ; \pmb { \theta } ) ) = \sum _ { j = 1 } ^ { J } \sum _ { \pmb { x } _ { n } \in \pmb { R } _ { j } } \ell ( y _ { n } , w _ { j } )
$$

Unfortunately, this is not differentiable, because of the need to learn the discrete tree structure. Indeed, finding the optimal partitioning of the data is NP-complete [HR76]. The standard practice is to use a greedy procedure, in which we iteratively grow the tree one node at a time. This approach is used by CART [BFO84], C4.5 [Qui93], and ID3 [Qui86], which are three popular implementations of the method.

The idea is as follows. Suppose we are at node $i$ ; let $\mathcal { D } _ { i } = \{ ( \boldsymbol { x } _ { n } , y _ { n } ) \in N _ { i } \}$ be the set of examples that reach this node. We will consider how to split this node into a left branch and right branch so as to minimize the error in each child subtree.

If the $j$ ’the feature is a real-valued scalar, we can partition the data at node $i$ by comparing to a threshold $t$ . The set of possible thresholds $\tau _ { j }$ for feature $j$ can be obtained by sorting the unique values of $\{ x _ { n j } \}$ . For example, if feature 1 has the values $\{ 4 . 5 , - 1 2 , 7 2 , - 1 2 \}$ , then we set $\mathcal { T } _ { 1 } = \{ - 1 2 , 4 . 5 , 7 2 \}$ . For each possible threshold, we define the left and right splits, $\mathcal { D } _ { i } ^ { L } ( j , t ) = \{ ( x _ { n } , y _ { n } ) \in N _ { i } : x _ { n , j } \leq t \}$ and $\mathcal { D } _ { i } ^ { R } ( j , t ) = \{ ( x _ { n } , y _ { n } ) \in N _ { i } : x _ { n , j } > t \}$ .

If the $j$ ’th feature is categorical, with $K _ { j }$ possible values, then we check if the feature is equal to each of those values or not. This defines a set of $K _ { j }$ possible binary splits: $\mathcal { D } _ { i } ^ { L } ( j , t ) = \{ ( x _ { n } , y _ { n } ) \in N _ { i } :$ $x _ { n , j } = t \}$ and $\mathcal { D } _ { i } ^ { R } ( j , t ) = \{ ( { \pmb x } _ { n } , y _ { n } ) \in N _ { i } : x _ { n , j } \neq t \}$ .) (Alternatively, we could allow for a multi-way split, as in Figure 18.2(b). However, this may cause data fragmentation, in which too little data might “fall” into each subtree, resulting in overfitting. Therefore it is more common to use binary splits.)

Once we have computed $\mathcal { D } _ { i } ^ { L } ( j , t )$ and $\mathcal { D } _ { i } ^ { R } ( j , t )$ for each $j$ and $t$ at node $i$ , we choose the best feature $j _ { i }$ to split on, and the best value for that feature, $t _ { i }$ , as follows:

$$
( j _ { i } , t _ { i } ) = \arg \operatorname* { m i n } _ { j \in \{ 1 , \dots , D \} } \operatorname* { m i n } _ { t \in \mathcal { T } _ { j } } \frac { | \mathcal { D } _ { i } ^ { L } ( j , t ) | } { | \mathcal { D } _ { i } | } c ( \mathcal { D } _ { i } ^ { L } ( j , t ) ) + \frac { | \mathcal { D } _ { i } ^ { R } ( j , t ) | } { | \mathcal { D } _ { i } | } c ( \mathcal { D } _ { i } ^ { R } ( j , t ) )
$$

We now discuss the cost function $c ( \mathcal { D } _ { i } )$ which is used to evaluate the cost of node $i$ . For regression, we can use the mean squared error

$$
\mathrm { c o s t } ( \mathcal { D } _ { i } ) = \frac { 1 } { | \mathcal { D } | } \sum _ { n \in \mathcal { D } _ { i } } ( y _ { n } - \overline { { y } } ) ^ { 2 }
$$

where $\begin{array} { r } { \overline { { y } } = \frac { 1 } { \left| { \mathcal { D } } \right| } \sum _ { n \in { \mathcal { D } } _ { i } } y _ { n } } \end{array}$ is the mean of the response variable for examples reaching node $i$ . For classification, we first compute the empirical distribution over class labels for this node:

$$
\hat { \pi } _ { i c } = \frac { 1 } { | D _ { i } | } \sum _ { n \in \mathcal { D } _ { i } } \mathbb { I } \left( y _ { n } = c \right)
$$

Given this, we can then compute the Gini index

$$
G _ { i } = \sum _ { c = 1 } ^ { C } \hat { \pi } _ { i c } ( 1 - \hat { \pi } _ { i c } ) = \sum _ { c } \hat { \pi } _ { i c } - \sum _ { c } \hat { \pi } _ { i c } ^ { 2 } = 1 - \sum _ { c } \hat { \pi } _ { i c } ^ { 2 }
$$

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

This is the expected error rate. To see this, note that $\hat { \pi } _ { i c }$ is the probability a random entry in the leaf belongs to class $c$ , and $1 - \hat { \pi } _ { i c }$ is the probability it would be misclassified.

Alternatively we can define cost as the entropy or deviance of the node:

$$
H _ { i } = \mathbb { H } ( \hat { \pmb { \pi } } _ { i } ) = - \sum _ { c = 1 } ^ { C } \hat { \pi } _ { i c } \log \hat { \pmb { \pi } } _ { i c }
$$

A node that is pure (i.e., only has examples of one class) will have 0 entropy.

Given one of the above cost functions, we can use Equation (18.5) to pick the best feature, and best threshold at each node. We then partition the data, and call the fitting algorithm recursively on each subset of the data.

# 18.1.3 Regularization

If we let the tree become deep enough, it can achieve 0 error on the training set (assuming no label noise), by partioning the input space into sufficiently small regions where the output is constant. However, this will typically result in overfitting. To prevent this, there are two main approaches. The first is to stop the tree growing process according to some heuristic, such as having too few examples at a node, or reaching a maximum depth. The second approach is to grow the tree to its maximum depth, where no more splits are possible, and then to prune it back, by merging split subtrees back into their parent (see e.g., [BA97b]). This can partially overcome the greedy nature of top-down tree growing. (For example, consider applying the top-down approach to the xor data in Figure 13.1: the algorithm would never make any splits, since each feature on its own has no predictive power.) However, forward growing and backward pruning is slower than the greedy top-down approach.

# 18.1.4 Handling missing input features

In general, it is hard for discriminative models, such as neural networks, to handle missing input features, as we discussed in Section 1.5.5. However, for trees, there are some simple heuristics that can work well.

The standard heuristic for handling missing inputs in decision trees is to look for a series of “backup” variables, which can induce a similar partition to the chosen variable at any given split; these can be used in case the chosen variable is unobserved at test time. These are called surrogate splits. This method finds highly correlated features, and can be thought of as learning a local joint model of the input. This has the advantage over a generative model of not modeling the entire joint distribution of inputs, but it has the disadvantage of being entirely ad hoc. A simpler approach, applicable to categorical variables, is to code “missing” as a new value, and then to treat the data as fully observed.

# 18.1.5 Pros and cons

Tree models are popular for several reasons:

• They are easy to interpret.   
• They can easily handle mixed discrete and continuous inputs.

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022 • They are insensitive to monotone transformations of the inputs (because the split points are based on ranking the data points), so there is no need to standardize the data.

![](images/75342f554c171f750a96ece40c24feb5e4240451eff6df995963bdb5a1f800c6.jpg)  
Figure 18.3: (a) A decision tree of depth 2 fit to the iris data, using just the petal length and petal width features. Leaf nodes are color coded according to the majority class. The number of training samples that pass from the root to each node is shown inside each box, as well as how many of these values fall into each class. This can be normalized to get a distribution over class labels for each node. (b) Decision surface induced by (a). (c) Fit to data where we omit a single data point (shown by red star). (d) Ensemble of the two models in (b) and (c). Generated by dtree_sensitivity.ipynb.

• They perform automatic variable selection.

• They are relatively robust to outliers.

• They are fast to fit, and scale well to large data sets.

• They can handle missing input features.

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

However, tree models also have some disadvantages. The primary one is that they do not predict very accurately compared to other kinds of model. This is in part due to the greedy nature of the tree construction algorithm.

A related problem is that trees are unstable: small changes to the input data can have large effects on the structure of the tree, due to the hierarchical nature of the tree-growing process, causing errors at the top to affect the rest of the tree. For example, consider the tree in Figure 18.3b. Omitting even a single data point from the training set can result in a dramatically different decision surface, as shown in Figure 18.3c, due to the use of axis parallel splits. (Omitting features can also cause instability.) In Section 18.3 and Section 18.4, we will turn this instability into a virtue.

# 18.2 Ensemble learning

In Section 18.1, we saw that decision trees can be quite unstable, in the sense that their predictions might vary a lot if the training data is perturbed. In other words, decision trees are a high variance estimator. A simple way to reduce variance is to average multiple models. This is called ensemble learning. The result model has the form

$$
f ( y | \mathbf { x } ) = \frac { 1 } { | \mathcal { M } | } \sum _ { m \in \mathcal { M } } f _ { m } ( y | \mathbf { x } )
$$

where $f _ { m }$ is the $m$ ’th base model. The ensemble will have similar bias to the base models, but lower variance, generally resulting in improved overall performance (see Section 4.7.6.3 for details on the bias-variance tradeoff).

Averaging is a sensible way to combine predictions from regression models. For classifiers, it can sometimes be better to take a majority vote of the outputs. (This is sometimes called a committee method.) To see why this can help, suppose each base model is a binary classifier with an accuracy of $\theta$ , and suppose class 1 is the correct class. Let $Y _ { m } \in \{ 0 , 1 \}$ be the prediction for the $m$ ’th model, and let $\begin{array} { r } { S = \sum _ { m = 1 } ^ { M } Y _ { m } } \end{array}$ be the number of votes for c ass 1. We define the final predictor to be the majority vote, i.e., class $^ { 1 }$ if $S > M / 2$ and class 0 otherwise. The probability that the ensemble will pick class 1 is

$$
p = \operatorname* { P r } ( S > M / 2 ) = 1 - B ( M / 2 , M , \theta )
$$

where $B ( x , M , \theta )$ is the cdf of the binomial distribution with parameters $M$ and $\theta$ evaluated at $x$ .   
For $\theta = 0 . 5 1$ and $M = 1 0 0 0$ , we get $p = 0 . 7 3$ and with $M = 1 0 , 0 0 0$ we get $p = 0 . 9 7$ .

The performance of the voting approach is dramatically improved, because we assumed each predictor made independent errors. In practice, their mistakes may be correlated, but as long as we ensemble sufficiently diverse models, we can still come out ahead.

# 18.2.1 Stacking

An alternative to using an unweighted average or majority vote is to learn how to combine the base models, by using

$$
f ( y | \mathbf { x } ) = \sum _ { m \in \mathcal { M } } w _ { m } f _ { m } ( y | \mathbf { x } )
$$

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

This is called stacking, which stands for “stacked generalization” [Wol92]. Note that the combination weights used by stacking need to be trained on a separate dataset, otherwise they would put all their mass on the best performing base model.

# 18.2.2 Ensembling is not Bayes model averaging

It is worth noting that an ensemble of models is not the same as using Bayes model averaging over models (Section 4.6), as pointed out in [Min00]. An ensemble considers a larger hypothesis class of the form

$$
p ( y | x , w , \pmb \theta ) = \sum _ { m \in \mathcal { M } } w _ { m } p ( y | \pmb x , \pmb \theta _ { m } )
$$

whereas BMA uses

$$
p ( y | \mathbf { x } , \mathcal { D } ) = \sum _ { m \in \mathcal { M } } p ( m | \mathcal { D } ) p ( y | \mathbf { x } , m , \mathcal { D } )
$$

The key difference is that in the case of BMA, the weights $p ( m | \mathcal { D } )$ sum to one, and in the limit of infinite data, only a single model will be chosen (namely the MAP model). By contrast, the ensemble weights $w _ { m }$ are arbitrary, and don’t collapse in this way to a single model.

# 18.3 Bagging

In this section, we discuss bagging [Bre96], which stands for “bootstrap aggregating”. This is a simple form of ensemble learning in which we fit $M$ different base models to different randomly sampled versions of the data; this encourages the different models to make diverse predictions. The datasets are sampled with replacement (a technique known as bootstrap sampling, Section 4.7.3), so a given example may appear multiple times, until we have a total of $N$ examples per model (where $N$ is the number of original data points).

The disadvantage of bootstrap is that each base model only sees, on average, 63% of the unique input examples. To see why, note that the chance that a single item will not be selected from a set of size $N$ in any of $N$ draws is $( 1 - 1 / N ) ^ { N }$ . In the limit of large $N$ , this becomes $e ^ { - 1 } \approx 0 . 3 7$ , which means only $1 - 0 . 3 7 = 0 . 6 3$ of the data points will be selected.

The $3 7 \%$ of the training instances that are not used by a given base model are called out-of-bag instances (oob). We can use the predicted performance of the base model on these oob instances as an estimate of test set performance. This provides a useful alternative to cross validation.

The main advantage of bootstrap is that it prevents the ensemble from relying too much on any individual training example, which enhances robustness and generalization [Gra04]. For example, comparing Figure 18.3b and Figure 18.3c, we see that omitting a single example from the training set can have a large impact on the decision tree that we learn (even though the tree growing algorithm is otherwise deterministic). By averaging the predictions from both of these models, we get the more reasonable prediction model in Figure 18.3d. This advantage generally increases with the size of the ensemble, as shown in Figure 18.4. (Of course, larger ensembles take more memory and more time.)

Bagging does not always improve performance. In particular, it relies on the base models being unstable estimators, so that omitting some of the data significantly changes the resulting model fit.

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

![](images/05cc101822496eed438207aa2cf92cc40dd86b3d5b9c816bb26faffef0e85be6.jpg)  
Figure 18.4: (a) A single decision tree. (b-c) Bagging ensemble of 10 and 50 trees. (d) Random forest of 50 trees. Adapted from Figure 7.5 of [Gér19]. Generated by bagging_trees.ipynb and rf_demo_2d.ipynb.

This is the case for decision trees, but not for other models, such as nearest neighbor classifiers. For neural networks, the story is more mixed. They can be unstable wrt their training set. On the other hand, deep networks will underperform if they only see 63% of the data, so bagged DNNs do not usually work well [NTL20].

# 18.4 Random forests

Bagging relies on the assumption that re-running the same learning algorithm on different subsets of the data will result in sufficiently diverse base models. The technique known as random forests [Bre01] tries to decorrelate the base learners even further by learning trees based on a randomly chosen subset of input variables (at each node of the tree), as well as a randomly chosen subset of data cases. It does this by modifying Equation (18.5) so the the feature split dimension $j$ is optimized over a random subset of the features, $S _ { i } \subset \{ 1 , \ldots , D \}$ .

For example, consider the email spam dataset [HTF09, p301]. This dataset contains 4601 email messages, each of which is classified as spam (1) or non-spam (0). The data was open sourced by George Forman from Hewlett-Packard (HP) Labs.

There are 57 quantitative (real-valued) features, as follows:

• 48 features corresponding to the percentage of words in the email that match a given word, such as “remove” or “labs”.

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022 • 6 features corresponding to the percentage of characters in the email that match a given character, namely ; . [ ! \$ # • 3 features corresponding to the average length, max length, and sum of lengths of uninterrupted sequences of capital letters. (These features are called CAPAVE, CAPMAX and CAPTOT.)

![](images/ac762a24aa235178937be417437e3bcd8c79e4630a8e5f26421d55c84c372ff6.jpg)  
Figure 18.5: Preditive accuracy vs size of tree ensemble for bagging, random forests and gradient boosting with log loss. Adapted from Figure 15.1 of [HTF09]. Generated by spam_tree_ensemble_compare.ipynb.

Figure 18.5 shows that random forests work much better than bagged decision trees, because many input features are irrelevant. (We also see that a method called “boosting”, discussed in Section 18.5, works even better; however, this requires sequentially fitting trees, whereas random forests can be fit in parallel.)

# 18.5 Boosting

Ensembles of trees, whether fit by bagging or the random forest algorithm, corresponding to a model of the form

$$
f ( \pmb { x } ; \pmb { \theta } ) = \sum _ { m = 1 } ^ { M } \beta _ { m } F _ { m } ( \pmb { x } ; \pmb { \theta } _ { m } )
$$

where $F _ { m }$ is the $m$ ’th tree, and $\beta _ { m }$ is the corresponding weight, often set to $\beta _ { m } = 1 / M$ . We can generalize this by allowing the $F _ { m }$ functions to be general function approximators, such as neural networks, not just trees. The result is called an additive model [HTF09]. We can think of this as a linear model with adaptive basis functions. The goal, as usual, is to minimize the empirical loss (with an optional regularizer):

$$
\mathcal { L } ( f ) = \sum _ { i = 1 } ^ { N } \ell ( y _ { i } , f ( \pmb { x } _ { i } ) )
$$

Boosting [Sch90; FS96] is an algorithm for sequentially fitting additive models where each $F _ { m }$ is a binary classifier that returns $F _ { m } \in \{ - 1 , + 1 \}$ . In particular, we first fit $F _ { 1 }$ on the original data,

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license and then we weight the data samples by the errors made by $F _ { 1 }$ , so misclassified examples get more weight. Next we fit $F _ { 2 }$ to this weighted data set. We keep repeating this process until we have fit the desired number $M$ of components. ( $M$ is a hyper-parameter that controls the complexity of the overall model, and can be chosen by monitoring performance on a validation set, and using early stopping.)

It can be shown that, as long as each $F _ { m }$ has an accuracy that is better than chance (even on the weighted dataset), then the final ensemble of classifiers will have higher accuracy than any given component. That is, if $F _ { m }$ is a weak learner (so its accuracy is only slightly better than $5 0 \%$ ), then we can boost its performance using the above procedure so that the final $f$ becomes a strong learner. (See e.g., [SF12] for more details on the learning theory approach to boosting.)

Note that boosting reduces the bias of the strong learner, by fitting trees that depend on each other, whereas bagging and RF reduce the variance by fitting independent trees. In many cases, boosting can work better. See Figure 18.5 for an example.

The original boosting algorithm focused on binary classification with a particular loss function that we will explain in Section 18.5.3, and was derived from the PAC learning theory framework (see Section 5.4.4). In the rest of this section, we focus on a more statistical version of boosting, due to [FHT00; Fri01], which works with arbitrary loss functions, making the method suitable for regression, multi-class classification, ranking, etc. Our presentation is based on [HTF09, ch10] and [BH07], which should be consulted for further details.

# 18.5.1 Forward stagewise additive modeling

In this section, we discuss forward stagewise additive modeling, in which we sequentially optimize the objective in Equation (18.16) for general (differentiable) loss functions, where $f$ is an additive model as in Equation 18.15. That is, at iteration $m$ , we compute

$$
( \beta _ { m } , \pmb { \theta } _ { m } ) = \underset { \beta , \pmb { \theta } } { \operatorname { a r g m i n } } \sum _ { i = 1 } ^ { N } \ell ( y _ { i } , f _ { m - 1 } ( \pmb { x } _ { i } ) + \beta F ( \pmb { x } _ { i } ; \pmb { \theta } ) )
$$

We then set

$$
f _ { m } ( { \pmb x } ) = f _ { m - 1 } ( { \pmb x } ) + \beta _ { m } F ( { \pmb x } ; { \pmb \theta } _ { m } ) = f _ { m - 1 } ( { \pmb x } ) + \beta _ { m } F _ { m } ( { \pmb x } )
$$

(Note that we do not adjust the parameters of previously added models.) The details on how to perform this optimization step depend on the loss function that we choose, and (in some cases) on the form of the weak learner $F$ , as we discuss below.

# 18.5.2 Quadratic loss and least squares boosting

Suppose we use squared error loss, $\ell ( y , \hat { y } ) = ( y - \hat { y } ) ^ { 2 }$ . In this case, the $i$ ’th term in the objective at step $m$ becomes

$$
f _ { m - 1 } ( \pmb { x } _ { i } ) + \beta F ( \pmb { x } _ { i } ; \pmb { \theta } ) ) = ( y _ { i } - f _ { m - 1 } ( \pmb { x } _ { i } ) - \beta F ( \pmb { x } _ { i } ; \pmb { \theta } ) ) ^ { 2 } = ( r _ { i m } - \beta F ( \pmb { x } _ { i } ; \pmb { \theta } ) ) ^ { 2 }
$$

where $r _ { i m } = y _ { i } - f _ { m - 1 } ( \pmb { x } _ { i } )$ is the residual of the current model on the $i$ ’th observation. We can minimize the above objective by simply setting $\beta = 1$ , and fitting $F$ to the residual errors. This is called least squares boosting [BY03].

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

![](images/2d5fa8a32e262cd05508f52185ac98d0346d8c514bbe9962684d6ce5e6951af7.jpg)  
Figure 18.6: Illustration of boosting using a regression tree of depth 2 applied to a 1d dataset. Adapted from Figure 7.9 of [Gér19]. Generated by boosted_regr_trees.ipynb.

We give an example of this process in Figure 18.6, where we use a regression tree of depth 2 as the weak learner. On the left, we show the result of fitting the weak learner to the residuals, and on the right, we show the current strong learner. We see how each new weak learner that is added to the ensemble corrects the errors made by earlier versions of the model.

# 18.5.3 Exponential loss and AdaBoost

Suppose we are interested in binary classification, i.e., predicting $\tilde { y } _ { i } \in \{ - 1 , + 1 \}$ . Let us assume the weak learner computes

$$
p ( y = 1 | x ) = \frac { e ^ { F ( x ) } } { e ^ { - F ( x ) } + e ^ { F ( x ) } } = \frac { 1 } { 1 + e ^ { - 2 F ( x ) } }
$$

so $F ( { \pmb x } )$ returns half the log odds. We know from Equation (10.13) that the negative log likelihood is given by

$$
\ell ( \tilde { y } , F ( { \pmb x } ) ) = \log ( 1 + e ^ { - 2 \tilde { y } F ( { \pmb x } ) } )
$$

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

![](images/067a24191a984b7292b392957229db48262e92f34511858e980beb46433de198.jpg)  
Figure 18.7: Illustration of various loss functions for binary classification. The horizontal axis is the margin $m ( { \pmb x } ) = \tilde { y } F ( { \pmb x } )$ , the vertical axis is the loss. The log loss uses log base 2. Generated by hinge_loss_plot.ipynb.

We can minimize this by ensuring that the margin $m ( { \pmb x } ) = \tilde { y } F ( { \pmb x } )$ is as large as possible. We see from Figure 18.7 that the log loss is a smooth upper bound on the 0-1 loss. We also see that it penalizes negative margins more heavily than positive ones, as desired (since positive margins are already correctly classified).

However, we can also use other loss functions. In this section, we consider the exponential loss

$$
\ell ( \tilde { y } , F ( \pmb { x } ) ) = \exp ( - \tilde { y } F ( \pmb { x } ) )
$$

We see from Figure 18.7 that this is also a smooth upper bound on the 0-1 loss. In the population setting (with infinite sample size), the optimal solution to the exponential loss is the same as for log loss. To see this, we can just set the derivative of the expected loss (for each $_ { x }$ ) to zero:

$$
\begin{array} { l } { \displaystyle \frac { \partial } { \partial F ( \pmb { x } ) } \mathbb { E } \left[ e ^ { - \tilde { y } f ( \pmb { x } ) } | \pmb { x } \right] = \frac { \partial } { \partial F ( \pmb { x } ) } [ p ( \tilde { y } = 1 | \pmb { x } ) e ^ { - F ( \pmb { x } ) } + p ( \tilde { y } = - 1 | \pmb { x } ) e ^ { F ( \pmb { x } ) } ] } \\ { \displaystyle = - p ( \tilde { y } = 1 | \pmb { x } ) e ^ { - F ( \pmb { x } ) } + p ( \tilde { y } = - 1 | \pmb { x } ) e ^ { F ( \pmb { x } ) } } \\ { \displaystyle = 0 \Rightarrow \frac { p ( \tilde { y } = 1 | \pmb { x } ) } { p ( \tilde { y } = - 1 | \pmb { x } ) } = e ^ { 2 F ( \pmb { x } ) } } \end{array}
$$

However, it turns out that the exponential loss is easier to optimize in the boosting setting, as we show below. (We consider the log loss case in Section 18.5.4.)

We now discuss how to solve for the $m$ ’th weak learner, $F _ { m }$ , when we use exponential loss. We will assume that the base classifier $F _ { m }$ returns a binary class label; the resulting algorithm is called discrete AdaBoost [FHT00]. If $F _ { m }$ returns a probability instead, a modified algorithm, known as real AdaBoost, can be used [FHT00].

At step $m$ we have to minimize

$$
L _ { m } ( F ) = \sum _ { i = 1 } ^ { N } \exp [ - \tilde { y } _ { i } ( f _ { m - 1 } ( \pmb { x } _ { i } ) + \beta F ( \pmb { x } _ { i } ) ) ] = \sum _ { i = 1 } ^ { N } \omega _ { i , m } \exp ( - \beta \tilde { y } _ { i } F ( \pmb { x } _ { i } ) )
$$

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

where $\omega _ { i , m } \triangleq \exp \bigl ( - \tilde { y } _ { i } f _ { m - 1 } ( \pmb { x } _ { i } ) \bigr )$ is a weight applied to datacase $i$ , and $\tilde { y } _ { i } \in \{ - 1 , + 1 \}$ . We can rewrite this objective as follows:

$$
\begin{array} { l } { { \displaystyle { \cal L } _ { m } = e ^ { - \beta } \sum _ { \tilde { y } _ { i } = F ( { \pmb x } _ { i } ) } \omega _ { i , m } + e ^ { \beta } \sum _ { \tilde { y } _ { i } \neq F ( { \pmb x } _ { i } ) } \omega _ { i , m } } } \\ { { \displaystyle ~ = ( e ^ { \beta } - e ^ { - \beta } ) \sum _ { i = 1 } ^ { N } \omega _ { i , m } \mathbb { I } \left( \tilde { y } _ { i } \neq F ( { \pmb x } _ { i } ) \right) + e ^ { - \beta } \sum _ { i = 1 } ^ { N } \omega _ { i , m } } } \end{array}
$$

Consequently the optimal function to add is

$$
F _ { m } = \underset { F } { \mathrm { a r g m i n } } \sum _ { i = 1 } ^ { N } \omega _ { i , m } \mathbb { I } \left( \tilde { y } _ { i } \neq F ( \pmb { x } _ { i } ) \right)
$$

This can be found by applying the weak learner to a weighted version of the dataset, with weights ωi,m.

All that remains is to solve for the size of the update, $\beta$ . Subsituting $F _ { m }$ into $L _ { m }$ and solving for $\beta$ we find

$$
\beta _ { m } = \frac { 1 } { 2 } \log \frac { 1 - \mathrm { e r r } _ { m } } { \mathrm { e r r } _ { m } }
$$

where

$$
\mathrm { e r r } _ { m } = \frac { \sum _ { i = 1 } ^ { N } \omega _ { i , m } \mathbb { I } \left( \tilde { y } _ { i } \neq F _ { m } ( \pmb { x } _ { i } ) \right) } { \sum _ { i = 1 } ^ { N } \omega _ { i , m } }
$$

Therefore overall update becomes

$$
f _ { m } ( { \pmb x } ) = f _ { m - 1 } ( { \pmb x } ) + \beta _ { m } F _ { m } ( { \pmb x } )
$$

After updating the strong learner, we need to recompute the weights for the next iteration, as follows:

$$
\omega _ { i , m + 1 } = e ^ { - \tilde { y } _ { i } f _ { m } ( \pmb { x } _ { i } ) } = e ^ { - \tilde { y } _ { i } f _ { m - 1 } ( \pmb { x } _ { i } ) - \tilde { y } _ { i } \beta _ { m } F _ { m } ( \pmb { x } _ { i } ) } = \omega _ { i , m } e ^ { - \tilde { y } _ { i } \beta _ { m } F _ { m } ( \pmb { x } _ { i } ) }
$$

If $\tilde { y } _ { i } = F _ { m } ( \pmb { x } _ { i } )$ , then $\tilde { y } _ { i } F _ { m } ( { \pmb x } _ { i } ) = 1$ , and if $\tilde { y } _ { i } \neq F _ { m } ( \pmb { x } _ { i } )$ , then $\tilde { y } _ { i } F _ { m } ( { \pmb x } _ { i } ) = - 1$ . Hence $\begin{array} { r l } { - \tilde { y } _ { i } F _ { m } ( \pmb { x } _ { i } ) = } \end{array}$ $2 \mathbb { I } \left( \tilde { y } _ { i } \neq F _ { m } ( \pmb { x } _ { o } ) \right) - 1$ , so the update becomes

$$
\omega _ { i , m + 1 } = \omega _ { i , m } e ^ { \beta _ { m } \left( 2 \mathbb { I } ( \tilde { y } _ { i } \neq F _ { m } ( \pmb x _ { i } ) ) - 1 \right) } = \omega _ { i , m } e ^ { 2 \beta _ { m } \mathbb { I } ( \tilde { y } _ { i } \neq F _ { m } ( \pmb x _ { i } ) ) } e ^ { - \beta _ { m } }
$$

Since the $e ^ { - \beta _ { m } }$ is constant across all examples, it can be dropped. If we then define $\alpha _ { m } = 2 \beta _ { m }$ , the update becomes

$$
\omega _ { i , m + 1 } = { \left\{ \begin{array} { l l } { \omega _ { i , m } e ^ { \alpha _ { m } } } & { { \mathrm { i f ~ } } \tilde { y } _ { i } \neq F _ { m } ( \pmb { x } _ { i } ) } \\ { \omega _ { i , m } } & { { \mathrm { o t h e r w i s e } } } \end{array} \right. }
$$

Thus we see that we exponentially increase weights of misclassified examples. The resulting algorithm shown in Algorithm 8, and is known as Adaboost.M1 [FS96].

A multiclass generalization of exponential loss, and an adaboost-like algorithm to minimize it, known as SAMME (stagewise additive modeling using a multiclass exponential loss function), is described in [Has+09]. This is implemented in scikit learn (the AdaBoostClassifier class).

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

<html><body><table><tr><td colspan="2">Algorithm 8: forbinaryclassificationwithexponentialloss</td></tr><tr><td colspan="2">1 Wi=1/N</td></tr><tr><td>2 for m=1:M do</td><td></td></tr><tr><td>3</td><td>Fit a classifier Fm(x) to the training set using weights w</td></tr><tr><td>4</td><td>Compute erTm = ∑1wiml(ifFm())</td></tr><tr><td>5</td><td>i=1Wi,m Compute αm =log[(1- errm)/errm]</td></tr><tr><td>6</td><td>Set wi ←Wi exp[αmI(yi≠Fm(xi))]</td></tr><tr><td colspan="2">7 Return f(x) = sgn 7M m=1amFm(c)</td></tr></table></body></html>

# 18.5.4 LogitBoost

The trouble with exponential loss is that it puts a lot of weight on misclassified examples, as is apparent from the exponential blowup on the left hand side of Figure 18.7. This makes the method very sensitive to outliers (mislabeled examples). In addition, $e ^ { - \tilde { y } f }$ is not the logarithm of any pmf for binary variables $\tilde { y } \in \{ - 1 , + 1 \}$ ; consequently we cannot recover probability estimates from $f ( { \pmb x } )$ . A natural alternative is to use log loss, as we discussed in Section 18.5.3. This only punishes mistakes linearly, as is clear from Figure 18.7. Furthermore, it means that we will be able to extract probabilities from the final learned function, using

$$
p ( y = 1 | \pmb { x } ) = \frac { e ^ { f ( \pmb { x } ) } } { e ^ { - f ( \pmb { x } ) } + e ^ { f ( \pmb { x } ) } } = \frac { 1 } { 1 + e ^ { - 2 f ( \pmb { x } ) } }
$$

The goal is to minimze the expected log-loss, given by

$$
L _ { m } ( F ) = \sum _ { i = 1 } ^ { N } \log \left[ 1 + \exp \left( - 2 \tilde { y } _ { i } ( f _ { m - 1 } ( \pmb { x } ) + F ( \pmb { x } _ { i } ) ) \right) \right]
$$

By performing a Newton update on this objective (similar to IRLS), one can derive the algorithm shown in Algorithm 9. This is known as logitBoost [FHT00]. The key subroutine is the ability of the weak learner $F$ to solve a weighted least squares problem. This method can be generalized to the multi-class setting, as explained in [FHT00].

# 18.5.5 Gradient boosting

Rather than deriving new versions of boosting for every different loss function, it is possible to derive a generic version, known as gradient boosting [Fri01; Mas+00]. To explain this, imagine solving $\hat { \pmb f } = \mathrm { a r g m i n } _ { \pmb f } \mathcal { L } ( \pmb f )$ by performing gradient descent in the space of functions. Since functions are infinite dimensional objects, we will represent them by their values on the training set, ${ \pmb f } = ( f ( { \pmb x } _ { 1 } ) , \dots , f ( { \pmb x } _ { N } ) )$ . At step $m$ , let ${ \bf { \nabla } } _ { \bf { { g } } } _ { m }$ be the gradient of $\mathcal { L } ( f )$ evaluated at $f = f _ { m - 1 }$ :

$$
g _ { i m } = \left[ \frac { \partial \ell ( y _ { i } , f ( { \pmb x } _ { i } ) ) } { \partial f ( { \pmb x } _ { i } ) } \right] _ { f = f _ { m - 1 } }
$$

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

Algorithm 9: LogitBoost, for binary classification with log-loss

1 $\omega _ { i } = 1 / N$ , $\pi _ { i } = 1 / 2$   
2 for $m = 1 : M$ do   
3 Compute the working response zi = πiy(i∗1−πii)   
4 Compute the weights $\omega _ { i } = \pi _ { i } ( 1 - \pi _ { i } )$   
5 $\begin{array} { r } { F _ { m } = \mathrm { a r g m i n } _ { F } \sum _ { i = 1 } ^ { N } \omega _ { i } ( z _ { i } - F ( \pmb { x } _ { i } ) ) ^ { 2 } } \end{array}$   
6 Update $\begin{array} { r } { f ( \pmb { x } )  f ( \pmb { x } ) + \frac { 1 } { 2 } F _ { m } ( \pmb { x } ) } \end{array}$   
7 Compute $\pi _ { i } = 1 / ( 1 + \exp ( - 2 f ( \pmb { x } _ { i } ) ) )$ ;

<html><body><table><tr><td>Name</td><td>Loss</td><td>-dl(yi, f(xi))/af(xi)</td></tr><tr><td>Squared error</td><td>2(yi-f(xi))²</td><td>yi-f(xi)</td></tr><tr><td>Absolute error</td><td>lyi-f(xi)l</td><td>sgn(yi-f(xi))</td></tr><tr><td>Exponential loss</td><td>exp(-yif(xi))</td><td>-yiexp(-yif(xi))</td></tr><tr><td>Binary Logloss</td><td>log(1+e-yifi)</td><td>Yi-Ti</td></tr><tr><td>Multiclass logloss</td><td>-∑c yic log Tic</td><td>Yic-Tic</td></tr></table></body></html>

8 Return $\begin{array} { r } { f ( \pmb { x } ) = \mathrm { s g n } \left[ \sum _ { m = 1 } ^ { M } F _ { m } ( \pmb { x } ) \right] } \end{array}$

Table 18.1: Some commonly used loss functions, their gradients, and their population minimizers $F ^ { * }$ . For binary classification problems, we assume $\tilde { y } _ { i } \in \{ - 1 , + 1 \}$ , and $\pi _ { i } = \sigma ( 2 f ( \pmb { x } _ { i } ) )$ . For regression problems, we assume $y _ { i } \in \mathbb { R }$ . Adapted from [HTF09, p360] and [BH07, p483].

Gradients of some common loss functions are given in Table 18.1. We then make the update

$$
\pmb { f } _ { m } = \pmb { f } _ { m - 1 } - \beta _ { m } \pmb { g } _ { m }
$$

where $\beta _ { m }$ is the step length, chosen by

$$
\beta _ { m } = \underset { \beta } { \operatorname { a r g m i n } } \mathcal { L } ( \pmb { f } _ { m - 1 } - \beta \pmb { g } _ { m } )
$$

In its current form, this is not much use, since it only optimizes $f$ at a fixed set of $N$ points, so we do not learn a function that can generalize. However, we can modify the algorithm by fitting a weak learner to approximate the negative gradient signal. That is, we use this update

$$
F _ { m } = \underset { F } { \mathrm { a r g m i n } } \sum _ { i = 1 } ^ { N } ( - g _ { i m } - F ( { \pmb x } _ { i } ) ) ^ { 2 }
$$

The overall algorithm is summarized in Algorithm 10. We have omitted the line search step for $\beta _ { m }$ , which is not strictly necessary, as argued in [BH07]. However, we have introduced a learning rate or shrinkage factor $0 < \nu \leq 1$ , to control the size of the updates, for regularization purposes.

If we apply this algorithm using squared loss, we recover L2Boosting, since $- g _ { i m } = y _ { i } - f _ { m - 1 } ( { \bf x } _ { i } )$ is just the residual error. We can also apply this algorithm to other loss functions, such as absolute loss or Huber loss (Section 5.1.5.3), which is useful for robust regression problems.

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

# Algorithm 10: Gradient boosting

<html><body><table><tr><td colspan="2">1 Initialize fo(x) = argminF∑i=1 L(yi,F(xi))</td></tr><tr><td colspan="2">2 for m=1:M do</td></tr><tr><td>3 Compute the gradient residual using rim = -</td><td>[L(y(）](）=m-(a)</td></tr><tr><td colspan="2">4 Use the weak learner to compute Fm = argminF ∑i=1(rim - F(xi)2 5 Update fm(x)= fm-1(x)+vFm(x)</td></tr></table></body></html>

For classification, we can use log-loss. In this case, we get an algorithm known as BinomialBoost [BH07]. The advantage of this over LogitBoost is that it does not need to be able to do weighted fitting: it just applies any black-box regression model to the gradient vector. To apply this to multi-class classification, we can fit $C$ separate regression trees, using the pseudo residual of the form

$$
- g _ { i c m } = \frac { \partial \ell ( y _ { i } , f _ { 1 m } ( x _ { i } ) , \ldots , f _ { C m } ( \pmb x _ { i } ) ) } { \partial f _ { c m } ( \pmb x _ { i } ) } = \mathbb { I } \left( y _ { i } = c \right) - \pi _ { i c }
$$

Although the trees are fit separately, their predictions are combined via a softmax transform

$$
p ( \boldsymbol { y } = c | \boldsymbol { x } ) = \frac { e ^ { f _ { c } ( \boldsymbol { x } ) } } { \sum _ { c ^ { \prime } = 1 } ^ { C } e ^ { f _ { c ^ { \prime } } ( \boldsymbol { x } ) } }
$$

When we have large datasets, we can use a stochastic variant in which we subsample (without replacement) a random fraction of the data to pass to the regression tree at each iteration. This is called stochastic gradient boosting [Fri99]. Not only is it faster, but it can also generalize better, because subsampling the data is a form of regularization.

# 18.5.5.1 Gradient tree boosting

In practice, gradient boosting nearly always assumes that the weak learner is a regression tree, which is a model of the form

$$
F _ { m } ( \pmb { x } ) = \sum _ { j = 1 } ^ { J _ { m } } w _ { j m } \mathbb { I } \left( \pmb { x } \in R _ { j m } \right)
$$

where $w _ { j m }$ is the predicted output for region $R _ { j m }$ . (In general, $w _ { j m }$ could be a vector.) This combination is called gradient boosted regression trees, or gradient tree boosting. (A related version is known as MART, which stands for “multivariate additive regression trees” [FM03].) To use this in gradient boosting, we first find good regions $R _ { j m }$ for tree $m$ using standard regression tree learning (see Section 18.1) on the residuals; we then (re)solve for the weights of each leaf by solving

$$
\hat { w } _ { j m } = \mathop { \operatorname { a r g m i n } } _ { w } \sum _ { \pmb { x } _ { i } \in R _ { j m } } \ell ( y _ { i } , f _ { m - 1 } ( \pmb { x } _ { i } ) + w )
$$

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

For squared error (as used by gradient boosting), the optimal weight $\hat { w } _ { j m }$ is the just the mean of the residuals in that leaf.

# 18.5.5.2 XGBoost

XGBoost (https://github.com/dmlc/xgboost), which stands for “extreme gradient boosting”, is a very efficient and widely used implementation of gradient boosted trees, that adds a few more improvements beyond the description in Section 18.5.5.1. The details can be found in [CG16], but in brief, the extensions are as follows: it adds a regularizer on the tree complexity, it uses a second order approximation of the loss (from [FHT00]) instead of just a linear approximation, it samples features at internal nodes (as in random forests), and it uses various computer science methods (such as handling out-of-core computation for large datasets) to ensure scalability.2

In more detail, XGBoost optimizes the following regularized objective

$$
\mathcal { L } ( f ) = \sum _ { i = 1 } ^ { N } \ell ( y _ { i } , f ( \pmb { x } _ { i } ) ) + \Omega ( f )
$$

where

$$
\Omega ( f ) = \gamma J + \frac { 1 } { 2 } \lambda \sum _ { j = 1 } ^ { J } w _ { j } ^ { 2 }
$$

is the regularizer, where $J$ is the number of leaves, and $\gamma \geq 0$ and $\lambda \geq 0$ are regularization coefficients. At the $m$ ’th step, the loss is given by

$$
\mathcal { L } _ { m } ( F _ { m } ) = \sum _ { i = 1 } ^ { N } \ell ( y _ { i } , f _ { m - 1 } ( \pmb { x } _ { i } ) + F _ { m } ( \pmb { x } _ { i } ) ) + \Omega ( F _ { m } ) + \mathrm { c o n s t }
$$

We can compute a second order Taylor expansion of this as follows:

$$
\mathcal { L } _ { m } ( F _ { m } ) \approx \sum _ { i = 1 } ^ { N } \bigg [ \ell ( y _ { i } , f _ { m - 1 } ( x _ { i } ) ) + g _ { i m } F _ { m } ( x _ { i } ) + \frac { 1 } { 2 } h _ { i m } F _ { m } ^ { 2 } ( x _ { i } ) \bigg ] + \Omega ( F _ { m } ) + \mathrm { c o n s }
$$

where $h _ { i m }$ is the Hessian

$$
h _ { i m } = \left[ \frac { \partial ^ { 2 } \ell ( y _ { i } , f ( { \pmb x } _ { i } ) ) } { \partial f ( { \pmb x } _ { i } ) ^ { 2 } } \right] _ { f = f _ { m - 1 } }
$$

In the case of regression trees, we have $F ( \pmb { x } ) = w _ { q ( \pmb { x } ) }$ , where $q : \mathbb { R } ^ { D }  \{ 1 , \ldots , J \}$ specifies which leaf node $_ { x }$ belongs to, and $\boldsymbol { w } \in \mathbb { R } ^ { J }$ are the leaf weights. Hence we can rewrite Equation (18.49) as

follows, dropping terms that are independent of $F _ { m }$ :

$$
\begin{array} { l } { \displaystyle \mathcal { L } _ { m } ( q , \pmb { w } ) \approx \sum _ { i = 1 } ^ { N } \left[ g _ { i m } F _ { m } ( \pmb { x } _ { i } ) + \frac { 1 } { 2 } h _ { i m } F _ { m } ^ { 2 } ( \pmb { x } _ { i } ) \right] + \gamma J + \frac { 1 } { 2 } \lambda \sum _ { j = 1 } ^ { J } w _ { j } ^ { 2 } } \\ { \displaystyle = \sum _ { j = 1 } ^ { J } \left[ ( \sum _ { i \in I _ { j } } g _ { i m } ) w _ { j } + \frac { 1 } { 2 } ( \sum _ { i \in I _ { j } } h _ { i } + \lambda ) w _ { j } ^ { 2 } \right] + \gamma J } \end{array}
$$

where $I _ { j } = \{ i : q ( { \pmb x } _ { i } ) = j \}$ is the set of indices of data points assigned to the $j$ ’th leaf. Let us define $\begin{array} { r } { G _ { j m } = \sum _ { i \in I _ { j } } g _ { i m } } \end{array}$ and $\begin{array} { r } { H _ { j m } = \sum _ { i \in I _ { j } } h _ { i m } } \end{array}$ . Then the above simplifies to

$$
\mathcal { L } _ { m } ( q , \pmb { w } ) = \sum _ { j = 1 } ^ { J } \bigg [ G _ { j m } w _ { j } + \frac { 1 } { 2 } ( H _ { j m } + \lambda ) w _ { j } ^ { 2 } \bigg ] + \gamma J
$$

This is a quadratic in each $w _ { j } \mathrm { m }$ so the optimal weights are given by

$$
w _ { j } ^ { \ast } = - \frac { G _ { j m } } { H _ { j m } + \lambda }
$$

The loss for evaluating different tree structures $q$ then becomes

$$
\mathcal { L } _ { m } ( q , \pmb { w } ^ { * } ) = - \frac { 1 } { 2 } \sum _ { j = 1 } ^ { J } \frac { G _ { j m } ^ { 2 } } { H _ { j m } + \lambda } + \gamma J
$$

We can greedily optimize this using a recursive node splitting procedure, as in Section 18.1. Specifically, for a given leaf $j$ , we consider splitting it into a left and right half, $I = I _ { L } \cup I _ { R }$ . We can compute the gain (reduction in loss) of such a split as follows:

$$
\mathrm { g a i n } = { \frac { 1 } { 2 } } \left[ { \frac { G _ { L } ^ { 2 } } { H _ { L } + \lambda } } + { \frac { G _ { R } ^ { 2 } } { H _ { R } + \lambda } } - { \frac { ( G _ { L } + G _ { R } ) ^ { 2 } } { ( H _ { L } + H _ { R } ) + \lambda } } \right] - \gamma
$$

where $\begin{array} { r } { G _ { L } = \sum _ { i \in I _ { L } } g _ { i m } } \end{array}$ , $\begin{array} { r } { G _ { R } = \sum _ { i \in I _ { R } } g _ { i m } } \end{array}$ , $\begin{array} { r } { H _ { L } = \sum _ { i \in I _ { L } } h _ { i m } } \end{array}$ , and $\begin{array} { r } { H _ { R } = \sum _ { i \in I _ { R } } h _ { i m } } \end{array}$ . Thus we see that it is not worth splitting a node if the gain is negative (i.e., the first term is less than $\gamma$ ).

A fast approximation for evaluating this objective, that does not require sorting the features (for choosing the optimal threshold to split on), is described in [CG16].

# 18.6 Interpreting tree ensembles

Trees are popular because they are interpretable. Unfortunately, ensembles of trees (whether in the form of bagging, random forests, or boosting) lose that property. Fortunately, there are some simple methods we can use to interpret what function has been learned.

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

![](images/65fb2599d3a0422e8c10162964df250c0167ad030832a28e2d6e793b3b0f53ab.jpg)  
Figure 18.8: Feature importance of a random forest classifier trained to distinguish MNIST digits from classes 0 and 8. Adapted from Figure 7.6 of [Gér19]. Generated by rf_feature_importance_mnist.ipynb.

# 18.6.1 Feature importance

For a single decision tree $T$ , [BFO84] proposed the following measure for feature importance of feature $k$ :

$$
R _ { k } ( T ) = \sum _ { j = 1 } ^ { J - 1 } G _ { j } \mathbb { I } \left( v _ { j } = k \right)
$$

where the sum is over all non-leaf (internal) nodes, $G _ { j }$ is the gain in accuracy (reduction in cost) at node $j$ , and $v _ { j } = k$ if node $j$ uses feature $k$ . We can get a more reliable estimate by averaging over all trees in the ensemble:

$$
R _ { k } = \frac { 1 } { M } \sum _ { m = 1 } ^ { M } R _ { k } ( T _ { m } )
$$

After computing these scores, we can normalize them so the largest value is $1 0 0 \%$ . We give some examples below.

Figure 18.8 gives an example of estimating feature importance for a classifier trained to distinguish MNIST digits from classes 0 and 8. We see that it focuses on the parts of the image that differ between these classes.

In Figure 18.9, we plot the relative importance of each of the features for the spam dataset (Section 18.4). Not surprisingly, we find that the most important features are the words “george” (the name of the recipient) and “hp” (the company he worked for), as well as the characters ! and $\$ 9$ . (Note it can be the presence or absence of these features that is informative.)

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

![](images/586e96e7f15b9069ce897a5a7be758cdb0409a6ed7cc83a21e088d0ac7172c21.jpg)  
Figure 18.9: Feature importance of a gradient boosted classifier trained to distinguish spam from non-spam email. The dataset has $X$ training examples with $Y$ features, corresponding to token frequency. Adapted from Figure 10.6 of [HTF09]. Generated by spam_tree_ensemble_interpret.ipynb.

![](images/0b7575592d8b923bbf5596106fadf3b6657bcf048c1d75a5924ffb6a6e1893ef.jpg)  
Figure 18.10: (a) Partial dependence of log-odds of the spam class for 4 important predictors. The red ticks at the base of the plot are deciles of the empirical distribution for this feature. (b) Joint partial dependence of log-odds on the features hp and !. Adapted from Figure 10.6–10.8 of [HTF09]. Generated by spam_tree_ensemble_interpret.ipynb.

# 18.6.2 Partial dependency plots

After we have identified the most relevant input features, we can try to assess the impact they have on the output. A partial dependency plot for feature $k$ is a plot of

$$
\overline { { f } } _ { k } ( x _ { k } ) = \frac { 1 } { N } \sum _ { n = 1 } ^ { N } f ( x _ { n , - k } , x _ { k } )
$$

vs $x _ { k }$ . Thus we marginalize out all features except $k$ . In the case of a binary classifier, we can convert this to log odds, $\log p ( y = 1 | x _ { k } ) / p ( y = 0 | x _ { k } )$ , before plotting. We illustrate this for our spam example in Figure 18.10a for 4 different features. We see that as the frequency of ! and “remove” increases, so does the probability of spam. Conversely, as the frequency of “edu” or “hp” increases, the probability of spam decreases.

We can also try to capture interaction effects between features $j$ and $k$ by computing

$$
\overline { { f } } _ { j k } ( x _ { j } , x _ { k } ) = \frac { 1 } { N } \sum _ { n = 1 } ^ { N } f ( \pmb { x } _ { n , - j k } , x _ { j } , x _ { k } )
$$

We illustrate this for our spam example in Figure 18.10b for hp and !. We see that higher frequency of ! makes it more likely to be spam, but much more so if the word “hp” is missing.

# Part V

# Beyond Supervised Learning

# 19 Learning with Fewer Labeled Examples

Many ML models, especially neural networks, often have many more parameters than we have labeled training examples. For example, a ResNet CNN (Section 14.3.4) with 50 layers has 23 million parameters. Transformer models (Section 15.5) can be even bigger. Of course these parameters are highly correlated, so they are not independent “degrees of freedom”. Nevertheless, such big models are slow to train and, more importantly, they may easily overfit. This is particularly a problem when you do not have a large labeled training set. In this chapter, we discuss some ways to tackle this issue, beyond the generic regularization techniques we discussed in Section 13.5 such as early stopping, weight decay and dropout.

# 19.1 Data augmentation

Suppose we just have a single small labeled dataset. In some cases, we may be able to create artificially modified versions of the input vectors, which capture the kinds of variations we expect to see at test time, while keeping the original labels unchanged. This is called data augmentation.1 We give some examples below, and then discuss why this approach works.

# 19.1.1 Examples

For image classification tasks, standard data augmentation methods include random crops, zooms, and mirror image flips, as illustrated in Figure 19.1. [GVZ16] gives a more sophisticated example, where they render text characters onto an image in a realistic way, thereby creating a very large dataset of text “in the wild”. They used this to train a state of the art visual text localization and reading system. Other examples of data augmentation include artifically adding background noise to clean speech signals, and artificially replacing characters or words at random in text documents.

If we afford to train and test the model many times using different versions of the data, we can learn which augmentations work best, using blackbox optimization methods such as RL (see e.g., [Cub+19]) or Bayesian optimization (see e.g., [Lim+19]); this is called AutoAugment. We can also learn to combine multiple augmentations together; this is called AutoAugment [Cub+19].

For some examples of augmentation in NLP, see e.g., [Fen+21].

![](images/7f6d3ef02722cd6aec70e6f0b339f72087870760ec1536ddfbe4b8ac52351756.jpg)  
Figure 19.1: Illustration of random crops and zooms of a image images. Generated by image_augmentation_jax.ipynb.

# 19.1.2 Theoretical justification

Data augmentation often significantly improves performance (predictive accuracy, robustness, etc). At first this might seem like we are getting something for nothing, since we have not provided additional data. However, the data augmentation mechanism can be viewed as a way to algorithmically inject prior knowledge.

To see this, recall that in standard ERM training, we minimize the empirical risk

$$
R ( f ) = \int \ell ( f ( { \pmb x } ) , { \pmb y } ) p ^ { * } ( { \pmb x } , { \pmb y } ) d { \pmb x } d { \pmb y }
$$

where we approximate $p ^ { * } ( { \pmb x } , { \pmb y } )$ by the empirical distribution

$$
p _ { \mathcal { D } } ( \pmb { x } , \pmb { y } ) = \frac { 1 } { N } \sum _ { n = 1 } ^ { N } \delta ( \pmb { x } - \pmb { x } _ { n } ) \delta ( \pmb { y } - \pmb { y } _ { n } )
$$

We can think of data augmentation as replacing the empirical distribution with the following algorithmically smoothed distribution

$$
p _ { \mathcal { D } } ( \pmb { x } , \pmb { y } | A ) = \frac { 1 } { N } \sum _ { n = 1 } ^ { N } p ( \pmb { x } | \pmb { x } _ { n } , A ) \delta ( \pmb { y } - \pmb { y } _ { n } )
$$

where $A$ is the data augmentation algorithm, which generates a sample $_ { x }$ from a training point ${ \boldsymbol { \mathbf { \mathit { x } } } } _ { n }$ , such that the label (“semantics”) is not changed. (A very simple example would be a Gaussian kernel, $p ( \pmb { x } | \pmb { x } _ { n } , A ) = \mathcal { N } ( \pmb { x } | \pmb { x } _ { n } , \sigma ^ { 2 } \mathbf { I } )$ .) This has been called vicinal risk minimization [Cha+01], since we are minimizing the risk in the vicinity of each training point $_ { \ast }$ . For more details on this perspective, see [Zha+17b; CDL19; Dao+19].

# 19.2 Transfer learning

This section is coauthored with Colin Raffel.

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

![](images/41e7a6d039907ef316b31258512c72e39aeb7278f680583691b9f0ad79c85ece.jpg)  
Figure 19.2: Illustration of fine-tuning a model on a new dataset. The final output layer is trained from scratch, since it might correspond to a different label set. The other layers are initialized at their previous parameters, and then optionally updated using a small learning rate. From Figure 13.2.1 of [Zha+20]. Used with kind permission of Aston Zhang.

Many data-poor tasks have some high-level structural similarity to other data-rich tasks. For example, consider the task of fine-grained visual classification of endangered bird species. Given that endangered birds are by definition rare, it is unlikely that a large quantity of diverse labeled images of these birds exist. However, birds bear many structural similarities across species - for example, most birds have wings, feathers, beaks, claws, etc. We therefore might expect that first training a model on a large dataset of non-endangered bird species and then continuing to train it on a small dataset of endangered species could produce better performance than training on the small dataset alone.

This is called transfer learning, since we are transferring information from one dataset to another, via a shared set of parameters. More precisely, we first perform a pre-training phase, in which we train a model with parameters $\pmb \theta$ on a large source dataset $\mathcal { D } _ { p }$ ; this may be labeled or unlabeled. We then perform a second fine-tuning phase on the small labeled target dataset $\mathcal { D } _ { q }$ of interest. We discuss these two phases in more detail below, but for more information, see e.g., [Tan+18; Zhu+21] for recent surveys.

# 19.2.1 Fine-tuning

Suppose, for now, that we already have a pretrained classifier, $p ( \boldsymbol { y } | \mathbf { x } , \boldsymbol { \theta } _ { p } )$ , such as a CNN, that works well for inputs $\pmb { x } \in \mathcal { X } _ { p }$ (e.g. natural images) and outputs $\boldsymbol { y } \in \mathcal { V } _ { p }$ (e.g., ImageNet labels), where the data comes from a distribution $p ( { \pmb x } , { \pmb y } )$ similar to the one used in training. Now we want to create a new model $q ( y | \mathbf { x } , \pmb { \theta } _ { q } )$ that works well for inputs $\pmb { x } \in \mathcal { X } _ { q }$ (e.g. bird images) and outputs $y \in \mathcal { V } _ { q }$ (e.g., fine-grained bird labels), where the data comes from a distribution $q ( { \pmb x } , { \pmb y } )$ which may be different from $p$ .

We will assume that the set of possible inputs is the same, so $\mathcal { X } _ { q } \approx \mathcal { X } _ { p }$ (e.g., both are RGB images), or that we can easily transform inputs from domain $p$ to domain $q$ (e.g., we can convert an RGB image to grayscale by dropping the chrominance channels and just keeping luminance). (If this is not

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license the case, then we may need to use a method called domain adaptation, that modifies models to map between modalities, as discussed in Section 19.2.5.)

![](images/1d0622d4bbaeda4ae02770ffa2b1f69882363ed53633a5c3a0c531d3a40ed20a.jpg)  
Figure 19.3: (a) Adding adapter layers to a transformer. From Figure 2 of [Hou+19]. Used with kind permission of Neil Houlsby. (b) Adding adapter layers to a resnet. From Figure 2 of [RBV18]. Used with kind permission of Sylvestre-Alvise Rebuffi.

However, the output domains are usually different, i.e., $\mathcal { V } _ { q } \not = \mathcal { V } _ { p }$ . For example, $\mathcal { V } _ { p }$ might be Imagenet labels and $\mathcal { V } _ { q }$ might be medical labels (e.g., types of diabetic retinopathy [Arc+19]). In this case, we need to “translate” the output of the pre-trained model to the new domain. This is easy to do with neural networks: we simply “chop off” the final layer of the original model, and add a new “head” to model the new class labels, as illustrated in Figure 19.2. For example, suppose $p ( \boldsymbol { y } | \mathbf { x } , \pmb { \theta } _ { p } ) = \mathrm { s o f t m a x } ( \boldsymbol { y } | \mathbf { W } _ { 2 } \boldsymbol { h } ( \mathbf { x } ; \pmb { \theta } _ { 1 } ) + b _ { 2 } )$ , where $\pmb { \theta } _ { p } = ( \mathbf { W } _ { 2 } , \pmb { b } _ { 2 } , \pmb { \theta } _ { 1 } )$ . Then we can construct 9 $\begin{array} { r } { \mathbf { \Theta } _ { l } ( y | \pmb { \theta } _ { q } ) = \mathrm { s o f t m a x } ( y | \mathbf { W } _ { 3 } \pmb { h } ( \pmb { x } ; \pmb { \theta } _ { 1 } ) + \pmb { b } _ { 3 } ) } \end{array}$ , where $\pmb { \theta } _ { q } = ( \mathbf { W } _ { 3 } , \pmb { b } _ { 3 } , \pmb { \theta } _ { 1 } )$ and $\pmb { h } ( \pmb { x } ; \pmb { \theta } _ { 1 } )$ is the shared nonlinear feature extractor.

After performing this “model surgery”, we can fine-tune the new model with parameters $\theta _ { q } = $ $( \theta _ { 1 } , \theta _ { 3 } )$ , where $\pmb { \theta } _ { 1 }$ parameterizes the feature extractor, and $\pmb { \theta } _ { 3 }$ parameterizes the final linear layer that maps features to the new set of labels. If we treat $\pmb { \theta } _ { 1 }$ as “frozen parameters”, then the resulting model $q ( y | \mathbf { x } , \pmb { \theta } _ { q } )$ is linear in its parameters, so we have a convex optimization problem for which many simple and efficient fitting methods exist (see Part II). This is particularly helpful in the long-tail setting, where some classes are very rare [Kan+20]. However, a linear “decoder” may be too limiting, so we can also allow $\pmb { \theta } _ { 1 }$ to be fine-tuned as well, but using a lower learning rate, to prevent the values moving too far from the values estimated on $\mathcal { D } _ { p }$ .

# 19.2.2 Adapters

One disadvantage of fine-tuning all the model parameters of a pre-trained model is that it can be slow, since there are often many parameters, and we may need to use a small learning rate to prevent the low-level feature extractors from diverging too far from their prior values. In addition, every new task requires a new model to be trained, making task sharing hard. An alternative approach is to keep the pre-trained model untouched, but to add new parameters to modify its internal behavior to

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022 customize the feature extraction process for each task. This idea is called adapters, and has been explored in several papers (e.g., [RBV17; RBV18; Hou+19]).

Figure 19.3a illustrates adapters for transformer networks (Section 15.5), as proposed in [Hou+19]. The basic idea is to insert two shallow bottleneck MLPs inside each transformer layer, one after the multi-head attention and once after the feed-forward layers. Note that these MLPs have skip connections, so that they can be initialized to implement the identity mapping. If the transformer layer has features of dimensionality $D$ , and the adapter uses a bottleneck of size $M$ , this introduces $O ( D M )$ new parameters per layer. These adapter MLPs, as well as the layer norm parameters and final output head, are trained for each new task, but the all remaining parameters are frozen. Empirically on several NLP benchmarks, this is found to give better performance than fine tuning, while only needing about 1-10% of the original parameters.

Figure 19.3b illustrates adapters for residual networks (Section 14.3.4), as proposed in [RBV17; RBV18]. The basic idea is to add a 1x1 convolution layer $\alpha$ , which is analogous to the MLP adapter in the transformer case, to the internal layers of the CNN. This can be added in series or in parallel, as shown in the diagram. If we denote the adapter layer by $\rho ( { \pmb x } )$ , we can define the series adapter to be

$$
\rho ( { \pmb x } ) = { \pmb x } + \mathrm { d i a g } _ { 1 } ( { \pmb \alpha } ) \circledast { \pmb x } = \mathrm { d i a g } _ { 1 } ( { \bf I } + { \pmb \alpha } ) \circledast { \pmb x }
$$

where $\mathrm { d i a g } _ { 1 } ( { \pmb { \alpha } } ) \in \mathbb { R } ^ { 1 \times 1 \times C \times D }$ reshapes a matrix $\pmb { \alpha } \in \mathbb { R } ^ { C \times D }$ into a matrix that can be applied to each spatial location in parallel. (We have omitted batch normalization for simplicity.) If we insert this after a regular convolution layer $f \circledast x$ we get

$$
{ \pmb y } = \rho ( { \pmb f } \circledast { \pmb x } ) = ( \mathrm { d i a g } _ { 1 } ( { \bf I } + { \pmb \alpha } ) \circledast { \pmb f } ) \circledast { \pmb x }
$$

This can be interpreted as a low-rank multiplicative perturbation to the original filter $f$ . The parallel adapter can be defined by

$$
y = f \circledast x + \mathrm { { d i a g } } _ { 1 } ( \alpha ) \circledast x = \left( f + { \mathrm { d i a g } } _ { L } ( \alpha ) \right) \circledast x
$$

This can be interpreted as a low-rank additive perturbation to the original filter $f$ . In both cases, setting $\alpha = 0$ ensures the adapter layers can be initialized to the identity transformation. In addition, both methods required $O ( C ^ { 2 } )$ parameters per layer.

# 19.2.3 Supervised pre-training

The pre-training task may be supervised or unsupervised; the main requirements are that it can teach the model basic structure about the problem domain and that it is sufficiently similar to the downstream fine-tuning task. The notion of task similarity is not rigorously defined, but in practice the domain of the pre-training task is often more broad than that of the fine-tuning task (e.g., pre-train on all bird species and fine-tune on endangered ones).

The most straightforward form of transfer learning is the case where a large labeled dataset is suitable for pre-training. For example, it is very common to use the ImageNet dataset (Section 1.5.1.2) to pretrain CNNs, which can then be used for an a variety of downstream tasks and datasets (see e.g., [Kol+19]). Imagenet has 1.28 million natural images, each associated with a label from one of 1,000 classes. The classes constitute a wide variety of different concepts, including animals, foods, buildings, musical instruments, clothing, and so on. The images themselves are diverse in the sense

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license that they contain objects from many angles and in many sizes with a wide variety of backgrounds. This diversity and scale may partially explain why it has become a de-facto pre-training task for transfer learning in computer vision. (See finetune_cnn_jax.ipynb for some example code.)

However, Imagenet pre-training has been shown to be less helpful when the domain of the finetuning task is quite different from natural images (e.g. medical images [Rag+19]). And in some cases where it is helpful (e.g., training object detection systems), it seems to be more of a speedup trick (by warm-starting optimization at a good point) rather than something that is essential, in the sense that one can achieve comparable performance on the downstream task when training from scratch, if done for long enough [HGD19].

Supervised pre-training is somewhat less common in non-vision applications. One notable exception is to pre-train on natural language inference data (i.e. whether a sentence implies or contradicts another) to learn vector representations of sentences [Con+17], though this approach has largely been supplanted by unsupervised methods (Section 19.2.4). Another non-vision application of transfer learning is to pre-train a speech recognition on a large English-labeled corpus before fine-tuning on low-resource languages [Ard+20].

# 19.2.4 Unsupervised pre-training (self-supervised learning)

It is increasingly common to use unsupervised pre-training, because unlabeled data is often easy to acquire, e.g., unlabeled images or text documents from the web.

For a short period of time it was common to pre-train deep neural networks using an unsupervised objective (e.g., reconstruction error, as discussed in Section 20.3) over the labeled dataset (i.e. ignoring the labels) before proceeding with standard supervised training [HOT06; Vin+10b; Erh+10]. While this technique is also called unsupervised pre-training, it differs from the form of pre-training for transfer learning we discuss in this section, which uses a (large) unlabeled dataset for pre-training before fine-tuning on a different (smaller) labeled dataset.

Pre-training tasks that use unlabeled data are often called self-supervised rather than unsupervised. This term is used because the labels are created by the algorithm, rather than being provided externally by a human, as in standard supervised learning. Both supervised and self-supervised learning are discriminative tasks, since they require predicting outputs given inputs. By contrast, other unsupervised approaches, such as some of those discussed in Chapter 20, are generative, since they predict outputs unconditionally.

There are many different self-supervised learning heuristics that have been tried (see e.g., [GR18; JT19; Ren19] for a review, and https://github.com/jason718/awesome-self-supervised-learning for an extensive list of papers). We can identify at least three main broad groups, which we discuss below.

# 19.2.4.1 Imputation tasks

One approach to self-supervised learning is to solve imputation tasks. In this approach, we partition the input vector $_ { x }$ into two parts, $\pmb { x } = ( \pmb { x } _ { h } , \pmb { x } _ { v } )$ , and then try to predict the hidden part $_ { x h }$ given the remaining visible part, ${ \bf { \sigma } } _ { x }$ , using a model of the form $\hat { \pmb { x } } _ { h } = f ( \pmb { x } _ { v } , \pmb { x } _ { h } = \mathbf { 0 } )$ . We can think of this as a “fill-in-the-blank” task; in the NLP community, this is called a cloze task. See Figure 19.4 for some visual examples, and Section 15.7.2 for some NLP examples.

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

![](images/fc4ef23fa2792f2f76e39c7814e9883e8deacad07c17d7110ed316099a3a2823.jpg)  
Figure 19.4: (a) Context encoder for self-supervised learning. From [Pat+16]. Used with kind permission of Deepak Pathak. (b) Some other proxy tasks for self-supervised learning. From [LeC18]. Used with kind permission of Yann LeCun.

# 19.2.4.2 Proxy tasks

Another approach to SSL is to solve proxy tasks, also called pretext tasks. In this setup, we create pairs of inputs, $( \pmb { x } _ { 1 } , \pmb { x } _ { 2 } )$ , and then train a Siamese network classifier (Figure 16.5a) of the form $p ( y | \pmb { x } _ { 1 } , \pmb { x } _ { 2 } ) = p ( y | r [ f ( \pmb { x } _ { 1 } ) , f ( \pmb { x } _ { 2 } ) ] )$ , where $f ( { \pmb x } )$ is some function that performs “representation learning” [BCV13], and $y$ is some label that captures the relationship between $\mathbf { \Delta x } _ { 1 }$ and $\scriptstyle { \pmb { x } } _ { 2 }$ , which is predicted by $r ( f _ { 1 } , f _ { 2 } )$ . For example, suppose ${ \bf { x } } _ { 1 }$ is an image patch, and ${ \pmb x } _ { 2 } = t ( { \pmb x } _ { 1 } )$ is some transformation of ${ \bf { x } } _ { 1 }$ that we control, such as a random rotation; then we define $y$ to be the rotation angle that we used [GSK18].

# 19.2.4.3 Contrastive tasks

The currently most popular approach to self-supervised learning is to use various kinds of contrastive tasks. The basic idea is to create pairs of examples that are semantically similar to each other, using data augmentation methods (Section 19.1), and then to ensure that the distance between their representations is closer (in embedding space) than the distance between two unrelated examples. This is exactly the same idea that is used in deep metric learning (Section 16.2.2) — the only difference is that the algorithm creates its own similar pairs, rather than relying on an externally provided measure of similarity, such as labels. We give some examples of this in Section 19.2.4.4 and Section 19.2.4.5.

# 19.2.4.4 SimCLR

In this section, we discuss SimCLR, which stands for “Simple contrastive learning of visual representations” [Che+20b; Che+20c]. This has shown state of the art performance on transfer learning and semi-supervised learning. The basic idea is as follows. Each input $\pmb { x } \in \mathbb { R } ^ { D }$ is converted to two augmented “views’ ${ \pmb x } _ { 1 } = t _ { 1 } ( { \pmb x } )$ , ${ \pmb x } _ { 2 } = t _ { 2 } ( { \pmb x } )$ , which are “semantically equivalent” versions of the input generated by some transformations $t _ { 1 } , t _ { 2 }$ . For example, if $_ { x }$ is an image, these could be small perturbations to the image, such as random crops, as discussed in Section 19.1. In addition, we sample “negative” examples $\pmb { x } _ { 1 } ^ { - } , \ldots , \pmb { x } _ { n } ^ { - } \in N ( \pmb { x } )$ from the dataset which represent “semantically different” images (in practice, these are the other examples in the minibatch). Next we define some feature mapping $F : \mathbb { R } ^ { D }  \mathbb { R } ^ { E }$ , where $D$ is the size of the input, and $E$ is the size of the embedding.

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

![](images/c046c88e05e772874ddc9f377c7ef6d542b995d0a1050d8295b5ec2175d1e176.jpg)  
Figure 19.5: (a) Illustration of SimCLR training. $\tau$ is a set of stochastic semantics-preserving transformations (data augmentations). (b-c) Illustration of the benefit of random crops. Solid rectangles represent the original image, dashed rectangles are random crops. In (b), the model is forced to predict the local view $A$ from the global view B (and vice versa). In (c), the model is forced to predict the appearance of adjacent views (C,D). From Figures 2–3 of [Che+20b]. Used with kind permission of Ting Chen.

![](images/411b613c34f93eddf88eb9b349370b03b80fdd7305b37fdc84c0c5cc97d0d4d2.jpg)  
Figure 19.6: Visualization of SimCLR training. Each input image in the minibatch is randomly modified in two different ways (using cropping (followed by resize), flipping, and color distortion), and then fed into a Siamese network. The embeddings (final layer) for each pair derived from the same image is forced to be close, whereas the embeddings for all other pairs are forced to be far. From https: // ai. googleblog. com/ 2020/ 04/ advancing-self-supervised-and-semi. html . Used with kind permission of Ting Chen.

We then try to maximize the similarity of the similar views, while minimizing the similarity of the different views, for each input $_ { x }$ :

$$
J = F { ( t _ { 1 } ( \pmb { x } ) ) } ^ { \mathsf { T } } F { ( t _ { 2 } ( \pmb { x } ) ) } - \log \sum _ { \pmb { x } _ { i } ^ { - } \in N ( \pmb { x } ) } \exp \left[ F ( \pmb { x } _ { i } ^ { - } ) ^ { \mathsf { T } } F { ( t _ { 1 } ( \pmb { x } ) ) } \right]
$$

In practice, we use cosine similarity, so we $\ell _ { 2 }$ -normalize the representations produced by $F$ before taking inner products, but this is omitted in the above equation. See Figure 19.5a for an illustration. (In this figure, we assume $F ( { \pmb x } ) = g ( r ( { \pmb x } ) )$ , where the intermediate representation $\boldsymbol { h } = \boldsymbol { r } ( \boldsymbol { x } )$ is the one that will be later used for fine-tuning, and $g$ is an additional transformation applied during training.) Interestingly, we can interpret this as a form of conditional energy based model of the form

$$
p ( \pmb { x } _ { 2 } | \pmb { x } _ { 1 } ) = \frac { \exp [ - \mathcal { E } ( \pmb { x } _ { 2 } | \pmb { x } _ { 1 } ) ] } { Z ( \pmb { x } _ { 1 } ) }
$$

where $\mathcal { E } ( { \pmb x } _ { 2 } | { \pmb x } _ { 1 } ) = - F ( { \pmb x } _ { 2 } ) ^ { 1 } F ( { \pmb x } _ { 1 } )$ is the energy, and

$$
Z ( { \pmb x } ) = \int \exp [ - { \mathcal E } ( { \pmb x } ^ { - } | { \pmb x } ) ] d { \pmb x } ^ { - } = \int \exp [ F ( { \pmb x } ^ { - } ) ^ { \top } F ( { \pmb x } ) ] d { \pmb x } ^ { - }
$$

is the normalization constant, known as the partition function. The conditional log likelihood under this model has the form

$$
\log p ( { \pmb x } _ { 2 } | { \pmb x } _ { 1 } ) = F ( { \pmb x } _ { 2 } ) ^ { \top } F ( { \pmb x } _ { 1 } ) - \log \int \exp [ F ( { \pmb x } ^ { - } ) ^ { \top } F ( { \pmb x } _ { 1 } ) ] d { \pmb x } ^ { - }
$$

The only difference from Equation (19.7) is that we replace the integral with a Monte Carlo upper bound derived from the negative samples. Thus we can think of contrastive learning as approximate maximum likelihood estimation of a conditional energy based generative model [Gra+20]. More details on such models can be found in the sequel to this book, [Mur23].

A critical ingredient to the success of SimCLR is the choice of data augmentation methods. By using random cropping, they can force the model to predict local views from global views, as well as to predict adjacent views of the same image (see Figure 19.5). After cropping, all images are resized back to the same size. In addition, they randomly flip the image some fraction of the time.2

SimCLR relies on large batch training, in order to ensure a sufficiently diverse set of negatives. When this is not possible, we can use a memory bank of past (negative) embeddings, which can be updated using exponential moving averaging (Section 4.4.2.2). This is known as momentum contrastive learning or MoCo [He+20].

# 19.2.4.5 CLIP

In this section, we describe CLIP, which stands for “Contrastive Language-Image Pre-training” [Rad+]. This is a contrastive approach to representation learning which uses a massive corpus of

![](images/554568b741f86f29f881ea015b5d1f378d9544d1b813c3b631621b8bc11bb8c5.jpg)  
1. Contrastive pre-training   
2.Createdatasetclassifierfrom label text   
Figure 19.7: Illustration of the CLIP model. From Figure 1 of [Rad+]. Used with kind permission of Alec Radford.

400M (image, text) pairs extracted from the web. Let ${ \boldsymbol { x } } _ { i }$ be the $\textit { \textbf { \ i } }$ ’th image and $\mathbf { \nabla } _ { \mathbf { \boldsymbol { y } } _ { i } }$ be its matching text. Rather than trying to predict the exact words associated with the image, it is simpler to just determine if $\pmb { y } _ { i }$ is more likely to be the correct text compared to ${ \bf { y } } _ { j }$ , for some other text string $j$ in the minibatch. Similarly, the model can try to determine if image ${ \bf { x } } _ { i }$ is more likely to be matched than $\boldsymbol { \mathscr { x } } _ { j }$ to a given text $\mathbf { \nabla } _ { \mathbf { \mathcal { Y } } _ { i } }$ .

More precisely, let ${ f } _ { I } ( { \pmb x } _ { i } )$ be the embedding of the image, $f _ { T } ( \pmb { y } _ { j } )$ be the embedding of the text, $\mathbf { I } _ { i } = { f _ { I } ( \pmb { x } _ { i } ) } / { | | \pmb { f } _ { I } ( \pmb { x } _ { i } ) | | _ { 2 } }$ be the unit-norm version of the image embedding, and $\mathbf { T } _ { j } = { f _ { T } ( \pmb { y } _ { j } ) } / { | | \pmb { f } _ { T } ( \pmb { y } _ { j } ) | | _ { 2 } }$ be the unit-norm version of the text embedding. Define the vector of pairwise logits (similarity scores) to be

$$
{ \cal L } _ { i j } = { \bf \bf { I } } _ { i } ^ { \sf T } { \bf { T } } _ { j }
$$

We now train the parameters of the two embedding functions $f _ { I }$ and $f _ { T }$ to minimize the following loss, averaged over minibatches of size $N$ :

$$
J = \frac { 1 } { 2 } \left[ \sum _ { i = 1 } ^ { N } \mathrm { C E } ( \mathbf { L } _ { i , : } , \mathbf { 1 } _ { i } ) + \sum _ { j = 1 } ^ { N } \mathrm { C E } ( \mathbf { L } _ { : , j } , \mathbf { 1 } _ { j } ) \right]
$$

where CE is the cross entropy loss

$$
\mathrm { C E } ( { \pmb p } , { \pmb q } ) = - \sum _ { k = 1 } ^ { K } p _ { k } \log q _ { k }
$$

and ${ \bf 1 } _ { i }$ is a one-hot encoding of label $i$ . See Figure 19.7a for an illustration. (In practice, the normalized embeddings are scaled by a temperature parameter which is also learned; this controls the sharpness of the softmax.)

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

In their paper, they considered using a ResNet (Section 14.3.4) and a vision transformer (Section 15.5.6) for the function $f _ { I }$ , and a text transformer (Section 15.5) for $f _ { T }$ . They used a very large minibatch of $N \sim 3 2 k$ , and trained for many days on 100s of GPUs.

After the model is trained, it can be used for zero-shot classification of an image $_ { x }$ as follows. First each of the $K$ possible class labels for a given dataset is converted into a text string $\mathbf { \mathcal { { y } } } _ { k }$ that might occur on the web. For example, “dog” becomes “a photo of a dog”. Second, we compute the normalized emebddings $\mathbf { I } \propto f _ { I } ( { \pmb x } )$ and $\mathbf { T } _ { k } \propto \mathbf { f } _ { T } ( \mathbf { \mathbf { y } } _ { k } )$ . Third, we compute the softmax probabilites

$$
p ( \boldsymbol { y } = k | \boldsymbol { x } ) = \mathrm { s o f t m a x } ( [ \mathbf { I } ^ { \mathsf { T } } \mathbf { T } _ { 1 } , \dots , \mathbf { I } ^ { \mathsf { T } } \mathbf { T } _ { k } ] ) _ { k }
$$

See Figure 19.7b for an illustration. (A similar approach was adopted in the visual n-grams paper [Li+17].)

Remarkably, this approach can perform as well as standard supervised learning on tasks such as ImageNet classification, without ever being explicitly trained on specific labeled datasets. Of course, the images in ImageNet come from the web, and were found using text-based web-search, so the model has seen similar data before. Nevertheless, its generalization to new tasks, and robustness to distribution shift, are quite impressive (see the paper for examples).

One drawback of the approach, however, is that it is sensitive to how class labels are converted to textual form. For example, to make the model work on food classification, it is necessary to use text strings of the form “a photo of guacamole, a type of food”, “a photo of ceviche, a type of food”, etc. Disambiguating phrases such as “a type of food” are currently added by hand, on a per-dataset basis. This is called prompt engineering, and is needed since the raw class names can be ambiguous across (and sometimes within) a dataset.

# 19.2.5 Domain adaptation

Consider a problem in which we have inputs from different domains, such as a source domain $\mathcal { X } _ { s }$ and target domain $\mathcal { X } _ { t }$ , but a common set of output labels, $_ { \mathcal { V } }$ . (This is the “dual” of transfer learning, since the input domains are different, but the output domains the same.) For example, the domains might be images from a computer graphics system and real images, or product reviews and movie reviews. We assume we do not have labeled examples from the target domain. Our goal is to fit the model on the source domain, and then modify its parameters so it works on the target domain. This is called (unsupervised) domain adaptation (see e.g., [KL21] for a review).

A common approach to this problem is to train the source classifier in such a way that it cannot distinguish whether the input is coming from the source or target distribution; in this case, it will only be able to use features that are common to both domains. This is called domain adversarial learning [Gan+16]. More formally, let $d _ { n } \in \{ s , t \}$ be a label that specifies if the data example $n$ comes from domain $s$ or $t$ . We want to optimize

$$
\operatorname* { m i n } _ { \phi } \operatorname* { m a x } _ { \theta } \frac { 1 } { N _ { s } + N _ { t } } \sum _ { n \in \mathcal { D } _ { s } , \mathcal { D } _ { t } } \ell ( d _ { n } , f _ { \theta } ( \pmb { x } _ { n } ) ) + \frac { 1 } { N _ { s } } \sum _ { m \in \mathcal { D } _ { s } } \ell ( y _ { m } , g _ { \phi } ( f _ { \theta } ( \pmb { x } _ { m } ) ) )
$$

where $N _ { s } ~ = ~ | D _ { s } |$ , $N _ { t } ~ = ~ | D _ { t } |$ , $f$ maps $\mathcal { X } _ { s } \cup \mathcal { X } _ { t } \to \mathcal { H }$ , and $g$ maps $\mathcal { H }  \mathcal { V } _ { t }$ . The objective in Equation (19.15) minimizes the loss on the desired task of classifying $y$ , but maximizes the loss on the auxiliary task of classifying the source domain $d$ . This can be implemented by the gradient sign reversal trick, and is related to GANs (generative adversarial networks). See e.g., [Csu17; Wu+19] for some other approaches to domain adaptation.

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

![](images/95c3e3a7b1f32d928f24a66e040c48cf7e31e470e3626732471e0c596cdba8e1.jpg)  
Figure 19.8: Illustration of the benefits of semi-supervised learning for a binary classification problem. Labeled points from each class are shown as black and white circles respectively. (a) Decision boundary we might learn given only labeled data. (b) Decision boundary we might learn if we also had a lot of unlabeled data points, shown as smaller grey circles.

# 19.3 Semi-supervised learning

This section is co-authored with Colin Raffel.

Many recent successful applications of machine learning are in the supervised learning setting, where a large dataset of labeled examples are available for training a model. However, in many practical applications it is expensive to obtain this labeled data. Consider the case of automatic speech recognition: Modern datasets contain thousands of hours of audio recordings [Pan+15; Ard+20]. The process of annotating the words spoken in a recording is many times slower than realtime, potentially resulting in a long (and costly) annotation process. To make matters worse, in some applications data must be labeled by an expert (such as a doctor in medical applications) which can further increase costs.

Semi-supervised learning can alleviate the need for labeled data by taking advantage of unlabeled data. The general goal of semi-supervised learning is to allow the model to learn the high-level structure of the data distribution from unlabeled data and only rely on the labeled data for learning the fine-grained details of a given task. Whereas in standard supervised learning we assume that we have access to samples from the joint distribution of data and labels $\pmb { x } , y \sim p ( \pmb { x } , y )$ , semi-supervised learning assumes that we additionally have access to samples from the marginal distribution of $_ { x }$ , namely $\mathbf { \boldsymbol { x } } \sim p ( \mathbf { \boldsymbol { x } } )$ , as illustrated in Figure 19.8. Further, it is generally assumed that we have many more of these unlabeled samples since they are typically cheaper to obtain. Continuing the example of automatic speech recognition, it is often much cheaper to simply record people talking (which would produce unlabeled data) than it is to transcribe recorded speech. Semi-supervised learning is a good fit for the scenario where a large amount of unlabeled data has been collected and the practitioner would like to avoid having to label all of it.

# 19.3.1 Self-training and pseudo-labeling

An early and straightforward approach to semi-supervised learning is self-training [Scu65; Agr70; McL75]. The basic idea behind self-training is to use the model itself to infer predictions on unlabeled

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022 data, and then treat these predictions as labels for subsequent training. Self-training has endured as a semi-supervised learning method because of its simplicity and general applicability; i.e. it is applicable to any model that can generate predictions for the unlabeled data. Recently, it has become common to refer to this approach as “pseudo-labeling” [Lee13] because the inferred labels for unlabeled data are only “pseudo-correct” in comparison with the true, ground-truth targets used in supervised learning.

Algorithmically, self-training typically follows one of the following two procedures. In the first approach, pseudo-labels are first predicted for the entire collection of unlabeled data and the model is re-trained (possibly from scratch) to convergence on the combination of the labeled and (pseudolabeled) unlabeled data. Then, the unlabeled data is re-labeled by the model and the process repeats itself until a suitable solution is found. The second approach instead continually generates predictions on randomly-chosen batches of unlabeled data and immediately trains the model against these pseudo-labels. Both approaches are currently common in practice; the first “offline” variant has been shown to be particularly successful when leveraging giant collections of unlabeled data [Yal+19; Xie+20] whereas the “online” approach is often used as one component of more sophisticated semisupervised learning methods [Soh+20]. Neither variant is fundamentally better than the other. Offline self-training can result in training the model on “stale” pseudo-labels, since they are only updated each time the model converges. However, online pseudo-labeling can incur larger computational costs since it involves constantly “re-labeling” unlabeled data.

Self-training can suffer from an obvious problem: If the model generates incorrect predictions for unlabeled data and then is re-trained on these incorrect predictions, it can become progressively worse and worse at the intended classification task until it eventually learns a totally invalid solution. This issue has been dubbed confirmation bias [TV17] because the model is continually confirming its own (incorrect) bias about the decision rule.

A common way to mitigate confirmation bias is to use a “selection metric” [RHS05] which heuristically tries to only retain pseudo-labels that are correct. For example, assuming that a model outputs probabilities for each possible class, a frequently-used selection metric is to only retain pseudo-labels whose largest class probability is above a threshold [Yar95; RHS05]. If the model’s class probability estimates are well-calibrated, then this selection metric will only retain labels that are highly likely to be correct (according to the model, at least). More sophisticated selection metrics can be designed according to the problem domain.

# 19.3.2 Entropy minimization

Self-training has the implicit effect of encouraging the model to output low-entropy (i.e. highconfidence) predictions. This effect is most apparent in the online setting with a cross-entropy loss, where the model minimizes the following loss function $\mathcal { L }$ on unlabeled data:

$$
\mathcal { L } = - \operatorname* { m a x } _ { c } \log p _ { \theta } ( y = c | \pmb { x } )
$$

where $p _ { \theta } ( y | \mathbf { \boldsymbol { x } } )$ is the model’s class probability distribution given input $_ { x }$ . This function is minimized when the model assigns all of its class probability to a single class $c ^ { * }$ , i.e. $p ( y = c ^ { * } | x ) = 1$ and $p ( y \neq c ^ { * } | x ) = 0$ .

A closely-related semi-supervised learning method is entropy minimization [GB05], which

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

![](images/79b064eac027a31fcd2947946a4e5a2ece61ff1c6b9506ddfd2a53bac6b4a8d1.jpg)  
Figure 19.9: Comparison of the entropy minimization, self-training, and “sharpened” entropy minimization loss functions for a binary classification problem.

minimizes the following loss function:

$$
\mathcal { L } = - \sum _ { c = 1 } ^ { C } p _ { \theta } ( y = c \vert x ) \log p _ { \theta } ( y = c \vert x )
$$

Note that this function is also minimized when the model assigns all of its class probability to a single class. We can make the entropy-minimization loss in Equation (19.17) equivalent to the online self-training loss in Equation (19.16) by replacing the first $p _ { \theta } ( y = c | \mathbf { x } )$ term with a “one-hot” vector that assigns a probability of 1 for the class that was assigned the highest probability. In other words, online self-training minimizes the cross-entropy between the model’s output and the “hard” target arg max $p _ { \theta } ( y | \mathbf { \boldsymbol { x } } )$ , whereas entropy minimization uses the the “soft” target $p _ { \theta } ( y | \mathbf { \boldsymbol { x } } )$ . One way to trade off between these two extremes is to adjust the “temperature” of the target distribution by raising each probability to the power of $1 / T$ and renormalizing; this is the basis of the mixmatch method of [Ber+19b; Ber+19a; Xie+19]. At $T = 1$ , this is equivalent to entropy minimization; as $T  0$ , it becomes hard online self-training. A comparison of these loss functions is shown in Figure 19.9.

# 19.3.2.1 The cluster assumption

Why is entropy minimization a good idea? A basic assumption of many semi-supervised learning methods is that the decision boundary between classes should fall in a low-density region of the data manifold. This effectively assumes that the data corresponding to different classes are clustered together. A good decision boundary, therefore, should not pass through clusters; it should simply separate them. Semi-supervised learning methods that make the “cluster assumption” can be thought of as using unlabeled data to estimate the shape of the data manifold and moving the decision boundary away from it.

Entropy minimization is one such method. To see why, first assume that the decision boundary between two classes is “smooth”, i.e. the model does not abruptly change its class prediction anywhere in its domain. This is true in practice for simple and/or regularized models. In this case, if the decision boundary passes through a high-density region of data, it will by necessity produce highentropy predictions for some samples from the data distribution. Entropy minimization will therefore encourage the model to place its decision boundary in low-density regions of the input space to

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022 avoid transitioning from one class to another in a region of space where data may be sampled. A visualization of this behavior is shown in Figure 19.10.

![](images/b31051c37e3d15daad9c2910d03f72ce5c9613c441bc7ee2e2d2648e9f5f7504.jpg)  
Figure 19.10: Visualization demonstrating how entropy minimization enforces the cluster assumption. The classifier assigns a higher probability to class 1 (black dots) or 2 (white dots) in red or blue regions respectively. The predicted class probabilities for one particular unlabeled datapoint is shown in the bar plot. In (a), the decision boundary passes through high-density regions of data, so the classifier is forced to output high-entropy predictions. In (b), the classifier avoids high-density regions and is able to assign low-entropy predictions to most of the unlabeled data.

# 19.3.2.2 Input-output mutual information

An alternative justification for the entropy minimization objective was proposed by Bridle, Heading, and MacKay [BHM92], where it was shown that it naturally arises from maximizing the mutual information (Section 6.3) between the data and the label (i.e. the input and output of a model). Denoting $_ { x }$ as the input and $y$ as the target, the input-output mutual information can be written as

$$
\begin{array} { l } { \displaystyle \mathcal { Z } ( y ; x ) = \iint p ( y , x ) \log \frac { p ( y , x ) } { p ( y ) p ( x ) } d y d x } \\ { \displaystyle = \iint p ( y | x ) p ( x ) \log \frac { p ( y , x ) } { p ( y ) p ( x ) } d y d x } \\ { \displaystyle = \int p ( x ) d x \int p ( y | x ) \log \frac { p ( y | x ) } { p ( y ) } d y } \\ { \displaystyle = \int p ( x ) d x \int p ( y | x ) \log \frac { p ( y | x ) } { \int p ( x ) p ( y | x ) d x } d y } \end{array}
$$

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

Note that the first integral is equivalent to taking an expectation over $_ { x }$ , and the second integral is equivalent to summing over all possible values of the class $y$ . Using these relations, we obtain

$$
\begin{array} { l l l } { \displaystyle \mathbb { Z } ( y ; \pmb { x } ) = \mathbb { E } _ { \pmb { x } } \left[ \sum _ { i = 1 } ^ { L } p ( y _ { i } | \pmb { x } ) \log \frac { p ( y _ { i } | \pmb { x } ) } { \mathbb { E } _ { \pmb { x } } [ p ( y _ { i } | \pmb { x } ) ] } \right] } \\ { \displaystyle \qquad = \mathbb { E } _ { \pmb { x } } \left[ \sum _ { i = 1 } ^ { L } p ( y _ { i } | \pmb { x } ) \log p ( y _ { i } | \pmb { x } ) \right] - \mathbb { E } _ { \pmb { x } } \left[ \sum _ { i = 1 } ^ { L } p ( y _ { i } | \pmb { x } ) \log \mathbb { E } _ { \pmb { x } } [ p ( y _ { i } | \pmb { x } ) ] \right] } \\ { \displaystyle \qquad = \mathbb { E } _ { \pmb { x } } \left[ \sum _ { i = 1 } ^ { L } p ( y _ { i } | \pmb { x } ) \log p ( y _ { i } | \pmb { x } ) \right] - \sum _ { i = 1 } ^ { L } \mathbb { E } _ { \pmb { x } } [ p ( y _ { i } | \pmb { x } ) \log \mathbb { E } _ { \pmb { x } } [ p ( y _ { i } | \pmb { x } ) ] ] } \end{array}
$$

Since we had initially sought to maximize the mutual information, and we typically minimize loss functions, we can convert this to a suitable loss function by negating it:

$$
\mathcal { Z } ( y ; x ) = - \mathbb { E } _ { x } \left[ \sum _ { i = 1 } ^ { L } p ( y _ { i } | x ) \log p ( y _ { i } | x ) \right] + \sum _ { i = 1 } ^ { L } \mathbb { E } _ { x } [ p ( y _ { i } | x ) \log \mathbb { E } _ { x } [ p ( y _ { i } | x ) ] ]
$$

The first term is exactly the entropy minimization objective in expectation. The second term specifies that we should maximize the entropy of the expected class prediction, i.e. the average class prediction over our training set. This encourages the model to predict each possible class with equal probability, which is only appropriate when we know a priori that all classes are equally likely.

# 19.3.3 Co-training

Co-training [BM98] is also similar to self-training, but makes an additional assumption that there are two complementary “views” (i.e. independent sets of features) of the data, both of which can be used separately to train a reasonable model. After training two models separately on each view, unlabeled data is classified by each model to obtain candidate pseudo-labels. If a particular pseudolabel receives a low-entropy prediction (indicating high confidence) from one model and a high-entropy prediction (indicating low confidence) from the other, then that pseudo-labeled datapoint is added to the training set for the low-confidence model. Then, the process is repeated with the new, larger training datasets. The procedure of only retaining pseudo-labels when one of the models is confident ideally builds up the training sets with correctly-labeled data.

Co-training makes the strong assumption that there are two informative-but-independent views of the data, which may not be true for many problems. The Tri-Training algorithm [ZL05] circumvents this issue by instead using three models that are first trained on independently-sampled (with replacement) subsets of the labeled data. Ideally, initially training on different collections of labeled data results in models that do not always agree on their predictions. Then, pseudo-labels are generated for the unlabeled data independently by each of the three models. For a given unlabeled datapoint, if two of the models agree on the pseudo-label, it is added to the training set for the third model. This can be seen as a selection metric, because it only retains pseudo-labels where two (differently initialized) models agree on the correct label. The models are then re-trained on the combination of the labeled data and the new pseudo-labels, and the whole process is repeated iteratively.

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

# 19.3.4 Label propagation on graphs

If two datapoints are “similar” in some meaningful way, we might expect that they share a label. This idea has been referred to as the manifold assumption. Label propagation is a semi-supervised learning technique that leverages the manifold assumption to assign labels to unlabeled data. Label propagation first constructs a graph where the nodes are the data examples and the edge weights represent the degree of similarity. The node labels are known for nodes corresponding to labeled data but are unknown for unlabeled data. Label propagation then propagates the known labels across edges of the graph in such a way that there is minimal disagreement in the labels of a given node’s neighbors. This provides label guesses for the unlabeled data, which can then be used in the usual way for supervised training of a model.

More specifically, the basic label propagation algorithm [ZG02] proceeds as follows: First, let $w _ { i , j }$ denote a non-negative edge weight between ${ \boldsymbol { x } } _ { i }$ and $\boldsymbol { \mathscr { x } } _ { j }$ that provides a measure of similarity for the two (labeled or unlabeled) datapoints. Assuming that we have $M$ labeled datapoints and $N$ unlabeled datapoints, define the $( M + N ) \times ( M + N )$ transition matrix $\mathbf { T }$ as having entries

$$
\mathbf { T } _ { i , j } = \frac { w _ { i , j } } { \sum _ { k } w _ { k , j } }
$$

$\mathbf { T } _ { i , j }$ represents the probability of propagating the label for node $j$ to node $i$ . Further, define the $( M + N ) \times C$ label matrix $\mathbf { Y }$ , where $C$ is the number of possible classes. The $i$ th row of $\mathbf { Y }$ represents the class probability distribution of datapoint $i$ . Then, repeat the following steps until the values in $\mathbf { Y }$ do not change significantly: First, use the transition matrix $\mathbf { T }$ to propagate labels in $\mathbf { Y }$ by setting $\mathbf { Y }  \mathbf { T Y }$ . Then, re-normalize the rows of Y by setting $\mathbf { Y } _ { i , c }  \mathbf { Y } _ { i , c } / \sum _ { k } \mathbf { Y } _ { i , k }$ . Finally, replace the rows of $\mathbf { Y }$ corresponding to labeled datapoints with their one-hot representation (i.e. $\mathbf { Y } _ { i , c } = 1$ if datapoint $i$ has ground-truth label $c$ and 0 otherwise). After convergence, guessed labels are chosen based on the highest class probability for each datapoint in $\mathbf { Y }$ .

This algorithm iteratively uses the similarity of datapoints (encoded in the weights used to construct the transition matrix) to propagate information from the (fixed) labels onto the unlabeled data. At each iteration, the label distribution for a given datapoint is computed as the weighted average of the label distributions for all of its connected datapoints, where the weighting corresponds to the edge weights in $\mathbf { T }$ . It can be shown that this procedure converges to a single fixed point, whose computational cost mainly involves the inversion of the matrix of unlabled-to-unlabled transition probabilities [ZG02].

The overall approach can be seen as a form of transductive learning, since it is learning to predict labels for a fixed unlabeled dataset, rather than learning a model that generalizes. However, given the induced labeling. we can perform inductive learning in the usual way.

The success of label propagation depends heavily on the notion of similarity used to construct the weights between different nodes (datapoints). For simple data, measuring the Euclidean distance between datapoints can be sufficient. However, for complex and high-dimensional data the Euclidean distance might not meaningfully reflect the likelihood that two datapoints share the same class. The similarity weights can also be set arbitrarily according to problem-specific knowledge. For a few examples of different ways of constructing the similarity graph, see Zhu [Zhu05, chapter 3]. For some recent papers that use this approach in conjunction with deep learning, see e.g., [BRR18; Isc+19].

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

# 19.3.5 Consistency regularization

Consistency regularization leverages the simple idea that perturbing a given datapoint (or the model itself) should not cause the model’s output to change dramatically. Since measuring consistency in this way only makes use of the model’s outputs (and not ground-truth labels), it is readily applicable to unlabeled data and therefore can be used to create appropriate loss functions for semi-supervised learning. This idea was first proposed under the framework of “learning with pseudo-ensembles” [BAP14], with similar variants following soon thereafter [LA16; SJT16].

In its most general form, both the model $p _ { \theta } ( y | \mathbf { \boldsymbol { x } } )$ and the transformations applied to the input can be stochastic. For example, in computer vision problems we may transform the input by using data augmentation like randomly rotating or adding noise the input image, and the network may include stochastic components like dropout (Section 13.5.4) or weight noise [Gra11]. A common and simple form of consistency regularization first samples ${ \pmb x } ^ { \prime } \sim q ( { \pmb x } ^ { \prime } | { \pmb x } )$ (where $q ( { \pmb x } ^ { \prime } | { \pmb x } )$ is the distribution induced by the stochastic input transformations) and then minimizes the loss $\| p _ { \boldsymbol { \theta } } ( y | \mathbf { x } ) - p _ { \boldsymbol { \theta } } ( y | \mathbf { x } ^ { \prime } ) \| ^ { 2 }$ . In practice, the first term $p _ { \theta } ( y | \mathbf { \boldsymbol { x } } )$ is typically treated as fixed (i.e. gradients are not propagated through it). In the semi-supervised setting, the combined loss function over a batch of labeled data $( { \pmb x } _ { 1 } , y _ { 1 } ) , ( { \pmb x } _ { 2 } , y _ { 2 } ) , \dots , ( { \pmb x } _ { M } , y _ { M } )$ and unlabeled data ${ \pmb x } _ { 1 } , { \pmb x } _ { 2 } , \ldots , { \pmb x } _ { N }$ is

$$
\mathcal { L } ( \pmb { \theta } ) = - \sum _ { i = 1 } ^ { M } \log p _ { \pmb { \theta } } ( \pmb { y } = y _ { i } | \pmb { x _ { i } } ) + \lambda \sum _ { j = 1 } ^ { N } \| p _ { \pmb { \theta } } ( \pmb { y } | \pmb { x _ { j } } ) - p _ { \pmb { \theta } } ( \pmb { y } | \pmb { x _ { j } ^ { \prime } } ) \| ^ { 2 }
$$

where $\lambda$ is a scalar hyperparameter that balances the importance of the loss on unlabeled data and, for simplicity, we write $\pmb { x } _ { j } ^ { \prime }$ to denote a sample drawn from $q ( \pmb { x } ^ { \prime } | \pmb { x } _ { j } )$ .

The basic form of consistency regularization in Equation (19.27) reveals many design choices that impact the success of this semi-supervised learning approach. First, the value chosen for the $\lambda$ hyperparameter is important. If it is too large, then the model may not give enough weight to learning the supervised task and will instead start to reinforce its own bad predictions (as with confirmation bias in self-training). Since the model is often poor at the start of training before it has been trained on much labeled data, it is common in practice to initialize set $\lambda$ to zero and increase its value over the course of training.

A second important consideration are the random transformations applied to the input, i.e., $q ( { \pmb x } ^ { \prime } | { \pmb x } )$ . Generally speaking, these transformations should be designed so that they do not change the label of $_ { x }$ . As mentioned above, a common choice is to use domain-specific data augmentations. It has recently been shown that using strong data augmentations that heavily corrupt the input (but, arguably, still do not change the label) can produce particularly strong results [Xie+19; Ber+19a; Soh+20].

The use of data augmentation requires expert knowledge to determine what kinds of transformations are label-preserving and appropriate for a given problem. An alternative technique, called virtual adversarial training (VAT), instead transforms the input using an analytically-found perturbation designed to maximally change the model’s output. Specifically, VAT computes a perturbation $\pmb { \delta }$ that approximates $\begin{array} { r } { \delta = \mathrm { a r g m a x } _ { \delta } D _ { \mathbb { K L } } \left( p _ { \theta } ( y | \pmb { x } ) \parallel p _ { \theta } ( y | \pmb { x } + \pmb { \delta } ) \right) } \end{array}$ . The approximation is done by sampling $\textbf { \em d }$ from a multivariate Gaussian distribution, initializing $\delta = d$ , and then setting

$$
\delta \gets \nabla _ { \delta } D _ { \mathbb { K L } } \left( p _ { \theta } ( y | \pmb { x } ) \parallel p _ { \theta } ( y | \pmb { x } + \delta ) \right) | _ { \delta = \xi d }
$$

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

![](images/03cc60f835c420e0f1280d331fd7d3ef1457b0b3f127307af5641aa4c5c9202e.jpg)

Figure 19.11: Comparison of the squared error and KL divergence lossses for a consistency regularization. This visualization is for a binary classification problem where it is assumed that the model’s output for the unperturbed input is 1. The figure plots the loss incurred for a particular value of the logit (i.e. the pre-activation fed into the output sigmoid nonlinearity) for the perturbed input. As the logit grows towards infinity, the model predicts a class label of 1 (in agreement with the prediction for the unperturbed input); as it grows towards negative infinity, the model predictions class 0. The squared error loss saturates (and has zero gradients) when the model predicts one class or the other with high probability, but the KL divergence grows without bound as the model predicts class 0 with more and more confidence.

where $\xi$ is a small constant, typically $1 0 ^ { - 6 }$ . VAT then sets

$$
\pmb { x } ^ { \prime } = \pmb { x } + \epsilon \frac { \delta } { \lVert \pmb { \delta } \rVert _ { 2 } }
$$

and proceeds as usual with consistency regularization (as in Equation (19.27)), where $\epsilon$ is a scalar hyperparameter that sets the L2-norm of the perturbation applied to $_ { x }$ .

Consistency regularization can also profoundly affect the geometry properties of the training objective, and the trajectory of SGD, such that performance can particularly benefit from nonstandard training procedures. For example, the Euclidean distances between weights at different training epochs is significantly larger for objectives that use consistency regularization. Athiwaratkun et al. [Ath+19] show that a variant of stochastic weight averaging (SWA) [Izm+18] can achieve state-of-the-art performance on semi-supervised learning tasks by exploiting the geometric properties of consistency regularization.

A final consideration when using consistency regularization is the function used to measure the difference between the network’s output with and without perturbations. Equation (19.27) uses the squared L2 distance (also referred to as the Brier score), which is a common choice [SJT16; TV17; LA16; Ber+19b]. It is also common to use the KL divergence $D _ { \mathbb { K } \mathbb { L } } ( p _ { \theta } ( y | \pmb { x } ) ~ \| ~ p _ { \theta } ( y | \pmb { x } ^ { \prime } )$ in analogy with the cross-entropy loss (i.e. KL divergence between ground-truth label and prediction) used for labeled examples [Miy+18; Ber+19a; Xie+19]. The gradient of the squared-error loss approaches zero as the model’s predictions on the perturbed and unperturbed input differ more and more, assuming the model uses a softmax nonlinearity on its output. Using the squared-error loss therefore has a possible advantage that the model is not updated when its predictions are very unstable. However, the KL divergence has the same scale as the cross-entropy loss used for labeled data, which makes for more intuitive tuning of the unlabeled loss hyperparameter $\lambda$ . A comparison of the two loss functions is shown in Figure 19.11.

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

# 19.3.6 Deep generative models \*

Generative models provide a natural way of making use of unlabeled data through learning a model of the marginal distribution by minimizing $\begin{array} { r } { \mathcal { L } _ { U } = - \sum _ { n } \log p _ { \pmb { \theta } } ( \pmb { x } _ { n } ) } \end{array}$ . Various approaches have leveraged generative models for semi-supervised by developing ways to use the model of $p _ { \pmb { \theta } } ( \pmb { x } _ { n } )$ to help produce a better supervised model.

# 19.3.6.1 Variational autoencoders

In Section 20.3.5, we describe the variational autoencoder (VAE), which defines a probabilistic model of the joint distribution of data $_ { x }$ and latent variables $\boldsymbol { z }$ . Data is assumed to be generated by first sampling $z \sim p ( z )$ and then sampling $\begin{array} { r } { \pmb { x } \sim p ( \pmb { x } | \pmb { z } ) } \end{array}$ . For learning, the VAE uses an encoder $\pmb { q } _ { \lambda } ( \pmb { z } | \pmb { x } )$ to approximate the posterior and a decoder $p _ { \theta } ( { \pmb x } | z )$ to approximate the likelihood. The encoder and decoder are typically deep neural networks. The parameters of the encoder and decoder can be jointly trained by maximizing the evidence lower bound (ELBO) of data.

The marginal distribution of latent variables $p ( z )$ is often chosen to be a simple distribution like a diagonal-covariance Gaussian. In practice, this can make the latent variables $\mathscr { z }$ more amenable to downstream classification thanks to the facts that $\mathscr { z }$ is typically lower-dimensional than $_ { x }$ , that $\boldsymbol { z }$ is constructed via cascaded nonlinear transformations, and that the dimensions of the latent variables are designed to be independent. In other words, the latent variables can provide a (learned) representation where data may be more easily separable. In [Kin+14], this approach is called M1 and it is indeed shown that the latent variables can be used to train stronger models when labels are scarce. (The general idea of unsupervised learning of representations to help with downstream classification tasks is described further in Section 19.2.4.)

An alternative approach to leveraging VAEs, also proposed in [Kin+14] and called M2, has the form

$$
p _ { \theta } ( x , y ) = p _ { \theta } ( y ) p _ { \theta } ( x | y ) = p _ { \theta } ( y ) \int p _ { \theta } ( x | y , z ) p _ { \theta } ( z ) d z
$$

where $\mathscr { z }$ is a latent variable, $\begin{array} { r } { p _ { \pmb { \theta } } ( z ) = \mathcal { N } ( z | \pmb { \mu } _ { \pmb { \theta } } , \pmb { \Sigma } _ { \pmb { \theta } } ) } \end{array}$ is the latent prior (typically we fix $\mu _ { \theta } = 0$ and $\Sigma _ { \theta } = \mathbf { I }$ ), $p _ { \pmb { \theta } } ( y ) = \mathrm { C a t } ( y | \pmb { \pi } _ { \pmb { \theta } } )$ the label prior, and $p _ { \pmb \theta } ( \pmb x | y , z ) = p ( \pmb x | f _ { \pmb \theta } ( y , z ) )$ is the likelihood, such as a Gaussian, with parameters computed by $f$ (a deep neural network). The main innovation of this approach is to assume that data is generated according to both a latent class variable $y$ as well as the continuous latent variable $_ { z }$ . The class variable $y$ is observed for labeled data and unobserved for unlabled data.

To compute the likelihood for the labeled data, $p _ { \pmb { \theta } } ( \pmb { x } , \pmb { y } )$ , we need to marginalize over $\boldsymbol { z }$ , which we can do by using an inference network of the form

$$
q _ { \phi } ( z | y , \pmb { x } ) = \mathcal { N } ( z | \pmb { \mu } _ { \phi } ( y , \pmb { x } ) , \mathrm { d i a g } ( \sigma _ { \phi } ^ { 2 } ( \pmb { x } ) )
$$

We then use the following variational lower bound

$$
\begin{array} { r } { \pmb { x } , y ) \geq \mathbb { E } _ { q _ { \phi } ( z | \pmb { x } , y ) } \left[ \log p _ { \theta } ( \pmb { x } | y , z ) + \log p _ { \theta } ( y ) + \log p _ { \theta } ( z ) - \log q _ { \phi } ( z | \pmb { x } , y ) \right] = - } \end{array}
$$

as is standard for VAEs (see Section 20.3.5). The only difference is that we observe two kinds of data: $_ { x }$ and $y$ .

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

To compute the likelihood for the unlabeled data, $p _ { \pmb { \theta } } ( \pmb { x } )$ , we need to marginalize over $\boldsymbol { z }$ and $y$ , which we can do by using an inference network of the form

$$
\begin{array} { r l } & { q _ { \phi } ( z , y | { \pmb x } ) = q _ { \phi } ( z | { \pmb x } ) q _ { \phi } ( y | { \pmb x } ) } \\ & { \quad q _ { \phi } ( z | { \pmb x } ) = \mathcal { N } ( z | \mu _ { \phi } ( { \pmb x } ) , \mathrm { d i a g } ( \sigma _ { \phi } ^ { 2 } ( { \pmb x } ) ) } \\ & { \quad q _ { \phi } ( y | { \pmb x } ) = \mathrm { C a t } ( y | \pi _ { \phi } ( { \pmb x } ) ) } \end{array}
$$

Note that $q _ { \phi } ( y | \mathbf { x } )$ acts like a discriminative classifier, that imputes the missing labels. We then use the following variational lower bound:

$$
\begin{array} { r l } & { \log p _ { \theta } ( x ) \geq \mathbb { E } _ { q _ { \phi } ( z , y | x ) } \left[ \log p _ { \theta } ( x | y , z ) + \log p _ { \theta } ( y ) + \log p _ { \theta } ( z ) - \log q _ { \phi } ( z , y | x ) \right] } \\ & { \qquad = - \displaystyle \sum _ { y } q _ { \phi } ( y | x ) \mathcal { L } ( x , y ) + \mathbb { H } \left( q _ { \phi } ( y | x ) \right) = - \mathcal { U } ( x ) } \end{array}
$$

Note that the discriminative classifier $q _ { \phi } ( y | \mathbf { x } )$ is only used to compute the log-likelihood of the unlabeled data, which is undesirable. We can therefore add an extra classification loss on the supervised data, to get the following overall objective function:

$$
\mathcal { L } ( \pmb { \theta } ) = \mathbb { E } _ { ( \pmb { x } , \pmb { y } ) \sim \mathcal { D } _ { L } } \left[ \mathcal { L } ( \pmb { x } , \pmb { y } ) \right] + \mathbb { E } _ { \pmb { x } \sim \mathcal { D } _ { U } } \left[ \mathcal { U } ( \pmb { x } ) \right] + \alpha \mathbb { E } _ { ( \pmb { x } , \pmb { y } ) \sim \mathcal { D } _ { L } } \left[ - \log q _ { \phi } ( \pmb { y } | \pmb { x } ) \right]
$$

where $\alpha$ is a hyperparameter that controls the relative weight of generative and discriminative learning.

Of course, the probablistic model used in M2 is just one of many ways to decompose the dependencies between the observed data, the class labels, and the continuous latent variables. There are also many ways other than variational inference to perform approximate inference. The best technique will be problem dependent, but overall the main advantage of the generative approach is that we can incorporate domain knowledge. For example, we can model the missing data mechanism, since the absence of a label may be informative about the underlying data (e.g., people may be reluctant to answer a survey question about their health if they are unwell).

# 19.3.6.2 Generative adversarial networks

Generative adversarial networks (GANs) (described in more detail in the sequel to this book, [Mur23]) are a popular class of generative models that learn an implicit model of the data distribution. They consist of a generator network, which maps samples from a simple latent distribution to the data space, and a critic network, which attempts to distinguish between the outputs of the generator and samples from the true data distribution. The generator is trained to generate samples that the critic classifies as “real”.

Since standard GANs do not produce a learned latent representation of a given datapoint and do not learn an explicit model of the data distribution, we cannot use the same approaches as were used for VAEs. Instead, semi-supervised learning with GANs is typically done by modifying the critic so that it outputs either a class label or “fake” instead of simply classifying real vs. fake [Sal+16; Ode16]. For labeled real data, the critic is trained to output the appropriate class label, and for unlabeled real data, it is trained to raise the probability of any of the class labels. As with standard GAN training, the critic is trained to classify outputs from the generator as fake and the generator is trained to fool the critic.

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

![](images/2f31a630cc62b9bd824eafae8c6c1a47ffafb1160a3ea6658655e4ec7dd97a3e.jpg)  
Figure 19.12: Diagram of the semi-supervised GAN framework. The discriminator is trained to output the class of labeled datapoints (red), a “fake” label for outputs from the generator (yellow), and any label for unlabeled data (green).

In more detail, let $p _ { \theta } ( y | \mathbf { \boldsymbol { x } } )$ denote the critic with $C + 1$ outputs corresponding to $C$ classes plus a “fake” class, and let $G ( z )$ denote the generator which takes as input samples from the prior distribution $p ( z )$ . Let us assume that we are using the standard cross-entropy GAN loss as originally proposed in [Goo+14]. Then the critic’s loss is

$$
{ \ L } _ { \sim p ( x , y ) } \log p _ { \theta } ( y | x ) - \mathbb { E } _ { x \sim p ( x ) } \log [ 1 - p _ { \theta } ( y = C + 1 | x ) ] - \mathbb { E } _ { z \sim p ( z ) } \log p _ { \theta } ( y = C + 1 | x ) ,
$$

This tries to maximize the probability of the correct class for the labeled examples, to minimize the probability of the fake class for real unlabeled examples, and to maximize the probability of the fake class for generated examples. The generator’s loss is simpler, namely

$$
\mathbb { E } _ { z \sim p ( z ) } \log p _ { \theta } ( y = C + 1 | G ( z ) )
$$

A diagram visualizing the semi-supervised GAN framework is shown in Figure 19.12.

# 19.3.6.3 Normalizing flows

Normalizing flows (described in more detail in the sequel to this book, [Mur23]) are a tractable way to define deep generative models. More precisely, they define an invertible mapping $f _ { \theta } : \mathcal { X }  \mathcal { Z }$ , with parameters $\theta$ , from the data space $\mathcal { X }$ to the latent space $\mathcal { Z }$ . The density in data space can be written starting from the density in the latent space using the change of variables formula:

$$
p ( x ) = p ( f ( x ) ) \cdot \left| { \operatorname* { d e t } \left( \frac { \partial f } { \partial x } \right) } \right| .
$$

We can extend this to semi-supervised learning, as proposed in [Izm+20]. For class labels $y \in \{ 1 \ldots { \mathcal { C } } \}$ , we can specify the latent distribution, conditioned on a label $k$ , as Gaussian with mean $\mu _ { k }$ and covariance $\Sigma _ { k }$ : $p ( z | y = k ) = \mathcal { N } ( z | \mu _ { k } , \Sigma _ { k } )$ . The marginal distribution of $z$ is then a Gaussian mixture. The likelihood for labeled data is then

$$
p _ { \mathcal { X } } ( x | y = k ) = \mathcal { N } \left( f ( x ) | \mu _ { k } , \Sigma _ { k } \right) \cdot \left| \operatorname* { d e t } \left( \frac { \partial f } { \partial x } \right) \right| ,
$$

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

![](images/b7cd2f55560b1e4e54cefcc89e3261d7dd3a48658d01a8daf0e0bae8edd9b6c4.jpg)  
Figure 19.13: Combining self-supervised learning on unlabeled data (left), supervised fine-tuning (middle), and self-training on pseudo-labeled data (right). From Figure 3 of [Che+20c]. Used with kind permission of Ting Chen.

and the likelihood for data with unknown label is $\begin{array} { r } { p ( x ) = \sum _ { k } p ( x | y = k ) p ( y = k ) } \end{array}$

For semi-supervised learning we can then maximize the joint likelihood of the labeled $\mathcal { D } _ { \ell }$ and unlabeled data $\mathcal { D } _ { u }$ :

$$
p ( \mathcal { D } _ { \ell } , \mathcal { D } _ { u } | \theta ) = \prod _ { ( x _ { i } , y _ { i } ) \in \mathcal { D } _ { \ell } } p ( x _ { i } , y _ { i } ) \prod _ { x _ { j } \in \mathcal { D } _ { u } } p ( x _ { j } ) ,
$$

over the parameters $\theta$ of the bijective function $f$ , which learns a density model for a Bayes classifier. Given a test point $x$ , the model predictive distribution is given by

$$
= c | x \rangle = { \frac { p ( x | y = c ) p ( y = c ) } { p ( x ) } } = { \frac { p ( x | y = c ) p ( y = c ) } { \sum _ { k = 1 } ^ { C } p ( x | y = k ) p ( y = k ) } } = { \frac { N ( f ( x ) | \mu _ { c } , \mu _ { c } ) } { \sum _ { k = 1 } ^ { C } { \mathcal { N } } ( f ( x ) | \mu _ { c } , \mu _ { c } ) } } = { \frac { N ( f ( x ) | \mu _ { c } , \mu _ { c } ) } { \sum _ { k = 1 } ^ { C } { \mathcal { N } } ( f ( x ) | \mu _ { c } , \mu _ { c } ) } } = { \frac { \sum _ { k = 1 } ^ { C } p ( x ) | \mu _ { c } , \mu _ { c } \rangle } { \sum _ { k = 1 } ^ { C } p ( x ) | \mu _ { c } , \mu _ { c } \rangle } } .
$$

where we have assumed $p ( y = c ) = 1 / C$ . We can make predictions for a test point $x$ with the Bayes decision rule $y = \arg \operatorname* { m a x } _ { c \in \{ 1 , . . . , C \} } p ( y = c | x )$ .

# 19.3.7 Combining self-supervised and semi-supervised learning

It is possible to combine self-supervised and semi-supervised learning. For example, [Che+20c] using SimCLR (Section 19.2.4.4) to perform self-supervised representation learning on the unlabeled data, they then fine-tune this representation on a small labeled dataset (as in transfer learning, Section 19.2), and finally, they apply the trained model back to the original unlabeled dataset, and distill the predictions from this teacher model $T$ into a student model $S$ . (Knowledge distillation is the name given to the approach of training one model on the predictions of another, as originally proposed in [HVD14].) That is, after fine-tuning $T$ , they train $S$ by minimizing

$$
\mathcal { L } ( T ) = - \sum _ { \pmb { x } _ { i } \in \mathcal { D } } \left[ \sum _ { y } p ^ { T } ( y | \pmb { x } _ { i } ; \tau ) \log p ^ { S } ( y | \pmb { x } _ { i } ; \tau ) \right]
$$

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license where $\tau > 0$ is a temperature parameter applied to the softmax output, which is used to perform label smoothing. If $S$ has the same form as $T$ , this is known as self-training, as discussed in Section 19.3.1. However, normally the student $S$ is smaller than the teacher $T$ . (For example, $T$ might be a high capacity model, and $S$ is a lightweight version that runs on a phone.) See Figure 19.13 for an illustration of the overall approach.

# 19.4 Active learning

In active learning, the goal is to identify the true predictive mapping $y = f ( { \pmb x } )$ by querying as few $( { \pmb x } , y )$ points as possible. There are three main variants. In query synthesis, the algorithm gets to choose any input $_ { x }$ , and can ask for its corresponding output $y = f ( { \pmb x } )$ . In pool-based active learning, there is a large, but fixed, set of unlabeled data points, and the algorithm gets to ask for a label for one or more of these points. Finally, in stream-based active learning, the incoming data is arriving continuously, and the algorithm must choose whether it wants to request a label for the current input or not.

There are various closely related problems. In Bayesian optimization the goal is to estimate the location of the global optimum $\begin{array} { r } { { \pmb x } ^ { * } = \mathrm { a r g m i n } _ { \pmb x } f ( { \pmb x } ) } \end{array}$ in as few queries as possible; typically we fit a surrogate (response surface) model to the intermediate $( { \pmb x } , y )$ queries, to decide which question to ask next. In experiment design, the goal is to infer a parameter vector of some model, using carefully chosen data samples $\mathcal { D } = \{ \pmb { x } _ { 1 } , \ldots , \pmb { x } _ { N } \}$ , i.e. we want to estimate $p ( \pmb { \theta } | \mathcal { D } )$ using as little data as possible. (This can be thought of as an unsupervised, or generalized, form of active learning.)

In this section, we give a brief review of the pool based approach to active learning. For more details, see e.g., [Set12] for a review.

# 19.4.1 Decision-theoretic approach

In the decision theoretic approach to active learning, proposed in [KHB07; RM01], we define the utility of querying $_ { x }$ in terms of the value of information. In particular, we define the utility of issuing query $_ { x }$ as

$$
U ( \pmb { x } ) \triangleq \mathbb { E } _ { p ( y | \pmb { x } , \mathcal { D } ) } \left[ \operatorname* { m i n } _ { a } \left( R ( a | \mathcal { D } ) - R ( a | \mathcal { D } , ( \pmb { x } , y ) ) \right) \right]
$$

where $R ( a | \mathcal { D } ) = \mathbb { E } _ { p ( \theta | \mathcal { D } ) } \left[ \ell ( \theta , a ) \right]$ is the posterior expected loss of taking some future action $a$ given the data $\mathcal { D }$ observed so far. Unfortunately, evaluating $U ( { \pmb x } )$ for each $_ { x }$ is quite expensive, since for each possible response $y$ we might observe, we have to update our beliefs given $( { \pmb x } , y )$ to see what effect it might have on our future decisions (similar to look ahead search technique applied to belief states).

# 19.4.2 Information-theoretic approach

In the information theoretic approach to active supervised learning, we avoid using task-specific loss functions, and instead focus on learning our model as well as we can. In particular, [Lin56] proposed to define the utility of querying $_ { x }$ in terms of information gain about the parameters $\pmb \theta$ , i.e., the reduction in entropy:

$$
U ( \pmb { x } ) \triangleq \mathbb { H } \left( p ( \pmb { \theta } | \mathcal { D } ) \right) - \mathbb { E } _ { p ( \pmb { y } | \pmb { x } , \mathcal { D } ) } \left[ \mathbb { H } \left( p ( \pmb { \theta } | \mathcal { D } , \pmb { x } , \pmb { y } ) \right) \right]
$$

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

(Note that the first term is a constant wrt $_ { x }$ , but we include it for later convenience.) Exercise 19.1 asks you to show that this objective is identical to the expected change in the posterior over the parameters which is given by

$$
U ^ { \prime } ( \pmb { x } ) \triangleq \mathbb { E } _ { p ( y | \pmb { x } , \mathcal { D } ) } \left[ D _ { \mathbb { K L } } \left( p ( \pmb { \theta } | \mathcal { D } , \pmb { x } , y ) \parallel p ( \pmb { \theta } | \mathcal { D } ) \right) \right]
$$

Using symmetry of the mutual information, we can rewrite Equation (19.47) as follows:

$$
\begin{array} { r l } & { U ( \pmb { x } ) = \mathbb { H } \left( p ( \pmb { \theta } | \mathcal { D } ) \right) - \mathbb { E } _ { p ( \pmb { y } | \pmb { x } , \mathcal { D } ) } \left[ \mathbb { H } \left( p ( \pmb { \theta } | \mathcal { D } , \pmb { x } , \pmb { y } ) \right) \right] } \\ & { \quad \quad \quad = \mathbb { I } ( \pmb { \theta } , \pmb { y } | \mathcal { D } , \pmb { x } ) } \\ & { \quad \quad \quad = \mathbb { H } \left( p ( \pmb { y } | \pmb { x } , \mathcal { D } ) \right) - \mathbb { E } _ { p ( \pmb { \theta } | \mathcal { D } ) } \left[ \mathbb { H } \left( p ( \pmb { y } | \pmb { x } , \pmb { \theta } ) \right) \right] } \end{array}
$$

The advantage of this approach is that we now only have to reason about the uncertainty of the predictive distribution over outputs $y$ , not over the parameters $\pmb \theta$ .

Equation (19.51) has an interesting interpretation. The first term prefers examples $_ { x }$ for which there is uncertainty in the predicted label. Just using this as a selection criterion is called maximum entropy sampling [SW87]. However, this can have problems with examples which are inherently ambiguous or mislabeled. The second term in Equation (19.51) will discourage such behavior, since it prefers examples $_ { x }$ for which the predicted label is fairly certain once we know $\pmb \theta$ ; this will avoid picking inherently hard-to-predict examples. In other words, Equation (19.51) will select examples $_ { x }$ for which the model makes confident predictions which are highly diverse. This approach has therefore been called Bayesian active learning by disagreement or BALD [Hou+12].

This method can be used to train classifiers for other domains where expert labels are hard to acquire, such as medical images or astronomical images [Wal+20].

# 19.4.3 Batch active learning

So far, we have assumed a greedy or myopic strategy, in which we select a single example $_ { \ast }$ , as if it were the last datapoint to be selected. But sometimes we have a budget to collect a set of $B$ samples, call them $( \mathbf { X } , \mathbf { Y } )$ . In this case, the information gain criterion becomes ${ \cal U } ( { \bf X } ) = $ $\mathbb { H } \left( p ( \pmb { \theta } | \mathcal { D } ) \right) - \mathbb { E } _ { p ( \mathbf { Y } | \mathbf { X } , \mathcal { D } ) } \left[ \mathbb { H } \left( p ( \pmb { \theta } | \mathbf { Y } , \mathbf { X } , \mathcal { D } ) \right) \right]$ . Unfortunately, optimizing this is NP-hard in the horizon length $B$ [KLQ95; KG05].

Fortunately, under certain conditions, the greedy strategy is near-optimal, as we now explain. First note that, for any given $\mathbf { X }$ , the information gain function $f ( \mathbf { Y } ) \triangleq \mathbb { H } \left( p ( \pmb { \theta } | \mathcal { D } ) \right) - \mathbb { H } \left( p ( \pmb { \theta } | \mathbf { Y } , \mathbf { X } , \mathcal { D } ) \right)$ maps a set of labels $\mathbf { Y }$ to a scalar. It is clear that $f ( \varnothing ) = 0$ , and that $f$ is non-decreasing, meaning $f ( Y ^ { \mathrm { l a r g e } } ) \geq f ( Y ^ { \mathrm { s m a l l } } )$ , due to the “more information never hurts” principle. Furthermore, [KG05] proved that $f$ is submodular. As a consequence, a sequential greedy approach is within a constant factor of optimal. If we combine this greedy technique with the BALD objective, we get a method called BatchBALD [KAG19].

# 19.5 Meta-learning

We can think of a learning algorithm as a function $A$ that maps data to a parameter estimate, $\theta = A ( \mathcal { D } )$ . The function $A$ usually has its own parameter — call them $\phi$ — such as the initial values for $\theta$ , or the learning rate, etc. We denote this by $\theta = A ( \mathcal { D } ; \phi )$ . We can imagine learning $\phi$ itself,

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license given a collection of datasets $\mathcal { D } _ { 1 : J }$ and some meta-learning algorithm $M$ , i.e., $\phi = M ( \mathcal { D } _ { 1 : J } )$ . We can then apply $A ( \cdot ; \phi )$ to learn the parameters $\theta _ { J + 1 }$ on some new dataset $\mathcal { D } _ { J + 1 }$ . There are many techniques for meta-learning — see e.g., [Van18; HRP21] for recent reviews. Below we discuss one particularly popular method. (Note that meta-learning is also called learning to learn [TP97].)

![](images/7d76151c2bcd7ff2e1c388b12ce97b8215e1ce2314048d25a940dea7b9a64a66.jpg)  
Figure 19.14: Illustration of a hierarchical Bayesian model for meta-learning. Generated by hbayes_maml.ipynb.

# 19.5.1 Model-agnostic meta-learning (MAML)

A natural approach to meta learning is to use a hierarchical Bayesian model, as illustrated in Figure 19.14. The parameters for each task $\pmb { \theta } _ { j }$ are assumed to come from a common prior, $p ( \pmb \theta _ { j } | \phi )$ , which can be used to help pool statistical strength from multiple data-poor problems. Meta-learning becomes equivalent to learning the prior $\phi$ . Rather than performing full Bayesian inference in this model, a more efficient approach is to use the following empirical Bayes (Section 4.6.5.3) approximation:

$$
\phi ^ { * } = \underset { \phi } { \operatorname { a r g m a x } } \frac { 1 } { J } \sum _ { j = 1 } ^ { J } \log p ( \mathcal { D } _ { \mathrm { v a l i d } } ^ { j } | \hat { \pmb { \theta } } _ { j } ( \phi , \mathcal { D } _ { \mathrm { t r a i n } } ^ { j } ) )
$$

where $\begin{array} { r } { \hat { \pmb { \theta } } _ { j } = \hat { \pmb { \theta } } ( \phi , \mathcal { D } _ { \mathrm { t r a i n } } ^ { j } ) } \end{array}$ is a point estimate of the parameters for task $j$ based on $\mathcal { D } _ { \mathrm { t r a i n } } ^ { j }$ and prior $\phi$ , and where we use a cross-validation approximation to the marginal likelihood (Section 5.2.4).

To compute the point estimate of the parameters for the target task $\hat { \pmb { \theta } } _ { J + 1 }$ , we use $K$ steps of a gradient ascent procedure starting at $\phi$ with a learning rate of $\eta$ . This is known as model-agnostic meta-learning or MAML [FAL17]. This can be shown to be equivalent to an approximate MAP estimate using a Gaussian prior centered at $\phi$ , where the strength of the prior is controlled by the number of gradient steps [San96; Gra+18]. (This is an example of fast adapation of the task specific weights starting from the shared prior $\phi$ .)

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

![](images/edb8af1468e41b0da791543bb304f3d8ae3450e0028271a4b6b4aca063e7eeda.jpg)  
Figure 19.15: Illustration of meta-learning for few-shot learning. Here, each task is a 3-way-2-shot classification problem because each training task contains a support set with three classes, each with two examples. From https: // bit. ly/ 3rrvSjw . Copyright (2019) Borealis AI. Used with kind permission of Simon Prince and April Cooper.

# 19.6 Few-shot learning

People can learn to predict from very few labeled examples. This is called few-shot learning. In the extreme in which the person or system learns from a single example of each class, this is called one-shot learning, and if no labeled examples are given, it is called zero-shot learning.

A common way to evaluate methods for FSL is to use C-way N-shot classification, in which the system is expected to learn to classify $C$ classes using just $N$ training examples of each class. Typically $N$ and $C$ are very small, e.g., Figure 19.15 illustrates the case where we have $C = 3$ classes, each with $N = 2$ examples. Since the amount of data from the new domain (here, ducks, dolphins and hens) is so small, we cannot expect to learn from scratch. Therefore we turn to meta-learning.

During training, the meta-algorithm $M$ trains on a labeled support set from group $j$ , returns a predictor $f ^ { j }$ , which is then evaluated on a disjoint query set also from group $j$ . We optimize $M$ over all $J$ groups. Finally we can apply $M$ to our new labeled support set to get $f ^ { \mathrm { t e s t } }$ , which is applied to the query set from the test domain. This is illustrated in Figure 19.15. We see that there is no overlap between the classes in the two training tasks ( $\{ \mathrm { c a t } , \mathrm { l a m b } , \mathrm { p i g } \}$ and $\{ \mathrm { d o g } , \mathrm { s h a r k } , \mathrm { l i o n } \}$ ) and those in the test task ( duck, dolphin, hen ). Thus the algorithm $M$ must learn to predict image classes in general rather than any particular set of labels.

There are many approaches to few-shot learning. We discuss one such method in Section 19.6.1. For more methods, see e.g., [Wan+20b].

# 19.6.1 Matching networks

One approach to few shot learning is to learn a distance metric on some other dataset, and then to use $d _ { \pmb \theta } ( \pmb x , \pmb x ^ { \prime } )$ inside of a nearest neighbor classifier. Essentially this defines a semi-parametric model of the form $p _ { \pmb \theta } ( y | \pmb x , S )$ , where $\boldsymbol { S }$ is the small labeled dataset (known as the support set), and $\pmb \theta$ are the parameters of the distance function. This approach is widely used for fine-grained classification

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license tasks, where there are many different visually similar categories, such as face images from a gallery, or product images from a catalog.

![](images/1490ae7cfccacc5676c04a849d5283b27c4a6e0f3939466a62cb5f5ba63096f6.jpg)  
Figure 19.16: Illustration of a matching network for one-shot learning. From Figure 1 of [Vin+16]. Used with kind permission of Oriol Vinyals.

An extension of this approach is to learn a function of the form

$$
p _ { \theta } ( y | x , S ) = \mathbb { I } \left( y = \sum _ { n \in S } a _ { \theta } ( x , x _ { n } ; S ) y _ { n } \right)
$$

where $a _ { \pmb \theta } ( \pmb x , \pmb x _ { n } ; \pmb S ) \in \mathbb { R } ^ { + }$ is some kind of adaptive similarity kernel. For example, we can use an attention kernel of the form

$$
a ( \pmb { x } , \pmb { x } _ { n } ; S ) = \frac { \exp ( c ( f ( \pmb { x } ) , g ( \pmb { x } _ { n } ) ) ) } { \sum _ { n ^ { \prime } = 1 } ^ { N } \exp ( c ( f ( \pmb { x } ) , g ( \pmb { x } _ { n ^ { \prime } } ) ) ) }
$$

where $c ( { \pmb u } , { \pmb v } )$ is the cosine distance. (We can make $f$ and $g$ be the same function if we want.) Intuitively, the attention kernel will compare $_ { x }$ to ${ \boldsymbol { \mathbf { \mathit { x } } } } _ { n }$ in the context of all the labeled examples, which provides an implicit signal about which feature dimensions are relevant. (We discuss attention mechanisms in more detail in Section 15.4.) This is called a matching network [Vin+16]. See Figure 19.16 for an illustration.

We can train the $f$ and $g$ functions using multiple small datasets, as in meta-learning (Section 19.5). More precisely, let $\mathcal { D }$ be a large labeled dataset (e.g., ImageNet), and let $p ( \mathcal { L } )$ be a distribution over its labels. We create a task by sampling a small set of labels (say 25), ${ \mathcal { L } } \sim p ( { \mathcal { L } } )$ , and then sampling a small support set of examples from $\mathcal { D }$ with those labels, $s \sim \mathcal { L }$ , and finally sampling a small test set with those same labels, $\tau \sim \mathcal L$ . We then train the model to predict the test labels given the support set, i.e., we optimize the following objective:

$$
\mathcal { L } ( \pmb { \theta } ; \mathcal { D } ) = \mathbb { E } _ { \mathcal { L } \sim p ( \mathcal { L } ) } \left[ \mathbb { E } _ { { \mathcal { S } } \sim \mathcal { L } , \mathcal { T } \sim \mathcal { L } } \left[ \sum _ { ( \pmb { x } , \pmb { y } ) \in \mathcal { T } } \log p _ { \pmb { \theta } } ( \pmb { y } | \pmb { x } , \mathcal { S } ) \right] \right]
$$

After training, we freeze $\pmb \theta$ , and apply Equation (19.53) to a test support set $\boldsymbol { S }$ .

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

# 19.7 Weakly supervised learning

The term weakly supervised learning refers to scenarios where we do not have an exact label associated with every feature vector in the training set.

One scenario is when we have a distribution over labels for each case, rather than a single label. Fortunately, we can still do maximum likelihood training: we just have to minimize the cross entropy,

$$
\mathcal { L } ( \pmb { \theta } ) = - \sum _ { n } \sum _ { y } p ( y | \pmb { x } _ { n } ) \log q _ { \pmb { \theta } } ( y | \pmb { x } _ { n } )
$$

where $p ( \boldsymbol { y } | \mathbf { x } _ { n } )$ is the label distribution for case $n$ , and $q _ { \pmb { \theta } } ( \pmb { y } | \mathbf { x } _ { n } )$ is the predicted distribution. Indeed, it is often useful to artificially replace exact labels with a “soft” version, in which we replace the delta function with a distribution that puts, say, $9 0 \%$ of its mass on the observed label, and spreads the remaining mass uniformly over the other choices. This is called label smoothing, and is a useful form of regularization (see e.g., [MKH19]).

Another scenario is when we have a set, or bag, of instances, $\pmb { x } _ { n } = \{ \pmb { x } _ { n , 1 } , \dotsc , \pmb { x } _ { n , B } \}$ , but we only have a label for the entire bag, $y _ { n }$ , not for the members of the bag, $y _ { n b }$ . We often assume that if any member of the bag is positive, the whole bag is labeled positive, so $y _ { n } = \vee _ { b = 1 } ^ { B } y _ { n b }$ , but we do not know which member “caused” the positive outcome. However, if all the members are negative, the entire bag is negative. This is known as multi-instance learning [DLLP97]. (For a recent example of this in the context of COVID-19 risk score learning, see [MKS21].) Various algorthms can be used to solve the MIL problem, depending on what assumptions we make about the correlation between the labels in each bag, and the fraction of positive members we expect to see (see e.g., [KF05]).

Yet another scenario is known as distant supervision [Min+09], which is often used to train information extraction systems. The idea is that we have some fact, such as “Married(B,M)”, that we know to be true (since it is stored in a database). We use this to label every sentence (in our unlabeled training corpus) in which the entities B and M are mentioned as being a positive example of the “Married” relation. For example, the sentence “B and M invited 100 people to their wedding” will be labeled positive. But this heuristic may include false positives, for example “B and M went out to dinner” will also be labeled positive. Thus the resulting labels will be noisy. We discuss some ways to handle label noise in Section 10.4.

# 19.8 Exercises

Exercise 19.1 [Information gain equations]   
Consider the following two objectives for evaluating the utility of querying a datapoint $_ { \ast }$ in an active learning   
setting:

$$
\begin{array} { r l } & { U ( \pmb { x } ) \triangleq \mathbb { H } \left( p ( \pmb { \theta } | \mathcal { D } ) \right) - \mathbb { E } _ { p ( y | \pmb { x } , \mathcal { D } ) } \left[ \mathbb { H } \left( p ( \pmb { \theta } | \mathcal { D } , \pmb { x } , y ) \right) \right] } \\ & { U ^ { \prime } ( \pmb { x } ) \triangleq \mathbb { E } _ { p ( y | \pmb { x } , \mathcal { D } ) } \left[ D _ { \mathbb { K L } } \left( p ( \pmb { \theta } | \mathcal { D } , \pmb { x } , y ) \parallel p ( \pmb { \theta } | \mathcal { D } ) \right) \right] } \end{array}
$$

Prove that these are equal.

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

# 20 Dimensionality Reduction

A common form of unsupervised learning is dimensionality reduction, in which we learn a mapping from the high-dimensional visible space, $\pmb { x } \in \mathbb { R } ^ { D }$ , to a low-dimensional latent space, $z \in \mathbb { R } ^ { L }$ . This mapping can either be a parametric model $z = f ( \boldsymbol { x } ; \boldsymbol { \theta } )$ which can be applied to any input, or it can be a nonparametric mapping where we compute an embedding $z _ { n }$ for each input ${ \boldsymbol { \mathbf { \mathit { x } } } } _ { n }$ in the data set, but not for any other points. This latter approach is mostly used for data visualization, whereas the former approach can also be used as a preprocessing step for other kinds of learning algorithms. For example, we might first reduce the dimensionality by learning a mapping from $_ { x }$ to $\boldsymbol { z }$ , and then learn a simple linear classifier on this embedding, by mapping $\mathscr { z }$ to $y$ .

# 20.1 Principal components analysis (PCA)

The simplest and most widely used form of dimensionality reduction is principal components analysis or PCA. The basic idea is to find a linear and orthogonal projection of the high dimensional data $\pmb { x } \in \mathbb { R } ^ { D }$ to a low dimensional subspace $z \in \mathbb { R } ^ { L }$ , such that the low dimensional representation is a “good approximation” to the original data, in the following sense: if we project or encode $_ { x }$ to get $z = \mathbf { W } ^ { \vert } x$ , and then unproject or decode $\boldsymbol { z }$ to get $\hat { \mathbf { \Omega } } _ { \hat { \mathbf { x } } } = \mathbf { W } z$ , then we want $\hat { \pmb x }$ to be close to $_ { x }$ in $\ell _ { 2 }$ distance. In particular, we can define the following reconstruction error or distortion:

$$
{ \mathcal { L } } ( \mathbf { W } ) \triangleq { \frac { 1 } { N } } \sum _ { n = 1 } ^ { N } | | \mathbf { \mathscr { x } } _ { n } - \mathrm { d e c o d e } ( \operatorname { e n c o d e } ( \mathbf { \mathscr { x } } _ { n } ; \mathbf { W } ) ; \mathbf { W } ) | | _ { 2 } ^ { 2 }
$$

where the encode and decoding stages are both linear maps, as we explain below.

In Section 20.1.2, we show that we can minimize this objective by setting $\hat { \mathbf { W } } = \mathbf { U } _ { L }$ , where $\mathbf { U } _ { L }$ contains the $L$ eigenvectors with largest eigenvalues of the empirical covariance matrix

$$
\hat { \mathbf { \Sigma } } = \frac { 1 } { N } \sum _ { n = 1 } ^ { N } ( \pmb { x } _ { n } - \overline { { \pmb { x } } } ) ( \pmb { x } _ { n } - \overline { { \pmb { x } } } ) ^ { \top } = \frac { 1 } { N } \mathbf { X } _ { c } ^ { \top } \mathbf { X } _ { c }
$$

where $\mathbf { X } _ { c }$ is a centered version of the $N \times D$ design matrix. In Section 20.2.2, we show that this is equivalent to maximizing the likelihood of a latent linear Gaussian model known as probabilistic PCA.

# 20.1.1 Examples

Before giving the details, we start by showing some examples.

![](images/8527731d92fbd4b18536f21e472c6b1ebdaf611f19a61aecac3cb4e739226543.jpg)  
Figure 20.1: An illustration of PCA where we project from 2d to 1d. Red circles are the original data points, blue circles are the reconstructions. The red dot is the data mean. Generated by pcaDemo2d.ipynb.

![](images/93f54c3d4df64eda1cf198074c6f5780b0ee9de98b930786371e14952f1b6964.jpg)  
Figure 20.2: An illustration of PCA applied to MNIST digits from class 9. Grid points are at the 5, 25, 50, 75, 95 % quantiles of the data distribution along each dimension. The circled points are the closest projected images to the vertices of the grid. Adapted from Figure 14.23 of [HTF09]. Generated by pca_digits.ipynb.

Figure 20.1 shows a very simple example, where we project 2d data to a 1d line. This direction captures most of the variation in the data.

In Figure 20.2, we show what happens when we project some MNIST images of the digit 9 down to 2d. Although the inputs are high dimensional (specifically $2 8 \times 2 8 = 7 8 4$ dimensional), the number of “effective degrees of freedom” is much less, since the pixels are correlated, and many digits look similar. Therefore we can represent each image as a point in a low dimensional linear space.

In general, it can be hard to interpet the latent dimensions to which the data is projected. However, by looking at several projected points along a given direction, and the examples from which they are derived, we see that the first principal component (horizontal direction) seems to capture the orientation of the digit, and the second component (vertical direction) seems to capture line thickness.

In Figure 20.3, we show PCA applied to another image dataset, known as the Olivetti face dataset,

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022 which is a set of $6 4 \times 6 4$ grayscale images. We project these to a 3d subspace. The resulting basis vectors (columns of the projection matrix W) are shown as images in in Figure 20.3b; these are known as eigenfaces [Tur13], for reasons that will be explained in Section 20.1.2. We see that the main modes of variation in the data are related to overall lighting, and then differences in the eyebrow region of the face. If we use enough dimensions (but fewer than the 4096 we started with), we can use the representation $z = \mathbf { W } ^ { \top } x$ as input to a nearest-neighbor classifier to perform face recognition; this is faster and more reliable than working in pixel space [MWP98].

![](images/1e7f5f3b7d24068a0a3c3a6e86c29b10b10e33a0aa1101dc1c0632f7eac29c8d.jpg)  
Figure 20.3: a) Some randomly chosen $6 4 \times 6 4$ pixel images from the Olivetti face database. (b) The mean and the first three PCA components represented as images. Generated by pcaImageDemo.ipynb.

# 20.1.2 Derivation of the algorithm

Suppose we have an (unlabeled) dataset $\mathcal { D } = \{ \pmb { x } _ { n } : n = 1 : N \}$ , where $\pmb { x } _ { n } \in \mathbb { R } ^ { D }$ . We can represent this as an $N \times D$ data matrix $\mathbf { X }$ . We will assume $\begin{array} { r } { \overline { { \pmb { x } } } = \frac { 1 } { N } \sum _ { n = 1 } ^ { N } \pmb { x } _ { n } = \mathbf { 0 } } \end{array}$ , which we can ensure by centering the data.

We would like to approximate each ${ \boldsymbol { \mathbf { \mathit { x } } } } _ { n }$ by a low dimensional representation, $z _ { n } \in \mathbb { R } ^ { L }$ . We assume where each that each ${ \boldsymbol { \mathbf { \mathit { x } } } } _ { n }$ ${ \pmb w } _ { k } \in \mathbb { R } ^ { D }$ can be “explained” in terms of a weighted combination of basis functions , and where the weights are given by $z _ { n } \in \mathbb { R } ^ { L }$ , i.e., we assume $\begin{array} { r } { \pmb { x } _ { n } \approx \sum _ { k = 1 } ^ { L } z _ { n k } \pmb { w } _ { k } } \end{array}$ $\pmb { w } _ { 1 } , \ldots , \pmb { w } _ { L }$ , The vector $z _ { n }$ is the low dimensional representation of ${ \pmb x } _ { n }$ , and is known as the latent vector, since it consists of latent or “hidden” values that are not observed in the data. The collection of these latent variables are called the latent factors.

We can measure the error produced by this approximation as follows:

$$
\mathcal { L } ( \mathbf { W } , \mathbf { Z } ) = \frac { 1 } { N } | | \mathbf { X } - \mathbf { Z } \mathbf { W } ^ { \mathsf { T } } | | _ { F } ^ { 2 } = \frac { 1 } { N } | | \mathbf { X } ^ { \mathsf { T } } - \mathbf { W } \mathbf { Z } ^ { \mathsf { T } } | | _ { F } ^ { 2 } = \frac { 1 } { N } \sum _ { n = 1 } ^ { N _ { \mathscr { D } } } | | \mathbf { x } _ { n } - \mathbf { W } \boldsymbol { z } _ { n } | | ^ { 2 }
$$

where the rows of $\mathbf { Z }$ contain the low dimension versions of the rows of $\mathbf { X }$ . This is known as the (average) reconstruction error, since we are approximating each ${ \boldsymbol { \mathbf { \mathit { x } } } } _ { n }$ by $\hat { \pmb x } _ { n } = { \bf W } \pmb z _ { n }$ .

We want to minimize this subject to the constraint that $\mathbf { W }$ is an orthogonal matrix. Below we show that the optimal solution is obtained by setting $\hat { \mathbf { W } } = \mathbf { U } _ { L }$ , where $\mathbf { U } _ { L }$ contains the $L$ eigenvectors with largest eigenvalues of the empirical covariance matrix.

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

# 20.1.2.1 Base case

Let us start by estimating the best 1d solution, ${ \pmb w } _ { 1 } \in \mathbb { R } ^ { D }$ . We will find the remaining basis vectors $_ { w _ { 2 } }$ , $_ { w _ { 3 } }$ , etc. later.

Let the coefficients for each of the data points associated with the first basis vector be denoted by $\tilde { \mathbf { z } } _ { 1 } = [ z _ { 1 1 } , \dots , z _ { N 1 } ] \in \mathbb { R } ^ { N _ { \mathcal { D } } }$ . The reconstruction error is given by

$$
\begin{array} { l } { \displaystyle \mathcal { L } ( \boldsymbol { w } _ { 1 } , \tilde { \mathbf { z } } _ { 1 } ) = \frac { 1 } { N _ { T } } \sum _ { n = 1 } ^ { N _ { T } } \vert \vert \boldsymbol { \mathbf { x } } _ { n } - z _ { n 1 } \boldsymbol { w } _ { 1 } \vert \vert ^ { 2 } = \frac { 1 } { N _ { T } } \sum _ { n = 1 } ^ { N _ { T } } ( x _ { n } - z _ { n 1 } \boldsymbol { w } _ { 1 } ) ^ { \top } ( x _ { n } - z _ { n 1 } \boldsymbol { w } _ { 1 } ) } \\ { \displaystyle \quad \quad = \frac { 1 } { N _ { T } } \sum _ { n = 1 } ^ { N _ { T } } [ x _ { n } ^ { \top } x _ { n } - 2 z _ { n 1 } \boldsymbol { w } _ { 1 } ^ { \top } x _ { n } + z _ { n 1 } ^ { 2 } \boldsymbol { w } _ { 1 } ^ { \top } w _ { 1 } ] } \\ { \displaystyle \quad \quad = \frac { 1 } { N _ { T } } \sum _ { n = 1 } ^ { N _ { T } } [ x _ { n } ^ { \top } x _ { n } - 2 z _ { n 1 } \boldsymbol { w } _ { 1 } ^ { \top } x _ { n } + z _ { n 1 } ^ { 2 } ] } \end{array}
$$

since $\pmb { w } _ { 1 } ^ { \vert } \pmb { w } _ { 1 } = 1$ (by the orthonormality assumption). Taking derivatives wrt $z _ { n 1 }$ and equating to zero gives

$$
\frac { \partial } { \partial z _ { n 1 } } \mathcal { L } ( \pmb { w } _ { 1 } , \widetilde { \mathbf { z } } _ { 1 } ) = \frac { 1 } { N _ { D } } [ - 2 \pmb { w } _ { 1 } ^ { \top } \pmb { x } _ { n } + 2 z _ { n 1 } ] = 0 \Rightarrow z _ { n 1 } = \pmb { w } _ { 1 } ^ { \top } \pmb { x } _ { n }
$$

So the optimal embedding is obtained by orthogonally projecting the data onto ${ \pmb w } _ { 1 }$ (see Figure 20.1(a)). Plugging this back in gives the loss for the weights:

$$
\mathcal { L } ( \boldsymbol { w } _ { 1 } ) = \mathcal { L } ( \boldsymbol { w } _ { 1 } , \tilde { \mathbf { z } } _ { 1 } ^ { * } ( \boldsymbol { w } _ { 1 } ) ) = \frac { 1 } { N _ { \mathcal { D } } } \sum _ { n = 1 } ^ { N _ { \mathcal { D } } } [ \mathbf { x } _ { n } ^ { \mathsf { T } } \mathbf { x } _ { n } - z _ { n 1 } ^ { 2 } ] = \mathrm { c o n s t } - \frac { 1 } { N _ { \mathcal { D } } } \sum _ { n = 1 } ^ { N _ { \mathcal { D } } } z _ { n 1 } ^ { 2 }
$$

To solve for ${ \pmb w } _ { 1 }$ , note that

$$
\mathcal { L } ( \boldsymbol { w } _ { 1 } ) = - \frac { 1 } { N _ { \mathcal { D } } } \sum _ { n = 1 } ^ { N _ { \mathcal { D } } } z _ { n 1 } ^ { 2 } = - \frac { 1 } { N _ { \mathcal { D } } } \sum _ { n = 1 } ^ { N _ { \mathcal { D } } } { \boldsymbol { w } _ { 1 } ^ { \top } \boldsymbol { x } _ { n } } x _ { n } ^ { \top } \boldsymbol { w } _ { 1 } = - \boldsymbol { w } _ { 1 } ^ { \top } \hat { \boldsymbol { \Sigma } } \boldsymbol { w } _ { 1 }
$$

where $\pmb { \Sigma }$ is the empirical covariance matrix (since we assumed the data is centered). We can trivially optimize this by letting $| | \pmb { w } _ { 1 } | |  \infty$ , so we impose the constraint $| | \pmb { w } _ { 1 } | | = 1$ and instead optimize

$$
\begin{array} { r } { \tilde { \mathcal { L } } ( \pmb { w } _ { 1 } ) = \pmb { w } _ { 1 } ^ { \top } \hat { \Sigma } \pmb { w } _ { 1 } - \lambda _ { 1 } ( \pmb { w } _ { 1 } ^ { \top } \pmb { w } _ { 1 } - 1 ) } \end{array}
$$

where $\lambda _ { 1 }$ is a Lagrange multiplier (see Section 8.5.1). Taking derivatives and equating to zero we have

$$
\begin{array} { c } { { \displaystyle \frac { \partial } { \partial { \pmb w } _ { 1 } } \tilde { \mathcal { L } } ( { \pmb w } _ { 1 } ) = 2 \hat { \pmb \Sigma } { \pmb w } _ { 1 } - 2 \lambda _ { 1 } { \pmb w } _ { 1 } = 0 } } \\ { { \hat { \pmb \Sigma } { \pmb w } _ { 1 } = \lambda _ { 1 } { \pmb w } _ { 1 } } } \end{array}
$$

Hence the optimal direction onto which we should project the data is an eigenvector of the covariance matrix. Left multiplying by $\pmb { w } _ { 1 } ^ { 1 }$ (and using $\pmb { w } _ { 1 } ^ { \vert } \pmb { w } _ { 1 } = 1$ ) we find

$$
\begin{array} { r } { { \pmb w } _ { 1 } ^ { \top } \hat { \pmb \Sigma } { \pmb w } _ { 1 } = \lambda _ { 1 } } \end{array}
$$

Since we want to maximize this quantity (minimize the loss), we pick the eigenvector which corresponds to the largest eigenvalue.

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

![](images/f3a7ccbd9b088ab7780f37d4e13c18be8ead0b1a5cacc1e519a4b0bb775132f4.jpg)  
Figure 20.4: Illustration of the variance of the points projected onto different 1d vectors. $v _ { 1 }$ is the first principal component, which maximizes the variance of the projection. $v _ { 2 }$ is the second principal component which is direction orthogonal to $_ { v 1 }$ . Finally $v ^ { \prime }$ is some other vector in between $v _ { 1 }$ and $v _ { 2 }$ . Adapted from Figure 8.7 of [Gér19]. Generated by pca_projected_variance.ipynb

# 20.1.2.2 Optimal weight vector maximizes the variance of the projected data

Before continuing, we make an interesting observation. Since the data has been centered, we have

$$
\mathbb { E } \left[ z _ { n 1 } \right] = \mathbb { E } \left[ \pmb { x } _ { n } ^ { \top } \pmb { w } _ { 1 } \right] = \mathbb { E } \left[ \pmb { x } _ { n } \right] ^ { \top } \pmb { w } _ { 1 } = 0
$$

Hence variance of the projected data is given by

$$
\Psi \left[ \mathbf { \tilde { z } _ { 1 } } \right] = \mathbb { E } \left[ \mathbf { \tilde { z } _ { 1 } ^ { 2 } } \right] - ( \mathbb { E } \left[ \mathbf { \tilde { z } _ { 1 } } \right] ) ^ { 2 } = \frac { 1 } { N _ { D } } \sum _ { n = 1 } ^ { N _ { D } } z _ { n 1 } ^ { 2 } - 0 = - \mathcal { L } ( w _ { 1 } ) + \mathrm { c o n s t }
$$

From this, we see that minimizing the reconstruction error is equivalent to maximizing the variance of the projected data:

$$
\arg \operatorname* { m i n } _ { \pmb { w } _ { 1 } } \mathcal { L } ( \pmb { w } _ { 1 } ) = \arg \operatorname* { m a x } _ { \pmb { w } _ { 1 } } \mathbb { V } \left[ \tilde { \mathbf { z } } _ { 1 } ( \pmb { w } _ { 1 } ) \right]
$$

This is why it is often said that PCA finds the directions of maximal variance. (See Figure 20.4 for an illustration.) However, the minimum error formulation is easier to understand and is more general.

# 20.1.2.3 Induction step

Now let us find another direction ${ \pmb w } _ { 2 }$ to further minimize the reconstruction error, subject to $\pmb { w } _ { 1 } ^ { \top } \pmb { w } _ { 2 } = 0$ and $\pmb { w } _ { 2 } ^ { \top } \pmb { w } _ { 2 } = 1$ . The error is

$$
\mathcal { L } ( \pmb { w } _ { 1 } , \tilde { \mathbf { z } } _ { 1 } , \pmb { w } _ { 2 } , \tilde { \mathbf { z } } _ { 2 } ) = \frac { 1 } { N _ { D } } \sum _ { n = 1 } ^ { N _ { D } } | | \pmb { x } _ { n } - z _ { n 1 } \pmb { w } _ { 1 } - z _ { n 2 } \pmb { w } _ { 2 } | | ^ { 2 }
$$

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

![](images/44b506ab613298fe6ed9c36b787d4c884c8f474422c7c87a92d7a59b675f065a.jpg)  
Figure 20.5: Effect of standardization on PCA applied to the height/weight dataset. (Red=female, blue=male.) Left: PCA of raw data. Right: PCA of standardized data. Generated by pcaStandardization.ipynb.

Optimizing wrt ${ \pmb w } _ { 1 }$ and $z _ { 1 }$ gives the same solution as before. Exercise 20.3 asks you to show that ∂zL = 0 yields zn2 = w2Txn. Substituting in yields

$$
\mathcal { L } ( \boldsymbol { w } _ { 2 } ) = \frac { 1 } { n } \sum _ { n = 1 } ^ { N _ { D } } [ \boldsymbol { x } _ { n } ^ { \top } \boldsymbol { x } _ { n } - \boldsymbol { w } _ { 1 } ^ { \top } \boldsymbol { x } _ { n } x _ { n } ^ { \top } \boldsymbol { w } _ { 1 } - \boldsymbol { w } _ { 2 } ^ { \top } \boldsymbol { x } _ { n } x _ { n } ^ { \top } \boldsymbol { w } _ { 2 } ] = \mathrm { c o n s t } - \boldsymbol { w } _ { 2 } ^ { \top } \hat { \boldsymbol { \Sigma } } \boldsymbol { w } _ { 2 }
$$

Dropping the constant term, plugging in the optimal ${ \pmb w } _ { 1 }$ and adding the constraints yields

$$
\begin{array} { r } { \tilde { \mathcal { L } } ( \pmb { w } _ { 2 } ) = \pmb { w } _ { 2 } ^ { \top } \hat { \pmb { \Sigma } } \pmb { w } _ { 2 } + \lambda _ { 2 } ( \pmb { w } _ { 2 } ^ { \top } \pmb { w } _ { 2 } - 1 ) + \lambda _ { 1 2 } ( \pmb { w } _ { 2 } ^ { \top } \pmb { w } _ { 1 } - 0 ) } \end{array}
$$

Exercise 20.3 asks you to show that the solution is given by the eigenvector with the second largest eigenvalue:

$$
\hat { \Sigma } w _ { 2 } = \lambda _ { 2 } w _ { 2 }
$$

The proof continues in this way to show that $\hat { \mathbf { W } } = \mathbf { U } _ { L }$ .

# 20.1.3 Computational issues

In this section, we discuss various practical issues related to using PCA.

# 20.1.3.1 Covariance matrix vs correlation matrix

We have been working with the eigendecomposition of the covariance matrix. However, it is better to use the correlation matrix instead. The reason is that otherwise PCA can be “misled” by directions in which the variance is high merely because of the measurement scale. Figure 20.5 shows an example of this. On the left, we see that the vertical axis uses a larger range than the horizontal axis. This results in a first principal component that looks somewhat “unnatural”. On the right, we show the results of PCA after standardizing the data (which is equivalent to using the correlation matrix instead of the covariance matrix); the results look much better.

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

# 20.1.3.2 Dealing with high-dimensional data

We have presented PCA as the problem of finding the eigenvectors of the $D \times D$ covariance matrix $\mathbf { X } ^ { \mathsf { I } } \mathbf { X }$ . If $D > N$ , it is faster to work with the $N \times N$ Gram matrix $\mathbf { X X ^ { \parallel } }$ . We now show how to do this.

First, let $\mathbf { U }$ be an orthogonal matrix containing the eigenvectors of $\mathbf { X X ^ { \mathsf { T } } }$ with corresponding eigenvalues in $\pmb { \Lambda }$ . By definition we have $( \mathbf { X } \mathbf { X } ^ { ! } ) \mathbf { U } = \mathbf { U } \mathbf { A }$ . Pre-multiplying by $\mathbf { X } ^ { \mathsf { I } }$ gives

$$
( \mathbf { X } ^ { \mathsf { T } } \mathbf { X } ) ( \mathbf { X } ^ { \mathsf { T } } \mathbf { U } ) = ( \mathbf { X } ^ { \mathsf { T } } \mathbf { U } ) \mathbf { A }
$$

from which we see that the eigenvectors of $\mathbf { X } ^ { \mathsf { I } } \mathbf { X }$ are $\mathbf { V } = \mathbf { X } ^ { \mathsf { I } } \mathbf { U }$ , with eigenvalues given by $\pmb { \Lambda }$ as before. However, these eigenvectors are not normalized, since $| | \pmb { v } _ { j } | | ^ { 2 } = \pmb { u } _ { j } ^ { \top } \mathbf { X } \mathbf { X } ^ { \top } \pmb { u } _ { j } = \lambda _ { j } \pmb { u } _ { j } ^ { \top } \pmb { u } _ { j } = \lambda _ { j }$ . The normalized eigenvectors are given by

$$
\mathbf { V } = \mathbf { X } ^ { \mathsf { T } } \mathbf { U } \mathbf { A } ^ { - \frac { 1 } { 2 } }
$$

This provides an alternative way to compute the PCA basis. It also allows us to use the kernel trick, as we discuss in Section 20.4.6.

# 20.1.3.3 Computing PCA using SVD

In this section, we show the equivalence between PCA as computed using eigenvector methods (Section 20.1) and the truncated SVD.1

Let ${ \bf U } _ { \Sigma } \pmb { \Lambda } _ { \Sigma } \mathbf { U } _ { \Sigma } ^ { \top }$ be the top $L$ eigendecomposition of the covariance matrix $\begin{array} { r } { \pmb { \Sigma } \propto \mathbf { X } ^ { \vert } \mathbf { X } } \end{array}$ (we assume $\mathbf { X }$ is centered). Recall from Section 20.1.2 that the optimal estimate of the projection weights $\mathbf { W }$ is given by the top $L$ eigenvalues, so $\mathbf { W } = \mathbf { U } _ { \Sigma }$ .

Now let $\mathbf { U } _ { X } \mathbf { S } _ { X } \mathbf { V } _ { X } ^ { \sf T } \approx \mathbf { X }$ be the $L$ -truncated SVD approximation to the data matrix $\mathbf { X }$ . From Equation (7.184), we know that the right singular vectors of $\mathbf { X }$ are the eigenvectors of $\mathbf { X } ^ { \mathsf { I } } \mathbf { X }$ , so $\mathbf { V } _ { X } = \mathbf { U } _ { \Sigma } = \mathbf { W }$ . (In addition, the eigenvalues of the covariance matrix are related to the singular values of the data matrix via $\lambda _ { k } = s _ { k } ^ { 2 } / N$ .)

Now suppose we are interested in the projected points (also called the principal components or PC scores), rather than the projection matrix. We have

$$
\mathbf { Z } = \mathbf { X } \mathbf { W } = \mathbf { U } _ { X } \mathbf { S } _ { X } \mathbf { V } _ { X } ^ { \top } \mathbf { V } _ { X } = \mathbf { U } _ { X } \mathbf { S } _ { X }
$$

Finally, if we want to approximately reconstruct the data, we have

$$
\begin{array} { r } { \hat { \mathbf { X } } = \mathbf { Z } \mathbf { W } ^ { \top } = \mathbf { U } _ { X } \mathbf { S } _ { X } \mathbf { V } _ { X } ^ { \top } } \end{array}
$$

This is precisely the same as a truncated SVD approximation (Section 7.5.5).

Thus we see that we can perform PCA either using an eigendecomposition of $\pmb { \Sigma }$ or an SVD decomposition of $\mathbf { X }$ . The latter is often preferable, for computational reasons. For very high dimensional problems, we can use a randomized SVD algorithm, see e.g., [HMT11; SKT14; DM16]. For example, the randomized solver used by sklearn takes $O ( N L ^ { 2 } ) + O ( L ^ { 3 } )$ time for $N$ examples and $L$ principal components, whereas exact SVD takes $O ( N D ^ { 2 } ) + O ( D ^ { 3 } )$ time.

![](images/9970a85d6a2de18589c3a78c8535f40e6a8cf9a31068f319251353bfbaec9206.jpg)  
Figure 20.6: Reconstruction error on MNIST vs number of latent dimensions used by PCA. (a) Training set. (b) Test set. Generated by pcaOverfitDemo.ipynb.

# 20.1.4 Choosing the number of latent dimensions

In this section, we discuss how to choose the number of latent dimensions $L$ for PCA.

# 20.1.4.1 Reconstruction error

Let us define the reconstruction error on some dataset $\mathcal { D }$ incurred by the model when using $L$ dimensions:

$$
\mathcal { L } _ { L } = \frac { 1 } { | \mathcal { D } | } \sum _ { n \in \mathcal { D } } | | \pmb { x } _ { n } - \hat { \pmb { x } } _ { n } | | ^ { 2 }
$$

where the reconstruction is given by by ${ \hat { \pmb x } } _ { n } = \mathbf { W } { \boldsymbol z } _ { n } + { \boldsymbol \mu }$ , where $z _ { n } = \mathbf { W } ^ { \parallel } ( { \pmb x } _ { n } - { \pmb \mu } )$ and $\mu$ is the empirical mean, and $\mathbf { W }$ is estimated as above. Figure 20.6(a) plots $\mathcal { L } _ { L }$ vs $L$ on the MNIST training data. We see that it drops off quite quickly, indicating that we can capture most of the empirical correlation of the pixels with a small number of factors.

Of course, if we use $L = { \mathrm { r a n k } } ( \mathbf { X } )$ , we get zero reconstruction error on the training set. To avoid overfitting, it is natural to plot reconstruction error on the test set. This is shown in Figure 20.6(b). Here we see that the error continues to go down even as the model becomes more complex! Thus we do not get the usual U-shaped curve that we typically expect to see in supervised learning. The problem is that PCA is not a proper generative model of the data: If you give it more latent dimensions, it will be able to approximate the test data more accurately. (A similar problem arises if we plot reconstruction error on the test set using K-means clustering, as discussed in Section 21.3.7.) We discuss some solutions to this below.

# 20.1.4.2 Scree plots

A common alternative to plotting reconstruction error vs $L$ is to use something called a scree plot, which is a plot of the eigenvalues $\lambda _ { j }$ vs $j$ in order of decreasing magnitude. One can show

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

![](images/df8d3cbd9ff55b4186cced0693e421770b9e26b06ba5dfa157dc8b1abb212112.jpg)  
Figure 20.7: (a) Scree plot for training set, corresponding to Figure ${ \it 2 0 . 6 ( a ) }$ . (b) Fraction of variance explained. Generated by pcaOverfitDemo.ipynb.

(Exercise 20.4) that

$$
\mathcal { L } _ { L } = \sum _ { j = L + 1 } ^ { D } \lambda _ { j }
$$

Thus as the number of dimensions increases, the eigenvalues get smaller, and so does the reconstruction error, as shown in Figure 20.7a).2 A related quantity is the fraction of variance explained, defined as

$$
F _ { L } = \frac { \sum _ { j = 1 } ^ { L } \lambda _ { j } } { \sum _ { j ^ { \prime } = 1 } ^ { L ^ { \operatorname* { m a x } } } \lambda _ { j ^ { \prime } } }
$$

This captures the same information as the scree plot, but goes up with $L$ (see Figure 20.7b).

# 20.1.4.3 Profile likelihood

Although there is no U-shape in the reconstruction error plot, there is sometimes a “knee” or “elbow” in the curve, where the error suddenly changes from relatively large errors to relatively small. The idea is that for $L < L ^ { * }$ , where $L ^ { * }$ is the “true” latent dimensionality (or number of clusters), the rate of decrease in the error function will be high, whereas for $L > L ^ { * }$ , the gains will be smaller, since the model is already sufficiently complex to capture the true distribution.

One way to automate the detection of this change in the gradient of the curve is to compute the profile likelihood, as proposed in [ZG06]. The idea is this. Let $\lambda _ { L }$ be some measure of the error incurred by a model of size $L$ , such that $\lambda _ { 1 } \geq \lambda _ { 2 } \geq \cdot \cdot \cdot \geq \lambda _ { L ^ { \operatorname* { m a x } } }$ . In PCA, these are the eigenvalues, but the method can also be applied to the reoconstruction error from K-means clustering (see Section 21.3.7). Now consider partitioning these values into two groups, depending on whether $k < L$ or $k > L$ , where $L$ is some threshold which we will determine. To measure the quality of $L$ , we will use a simple change-point model, where $\lambda _ { k } \sim \mathcal N ( \mu _ { 1 } , \sigma ^ { 2 } )$ if $k \leq L$ , and $\lambda _ { k } \sim \mathcal N ( \mu _ { 2 } , \sigma ^ { 2 } )$ if $k > L$ . (It is important that $\sigma ^ { 2 }$ be the same in both models, to prevent overfitting in the case where one regime has less data than the other.) Within each of the two regimes, we assume the $\lambda _ { k }$ are iid, which is obviously incorrect, but is adequate for our present purposes. We can fit this model for each $L = 1 : L ^ { \operatorname* { m a x } }$ by partitioning the data and computing the MLEs, using a pooled estimate of the variance:

![](images/bed41d0da2f4ae88479d510a0e810300f04dc690037cbcbe4963d9c4484cf08a.jpg)  
Figure 20.8: Profile likelihood corresponding to PCA model in Figure ${ \it 2 0 . 6 ( a ) }$ . Generated by pcaOverfitDemo.ipynb.

$$
\begin{array} { l } { \displaystyle \mu _ { 1 } ( L ) = \frac { \sum _ { k \leq L } \lambda _ { k } } { L } } \\ { \displaystyle \mu _ { 2 } ( L ) = \frac { \sum _ { k > L } \lambda _ { k } } { L ^ { \operatorname* { m a x } } - L } } \\ { \displaystyle \sigma ^ { 2 } ( L ) = \frac { \sum _ { k \leq L } ( \lambda _ { k } - \mu _ { 1 } ( L ) ) ^ { 2 } + \sum _ { k > L } ( \lambda _ { k } - \mu _ { 2 } ( L ) ) ^ { 2 } } { L ^ { \operatorname* { m a x } } } } \end{array}
$$

We can then evaluate the profile log likelihood

$$
\ell ( L ) = \sum _ { k = 1 } ^ { L } \log \mathcal { N } ( \lambda _ { k } | \mu _ { 1 } ( L ) , \sigma ^ { 2 } ( L ) ) + \sum _ { k = L + 1 } ^ { L ^ { \operatorname* { m a x } } } \log \mathcal { N } ( \lambda _ { k } | \mu _ { 2 } ( L ) , \sigma ^ { 2 } ( L ) )
$$

This is illustrated in Figure 20.8. We see that the peak $L ^ { * } = \operatorname { a r g m a x } \ell ( L )$ is well determined.

# 20.2 Factor analysis \*

PCA is a simple method for computing a linear low-dimensional representation of data. In this section, we present a generalization of PCA known as factor analysis. This is based on a probabilistic model, which means we can treat it as a building block for more complex models, such as the mixture of FA models in Section 20.2.6, or the nonlinear FA model in Section 20.3.5. We can recover PCA as a special limiting case of FA, as we discuss in Section 20.2.2.

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

# 20.2.1 Generative model

Factor analysis corresponds to the following linear-Gaussian latent variable generative model:

$$
\begin{array} { c } { p ( z ) = \mathcal { N } ( z | \pmb { \mu } _ { 0 } , \pmb { \Sigma } _ { 0 } ) } \\ { p ( \pmb { x } | z , \pmb { \theta } ) = \mathcal { N } ( \pmb { x } | \mathbf { W } z + \pmb { \mu } , \pmb { \Psi } ) } \end{array}
$$

where $\mathbf { W }$ is a $D \times L$ matrix, known as the factor loading matrix, and $\Psi$ is a diagonal $D \times D$ covariance matrix.

FA can be thought of as a low-rank version of a Gaussian distribution. To see this, note that the induced marginal distribution $p ( { \pmb x } | { \pmb \theta } )$ is a Gaussian (see Equation (3.38) for the derivation):

$$
\begin{array} { c } { { \displaystyle p ( { \bf x } | \mathbf { \theta } ) = \int \mathcal { N } ( { \boldsymbol { \mathbf { \mathit { x } } } } | \mathbf { \boldsymbol { W } } z + \mu , \Psi ) \mathcal { N } ( z | \mu _ { 0 } , \Sigma _ { 0 } ) d z } } \\ { { \displaystyle ~ = \mathcal { N } ( { \boldsymbol { \mathbf { \mathit { x } } } } | \mathbf { \boldsymbol { W } } \mu _ { 0 } + \mu , \Psi + \mathbf { \boldsymbol { W } } \Sigma _ { 0 } \mathbf { \boldsymbol { W } } ^ { \top } ) } } \end{array}
$$

Hence $\mathbb { E } \left[ \pmb { x } \right] = \mathbf { W } \pmb { \mu } _ { 0 } + \pmb { \mu }$ and $\operatorname { C o v } \left[ \mathbf { { x } } \right] = \mathbf { W } \operatorname { C o v } \left[ { \boldsymbol { z } } \right] \mathbf { W } ^ { \mathsf { T } } + \Psi = \mathbf { W } \pmb { \Sigma } _ { 0 } \mathbf { W } ^ { \mathsf { T } } + \Psi$ . From this, we see that we can set ${ \boldsymbol { \mu } } _ { 0 } = \mathbf { 0 }$ without loss of generality, since we can always absorb $\mathbf { W } \pmb { \mu } _ { 0 }$ into $\pmb { \mu }$ . Similarly, we can set $\pmb { \Sigma } _ { 0 } = \mathbf { I }$ without loss of generality, since we can always absorb a correlated prior by using a new weight matrix, $\tilde { \mathbf { W } } = \mathbf { W } \boldsymbol { \Sigma } _ { 0 } ^ { - \frac { 1 } { 2 } }$ . After these simplifications we have

$$
\begin{array} { c } { p ( z ) = \mathcal { N } ( z | \mathbf { 0 } , \mathbf { I } ) } \\ { p ( \mathbf { \boldsymbol { x } } | z ) = \mathcal { N } ( \mathbf { \boldsymbol { x } } | \mathbf { W } z + \mu , \boldsymbol { \Psi } ) } \\ { p ( \mathbf { \boldsymbol { x } } ) = \mathcal { N } ( \mathbf { \boldsymbol { x } } | \mu , \mathbf { W } \mathbf { W } ^ { \intercal } + \boldsymbol { \Psi } ) } \end{array}
$$

For example, suppose where $L = 1$ , $D = 2$ and $\boldsymbol { \Psi } = \sigma ^ { 2 } \mathbf { I }$ . We illustrate the generative process in this case in Figure 20.9. We can think of this as taking an isotropic Gaussian “spray can”, representing the likelihood $p ( \pmb { x } | \pmb { z } )$ , and “sliding it along” the 1d line defined by $\boldsymbol { w z } + \boldsymbol { \mu }$ as we vary the 1d latent prior $z$ . This induces an elongated (and hence correlated) Gaussian in 2d. That is, the induced distribution has the form $p ( { \pmb x } ) = \mathcal { N } ( { \pmb x } | { \pmb \mu } , { \pmb w } { \pmb w } ^ { 1 } + \sigma ^ { 2 } { \bf I } )$ .

In general, FA approximates the covariance matrix of the visible vector using a low-rank decomposition:

$$
\mathbf { C } = \operatorname { C o v } \left[ \pmb { x } \right] = \mathbf { W } \mathbf { W } ^ { \mathsf { T } } + \pmb { \Psi }
$$

This only uses $O ( L D )$ parameters, which allows a flexible compromise between a full covariance Gaussian, with $O ( D ^ { 2 } )$ parameters, and a diagonal covariance, with $O ( D )$ parameters.

From Equation (20.39), we see that we should restrict $\Psi$ to be diagonal, otherwise we could set $\mathbf { W } = \mathbf { 0 }$ , thus ignoring the latent factors, while still being able to model any covariance. The marginal variance of each visible variable is given by $\begin{array} { r } { \mathbb { V } \left[ x _ { d } \right] = \sum _ { k = 1 } ^ { L } w _ { d k } ^ { 2 } + \psi _ { d } } \end{array}$ , where the first term is the variance due to the common factors, and the second $\psi _ { d }$ term is called the uniqueness, and is the variance term that is specific to that dimension.

We can estimate the parameters of an FA model using EM (see Section 20.2.3). Once we have fit the model, we can compute probabilistic latent embeddings using $p ( \boldsymbol { z } | \boldsymbol { x } )$ . Using Bayes rule for Gaussians we have

$$
p ( z | \boldsymbol { x } ) = \mathcal { N } ( z | \mathbf { W } ^ { \mathsf { T } } \mathbf { C } ^ { - 1 } ( \boldsymbol { x } - \boldsymbol { \mu } ) , \mathbf { I } - \mathbf { W } ^ { \mathsf { T } } \mathbf { C } ^ { - 1 } \mathbf { W } )
$$

where $\mathbf { C }$ is defined in Equation (20.39).

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

![](images/1475a74734e43359552c17948e0ffdda046b73fd3885ffac51a8523d82dd1b4c.jpg)

Figure 20.9: Illustration of the $F A$ generative process, where we have $L = 1$ latent dimension generating $D = 2$ observed dimensions; we assume $\scriptstyle \Psi \ = \ \sigma ^ { 2 } \mathbf { I }$ . The latent factor has value $z \in \mathbb { R }$ , sampled from $p ( z )$ ; this gets mapped to a 2d offset ${ \pmb { \delta } } = z { \pmb { w } }$ , where $\pmb { w } \in \mathbb { R } ^ { 2 }$ , which gets added to $\pmb { \mu }$ to define a Gaussian $p ( \pmb { x } | z ) = \mathcal { N } ( \pmb { x } | \pmb { \mu } + \pmb { \delta } , \sigma ^ { 2 } \mathbf { I } )$ . By integrating over $z$ , we “slide” this circular Gaussian “spray can” along the principal component axis $\pmb { w }$ , which induces elliptical Gaussian contours in $\scriptstyle { \pmb x }$ space centered on $\pmb { \mu }$ . Adapted from Figure 12.9 of [Bis06].

# 20.2.2 Probabilistic PCA

In this section, we consider a special case of the factor analysis model in which W has orthonormal columns, $\boldsymbol { \Psi } = \sigma ^ { 2 } \mathbf { I }$ and ${ \pmb \mu } = { \bf 0 }$ . This model is called probabilistic principal components analysis (PPCA) [TB99], or sensible PCA [Row97]. The marginal distribution on the visible variables has the form

$$
p ( { \pmb x } | { \pmb \theta } ) = \int { \mathcal { N } } ( { \pmb x } | { \bf W } z , \sigma ^ { 2 } { \bf I } ) { \mathcal { N } } ( z | \mathbf { 0 } , { \bf I } ) d z = { \mathcal { N } } ( { \pmb x } | { \pmb \mu } , \mathbf { C } )
$$

where

$$
\mathbf { C } = \mathbf { W } \mathbf { W } ^ { \mathsf { T } } + \sigma ^ { 2 } \mathbf { I }
$$

The log likelihood for PPCA is given by

$$
\log p ( \mathbf { X } | \mu , \mathbf { W } , \sigma ^ { 2 } ) = - { \frac { N D } { 2 } } \log ( 2 \pi ) - { \frac { N } { 2 } } \log | \mathbf { C } | - { \frac { 1 } { 2 } } \sum _ { n = 1 } ^ { N } ( x _ { n } - \mu ) ^ { \mathsf { T } } \mathbf { C } ^ { - 1 } ( x _ { n } - \mu ) ,
$$

The MLE for $\pmb { \mu }$ is ${ \pmb x }$ . Plugging in gives

$$
\log p ( \mathbf { X } | \mu , \mathbf { W } , \boldsymbol { \sigma } ^ { 2 } ) = - \frac { N } { 2 } \left[ D \log ( 2 \pi ) + \log \left| \mathbf { C } \right| + \operatorname { t r } ( \mathbf { C } ^ { - 1 } \mathbf { S } ) \right]
$$

where $\begin{array} { r } { \mathbf { S } = \frac { 1 } { N } \sum _ { n = 1 } ^ { N } ( { \pmb x } _ { n } - { \overline { { \pmb x } } } ) ( { \pmb x } _ { n } - { \overline { { \pmb x } } } ) ^ { \top } } \end{array}$ is the empirical covariance matrix.

In [TB99; Row97] they show that the maximum of this objective must satisfy

$$
\mathbf { W } = \mathbf { U } _ { L } ( \mathbf { L } _ { L } - \sigma ^ { 2 } \mathbf { I } ) ^ { \frac { 1 } { 2 } } \mathbf { R }
$$

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022 where $\mathbf { U } _ { L }$ is a $D \times L$ matrix whose columns are given by the $L$ eigenvectors of $\mathbf { s }$ with largest eigenvalues, $\mathbf { L } _ { L }$ is the $L \times L$ diagonal matrix of eigenvalues, and $\mathbf { R }$ is an arbitrary $L \times L$ orthogonal matrix, which (WLOG) we can take to be $\mathbf R = \mathbf I$ . In the noise-free limit, where $\sigma ^ { 2 } = 0$ , we see that $\mathbf { W } _ { \mathrm { m l e } } = \mathbf { U } _ { L } \mathbf { L } _ { L } ^ { \frac { 1 } { 2 } }$ , which is proportional to the PCA solution.

The MLE for the observation variance is

$$
\sigma ^ { 2 } = \frac { 1 } { D - L } \sum _ { i = L + 1 } ^ { D } \lambda _ { i }
$$

which is the average distortion associated with the discarded dimensions. If $L \ = \ D$ , then the estimated noise is $0$ , since the model collapses to $z = x$ .

To compute the likelihood $p ( \mathbf { X } | \boldsymbol { \mu } , \mathbf { W } , \boldsymbol { \sigma } ^ { 2 } )$ , we need to evaluate $\mathbf { C } ^ { - 1 }$ and $\log | \mathbf { C } |$ , where $\mathbf { C }$ is a $D \times D$ matrix. To do this efficiently, we can use the matrix inversion lemma to write

$$
\mathbf { C } ^ { - 1 } = \sigma ^ { - 2 } \left[ \mathbf { I } - \mathbf { W M } ^ { - 1 } \mathbf { W } ^ { \mathsf { T } } \right]
$$

where the $L \times L$ dimensional matrix $\mathbf { M }$ is given by

$$
\mathbf { M } = \mathbf { W } ^ { \mathsf { T } } \mathbf { W } + \sigma ^ { 2 } \mathbf { I }
$$

When we plug in the MLE for $\mathbf { W }$ from Equation (20.45) (using $\mathbf R = \mathbf I$ ) we find

$$
\mathbf { M } = \mathbf { U } _ { L } ( \mathbf { L } _ { L } - \sigma ^ { 2 } \mathbf { I } ) \mathbf { U } _ { L } ^ { \mathsf { T } } + \sigma ^ { 2 } \mathbf { I }
$$

and hence

$$
\begin{array} { c } { { \displaystyle { \bf C } ^ { - 1 } = \sigma ^ { - 2 } \left[ { \bf I } - { \bf U } _ { L } ( { \bf L } _ { L } - \sigma ^ { 2 } { \bf I } ) { \bf A } _ { L } ^ { - 1 } { \bf U } _ { L } ^ { \top } \right] } } \\ { { \displaystyle \log \left. { \bf C } \right. = ( D - L ) \log \sigma ^ { 2 } + \sum _ { j = 1 } ^ { L } \log \lambda _ { j } } } \end{array}
$$

Thus we can avoid all matrix inversions (since $\Lambda _ { L } ^ { - 1 } = \mathrm { d i a g } ( 1 / \lambda _ { j } ) )$ .

To use PPCA as an alternative to PCA, we need to compute the posterior mean $\mathbb { E } \left[ \boldsymbol { z } | \boldsymbol { x } \right]$ , which is the equivalent of the encoder model. Using Bayes rule for Gaussians we have

$$
p ( z | \mathbf { \boldsymbol { x } } ) = \mathcal { N } ( z | \mathbf { \mathbf { M } } ^ { - 1 } \mathbf { \mathbf { W } } ^ { \mathsf { T } } ( \mathbf { \boldsymbol { x } } - \pmb { \mu } ) , \sigma ^ { 2 } \mathbf { \mathbf { M } } ^ { - 1 } )
$$

where $\mathbf { M }$ is defined in Equation (20.48). In the $\sigma ^ { 2 } = 0$ limit, the posterior mean using the MLE parameters becomes

$$
\mathbb { E } \left[ \pmb { z } | \pmb { x } \right] = ( \mathbf { W } ^ { \mathsf { T } } \mathbf { W } ) ^ { - 1 } \mathbf { W } ^ { \mathsf { T } } ( \pmb { x } - \overline { { \pmb { x } } } )
$$

which is the orthogonal projection of the data into the latent space, as in standard PCA.

# 20.2.3 EM algorithm for FA/PPCA

In this section, we describe one method for computing the MLE for the FA model using the EM algorithm, based on [RT82; GH96].

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

# 20.2.3.1 EM for FA

In the $\mathrm { E }$ step, we compute the posterior embeddings

$$
\begin{array} { r l } & { p ( z _ { i } | \mathbf { \boldsymbol { x } } _ { i } , \pmb { \theta } ) = \mathcal { N } ( z _ { i } | \mathbf { \boldsymbol { m } } _ { i } , \pmb { \Sigma } _ { i } ) } \\ & { ~ \pmb { \Sigma } _ { i } \triangleq ( \mathbf { I } _ { L } + \mathbf { W } ^ { \mathsf { T } } \pmb { \Psi } ^ { - 1 } \mathbf { W } ) ^ { - 1 } } \\ & { ~ \pmb { m } _ { i } \triangleq \pmb { \Sigma } _ { i } ( \mathbf { W } ^ { \mathsf { T } } \pmb { \Psi } ^ { - 1 } ( \pmb { x } _ { i } - \pmb { \mu } ) ) } \end{array}
$$

In the M step, it is easiest to estimate $\pmb { \mu }$ and $\mathbf { W }$ at the same time, by defining $\tilde { \mathbf { W } } = ( \mathbf { W } , \pmb { \mu } )$ , $\tilde { z } = ( z , 1 )$ , Also, define

$$
\begin{array} { r l } & { \pmb { b } _ { i } \triangleq \mathbb { E } \left[ \tilde { \mathbf { z } } | \pmb { x } _ { i } \right] = \left[ \pmb { m } _ { i } ; 1 \right] } \\ & { \mathbf { C } _ { i } \triangleq \mathbb { E } \left[ \tilde { \mathbf { z } } \tilde { \mathbf { z } } ^ { T } | \pmb { x } _ { i } , \right] = \left( \begin{array} { l r } { \mathbb { E } \left[ z z ^ { T } | \pmb { x } _ { i } \right] } & { \mathbb { E } \left[ z | \pmb { x } _ { i } \right] } \\ { \mathbb { E } \left[ z | \pmb { x } _ { i } \right] ^ { T } } & { 1 } \end{array} \right) } \end{array}
$$

Then the M step is as follows:

$$
\begin{array} { l } { { \hat { \tilde { \bf W } } = \left[ \sum _ { i } { \boldsymbol x } _ { i } { \boldsymbol b } _ { i } ^ { \top } \right] \left[ \sum _ { i } { \bf C } _ { i } \right] ^ { - 1 } } } \\ { { \hat { \bf W } = \displaystyle \frac { 1 } { N _ { D } } \mathrm { d i a g } \left\{ \sum _ { i } \left( { \boldsymbol x } _ { i } - \hat { \tilde { \bf W } } { \boldsymbol b } _ { i } \right) { \boldsymbol x } _ { i } ^ { T } \right\} } } \end{array}
$$

Note that these updates are for “vanilla” EM. A much faster version of this algorithm, based on ECM, is described in [ZY08].

# 20.2.3.2 EM for (P)PCA

We can also use EM to fit the PPCA model, which provides a useful alternative to eigenvector methods. This relies on the probabilistic formulation of PCA. However the algorithm continues to work in the zero noise limit, $\sigma ^ { 2 } = 0$ , as shown by [Row97].

In particular, let $\tilde { \mathbf { Z } } = \mathbf { Z } ^ { \top }$ be a $L \times N _ { \mathcal { D } }$ matrix storing the posterior means (low-dimensional representations) along its columns. Similarly, let $\tilde { \mathbf { X } } = \mathbf { X } ^ { \top }$ store the original data along its columns. From Equation (20.52), when $\sigma ^ { 2 } = 0$ , we have

$$
\tilde { \mathbf { Z } } = ( \mathbf { W } ^ { T } \mathbf { W } ) ^ { - 1 } \mathbf { W } ^ { T } \tilde { \mathbf { X } }
$$

This constitutes the $\mathrm { E }$ step. Notice that this is just an orthogonal projection of the data. From Equation 20.59, the M step is given by

$$
\hat { \mathbf { W } } = \left[ \sum _ { i } \pmb { x } _ { i } \mathbb { E } \left[ \pmb { z } _ { i } \right] ^ { T } \right] \left[ \sum _ { i } \mathbb { E } \left[ \pmb { z } _ { i } \right] \mathbb { E } \left[ \pmb { z } _ { i } \right] ^ { T } \right] ^ { - 1 }
$$

where we exploited the fact that $\Sigma = \mathrm { C o v } \left[ z _ { i } | \boldsymbol { x } _ { i } , \pmb { \theta } \right] = 0 \mathbf { I }$ when $\sigma ^ { 2 } = 0$ .

It is worth comparing this expression to the MLE for multi-output linear regression (Equation 11.2), which has the form $\begin{array} { r } { { \bf W } = ( \sum _ { i } \pmb { y } _ { i } \pmb { x } _ { i } ^ { T } ) ( \sum _ { i } \pmb { x } _ { i } \pmb { x } _ { i } ^ { T } ) ^ { - 1 } } \end{array}$ . Thus we see that the M step is like linear regression where we replace the observed inputs by the expected values of the latent variables.

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

In summary, here is the entire algorithm:

$$
\begin{array} { r } { \tilde { \mathbf { Z } } = ( \mathbf { W } ^ { T } \mathbf { W } ) ^ { - 1 } \mathbf { W } ^ { T } \tilde { \mathbf { X } } \mathbf { \Lambda } ( \mathrm { E } \mathbf { \Lambda } \mathrm { s t e p } ) } \\ { \mathbf { W } = \tilde { \mathbf { X } } \tilde { \mathbf { Z } } ^ { T } ( \tilde { \mathbf { Z } } \tilde { \mathbf { Z } } ^ { T } ) ^ { - 1 } \mathbf { \Lambda } ( \mathrm { M } \mathbf { \Lambda } \mathrm { s t e p } ) } \end{array}
$$

[TB99] showed that the only stable fixed point of the EM algorithm is the globally optimal solution. That is, the EM algorithm converges to a solution where $\mathbf { W }$ spans the same linear subspace as that defined by the first $L$ eigenvectors. However, if we want $\mathbf { W }$ to be orthogonal, and to contain the eigenvectors in descending order of eigenvalue, we have to orthogonalize the resulting matrix (which can be done quite cheaply). Alternatively, we can modify EM to give the principal basis directly [AO03].

This algorithm has a simple physical analogy in the case $D = 2$ and $L = 1$ [Row97]. Consider some points in $\mathbb { R } ^ { 2 }$ attached by springs to a rigid rod, whose orientation is defined by a vector $\mathbf { \boldsymbol { w } }$ . Let $z _ { i }$ be the location where the $i$ ’th spring attaches to the rod. In the E step, we hold the rod fixed, and let the attachment points slide around so as to minimize the spring energy (which is proportional to the sum of squared residuals). In the M step, we hold the attachment points fixed and let the rod rotate so as to minimize the spring energy. See Figure 20.10 for an illustration.

# 20.2.3.3 Advantages

EM for PCA has the following advantages over eigenvector methods:

• EM can be faster. In particular, assuming $N _ { \mathit { D } } , D \gg L$ , the dominant cost of EM is the projection operation in the $\mathrm { E }$ step, so the overall time is $O ( T L N _ { \mathcal { D } } D )$ , where $T$ is the number of iterations. [Row97] showed experimentally that the number of iterations is usually very small (the mean was 3.6), regardless of $N$ or $D$ . (This result depends on the ratio of eigenvalues of the empirical covariance matrix.) This is much faster than the $O ( \operatorname* { m i n } ( N D ^ { 2 } , D N ^ { 2 } ) )$ time required by straightforward eigenvector methods, although more sophisticated eigenvector methods, such as the Lanczos algorithm, have running times comparable to EM.   
• EM can be implemented in an online fashion, i.e., we can update our estimate of $\mathbf { W }$ as the data streams in.   
• EM can handle missing data in a simple way (see e.g., [IR10; DJ15]).   
• EM can be extended to handle mixtures of PPCA/ FA models (see Section 20.2.6).   
• EM can be modified to variational EM or to variational Bayes EM to fit more complex models (see e.g., Section 20.2.7).

# 20.2.4 Unidentifiability of the parameters

The parameters of a FA model are unidentifiable. To see this, consider a model with weights $\mathbf { W }$ and observation covariance $\Psi$ . We have

$$
\operatorname { C o v } \left[ \boldsymbol { x } \right] = \mathbf { W } \mathbb { E } \left[ \boldsymbol { z } \boldsymbol { z } ^ { \mathsf { T } } \right] \mathbf { W } ^ { \mathsf { T } } + \mathbb { E } \left[ \boldsymbol { \epsilon } \boldsymbol { \epsilon } ^ { \mathsf { T } } \right] = \mathbf { W } \mathbf { W } ^ { \mathsf { T } } + \boldsymbol { \Psi }
$$

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

![](images/1eab81c34f0e9cad18503415ab278f517e7dc62a1c6775843a39ae75306d46d5.jpg)  
Figure 20.10: Illustration of EM for PCA when $D = 2$ and $L = 1$ . Green stars are the original data points, black circles are their reconstructions. The weight vector $\textbf { \em w }$ is represented by blue line. (a) We start with a random initial guess of $\mathbf { \boldsymbol { w } }$ . The $E$ step is represented by the orthogonal projections. (b) We update the rod w in the M step, keeping the projections onto the rod (black circles) fixed. (c) Another E step. The black circles can ’slide’ along the rod, but the rod stays fixed. (d) Another M step. Adapted from Figure 12.12 of [Bis06]. Generated by pcaEmStepByStep.ipynb.

Now consider a different model with weights $\tilde { \mathbf { W } } = \mathbf { W } \mathbf { R } \mathbf { \Lambda }$ , where $\mathbf { R }$ is an arbitrary orthogonal rotation matrix, satisfying $\mathbf { R R } ^ { \mathsf { I } } = \mathbf { I }$ . This has the same likelihood, since

$$
\mathrm { C o v } \left[ \mathbf { \boldsymbol { x } } \right] = \tilde { \mathbf { W } } \mathbb { E } \left[ z z ^ { \mathsf { T } } \right] \tilde { \mathbf { W } } ^ { \mathsf { T } } + \mathbb { E } \left[ \epsilon \boldsymbol { \epsilon } ^ { \mathsf { T } } \right] = \mathbf { W } \mathbf { R } \mathbf { R } ^ { \mathsf { T } } \mathbf { W } ^ { \mathsf { T } } + \boldsymbol { \Psi } = \mathbf { W } \mathbf { W } ^ { \mathsf { T } } + \boldsymbol { \Psi }
$$

Geometrically, multiplying $\mathbf { W }$ by an orthogonal matrix is like rotating $\mathscr { z }$ before generating $_ { x }$ ; but since $\boldsymbol { z }$ is drawn from an isotropic Gaussian, this makes no difference to the likelihood. Consequently, we cannot uniquely identify $\mathbf { W }$ , and therefore cannot uniquely identify the latent factors, either.

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

To break this symmetry, several solutions can be used, as we discuss below.

• Forcing W to have orthonormal columns. Perhaps the simplest solution to the identifiability problem is to force W to have orthonormal columns. This is the approach adopted by PCA. The resulting posterior estimate will then be unique, up to permutation of the latent dimensions. (In PCA, this ordering ambiguity is resolved by sorting the dimensions in order of decreasing eigenvalues of W.)   
• Forcing W to be lower triangular. One way to resolve permutation unidentifiability, which is popular in the Bayesian community (e.g., [LW04c]), is to ensure that the first visible feature is only generated by the first latent factor, the second visible feature is only generated by the first two latent factors, and so on. For example, if $L = 3$ and $D = 4$ , the corresponding factor loading matrix is given by

$$
\mathbf { W } = \left( \begin{array} { c c c } { w _ { 1 1 } } & { 0 } & { 0 } \\ { w _ { 2 1 } } & { w _ { 2 2 } } & { 0 } \\ { w _ { 3 1 } } & { w _ { 3 2 } } & { w _ { 3 3 } } \\ { w _ { 4 1 } } & { w _ { 4 2 } } & { w _ { 4 3 } } \end{array} \right)
$$

We also require that $w _ { k k } > 0$ for $k = 1 : L$ . The total number of parameters in this constrained matrix is $D + D L - L ( L - 1 ) / 2$ , which is equal to the number of uniquely identifiable parameters in FA.3 The disadvantage of this method is that the first $L$ visible variables, known as the founder variables, affect the interpretation of the latent factors, and so must be chosen carefully.

• Sparsity promoting priors on the weights. Instead of pre-specifying which entries in $\mathbf { W }$ are zero, we can encourage the entries to be zero, using $\ell _ { 1 }$ regularization [ZHT06], ARD [Bis99; AB08], or spike-and-slab priors [Rat+09]. This is called sparse factor analysis. This does not necessarily ensure a unique MAP estimate, but it does encourage interpretable solutions.   
• Choosing an informative rotation matrix. There are a variety of heuristic methods that try to find rotation matrices $\mathbf { R }$ which can be used to modify $\mathbf { W }$ (and hence the latent factors) so as to try to increase the interpretability, typically by encouraging them to be (approximately) sparse. One popular method is known as varimax [Kai58].   
• Use of non-Gaussian priors for the latent factors. If we replace the prior on the latent variables, $p ( z )$ , with a non-Gaussian distribution, we can sometimes uniquely identify $\mathbf { W }$ , as well as the latent factors. See e.g., [KKH20] for details.

# 20.2.5 Nonlinear factor analysis

The FA model assumes the observed data can be modeled as arising from a linear mapping from a low-dimensional set of Gaussian factors. One way to relax this assumption is to let the mapping from $\boldsymbol { z }$ to $_ { x }$ be a nonlinear model, such as a neural network. That is, the model becomes

$$
p ( { \pmb x } ) = \int \mathcal { N } ( { \pmb x } | f ( { \pmb z } ; { \pmb \theta } ) , \Psi ) \mathcal { N } ( { \pmb z } | \mathbf { 0 } , \mathbf { I } ) d z
$$

![](images/e5622ca15ae755ae009d99e4dd541c11a382e18fe91e47f36988f1c545c3c56f.jpg)  
Figure 20.11: Mixture of factor analyzers as a PGM.

This is called nonlinear factor analysis. Unfortunately we can no longer compute the posterior or the MLE exactly, so we need to use approximate methods. In Section 20.3.5, we discuss variational autoencoders, which is the most common way to approximate a nonlinear FA model.

# 20.2.6 Mixtures of factor analysers

The factor analysis model (Section 20.2) assumes the observed data can be modeled as arising from a linear mapping from a low-dimensional set of Gaussian factors. One way to relax this assumption is to assume the model is only locally linear, so the overall model becomes a (weighted) combination of FA models; this is called a mixture of factor analysers. The overall model for the data is a mixture of linear manifolds, which can be used to approximate an overall curved manifold.

More precisely, let latent indicator $m _ { n } \in \{ 1 , \ldots , K \}$ , specifying which subspace (cluster) we should use to generate the data. If $m _ { n } = k$ , we sample $z _ { n }$ from a Gaussian prior and pass it through the $\mathbf { W } _ { k }$ matrix and add noise, where $\mathbf { W } _ { k }$ maps from the $L$ -dimensional subspace to the $D$ -dimensional visible space.4 More precisely, the model is as follows:

$$
\begin{array} { c } { p ( { \pmb x } _ { n } | z _ { n } , m _ { n } = k , \pmb \theta ) = \mathcal { N } ( { \pmb x } _ { n } | { \pmb \mu } _ { k } + { \mathbf W } _ { k } z _ { n } , \pmb \Psi _ { k } ) } \\ { p ( { \pmb z } _ { n } | \pmb \theta ) = \mathcal { N } ( { \pmb z } _ { n } | { \bf 0 } , { \bf I } ) } \\ { p ( m _ { n } | \pmb \theta ) = \mathrm { C a t } ( m _ { n } | \pmb \pi ) } \end{array}
$$

This is called a mixture of factor analysers (MFA) [GH96]. The corresponding distribution in the visible space is given by

$$
\displaystyle { x | \theta ) = \sum _ { k } p ( c = k ) \int d z \ p ( z | c ) p ( x | z , c ) = \sum _ { k } \pi _ { k } \int d z \ { \mathcal { N } } ( z | { \boldsymbol { \mu } } _ { k } , \mathbf { I } ) { \mathcal { N } } ( x | \mathbf { W } z , c ) } .
$$

In the special case that $\Psi _ { k } = \sigma ^ { 2 } \mathbf { I }$ , we get a mixture of PPCA models (although it is difficult to ensure orthogonality of the $\mathbf { W } _ { k }$ in this case). See Figure 20.12 for an example of the method applied to some 2d data.

We can think of this as a low-rank version of a mixture of Gaussians. In particular, this model needs $O ( K L D )$ parameters instead of the $O ( K D ^ { 2 } )$ parameters needed for a mixture of full covariance Gaussians. This can reduce overfitting.

![](images/992f4531afc14cb82e1ffe9b2b064b0e00eb773d60d0b1157bd3299337d4ff60.jpg)  
Figure 20.12: Mixture of PPCA models fit to a 2d dataset, using $L = 1$ latent dimensions. (a) $K = 1$ mixture components. (b) $K = 1 0$ mixture components. Generated by mixPpcaDemo.ipynb.

# 20.2.7 Exponential family factor analysis

So far we have assumed the observed data is real-valued, so $\pmb { x } _ { n } \in \mathbb { R } ^ { D }$ . If we want to model other kinds of data (e.g., binary or categorical), we can simply replace the Gaussian output distribution with a suitable member of the exponential family, where the natural parameters are given by a linear function of $z _ { n }$ . That is, we use

$$
p ( \pmb { x } _ { n } | \pmb { z } _ { n } ) = \mathrm { e x p } ( \tilde { T } ( \pmb { x } ) ^ { \top } \pmb { \theta } + h ( \pmb { x } ) - g ( \pmb { \theta } ) )
$$

where the $N \times D$ matrix of natural parameters is assumed to be given by the low rank decomposition $\mathbf { \Theta } \Theta = \mathbf { Z } \mathbf { W }$ , where $\mathbf { Z }$ is $N \times L$ and $\mathbf { W }$ is $L \times D$ . The resulting model is called exponential family factor analysis.

Unlike the linear-Gaussian FA, we cannot compute the exact posterior $p ( \boldsymbol { z } _ { n } | \boldsymbol { x } _ { n } , \mathbf { W } )$ due to the lack of conjugacy between the expfam likelihood and the Gaussian prior. Furthermore, we cannot compute the exact marginal likelihood either, which prevents us from finding the optimal MLE.

[CDS02] proposed a coordinate ascent method for a deterministic variant of this model, known as exponential family PCA. This alternates between computing a point estimate of $z _ { n }$ and $\mathbf { W }$ . This can be regarded as a degenerate version of variational EM, where the E step uses a delta function posterior for $z _ { n }$ . [GS08] present an improved algorithm that finds the global optimum, and [Ude+16] presents an extension called generalized low rank models, that covers many different kinds of loss function.

However, it is often preferable to use a probabilistic version of the model, rather than computing point estimates of the latent factors. In this case, we must represent the posterior using a nondegenerate distribution to avoid overfitting, since the number of latent variables is proportional to the number of datacases [WCS08]. Fortunately, we can use a non-degenerate posterior, such as a Gaussian, by optimizing the variational lower bound. We give some examples of this below.

# 20.2.7.1 Example: binary PCA

Consider a factored Bernoulli likelihood:

$$
p ( \pmb { x } | \pmb { z } ) = \prod _ { d } \mathrm { B e r } ( x _ { d } | \sigma ( \pmb { w } _ { d } ^ { \top } \pmb { z } ) )
$$

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

![](images/0ebcaa0acaa4ee9e6716df0466d71614cd3ca0506858e475192aa8d9ffab3595.jpg)  
Figure 20.13: (a) 150 synthetic 16 dimensional bit vectors. (b) The 2d embedding learned by binary PCA, fit using variational EM. We have color coded points by the identity of the true “prototype” that generated them. (c) Predicted probability of being on. (d) Thresholded predictions. Generated by binary_fa_demo.ipynb.

Suppose we observe $N _ { \mathrm { } D } = 1 5 0$ bit vectors of length $D = 6$ . Each example is generated by choosing one of three binary prototype vectors, and then by flipping bits at random. See Figure 20.13(a) for the data. We can fit this using the variational EM algorithm (see [Tip98] for details). We use $L = 2$ latent dimensions to allow us to visualize the latent space. In Figure 20.13(b), we plot $\mathbb { E } \left[ z _ { n } | \boldsymbol { \mathbf { \mathit { x } } } _ { n } , \hat { \boldsymbol { \mathbf { W } } } \right]$ . We see that the projected points group into three distinct clusters, as is to be expected. In Figure 20.13(c), we plot the reconstructed version of the data, which is computed as follows:

$$
p ( \hat { x } _ { n d } = 1 | \pmb { x } _ { n } ) = \int d z _ { n } \ p ( z _ { n } | \pmb { x } _ { n } ) p ( \hat { x } _ { n d } | z _ { n } )
$$

If we threshold these probabilities at 0.5 (corresponding to a MAP estimate), we get the “denoised” version of the data in Figure 20.13(d).

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

![](images/dc8e68621331d4ab02ac756ba34eb5e89f8dfe7941e45da728079c39ca3689bc.jpg)  
Figure 20.14: Gaussian latent factor models for paired data. (a) Supervised PCA. (b) Partial least squares.

# 20.2.7.2 Example: categorical PCA

We can generalize the model in Section 20.2.7.1 to handle categorical data by using the following likelihood:

$$
\begin{array}{c} p ( { \pmb x } | { \pmb z } ) = \prod _ { d } \mathrm { C a t } ( x _ { d } | \mathrm { s o f t m a x } ( \mathbf { W } _ { d } { \pmb z } ) )  \\ { { \frac { 1 } { d } } \mathrm { C a t } ( { \pmb x } _ { d } | \mathrm { s o f t m a x } ( \mathbf { W } _ { d } { \pmb z } ) ) } \end{array}
$$

We call this categorical PCA (CatPCA). A variational EM algorithm for fitting this is described in [Kha+10].

# 20.2.8 Factor analysis models for paired data

In this section, we discuss linear-Gaussian factor analysis models when we have two kinds of observed variables, $\pmb { x } \in \mathbb { R } ^ { D _ { x } }$ and $\boldsymbol { y } \in \mathbb { R } ^ { D _ { y } }$ , which are paired. These often correspond to different sensors or modalities (e.g., images and sound). We follow the presentation of [Vir10].

# 20.2.8.1 Supervised PCA

In supervised PCA [Yu+06], we model the joint $p ( { \pmb x } , { \pmb y } )$ using a shared low-dimensional representation using the following linear Gaussian model:

$$
\begin{array} { c } { p ( z _ { n } ) = \mathcal { N } ( z _ { n } | \mathbf { 0 } , \mathbf { I } _ { L } ) } \\ { p ( \pmb { x } _ { n } | z _ { n } , \pmb { \theta } ) = \mathcal { N } ( \pmb { x } _ { n } | \mathbf { W } _ { x } z _ { n } , \sigma _ { x } ^ { 2 } \mathbf { I } _ { D _ { x } } ) } \\ { p ( \pmb { y } _ { n } | z _ { n } , \pmb { \theta } ) = \mathcal { N } ( \pmb { y } _ { n } | \mathbf { W } _ { y } z _ { n } , \sigma _ { y } ^ { 2 } \mathbf { I } _ { D _ { y } } ) } \end{array}
$$

This is illustrated as a graphical model in Figure 20.14a. The intuition is that $z _ { n }$ is a shared latent subspace, that captures features that ${ \boldsymbol { \mathbf { \mathit { x } } } } _ { n }$ and ${ \bf { y } } _ { n }$ have in common. The variance terms $\sigma _ { x }$ and $\sigma _ { y }$ control how much emphasis the model puts on the two different signals. If we put a prior on the parameters $\pmb { \theta } = ( \mathbf { W } _ { x } , \mathbf { W } _ { y } , \sigma _ { x } , \sigma _ { y } )$ , we recover the Bayesian factor regression model of [Wes03].

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

We can marginalize out $z _ { n }$ to get $p ( \pmb { y } _ { n } | \pmb { x } _ { n } )$ . If ${ \bf { y } } _ { n }$ is a scalar, this becomes

$$
\begin{array} { r l } & { p ( y _ { n } | \mathbfcal { x } _ { n } , \pmb { \theta } ) = \mathcal { N } ( y _ { n } | \mathbfcal { x } _ { n } ^ { \top } \mathbf { v } , { w } _ { y } ^ { \top } \mathbf { C } { w } _ { y } + \sigma _ { y } ^ { 2 } ) } \\ & { \quad \quad \quad \mathbf { C } = ( \mathbf I + \sigma _ { x } ^ { - 2 } \mathbf W _ { x } ^ { \top } \mathbf W _ { x } ) ^ { - 1 } } \\ & { \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad v = \sigma _ { x } ^ { - 2 } \mathbf W _ { x } \mathbf C w _ { y } } \end{array}
$$

To apply this to the classification setting, we can use supervised ePCA [Guo09], in which we replace the Gaussian $p ( \pmb { y } | \pmb { z } )$ with a logistic regression model.

This model is completely symmetric in $_ { x }$ and $\pmb { y }$ . If our goal is to predict $\mathbf { \Delta } _ { \mathbf { \mathcal { Y } } }$ from $_ { x }$ via the latent bottleneck $\boldsymbol { z }$ , then we might want to upweight the likelihood term for $\pmb { y }$ , as proposed in [Ris+08]. This gives

$$
p ( \mathbf { X } , \mathbf { Y } , \mathbf { Z } | \pmb { \theta } ) = p ( \mathbf { Y } | \mathbf { Z } , \mathbf { W } _ { y } ) p ( \mathbf { X } | \mathbf { Z } , \mathbf { W } _ { x } ) ^ { \alpha } p ( \mathbf { Z } )
$$

where $\alpha \leq 1$ controls the relative importance of modeling the two sources. The value of $\alpha$ can be chosen by cross-validation.

# 20.2.8.2 Partial least squares

Another way to improve the predictive performance in supervised tasks is to allow the inputs $_ { x }$ to have their own “private” noise source that is independent on the target variable, since not all variation in $_ { x }$ is relevant for predictive purposes. We can do this by introducing an extra latent variable $z _ { n } ^ { x }$ just for the inputs, that is different from $z _ { n } ^ { s }$ that is the shared bottleneck between ${ \boldsymbol { \mathbf { \mathit { x } } } } _ { n }$ and ${ \pmb y } _ { n }$ . In the Gaussian case, the overall model has the form

$$
\begin{array} { r l } & { \qquad p ( z _ { n } ) = \mathcal { N } ( z _ { n } ^ { s } | \mathbf { 0 } , \mathbf { I } ) \mathcal { N } ( z _ { n } ^ { x } | \mathbf { 0 } , \mathbf { I } ) } \\ & { \qquad p ( \mathbf { x } _ { n } | z _ { n } , \pmb { \theta } ) = \mathcal { N } ( \mathbf { x } _ { n } | \mathbf { W } _ { x } z _ { n } ^ { s } + \mathbf { B } _ { x } z _ { n } ^ { x } , \sigma _ { x } ^ { 2 } \mathbf { I } ) } \\ & { \qquad p ( \pmb { y } _ { n } | z _ { n } , \pmb { \theta } ) = \mathcal { N } ( \pmb { y } _ { n } | \mathbf { W } _ { y } z _ { n } ^ { s } , \sigma _ { y } ^ { 2 } \mathbf { I } ) } \end{array}
$$

See Figure 20.14b. MLE for $\pmb \theta$ in this model is equivalent to the technique of partial least squares (PLS) [Gus01; Nou+02; Sun+09].

# 20.2.8.3 Canonical correlation analysis

In some cases, we want to use a fully symmetric model, so we can capture the dependence between $_ { x }$ and $\mathbf { \nabla } _ { \mathbf { \boldsymbol { y } } }$ , while allowing for domain-specific or “private” noise sources We can do this by introducing a latent variable $z _ { n } ^ { x }$ just for ${ \boldsymbol { \mathbf { \mathit { x } } } } _ { n }$ , a latent variable $z _ { n } ^ { y }$ just for ${ \bf { y } } _ { n }$ , and a shared latent variable $z _ { n } ^ { s }$ . In the Gaussian case, the overall model has the form

$$
\begin{array} { r l } & { \quad p ( z _ { n } ) = { \mathcal { N } } ( z _ { n } ^ { s } | \mathbf { 0 } , \mathbf { I } ) { \mathcal { N } } ( z _ { n } ^ { x } | \mathbf { 0 } , \mathbf { I } ) } \\ & { \quad p ( \mathbf { x } _ { n } | z _ { n } , \pmb { \theta } ) = { \mathcal { N } } ( \mathbf { x } _ { n } | \mathbf { W } _ { x } z _ { n } ^ { s } + \mathbf { B } _ { x } z _ { n } ^ { x } , \sigma _ { x } ^ { 2 } \mathbf { I } ) } \\ & { \quad p ( \pmb { y } _ { n } | z _ { n } , \pmb { \theta } ) = { \mathcal { N } } ( \pmb { y } _ { n } | \mathbf { W } _ { y } z _ { n } ^ { s } + \mathbf { B } _ { y } z _ { n } ^ { y } , \sigma _ { y } ^ { 2 } \mathbf { I } ) } \end{array}
$$

where $\mathbf { W } _ { x }$ and $\mathbf { W } _ { y }$ are $L ^ { s } \times D$ dimensional, $\mathbf { V } _ { x }$ is $L ^ { x } \times D$ dimensional, and $\mathbf { V } _ { y }$ is $L ^ { y } \times D$ dimensional.   
See Figure 20.15 for the PGM.

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

![](images/98625386c5cfdc4976ae941568a49eee85019286f9b9f1f4b4ed24b594696f9a.jpg)  
Figure 20.15: Canonical correlation analysis as a PGM.

If we marginalize out all the latent variables, we get the following distribution on the visibles (where we assume $\sigma _ { x } = \sigma _ { y } = \sigma$ ):

$$
p ( { \pmb x } _ { n } , { \pmb y } _ { n } ) = \int d z _ { n } p ( { \pmb z } _ { n } ) p ( { \pmb x } _ { n } , { \pmb y } _ { n } | z _ { n } ) = \mathcal { N } ( { \pmb x } _ { n } , { \pmb y } _ { n } | { \pmb \mu } , \mathbf { W } \mathbf { W } ^ { \top } + \sigma ^ { 2 } \mathbf { I } )
$$

where $\pmb { \mu } = ( \mu _ { x } ; \pmb { \mu } _ { y } )$ , and $\mathbf { W } = | \mathbf { W } _ { x } ; \mathbf { W } _ { y } |$ . Thus the induced covariance is the following low rank matrix:

$$
\mathbf { W } \mathbf { W } ^ { \mathsf { T } } = \left( \begin{array} { l l } { \mathbf { W } _ { x } \mathbf { W } _ { x } ^ { \mathsf { T } } } & { \mathbf { W } _ { x } \mathbf { W } _ { y } ^ { \mathsf { T } } } \\ { \mathbf { W } _ { y } \mathbf { W } _ { x } ^ { \mathsf { T } } } & { \mathbf { W } _ { y } \mathbf { W } _ { y } ^ { \mathsf { T } } } \end{array} \right)
$$

[BJ05] showed that MLE for this model is equivalent to a classical statistical method known as canonical correlation analysis or CCA [Hot36]. However, the PGM perspective allows us to easily generalize to multiple kinds of observations (this is known as generalized CCA [Hor61]) or to nonlinear models (this is known as deep CCA [WLL16; SNM16]), or exponential family CCA [KVK10]. See [Uur+17] for further discussion of CCA and its extensions.

# 20.3 Autoencoders

We can think of PCA (Section 20.1) and factor analysis (Section 20.2) as learning a (linear) mapping from $x  z$ , called the encoder, $f _ { e }$ , and learning another (linear) mapping $z  x$ , called the decoder, $f _ { d }$ . The overall reconstruction function has the form $r ( { \pmb x } ) = f _ { d } ( f _ { e } ( { \pmb x } ) )$ . The model is trained to minimize $\mathcal { L } ( \pmb { \theta } ) = | | \boldsymbol { r } ( \pmb { x } ) - \pmb { x } | | _ { 2 } ^ { 2 }$ . More generally, we can use $\begin{array} { r } { \mathcal { L } ( \pmb { \theta } ) = - \log p ( \pmb { x } | r ( \pmb { x } ) ) } \end{array}$ .

In this section, we consider the case where the encoder and decoder are nonlinear mappings implemented by neural networks. This is called an autoencoder. If we use an MLP with one hidden layer, we get the model shown Figure 20.16. We can think of the hidden units in the middle as a low-dimensional bottleneck between the input and its reconstruction.

Of course, if the hidden layer is wide enough, there is nothing to stop this model from learning the identity function. To prevent this degenerate solution, we have to restrict the model in some way. The simplest approach is to use a narrow bottleneck layer, with $L \ll D$ ; this is called an undercomplete representation. The other approach is to use $L \gg D$ , known as an overcomplete representation, but to impose some other kind of regularization, such as adding noise to the inputs, forcing the

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license activations of the hidden units to be sparse, or imposing a penalty on the derivatives of the hidden units. We discuss these options in more detail below.

![](images/616e8cea6541c46475234b79b9f3e3075a591aa14d08c66b0298f222064ba9d4.jpg)  
Figure 20.16: An autoencoder with one hidden layer.

# 20.3.1 Bottleneck autoencoders

We start by considering the special case of a linear autoencoder, in which there is one hidden layer, the hidden units are computed using $\boldsymbol { z } = \mathbf { W } _ { 1 } \boldsymbol { x }$ , and the output is reconstructed using $\hat { \mathbf { \Delta } } \hat { \mathbf { \Delta } } \hat { \mathbf { \Delta } } \hat { \mathbf { \Delta } } \hat { \mathbf { \Delta } } \hat { \mathbf { \Delta } } \hat { \mathbf { \Delta } } \hat { \mathbf { \Delta } } \hat { \mathbf { \Delta } } \hat { \mathbf { \Delta } } \hat { \mathbf { \Delta } } \hat { \mathbf { \Delta } } \hat { \mathbf { \Delta } } \hat { \mathbf { \Delta } } \hat { \mathbf { \Delta } } \hat { \mathbf { \Delta } } \hat { \mathbf { \Delta } } \hat { \mathbf { \Delta } } \hat { \mathbf { \Delta } } \hat { \mathbf { \Delta } } \hat { \mathbf { \Delta } } \hat { \mathbf { \Delta } } \hat { \mathbf { \Delta } } \hat { \mathbf { \Delta } } \hat { \mathbf { \Delta } } \hat { \mathbf { \Delta } } \hat { \mathbf { \Delta } } \hat { \mathbf { \Delta } }$ , where $\mathbf { W } _ { 1 }$ is a $L \times D$ matrix, $\mathbf { W } _ { 2 }$ is a $D \times L$ matrix, and $L < D$ . Hence $\hat { \pmb { x } } = \mathbf { W } _ { 2 } \mathbf { W } _ { 1 } \pmb { x } = \mathbf { W } \pmb { x }$ is the output of the model. If we train this model to minimize the squared reconstruction error, $\begin{array} { r } { \mathcal { L } ( \mathbf { W } ) = \sum _ { n = 1 } ^ { N } | | \pmb { x } _ { n } - \mathbf { W } \pmb { x } _ { n } | | _ { 2 } ^ { 2 } } \end{array}$ , one can show [BH89; KJ95] that $\hat { \mathbf { W } }$ is an orthogonal projection onto the first $L$ eigenvectors of the empirical covariance matrix of the data. This is therefore equivalent to PCA.

If we introduce nonlinearities into the autoencoder, we get a model that is strictly more powerful than PCA, as proved in [JHG00]. Such methods can learn very useful low dimensional representations of data.

Consider fitting an autoencoder to the Fashion MNIST dataset. We consider both an MLP architecture (with 2 layers and a bottleneck of size 30), and a CNN based architecture (with 3 layers and a 3d bottleneck with 64 channels). We use a Bernoulli likelihood model and binary cross entropy as the loss. Figure 20.17 shows some test images and their reconstructions. We see that the CNN model reconstructs the images more accurately than the MLP model. However, both models are small, and were only trained for 5 epochs; results can be improved by using larger models, and training for longer.

Figure 20.18 visualizes the first 2 (of 30) latent dimensions produced by the MLP-AE. More precisely, we plot the tSNE embeddings (see Section 20.4.10), color coded by class label. We also show some corresponding images from the dataset, from which the embeddings were derived. We see that the method has done a good job of separating the classes in a fully unsupervised way. We also see that the latent space of the MLP and CNN models is very similar (at least when viewed through this 2d projection).

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

![](images/c91b8cc759a4ced83f9cd5d06682be088f412fc1f43eb885679c4dfe754218eb.jpg)  
Figure 20.17: Results of applying an autoencoder to the Fashion MNIST data. Top row are first 5 images from validation set. Bottom row are reconstructions. (a) MLP model (trained for 20 epochs). The encoder is an MLP with architecture 784-100-30. The decoder is the mirror image of this. (b) CNN model (trained for 5 epochs). The encoder is a CNN model with architecture Conv2D(16, $3 \times 3$ , same, selu), MaxPool2D(2x2), Conv2D(32, $3 \times 3$ , same, selu), MaxPool2D( $2 \times 2 )$ , Conv2D(64, $3 \times 3$ , same, selu), MaxPool2D( $2 \times 2$ ). The decoder is the mirror image of this, using transposed convolution and without the max pooling layers. Adapted from Figure 17.4 of [Gér19]. Generated by ae_mnist_tf.ipynb.

![](images/9bdb5c1a02d39723f17708fe51d7980e2cfe5b2000cd1a3a77b94bf13c807135.jpg)  
Figure 20.18: tSNE plot of the first 2 latent dimensions of the Fashion MNIST validation set using an autoencoder. (a) MLP. (b) CNN. Adapted from Figure 17.5 of [Gér19]. Generated by ae_mnist_tf.ipynb.

# 20.3.2 Denoising autoencoders

One useful way to control the capacity of an autoencoder is to add noise to its input, and then train the model to reconstruct a clean (uncorrupted) version of the original input. This is called a denoising autoencoder [Vin+10a].

We can implement this by adding Gaussian noise, or using Bernoulli dropout. Figure 20.19 shows some reconstructions of corrupted images computed using a DAE. We see that the model is able to “hallucinate” details that are missing in the input, since it has seen similar images before, and can store this information in the parameters of the model.

Suppose we train a DAE using Gaussian corruption and squared error reconstruction, i.e., we use $p _ { c } ( \tilde { \mathbf { \boldsymbol { x } } } | \mathbf { \boldsymbol { x } } ) = \mathcal { N } ( \tilde { \mathbf { \boldsymbol { x } } } | \mathbf { \boldsymbol { x } } , \sigma ^ { 2 } \mathbf { I } )$ and $\ell ( \pmb { x } , r ( \tilde { \pmb { x } } ) ) = | | \pmb { e } | | _ { 2 } ^ { 2 }$ , where $e ( { \pmb x } ) = r ( { \tilde { \pmb x } } ) - { \pmb x }$ is the residual error for example

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license $_ { x }$ . Then one can show [AB14] the remarkable result that, as $\sigma  0$ (and with a sufficiently powerful model and enough data), the residuals approximate the score function, which is the log probability of the data, i.e., $e ( \pmb { x } ) \approx \nabla _ { \pmb { x } } \log p ( \pmb { x } )$ . That is, the DAE learns a vector field, corresponding to the gradient of the log data density. Thus points that are close to the data manifold will be projected onto it via the sampling process. See Figure 20.20 for an illustration.

![](images/9648601c3a129a23bd71f5217d8efa8aedbf8b3d1ed74285f9c4d3db7c0a88a5.jpg)  
Figure 20.19: Denoising autoencoder (MLP architecture) applied to some noisy Fashion MNIST images from the validation set. (a) Gaussian noise. (b) Bernoulli dropout noise. Top row: input. Bottom row: output. Adapted from Figure 17.9 of [Gér19]. Generated by ae_mnist_tf.ipynb.

![](images/fa17b25a58864d65d09ee95d06418b8ff406cb713acdbf59381c925ff315ba1f.jpg)  
Figure 20.20: The residual error from a $D A E$ , $e ( { \pmb x } ) = r ( { \tilde { \pmb x } } ) - { \pmb x }$ , can learn a vector field corresponding to the score function. Arrows point towards higher probability regions. The length of the arrow is proportional to $| | e ( { \pmb x } ) | |$ , so points near the 1d data manifold (represented by the curved line) have smaller arrows. From Figure 5 of [AB14]. Used with kind permission of Guillaume Alain.

# 20.3.3 Contractive autoencoders

A different way to regularize autoencoders is by adding the penalty term

$$
\Omega ( z , \pmb { x } ) = \lambda | | \frac { \partial f _ { e } ( \pmb { x } ) } { \partial \pmb { x } } | | _ { F } ^ { 2 } = \lambda \sum _ { k } | | \nabla _ { \pmb { x } } h _ { k } ( \pmb { x } ) | | _ { 2 } ^ { 2 }
$$

to the reconstruction loss, where $h _ { k }$ is the value of the $k$ ’th hidden embedding unit. That is, we penalize the Frobenius norm of the encoder’s Jacobian. This is called a contractive autoencoder

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022 [Rif+11]. (A linear operator with Jacobian $\mathbf { J }$ is called a contraction if $| | \mathbf { J } \pmb { x } | | \leq 1$ for all unit-norm inputs $_ { x }$ .)

To understand why this is useful, consider Figure 20.20. We can approximate the curved lowdimensional manifold by a series of locally linear manifolds. These linear approximations can be computed using the Jacobian of the encoder at each point. By encouraging these to be contractive, we ensure the model “pushes” inputs that are off the manifold to move back towards it.

Another way to think about CAEs is as follows. To minimize the penalty term, the model would like to ensure the encoder is a constant function. However, if it was completely constant, it would ignore its input, and hence incur high reconstruction cost. Thus the two terms together encourage the model to learn a representation where only a few units change in response to the most significant variations in the input.

One possible degenerate solution is that the encoder simply learns to multiply the input by a small constant $\epsilon$ (which scales down the Jacobian), followed by a decoder that divides by $\epsilon$ (which reconstructs perfectly). To avoid this, we can tie the weights of the encoder and decoder, by setting the weight matrix for layer $\ell$ of $f _ { d }$ to be the transpose of the weight matrix for layer $\ell$ of $f _ { e }$ , but using untied bias terms. Unfortunately CAEs are slow to train, because of the expense of computing the Jacobian.

# 20.3.4 Sparse autoencoders

Yet another way to regularize autoencoders is to add a sparsity penalty to the latent activations of the form $\Omega ( z ) = \lambda | | z | | _ { 1 }$ . (This is called activity regularization.)

An alternative way to implement sparsity, that often gives better results, is to use logistic units, and then to compute the expected fraction of time each unit $k$ is on within a minibatch (call this $q _ { k }$ ), and ensure that this is close to a desired target value $p$ , as proposed in [GBB11]. In particular, we use the regularizer $\begin{array} { r } { \Omega ( z _ { 1 : L , 1 : N } ) = \lambda \sum _ { k } D _ { \mathbb { K L } } ( \pmb { p } \| \ \pmb { q } _ { k } ) } \end{array}$ for latent dimensions $1 : L$ and examples $1 : N$ , where $\pmb { p } = ( p , 1 - p )$ is the desired target distribution, and $\pmb q _ { k } = ( q _ { k } , 1 - q _ { k } )$ is the empirical distribution for unit $k$ , computed using $\begin{array} { r } { q _ { k } = \frac { 1 } { N } \sum _ { n = 1 } ^ { N } \mathbb { I } \left( z _ { n , k } = 1 \right) } \end{array}$ ).

Figure 20.21 shows the results when fitting an AE-MLP (with 300 hidden units) to Fashion MNIST. If we set $\lambda = 0$ (i.e., if we don’t impose a sparsity penalty), we see that the average activation value is about 0.4, with most neurons being partially activated most of the time. With the $\ell _ { 1 }$ penalty, we see that most units are off all the time, which means they are not being used at all. With the KL penalty, we see that about $7 0 \%$ of neurons are off on average, but unlike the $\ell _ { 1 }$ case, we don’t see units being permanently turned off (the average activation level is 0.1). This latter kind of sparse firing pattern is similar to that observed in biological brains (see e.g., [Bey+19]).

# 20.3.5 Variational autoencoders

In this section, we discuss the variational autoencoder or VAE [KW14; RMW14; KW19a], which can be thought of as a probabilistic version of a deterministic autoencoder (Section 20.3) The principal advantage is that a VAE is a generative model that can create new samples, whereas an autoencoder just computes embeddings of input vectors.

We discuss VAEs in detail in the sequel to this book, [Mur23]. However, in brief, the VAE combines two key ideas. First we create a non-linear extension of the factor analysis generative model, i.e., we

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license replace $p ( \pmb { x } | z ) = \mathcal { N } ( \pmb { x } | \mathbf { W } z , \sigma ^ { 2 } \mathbf { I } )$ with

![](images/2323fdfbcd0fb56352ba8e39553ec2d382d454e6dbeb2f4419641969745c1b32.jpg)  
Figure 20.21: Neuron activity (in the bottleneck layer) for an autoencoder applied to Fashion MNIST. We show results for three models, with different kinds of sparsity penalty: no penalty (left column), $\ell _ { 1 }$ penalty (middle column), KL penalty (right column). Top row: Heatmap of 300 neuron activations (columns) across 100 examples (rows). Middle row: Histogram of activation levels derived from this heatmap. Bottom row: Histogram of the mean activation per neuron, averaged over all examples in the validation set. Adapted from Figure 17.11 of [Gér19]. Generated by ae_mnist_tf.ipynb.

$$
p _ { \pmb { \theta } } ( \pmb { x } | z ) = \mathcal { N } ( \pmb { x } | f _ { d } ( z ; \pmb { \theta } ) , \sigma ^ { 2 } \mathbf { I } )
$$

where $f _ { d }$ is the decoder. For binary observations we should use a Bernoulli likelihood:

$$
p ( \pmb { x } | \boldsymbol { z } , \pmb \theta ) = \prod _ { i = 1 } ^ { D } \mathrm { B e r } \big ( x _ { i } | f _ { d } ( \boldsymbol { z } ; \boldsymbol \theta ) , \sigma ^ { 2 } \mathbf I \big )
$$

Second, we create another model, $q ( \boldsymbol { z } | \boldsymbol { x } )$ , called the recognition network or inference network, that is trained simultaneously with the generative model to do approximate posterior inference. If we assume the posterior is Gaussian, with diagonal covariance, we get

$$
\begin{array} { r } { q _ { \phi } ( z | \pmb { x } ) = \mathcal { N } ( z | f _ { e , \mu } ( \pmb { x } ; \phi ) , \mathrm { d i a g } ( f _ { e , \sigma } ( \pmb { x } ; \phi ) ) ) } \end{array}
$$

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022 where $f _ { e }$ is the encoder. See Figure 20.22 for a sketch.

![](images/b34dd8ca818c7e2a20872a471ef8c9ecfe42a4a9ca4c61e3fac347f731929119.jpg)  
Figure 20.22: Schematic illustration of a VAE. From a figure from http: // krasserm. github. io/ 2018/ 07/ 27/ dfc-vae/ . Used with kind permission of Martin Krasser.

The idea of training an inference network to “invert” a generative network, rather than running an optimization algorithm to infer the latent code, is called amortized inference. This idea was first proposed in the Helmholtz machine [Day+95]. However, that paper did not present a single unified objective function for inference and generation, but instead used the wake sleep method for training, which alternates between optimizing the generative model and inference model. By contrast, the VAE optimizes a variational lower bound on the log-likelihood, which is more principled, since it is a single unified objective.

# 20.3.5.1 Training VAEs

We cannot compute the exact marginal likelihood $p ( { \pmb x } | { \pmb \theta } )$ needed for MLE training, because posterior inference in a nonlinear FA model is intractable. However, we can use the inference network to compute an approximate posterior, $q ( \boldsymbol { z } | \boldsymbol { x } )$ . We can then use this to compute the evidence lower bound or ELBO. For a single example $_ { x }$ , this is given by

$$
\begin{array} { r l } & { \mathrm { \mathbb { L } } ( \pmb { \theta } , \phi | \pmb { x } ) = \mathbb { E } _ { q _ { \phi } ( z | \pmb { x } ) } \left[ \log p _ { \pmb { \theta } } ( \pmb { x } , z ) - \log q _ { \phi } ( z | \pmb { x } ) \right] } \\ & { \quad \quad \quad = \mathbb { E } _ { q ( z | \pmb { x } , \phi ) } \left[ \log p ( \pmb { x } | z , \pmb { \theta } ) \right] - D _ { \mathbb { K L } } \left( q ( z | \pmb { x } , \phi ) \parallel p ( z ) \right) } \end{array}
$$

This can be interpreted as the expected log likelihood, plus a regularizer, that penalizes the posterior from deviating too much from the prior. (This is different than the approach in Section 20.3.4, where we applied the KL penalty to the aggregate posterior in each minibatch.)

The ELBO is a lower bound of the log marginal likelihood (aka evidence), as can be seen from Jensen’s inequality:

$$
\begin{array} { l } { \displaystyle \mathtt { L } ( \theta , \phi | x ) = \int q _ { \phi } ( z | x ) \log \frac { p _ { \theta } ( x , z ) } { q _ { \phi } ( z | x ) } d z } \\ { \displaystyle \le \log \int q _ { \phi } ( z | x ) \frac { p _ { \theta } ( x , z ) } { q _ { \phi } ( z | x ) } d z = \log p _ { \theta } ( x ) } \end{array}
$$

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

![](images/eceb96f69b419d5869a16489da0c58bbe3b33f1509f188a97107e05efd5c9d78.jpg)  
Figure 20.23: Computation graph for VAEs. where $p ( z ) = \mathcal { N } ( z | \mathbf { 0 } , \mathbf { I } )$ , $p ( \pmb { x } | z , \pmb { \theta } ) = \mathcal { N } ( \pmb { x } | f ( z ) , \sigma ^ { 2 } \mathbf { I } )$ , and $q ( z | \mathbf { x } , \phi ) = \mathcal { N } ( z | \mu ( \mathbf { x } ) , \Sigma ( \pmb { x } ) )$ . Red boxes show sampling operations which are not differentiable. Blue boxes show loss layers (we assume Gaussian likelihoods and priors). (a) Without the reparameterization trick. (b) With the reparameterization trick. Gradients can flow from the output loss, back through the decoder and into the encoder. From Figure 4 of [Doe16]. Used with kind permission of Carl Doersch.

Thus for fixed inference network parameters $\phi$ , increasing the ELBO should increase the log likelihood of the data, similar to EM Section 8.7.2.

# 20.3.5.2 The reparameterization trick

In this section, we discuss how to compute the ELBO and its gradient. For simplicity, let us suppose that the inference network estimates the parameters of a Gaussian posterior. Since $q _ { \phi } ( z | \pmb { x } )$ is Gaussian, we can write

$$
z = f _ { e , \mu } ( \pmb { x } ; \phi ) + f _ { e , \sigma } ( \pmb { x } ; \phi ) \odot \epsilon
$$

where $\mathbf { \epsilon } \gets \mathcal { N } ( \mathbf { 0 } , \mathbf { I } )$ . Hence

$$
\mathrm { L } ( \boldsymbol { \theta } , \boldsymbol { \phi } | \mathbf { x } ) = \mathbb { E } _ { \epsilon \sim \mathcal { N } ( \mathbf { 0 } , \mathbf { I } ) } \left[ \log p _ { \boldsymbol { \theta } } ( \mathbf { x } | \boldsymbol { z } = \mu _ { \phi } ( \mathbf { x } ) + \sigma _ { \phi } ( \mathbf { x } ) \odot \epsilon ) \right] - D _ { \mathbb { K L } } \left( q _ { \phi } ( \boldsymbol { z } | \mathbf { x } ) \parallel p _ { \phi } ( \mathbf { x } | \boldsymbol { z } ) \right) ,
$$

Now the expectation is independent of the parameters of the model, so we can safely push gradients inside and use backpropagation for training in the usual way, by minimizing $- \mathbb { E } _ { { \pmb x } \sim \mathcal { D } } \left[ \mathbb { E } ( { \pmb \theta } , { \pmb \phi } | { \pmb x } ) \right]$ wrt $\pmb \theta$ and $\phi$ . This is known as the reparameterization trick. See Figure 20.23 for an illustration.

The first term in the ELBO can be approximated by sampling $\epsilon$ , scaling it by the output of the inference network to get $_ { z }$ , and then evaluating $\log p ( { \pmb x } | z )$ using the decoder network.

The second term in the ELBO is the KL of two Gaussians, which has a closed form solution. In particular, inserting $p ( z ) = \mathcal { N } ( z | \mathbf { 0 } , \mathbf { I } )$ and $q ( z ) = \mathcal { N } ( z | \mu , \mathrm { d i a g } ( \pmb { \sigma } ) )$ into Equation (6.33), we get

$$
D _ { \mathbb { K L } } \left( q \parallel p \right) = \sum _ { k = 1 } ^ { K } \left[ \log ( \frac { 1 } { \sigma _ { k } } ) + \frac { \sigma _ { k } ^ { 2 } + ( \mu _ { k } - 0 ) ^ { 2 } } { 2 \cdot 1 } - \frac { 1 } { 2 } \right] = - \frac { 1 } { 2 } \sum _ { k = 1 } ^ { K } \left[ \log \sigma _ { k } ^ { 2 } - \sigma _ { k } ^ { 2 } - 1 \right] p \in \mathbb { K } ^ { 3 } .
$$

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

0 0   
20 5041q213 20 504/q213   
40 14353617 40 4353617   
60 60 0 50 100 150 200 250 0 50 100 150 200 0 0   
20 50419213 20 30488413   
40 60 19353617 40 60 （363457 0 50 100 150 200 250 0 50 100 150 200 250 (a) (b)

![](images/b7fc914baa4823eca3ed7db026670cc2372d4246b0d213ed79681a6ccd758c1b.jpg)  
Figure 20.24: Reconstructing MNIST digits using a 20 dimensional latent space. Top row: input images. Bottom row: reconstructions. (a) VAE. Generated by vae_mnist_conv_lightning.ipynb. (b) Deterministic AE. Generated by ae_mnist_conv.ipynb.   
Figure 20.25: Sampling MNIST digits using a 20 dimensional latent space. (a) VAE. Generated by vae_mnist_conv_lightning.ipynb. (b) Deterministic AE. Generated by ae_mnist_conv.ipynb.

# 20.3.5.3 Comparison of VAEs and autoencoders

VAEs are very similar to autoencoders. In particular, the generative model, $p _ { \pmb { \theta } } ( \pmb { x } | \pmb { z } )$ , acts like the decoder, and the inference network, $q _ { \phi } ( z | \pmb { x } )$ , acts like the encoder. The reconstruction abilities of both models are similar, as can be seen by comparing Figure 20.24a with Figure 20.24b.

The primary advantage of the VAE is that it can be used to generate new data from random noise. In particular, we sample $\mathscr { z }$ from the Gaussian prior $\mathcal { N } ( z | \mathbf { 0 } , \mathbf { I } )$ , and then pass this through the decoder to get $\mathbb { E } \left[ { \pmb { x } } | { \pmb z } \right] = f _ { d } ( { \pmb z } ; { \pmb \theta } )$ . The VAE’s decoder is trained to convert random points in the embedding space (generated by perturbing the input encodings) to sensible outputs. By contrast, the decoder for the deterministic autoencoder only ever gets as inputs the exact encodings of the training set, so it does not know what to do with random inputs that are outside what it was trained on. So a standard autoencoder cannot create new samples. This difference can be seen by comparing Figure 20.25a with Figure 20.25b.

The reason the VAE is better at sample is that it it embeds images into Gaussians in latent space, whereas the AE embeds images into points, which are like delta functions. The advantage of using a

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

![](images/51251027e8b7f38d7aa3afc88c747d889d4f23710e6c98c9737db4bf4ab07746.jpg)  
Figure 20.26: tSNE projection of a 20 dimensional latent space. (a) VAE. Generated by vae_mnist_conv_lightning.ipynb. (b) Deterministic AE. Generated by ae_mnist_conv.ipynb.   
Figure 20.27: Linear interpolation between the left and right images in a 20 dimensional latent space. (a) VAE. (b) Deterministic AE. Generated by vae_mnist_conv_lightning.ipynb.

20 22883355 20 43333333 0 50 100 150 200 250 0 50 100 150 200 250 (a) (b)

latent distribution is that it encourages local smoothness, since a given image may map to multiple nearby places, depending on the stochastic sampling. By contrast, in an AE, the latent space is typically not smooth, so images from different classes often end up next to each other. This difference can be seen by comparing Figure 20.26a with Figure 20.26b.

We can leverage the smoothness of the latent space to perform image interpolation. Rather than working in pixel space, we can work in the latent space of the model. Specifically, let $\pmb { x } _ { 1 }$ and $\mathbf { \delta x } _ { 2 }$ be two images, and let $z _ { 1 } = \mathbb { E } _ { q ( z | \mathbf { x } _ { 1 } ) } \left[ z \right]$ and $z _ { 2 } = \mathbb { E } _ { q ( z | \mathbf { x } _ { 2 } ) } \left[ z \right]$ be their encodings. We can now generate new images that interpolate between these two anchors by computing $z = \lambda z _ { 1 } + ( 1 - \lambda ) z _ { 2 }$ , where $0 \leq \lambda \leq 1$ , and then decoding by computing $\mathbb { E } \left[ \pmb { x } | \pmb { z } \right]$ . This is called latent space interpolation. (The justification for taking a linear interpolation is that the learned manifold has approximately zero curvature, as shown in [SKTF18].) A VAE is more useful for latent space interpolation than an AE because its latent space is smoother, and because the model can generate from almost any point in latent space. This difference can be seen by comparing Figure 20.27a with Figure 20.27b.

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

![](images/2135978961d0fb43230fda7b0a51e803ffe032db6e3bd9dd8b592eef107f6b92.jpg)  
Figure 20.28: Illustration of the tangent space and tangent vectors at two different points on a 2d curved manifold. From Figure 1 of [Bro+17a]. Used with kind permission of Michael Bronstein.

# 20.4 Manifold learning \*

In this section, we discuss the problem of recovering the underlying low-dimensional structure in a high-dimensional dataset. This structure is often assumed to be a curved manifold (explained in Section 20.4.1), so this problem is called manifold learning or nonlinear dimensionality reduction. The key difference from methods such as autoencoders (Section 20.3) is that we will focus on non-parametric methods, in which we compute an embedding for each point in the training set, as opposed to learning a generic model that can embed any input vector. That is, the methods we discuss do not (easily) support out-of-sample generalization. However, they can be easier to fit, and are quite flexible. Such methods can be a useful for unsupervised learning (knowledge discovery), data visualization, and as a preprocessing step for supervised learning. See [AAB21] for a recent review of this field.

# 20.4.1 What are manifolds?

Roughly speaking, a manifold is a topological space which is locally Euclidean. One of the simplest examples is the surface of the earth, which is a curved 2d surface embedded in a 3d space. At each local point on the surface, the earth seems flat.

More formally, a $d$ -dimensional manifold $\mathcal { X }$ is a space in which each point $x \in \mathcal { X }$ has a neighborhood which is topologically equivalent to a $d$ -dimensional Euclidean space, called the tangent space, denoted $\mathcal { T } _ { x } = T _ { x } \mathcal { X }$ . This is illustrated in Figure 20.28.

A Riemannian manifold is a differentiable manifold that associates an inner product operator at each point $x$ in tangent space; this is assumed to depend smoothly on the position $x$ . The inner product induces a notion of distance, angles, and volume. The collection of these inner products is called a Riemannian metric. It can be shown that any sufficiently smooth Riemannian manifold can be embedded into a Euclidean space of potentially higher dimension; the Riemannian inner product at a point then becomes Euclidean inner product in that tangent space.

# 20.4.2 The manifold hypothesis

Most “naturally occuring” high dimensional dataset lie a low dimensional manifold. This is called the manifold hypothesis [FMN16]. For example, consider the case of an image. Figure 20.29a shows a

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license single image of size $6 4 \times 5 7$ . This is a vector in a 3,648-dimensional space, where each dimension corresponds to a pixel intensity. Suppose we try to generate an image by drawing a random point in this space; it is unlikely to look like the image of a digit, as shown in Figure 20.29b. However, the pixels are not independent of each other, since they are generated by some lower dimensional structure, namely the shape of the digit 6.

![](images/eb799527ac7ec7050353b3c5e6e51e30c8319a15023c6df6e5a9fe6f70cbb7da.jpg)  
Figure 20.29: Illustration of the image manifold. (a) An image of the digit 6 from the USPS dataset, of size $6 4 \times 5 7 = 3 , 6 4 8$ . (b) A random sample from the space $\{ 0 , 1 \} ^ { 3 6 4 8 }$ reshaped as an image. (c) A dataset created by rotating the original image by one degree 360 times. We project this data onto its first two principal components, to reveal the underlying 2d circular manifold. From Figure 1 of [Law12]. Used with kind permission of Neil Lawrence.

As we vary the shape, we will generate different images. We can often characterize the space of shape variations using a low-dimensional manifold. This is illustrated in Figure 20.29c, where we apply PCA (Section 20.1) to project a dataset of 360 images, each one a slightly rotated version of the digit 6, into a 2d space. We see that most of the variation in the data is captured by an underlying curved 2d manifold. We say that the intrinsic dimensionality $d$ of the data is 2, even though the ambient dimensionality $D$ is 3,648.

# 20.4.3 Approaches to manifold learning

In the rest of this section, we discuss ways to learn manifolds from data. There are many different algorithms that have been proposed, which make different assumptions about the nature of the manifold, and which have different computational properties. We discuss a few of these methods in the following sections. For more details, see e.g., [Bur10].

The methods can be categorized as shown in Table 20.1. The term “nonparametric” refers to methods that learn a low dimensional embedding $z _ { i }$ for each datapoint ${ \bf { x } } _ { i }$ , but do not learn a mapping function which can be applied to an out-of-sample datapoint. (However, [Ben+04b] discusses how to extend many of these methods beyond the training set by learning a kernel.)

In the sections below, we compare some of these methods using 2 different datasets: a set of 1000 3d-points sampled from the 2d “Swiss roll” manifold, and a set of 1797 64-dimensional points sampled from the UCI digits dataset. See Figure 20.30 for an illustration of the data. We will learn a 2d manifold, so we can visualize the data.

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

<html><body><table><tr><td>Method</td><td>Parametric</td><td>Convex</td><td>Section</td></tr><tr><td>PCA/classicalMDS</td><td>N</td><td>Y (Dense)</td><td>Section 20.1</td></tr><tr><td>Kernel PCA</td><td>N</td><td>Y (Dense)</td><td>Section 20.4.6</td></tr><tr><td>Isomap</td><td>N</td><td>Y (Dense)</td><td>Section 20.4.5</td></tr><tr><td>LLE</td><td>N</td><td>Y (Sparse)</td><td>Section 20.4.8</td></tr><tr><td>Laplacian Eigenmaps</td><td>N</td><td>Y (Sparse)</td><td>Section 20.4.9</td></tr><tr><td>tSNE</td><td>N</td><td>N</td><td>Section 20.4.10</td></tr><tr><td>Autoencoder</td><td>Y</td><td>N</td><td>Section 20.3</td></tr></table></body></html>

Table 20.1: A list of some approaches to dimensionality reduction. If a method is convex, we specify in parentheses whether it requires solving a sparse or dense eigenvalue problem.

![](images/c5970237e24cc6da343114b2efb307be636869e9d07e148e0e3f4e461865ff36.jpg)  
Figure 20.30: Illustration of some data generated from low-dimensional manifolds. (a) The 2d Swiss-roll manifold embedded into 3d. Generated by manifold_swiss_sklearn.ipynb. (b) Sample of some UCI digits, which have size $8 \times 8 = 6 4$ . Generated by manifold_digits_sklearn.ipynb.

# 20.4.4 Multi-dimensional scaling (MDS)

The simplest approach to manifold learning is multidimensional scaling (MDS). This tries to find a set of low dimensional vectors $\{ z _ { i } \in \mathbb { R } ^ { L } : i = 1 : N \}$ such that the pairwise distances between these vectors is as similar as possible to a set of pairwise dissimilarities $\mathbf { D } = \{ d _ { i j } \}$ provided by the user. There are several variants of MDS, one of which turns out to be equivalent to PCA, as we discuss below.

# 20.4.4.1 Classical MDS

Suppose we start an $N \times D$ data matrix $\mathbf { X }$ with rows ${ \bf { x } } _ { i }$ . Let us define the centered Gram (similarity) matrix as follows:

$$
\tilde { K } _ { i j } = \langle { \pmb x } _ { i } - { \overline { { \pmb x } } } , { \pmb x } _ { j } - { \overline { { \pmb x } } } \rangle
$$

In matrix notation, we have $\tilde { \mathbf { K } } = \tilde { \mathbf { X } } \tilde { \mathbf { X } } ^ { \top }$ , where $\ddot { \mathbf { X } } = \mathbf { C } _ { N } \mathbf { X }$ and $\begin{array} { r } { { \bf { C } } _ { N } = { \bf { I } } _ { N } - \frac { 1 } { N } { \bf { 1 } } _ { N } { \bf { 1 } } _ { N } ^ { \sf t } } \end{array}$ is the centering matrix.

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

Now define the strain of a set of embeddings as follows:

$$
\mathcal { L } _ { \mathrm { s t r a i n } } ( \mathbf { Z } ) = \sum _ { i , j } ( \tilde { K } _ { i j } - \langle \tilde { z } _ { i } , \tilde { z } _ { j } \rangle ) ^ { 2 } = | | \tilde { \mathbf { K } } - \tilde { \mathbf { Z } } \tilde { \mathbf { Z } } ^ { \mathsf { T } } | | _ { F } ^ { 2 }
$$

where $\begin{array} { r } { \dot { z } _ { i } = z _ { i } - \overline { { z } } } \end{array}$ is the centered embedding vector. Intuitively this measures how well similarities in the high-dimensional data space, $\tilde { K } _ { i j }$ , are matched by similarities in the low-dimensional embedding space, $\langle \tilde { z } _ { i } , \tilde { z } _ { j } \rangle$ . Minimizing this loss is called classical MDS.

We know from Section 7.5 that the best rank $L$ approximation to a matrix is its truncated SVD representation, $\tilde { \mathbf { K } } = \mathbf { U S V } ^ { \mathsf { T } }$ . Since $\tilde { \bf K }$ is positive semi definite, we have that $\mathbf { V } = \mathbf { U }$ . Hence the optimal embedding satisfies

$$
\mathbf { \tilde { Z } } \mathbf { \tilde { Z } } ^ { \mathsf { T } } = \mathbf { U S U } ^ { \mathsf { T } } = ( \mathbf { U S } ^ { \frac { 1 } { 2 } } ) ( \mathbf { S } ^ { \frac { 1 } { 2 } } \mathbf { U } ^ { \mathsf { T } } )
$$

Thus we can set the embedding vectors to be the rows of $\tilde { \mathbf { Z } } = \mathbf { U } \mathbf { S } ^ { \frac { 1 } { 2 } }$ .

Now we describe how to apply classical MDS to a dataset where we just have Euclidean distances, rather than raw features. First we compute a matrix of squared Euclidean distances, $\mathbf { D } ^ { ( 2 ) } = \mathbf { D } \odot \mathbf { D }$ , which has the following entries:

$$
\begin{array} { c } { { D _ { i j } ^ { ( 2 ) } = | | { \pmb x } _ { i } - { \pmb x } _ { j } | | ^ { 2 } = | | { \pmb x } _ { i } - { \overline { { \pmb x } } } | | ^ { 2 } + | | { \pmb x } _ { j } - { \overline { { \pmb x } } } | | ^ { 2 } - 2 \langle { \pmb x } _ { i } - { \overline { { \pmb x } } } , { \pmb x } _ { j } - { \overline { { \pmb x } } } \rangle } } \\ { { = | | { \pmb x } _ { i } - { \overline { { \pmb x } } } | | ^ { 2 } + | | { \pmb x } _ { j } - { \overline { { \pmb x } } } | | ^ { 2 } - 2 \tilde { K } _ { i j } } } \end{array}
$$

We see that $\mathbf { D } ^ { ( 2 ) }$ only differs from $\ddot { \bf K }$ by some row and column constants (and a factor of -2). Hence we can compute $\ddot { \bf K }$ by double centering $\mathbf { D } ^ { ( 2 ) }$ using Equation (7.89) to get $\begin{array} { r } { \tilde { \mathbf { K } } = - \frac { 1 } { 2 } \mathbf { C } _ { N } \mathbf { D } ^ { ( 2 ) } \mathbf { C } _ { N } } \end{array}$ . In other words,

$$
\tilde { K } _ { i j } = - \frac { 1 } { 2 } \left( d _ { i j } ^ { 2 } - \frac { 1 } { N } \sum _ { l = 1 } ^ { N } d _ { i l } ^ { 2 } - \frac { 1 } { N } \sum _ { l = 1 } ^ { N } d _ { j l } ^ { 2 } + \frac { 1 } { N ^ { 2 } } \sum _ { l = 1 } ^ { N } \sum _ { m = 1 } ^ { N } d _ { l m } ^ { 2 } \right)
$$

We can then compute the embeddings as before.

It turns out that classical MDS is equivalent to PCA (Section 20.1). To see this, let $\tilde { \mathbf { K } } = \mathbf { U } _ { L } \mathbf { S } _ { L } \mathbf { U } _ { L } ^ { \top }$ be the rank $L$ truncated SVD of the centered kernel matrix. The MDS embedding is given by $\mathbf { Z } _ { \mathrm { M D S } } = \mathbf { U } _ { L } \mathbf { S } _ { L } ^ { \frac { 1 } { 2 } }$ . Now consider the rank $L$ SVD of the centered data matrix, $\ddot { \mathbf { X } } = \mathbf { U } _ { X } \mathbf { S } _ { X } \mathbf { V } _ { X } ^ { \top }$ . The PCA embedding is $\mathbf { Z } _ { \mathrm { P C A } } = \mathbf { U } _ { X } \mathbf { S } _ { X }$ . Now

$$
\tilde { \mathbf { K } } = \tilde { \mathbf { X } } \tilde { \mathbf { X } } ^ { \mathsf { T } } = \mathbf { U } _ { X } \mathbf { S } _ { X } \mathbf { V } _ { X } ^ { \mathsf { T } } \mathbf { V } _ { X } \mathbf { S } _ { X } \mathbf { U } _ { X } ^ { \mathsf { T } } = \mathbf { U } _ { X } \mathbf { S } _ { X } ^ { 2 } \mathbf { U } _ { X } ^ { \mathsf { T } } = \mathbf { U } _ { L } \mathbf { S } _ { L } \mathbf { U } _ { L } ^ { \mathsf { T } }
$$

Hence $\mathbf { U } _ { X } = \mathbf { U } _ { L }$ and $\mathbf { S } _ { X } = \mathbf { S } _ { L } ^ { 2 }$ , and so ${ \bf Z } _ { \mathrm { P C A } } = { \bf Z } _ { \mathrm { M D S } }$ .

# 20.4.4.2 Metric MDS

Classical MDS assumes Euclidean distances. We can generalize it to allow for any dissimilarity measure by defining the stress function

$$
\mathcal { L } _ { \mathrm { s t r e s s } } ( \mathbf { Z } ) = \sqrt { \frac { \sum _ { i < j } ( d _ { i , j } - \hat { d } _ { i j } ) ^ { 2 } } { \sum _ { i j } d _ { i j } ^ { 2 } } }
$$

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022 where $\hat { d } _ { i j } = | | z _ { i } - z _ { j } | |$ . This is called metric MDS. Note that this is a different objective than the one used by classical MDS, so even if $d _ { i j }$ are Euclidean distances, the results will be different.

![](images/bfea1fbdb770c3e78e3a57dc16d15f7f870dbaab6437b0193f89eecbb4976f9c.jpg)  
Figure 20.31: Metric MDS applied to (a) Swiss roll. Generated by manifold_swiss_sklearn.ipynb. (b) UCI digits. Generated by manifold_digits_sklearn.ipynb.

We can use gradient descent to solve the optimization problem. However, it is better to use a bound optimization algorithm (Section 8.7) called SMACOF [Lee77], which stands for “Scaling by MAjorizing a COmplication Function”. (This is the method implemented in scikit-learn.) See Figure 20.31 for the results of applying this to our running example.

# 20.4.4.3 Non-metric MDS

Instead of trying to match the distance between points, we can instead just try to match the ranking of how similar points are. To do this, let $f ( d )$ be a monotonic transformation from distances to ranks. Now define the loss

$$
\mathcal { L } _ { \mathrm { N M } } ( \mathbf { Z } ) = \sqrt { \frac { \sum _ { i < j } ( f ( d _ { i , j } ) - \hat { d } _ { i j } ) ^ { 2 } } { \sum _ { i j } \hat { d } _ { i j } ^ { 2 } } }
$$

where $\hat { d } _ { i j } = | | z _ { i } - z _ { j } | |$ . Minimizing this is known as non-metric MDS.

This objective can be optimized iteratively. First the function $f$ is optimized, for a given $\mathbf { Z }$ , using isotonic regression; this finds the optimal monotonic transformation of the input distances to match the current embedding distances. Then the embeddings $\mathbf { Z }$ are optimized, for a given $f$ , using gradient descent, and the process repeats.

# 20.4.4.4 Sammon mapping

Metric MDS tries to minimize the sum of squared distances, so it puts the most emphasis on large distances. However, for many embedding methods, small distances matter more, since they capture local structure. One way to capture this is to divide each term of the loss by $d _ { i j }$ , so small distances get upweighted:

$$
\mathcal { L } _ { \mathrm { s a m m o n } } ( \mathbf { Z } ) = \left( \frac { 1 } { \sum _ { i < j } d _ { i j } } \right) \sum _ { i \neq j } \frac { ( \hat { d } _ { i j } - d _ { i j } ) ^ { 2 } } { d _ { i j } }
$$

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

![](images/79d1b346c63ce019750c087cc7d26c6f67ed6a744b6a1200263ea823367376e9.jpg)  
Figure 20.32: (a) If we measure distances along the manifold, we find $d ( 1 , 6 ) > d ( 1 , 4 )$ , whereas if we measure in ambient space, we find $d ( 1 , 6 ) < d ( 1 , 4 )$ . The plot at the bottom shows the underlying 1d manifold. (b) The $K$ -nearest neighbors graph for some datapoints; the red path is the shortest distance between $A$ and $B$ on this graph. From [Hin13]. Used with kind permission of Geoff Hinton.

Minimizing this results in a Sammon mapping. (The coefficient in front of the sum is just to simplify the gradient of the loss.) Unfortunately this is a non-convex objective, and it arguably puts too much emphasis on getting very small distances exactly right. We will discuss better methods for capturing local structure later on.

# 20.4.5 Isomap

If the high-dimensional data lies on or near a curved manifold, such as the Swiss roll example, then MDS might consider two points to be close even if their distance along the manifold is large. This is illustrated in Figure 20.32a.

One way to capture this is to create the $K$ -nearest neighbor graph between datapoints5, and then approximate the manifold distance between a pair of points by the shortest distance along this graph; this can be computed efficiently using Dijkstra’s shortest path algorithm. See Figure 20.32b for an illustration. Once we have computed this new distance metric, we can apply classical MDS (i.e., PCA). This is a way to capture local structure while avoiding local optima. The overall method is called isomap [TSL00].

See Figure 20.33 for the results of this method on our running example. We see that they are quite reasonable. However, if the data is noisy, there can be “false” edges in the nearest neighbor graph, which can result in “short circuits” which significantly distort the embedding, as shown in Figure 20.34. This problem is known as “topological instability” [BS02]. Choosing a very small neighborhood does not solve this problem, since this can fragment the manifold into a large number of disconnected regions. Various other solutions have been proposed, e.g., [CC07].

# 20.4.6 Kernel PCA

PCA (and classical MDS) finds the best linear projection of the data, so as to preserve pairwise similarities between all the points. In this section, we consider nonlinear projections. The key idea is to solve PCA by finding the eigenvectors of the inner product (Gram) matrix $\mathbf { K } = \mathbf { X } \mathbf { X } ^ { \mathsf { I } }$ , as in Section 20.1.3.2, and then to use the kernel trick (Section 17.3.4), which lets us replace inner products such as ${ \pmb x } _ { i } ^ { 1 } { \pmb x } _ { j }$ with a kernel function, $K _ { i j } = \mathcal { K } ( \pmb { x } _ { i } , \pmb { x } _ { k } )$ . This is known as kernel PCA [SSM98].

![](images/2cbd1be80b0f28414d8bbdb6c7fda36c7bfbc87f6005f0fc276a0ed4bea439e5.jpg)  
Figure 20.33: Isomap applied to (a) Swiss roll. Generated by manifold_swiss_sklearn.ipynb. (b) UCI digits. Generated by manifold_digits_sklearn.ipynb.

![](images/ad704801893f8f65770710485f29a6a2ce4c1162186c28a083d7a38159665c3b.jpg)  
Figure 20.34: (a) Noisy version of Swiss roll data. We perturb each point by adding $\mathcal { N } ( 0 , 0 . 5 ^ { 2 } )$ noise. (b) Results of Isomap applied to this data. Generated by manifold_swiss_sklearn.ipynb.

Recall from Mercer’s theorem that the use of a kernel implies some underlying feature space, so we are implicitly replacing ${ \boldsymbol { x } } _ { i }$ with $\phi ( \pmb { x } _ { i } ) = \phi _ { i }$ . Let $\Phi$ be the corresponding (notional) design matrix, and $\mathbf { K } = \mathbf { X } \mathbf { X } ^ { \mathsf { T } }$ be the Gram matrix. Finally, let $\begin{array} { r } { { \bf S } _ { \phi } = \frac { 1 } { N } \sum _ { i } \phi _ { i } \phi _ { i } ^ { \top } } \end{array}$ be the covariance matrix in feature space. (We are assuming for now the features are centered.) From Equation (20.22), the normalized eigenvectors of $\mathbf { s }$ are given by $\mathbf { V } _ { \mathrm { k P C A } } = \Phi ^ { \mathsf { T } } \mathbf { U } \mathbf { A } ^ { - \frac { 1 } { 2 } }$ , where $\mathbf { U }$ and $\pmb { \Lambda }$ contain the eigenvectors and eigenvalues of $\mathbf { K }$ . Of course, we can’t actually compute $\mathbf { V } _ { \mathrm { k P C A } }$ , since $\phi _ { i }$ is potentially infinite dimensional. However, we can compute the projection of a test vector ${ \pmb x } _ { * }$ onto the feature space as follows:

$$
\phi _ { * } ^ { \mathsf { T } } \mathbf { V } _ { \mathrm { k P C A } } = \phi _ { * } ^ { \mathsf { T } } \Phi ^ { \mathsf { T } } \mathbf { U } \mathbf { A } ^ { - \frac { 1 } { 2 } } = k _ { * } ^ { \mathsf { T } } \mathbf { U } \mathbf { A } ^ { - \frac { 1 } { 2 } }
$$

where $\pmb { k } _ { * } = [ \mathcal { K } ( \pmb { x } _ { * } , \pmb { x } _ { 1 } ) , \dots , \mathcal { K } ( \pmb { x } _ { * } , \pmb { x } _ { N } ) ]$ .

There is one final detail to worry about. The covariance matrix is only given by $\mathbf { S } = \Phi ^ { \prime } \bar { \Phi }$ if the features is zero-mean. Thus we can only use the Gram matrix $\mathbf { K } = \Phi \mathbf { \Phi } \mathbf { \Phi } ^ { \mathsf { T } }$ if $\mathbb { E } \left[ \phi _ { i } \right] = \mathbf { 0 }$ . Unfortunately,

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license we cannot simply subtract off the mean in feature space, since it may be infinite dimensional. However, there is a trick we can use. Define the centered feature vector as $\begin{array} { r } { \tilde { \phi } _ { i } = \phi ( \pmb { x } _ { i } ) - \frac { 1 } { N } \sum _ { j = 1 } ^ { N } \phi ( \pmb { x } _ { j } ) } \end{array}$ . The Gram matrix of the centered feature vectors is given by $\tilde { K } _ { i j } = \tilde { \phi } _ { i } ^ { \top } \tilde { \phi } _ { j }$ . Using the double centering trick from Equation (7.89), we can write this in matrix form as $\tilde { \mathbf { K } } = \mathbf { C } _ { N } \mathbf { K } \mathbf { C } _ { N }$ , where $\begin{array} { r } { { \bf C } _ { N } \triangleq { \bf I } _ { N } - \frac { 1 } { N } { \bf 1 } _ { N } { \bf 1 } _ { N } ^ { \sf } } \end{array}$ is the centering matrix.

![](images/da69a020efe10145321797892b535a72f16f0a7bd2f7a5bee683ab52c4e8f986.jpg)  
Figure 20.35: Visualization of the first 8 kernel principal component basis functions derived from some 2d data. We use an RBF kernel with $\sigma ^ { 2 } = 0 . 1$ . Generated by kpcaScholkopf.ipynb.

If we apply kPCA with a linear kernel, we recover regular PCA (classical MDS). This is limited to using $L \leq D$ embedding dimensions. If we use a non-degenerate kernel, we can use up to $N$ components, since the size of $\Phi$ is $N \times D ^ { * }$ , where $D ^ { * }$ is the (potentially infinite) dimensionality of embedded feature vectors. Figure 20.35 gives an example of the method applied to some $D = 2$ dimensional data using an RBF kernel. We project points in the unit grid onto the first 8 components and visualize the corresponding surfaces using a contour plot. We see that the first two components separate the three clusters, and the following components split the clusters.

See Figure 20.36 for some the results on kPCA (with an RBF kernel) on our running example. In this case, the results are arguably not very useful. In fact, it can be shown that kPCA with an RBF kernel expands the feature space instead of reducing it [WSS04], as we saw in Figure 20.35, which makes it not very useful as a method for dimensionality reduction. We discuss a solution to this in Section 20.4.7.

# 20.4.7 Maximum variance unfolding (MVU)

kPCA with certain kernels, such as RBF, might not result in a low dimensional embedding, as discussed in Section 20.4.6. This observation led to the development of the semidefinite embedding

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

![](images/93a58735fb40b35f4868db737b5f8cb5de64b4dc3afb91d7e71fc65db203c264.jpg)  
Figure 20.36: Kernel PCA applied to (a) Swiss roll. Generated by manifold_swiss_sklearn.ipynb. (b) UCI digits. Generated by manifold_digits_sklearn.ipynb.

algorithm [WSS04], also called maximum variance unfolding, which tries to learn an embedding $\left\{ z _ { i } \right\}$ such that

$$
\operatorname* { m a x } \sum _ { i j } | | z _ { i } - z _ { j } | | _ { 2 } ^ { 2 } ~ \mathrm { s . t . } ~ | | z _ { i } - z _ { j } | | _ { 2 } ^ { 2 } = | | x _ { i } - x _ { j } | | _ { 2 } ^ { 2 } \mathrm { f o r ~ a l l ~ } ( i , j ) \in G
$$

where $G$ is the nearest neighbor graph (as in Isomap). This approach explicitly tries to ’unfold’ th data manifold while respecting the nearest neighbor constraints.

This can be reformulated as a semidefinite programming (SDP) problem by defining the kernel matrix $\mathbf { K } = \mathbf { Z } \mathbf { Z } ^ { \mathsf { T } }$ and then optimizing

$$
\operatorname* { m a x } { \mathrm { t r } ( \mathbf { K } ) } \mathrm { s . t . } | | z _ { i } - z _ { j } | | _ { 2 } ^ { 2 } = | | \pmb { x } _ { i } - \pmb { x } _ { j } | | _ { 2 } ^ { 2 } , \sum _ { i j } K _ { i j } = 0 , \mathbf { K } \succ 0
$$

The resulting kernel is then passed to kPCA, and the resulting eigenvectors give the low dimensional embedding.

# 20.4.8 Local linear embedding (LLE)

The techniques we have discussed so far all rely on an eigendecomposition of a full matrix of pairwise similarities, either in the ambient space (PCA), in feature space (kPCA), or along the KNN graph (Isomap). In this section, we discuss local linear embedding (LLE) [RS00], a technique that solves a sparse eigenproblem, thus focusing more on local structure in the data.

LLE assumes the data manifold around each point ${ \bf { \chi } } _ { i }$ is locally linear. The best linear approximation can be found by predicting ${ \bf { \chi } } _ { i }$ as a linear combination of its $K$ nearest neighbors using reconstruction weights ${ \pmb w } _ { i }$ . This can be found by solving

$$
\hat { \mathbf { W } } = \operatorname* { m i n } _ { \mathbf { W } } \sum _ { i = 1 } ^ { N } ( \pmb { x } _ { i } - \sum _ { j = 1 } ^ { N } w _ { i j } \pmb { x } _ { j } ) ^ { 2 }
$$

$$
{ \mathrm { s u b j e c t ~ t o } } { \left\{ \begin{array} { l l } { w _ { i j } = 0 } & { { \mathrm { i f ~ } } x _ { j } \not \in { \mathrm { n b r } } ( \mathbf { \mathbf { x } } _ { i } , K ) } \\ { \sum _ { j = 1 } ^ { N } w _ { i j } = 1 } & { { \mathrm { f o r ~ } } i = 1 : N } \end{array} \right. }
$$

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

![](images/9cb8efdb6b76ae903579c3680f09123439a1017f80d125b2367f185e3e53911b.jpg)  
Figure 20.37: LLE applied to (a) Swiss roll. Generated by manifold_swiss_sklearn.ipynb. (b) UCI digits. Generated by manifold_digits_sklearn.ipynb.

Note that we need the sum-to-one constraint on the weights to prevent the trivial solution $\mathbf { W } = \mathbf { 0 }$ The resulting vector of weights ${ \mathbf { } } { \mathbf { } } w _ { i } ,$ ,: constitute the barycentric coordinates of ${ \bf { x } } _ { i }$ .

Any linear mapping of this hyperplane to a lower dimensional space preserves the reconstruction weights, and thus the local geometry. Thus we can solve for the low-dimensional embeddings for each point by solving

$$
\hat { \mathrm { \bf ~ Z } } = \underset { \mathrm { \bf ~ Z } } { \mathrm { a r g m i n } } \sum _ { i } | | z _ { i } - \sum _ { j = 1 } ^ { N } \hat { w } _ { i j } z _ { j } | | _ { 2 } ^ { 2 }
$$

where $\hat { w } _ { i j } = 0$ if $j$ is not one of the $K$ nearest neighbors of $i$ . We can rewrite this loss as

$$
{ \mathcal { L } } ( \mathbf { Z } ) = \left| \left| \mathbf { Z } - \mathbf { W } \mathbf { Z } \right| \right| ^ { 2 } = \mathbf { Z } ^ { \mathsf { T } } ( \mathbf { I } - \mathbf { W } ) ^ { \mathsf { T } } ( \mathbf { I } - \mathbf { W } ) \mathbf { Z }
$$

Thus the solution is given by the eigenvectors of $\left( \mathbf { I } - \mathbf { W } \right) ^ { \parallel } \left( \mathbf { I } - \mathbf { W } \right)$ corresponding to the smallest nonzero eigenvalues, as shown in Section 7.4.8.

See Figure 20.37 for some the results on LLE on our running example. In this case, the results do not seem as good as those produced by Isomap. However, the method tends to be somewhat less sensitive to short-circuiting (noise).

# 20.4.9 Laplacian eigenmaps

In this section, we describe Laplacian eigenmaps or spectral embedding [BN01]. The idea is to compute a low-dimensional representation of the data in which the weighted distances between a datapoint and its $K$ nearest neighbors are minimized. We put more weight on the first nearest neighbor than the second, etc. We give the details below.

20.4.9.1 Using eigenvectors of the graph Laplacian to compute embeddings

We want to find embeddings which minimize

$$
\mathcal { L } ( \mathbf { Z } ) = \sum _ { ( i , j ) \in E } W _ { i , j } | | z _ { i } - z _ { j } | | _ { 2 } ^ { 2 }
$$

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

![](images/16704ab4d06321062447f3c904f531862b5744585805e6bb3a83f7a353857b8c.jpg)  
Figure 20.38: Laplacian eigenmaps applied to (a) Swiss roll. Generated by manifold_swiss_sklearn.ipynb. (b) UCI digits. Generated by manifold_digits_sklearn.ipynb.

where $\begin{array} { r } { W _ { i j } = \exp \bigl ( { - \frac { 1 } { 2 \sigma ^ { 2 } } | | \pmb { x } _ { i } - \pmb { x } _ { j } | | _ { 2 } ^ { 2 } } \bigr ) } \end{array}$ if $i - j$ are neighbors in the KNN graph and 0 otherwise. We add the constraint ${ \bf Z } ^ { 1 } { \bf D } { \bf Z } = { \bf I }$ to avoid the degenerate solution where $\mathbf { Z } = \mathbf { 0 }$ , where $\mathbf { D }$ is the diagonal weight matrix storing the degree of each node, $\begin{array} { r } { D _ { i i } = \sum _ { j } W _ { i , j } } \end{array}$ .

We can rewrite the above objective as follows:

$$
\begin{array} { l } { \displaystyle \mathcal { L } ( \mathbf { Z } ) = \sum _ { i j } W _ { i j } ( | | z _ { i } | | ^ { 2 } + | | z _ { j } | | ^ { 2 } - 2 z _ { i } ^ { \mathsf { T } } z _ { j } ) } \\ { = \sum _ { i } D _ { i i } | | z _ { i } | | ^ { 2 } + \sum _ { j } D _ { j j } | | z _ { j } | | ^ { 2 } - 2 \sum _ { i j } W _ { i j } z _ { i } z _ { j } ^ { \mathsf { T } } } \\ { = 2 \mathrm { t r } ( \mathbf { Z } ^ { \mathsf { T } } \mathbf { D } \mathbf { Z } ) - 2 \mathrm { t r } ( \mathbf { Z } ^ { \mathsf { T } } \mathbf { W } \mathbf { Z } ) = 2 \mathrm { t r } ( \mathbf { Z } ^ { \mathsf { T } } \mathbf { L } \mathbf { Z } ) } \end{array}
$$

where $\mathbf { L } = \mathbf { D } - \mathbf { W }$ is the graph Laplacian (see Section 20.4.9.2). One can show that minimizing this is equivalent to solving the (generalized) eigenvalue problem $\mathbf { L } z _ { i } = \lambda _ { i } \mathbf { D } z _ { i }$ for the $L$ smallest nonzero eigenvalues.

See Figure 20.38 for the results of applying this method (with an RBF kernel) to our running example.

# 20.4.9.2 What is the graph Laplacian?

We saw above that we can compute the eigenvectors of the graph Laplacian in order to learn a good embedding of the high dimensional points. In this section, we give some intuition as to why this works.

Let W be a symmetric weight matrix for a graph, where $W _ { i j } = W _ { j i } \ge 0$ . Let $\mathbf { D } = \mathrm { d i a g } ( d _ { i } )$ be a diagonal matrix containing the weighted degree of each node, $\begin{array} { r } { d _ { i } = \sum _ { j } w _ { i j } } \end{array}$ . We define the graph Laplacian as follows:

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

<html><body><table><tr><td>Labelled graph</td><td colspan="5">Degree matrix</td><td colspan="5">Adjacency matrix</td><td colspan="5">Laplacian matrix</td></tr><tr><td></td><td>2 0</td><td>0</td><td>0 0</td><td>0</td><td>0 1</td><td>0 0</td><td>1</td><td>0</td><td></td><td>2</td><td>-1</td><td>0</td><td>0 -1</td><td></td><td>0）</td></tr><tr><td></td><td>0</td><td>3 0</td><td>0</td><td>0 0</td><td>1 0</td><td>1</td><td>0 1</td><td>0</td><td></td><td>-1</td><td>3</td><td>-1</td><td>0</td><td>-1</td><td>0</td></tr><tr><td></td><td></td><td>0</td><td>2 0 0</td><td>0</td><td>1</td><td>0 1</td><td>0</td><td>0</td><td></td><td>0</td><td>-1</td><td>2</td><td>-1</td><td>0</td><td>0</td></tr><tr><td></td><td>0</td><td></td><td></td><td>0</td><td></td><td></td><td></td><td></td><td></td><td>0</td><td>0</td><td></td><td></td><td></td><td>-1</td></tr><tr><td></td><td>0 0</td><td></td><td>0 3</td><td></td><td>0</td><td>1 0</td><td>1</td><td>1</td><td></td><td></td><td></td><td>-1</td><td>3</td><td>-1</td><td></td></tr><tr><td></td><td>0 0</td><td></td><td>0 0 0</td><td>0 1</td><td>1</td><td>0 1</td><td>0</td><td>0 0</td><td></td><td>-1 0</td><td>-1</td><td>0</td><td>-1</td><td>3</td><td>0 1)</td></tr></table></body></html>

Figure 20.39: Illustration of the Laplacian matrix derived from an undirected graph. From https: // en.   
wikipedia. org/ wiki/ Laplacian_ matrix . Used with kind permission of Wikipedia author AzaToth.

![](images/443f48053cff6c178183cdfec3048d768a4b023dd88ec0b07eaf01ffa347fcd8.jpg)  
Figure 20.40: Illustration of a (positive) function defined on a graph. From Figure 1 of [Shu+13]. Used with kind permission of Pascal Frossard.

Thus the elements of $\mathbf { L }$ are given by

$$
L _ { i j } = \left\{ { \begin{array} { l l } { d _ { i } } & { { \mathrm { i f ~ } } i = j } \\ { - w _ { i j } } & { { \mathrm { i f ~ } } i \not = j { \mathrm { ~ a n d ~ } } w _ { i j } \not = 0 } \\ { 0 } & { { \mathrm { o t h e r w i s e } } } \end{array} } \right.
$$

See Figure 20.39 for an example of how to compute this.

Suppose we associate a value $f _ { i } \in \mathbb { R }$ with each node $i$ in the graph (see Figure 20.40 for example). Then we can use the graph Laplacian as a difference operator, to compute a discrete derivative of the function at a point:

$$
\mathbf { \Phi } ( \mathbf { L } f ) ( i ) = \sum _ { j \in \mathrm { n b r } _ { i } } W _ { i j } [ f ( i ) - f ( j ) ]
$$

where $\mathrm { n b r } _ { i }$ is the set of neighbors of node $i$ . We can also compute an overall measure of “smoothness”

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

of the function $f$ by computing its Dirichlet energy as follows:

$$
\begin{array} { l } { { \displaystyle f ^ { T } { \bf L } f = f ^ { T } { \bf D } f - f ^ { T } { \bf W } f = \sum _ { i } d _ { i } f _ { i } ^ { 2 } - \sum _ { i , j } f _ { i } f _ { j } w _ { i j } } } \\ { { \displaystyle ~ = \frac { 1 } { 2 } \left( \sum _ { i } d _ { i } f _ { i } ^ { 2 } - 2 \sum _ { i , j } f _ { i } f _ { j } w _ { i j } + \sum _ { j } d _ { j } f _ { j } ^ { 2 } \right) = \frac { 1 } { 2 } \sum _ { i , j } w _ { i j } ( f _ { i } - f _ { j } ) ^ { 2 } } } \end{array}
$$

By studying the eigenvalues and eigenvectors of the Laplacian matrix, we can determine various useful properties of the function. (Applying linear algebra to study the adjacency matrix of a graph, or related matrices, is called spectral graph theory [Chu97].) For example, we see that $\mathbf { L }$ is symmetric and positive semi-definite, since we have $f ^ { T } \mathbf { L } f \geq 0$ for all $\pmb { f } \in \mathbb { R } ^ { N }$ , which follows from Equation (20.128) due to the assumption that $w _ { i j } \geq 0$ . Consequently $\mathbf { L }$ has $N$ non-negative, real-valued eigenvalues, $0 \le \lambda _ { 1 } \le \lambda _ { 2 } \le . . . \le \lambda _ { N }$ . The corresponding eigenvectors form an orthogonal basis for the function $f$ defined on the graph, in order of decreasing smoothness.

In Section 20.4.9.1, we discuss Laplacian eigenmaps, which is a way to learn low dimensional embeddings for high dimensional data vectors. The approach is to let $z _ { i d } = f _ { i } ^ { d }$ be the $d { \mathrm { ~ } }$ ’th embedding dimension for input $i$ , and then to find a basis for these functions (i.e., embedding of the points) that varies smoothly over the graph, thus respecting distance of the points in ambient space.

There are many other applications of the graph Laplacian in ML. For example, in Section 21.5.1, we discuss normalized cuts, which is a way to learn a clustering of high dimensional data vectors based on pairwise similarity; and [WTN19] discusses how to use the eigenvectors of the state transition matrix to learn representations for RL.

# 20.4.10 t-SNE

In this section, we describe a very popular nonconvex technique for learning low dimensional embeddings called t-SNE [MH08]. This extends the earlier stochastic neighbor embedding method of [HR03], so we first describe SNE, before describing the t-SNE extension.

# 20.4.10.1 Stochastic neighborhood embedding (SNE)

The basic idea in SNE is to convert high-dimensional Euclidean distances into conditional probabilities that represent similarities. More precisely, we define $p _ { j | i }$ to be the probability that point $i$ would pick point $j$ as its neighbor if neighbors were picked in proportion to their probability under a Gaussian centered at ${ \bf { \chi } } _ { i }$ :

$$
p _ { j | i } = \frac { \exp ( - \frac { 1 } { 2 \sigma _ { i } ^ { 2 } } | | \pmb { x } _ { i } - \pmb { x } _ { j } | | ^ { 2 } ) } { \sum _ { k \neq i } \exp ( - \frac { 1 } { 2 \sigma _ { i } ^ { 2 } } | | \pmb { x } _ { i } - \pmb { x } _ { k } | | ^ { 2 } ) }
$$

Here $\sigma _ { i } ^ { 2 }$ is the variance for data point $i$ , which can be used to “magnify” the scale of points in dense regions of input space, and diminish the scale in sparser regions. (We discuss how to estimate the length scales $\sigma _ { i } ^ { 2 }$ shortly).

Let $z _ { i }$ be the low dimensional embedding representing ${ \boldsymbol { x } } _ { i }$ . We define similarities in the low

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

dimensional space in an analogous way:

$$
q _ { j | i } = \frac { \exp ( - | | z _ { i } - z _ { j } | | ^ { 2 } ) } { \sum _ { k \neq i } \exp ( - | | z _ { i } - z _ { k } | | ^ { 2 } ) }
$$

In this case, the variance is fixed to a constant; changing it would just rescale the learned map, and not change its topology.

If the embedding is a good one, then $q _ { j | i }$ should match $p _ { j | i }$ . Therefore, SNE defines the objective to be

$$
\mathcal { L } = \sum _ { i } D _ { \mathbb { K L } } \left( P _ { i } \parallel Q _ { i } \right) = \sum _ { i } \sum _ { j } p _ { j | i } \log \frac { p _ { j | i } } { q _ { j | i } }
$$

where $P _ { i }$ is the conditional distribution over all other data points given ${ \boldsymbol { x } } _ { i }$ , $Q _ { i }$ is the conditional distribution over all other latent points given $z _ { i }$ , and $D _ { \mathbb { K L } } \left( P _ { i } \parallel Q _ { i } \right)$ is the KL divergence (Section 6.2) between the distributions.

Note that this is an asymmetric objective. In particular, there is a large cost if a small $q _ { j | i }$ is used to model a large $p _ { j | i }$ . This objective will prefer to pull distant points together rather than push nearby points apart. We can get a better idea of the geometry by looking at the gradient for each embedding vector, which is given by

$$
{ \bf \nabla } _ { z _ { i } } \dot { \mathcal { L } } ( { \bf Z } ) = 2 \sum _ { j } ( z _ { j } - z _ { i } ) ( p _ { j \vert i } - q _ { j \vert i } + p _ { i \vert j } - q _ { i \vert j } )
$$

Thus points are pulled towards each other if the $p$ ’s are bigger than the $q$ ’s, and repelled if the $q$ ’s are bigger than the $p$ ’s.

Although this is an intuitively sensible objective, it is not convex. Nevertheless it can be minimized using SGD. In practice, it helps to add Gaussian noise to the embedding points, and to gradually anneal the amount of noise. [Hin13] recommends to “spend a long time at the noise level at which the global structure starts to form from the hot plasma of map points” before reducing it.6

# 20.4.10.2 Symmetric SNE

There is a slightly simpler version of SNE that minimizes a single KL between the joint distribution $P$ in high dimensional space and $Q$ in low dimensional space:

$$
\mathcal { L } = D _ { \mathbb { K L } } \left( P \parallel Q \right) = \sum _ { i < j } p _ { i j } \log \frac { p _ { i j } } { q _ { i j } }
$$

This is called symmetric SNE.

The obvious way to define $p _ { i j }$ is to use

$$
p _ { i j } = \frac { \exp ( - \frac { 1 } { 2 \sigma ^ { 2 } } | | \pmb { x } _ { i } - \pmb { x } _ { j } | | ^ { 2 } ) } { \sum _ { k < l } \exp ( - \frac { 1 } { 2 \sigma ^ { 2 } } | | \pmb { x } _ { k } - \pmb { x } _ { l } | | ^ { 2 } ) }
$$

We can define $q _ { i j }$ similarily.

The corresponding gradient becomes

$$
\nabla _ { z _ { i } } \mathcal { L } ( \mathbf { Z } ) = 2 \sum _ { j } ( z _ { j } - z _ { i } ) ( p _ { i j } - q _ { i j } )
$$

As before, points are pulled towards each other if the $p$ ’s are bigger than the $q$ ’s, and repelled if the $q$ ’s are bigger than the $p$ ’s.

Although symmetric SNE is slightly easier to implement, it loses the nice property of regular SNE that the data is its own optimal embedding if the embedding dimension $L$ is set equal to the ambient dimension $D$ . Nevertheless, the methods seems to give similar results in practice on real datasets where $L \ll D$ .

# 20.4.10.3 t-distributed SNE

A fundamental problem with SNE and many other embedding techniques is that they tend to squeeze points that are relatively far away in the high dimensional space close together in the low dimensional (usually 2d) embedding space; this is called the crowding problem, and arises due to the use of squared errors (or Gaussian probabilities).

One solution to this is to use a probability distribution in latent space that has heavier tails, which eliminates the unwanted attractive forces between points that are relatively far in the high dimensional space. An obvious choice is the Student-t distribution (Section 2.7.1). In t-SNE, they set the degree of freedom parameter to $\nu = 1$ , so the distribution becomes equivalent to a Cauchy:

$$
q _ { i j } = \frac { ( 1 + | | z _ { i } - z _ { j } | | ^ { 2 } ) ^ { - 1 } } { \sum _ { k < l } ( 1 + | | z _ { k } - z _ { l } | | ^ { 2 } ) ^ { - 1 } }
$$

We can use the same global KL objective as in Equation (20.133). For t-SNE, the gradient turns out to be

$$
\nabla z _ { i } \mathcal { L } = 4 \sum _ { j } ( p _ { i j } - q _ { i j } ) ( z _ { i } - z _ { j } ) ( 1 + | | z _ { i } - z _ { j } | | ^ { 2 } ) ^ { - 1 }
$$

The gradient for symmetric (Gaussian) SNE is the same, but lacks the $( 1 + | | z _ { i } - z _ { j } | | ^ { 2 } ) ^ { - 1 }$ term. This term is useful because $( 1 + | | z _ { i } - z _ { j } | | ^ { 2 } ) ^ { - 1 }$ acts like an inverse square law. This means that points in embedding space act like stars and galaxies, forming many well-separated clusters (galaxies) each of which has many stars tightly packed inside. This can be useful for separating different classes of data in an unsupervised way (see Figure 20.41 for an example).

# 20.4.10.4 Choosing the length scale

An important parameter in t-SNE is the local bandwidth $\sigma _ { i } ^ { 2 }$ . This is usually chosen so that $P _ { i }$ has a perplexity chosen by the user.7 This can be interpreted as a smooth measure of the effective number of neighbors.

![](images/aa6bc077db5f921b030691570e728ec286612c3c8fdbf221ef371f28461fdf12.jpg)  
Figure 20.41: tSNE applied to (a) Swiss roll. Generated by manifold_swiss_sklearn.ipynb. (b) UCI digits. Generated by manifold_digits_sklearn.ipynb.

![](images/8794e3b71bb280278aa65aa54e21929a0c6a87b4a57136150c7867ec97f6bbae.jpg)  
Figure 20.42: Illustration of the effect of changing the perplexity parameter when t-SNE is applied to some 2d data. From [WVJ16]. See http: // distill. pub/ 2016/ misread-tsne for an animated version of these figures. Used with kind permission of Martin Wattenberg.

Unfortunately, the results of t-SNE can be quite sensitive to the perplexity parameter, so it is wise to run the algorithm with many different values. This is illustrated in Figure 20.42. The input data is 2d, so there is no distortion generating by mapping to a 2d latent space. If the perplexity is too small, the method tends to find structure within each cluster which is not truly present. At perplexity 30 (the default for scikit-learn), the clusters seem equi-distant in embedding space, even though some are closer than others in the data space. Many other caveats in interpreting t-SNE plots can be found in [WVJ16].

# 20.4.10.5 Computational issues

The naive implementation of t-SNE takes $O ( N ^ { 2 } )$ time, as can be seen from the gradient term in Equation (20.137). A faster version can be created by leveraging an analogy to N-body simulation in physics. In particular, the gradient requires computing the force of $N$ points on each of $N$ points. However, points that are far away can be grouped into clusters (computationally speaking), and their effective force can be approximated by a few representative points per cluster. We can then approximate the forces using the Barnes-Hut algorithm [BH86], which takes $O ( N \log N )$ time, as proposed in [Maa14]. Unfortunately, this only works well for low dimensional embeddings, such as $L = 2$ .

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

# 20.4.10.6 UMAP

Various extensions of tSNE have been proposed, that try to improve its speed, the quality of the embedding space, or the ability to embed into more than 2 dimensions.

One popular recent extension is called UMAP (which stands for “Uniform Manifold Approximation and Projection”), was proposed in [MHM18]. At a high level, this is similar to tSNE, but it tends to preserve global structure better, and it is much faster. This makes it easier to try multiple values of the hyperparameters. For an interactive tutorial on UMAP, and a comparison to tSNE, see [CP19].

# 20.5 Word embeddings

Words are categorical random variables, so their corresponding one-hot vector representations are sparse. The problem with this binary representation is that semantically similar words may have very different vector representations. For example, the pair of related words “man” and “woman” will be Hamming distance 1 apart, as will the pair of unrelated words “man” and “banana”.

The standard way to solve this problem is to use word embeddings, in which we map each sparse one-hot vector, $\pmb { s } _ { n , t } \in \{ 0 , 1 \} ^ { M }$ , representing the $t$ ’th word in document $n$ , to a lower-dimensional dense vector, $z _ { n , t } \in \mathbb { R } ^ { D }$ , such that semantically similar words are placed close by. This can significantly help with data sparsity. There are many ways to learn such embeddings, as we discuss below.

Before discussing methods, we have to define what we mean by “semantically similar” words. We will assume that two words are semantically similar if they occur in similar contexts. This is known as the distributional hypothesis [Har54], which is often summarized by the phase (originally from [Fir57]) “a word is characterized by the company it keeps”. Thus the methods we discuss will all learn a mapping from a word’s context to an embedding vector for that word.

# 20.5.1 Latent semantic analysis / indexing

In this section, we discuss a simple way to learn word embeddings based on singular value decomposition (Section 7.5) of a term-frequency count matrix.

# 20.5.1.1 Latent semantic indexing (LSI)

Let $C _ { i j }$ be the number of times “term” $i$ occurs in “context” $j$ . The definition of what we mean by “term” is application-specific. In English, we often take it to be the set of unique tokens that are separated by punctuation or whitespace; for simplicity, we will call these “words”. However, we may preprocess the text data to remove very frequent or infrequent words, or perform other kinds of preprocessing. as we discuss in Section 1.5.4.1.

The definition of what we mean by “context” is also application-specific. In this section, we count how many times word $i$ occurs in each document $j \in \{ 1 , \ldots , N \}$ from a set or corpus of documents; the resulting matrx $\mathbf { C }$ is called a term-document frequency matrix, as in Figure 1.15. (Sometimes we apply the TF-IDF transformation to the counts, as discussed in Section 1.5.4.2.)

Let $\mathbf { C } \in \mathbb { R } ^ { M \times N }$ be the count matrix, and let $\hat { \mathbf { C } }$ be the rank $K$ approximation that minimizes the following loss:

$$
\mathcal { L } ( \hat { \mathbf { C } } ) = | | \mathbf { C } - \hat { \mathbf { C } } | | _ { F } = \sum _ { i j } ( C _ { i j } - \hat { C } _ { i j } ) ^ { 2 }
$$

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

![](images/d06933893dea0ecbcdf2d73efd669790ac1a0a26999a3f87cc223e836c077287.jpg)  
Figure 20.43: Illustration of the cosine similarity between a query vector $\mathbf { \pmb q }$ and two document vectors $\pmb { d } _ { 1 }$ and $\mathbf { { d } } _ { 2 }$ . Since angle α is less than angle $\theta$ , we see that the query is more similar to document 1. From https: // en. wikipedia. org/ wiki/ Vector_ space_ model . Used with kind permission of Wikipedia author Riclas.

One can show that the minimizer of this is given by the rank $K$ truncated SVD approximation, $\hat { \mathbf { C } } = \mathbf { U } \mathbf { S } \mathbf { V }$ . This means we can represent each $c _ { i j }$ as a bilinear product:

$$
c _ { i j } \approx \sum _ { k = 1 } ^ { K } u _ { i k } s _ { k } v _ { j k }
$$

We define $\mathbf { \delta } \mathbf { u } _ { i }$ to be the embedding for word $i$ , and $\mathbf { \boldsymbol { s } } \odot \mathbf { \boldsymbol { v } } _ { j }$ to be the embedding for context $j$ .

We can use these embeddings for document retrieval. The idea is to compute an embedding for the query words using $\mathbf { \Delta } \mathbf { u } _ { i }$ , and to compare this to the embedding of all the documents or contexts ${ \pmb v } _ { j }$ . This is known as latent semantic indexing or LSI [Dee+90].

$\begin{array} { r } { \pmb q = \frac { 1 } { B } \sum _ { b = 1 } ^ { B } \pmb u _ { w _ { b } } } \end{array}$ In more detail, suppose the query is a bag of words , where $\mathbf { \Delta } \mathbf { u } _ { w _ { b } }$ is tchoesienmebseidmdilnagrfiotry wor $w _ { 1 } , \ldots , w _ { B }$ $w _ { b }$ ; we represent this by the vector ocument $j$ be represented by $\boldsymbol { v } _ { j }$ by

$$
\mathrm { s i m } ( \pmb { q } , \pmb { d } ) = \frac { \pmb { q } ^ { \top } \pmb { d } } { | | \pmb { q } | | \ | | \pmb { d } | | }
$$

where $| | { \pmb q } | | = \sqrt { \sum _ { i } q _ { i } ^ { 2 } }$ is the $\ell _ { 2 }$ -norm of $\mathbf { \pmb { q } }$ . This measures the angles between the two vectors, as shown in Figure 20.43. Note that if the vectors are unit norm, cosine similarity is the same as inner product; it is also equal to the squared Euclidean distance, up to a change of sign and an irrelevant additive constant:

$$
| | q - d | | ^ { 2 } = ( q - d ) ^ { \top } ( q - d ) = q ^ { \top } q + d ^ { \top } d - 2 q ^ { \top } d = 2 ( 1 - \sin ( q , d ) )
$$

# 20.5.1.2 Latent semantic analysis (LSA)

Now suppose we define context more generally to be some local neighborhood of words $j \in \{ 1 , \dots , M ^ { h } \}$ , where $h$ is the window size. Thus $C _ { i j }$ is how many times word $i$ occurs in a neighborhood of type $j$ . We can compute the SVD of this matrix as before, to get $\begin{array} { r } { c _ { i j } \approx \sum _ { k = 1 } ^ { K } u _ { i k } s _ { k } v _ { j k } } \end{array}$ . We define ${ \pmb u } _ { i }$ to be

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022 the embedding for word $i$ , and $\mathbf { \boldsymbol { s } } \odot \mathbf { \boldsymbol { v } } _ { j }$ to be the embedding for context $j$ . This is known as latent semantic analysis or LSA [Dee+90].

For example, suppose we compute $\mathbf { C }$ on the British National Corpus.8 For each word, let us retrieve the $K$ nearest neighbors in embedding space ranked by cosine similarity (i.e., normalized inner product). If the query word is “dog”, and we use $h = 2$ or $h = 3 0$ , the nearest neighbors are as follows:

h=2: cat, horse, fox, pet, rabbit, pig, animal, mongrel, sheep, pigeon h=30: kennel, puppy, pet, bitch, terrier, rottweiler, canine, cat, to bark

The 2-word context window is more sensitive to syntax, while the 30-word window is more sensitive to semantics. The “optimal” value of context size $h$ depends on the application.

# 20.5.1.3 PMI

In practice LSA (and other similar methods) give much better results if we replace the raw counts $C _ { i j }$ with pointwise mutual information (PMI) [CH90], defined as

$$
\mathbb { P M I } ( i , j ) = \log \frac { p ( i , j ) } { p ( i ) p ( j ) }
$$

If word $i$ is strongly associated with context $j$ , we will have $\mathbb { P } \mathbb { M } \mathbb { I } ( i , j ) > 0$ . If the PMI is negative, it means $i$ and $j$ co-occur less often that if they were independent; however, such negative correlations can be unreliable, so it is common to use the positive PMI: $\mathbb { P } \mathbb { P } \mathbb { M } [ ( i , j ) = \operatorname* { m a x } ( \mathbb { P } \mathbb { M } \mathbb { I } ( i , j ) , 0 )$ . In [BL07b], they show that SVD applied to the PPMI matrix results in word embeddings that perform well on a many tasks related to word meaning. See Section 20.5.5 for a theoretical model that explains this empirical performance.

# 20.5.2 Word2vec

In this section, we discuss the popular word2vec model from [Mik+13a; Mik+13b], which are “shallow” neural nets for predicting a word given its context. In Section 20.5.5, we will discuss the connections with SVD of the PMI matrix.

There are two versions of the word2vec model. The first is called CBOW, which stands for “continuous bag of words”. The second is called skipgram. We discuss both of these below.

# 20.5.2.1 Word2vec CBOW model

In the continuous bag of words (CBOW) model (see Figure 20.44(a)), the log likelihood of a sequence of words is computed using the following model:

$$
\begin{array} { l } { \log p ( \pmb { w } ) = \displaystyle \sum _ { t = 1 } ^ { T } \log p \big ( \ b { w } _ { t } | \pmb { w } _ { t - m : t + m } \big ) = \displaystyle \sum _ { t = 1 } ^ { T } \log \frac { \exp \big ( \pmb { v } _ { { w } _ { t } } ^ { \top } \overline { { \pmb { v } } } _ { t } \big ) } { \sum _ { w ^ { \prime } } \exp \big ( \pmb { v } _ { { w ^ { \prime } } } ^ { \top } \overline { { \pmb { v } } } _ { t } \big ) } } \\ { = \displaystyle \sum _ { t = 1 } ^ { T } \pmb { v } _ { w _ { t } } ^ { \top } \overline { { \pmb { v } } } _ { t } - \log \displaystyle \sum _ { i \in \mathcal { V } } \exp \big ( \pmb { v } _ { i } ^ { \top } \overline { { \pmb { v } } } _ { t } \big ) } \end{array}
$$

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

![](images/d8633dd418cd00ae78b9547f7aef04b9c8fc57c443e684fb9915577492681979.jpg)  
Figure 20.44: Illustration of word2vec model with window size of 2. (a) CBOW version. (b) Skip-gram version.

where ${ \pmb v } _ { w _ { t } }$ is the vector for the word at location $w _ { t }$ , $\nu$ is the set of all words, $m$ is the context size, and

$$
\overline { { \pmb { v } } } _ { t } = \frac { 1 } { 2 m } \sum _ { h = 1 } ^ { m } ( \pmb { v } _ { w _ { t + h } } + \pmb { v } _ { w _ { t - h } } )
$$

is the average of the word vectors in the window around word $w _ { t }$ . Thus we try to predict each word given its context. The model is called CBOW because it uses a bag of words assumption for the context, and represents each word by a continuous embedding.

# 20.5.2.2 Word2vec Skip-gram model

In CBOW, each word is predicted from its context. A variant of this is to predict the context (surrounding words) given each word. This yields the following objective:

$$
\begin{array} { l } { \displaystyle - \log p ( \pmb { w } ) = - \sum _ { t = 1 } ^ { T } \left[ \sum _ { j = 1 } ^ { m } \log p ( w _ { t - j } | w _ { t } ) + \log p ( w _ { t + j } | w _ { t } ) \right] } \\ { \displaystyle = - \sum _ { t = 1 } ^ { T } \sum _ { - m \leq j \leq m , j \not = 0 } ^ { \displaystyle \sum } \log p ( w _ { t + j } | w _ { t } ) } \end{array}
$$

where $m$ is the context window length. We define the log probability of some other context word $w _ { o }$ given the central word $w _ { c }$ to be

$$
\log p ( w _ { o } | w _ { c } ) = \boldsymbol { \mathbf { \mathit { u } } } _ { o } ^ { \top } \boldsymbol { \mathbf { \mathit { v } } } _ { c } - \log \left( \sum _ { i \in \mathcal { V } } \exp ( \boldsymbol { \mathbf { \mathit { u } } } _ { i } ^ { \top } \boldsymbol { \mathbf { \mathit { v } } } _ { c } ) \right)
$$

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

where $\nu$ is the vocabulary. Here $\mathbf { \delta } \mathbf { u } _ { i }$ is the embedding of a word if used as context, and ${ \pmb v } _ { i }$ is the embedding of a word if used as a central (target) word to be predicted. This model is known as the skipgram model. See Figure 20.44(b) for an illustration.

# 20.5.2.3 Negative sampling

Computing the conditional probability of each word using Equation (20.148) is expensive, due to the need to normalize over all possible words in the vocabulary. This makes it slow to compute the log likelihood and its gradient, for both the CBOW and skip-gram models.

In [Mik+13b], they propose a fast approximation, called skip-gram with negative sampling (SGNS). The basic idea is to create a set of $K + 1$ context words for each central word $w _ { t }$ , and to label the one that actually occurs as positive, and the rest as negative. The negative words are called noise words, and can be sampled from a reweighted unigram distribution, $p ( w ) \propto \mathrm { f r e q } ( w ) ^ { 3 / 4 }$ , which has the effect of redistributing probability mass from common to rare words. The conditional probability is now approximated by

$$
p ( w _ { t + j } | w _ { t } ) = p ( D = 1 | w _ { t } , w _ { t + j } ) \prod _ { k = 1 } ^ { K } p ( D = 0 | w _ { t } , w _ { k } )
$$

where $w _ { k } \sim p ( w )$ are noise words, and $D = 1$ is the event that the word pair actually occurs in the data, and $D = 0$ is the event that the word pair does not occur. The binary probabilities are given by

$$
\begin{array} { r } { p ( D = 1 | w _ { t } , w _ { t + j } ) = \sigma ( \mathbf { u } _ { w _ { t + j } } ^ { \mathsf T } \pmb { v } _ { w _ { t } } ) } \\ { p ( D = 0 | w _ { t } , w _ { k } ) = 1 - \sigma ( \pmb { u } _ { w _ { k } } ^ { \mathsf T } \pmb { v } _ { w _ { t } } ) } \end{array}
$$

To train this model, we just need to compute the contexts for each central word, and a set of negative noise words. We associate a label of 1 with the context words, and a label of 0 with the noise words. We can then compute the log probability of the data, and optimize the embedding vectors ${ \pmb u } _ { i }$ and ${ \pmb v } _ { i }$ for each word using SGD. See skipgram_jax.ipynb for some sample code.

# 20.5.3 GloVE

A popular alternative to Skipgram is the GloVe model of [PSM14a]. (GloVe stands for “global vectors for word representation”.) This method uses a simpler objective, which is much faster to optimize.

To explain the method, recall that in the skipgram model, the predicted conditional probability of word $j$ occuring in the context window of central word $i$ as

$$
q _ { i j } = \frac { \exp ( \pmb { u } _ { j } ^ { \top } \pmb { v } _ { i } ) } { \sum _ { k \in \mathcal { V } } \exp ( \pmb { u } _ { k } ^ { \top } \pmb { v } _ { i } ) }
$$

Let $x _ { i j }$ be the number of times word $j$ occurs in any context window of $i$ . (Note that if word $i$ occurs in the window of $j$ , then $j$ will occur in the window of $i$ , so we have $x _ { i j } = x _ { j i }$ .) Then we can rewrite Equation (20.147) as follows:

$$
\mathcal { L } = - \sum _ { i \in \mathcal { V } } \sum _ { j \in \mathcal { V } } x _ { i j } \log q _ { i j }
$$

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

![](images/35aca7c6ac9f2d054b8b57542bdc976d6317b71e2ebf330ae95e10e4883f93bf.jpg)  
Figure 20.45: Visualization of arithmetic operations in word2vec embedding space. From https: // www. tensorflow. org/ tutorials/ representation/ word2vec .

If we define $p _ { i j } = x _ { i j } / x _ { i }$ to be the empirical probability of word $j$ occuring in the context window of central word $i$ , we can rewrite the skipgram loss as a cross entropy loss:

$$
\mathcal { L } = - \sum _ { i \in \mathcal { V } } x _ { i } \sum _ { j \in \mathcal { V } } p _ { i j } \log q _ { i j }
$$

The problem with this objective is that computing $q _ { i j }$ is expensive, due to the need to normalize over all words. In GloVe, we work with unnormalized probabilities, $p _ { i j } ^ { \prime } = x _ { i j }$ and $q _ { i j } ^ { \prime } = \exp ( { \boldsymbol { u } _ { j } ^ { \scriptscriptstyle 1 } } \boldsymbol { v } _ { i } + \boldsymbol { b } _ { i } + \boldsymbol { c } _ { j } )$ , where $b _ { i }$ and $c _ { j }$ are bias terms to capture marginal probabilities. In addition, we minimize the squared loss, $( \log p _ { i j } ^ { \prime } - \log q _ { i j } ^ { \prime } ) ^ { 2 }$ , which is more robust to errors in estimating small probablities than log loss. Finally, we upweight rare words for which $x _ { i j } < c$ , where $c = 1 0 0$ , by weighting the squared errors by $h ( x _ { i j } )$ , where $h ( x ) = ( x / c ) ^ { 0 . 7 5 }$ if $x < c$ , and $h ( x ) = 1$ otherwise. This gives the final GloVe objective:

$$
\mathcal { L } = - \sum _ { i \in \mathcal { V } } \sum _ { j \in \mathcal { V } } h ( x _ { i j } ) ( \boldsymbol { u } _ { j } ^ { \mathsf { T } } \boldsymbol { v } _ { i } + b _ { i } + c _ { j } - \log x _ { i j } ) ^ { 2 }
$$

We can precompute $x _ { i j }$ offline, and then optimize the above objective using SGD. After training, we define the embedding of word $i$ to be the average of ${ \pmb v } _ { i }$ and $\mathbf { \delta } \mathbf { u } _ { i }$ .

Empirically GloVe gives similar results to skigram, but it is faster to train. See Section 20.5.5 for a theoretical model that explains why these methods work.

# 20.5.4 Word analogies

One of the most remarkable properties of word embeddings produced by word2vec, GloVe, and other similar methods is that the learned vector space seems to capture relational semantics in terms of simple vector addition. For example, consider the word analogy problem “man is to woman as king is to queen”, often written as man:woman::king:queen. Suppose we are given the words $a { = }$ man, $b$ =woman, $c { = }$ king; how do we find $d$ =queen? Let $\pmb { \delta } = \pmb { v } _ { b } - \pmb { v } _ { a }$ be the vector representing the concept of “converting the gender from male to female”. Intuitively we can find word $d$ by computing

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022 ${ \pmb v } _ { d } = { \pmb c } + \delta$ , and then finding the closest word in the vocabulary to ${ \pmb v } _ { d }$ . See Figure 20.45 for an illustration of this process, and word_analogies_jax.ipynb for some code.

In [PSM14a], they conjecture that $a : b : : c : d$ holds iff for every word $w$ in the vocabulary, we have

$$
\frac { p ( w | a ) } { p ( w | b ) } \approx \frac { p ( w | c ) } { p ( w | d ) }
$$

In [Aro+16], they show that this follows from the RAND-WALK modeling assumptions in Section 20.5.5. See also [AH19; EDH19] for other explanations of why word analogies work, based on different modeling assumptions.

# 20.5.5 RAND-WALK model of word embeddings

Word embeddings significantly improve the performance of various kinds of NLP models compared to using one-hot encodings for words. It is natural to wonder why the above word embeddings work so well. In this section, we give a simple generative model for text documents that explains this phenomenon, based on [Aro+16].

Consider a sequence of words $w _ { 1 } , \dots , w _ { T }$ . We assume each word is generated by a latent context or discourse vector $\boldsymbol { z } _ { t } \in \mathbb { R } ^ { D }$ using the following log bilinear language model, similar to [MH07]:

$$
p ( w _ { t } = w | z _ { t } ) = \frac { \exp ( z _ { t } ^ { \top } v _ { w } ) } { \sum _ { w ^ { \prime } } \exp ( z _ { t } ^ { \top } v _ { w ^ { \prime } } ) } = \frac { \exp ( z _ { t } ^ { \top } v _ { w } ) } { Z ( z _ { t } ) }
$$

where ${ \pmb v } _ { w } \in \mathbb { R } ^ { D }$ is the embedding for word $w$ , and $Z ( z _ { t } )$ is the partition function. We assume $D < M$ the number of words in the vocabulary.

Let us further assume the prior for the word embeddings ${ \pmb v } _ { w }$ is an isotropic Gaussian, and that the latent topic $z _ { t }$ undergoes a slow Gaussian random walk. (This is therefore called the RAND-WALK model.) Under this model, one can show that $Z ( z _ { t } )$ is approximately equal to a fixed constant, $Z$ , independent of the context. This is known as the self-normalization property of log-linear models [AK15]. Furthermore, one can show that the pointwise mutual information of predictions from the model is given by

$$
\mathbb { P M I } [ ( w , w ^ { \prime } ) = \frac { p ( w , w ^ { \prime } ) } { p ( w ) p ( w ^ { \prime } ) } \approx \frac { { \pmb v } _ { w } ^ { \top } { \pmb v } _ { w ^ { \prime } } } { D }
$$

We can therefore fit the RAND-WALK model by matching the model’s predicted values for PMI with the empirical values, i.e., we minimize

$$
\mathcal { L } = \sum _ { w , w ^ { \prime } } X _ { w , w ^ { \prime } } ( \mathbb { P M I I } ( w , w ^ { \prime } ) - v _ { w } ^ { \top } v _ { w ^ { \prime } } ) ^ { 2 }
$$

where $X _ { w , w ^ { \prime } }$ is the number of times $w$ and $w ^ { \prime }$ occur next to each other. This objective can be seen as a frequency-weighted version of the SVD loss in Equation (20.138). (See [LG14] for more connections between word embeddings and SVD.)

Furthermore, some additional approximations can be used to show that the NLL for the RANDWALK model is equivalent to the CBOW and SGNS word2vec objectives. We can also derive the objective for GloVE from this approach.

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

# 20.5.6 Contextual word embeddings

Consider the sentences “I was eating an apple” and “I bought a new phone from Apple”. The meaning of the word “apple” is different in both cases, but a fixed word embedding, of the type discussed in Section 20.5, would not be able to capture this. In Section 15.7, we discuss contextual word embeddings, where the embedding of a word is a function of all the words in its context (usually a sentence). This can give much improved results, and is currently the standard approach to representing natural language data, as a pre-processing step before doing transfer learning (see Section 19.2).

# 20.6 Exercises

Exercise 20.1 [EM for FA]

Derive the EM updates for the factor analysis model. For simplicity, you can optionally assume $\pmb { \mu } = \mathbf { 0 }$ is fixed.

Exercise 20.2 [EM for mixFA \*]

Derive the EM updates for a mixture of factor analysers.

Exercise 20.3 [Deriving the second principal component]

a. Let

$$
J ( { \pmb v } _ { 2 } , z _ { 2 } ) = \frac { 1 } { n } \sum _ { i = 1 } ^ { n } ( { \pmb x } _ { i } - z _ { i 1 } { \pmb v } _ { 1 } - z _ { i 2 } { \pmb v } _ { 2 } ) ^ { T } ( { \pmb x } _ { i } - z _ { i 1 } { \pmb v } _ { 1 } - z _ { i 2 } { \pmb v } _ { 2 } )
$$

Show that $\begin{array} { r } { \frac { \partial J } { \partial z _ { 2 } } = 0 } \end{array}$ yields $z _ { i 2 } = \pmb { v } _ { 2 } ^ { I } \pmb { x } _ { i }$

b. Show that the value of ${ \pmb v } _ { 2 }$ that minimizes

$$
\begin{array} { r } { \tilde { J } ( v _ { 2 } ) = - v _ { 2 } ^ { T } \mathbf { C } v _ { 2 } + \lambda _ { 2 } ( v _ { 2 } ^ { T } v _ { 2 } - 1 ) + \lambda _ { 1 2 } ( v _ { 2 } ^ { T } v _ { 1 } - 0 ) } \end{array}
$$

is given by the eigenvector of $\mathbf { C }$ with the second largest eigenvalue. Hint: recall that $\mathbf { C } { \boldsymbol { v } } _ { 1 } = \lambda _ { 1 } { \boldsymbol { v } } _ { 1 }$ and $\begin{array} { r } { \frac { \partial \mathbf { x } ^ { T } \mathbf { A } \pmb { x } } { \partial \mathbf { x } } = ( \mathbf { A } + \mathbf { A } ^ { T } ) \pmb { x } } \end{array}$ .

Exercise 20.4 [Deriving the residual error for PCA \*]

a. Prove that

$$
| | { \pmb x } _ { i } - \sum _ { j = 1 } ^ { K } z _ { i j } { \pmb v } _ { j } | | ^ { 2 } = { \pmb x } _ { i } ^ { T } { \pmb x } _ { i } - \sum _ { j = 1 } ^ { K } { \pmb v } _ { j } ^ { T } { \pmb x } _ { i } { \pmb x } _ { i } ^ { T } { \pmb v } _ { j }
$$

Hint: first consider the case $K = 2$ . Use the fact that $\pmb { v } _ { j } ^ { T } \pmb { v } _ { j } = 1$ and ${ \pmb v } _ { j } ^ { \prime } { \pmb v } _ { k } = 0$ for $k \neq j$ . Also, recall $z _ { i j } = \pmb { x } _ { i } ^ { T } \pmb { v } _ { j }$ .

b. Now show that

$$
J _ { K } \triangleq { \frac { 1 } { n } } \sum _ { i = 1 } ^ { n } \left( { \pmb x } _ { i } ^ { T } { \pmb x } _ { i } - \sum _ { j = 1 } ^ { K } { \pmb v } _ { j } ^ { T } { \pmb x } _ { i } { \pmb x } _ { i } ^ { T } { \pmb v } _ { j } \right) = { \frac { 1 } { n } } \sum _ { i = 1 } ^ { n } { \pmb x } _ { i } ^ { T } { \pmb x } _ { i } - \sum _ { j = 1 } ^ { K } \lambda _ { j }
$$

Hint: recall vjT Cvj = λjvjT vj = λj.

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

c. If $K = d$ there is no truncation, so $J _ { d } = 0$ . Use this to show that the error from only using $K < d$ terms is given by

$$
J _ { K } = \sum _ { j = K + 1 } ^ { d } \lambda _ { j }
$$

Hint: partition the sum $\textstyle \sum _ { j = 1 } ^ { d } \lambda _ { j }$ into $\textstyle \sum _ { j = 1 } ^ { K } \lambda _ { j }$ and $\textstyle \sum _ { j = K + 1 } ^ { d } \lambda _ { j }$ .

# Exercise 20.5 [PCA via successive deflation]

Let $\pmb { v } _ { 1 } , \pmb { v } _ { 2 } , \ldots , \pmb { v } _ { k }$ be the first $k$ eigenvectors with largest eigenvalues of $\begin{array} { r } { \mathbf { C } = \frac { 1 } { n } \mathbf { X } ^ { T } \mathbf { X } } \end{array}$ , i.e., the principal basis vectors. These satisfy

$$
\pmb { v } _ { j } ^ { T } \pmb { v } _ { k } = \left\{ \begin{array} { r l } { 0 } & { \mathrm { ~ i f ~ } j \neq k } \\ { 1 } & { \mathrm { ~ i f ~ } j = k } \end{array} \right.
$$

We will construct a method for finding the ${ \pmb v } _ { j }$ sequentially.

As we showed in class, $_ { v _ { 1 } }$ is the first principal eigenvector of $\mathbf { C }$ , and satisfies $\mathbf { C } { \boldsymbol { v } } _ { 1 } = \lambda _ { 1 } { \boldsymbol { v } } _ { 1 }$ . Now define $\tilde { \mathbf { x } } _ { i }$ as the orthogonal projection of $\pmb { x } _ { i }$ onto the space orthogonal to ${ \pmb v } _ { 1 }$ :

$$
\tilde { \pmb { x } } _ { i } = \mathbf { P } _ { \perp v _ { 1 } } \pmb { x } _ { i } = ( \mathbf { I } - \pmb { v } _ { 1 } \pmb { v } _ { 1 } ^ { T } ) \pmb { x } _ { i }
$$

Define $\tilde { \mathbf { X } } = [ \tilde { \pmb { x } } _ { 1 } ; . . . ; \tilde { \pmb { x } } _ { n } ]$ as the deflated matrix of rank $d - 1$ , which is obtained by removing from the $d$ dimensional data the component that lies in the direction of the first principal direction:

$$
\tilde { \mathbf { X } } = ( \mathbf { I } - \pmb { v } _ { 1 } \pmb { v } _ { 1 } ^ { T } ) ^ { T } \mathbf { X } = ( \mathbf { I } - \pmb { v } _ { 1 } \pmb { v } _ { 1 } ^ { T } ) \mathbf { X }
$$

a. Using the facts that $\mathbf { X } ^ { T } \mathbf { X } \pmb { v } _ { 1 } = n \lambda _ { 1 } \pmb { v } _ { 1 }$ (and hence $\pmb { v } _ { 1 } ^ { T } \mathbf { X } ^ { T } \mathbf { X } = n \lambda _ { 1 } \pmb { v } _ { 1 } ^ { T }$ ) and ${ \pmb v } _ { 1 } ^ { T } { \pmb v } _ { 1 } = 1$ , show that the covariance of the deflated matrix is given by

$$
\tilde { \mathbf { C } } \triangleq \frac { 1 } { n } \tilde { \mathbf { X } } ^ { T } \tilde { \mathbf { X } } = \frac { 1 } { n } \mathbf { X } ^ { T } \mathbf { X } - \lambda _ { 1 } \pmb { v } _ { 1 } \pmb { v } _ { 1 } ^ { T }
$$

b. Let $\textbf { \em u }$ be the principal eigenvector of $\tilde { \mathbf { C } }$ . Explain why ${ \pmb u } = { \pmb v } _ { 2 }$ . (You may assume $\mathbf { \Delta } ^ { \mathbf { u } }$ is unit norm.)

c. Suppose we have a simple method for finding the leading eigenvector and eigenvalue of a pd matrix, denoted by $[ \lambda , \boldsymbol { \mathbf { u } } ] = f ( \boldsymbol { \mathbf { C } } )$ . Write some pseudo code for finding the first $K$ principal basis vectors of $\mathbf { X }$ that only uses the special $f$ function and simple vector arithmetic, i.e., your code should not use SVD or the eig function. Hint: this should be a simple iterative routine that takes 2–3 lines to write. The input is $\mathbf { C }$ , $K$ and the function $f$ , the output should be ${ \pmb v } _ { j }$ and $\lambda _ { j }$ for $j = 1 : K$ .

# Exercise 20.6 [PPCA variance terms]

Recall that in the PPCA model, $\mathbf { C } = \mathbf { W } \mathbf { W } ^ { T } + \sigma ^ { 2 } \mathbf { I }$ . We will show that this model correctly captures the variance of the data along the principal axes, and approximates the variance in all the remaining directions with a single average value $\sigma ^ { 2 }$ .

Consider the variance of the predictive distribution $p ( { \pmb x } )$ along some direction specified by the unit vector $_ { v }$ , where $\pmb { v } ^ { T } \pmb { v } = 1$ , which is given by $\boldsymbol { v } ^ { \prime } \boldsymbol { C } \boldsymbol { v }$ .

a. First suppose $_ v$ is orthogonal to the principal subspace. and hence $\pmb { v } ^ { T } \mathbf { U } = \mathbf { 0 }$ . Show that ${ \pmb v } ^ { T } { \bf C } { \pmb v } = \sigma ^ { 2 }$ . b. Now suppose $_ v$ is parallel to the principal subspace. and hence $\mathbf { \nabla } \pmb { v } = \mathbf { \nabla } \pmb { u } _ { i }$ for some eigenvector ${ \bf { u } } _ { i }$ . Show that $v ^ { T } \mathbf { C } v = ( \lambda _ { i } - \sigma ^ { 2 } ) + \sigma ^ { 2 } = \lambda _ { i }$ .

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

Exercise 20.7 [Posterior inference in PPCA \*] Derive $p ( z _ { n } | \pmb { x } _ { n } )$ for the PPCA model.

Exercise 20.8 [Imputation in a FA model \*] Derive an expression for $p ( \pmb { x } _ { h } | \pmb { x } _ { v } , \pmb { \theta } )$ for a FA model, where ${ \pmb x } = ( { \pmb x } _ { h } , { \pmb x } _ { v } )$ is a partition of the data vector.

Exercise 20.9 [Efficiently evaluating the PPCA density]

Derive an expression for $p ( \mathbf { \boldsymbol { x } } | \hat { \mathbf { W } } , \hat { \boldsymbol { \sigma } } ^ { 2 } )$ for the PPCA model based on plugging in the MLEs and using the matrix inversion lemma.

# 21 Clustering

# 21.1 Introduction

Clustering is a very common form of unsupervised learning. There are two main kinds of methods. In the first approach, the input is a set of data samples $\mathcal { D } = \{ \pmb { x } _ { n } : n = 1 : N \}$ , where $\pmb { x } _ { n } \in \mathcal { X }$ , where typically $\boldsymbol { \mathcal { X } } = \mathbb { R } ^ { D }$ . In the second approach, the input is an $N \times N$ pairwise dissimilarity metric $D _ { i j } \geq 0$ . In both cases, the goal is to assign similar data points to the same cluster.

As is often the case with unsupervised learning, it is hard to evaluate the quality of a clustering algorithm. If we have labeled data for some of the data, we can use the similarity (or equality) between the labels of two data points as a metric for determining if the two inputs “should” be assigned to the same cluster or not. If we don’t have labels, but the method is based on a generative model of the data, we can use log likelihood as a metric. We will see examples of both approaches below.

# 21.1.1 Evaluating the output of clustering methods

The validation of clustering structures is the most difficult and frustrating part of cluster analysis. Without a strong effort in this direction, cluster analysis will remain a black art accessible only to those true believers who have experience and great courage. — Jain and Dubes [JD88]

Clustering is an unsupervised learning technique, so it is hard to evaluate the quality of the output of any given method [Kle02; LWG12]. If we use probabilistic models, we can always evaluate the likelihood of the data, but this has two drawbacks: first, it does not directly assess any clustering that is discovered by the model; and second, it does not apply to non-probabilistic methods. So now we discuss some performance measures not based on likelihood.

Intuitively, the goal of clustering is to assign points that are similar to the same cluster, and to ensure that points that are dissimilar are in different clusters. There are several ways of measuring these quantities e.g., see [JD88; KR90]. However, these internal criteria may be of limited use. An alternative is to rely on some external form of data with which to validate the method. For example, if we have labels for each object, then we can assume that objects with the same label are similar. We can then use the metrics we discuss below to quantify the quality of the clusters. (If we do not have labels, but we have a reference clustering, we can derive labels from that clustering.)

AAA ABB AA AAB BBC ccc

# 21.1.1.1 Purity

Let $N _ { i j }$ be the number of objects in cluster $i$ that belong to class $j$ , and let $\begin{array} { r } { N _ { i } = \sum _ { j = 1 } ^ { C } N _ { i j } } \end{array}$ be the total number of objects in cluster $i$ . Define $p _ { i j } = N _ { i j } / N _ { i }$ ; this is the empirical distr bution over class labels for cluster $i$ . We define the purity of a cluster as $p _ { i } \triangleq \operatorname* { m a x } _ { j } p _ { i j }$ , and the overall purity of a clustering as

$$
\mathrm { p u r i t y } \triangleq \sum _ { i } { \frac { N _ { i } } { N } } p _ { i }
$$

For example, in Figure 21.1, we have that the purity is

$$
{ \frac { 6 } { 1 7 } } { \frac { 5 } { 6 } } + { \frac { 6 } { 1 7 } } { \frac { 4 } { 6 } } + { \frac { 5 } { 1 7 } } { \frac { 3 } { 5 } } = { \frac { 5 + 4 + 3 } { 1 7 } } = 0 . 7 1
$$

The purity ranges between 0 (bad) and 1 (good). However, we can trivially achieve a purity of $^ { 1 }$ by putting each object into its own cluster, so this measure does not penalize for the number of clusters.

# 21.1.1.2 Rand index

Let $U = \{ u _ { 1 } , \ldots , u _ { R } \}$ and $V = \{ v _ { 1 } , \ldots , v _ { C } \}$ be two different partitions of the $N$ data points. For example, $U$ might be the estimated clustering and $V$ is reference clustering derived from the class labels. Now define a $2 \times 2$ contingency table, containing the following numbers: $T P$ is the number of pairs that are in the same cluster in both $U$ and $V$ (true positives); $T N$ is the number of pairs that are in the different clusters in both $U$ and $V$ (true negatives); $F N$ is the number of pairs that are in the different clusters in $U$ but the same cluster in $V$ (false negatives); and $F P$ is the number of pairs that are in the same cluster in $U$ but different clusters in $V$ (false positives). A common summary statistic is the Rand index:

$$
R \triangleq { \frac { T P + T N } { T P + F P + F N + T N } }
$$

This can be interpreted as the fraction of clustering decisions that are correct. Clearly $0 \leq R \leq 1$ . For example, consider Figure 21.1, The three clusters contain 6, 6 and 5 points, so the number of “positives” (i.e., pairs of objects put in the same cluster, regardless of label) is

$$
T P + F P = { \binom { 6 } { 2 } } + { \binom { 6 } { 2 } } + { \binom { 5 } { 2 } } = 4 0
$$

Of these, the number of true positives is given by

$$
T P = { \binom { 5 } { 2 } } + { \binom { 4 } { 2 } } + { \binom { 3 } { 2 } } + { \binom { 2 } { 2 } } = 2 0
$$

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

where the last two terms come from cluster 3: there are $\binom { 3 } { 2 }$ pairs labeled $C$ and $\binom { 2 } { 2 }$ pairs labeled $A$ . So $F P = 4 0 - 2 0 = 2 0$ . Similarly, one can show $F N = 2 4$ and $T N = 7 2$ . So the Rand index is $( 2 0 + 7 2 ) / ( 2 0 + 2 0 + 2 4 + 7 2 ) = 0 . 6 8$ .

The Rand index only achieves its lower bound of $0$ if $T P = T N = 0$ , which is a rare event. One can define an adjusted Rand index [HA85] as follows:

$$
A R \triangleq { \frac { \mathrm { i n d e x } - { \mathrm { e x p e c t e d ~ i n d e x } } } { \mathrm { m a x ~ i n d e x } - { \mathrm { e x p e c t e d ~ i n d e x } } } }
$$

Here the model of randomness is based on using the generalized hyper-geometric distribution, i.e., the two partitions are picked at random subject to having the original number of classes and objects in each, and then the expected value of $T P + T N$ is computed. This model can be used to compute the statistical significance of the Rand index.

The Rand index weights false positives and false negatives equally. Various other summary statistics for binary decision problems, such as the F-score (Section 5.1.4), can also be used.

# 21.1.1.3 Mutual information

Another way to measure cluster quality is to compute the mutual information between two candidate partitions $U$ and $V$ , as proposed in [VD99]. To do this, let $\begin{array} { r } { p _ { U V } ( i , j ) = \frac { | u _ { i } \cap v _ { j } | } { N } } \end{array}$ be the probability that a randomly chosen object belongs to cluster $u _ { i }$ in $U$ and $v _ { j }$ in $V$ . Also, let $p _ { U } ( i ) = | u _ { i } | / N$ be the be the probability that a randomly chosen object belongs to cluster $u _ { i }$ in $U$ ; define $p _ { V } ( j ) = | v _ { j } | / N$ similarly. Then we have

$$
\mathbb { I } ( U , V ) = \sum _ { i = 1 } ^ { R } \sum _ { j = 1 } ^ { C } p _ { U V } ( i , j ) \log \frac { p _ { U V } ( i , j ) } { p _ { U } ( i ) p _ { V } ( j ) }
$$

This lies between 0 and $\operatorname* { m i n } \{ \mathbb { H } \left( U \right) , \mathbb { H } \left( V \right) \}$ . Unfortunately, the maximum value can be achieved by using lots of small clusters, which have low entropy. To compensate for this, we can use the normalized mutual information,

$$
N M I ( U , V ) \triangleq \frac { \mathbb { I } ( U , V ) } { ( \mathbb { H } ( U ) + \mathbb { H } ( V ) ) / 2 }
$$

This lies between 0 and 1. A version of this that is adjusted for chance (under a particular random data model) is described in [VEB09]. Another variant, called variation of information, is described in [Mei05].

# 21.2 Hierarchical agglomerative clustering

A common form of clustering is known as hierarchical agglomerative clustering or HAC. The input to the algorithm is an $N \times N$ dissimilarity matrix $D _ { i j } \geq 0$ , and the output is a tree structure in which groups $i$ and $j$ with small disimilarity are grouped together in a hierarchical fashion.

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

![](images/566a537366ff4c0526776211a52c167bafe4467a460e6ee9682e2d6d19e5fc51.jpg)  
Figure 21.2: (a) An example of single link clustering using city block distance. Pairs (1,3) and (4,5) are both distance 1 apart, so get merged first. (b) The resulting dendrogram. Adapted from Figure 7.5 of [Alp04]. Generated by agglomDemo.ipynb.

![](images/46b5386596daf87d04e7b761eae66fe1f897efd899feb95b8851774eb1479a54.jpg)  
Figure 21.3: Illustration of (a) Single linkage. (b) Complete linkage. (c) Average linkage.

For example, consider the set of 5 inputs points in Figure 21.2(a), $\pmb { x } _ { n } \in \mathbb { R } ^ { 2 }$ . We will use city block distance between the points to define the dissimilarity, i.e.,

$$
d _ { i j } = \sum _ { k = 1 } ^ { 2 } \left| x _ { i k } - x _ { j k } \right|
$$

We start with a tree with $N$ leaves, each corresponding to a cluster with a single data point. Next we compute the pair of points that are closest, and merge them. We see that (1,3) and (4,5) are both distance 1 apart, so they get merged first. We then measure the dissimilarity between the sets $\{ 1 , 3 \}$ , $\{ 4 , 5 \}$ and $\{ 2 \}$ using some measure (details below), and group them, and repeat. The result is a binary tree known as a dendogram, as shown in Figure 21.2(b). By cutting this tree at different heights, we can induce a different number of (nested) clusters. We give more details below.

# 21.2.1 The algorithm

Agglomerative clustering starts with $N$ groups, each initially containing one object, and then at each step it merges the two most similar groups until there is a single group, containing all the data. See Algorithm 11 for the pseudocode. Since picking the two most similar clusters to merge takes $O ( N ^ { 2 } )$ time, and there are $O ( N )$ steps in the algorithm, the total running time is $O ( N ^ { 3 } )$ . However, by using a priority queue, this can be reduced to $O ( N ^ { 2 } \log N )$ (see e.g., [MRS08, ch. 17] for details).

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

# Algorithm 11: Agglomerative clustering

1 Initialize clusters as singletons: for $i \gets 1$ to $n$ do $C _ { i } \gets \{ i \}$   
2   
3 Initialize set of clusters available for merging: $S \gets \{ 1 , \ldots , n \}$ ; repeat   
4 Pick 2 most similar clusters to merge: $( j , k ) \gets \arg \operatorname* { m i n } _ { j , k \in S } d _ { j , k }$   
5 Create new cluster $C _ { \ell } \gets C _ { j } \cup C _ { k }$   
6 Mark $j$ and $k$ as unavailable: $S \gets S \setminus \{ j , k \}$   
7 if $C _ { \ell } \neq \{ 1 , \ldots , n \}$ then   
8 Mark $\ell$ as available, $S \gets S \cup \{ \ell \}$   
9 foreach $i \in S$ do   
10 Update dissimilarity matrix $d ( i , \ell )$

11 until no more clusters are available for merging

![](images/04d4e26c5c750110128cb7a46279dc25a4cbb38125f9a13a68008c95bfa4dc4b.jpg)  
Figure 21.4: Hierarchical clustering of yeast gene expression data. (a) Single linkage. (b) Complete linkage. (c) Average linkage. Generated by hclust_yeast_demo.ipynb.

There are actually three variants of agglomerative clustering, depending on how we define the dissimilarity between groups of objects. We give the details below.

# 21.2.1.1 Single link

In single link clustering, also called nearest neighbor clustering, the distance between two groups $G$ and $H$ is defined as the distance between the two closest members of each group:

$$
d _ { S L } ( G , H ) = \operatorname* { m i n } _ { i \in G , i ^ { \prime } \in H } d _ { i , i ^ { \prime } }
$$

See Figure 21.3(a).

The tree built using single link clustering is a minimum spanning tree of the data, which is a tree that connects all the objects in a way that minimizes the sum of the edge weights (distances). To see this, note that when we merge two clusters, we connect together the two closest members of the clusters; this adds an edge between the corresponding nodes, and this is guaranteed to be the

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license “lightest weight” edge joining these two clusters. And once two clusters have been merged, they will never be considered again, so we cannot create cycles. As a consequence of this, we can actually implement single link clustering in $O ( N ^ { 2 } )$ time, whereas the other variants take $O ( N ^ { 3 } )$ time.

# 21.2.1.2 Complete link

In complete link clustering, also called furthest neighbor clustering, the distance between two groups is defined as the distance between the two most distant pairs:

$$
d _ { C L } ( G , H ) = \operatorname* { m a x } _ { i \in G , i ^ { \prime } \in H } d _ { i , i ^ { \prime } }
$$

See Figure 21.3(b).

Single linkage only requires that a single pair of objects be close for the two groups to be considered close together, regardless of the similarity of the other members of the group. Thus clusters can be formed that violate the compactness property, which says that all the observations within a group should be similar to each other. In particular if we define the diameter of a group as the largest dissimilarity of its members, $d _ { G } = \operatorname* { m a x } _ { i \in G , i ^ { \prime } \in G } d _ { i , i ^ { \prime } }$ , then we can see that single linkage can produce clusters with large diameters. Complete linkage represents the opposite extreme: two groups are considered close only if all of the observations in their union are relatively similar. This will tend to produce clusterings with small diameter, i.e., compact clusters. (Compare Figure 21.4(a) with Figure 21.4(b).)

# 21.2.1.3 Average link

In practice, the preferred method is average link clustering, which measures the average distance between all pairs:

$$
d _ { a v g } ( G , H ) = \frac { 1 } { n _ { G } n _ { H } } \sum _ { i \in G } \sum _ { i ^ { \prime } \in H } d _ { i , i ^ { \prime } }
$$

where $n _ { G }$ and $n _ { H }$ are the number of elements in groups $G$ and $H$ . See Figure 21.3(c).

Average link clustering represents a compromise between single and complete link clustering. It tends to produce relatively compact clusters that are relatively far apart. (See Figure 21.4(c).) However, since it involves averaging of the $d _ { i , i ^ { \prime } }$ ’s, any change to the measurement scale can change the result. In contrast, single linkage and complete linkage are invariant to monotonic transformations of $d _ { i , i ^ { \prime } }$ , since they leave the relative ordering the same.

# 21.2.2 Example

Suppose we have a set of time series measurements of the expression levels for $N = 3 0 0$ genes at $T = 7$ points. Thus each data sample is a vector $\mathbf { \boldsymbol { x } } _ { n } \in \mathbb { R } ^ { 7 }$ . See Figure 21.5 for a visualization of the data. We see that there are several kinds of genes, such as those whose expression level goes up monotonically over time (in response to a given stimulus), those whose expression level goes down monotonically, and those with more complex response patterns.

Suppose we use Euclidean distance to compute a pairwise dissimilarity matrix, $ { \mathbf { D } } \in \mathbb { R } ^ { 3 0 0 \times 3 0 0 }$ , and apply HAC using average linkage. We get the dendogram in Figure 21.6(a). If we cut the tree at

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022 a certain height, we get the 16 clusters shown in Figure 21.6(b). The time series assigned to each cluster do indeed “look like” each other.

![](images/7522fee6b860c5d5ebd2b40b79371a2a8a98b352de44c180ff20e62b6c1ed036.jpg)  
Figure 21.5: (a) Some yeast gene expression data plotted as a heat map. (b) Same data plotted as a time series. Generated by yeast_data_viz.ipynb.

![](images/cbeb064f7445f3c8ba7c97cfd1079edb9217a2e9c43fde63b9e8eb3fff1759fb.jpg)  
Figure 21.6: Hierarchical clustering applied to the yeast gene expression data. (a) The rows are permuted according to a hierarchical clustering scheme (average link agglomerative clustering), in order to bring similar rows close together. (b) 16 clusters induced by cutting the average linkage tree at a certain height. Generated by hclust_yeast_demo.ipynb.

# 21.2.3 Extensions

There are many extensions to the basic HAC algorithm. For example, [Mon+21] present a more scalable version of the bottom up algorithm that builds sub-clusters in parallel. And g [Mon+19] discusses an online version of the algorithm, that can cluster data as it arrives, while reconsidering

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license previous clustering decisions (as opposed to only making greedy decisions). Under certain assumptions, this can provably recover the true underlying structure. This can be useful for clustering “mentions” of “entities” (such as people or things) in streaming text data. (This problem is called entity discovery.)

# 21.3 K means clustering

There are several problems with hierarchical agglomerative clustering (Section 21.2). First, it takes $O ( N ^ { 3 } )$ time (for the average link method), making it hard to apply to big datasets. Second, it assumes that a dissimilarity matrix has already been computed, whereas the notion of “similarity” is often unclear and needs to be learned. Third, it is just an algorithm, not a model, and so it is hard to evaluate how good it is. That is, there is no clear objective that it is optimizing.

In this section, we discuss the $\mathbf { K }$ -means algorithm [Mac67; Llo82], which addresses these issues. First, it runs in $O ( N K T )$ time, where $T$ is the number of iterations. Second, it computes similarity in terms of Euclidean distance to learned cluster centers $\pmb { \mu } _ { k } \in \mathbb { R } ^ { D }$ , rather than requiring a dissimilarity matrix. Third, it optimizes a well-defined cost function, as we will see.

# 21.3.1 The algorithm

We assume there are $K$ cluster centers $\pmb { \mu } _ { k } \in \mathbb { R } ^ { D }$ , so we can cluster the data by assigning each data point $\pmb { x } _ { n } \in \mathbb { R } ^ { D }$ to it closest center:

$$
z _ { n } ^ { * } = \arg \operatorname* { m i n } _ { k } | | { \pmb x } _ { n } - { \pmb \mu } _ { k } | | _ { 2 } ^ { 2 }
$$

Of course, we don’t know the cluster centers, but we can estimate them by computing the average value of all points assigned to them:

$$
\pmb { \mu } _ { k } = \frac { 1 } { N _ { k } } \sum _ { n : z _ { n } = k } \pmb { x } _ { n }
$$

We can then iterate these steps to convergence.

More formally, we can view this as finding a local minimum of the following cost function, known as the distortion:

$$
J ( \mathbf { M } , \mathbf { Z } ) = \sum _ { n = 1 } ^ { N } | | \pmb { x } _ { n } - \pmb { \mu } _ { z _ { n } } | | ^ { 2 } = | | \mathbf { X } - \mathbf { Z } \mathbf { M } ^ { \mathsf { T } } | | _ { F } ^ { 2 }
$$

where $\mathbf { X } \in \mathbb { R } ^ { N \times D }$ , $\mathbf { Z } \in [ 0 , 1 ] ^ { N \times K }$ , and $\mathbf { M } \in \mathbb { R } ^ { D \times K }$ contains the cluster centers $\pmb { \mu } _ { k }$ in its columns. K-means optimizes this using alternating minimization. (This is closely related to the EM algorithm for GMMs, as we discuss in Section 21.4.1.1.)

# 21.3.2 Examples

In this section, we give some examples of K-means clustering.

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

![](images/5ad9a05a881d8886cfeec93f9c039bb1031628956573d3a5b7f024dee4ab06cf.jpg)  
Figure 21.7: Illustration of K-means clustering in 2d. We show the result of using two different random seeds. Adapted from Figure 9.5 of [Gér19]. Generated by kmeans_voronoi.ipynb.

![](images/a11abe72e19bd61920bd32ec2b40febfc82e3fe67fd77e1b9fababa81eacbbec.jpg)  
Figure 21.8: Clustering the yeast data from Figure 21.5 using K-means clustering with $K = 1 6$ . (a) Visualizing all the time series assigned to each cluster. (b) Visualizing the 16 cluster centers as prototypical time series. Generated by kmeans_yeast_demo.ipynb.

# 21.3.2.1 Clustering points in the 2d plane

Figure 21.7 gives an illustration of K-means clustering applied to some points in the 2d plane. We see that the method induces a Voronoi tessellation of the points. The resulting clustering is sensitive to the initialization. Indeed, we see that the lower quality clustering on the right has higher distortion. By default, sklearn uses 10 random restarts (combined with the K-means $^ { + + }$ initialization described in Section 21.3.4) and returns the clustering with lowest distortion. (In sklearn, the distortion is called the “inertia”.)

# 21.3.2.2 Clustering gene expression time series data from yeast cells

In Figure 21.8, we show the result of applying K-means clustering with $K = 1 6$ to the $3 0 0 \times 7$ yeast time series matrix shown in Figure 21.5. We see that time series that “look similar” to each other are

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license assigned to the same cluster. We also see that the centroid of each cluster is a reasonabe summary all the data points assigned to that cluster. Finally we notice that group 6 was not used, since no points were assigned to it. However, this is just an accident of the initialization process, and we are not guaranteed to get the same clustering, or number of clusters, if we repeat the algorithm. (We discuss good ways to initialize the method in Section 21.3.4, and ways to choose $K$ in Section 21.3.7.)

![](images/4c0087ff2a923ae8b462d04cabba8bde735c786acc397800a57a853f6aa0946e.jpg)  
Figure 21.9: An image compressed using vector quantization with a codebook of size $K$ . (a) $K = 2$ . (b) $K = 4$ . (c) Original uncompressed image. Generated by vqDemo.ipynb.

# 21.3.3 Vector quantization

Suppose we want to perform lossy compression of some real-valued vectors, $\pmb { x } _ { n } \in \mathbb { R } ^ { D }$ . A very simple approach to this is to use vector quantization or VQ. The basic idea is to replace each real-valued vector $\pmb { x } _ { n } \in \mathbb { R } ^ { D }$ with a discrete symbol $z _ { n } \in \{ 1 , \ldots , K \}$ , which is an index into a codebook of $K$ prototypes, $\pmb { \mu } _ { k } \in \mathbb { R } ^ { D }$ . Each data vector is encoded by using the index of the most similar prototype, where similarity is measured in terms of Euclidean distance:

$$
\operatorname { e n c o d e } ( \pmb { x } _ { n } ) = \arg \operatorname* { m i n } _ { k } | | \pmb { x } _ { n } - \pmb { \mu } _ { k } | | ^ { 2 }
$$

We can define a cost function that measures the quality of a codebook by computing the reconstruction error or distortion it induces:

$$
J \triangleq { \frac { 1 } { N } } \sum _ { n = 1 } ^ { N } | | x _ { n } - \operatorname* { d e c o d e } ( \operatorname { e n c o d e } ( \pmb { x } _ { n } ) ) | | ^ { 2 } = { \frac { 1 } { N } } \sum _ { n = 1 } ^ { N } | | x _ { n } - \mu _ { z _ { n } } | | ^ { 2 }
$$

where $\operatorname* { d e c o d e } ( k ) = \pmb { \mu } _ { k }$ . This is exactly the cost function that is minimized by the K-means algorithm. Of course, we can achieve zero distortion if we assign one prototype to every data vector, by using   
$K = N$ and assigning . However, this does not compress the data at all. In particular, it ${ \pmb { \mu } } _ { n } = { \pmb x } _ { n }$   
takes $O ( N D B )$ bits, where $N$ is the number of real-valued data vectors, each of length $D$ , and $B$ is   
the number of bits needed to represent a real-valued scalar (the quantization accuracy to represent   
each ${ \boldsymbol { \mathbf { \mathit { x } } } } _ { n }$ ).

We can do better by detecting similar vectors in the data, creating prototypes or centroids for them, and then representing the data as deviations from these prototypes. This reduces the space

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022 requirement to $O ( N \log _ { 2 } K + K D B )$ bits. The $O ( N \log _ { 2 } K )$ term arises because each of the $N$ data vectors needs to specify which of the $K$ codewords it is using; and the $O ( K D B )$ term arises because we have to store each codebook entry, each of which is a $D$ -dimensional vector. When $N$ is large, the first term dominates the second, so we can approximate the rate of the encoding scheme (number of bits needed per object) as $O ( \log _ { 2 } K )$ , which is typically much less than $O ( D B )$ .

One application of VQ is to image compression. Consider the $2 0 0 \times 3 2 0$ pixel image in Figure 21.9; we will treat this as a set of $N = 6 4 , 0 0 0$ scalars. If we use one byte to represent each pixel (a gray-scale intensity of 0 to 255), then $B = 8$ , so we need $N B = 5 1 2 , 0 0 0$ bits to represent the image in uncompressed form. For the compressed image, we need $O ( N \log _ { 2 } K )$ bits. For $K = 4$ , this is about 128kb, a factor of 4 compression, yet it results in negligible perceptual loss (see Figure 21.9(b)).

Greater compression could be achieved if we modeled spatial correlation between the pixels, e.g., if we encoded 5x5 blocks (as used by JPEG). This is because the residual errors (differences from the model’s predictions) would be smaller, and would take fewer bits to encode. This shows the deep connection between data compression and density estimation. See the sequel to this book, [Mur23], for more information.

# 21.3.4 The K-means++ algorithm

K-means is optimizing a non-convex objective, and hence needs to be initialized carefully. A simple approach is to pick $K$ data points at random, and to use these as the initial values for $\pmb { \mu } _ { k }$ . We can improve on this by using multiple restarts, i.e., we run the algorithm multiple times from different random starting points, and then pick the best solution. However, this can be slow.

A better approach is to pick the centers sequentially so as to try to “cover” the data. That is, we pick the initial point uniformly at random, and then each subsequent point is picked from the remaining points, with probability proportional to its squared distance to the point’s closest cluster center. That is, at iteration $t$ , we pick the next cluster center to be ${ \boldsymbol { \mathbf { \mathit { x } } } } _ { n }$ with probability

$$
p ( \pmb \mu _ { t } = \pmb x _ { n } ) = \frac { D _ { t - 1 } ( \pmb x _ { n } ) } { \sum _ { n ^ { \prime } = 1 } ^ { N } D _ { t - 1 } ( \pmb x _ { n ^ { \prime } } ) }
$$

where

$$
D _ { t } ( \pmb { x } ) = \operatorname* { m i n } _ { k = 1 } ^ { t - 1 } | | \pmb { x } - \pmb { \mu _ { k } } | | _ { 2 } ^ { 2 }
$$

is the squared distance of $_ { x }$ to the closest existing centroid. Thus points that are far away from a centroid are more likely to be picked, thus reducing the distortion. This is known as farthest point clustering [Gon85], or K-means $^ { + + }$ [AV07; Bah+12; Bac+16; BLK17; LS19a]. Surprisingly, this simple trick can be shown to guarantee that the recontruction error is never more than $O ( \log K )$ worse than optimal [AV07].

# 21.3.5 The K-medoids algorithm

There is a variant of K-means called K-medoids algorithm, in which we estimate each cluster center $\pmb { \mu } _ { k }$ by choosing the data example $\pmb { x } _ { n } \in \mathcal { X }$ whose average dissimilarity to all other points in that cluster is minimal; such a point is known as a medoid. By contrast, in K-means, we take averages over points ${ \pmb x } _ { n } \in \mathbb { R } ^ { D }$ assigned to the cluster to compute the center. K-medoids can be more robust to

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license outliers (although that issue can also be tackled by using mixtures of Student distributions, instead of mixtures of Gaussians). More importantly, K-medoids can be applied to data that does not live in $\mathbb { R } ^ { D }$ , where averaging may not be well defined. In K-medoids, the input to the algorithm is $N \times N$ pairwise distance matrix, $D ( n , n ^ { \prime } )$ , not an $N \times D$ feature matrix.

The classic algorithm for solving the K-medoids is the partitioning around medoids or PAM method [KR87]. In this approach, at each iteration, we loop over all $K$ medoids. For each medoid $m$ , we consider each non-medoid point $o$ , swap $m$ and $o$ , and recompute the cost (sum of all the distances of points to their medoid). If the cost has decreased, we keep this swap. The running time of this algorithm is $O ( N ^ { 2 } K T )$ , where $T$ is the number of iterations.

There is also a simpler and faster method, known as the Voronoi iteration method due to [PJ09]. In this approach, at each iteration, we have two steps, similar to K-means. First, for each cluster $k$ , look at all the points currently assigned to that cluster, $S _ { k } = \{ n : z _ { n } = k \}$ , and then set $m _ { k }$ to be the index of the medoid of that set. (To find the medoid requires examining all $\vert S _ { k } \vert$ candidate points, and choosing the one that has the smallest sum of distances to all the other points in $S _ { k }$ .) Second, for each point $n$ , assign it to its closest medoid, $z _ { n } = \mathrm { a r g m i n } _ { k } D ( n , k )$ . The pseudo-code is given in Algorithm 12.

<html><body><table><tr><td colspan="2">Algorithm 12:K-medoids algorithm</td></tr><tr><td colspan="2">1 Initialize m1:k as a random subset of size K from {1,.,N}</td></tr><tr><td>2repeat 3</td><td>zn = argmink d(n,mk) for n=1 : N</td></tr><tr><td>4 5 until converged</td><td> mk = argminn:zn=k∑n':zn/=kd(n,n') for k =1 : K</td></tr></table></body></html>

# 21.3.6 Speedup tricks

K-means clustering takes $O ( N K I )$ time, where $I$ is the number of iterations, but we can reduce the constant factors using various tricks. For example, [Elk03] shows how to use the triangle inequality to keep track of lower and upper bounds for the distances between inputs and the centroids; this can be used to eliminate some redundant computations. Another approach is to use a minibatch approximation, as proposed in [Scu10]. This can be significantly faster, although can result in slightly worse loss (see Figure 21.10).

# 21.3.7 Choosing the number of clusters $\pmb { K }$

In this section, we discuss how to choose the number of clusters $K$ in the K-means algorithm and other related methods.

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

![](images/646be142dc3e1476d08b1f99245ae9786130b61e22c89c54536e311c60468eec.jpg)  
Figure 21.10: Illustration of batch vs mini-batch K-means clustering on the 2d data from Figure 21.7. Left: distortion vs $K$ . Right: Training time vs $K$ . Adapted from Figure 9.6 of [Gér19]. Generated by kmeans_minibatch.ipynb.

![](images/1914e77b677849e367d886dd8f2b414a61390fb29f56291927c4d13dff32ed8c.jpg)  
Figure 21.11: Performance of $K$ -means and GMM vs $K$ on the 2d dataset from Figure 21.7. (a) Distortion on validation set vs $K$ . Generated by kmeans_silhouette.ipynb. (b) $B I C$ vs $K$ . Generated by gmm_2d.ipynb. (c) Silhouette score vs $K$ . Generated by kmeans_silhouette.ipynb.

# 21.3.7.1 Minimizing the distortion

Based on our experience with supervised learning, a natural choice for picking $K$ is to pick the value that minimizes the reconstruction error on a validation set, defined as follows:

$$
\mathrm { e r r } ( \mathcal { D } _ { \mathrm { v a l i d } } , K ) = \frac { 1 } { | \mathcal { D } _ { \mathrm { v a l i d } } | } \sum _ { n \in \mathcal { D } _ { \mathrm { v a l i d } } } | | \pmb { x } _ { n } - \hat { \pmb { x } } _ { n } | | _ { 2 } ^ { 2 }
$$

where $\hat { \pmb x } _ { n } = \mathrm { d e c o d e } ( \mathrm { e n c o d e } ( { \pmb x } _ { n } ) )$ is the reconstruction of ${ \boldsymbol { \mathbf { \mathit { x } } } } _ { n }$ .

Unfortunately, this technique will not work. Indeed, as we see in Figure 21.11a, the distortion monotonically decreases with $K$ . To see why, note that the K-means model is a degenerate density model which consists of $K$ “spikes” at the centers. As we increase $K$ , we “cover” more of the input $\pmb { \mu } _ { k }$ space. Hence any given input point is more likely to find a close prototype to accurately represent it as $K$ increases, thus decreasing reconstruction error. Thus unlike with supervised learning, we cannot use reconstruction error on a validation set as a way to select the best unsupervised model. (This comment also applies to picking the dimensionality for PCA, see Section 20.1.4.)

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

# 21.3.7.2 Maximizing the marginal likelihood

A method that does work is to use a proper probabilistic model, such as a GMM, as we describe in Section 21.4.1. We can then use the log marginal likelihood (LML) of the data to perform model selection.

We can approximate the LML using the BIC score as we discussed in Section 5.2.5.1. From Equation (5.59), we have

$$
\mathrm { B I C } ( K ) = \log p ( \mathcal { D } | \hat { \pmb \theta } _ { k } ) - \frac { D _ { K } } { 2 } \log ( N )
$$

where $D _ { K }$ is the number of parameters in a model with $K$ clusters, and $\hat { \pmb { \theta } } _ { K }$ is the MLE. We see from Figure 21.11b that this exhibits the typical U-shaped curve, where the penalty decreases and then increases.

The reason this works is that each cluster is associated with a Gaussian distribution that fills a volume of the input space, rather than being a degenerate spike. Once we have enough clusters to cover the true modes of the distribution, the Bayesian Occam’s razor (Section 5.2.3) kicks in, and starts penalizing the model for being unncessarily complex.

See Section 21.4.1.3 for more discussion of Bayesian model selection for mixture models.

# 21.3.7.3 Silhouette coefficient

In this section, we describe a common heuristic method for picking the number of clusters in a K-means clustering model. This is designed to work for spherical (not elongated) clusters. First we define the silhouette coefficient of an instance $i$ to be $s c ( i ) = ( b _ { i } - a _ { i } ) / \operatorname* { m a x } ( a _ { i } , b _ { i } )$ , where $a _ { i }$ is the mean distance to the other instances in cluster $k _ { i } = \mathrm { a r g m i n } _ { k } \left| \left| \pmb { \mu } _ { k } - \pmb { x } _ { i } \right| \right|$ , and $b _ { i }$ is the mean distance to the other instances in the next closest cluster, $k _ { i } ^ { \prime } = \mathrm { a r g m i n } _ { k \neq k _ { i } } \vert \vert \pmb { \mu } _ { k } - \pmb { x } _ { i } \vert \vert$ . Thus $a _ { i }$ is a measure of compactness of $i$ ’s cluster, and $b _ { i }$ is a measure of distance between the clusters. The silhouette coefficient varies from -1 to $+ 1$ . A value of $+ 1$ means the instance is close to all the members of its cluster, and far from other clusters; a value of 0 means it is close to a cluster boundary; and a value of -1 means it may be in the wrong cluster. We define the silhouette score of a clustering $K$ to be the mean silhouette coefficient over all instances.

In Figure 21.11a, we plot the distortion vs $K$ for the data in Figure 21.7. As we explained above, it goes down monotonically with $K$ . There is a slight “kink” or “elbow” in the curve at $K = 3$ , but this is hard to detect. In Figure 21.11c, we plot the silhouette score vs $K$ . Now we see a more prominent peak at $K = 3$ , although it seems $K = 7$ is almost as good. See Figure 21.12 for a comparison of some of these clusterings.

It can be informative to look at the individual silhouette coefficients, and not just the mean score. We can plot these in a silhouette diagram, as shown in Figure 21.13, where each colored region corresponds to a different cluster. The dotted vertical line is the average coefficient. Clusters with many points to the left of this line are likely to be of low quality. We can also use the silhouette diagram to look at the size of each cluster, even if the data is not 2d.

# 21.3.7.4 Incrementally growing the number of mixture components

An alternative to searching for the best value of $K$ is to incrementally “grow” GMMs. We can start with a small value of $K$ , and after each round of training, we consider splitting the cluster with the

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022 highest mixing weight into two, with the new centroids being random perturbations of the original centroid, and the new scores being half of the old scores. If a new cluster has too small a score, or too narrow a variance, it is removed. We continue in this way until the desired number of clusters is reached. See [FJ02] for details.

![](images/b2b4dbddbe197f9cb67f1c2471844a1d4e92fadba6d76b00c1dd5415ee2d11e2.jpg)  
Figure 21.12: Voronoi diagrams for $K$ -means for different $K$ on the 2d dataset from Figure 21.7. Generated by kmeans_silhouette.ipynb.

# 21.3.7.5 Sparse estimation methods

Another approach is to pick a large value of $K$ , and then to use some kind of sparsity-promoting prior or inference method to “kill off” unneeded mixture components, such as variational Bayes. See the sequel to this book, [Mur23], for details.

# 21.4 Clustering using mixture models

We have seen how the K-means algorithm can be used to cluster data vectors in $\mathbb { R } ^ { D }$ . However, this method assumes that all clusters have the same spherical shape, which is a very restrictive assumption. In addition, K-means assumes that all clusters can be described by Gaussians in the input space, so it cannot be applied to discrete data. By using mixture models (Section 3.5), we can overcome both of these problems, as we illustrate below.

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

![](images/b9ca447899d480489c978c45b36335ee6163f12e3ba5a516c3bb846b9e47ba77.jpg)  
Figure 21.13: Silhouette diagrams for $K .$ -means for different $K$ on the 2d dataset from Figure 21.7. Generated by kmeans_silhouette.ipynb.

# 21.4.1 Mixtures of Gaussians

Recall from Section 3.5.1 that a Gaussian mixture model (GMM) is a model of the form

$$
p ( { \pmb x } | \pmb \theta ) = \sum _ { k = 1 } ^ { K } \pi _ { k } \mathcal { N } ( { \pmb x } | { \pmb \mu } _ { k } , { \pmb \Sigma } _ { k } )
$$

If we know the model parameters $\pmb { \theta } = ( \pi , \{ \pmb { \mu } _ { k } , \pmb { \Sigma } _ { k } \} )$ , we can use Bayes rule to compute the responsibility (posterior membership probability) of cluster $k$ for data point ${ \boldsymbol { \mathbf { \mathit { x } } } } _ { n }$ :

$$
r _ { n k } \triangleq p ( z _ { n } = k | x _ { n } , \pmb \theta ) = \frac { p ( z _ { n } = k | \pmb \theta ) p ( \pmb x _ { n } | z _ { n } = k , \pmb \theta ) } { \sum _ { k ^ { \prime } = 1 } ^ { K } p ( z _ { n } = k ^ { \prime } | \pmb \theta ) p ( \pmb x _ { n } | z _ { n } = k ^ { \prime } , \pmb \theta ) }
$$

Given the responsibilities, we can compute the most probable cluster assignment as follows:

$$
\hat { z } _ { n } = \arg \operatorname* { m a x } _ { k } r _ { n k } = \arg \operatorname* { m a x } _ { k } \left[ \log p ( { \pmb x } _ { n } | z _ { n } = k , \pmb \theta ) + \log p ( z _ { n } = k | \pmb \theta ) \right]
$$

This is known as hard clustering.

# 21.4.1.1 K-means is a special case of EM

We can estimate the parameters of a GMM using the EM algorithm (Section 8.7.3). It turns out that the K-means algorithm is a special case of this algorithm, in which we make two approximations:

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

![](images/ac6576096f22fcf0f81d3eca4b13dde453944e92889c58533bde2dfe1b9eafdc.jpg)  
Figure 21.14: Some data in 2d fit using a GMM with $K = 5$ components. Left column: marginal distribution $p ( { \pmb x } )$ . Right column: visualization of each mixture distribution, and the hard assignment of points to their most likely cluster. (a-b) Full covariance. (c-d) Tied full covariance. (e- $f$ ) Diagonal covairance, (g-h) Spherical covariance. Color coding is arbitrary. Generated by gmm_2d.ipynb.

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license we fix $\boldsymbol { \Sigma } _ { k } = \mathbf { I }$ and $\pi _ { k } = 1 / K$ for all the clusters (so we just have to estimate the means $\pmb { \mu } _ { k }$ ), .a90nd we approximate the $\mathrm { E }$ step, by replacing the soft responsibilities with hard cluster assignments, .i88.e., we compute . $z _ { n } ^ { * } = \mathrm { a r g m a x } _ { k } r _ { n k }$ , and s0e.8t $r _ { n k } \approx \mathbb { I } \left( k = z _ { n } ^ { * } \right)$ i10n0st0e.89ad o20f 0using 93t100he s 0o.9f2t 0r0es0.p93onsibilitie0s, $r _ { n k } = p ( z _ { n } = k | \mathbf { x } _ { n } , \pmb \theta )$ . With this approximation, the weighted MLE problem in Equation (8.165) of the M step reduces to Equation (21.14), so we recover K-means.

![](images/4b2a85eeb5d4756b2ca7da0cd52f3102d66066cbfe98b2a053f7887d86ce665e.jpg)  
Figure 21.15: Some 1d data, with a kernel density estimate superimposed. Adapted from Figure 6.2 of [Mar18]. Generated by gmm_identifiability_pymc3.ipynb.

![](images/c254cf6a8cc19d2da6805c78f2165a2cdf1cfcb608e18c4bbd786d3964fa2ead.jpg)  
Figure 21.16: Illustration of the label switching problem when performing posterior inference for the parame0.t10ers of a GMM. We show a KDE estimate of the poster0i.2o5r marginals derived from 1000 samples from 4 H0.0M8 C chains. (a) Unconstrained model. Posterior is symmetric. (b) Constrained model, where we add a penalty to ensure $\mu _ { 0 } < \mu _ { 1 }$ . Adapt 0e.4d from F0i.6gure 6.6-0.68.7 of [Mar180]. Gen0.0e71r0a0 ted .0b8y g200m0.m09_ide30n0.01t0ifiabil0.i1t14y00_py0.1m2c3.ipynb.0

However, the assumption that all the clusters have the same spherical shape is very restrictive. For example, Figure 21.14 shows the marginal density and clustering induced using different shaped covariance matrices for some 2d data. We see that modeling this particular dataset needs the ability to capture off-diagonal covariance for some clusters (top row).

# 21.4.1.2 Unidentifiability and label switching

Note that we are free to permute the labels in a mixture model without changing the likelihood. This is called the label switching problem, and is an example of non-identifiability of the parameters.

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

This can cause problems if we wish to perform posterior inference over the parameters (as opposed to just computing the MLE or a MAP estimate). For example, suppose we fit a GMM with $K = 2$ components to the data in Figure 21.15 using HMC. The posterior over the means, $p ( \mu _ { 1 } , \mu _ { 2 } | \mathcal { D } )$ , is shown in Figure 21.16a. We see that the marginal posterior for each component, $p ( \mu _ { k } \vert \mathcal { D } )$ , is bimodal. This reflects the fact that there are two equally good explanations of the data: either $\mu _ { 1 } \approx 4 7$ and $\mu _ { 2 } \approx 5 7$ , or vice versa.

To break symmetry, we can add an ordering constraint on the centers, so that $\mu _ { 1 } < \mu _ { 2 }$ . We can do this by adding a penalty or potential function to the objective if the penalty is violated. More precisely, the penalized log joint becomes

$$
\ell ^ { \prime } ( \pmb { \theta } ) = \log p ( \mathcal { D } | \pmb { \theta } ) + \log p ( \pmb { \theta } ) + \phi ( \pmb { \mu } )
$$

where

$$
\phi ( \pmb { \mu } ) = \left\{ { \begin{array} { l l } { - \infty } & { \mathrm { i f ~ } \mu _ { 1 } < \mu _ { 0 } } \\ { 0 } & { \mathrm { o t h e r w i s e } } \end{array} } \right.
$$

This has the desired effect, as shown in Figure 21.16b.

A more general approach is to apply a transformation to the parameters, to ensure identifiability. That is, we sample the parameters $\pmb \theta$ from a proposal, and then apply an invertible transformation $\theta ^ { \prime } = f ( \theta )$ to them before computing the log joint, $\log p ( \mathcal { D } , \pmb \theta ^ { \prime } )$ . To account for the change of variables (Section 2.8.3), we add the log of the determinant of the Jacobian. In the case of a 1d ordering transformation, which just sorts its inputs, the determinant of the Jacobian is 1, so the log-det-Jacobian term vanishes.

Unfortunately, this approach does not scale to more than 1 dimensional problems, because there is no obvious way to enforce an ordering constraint on the centers $\pmb { \mu } _ { k }$ .

# 21.4.1.3 Bayesian model selection

Once we have a reliable way to ensure identifiability, we can use Bayesian model selection techniques from Section 5.2.2 to select the number of clusters $K$ . In Figure 21.17, we illustrate the results of fitting a GMM with $K = 3 - 6$ components to the data in Figure 21.15. We use the ordering transform on the means, and perform inference using HMC. We compare the resulting GMM model fits to the fit of a kernel density estimate (Section 16.3), which often over-smooths the data. We see fairly strong evidence for two bumps, corresponding to different subpopulations.

We can compare these models more quantitatively by computing their WAIC scores (widely applicable information criterion) which is an approximation to the log marginal likelihood (see [Wat10; Wat13; VGG17] for details). The results are shown in Figure 21.18. (This kind of visualization was proposed in [McE20, p228].) We see that the model with $K = 6$ scores significantly higher than for the other models, although $K = 5$ is a close second. This is consistent with the plot in Figure 21.17.

# 21.4.2 Mixtures of Bernoullis

As we discussed in Section 3.5.2, we can use a mixtures of Bernoullis to cluster binary data. The model has the form

$$
p ( \pmb { y } | \boldsymbol { z } = \boldsymbol { k } , \pmb { \theta } ) = \prod _ { d = 1 } ^ { D } \mathrm { B e r } ( y _ { d } | \mu _ { d k } ) = \prod _ { d = 1 } ^ { D } \mu _ { d k } ^ { y _ { d } } ( 1 - \mu _ { d k } ) ^ { 1 - y _ { d } }
$$

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

![](images/7b5c27acd0adad2491416d14a719ff0f3ea99f6dcdbfcaa6004e0719d5836d0b.jpg)  
Figure 21.17: Fitting GMMs with different numbers of clusters $K$ to the data in Figure 21.15. Black solid line is KDE fit. Solid blue line is posterior mean; feint blue lines are posterior samples. Dotted lines show the individual Gaussian mixture components, evaluated by plugging in their posterior mean parameters. Adapted from Figure 6.8 of [Mar18]. Generated by gmm_chooseK_pymc3.ipynb.

Here is the probability that bit $d$ turns on in cluster $k$ . We can fit this model with EM, SGD, $\mu _ { d k }$ MCMC, etc. See Figure 3.13 for an example, where we cluster some binarized MNIST digits.

# 21.5 Spectral clustering \*

In this section, we discuss an approach to clustering based on eigenvalue analysis of a pairwise similarity matrix. It uses the eigenvectors to derive feature vectors for each datapoint, which are then clustered using a feature-based clustering method, such as K-means (Section 21.3). This is known as spectral clustering [SM00; Lux07].

# 21.5.1 Normalized cuts

We start by creating a weighted undirected graph W, where each data vector is a node, and the strength of the $i - j$ edge is a measure of similarity. Typically we only connected a node to its most similar neighbors, to ensure the graph is sparse, which speeds computation.

Our goal is to find $K$ clusters of similar points. That is, we want to find a graph partition into $S _ { 1 } , \ldots , S _ { K }$ disjoint sets of nodes so as to minimize some kind of cost.

Our first attempt at a cost function is to compute the weight of connections between nodes in each cluster to nodes outside each cluster:

$$
\operatorname { c u t } ( S _ { 1 } , \ldots , S _ { K } ) \triangleq { \frac { 1 } { 2 } } \sum _ { k = 1 } ^ { K } W ( S _ { k } , { \overline { { S } } } _ { k } )
$$

where $\begin{array} { r } { W ( A , B ) \triangleq \sum _ { i \in A , j \in B } w _ { i j } } \end{array}$ and ${ \overline { { S } } } _ { k } = V \setminus S _ { k }$ is the complement of $S _ { k }$ , where $V = \{ 1 , \ldots , N \}$ . Unfortunately the optimal solution to this often just partitions off a single node from the rest, since that minimizes the weight of the cut. To prevent this, we can divide by the size of each set, to

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

![](images/e0a0a3b48b5d2dca58cbce4f0b07fd928c7d3c8b0b471d7c887b5cc58f012545.jpg)  
Figure 21.18: WAIC scores for the different GMMs. The empty circle is the posterior mean WAIC score for each model, and the black lines represent the standard error of the mean. The solid circle is the in-sample deviance of each model, i.e., the unpenalized log-likelihood. The dashed vertical line corresponds to the maximum WAIC value. The gray triangle is the difference in WAIC score for that model compared to the best model. Adapted from Figure 6.10 of [Mar18]. Generated by gmm_chooseK_pymc3.ipynb.

get the following objective, known as the normalized cut:

$$
\operatorname { N c u t } ( S _ { 1 } , \ldots , S _ { K } ) \triangleq { \frac { 1 } { 2 } } \sum _ { k = 1 } ^ { K } { \frac { \operatorname { c u t } ( S _ { k } , { \overline { { S } } } _ { k } ) } { \operatorname { v o l } ( S _ { k } ) } }
$$

nwohdeer $\operatorname { v o l } ( A ) \triangleq \textstyle \sum _ { i \in A } d _ { i }$ aisphthientto clwuesitgehrts osfucshet $A$ atanod $\begin{array} { r } { d _ { i } = \sum _ { j = 1 } ^ { N } w _ { i j } } \end{array}$ cilsutshterwaeriegshitmeidladretgoreeacohf $i$ $K$   
other, but are different to nodes in other clusters.

We can formulate the Ncut problem in terms of searching for binary vectors $\pmb { c } _ { i } \in \{ 0 , 1 \} ^ { N }$ that minimizes the above objective, where $c _ { i k } = 1$ iff point $i$ belongs to cluster $k$ . Unfortunately this is NP-hard [WW93]. Below we discuss a continuous relaxation of the problem based on eigenvector methods that is easier to solve.

# 21.5.2 Eigenvectors of the graph Laplacian encode the clustering

In Section 20.4.9.2, we discussed the graph Laplacian, which is defined as $\mathbf { L } \triangleq \mathbf { D } - \mathbf { W }$ , where W is a symmetric weight matrix for the graph, and $\mathbf { D } = \mathrm { d i a g } ( d _ { i } )$ is a diagonal matrix containing the weighted degree of each node, $d _ { i } = \sum _ { j } w _ { i j }$ . To get some intuition as to why $\mathbf { L }$ might be useful for graph-based clustering, we note the following result.

Theorem 21.5.1. The set of eigenvectors of $\mathbf { L }$ with eigenvalue 0 is spanned by the indicator vectors $\mathbf { 1 } _ { S _ { 1 } } , \dotsc , \mathbf { 1 } _ { S _ { K } }$ , where $S _ { k }$ are the $K$ connected components of the graph.

Proof. Let us start with the case $K = 1$ . If $f$ is an eigenvector with eigenvalue 0, then $0 =$ $\begin{array} { r } { \sum _ { i j } w _ { i j } ( f _ { i } - f _ { j } ) ^ { 2 } } \end{array}$ . If two nodes are connected, so $w _ { i j } > 0$ , we must have that $f _ { i } = f _ { j }$ . Hence $f$ is constant for all vertices which are connected by a path in the graph. Now suppose $K > 1$ . In this

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license case, $\mathbf { L }$ will be block diagonal. A similar argument to the above shows that we will have $K$ indicator functions, which “select out” the connected components. □

![](images/4c995903310a4875a9cc844c722389af420ecb9a2f6218de54303b46da668f12.jpg)  
Figure 21.19: Results of clustering some data. (a) K-means. (b) Spectral clustering. Generated by spectral_clustering_demo.ipynb.

This suggests the following clustering algorithm. Compute the eigenvectors and values of $\mathbf { L }$ , and let $\mathbf { U }$ be an $N \times K$ matrix with the $K$ eigenvectors with smallest eigenvalue in its columns. (Fast methods for computing such “bottom” eigenvectors are discussed in [YHJ09]). Let $\pmb { u } _ { i } \in \mathbb { R } ^ { K }$ be the i’th row of U. Since these ${ \pmb u } _ { i }$ will be piecewise constant, we can apply K-means clustering (Section 21.3) to them to recover the connected components. (Note that the vectors ${ \pmb u } _ { i }$ are the same as those computed by Laplacian eigenmaps discussed in Section 20.4.9.)

Real data may not exhibit such clean block structure, but one can show, using results from perturbation theory, that the eigenvectors of a “perturbed” Laplacian will be close to these ideal indicator functions [NJW01].

In practice, it is important to normalize the graph Laplacian, to account for the fact that some nodes are more highly connected than others. One way to do this (proposed in [NJW01]) is to create a symmetric matrix

$$
\mathbf { L } _ { s y m } \triangleq \mathbf { D } ^ { - \frac { 1 } { 2 } } \mathbf { L } \mathbf { D } ^ { - \frac { 1 } { 2 } } = \mathbf { I } - \mathbf { D } ^ { - \frac { 1 } { 2 } } \mathbf { W } \mathbf { D } ^ { - \frac { 1 } { 2 } }
$$

This time the eigenspace of $0$ is spanned by $\mathbf { D } ^ { \frac { 1 } { 2 } } \mathbf { 1 } _ { S _ { k } }$ . This suggests the following algorithm: find the smallest $K$ eigenvectors of $\mathbf { L } _ { \boldsymbol { s y m } }$ , stack them into the matrix $\mathbf { U }$ , normalize each row to unit norm by creating $t _ { i j } = u _ { i j } / \sqrt { ( \sum _ { k } u _ { i k } ^ { 2 } ) }$ to make the matrix $\mathbf { T }$ , cluster the rows of $\mathbf { T }$ using K-means, then infer the partitioning of the original points.

# 21.5.3 Example

Figure 21.19 illustrates the method in action. In Figure 21.19(a), we see that K-means does a poor job of clustering, since it implicitly assumes each cluster corresponds to a spherical Gaussian. Next we try spectral clustering. We compute a dense similarity matrix W using a Gaussian kernel,

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

$\begin{array} { r } { W _ { i j } = \exp \bigl ( { - \frac { 1 } { 2 \sigma ^ { 2 } } | | \pmb { x } _ { i } - \pmb { x } _ { j } | | _ { 2 } ^ { 2 } } \bigr ) } \end{array}$ . We then compute the first two eigenvectors of the normalized Laplacian $L _ { \mathrm { s y m } }$ . From this we infer the clustering using K-means, with $K = 2$ ; the results are shown in Figure 21.19(b).

# 21.5.4 Connection with other methods

Spectral clustering is closely related to several other methods for unsupervised learning, some of which we discuss below.

# 21.5.4.1 Connection with kPCA

Spectral clustering is closely related to kernel PCA (Section 20.4.6). In particular, kPCA uses the largest eigenvectors of $\mathbf { W }$ ; these are equivalent to the smallest eigenvectors of $\mathbf { I } - \mathbf { W }$ . This is similar to the above method, which computes the smallest eigenvectors of $\mathbf { L } = \mathbf { D } - \mathbf { W }$ . See [Ben+04a] for details. In practice, spectral clustering tends to give better results than kPCA.

# 21.5.4.2 Connection with random walk analysis

In practice we get better results by computing the eigenvectors of the normalized graph Laplacian. One way to normalize the graph Laplacian, which is used in [SM00; Mei01], is to define

$$
\mathbf { L } _ { r w } \triangleq \mathbf { D } ^ { - 1 } \mathbf { L } = \mathbf { I } - \mathbf { D } ^ { - 1 } \mathbf { W }
$$

One can show that for $\mathbf { L } _ { r w }$ , the eigenspace of $0$ is again spanned by the indicator vectors $\mathbf { 1 } _ { S _ { k } }$ [Lux07], so we can perform clustering directly on the $K$ smallest eigenvectors $\mathbf { U }$ .

There is an interesting connection between this approach and random walks on a graph. First note that ${ \mathbf { P } } = { \mathbf { D } } ^ { - 1 } { \mathbf { W } } = { \mathbf { I } } - { \mathbf { L } } _ { r w }$ is a stochastic matrix, where $p _ { i j } = w _ { i j } / d _ { i }$ can be interpreted as the probability of going from $i$ to $j$ . If the graph is connected and non-bipartite, it possesses a unique stationary distribution $\pmb { \pi } = ( \pmb { \pi } _ { 1 } , \ldots , \pmb { \pi } _ { N } )$ , where $\pi _ { i } = d _ { i } / \mathrm { v o l } ( V )$ , and $\operatorname { v o l } ( V ) = \textstyle \sum _ { i } d _ { i }$ is the sum of all the node degrees. Furthermore, one can show that for a partition of size 2,

$$
\mathrm { N c u t } ( S , { \overline { { S } } } ) = p ( { \overline { { S } } } | S ) + p ( S | { \overline { { S } } } )
$$

This means that we are looking for a cut such that a random walk spends more time transitioning to similar points, and rarely makes transitions from $S$ to $\overline { S }$ or vice versa. This analysis can be extended to $K > 2$ ; for details, see [Mei01].

# 21.6 Biclustering \*

In some cases, we have a data matrix $\mathbf { X } \in \mathbb { R } ^ { N _ { r } \times N _ { c } }$ and we want to cluster the rows and the columns; this is known as biclustering or coclustering. This is widely used in bioinformatics, where the rows often represent genes and the columns represent conditions. It can also be used for collaborative filtering, where the rows represent users and the columns represent movies.

A variety of ad hoc methods for biclustering have been proposed; see [MO04] for a review. In Section 21.6.1, we present a simple probabilistic generative model in which we assign a latent cluster id to each row, and a differnet latent cluster id to each column. In Section 21.6.2, we extend this to the case where each row can belong to multiple clusters, depending on which groups of features (columns) we choose to use to define the different groups of objects (rows).

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

O1 killer whale, blue whale, humpback, seal, walrus, dolphin   
O2 antelope, horse, giraffe, zebra, deer   
O3 monkey, gorilla, chimp   
O4 hippo, elephant, rhino   
O5 grizzly bear, polar bear   
F1 flippers, strain teeth, swims, arctic, coastal, ocean, water   
F2 hooves, long neck, horns   
F3 hands, bipedal, jungle, tree   
F4 bulbous body shape, slow, inactive   
F5 meat teeth, eats meat, hunter, fierce   
F6 walks, quadrapedal, ground

O1  
O2  
O3  
O4  
O5   
中

# 21.6.1 Basic biclustering

Here we present a simple probabilistic generative model for biclustering based on [Kem+06] (see also [SMM03] for a related approach). The idea is to associate each row and each column with a latent indicator, $u _ { i } \in \{ 1 , \ldots , N _ { u } \}$ , $v _ { j } \in \{ 1 , \ldots , N _ { v } \}$ , where $N _ { u }$ is the number of row clusters, and $N _ { v }$ is the number of column clusters. We then use the following generative model:

$$
\begin{array} { c } { { \displaystyle p ( { \bf U } ) = \prod _ { i = 1 } ^ { N _ { r } } \mathrm { U n i f } ( u _ { i } | \{ { { \bf 1 } } , \dots , N _ { u } \} ) } } \\ { { \displaystyle p ( { \bf V } ) = \prod _ { j = 1 } ^ { N _ { c } } \mathrm { C a t } ( v _ { j } | \{ { { \bf 1 } } , \dots , N _ { v } \} ) } } \\ { { \displaystyle p ( { \bf X } | { \bf U } , { \bf V } , \theta ) = \prod _ { i = 1 } ^ { N _ { r } } \prod _ { j = 1 } ^ { N _ { c } } p ( X _ { i j } | \theta _ { u _ { i } , v _ { j } } ) } } \end{array}
$$

where $\theta _ { a , b }$ are the parameters for row cluster $a$ and column cluster $b$ .

Figure 21.20 shows a simple example. The data has the form $X _ { i j } = 1$ iff animal $i$ has feature $j$ , where $i ~ = ~ 1 : ~ 5 0$ and $j ~ = ~ 1 ~ : ~ 8 5$ . The animals represent whales, bears, horses, etc. The features represent properties of the habitat (jungle, tree, coastal), or anatomical properties (has teeth, quadripedal), or behavioral properties (swims, eats meat), etc. The method discovered 12 animal clusters and 33 feature clusters. ([Kem+06] use a Bayesian nonparametric method to infer the number of clusters.) For example, the O2 cluster is $\{$ { antelope, horse, giraffe, zebra, deer $\}$ , which is characterized by feature clusters $\mathrm { F 2 } = \left\{ \begin{array} { r l r l } \end{array} \right.$ { hooves, long neck, horns} and ${ \mathrm { F 6 } } = \left\{ \begin{array} { r l r l } \end{array} \right.$ { walks, quadripedal, ground $\}$ , whereas the O4 cluster is $\{$ { hippo, elephant, rhino $\}$ , which is characterized by feature clusters $\mathrm { F 4 } = \left\{ \begin{array} { r l r } \end{array} \right.$ bulbous body shape, slow, inactive $\}$ and F6.

# 21.6.2 Nested partition models (Crosscat)

The problem with basic biclustering (Section 21.6.1) is that each object (row) can only belong to one cluster. Intuitively, an object can have multiple roles, and can be assigned to different clusters depending on which subset of features you use. For example, in the animal dataset, we may want to group the animals on the basis of anatomical features (e.g., mammals are warm blooded, reptiles are

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022 not), or on the basis of behavioral features (e.g., predators vs prey).

![](images/c1cf45e348ff461d390e315da542423f0d1901bd42172a6e53881c830de99827.jpg)  
Figure 21.21: (a) Example of biclustering. Each row is assigned to a unique cluster, and each column is assigned to a unique cluster. (b) Example of multi-clustering using a nested partition model. The rows can belong to different clusters depending on which subset of column features we are looking at.

We now present a model that can capture this phenomenon. We illustrate the method with an example. Suppose we have a $6 \times 6$ matrix, with $N _ { u } = 2$ row clusters and $N _ { v } = 3$ column clusters. Furthermore, suppose the latent column assignments are as follows: $\pmb { v } = [ 1 , 1 , 2 , 3 , 3 , 3 ]$ . This means we put columns 1 and 2 into group 1, column 3 into group 2, and columns 4 to 6 into group 3. For the columns that get clustered into group 1, we cluster the rows as follows: $\pmb { u } _ { : , 1 } = [ 1 , 1 , 1 , 2 , 2 , 2 ]$ ; For the columns that get clustered into group 2, we cluster the rows as follows: $\pmb { u } _ { : , 2 } = [ 1 , 1 , 2 , 2 , 2 , 2 ]$ ; and for the columns that get clustered into group 3, we cluster the rows as follows: $\pmb { u } _ { : , 3 } = \left[ 1 , 1 , 1 , 1 , 1 , 2 \right]$ . The resulting partition is shown in Figure 21.21(b). We see that the clustering of the rows depends on which group of columns we choose to focus on.

Formally, we can define the model as follows:

$$
\begin{array} { l } { { \displaystyle p ( { \bf U } ) = \prod _ { i = 1 } ^ { N _ { \epsilon } } \prod _ { l = 1 } ^ { N _ { \epsilon } } \mathrm { [ u n i f } ( u _ { i } | \{ { { \bf 1 } } , \dots , N _ { u } \} ) } } \\ { { \displaystyle p ( { \bf V } ) = \prod _ { j = 1 } ^ { N _ { \epsilon } } \mathrm { [ u n i f } ( v _ { j } | \{ { { \bf 1 } } , \dots , N _ { v } \} ) } } \\ { { \displaystyle p ( { \bf Z } | { \bf U } , { \bf V } ) = \prod _ { i = 1 } ^ { N _ { \epsilon } } \prod _ { j = 1 } ^ { N _ { c } } \mathbb { I } \left( { \bf \Psi } _ { { Z } _ { i j } } = ( u _ { i , n _ { j } } , v _ { j } ) \right) } } \\ { { \displaystyle p ( { \bf X } | { \bf Z } , \theta ) = \prod _ { i = 1 } ^ { N _ { \epsilon } } \prod _ { j = 1 } ^ { N _ { c } } p ( X _ { i j } | \theta _ { s _ { 3 } } ) } } \end{array}
$$

where $\theta _ { k , l }$ are the parameters for cocluster $k \in \{ 1 , \ldots , N _ { u } \}$ and $l \in \{ 1 , \ldots , N _ { v } \}$ .

This model was independently proposed in [Sha+06; Man+16] who call it crosscat (for crosscategorization), in [Gua+10; CFD10], who call it multi-clust, and in [RG11], who call it nested partitioning. In all of these papers, the authors propose to use Dirichlet processes, to avoid the problem of estimating the number of clusters. Here we assume the number of clusters is known, and show the parameters explicitly, for notational simplicity.

Figure 21.22 illustrates the model applied to some binary data containing 22 animals and 106 features. The figure shows the (approximate) MAP partition. The first partition of the columns contains taxonomic features, such as “has bones”, “is warm-blooded”, “lays eggs”, etc. This divides the

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

A B C Leopard Leopard Sheep Alligator Seal Python Dolphin Seal Monkey Dolphin Bat Frog Alligator Jellyfish Iguana Octopus Frog Penguin Python Finch Finch Seagull Ostrich Owl Seagull Eagle Owl Dragonfly Penguin Bat Eagle Grasshopper Grasshopper Ant Ant Bee Bee Sheep Jellyfish Frog Monkey Octopus Iguana Dragonfly ■ Ostrich 聘野畔 谢盟 animals into birds, reptiles/ amphibians, mammals, and invertebrates. The second partition of the columns contains features that are treated as noise, with no apparent structure (except for the single row labeled “frog”). The third partition of the columns contains ecological features like “dangerous”, “carnivorous”, “lives in water”, etc. This divides the animals into prey, land predators, sea predators and air predators. Thus each animal (row) can belong to a different cluster depending on what set of features are considered.

# 22 Recommender Systems

Recommender systems are systems which recommend items (such as movies, books, ads) to users based on various information, such as their past viewing/ purchasing behavior (e.g., which movies they rated high or low, which ads they clicked on), as well as optional “side information” such as demographics about the user, or information about the content of the item (e.g., its title, genre or price). Such systems are widely used by various internet companies, such as Facebook, Amazon, Netflix, Google, etc. In this chapter, we give a brief introduction to the topic. More details can be found in e.g., [DKK12; Pat12; Yan+14; AC16; Agg16; Zha+19b]..

# 22.1 Explicit feedback

In this section, we consider the simplest setting in which the user gives explicit feedback to the system in terms of a rating, such as $+ 1$ or -1 (for like/dislike) or a score from 1 to 5. Let $Y _ { u i } \in \mathbb { R }$ be the rating that user $u$ gives to item $i$ . We can represent this as an $M \times N$ matrix, where $M$ is the number of users, and $N$ is the number of items. Typically this matrix will be very large but very sparse, since most users will not provide any feedback on most items. See Figure 22.1(a) for an example. We can also view this sparse matrix as a bipartite graph, where the weight of the $u - i$ edge is $Y _ { u i }$ . This reflects the fact that we are dealing with relational data, i.e., the values of $u$ and $i$ have no intrinsic meaning (they are just arbitrary indices), it is the fact that $u$ and $i$ are connected that matters.

If $Y _ { u i }$ is missing, it could be because user $u$ has not interacted with item $i$ , or it could be that they knew they wouldn’t like it and so they chose not to engage with it. In the former case, some of the data is missing at random; in the latter case, the missingness is informative about the true value of $Y _ { u i }$ . (See e.g., [Mar+11] for further discussion of this point.) We will assume the data is missing at random, for simplicity.

# 22.1.1 Datasets

A famous example of an explicit ratings matrix was made available by the movie streaming company Netflix. In 2006, they released a large dataset of 100,480,507 movie ratings (on a scale of 1 to 5) from 480,189 users of 17,770 movies. Despite the large size of the training set, the ratings matrix is still $9 9 \%$ sparse (unknown). Along with the data, they offered a prize of $\$ 100,000$ , known as the Netflix Prize, to any team that could predict the true ratings of a set of test (user, item) pairs more accurately than their incumbent system. The prize was claimed on September 21, 2009 by a team known as “Pragmatic Chaos”. They used an ensemble of different methods, as described in [Kor09; BK07; FHK12]. However, a key component in their ensemble was the method described in Section 22.1.3.

![](images/966a27c1f391b7021ea5a91627504667a34798ecfec6d5433010aee8f157dee6.jpg)  
Figure 22.1: Example of a relational dataset represented as a sparse matrix (left) or a sparse bipartite graph (right). Values corresponding to empty cells (missing edges) are unknown. Rows 3 and 4 are similar to each other, indicating that users 3 and 4 might have similar preferences, so we can use the data from user 3 to predict user 4’s preferences. However, user 1 seems quite different in their preferences, and seems to give low ratings to all items. For user 2, we have very little observed data, so it is hard to make reliable predictions.

Unfortunately the Netflix data is no longer available due to privacy concerns. Fortunately the MovieLens group at the University of Minnesota have released an anonymized public dataset of movie ratings, on a scale of 1-5, that can be used for research [HK15]. There are also various other public explicit ratings datasets, such as the Jester jokes dataset from [Gol+01] and the BookCrossing dataset from [Zie+05].

# 22.1.2 Collaborative filtering

The original approach to the recommendation problem is called collaborative filtering [Gol+92]. The idea is that users collaborate on recommending items by sharing their ratings with other users; then if $u$ wants to know if they interact with $i$ , they can see what ratings other users $u ^ { \prime }$ have given to $i$ , and take a weighted average:

$$
\hat { Y } _ { u i } = \sum _ { u ^ { \prime } : Y _ { u ^ { \prime } , i } \neq ? } \sin ( u , u ^ { \prime } ) \ : Y _ { u ^ { \prime } , i }
$$

where we assume $Y _ { u ^ { \prime } , i } =$ ? if the entry is unknown. The traditional approach measured the similarity of two users by comparing the sets $S _ { u } = \{ Y _ { u , i } \neq ? : i \in \mathcal { I } \}$ and $S _ { u ^ { \prime } } = \{ Y _ { u ^ { \prime } , i } \neq ? : i \in \mathcal { T } \}$ , where $\mathcal { T }$ is the set of items. However, this can suffer from data sparsity. In Section 22.1.3 we discuss an approach based on learning dense embedding vectors for each item and each user, so we can compute similarity in a low dimensional feature space.

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

# 22.1.3 Matrix factorization

We can view the recommender problem as one of matrix completion, in which we wish to predict all the missing entries of $\mathbf { Y }$ . We can formulate this as the following optimization problem:

$$
\mathcal { L } ( \mathbf { Z } ) = \sum _ { i j : Y _ { i j } \neq ? } ( Z _ { i j } - Y _ { i j } ) ^ { 2 } = | | \mathbf { Z } - \mathbf { Y } | | _ { F } ^ { 2 }
$$

However, this is an under-specified problem, since there are an infinite number of ways of filling in the missing entries of $\mathbf { Z }$ .

We need to add some constraints. Suppose we assume that $\mathbf { Y }$ is low rank. Then we can write it in the form $\mathbf { Z } = \mathbf { U } \mathbf { V } ^ { \parallel } \approx \mathbf { Y }$ , where $\mathbf { U }$ is an $M \times K$ matrix, $\mathbf { V }$ is a $N \times K$ matrix, $K$ is the rank of the matrix, $M$ is the number of users, and $N$ is the number of items. This corresponds to a prediction of the form by writing

$$
\hat { y } _ { u i } = \pmb { u } _ { u } ^ { \top } \pmb { v } _ { i }
$$

This is called matrix factorization.

If we observe all the $Y _ { i j }$ entries, we can find the optimal $\mathbf { Z }$ using SVD (Section 7.5). However, when $\mathbf { Y }$ has missing entries, the corresponding objective is no longer convex, and does not have a unique optimum [SJ03]. We can fit this using alternating least squares (ALS), where we estimate $\mathbf { U }$ given $\mathbf { V }$ and then estimate $\mathbf { V }$ given $\mathbf { U }$ (for details, see e.g., [KBV09]). Alternatively we can just use SGD.

In practice, it is important to also allow for user-specific and item-specific baselines, by writing

$$
\hat { y } _ { u i } = \mu + b _ { u } + c _ { i } + \pmb { u } _ { u } ^ { \top } \pmb { v } _ { i }
$$

This can capture the fact that some users might always tend to give low ratings and others may give high ratings; in addition, some items (e.g., very popular movies) might have unusually high ratings. In addition, we can add some $\ell _ { 2 }$ regularization to the parameters to get the objective

$$
\mathcal { L } ( \pmb { \theta } ) = \sum _ { i j : Y _ { i j } \neq \uparrow } ( y _ { i j } - \hat { y } _ { i j } ) ^ { 2 } + \lambda ( b _ { u } ^ { 2 } + c _ { i } ^ { 2 } + | | \pmb { u } _ { u } | | ^ { 2 } + | | \pmb { v } _ { i } | | ^ { 2 } )
$$

We can optimize this using SGD by sampling a random $( u , i )$ entry from the set of observed values, and performing the following updates:

$$
\begin{array} { r l } & { b _ { u } = b _ { u } + \eta ( e _ { u i } - \lambda b _ { u } ) } \\ & { ~ c _ { i } = c _ { i } + \eta ( e _ { u i } - \lambda c _ { i } ) } \\ & { ~ { \pmb u } _ { u } = { \pmb u } _ { u } + \eta ( e _ { u i } { \pmb v } _ { i } - \lambda { \pmb u } _ { u } ) } \\ & { ~ { \pmb v } _ { i } = { \pmb v } _ { i } + \eta ( e _ { u i } { \pmb u } _ { u } - \lambda { \pmb v } _ { i } ) } \end{array}
$$

where $e _ { u i } = y _ { u i } - { \hat { y } } _ { u i }$ is the error term, and $\eta \geq 0$ is the learning rate. This approach was first proposed by Simon Funk, who was one of the first to do well in the early days of the Netflix competition.1

![](images/74440e1c218af122568aa2fe2aff18c457c0a085e0e86c0f6f1dac9e2d1c9475.jpg)  
Figure 22.2: Visualization of the first two latent movie factors estimated from the Netflix challenge data. Each movie j is plotted at the location specified by $\boldsymbol { v } _ { j }$ . See text for details. From Figure 3 of [KBV09]. Used with kind permission of Yehuda Koren.

# 22.1.3.1 Probabilistic matrix factorization (PMF)

We can convert matrix factorization into a probabilistic model by defining

$$
p ( y _ { u i } = y ) = N ( y | \mu + b _ { u } + c _ { i } + \pmb { u } _ { u } ^ { \top } \pmb { v } _ { i } , \sigma ^ { 2 } )
$$

This is known as probabilistic matrix factorization (PMF) [SM08]. The NLL of this model is equivalent to the matrix factorization objective in Equation (22.2). However, the probabilistic perspective allows us to generalize the model more easily. For example, we can capture the fact that the ratings are integers (often mostly 0s), and not reals, using a Poisson or negative Binomial likelihood (see e.g., [GOF18]). This is similar to exponential family PCA (Section 20.2.7), except that we view rows and columns symmetrically.

# 22.1.3.2 Example: Netflix

Suppose we apply PMF to the Netflix dataset using $K = 2$ latent factors. Figure 22.2 visualizes the learned embedding vectors $\mathbf { \Delta } \mathbf { u } _ { i }$ for a few movies. On the left of the plot we have low-brow humor and horror movies (Half Baked, Freddy vs Jason), and on the right we have more serious dramas (Sophie’s Choice, Moonstruck). On the top we have critically acclaimed independent movies (Punch-Drunk Love, I Heart Huckabees), and on the bottom we have mainstream Hollywood blockbusters (Armageddon, Runway Bride). The Wizard of $O z$ is right in the middle of these axes, since it is in some senses an “average movie”.

Users are embedded into the same spaces as movies. We can then predict the rating for any user-video pair using proximity in the latent embedding space.

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

![](images/ac3a3bc6b0144cd806271ca667ef0730521b5e8ba9046959adb645cf9bdcb3c4.jpg)  
Figure 22.3: (a) A fragment of the observed ratings matrix from the MovieLens-1M dataset. (b) Predictions using SVD with 50 latent components. Generated by matrix_factorization_recommender.ipynb.

# 22.1.3.3 Example: MovieLens

Now suppose we apply PMF to the MovieLens-1M dataset with 6040 users, 3706 movies, and 1,000,209 ratings. We will use $K = 5 0$ factors. For simplicity, we fit this using SVD applied to the dense ratings matrix, where we replace missing values with 0. (This is just a simple approximation to keep the demo code simple.) In Figure 22.3 we show a snippet of the true and predicted ratings matrix. (We truncate the predictions to lie in the range [1,5].) We see that the model is not particularly accurate, but does capture some structure in the data.

Furthermore, it seems to behave in a qualitatively sensible way. For example, in Figure 22.4 we show the top 10 movies rated by a given user as well as the top 10 predictions for movies they had not seen. The model seems to have “picked up” on the underlying preferences of the user. For example, we see that many of the predicted movies are action or film-noir, and both of these genres feature in the user’s own top-10 list, even though explicit genre information is not used during model training.

# 22.1.4 Autoencoders

Matrix factorization is a (bi)linear model. We can make a nonlinear version using autoencoders. Let $\pmb { y } _ { : , i } \in \mathbb { R } ^ { M }$ be the $i$ ’th column of the ratings matrix, where unknown ratings are set to $0$ . We can predict this ratings vector using an autoencoder of the form

$$
f ( \pmb { y } _ { : , i } ; \pmb { \theta } ) = \mathbf { W } ^ { \top } \boldsymbol { \varphi } ( \mathbf { V } \pmb { y } _ { : , i } + \pmb { \mu } ) + \pmb { b }
$$

where $\mathbf { V } \in \mathbb { R } ^ { K M }$ maps the ratings to an embedding space, $\mathbf { W } \in \mathbb { R } ^ { K M }$ maps the embedding space to a distribution over ratings, $\pmb { \mu } \in \mathbb { R } ^ { K }$ are the biases of the hidden units, and $\pmb { b } \in \mathbb { R } ^ { M }$ are the biases of the output units. This is called the (item-based) version of the AutoRec model [Sed+15]. This has $2 M K + M + K$ parameters. There is also a user-based version, that can be derived in a similar manner, which has $2 N K + N + K$ parameters. (On MovieLens and Netflix, the authors find that the item-based method works better.)

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

<html><body><table><tr><td colspan="2">MovieID</td><td>Title</td><td>Genres</td></tr><tr><td>36</td><td>858</td><td>Godfather, The (1972)</td><td>Action|Crime|Drama</td></tr><tr><td>35</td><td>1387</td><td>Jaws (1975)</td><td>Action|Horror</td></tr><tr><td>65</td><td>2028</td><td>Saving Private Ryan (1998)</td><td>Action|Drama/War</td></tr><tr><td>63</td><td>1221</td><td>Godfather: Part II, The (1974)</td><td>Action|Crime|Drama</td></tr><tr><td>11</td><td>913</td><td>Maltese Falcon, The (1941)</td><td>Film-Noir|Mystery</td></tr><tr><td>20</td><td>3417</td><td>Crimson Pirate, The (1952)</td><td>Adventure|Comedy|Sci-Fi</td></tr><tr><td>34</td><td>2186</td><td>Strangers on a Train (1951)</td><td>Film-Noir|Thriller</td></tr><tr><td>55</td><td>2791</td><td>Airplane! (1980)</td><td>Comedy</td></tr><tr><td>31</td><td>1188</td><td>Strictly Ballroom (1992)</td><td>Comedy|Romance</td></tr><tr><td>28</td><td>1304</td><td>Butch Cassidy and the Sundance Kid (1969)</td><td>Action|Comedy|Westem</td></tr><tr><td></td><td></td><td>(@）</td><td></td></tr><tr><td>516</td><td>MovieID 527</td><td>Title</td><td>Genres</td></tr><tr><td>1848</td><td></td><td>Schindler's List (1993)</td><td>Drama/War</td></tr><tr><td></td><td>1953</td><td>French Connection, The (1971)</td><td>Action|Crime|Drama|Thriller</td></tr><tr><td>596</td><td>608</td><td>Fargo (1996)</td><td>Crime|Drama|Thriller</td></tr><tr><td>1235</td><td>1284</td><td>Big Sleep, The (1946)</td><td>Film-Noir|Mystery</td></tr><tr><td>2085</td><td>2194</td><td>Untouchables, The (1987)</td><td>Action|Crime|Drama</td></tr><tr><td>1188</td><td>1230</td><td>Annie Hall (1977)</td><td>ComedylRomance</td></tr><tr><td>1198</td><td>1242</td><td>Glory (1989)</td><td>Action|Drama/War</td></tr><tr><td>897</td><td>922</td><td>Sunset Blvd. (a.k.a. Sunset Boulevard) (1950)</td><td>Film-Noir</td></tr><tr><td>1849</td><td>1954</td><td>Rocky (1976)</td><td>Action|Drama</td></tr><tr><td>581</td><td>593</td><td>Silence of the Lambs, The (1991)</td><td>Drama|Thriller</td></tr></table></body></html>

We can fit this by only updating parameters that are associated with the observed entries of $\mathbf { \it _ y } _ { : , i }$ Furthermore, we can add an $\ell _ { 2 }$ regularizer to the weight matrices to get the objective

$$
\mathcal { L } ( \pmb { \theta } ) = \sum _ { i = 1 } ^ { N } \sum _ { u : y _ { u i } \neq \uparrow } ( y _ { u , i } - f ( \pmb { y } _ { : , i } ; \pmb { \theta } ) _ { u } ) ^ { 2 } + \frac { \lambda } { 2 } ( | | \mathbf { W } | | _ { F } ^ { 2 } + | | \mathbf { W } | | _ { F } ^ { 2 } )
$$

Despite the simplicity of this method, the authors find that this does better than more complex methods such as restricted Boltzmann machines (RBMs, [SMH07]) and local low-rank matrix

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

approximation (LLORMA, [Lee+13]).

# 22.2 Implicit feedback

So far, we have assumed that the user gives explicit ratings for each item that they interact with. This is a very restrictive assumption. More generally, we would like to learn from the implicit feedback that users give just by interacting with a system. For example, we can treat the list of movies that user $u$ watches as positives, and regard all the other movies as negatives. Thus we get a sparse, positive-only ratings matrix.

Alternatively, we can view the fact that they watched movie $i$ but did not watch movie $j$ as an implicit signal that they prefer $i$ to $j$ . The resulting data can be represented as a set of tuples of the form $y _ { n } = ( u , i , j )$ , where $( u , i )$ is a positive pair, and $( u , j )$ is a negative (or unlabeled) pair.

# 22.2.1 Bayesian personalized ranking

To fit a model to data of the form $( u , i , j )$ , we need to use a ranking loss, so that the model ranks $i$ ahead of $j$ for user $u$ . A simple way to do this is to use a Bernoulli model of the form

$$
p ( y _ { n } = ( u , i , j ) | \pmb \theta ) = \sigma ( f ( u , i ; \pmb \theta ) - f ( u , j ; \pmb \theta ) )
$$

If we combine this with a Gaussian prior for $\pmb \theta$ , we get the following MAP estimation problem:

$$
\mathcal { L } ( \pmb { \theta } ) = \sum _ { ( u , i , j ) \in \mathcal { D } } \log \sigma ( f ( u , i ; \pmb { \theta } ) - f ( u , j ; \pmb { \theta } ) ) - \lambda | | \pmb { \theta } | | ^ { 2 }
$$

where $\mathcal { D } = \{ ( u , i , j ) : i \in \mathcal { T } _ { u } ^ { + } , j \in \mathcal { T } \setminus \mathcal { T } _ { u } ^ { + } \}$ , where $\mathcal { I } _ { u } ^ { + }$ are the set of all items that user $u$ selected, and $\mathcal { T } \backslash \mathcal { T } _ { u } ^ { + }$ are all the other items (which they may dislike, or simply may not have seen). This is known as Bayesian personalized ranking or BPR [Ren+09].

Let us consider this example from [Zha+20, Sec 16.5]. There are 4 items in total, $\mathcal { T } = \{ i _ { 1 } , i _ { 2 } , i _ { 3 } , i _ { 4 } \}$ , and user $u$ chose to interact with $\mathcal { T } _ { u } ^ { + } = \{ i _ { 2 } , i _ { 3 } \}$ . In this case, the implicit item-item preference matrix for user $u$ has the form

$$
\mathbf { Y } _ { u } = \left( \begin{array} { c c c c } { . } & { + } & { + } & { ? } \\ { - } & { . } & { ? } & { - } \\ { - } & { ? } & { . } & { - } \\ { ? } & { + } & { + } & { . } \end{array} \right)
$$

where $Y _ { u , i , i ^ { \prime } } = +$ means user $u$ prefers $i ^ { \prime }$ to $i$ , $Y _ { u , i , i ^ { \prime } } = -$ means user $u$ prefers $i$ to $i ^ { \prime }$ , and $Y _ { u , i , i ^ { \prime } } = :$ means we cannot tell what the user’s preference is. For example, focusing on the second column, we see that this user rates $i _ { 2 }$ higher than $i _ { 1 }$ and $i _ { 4 }$ , since they selected $i _ { 2 }$ but not $i _ { 1 }$ or $i _ { 4 }$ ; however, we cannot tell if they prefer $i _ { 2 }$ over $i _ { 3 }$ or vice versa.

When the set of posssible items is large, the number of negatives in $\mathcal { T } \backslash \mathcal { T } _ { u } ^ { + }$ can be very large. Fortunately we can approximate the loss by subsampling negatives.

Note that an alternative to the log-loss above is to use a hinge loss, similar to the approach used in SVMs (Section 17.3). This has the form

$$
( u , i , j ) , f ) = \operatorname* { m a x } { \big ( } m - ( f ( u , i ) - f ( u , j ) ) , 0 { \big ) } = \operatorname* { m a x } { \big ( } m - f ( u , i ) + f ( u , j ) , 0 { \big ) }
$$

where $m \geq 0$ is the safety margin. This tries to ensure the negative items $j$ never score more than $m$ higher than the positive items $i$ .

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

# 22.2.2 Factorization machines

The AutoRec approach of Section 22.1.4 is nonlinear, but treats users and items asymmetrically. In this section, we discuss a more symmetric discriminative modeling approach. We start with a linear version. The basic idea is to predict the output (such as a rating) for any given user-item pair, $\pmb { x } = [ \mathrm { o n e - h o t } ( u )$ , one-hot $( i ) ]$ , using

$$
f ( \pmb { x } ) = \mu + \sum _ { i = 1 } ^ { D } w _ { i } x _ { i } + \sum _ { i = 1 } ^ { D } \sum _ { j = i + 1 } ^ { D } ( \pmb { v } _ { i } ^ { \top } \pmb { v } _ { j } ) x _ { i } x _ { j }
$$

where $\pmb { x } \in \mathbb { R } ^ { D }$ where $D = ( M + N )$ is the number of inputs, $\mathbf { V } \in \mathbb { R } ^ { D \times K }$ is a weight matrix, ${ \pmb w } \in \mathbb { R } ^ { D }$ is a weight vector, and $\mu \in \mathbb { R }$ is a global offset. This is known as a factorization machine (FM) [Ren12].

The term $( { \pmb v } _ { i } ^ { 1 } { \pmb v } _ { j } ) x _ { i } x _ { j }$ measures the interaction between feature $i$ and $j$ in the input. This generalizes the matrix factorization model of Equation (22.4), since it can handle other kinds of information in the input $_ { x }$ , beyond just user and item, as we discuss in Section 22.3.

Computing Equation (22.17) takes $O ( K D ^ { 2 } )$ time, since it considers all possible pairwise interactions between every user and every item. Fortunately we can rewrite this so that we can compute it in $O ( K D )$ time as follows:

$$
\begin{array} { l } { \displaystyle \sum _ { i = 1 } ^ { D } \sum _ { j = i + 1 } ^ { D } ( v _ { i } ^ { \top } v _ { j } ) x _ { i } x _ { j } = \frac { 1 } { 2 } \sum _ { i = 1 } ^ { D } \sum _ { j = 1 } ^ { D } ( v _ { i } ^ { \top } v _ { j } ) x _ { i } x _ { j } - \frac { 1 } { 2 } \sum _ { i = 1 } ^ { D } ( v _ { i } ^ { \top } v _ { i } ) x _ { i } x _ { i } } \\ { \displaystyle = - \frac { 1 } { 2 } \left( \sum _ { i = 1 } ^ { D } \sum _ { j = 1 } ^ { D } \sum _ { k = 1 } ^ { K } v _ { i k } v _ { j k } x _ { i } x _ { j } - \sum _ { i = 1 } ^ { D } \sum _ { k = 1 } ^ { K } v _ { i k } v _ { i k } x _ { i } x _ { i } \right) } \\ { \displaystyle = - \frac { 1 } { 2 } \sum _ { k = 1 } ^ { K } \left( ( \sum _ { i = 1 } ^ { D } v _ { i k } x _ { i } ) ^ { 2 } - \sum _ { i = 1 } ^ { D } v _ { i k } ^ { 2 } x _ { i } ^ { 2 } \right) } \end{array}
$$

For sparse vectors, the overall complexity is linear in the number of non-zero components. So if we use one-hot encodings of the user and item id, the complexity is just $O ( K )$ , analogous to the original matrix factorization objective of Equation (22.4).

We can fit this model to minimize any loss we want. For example, if we have explicit feedback, we may choose MSE loss, and if we have implicit feedback, we may choosing ranking loss.

In [Guo+17], they propose a model called deep factorization machines, which combines the above method with an MLP applied to a concatenation of the embedding vectors, instead of the inner product. More precisely, it is a model of the form

$$
f ( \pmb { x } ; \pmb { \theta } ) = \sigma ( \mathrm { F M } ( \pmb { x } ) + \mathrm { M L P } ( \pmb { x } ) )
$$

This is closely related to the wide and deep model proposed in [Che+16]. The idea is that the bilinear FM model captures explicit interactions between specific users and items (a form of memorization), whereas the MLP captures implicit interactions between user features and item features, which allows the model to generalize.

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

![](images/53625efcc2e0e8b5f7d97fa8392631385ea4c40cd81c140d1395d1276e3fb95c.jpg)  
Figure 22.5: Illustration of the neural matrix factorization model. From Figure $\mathcal { Z }$ of [He+17]. Used with kind permission of Xiangnan He.

# 22.2.3 Neural matrix factorization

In this section, we describe the neural matrix factorization model of [He+17]. This is another way to combine bilinear models with deep neural networks. The bilinear part is used to define the following generalized matrix factorization (GMF) pathway, which computes the following feature vector for user $u$ and item $i$ :

$$
z _ { u i } ^ { 1 } = \mathbf { P } _ { u , : } \odot \mathbf { Q } _ { i , : }
$$

where $\mathbf { P } \in \mathbb { R } ^ { M K }$ is a user embedding matrix, and $\mathbf { Q } \in \mathbb { R } ^ { N K }$ is an item embedding matrix. The DNN part is just an MLP applied to a concatenation of the embedding vectors (using different embedding matrices):

$$
z _ { u i } ^ { 2 } = \mathrm { M L P } ( [ \tilde { \mathbf { U } } _ { u , : } , \tilde { \mathbf { V } } _ { i , : } ] )
$$

Finally, the model combines these to get

$$
\begin{array} { r } { f ( u , i ; \pmb { \theta } ) = \sigma ( \pmb { w } ^ { \top } [ \pmb { z } _ { u i } ^ { 1 } , \pmb { z } _ { u i } ^ { 2 } ] ) } \end{array}
$$

See Figure 22.5 for an illustration.

In [He+17], the model is trained on implicit feedback, where $y _ { u i } = 1$ if the interaction of user $u$ with item $i$ is observed, and $y _ { u i } = 0$ otherwise. However, it could be trained to minimize BPR loss.

# 22.3 Leveraging side information

So far, we have assumed that the only information available to the predictor are the integer id of the user and the integer id of the item. This is an extremely impoverished representation, and will fail to

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

Feature vector x Targety   
X 1 0 0 1 0 0 0 0.30.30.3 0 13 0 0 0 0 5 y   
$\mathbf { x } _ { 2 }$ 1 0 0 0 1 0 0 0.30.30.3 0 14 1 0 0 0 3 ${ \tt y } _ { 2 }$   
$\mathbf { x } _ { 3 }$ 1 0 0 0 0 1 0 0.30.30.3 0 16 0 0 0 1 ${ \tt y } _ { 3 }$   
$\mathbf { x } _ { 4 }$ 0 1 0 0 0 0 0 0 0.50.5 5 0 0 0 0 4 y   
$\pmb { x } _ { 5 }$ 0 1 0 0 0 0 1 0 0 0.50.5 8 0 0 1 0 · 5 y5   
$\mathbf { x } _ { 6 }$ 0 0 1 1 0 0 0 \* 0.5 0 0.5 0 9 0 0 0 0 # 1 y6   
X7 0 0 1 0 0 0 0.5 0 0.5 0 12 1 0 0 0 5 y7 B SW TI NH SW ST User Movie Time Last Movierated

work if we encounter a new user or new item (the so-called cold start problem). To overcome this, we need to leverage “side information”, beyond just the id of the user/item.

There are many forms of side information we can use. For items, we often have rich meta-data, such text (e.g., title), images (e.g., cover), high-dimensional categorical variables (e.g., location), or just scalars (eg., price). For users, the side information available depends on the specific form of the interactive system. For search engines, it is the list of queries the user has issued, and (if they are logged in), information derived from websites they have visited (which is tracked via cookies). For online shopping sites, it is the list of searches plus past viewing and purchasing behavior. For social networking sites, there is information about the friendship graph of each user.

It is very easy to capture this side information in the factorization machines framework, by expanding our definition of $_ { x }$ beyond the two one-hot vectors, as illustrated in Figure 22.6. The same input encoding can of course be fed into other kinds of models, such as deepFM or neuralMF.

In addition to features about the user and item, there may be other contextual features, such as the time of the interaction (e.g., the day or evening). The order (sequence) of the most recently viewed items is often also a useful signal. The “Convolutional Sequence Embedding Recommendation” or Caser model proposed in [TW18] captures this by embedding the last $M$ items, and then treating the $M \times K$ input as an image, by using a convolutional layer as part of the model.

Many other kinds of neural models can be designed for the recommender task. See e.g., [Zha+19b] for a review.

# 22.4 Exploration-exploitation tradeoff

An interesting “twist” to recommender systems that does not arise in other kinds of prediction problems is the fact that the data that the system is trained on is a consequence of recommendations made by earlier versions of the system. Thus there is a feedback loop [Bot+13]. For example, consider the YouTube video recommendation system [CAS16]. There are millions of videos on the site, so the system must come up with a shortlist, or “slate”, of videos to show the user, to help them find what they want (see e.g., [Ie+19]). If the user watches one of these videos, the system can consider this positive feedback that it made a good recommendation, and it can update the model parameters accordingly. However, maybe there was some other video that the user would have liked even more?

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

It is impossible to answer this counterfactual unless the system takes a chance and shows some items for which the user response is uncertain. This is an example of the exploration-exploitation tradeoff.

In addition to needing to explore, the system may have to wait for a long time until it can detect if a change it made its recommendation policies was beneficial. It is common to use reinforcement learning to learn policies which optimize long-term reward. See the sequel to this book, [Mur23], for details.

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

# 23 Graph Embeddings \*

This chapter is coauthored with Bryan Perozzi, Sami Abu-El-Haija and Ines Chami, and is based on [Cha+21].

# 23.1 Introduction

We now turn our focus to data which has semantic relationships between training samples $\{ { \bf x } _ { n } \} _ { n = 1 } ^ { N }$ . The relationships (known as edges) connect training samples (nodes) with an application specific meaning (commonly similarity). Graphs provide the mathematical foundations for reasoning about these kind of relationships

Graphs are universal data structures that can represent complex relational data (composed of nodes and edges), and appear in multiple domains such as social networks, computational chemistry [Gil+17], biology [Sta+06], recommendation systems [KSJ09], semi-supervised learning [GB18], and others.

Let ${ \bf A } \in \{ 0 , 1 \} ^ { N \times N }$ be the adjacency matrix, where $N$ is the number of nodes, and let $\mathbf { W } \in \mathbb { R } ^ { N \times N }$ be a weighted version. In the methods we discuss below, some set $\mathbf { W } = \mathbf { A }$ while others set $\mathbf { W }$ to a transformation of A, such as row-wise normalization. Finally, let $\mathbf { X } \in \mathbb { R } ^ { N \times D }$ be a matrix of node features.

When designing and training a neural network model over graph data, we desire the designed method be applicable to nodes which participate in different graph settings (e.g. have differing connections and community structure). Contrast this with a neural network model designed for images, where each pixel (node) has the same neighborhood structure. By contrast, an arbitrary graph has no specified alignment of nodes, and further, each node might have a different neighborhood structure. See Figure 23.1 for a comparison. Consequently, operations like Euclidean spatial convolution cannot be directly applied on irregular graphs: Euclidean convolutions strongly rely on geometric priors (such as shift invariance), which don’t generalize to non-Euclidean domains.

These challenges led to the development of Geometric Deep Learning (GDL) research [Bro+17b], which aims at applying deep learning techniques to non-Euclidean data. In particular, given the widespread prevalence of graphs in real-world applications, there has been a surge of interest in applying machine learning methods to graph-structured data. Among these, Graph Representation Learning (GRL) [Cha+21] methods aim at learning low-dimensional continuous vector representations for graph-structured data, also called embeddings.

We divide GRL here into two classes of problems: unsupervised and supervised (or semisupervised) GRL. The first class aims at learning low-dimensional Euclidean representations optimizing an objective, e.g. one that preserve the structure of an input graph. The second class also learns low-dimensional Euclidean representations but for a specific downstream prediction task such as node or graph classification. Further, the graph structure can be fixed throughout training and testing, which is known as the transductive learning setting (e.g. predicting user properties in a large social network), or alternatively the model is expected to answer questions about graphs not seen during training, known as the inductive learning setting (e.g. classifying molecular structures). Finally, while most supervised and unsupervised methods learn representations in Euclidean vector spaces, there recently has been interest for non-Euclidean representation learning, which aims at learning non-Euclidean embedding spaces such as hyperbolic or spherical spaces. The main motivations for this body of work is to use a continuous embedding space that resembles the underlying discrete structure of the input data it tries to embed (e.g. the hyperbolic space is a continuous version of trees [Sar11]).

![](images/77d2fc72b915de72ce459eff0f188378aa2ce10f4ad6561f42020d1bf167e1d2.jpg)  
Figure 23.1: An illustration of Euclidean vs. non-Euclidean graphs. Used with permission from [Cha+21].

# 23.2 Graph Embedding as an Encoder/Decoder Problem

While there are many approaches to GRL, many methods follow a similar pattern. First, the network input (node features $\mathbf { X } \in \mathbb { R } ^ { N \times D }$ and graph edges in A or $\mathbf { W } \in \mathbb { R } ^ { N \times N }$ ) is encoded from the discrete domain of the graph into a continuous representation (embedding), $\mathbf { Z } \in \mathbb { R } ^ { N \times L }$ . Next, the learned representation $\mathbf { Z }$ is used to optimize a particular objective (such as reconstructing the links of the graph). In this section we will use the graph encoder-decoder model (GraphEDM) proposed by Chami et al. [Cha+21] to analyze popular families of GRL methods.

The GraphEDM framework (Figure 23.2, [Cha+21]) provides a general framework that encapsulates a wide variety of supervised and unsupervised graph embedding methods: including ones utilizing the graph as a regularizer (e.g. [ZG02]), positional embeddings(e.g. [PARS14]), and graph neural networks such as ones based on message passing [Gil+17; Sca+09] or graph convolutions

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

![](images/313a2afe25857b735bbcf6485fa6cfca92536a8b4b3b6c587625d95c98f6a556.jpg)  
Figure 23.2: Illustration of the GraphEDM framework from Chami et al. [Cha+21]. Based on the supervision available, methods will use some or all of the branches. In particular, unsupervised methods do not leverage label decoding for training and only optimize the similarity decoder (lower branch). On the other hand, semi-supervised and supervised methods leverage the additional supervision to learn models’ parameters (upper branch). Reprinted with permission from [Cha+21].

[Bru+14; KW16a]).

The GraphEDM framework takes as input a weighted graph $\mathbf { W } \in \mathbb { R } ^ { N \times N }$ , and optional node features $\mathbf { X } \in \mathbb { R } ^ { N \times D }$ . In (semi-)supervised settings, we assume that we are given training target labels for nodes (denoted $N$ ), edges (denoted $E$ ), and/or for the entire graph (denoted $G$ ). We denote the supervision signal as $S \in \{ N , E , G \}$ , as presented below.

The GraphEDM model itself can be decomposed into the following components:

• Graph encoder network $\mathrm { E N C } _ { \Theta ^ { E } } : \mathbb { R } ^ { N \times N } \times \mathbb { R } ^ { N \times D }  \mathbb { R } ^ { N \times L }$ , parameterized by $\Theta ^ { E }$ , which combines the graph structure with optional node features to produce a node embedding matrix $\mathbf { Z } \in \mathbb { R } ^ { N \times L }$ as follows:

$$
\begin{array} { r } { \mathbf { Z } = \mathrm { E N C } ( \mathbf { W } , \mathbf { X } ; \Theta ^ { E } ) . } \end{array}
$$

As we shall see next, this node embedding matrix might capture different graph properties depending on the supervision used for training.

• Graph decoder network ${ \mathrm { D E C } } _ { \Theta ^ { D } } : \mathbb { R } ^ { N \times L } \to \mathbb { R } ^ { N \times N }$ , parameterized by $\Theta ^ { D }$ , which uses the node embeddings $Z$ to compute similarity scores for all node pairs in matrix $\widehat { \mathbf { W } } \in \mathbb { R } ^ { N \times N }$ as follows:

$$
\widehat { \mathbf { W } } = \mathrm { D E C } ( \mathbf { Z } ; \boldsymbol { \Theta } ^ { D } ) .
$$

• Classification network ${ \mathrm { D E C } } _ { \ominus } s : \mathbb { R } ^ { N \times L }  \mathbb { R } ^ { N \times | \mathcal { V } | }$ , where $y$ is the label space. This network is used in (semi-)supervised settings and parameterized by $\Theta ^ { S }$ . The output is a distribution over the labels $\hat { y } ^ { S }$ , using node embeddings, as follows:

$$
\widehat { \boldsymbol { y } } ^ { S } = \operatorname { D E C } ( \mathbf { Z } ; \boldsymbol { \Theta } ^ { S } ) .
$$

Specific choices of the aforementioned (encoder and decoder) networks allows GraphEDM to realize specific graph embedding methods, as we explain in the next subsections.

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

![](images/ae76bfc40b3e87fff2e4bdf28a85f00fff10b637153191eb3e8c6c5dbfe6a8dd.jpg)  
Figure 23.3: Shallow embedding methods. The encoder is a simple embedding look-up and the graph structure is only used in the loss function. Reprinted with permission from [Cha+21].

The output of a model, as described by GraphEDM framework, is a reconstructed graph similarity matrix $\widehat { W }$ (often used to train unsupervised embedding algorithms), and/or labels $\widehat { \boldsymbol { y } } ^ { S }$ for supervised applicaticons. The label output space $_ { \mathcal { V } }$ is application dependent. For instancbe, in node-level classification, $\widehat { y } ^ { N } \in \mathcal { V } ^ { N }$ , with $\mathcal { V }$ representing the node label space. Alternately, for edge-level labeling, $\widehat { y } ^ { E } \in \mathcal { V } ^ { N \times N }$ , wbith $\mathcal { V }$ representing the edge label space. Finally, we note that other kinds of labeling abre possible, such as graph-level labeling (where we would say $\widehat { \boldsymbol { y } } ^ { G } \in \mathcal { V }$ , with $\mathcal { V }$ representing the graph label space).

Finally, a loss must be specified. This can be used to optimize the parameters $\Theta = \{ \Theta ^ { E } , \Theta ^ { D } , \Theta ^ { S } \}$ . GraphEDM models can be optimized using a combination of three different terms. First, a supervised lroescsontsetrrmu,c $\mathcal { L } _ { \mathrm { S U P } } ^ { S }$ ,oscsotmepramr,e he predi,ctmedaylalbeveles $\hat { y } ^ { S }$ tohethgeragprohusntdrutcrtutrhe taobeilms $y ^ { S }$ . rNegxutl,ara zgartaiponh $\mathcal { L } _ { G }$ constraints on the model parameters. Finally, a weight regularization loss term, $\mathcal { L } _ { \mathrm { R E G } }$ , allows representing priors on trainable model parameters for reducing overfitting. Models realizable by GraphEDM framework are trained by minimizing the total loss $\mathcal { L }$ defined as:

$$
\mathcal { L } = \alpha \mathcal { L } _ { \mathrm { S U P } } ^ { S } ( y ^ { S } , \hat { y } ^ { S } ; \boldsymbol { \Theta } ) + \beta \mathcal { L } _ { G , \mathrm { R E C O N } } ( \mathbf { W } , \widehat { \mathbf { W } } ; \boldsymbol { \Theta } ) + \gamma \mathcal { L } _ { \mathrm { R E G } } ( \boldsymbol { \Theta } ) ,
$$

where $\alpha$ , $\beta$ and $\gamma$ are hyper-parameters, that can be tuned or set to zero. Note that graph embedding methods can be trained in a supervised ( $\alpha \neq 0$ ) or unsupervised ( $\alpha = 0$ ) fashion. Supervised graph embedding approaches leverage an additional source of information to learn embeddings such as node or graph labels. On the other hand, unsupervised network embedding approaches rely on the graph structure only to learn node embeddings.

# 23.3 Shallow graph embeddings

Shallow embedding methods are transductive graph embedding methods, where the encoder function maps categorical node IDs onto a Euclidean space through an embedding matrix. Each node $v _ { i } \in V$ has a corresponding low-dimensional learnable embedding vector $\mathbf { Z } _ { i } \in \mathbb { R } ^ { L }$ and the shallow encoder function is

$$
\mathbf { Z } = \mathrm { E N C } ( \Theta ^ { E } ) \triangleq \Theta ^ { E } \mathrm { w h e r e } \quad \Theta ^ { E } \in \mathbb { R } ^ { N \times L } .
$$

Crucially, the embedding dictionary $\mathbf { Z }$ is directly learned as model parameters. In the unsupervised case, embeddings $\mathbf { Z }$ are optimized to recover some information about the input graph (e.g., the adjacency matrix $\mathbf { W }$ , or some transformation of it). This is somewhat similar to dimensionality reduction methods, such as PCA (Section 20.1), but for graph data structures. In the supervised case, the embeddings are optimized to predict some labels, for nodes, edges and/or the whole graph.

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

# 23.3.1 Unsupervised embeddings

In the unsupervised case, we will consider two main types of shallow graph embedding methods: distance-based and outer product-based. Distance-based methods optimize the embedding dictionary $\mathbf { Z } = \boldsymbol { \Theta } ^ { E } \in \mathbb { R } ^ { N \times L }$ such that nodes $i$ and $j$ which are close in the graph (as measured by some graph distance function) are embedded in $\mathbf { Z }$ such that $d _ { 2 } ( \mathbf { Z } _ { i } , \mathbf { Z } _ { j } )$ is small, where $d _ { 2 } ( . , . )$ is a pairwise distance function between embedding vectors. The distance function $d _ { 2 } ( \cdot , \cdot )$ can be customized, which can lead to Euclidean (Section 23.3.2) or non-Euclidean (Section 23.3.3) embeddings. The decoder outputs a node-to-node matrix $\widehat { \mathbf { W } } = \mathrm { D E C } ( \mathbf { Z } ; \boldsymbol { \Theta } ^ { D } )$ , with $\widehat { W } _ { i j } = d _ { 2 } ( \mathbf { Z } _ { i } , \mathbf { Z } _ { j } )$ .

Alternatively, some method crely on pairwise dot-procducts to compute node similarities. The ecoder network can be written as: $\widehat { W } = \mathrm { D E C } ( \mathbf { Z } ; \boldsymbol { \Theta } ^ { D } ) = \mathbf { Z } \mathbf { Z } ^ { \top }$ .

In both cases, unsupervised emb dcdings for distance- and product-based methods are learned by minimizing the graph regularization loss:

$$
\mathcal { L } _ { G , \mathrm { R E C O N } } ( \mathbf { W } , \widehat { \mathbf { W } } ; \boldsymbol { \Theta } ) = d _ { 1 } ( s ( \mathbf { W } ) , \widehat { \mathbf { W } } ) ,
$$

where $s ( \mathbf { W } )$ is an optional transformation of the adjacency matrix $\mathbf { W }$ , and $d _ { 1 }$ is pairwise distance function between matrices, which does not need to be of the same form as $d _ { 2 }$ . As we shall see, there are many plausible choices for $s , d _ { 1 } , d _ { 2 }$ . For instance, we can let $s$ be the adjacency matrix itself, $s ( \mathbf { W } ) = \mathbf { W }$ or a power of it e.g. $s ( \mathbf { W } ) = \mathbf { W } ^ { 2 }$ . If the input is a weighted binary matrix $\mathbf { W } = \mathbf { A }$ , we can set $s ( \mathbf { W } ) = 1 - \mathbf { W }$ , so that connected nodes with $A _ { i j } = 1$ get a weight (distance) of $0$ .

# 23.3.2 Distance-based: Euclidean methods

Distance-based methods minimize Euclidean distances between similar (connected) nodes. We give some examples below.

Multi-dimensional scaling (MDS, Section 20.4.4) is equivalent to setting $s ( \mathbf { W } )$ to some distance matrix measuring the dissimilarity between nodes (e.g. proportional to pairwise shortest distance) and then defining

$$
d _ { 1 } ( \boldsymbol { s } ( W ) , \widehat { W } ) = \sum _ { i , j } ( \boldsymbol { s } ( W ) _ { i j } - \widehat { W } _ { i j } ) ^ { 2 } = | | \boldsymbol { s } ( \mathbf { W } ) - \widehat { \mathbf { W } } | | _ { F } ^ { 2 }
$$

where $\widehat { W } _ { i j } = d _ { 2 } ( \mathbf { Z } _ { i } , \mathbf { Z } _ { j } ) = | | \mathbf { Z } _ { i } - \mathbf { Z } _ { j } | |$ (although other distance metrics are plausible).

Laplcacian eigenmaps (Section 20.4.9) learn embeddings by solving the generalized eigenvector problem

$$
\operatorname* { m i n } _ { \mathbf { Z } \in \mathbb { R } ^ { | V | \times d } } \mathrm { t r } ( \mathbf { Z } ^ { \mathsf { T } } \mathbf { L } \textbf { Z } ) \mathrm { s . t . } \mathbf { Z } ^ { \mathsf { T } } \mathbf { D } \mathbf { Z } = \mathbf { I } \mathrm { a n d } \mathbf { Z } ^ { \mathsf { T } } \mathbf { D } \mathbf { 1 } = \mathbf { 0 }
$$

where $\mathbf { L } = \mathbf { D } - \mathbf { W }$ is the graph Laplacian (Section 20.4.9.2), and $\mathbf { D }$ is a diagonal matrix containing the sum across columns for each row. The first constraint removes an arbitrary scaling factor in the embedding and the second one removes trivial solutions corresponding to the constant eigenvector (with eigenvalue zero for connected graphs). Further, note that $\begin{array} { r } { \mathrm { t r } ( \mathbf { Z } ^ { \mathsf { T } } \mathbf { L } \mathbf { Z } ) = \frac { 1 } { 2 } \sum _ { i , j } W _ { i j } \vert \vert \mathbf { Z } _ { i } - \mathbf { Z } _ { j } \vert \vert _ { 2 } ^ { 2 } } \end{array}$ , where $\mathbf { Z } _ { i }$ is the $i$ ’th row of $\mathbf { Z }$ ; therefore the minimization objective can be equivalently written as a

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license graph reconstruction term, as follows:

$$
\begin{array} { c } { d _ { 1 } ( s ( \mathbf { W } ) , \widehat { \mathbf { W } } ) = \displaystyle \sum _ { i , j } \mathbf { W } _ { i j } \times \widehat { \mathbf { W } } _ { i j } } \\ { \widehat { \mathbf { W } } _ { i j } = d _ { 2 } ( \mathbf { Z } _ { i } , \mathbf { Z } _ { j } ) = \| \mathbf { Z } _ { i } - \mathbf { Z } _ { j } \| _ { 2 } ^ { 2 } } \end{array}
$$

where $s ( \mathbf { W } ) = \mathbf { W }$ .

# 23.3.3 Distance-based: non-Euclidean methods

So far, we have discussed methods which assume that embeddings lie in an Euclidean Space. However, recent work has considered hyperbolic geometry for graph embedding. In particular, hyperbolic embeddings are ideal for embedding trees and offer an exciting alternative to Euclidean geometry for graphs that exhibit hierarchical structures. We give some examples below.

Nickel and Kiela [NK17] learn embeddings of hierarchical graphs using the Poincaré model of hyperbolic space. This is simple to represent in our notation as we only need to change $d _ { 2 } ( \mathbf { Z } _ { i } , \mathbf { Z } _ { j } )$ to the Poincaré distance function:

$$
d _ { 2 } ( \mathbf { Z } _ { i } , \mathbf { Z } _ { j } ) = d _ { \mathrm { P o i n c a r e } } ( \mathbf { Z } _ { i } , \mathbf { Z } _ { j } ) = \operatorname { a r c o s h } \left( 1 + 2 \frac { | | \mathbf { Z } _ { i } - \mathbf { Z } _ { j } | | _ { 2 } ^ { 2 } } { ( 1 - | | \mathbf { Z } _ { i } | | _ { 2 } ^ { 2 } ) ( 1 - | | \mathbf { Z } _ { j } | | _ { 2 } ^ { 2 } ) } \right) .
$$

The optimization then learns embeddings which minimize distances between connected nodes while maximizing distances between disconnected nodes:

$$
d _ { 1 } ( \mathbf { W } , \widehat { \mathbf { W } } ) = \sum _ { i , j } \mathbf { W } _ { i j } \mathrm { l o g } \ \frac { e ^ { - \widehat { \mathbf { W } } _ { i j } } } { \sum _ { k | \mathbf { W } _ { i k } = 0 } e ^ { - \widehat { \mathbf { W } } _ { i k } } }
$$

where the denominator is approximated using negative sampling. Note that since the hyperbolic space has a manifold structure, care needs to be taken to ensure that the embeddings remain on the manifold (using Riemannian optimization techniques [Bon13]).

Other variants of these methods have been proposed. Nickel and Kiela [NK18] explore the Lorentz model of hyperbolic space , and show that it provides better numerical stability than the Poincaré model. Another line of work extends non-Euclidean embeddings to mixed-curvature product spaces [Gu+18], which provide more flexibility for other types of graphs (e.g. ring of trees). Finally, work by Chamberlain, Clough, and Deisenroth [CCD17] extends Poincaré embeddings using skip-gram losses with hyperbolic inner products.

# 23.3.4 Outer product-based: Matrix factorization methods

Matrix factorization approaches learn embeddings that lead to a low rank representation of some similarity matrix $s ( \mathbf { W } )$ , with $s : \mathbb { R } ^ { N \times N } \to \mathbb { R } ^ { N \times N }$ . The following are frequent choices: $s ( \mathbf { W } ) = \mathbf { W }$ , $s ( \mathbf { W } ) = L$ (Graph Laplacian), or other proximity measure such as the Katz centrality index, Common Neighbors or Adamic/Adar index.

The decoder function in matrix factorization methods is just a dot product:

$$
\widehat { \mathbf { W } } = \mathrm { D E C } ( \mathbf { Z } ; \boldsymbol { \Theta } ^ { D } ) = \mathbf { Z } \mathbf { Z } ^ { \top }
$$

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

![](images/88f75f3366914672d2f6e84e8d5744e8a4083b1fa8e103e4e56a35361f6b9bf1.jpg)  
Figure 23.4: An overview of the pipeline for random-walk graph embedding methods. Reprinted with permission from [God18].

Matrix factorization methods learn $\mathbf { Z }$ by minimizing a regularization loss $\mathcal { L } _ { G , \mathrm { R E C O N } } ( \mathbf { W } , \widehat { \mathbf { W } } ; \Theta ) =$ $| | s ( \mathbf { W } ) - \widehat { \mathbf { W } } | | _ { F } ^ { 2 }$ .

The gracph factorization method of [Ahm+13] learns a low-rank factorization of a graph by minimizing the graph regularization loss $\begin{array} { r } { \mathcal { L } _ { G , \mathrm { R E C O N } } ( \mathbf { W } , \widehat { \mathbf { W } } ; \boldsymbol { \Theta } ) = \sum _ { ( v _ { i } , v _ { j } ) \in E } ( \mathbf { W } _ { i j } - \widehat { \mathbf { W } } _ { i j } ) ^ { 2 } } \end{array}$ .

Note that if $\mathbf { A }$ is the binary adjacency matrix, ( ${ \bf A } _ { i j } = 1$ iff $( v _ { i } , v _ { j } ) \in E$ and $\mathbf { A } _ { i j } = 0$ otherwise), the graph regularization loss can be expressed in terms of the Frobenius norm:

$$
\mathcal { L } _ { G , \mathrm { R E C O N } } ( \mathbf { W } , \widehat { \mathbf { W } } ; \boldsymbol { \Theta } ) = | | \mathbf { A } \odot ( \mathbf { W } - \widehat { \mathbf { W } } ) | | _ { F } ^ { 2 } ,
$$

where $\odot$ is the element-wise matrix multiplication operator. Therefore, GF also learns a low-rank factorization of the adjacency matrix $W$ measured in Frobenuis norm. We note that this is a sparse operation (summing only over edges which exist in the graph), and so the method has computational complexity $O ( M )$ .

The methods described so far are all symmetric, that is, they assume that $\mathbf { W } _ { i j } = \mathbf { W } _ { j i }$ . This is a limiting assumption when working with directed graphs as some relationships are not reciprocal. The GraRep method of [CLX15] overcomes this limitation by learning two embeddings per node, a source embedding $\mathbf { Z } ^ { s }$ and a target embedding $\mathbf { Z } ^ { t }$ , which capture asymmetric proximity in directed networks. In addition to asymmetry, GraRep learns embeddings that preserve $k$ -hop neighborhoods via powers of the adjacency matrix and minimizes a graph reconstruction loss with:

$$
\begin{array} { c } { \widehat { \mathbf { W } } ^ { ( k ) } = \mathbf { Z } ^ { ( k ) , s } \mathbf { Z } ^ { ( k ) , t ^ { \intercal } } } \\ { \mathcal { L } _ { G , \mathrm { R E C O N } } ( \mathbf { W } , \widehat { \mathbf { W } } ^ { ( k ) } ; \boldsymbol { \Theta } ) = | | \mathbf { D } ^ { - k } \mathbf { W } ^ { k } - \widehat { \mathbf { W } } ^ { ( k ) } | | _ { F } ^ { 2 } , } \end{array}
$$

for each $1 \leq k \leq K$ . GraRep concatenates all representations to get source embeddings ${ \bf Z } ^ { s } = { }$ $[ \mathbf { Z } ^ { ( 1 ) , s } | \ldots | \mathbf { Z } ^ { ( K ) , s } ]$ and target embeddings $\mathbf { Z } ^ { t } = [ \mathbf { Z } ^ { ( 1 ) , t } | \ldots | \mathbf { Z } ^ { ( K ) , t } ]$ . Unfortunately, GraRep is not very scalable, since it uses a matrix power, $\mathbf { D } ^ { - 1 } \mathbf { W }$ , making it increasingly more dense. This limitation can be circumvented by using implicit matrix factorization [Per+17] as discussed below.

# 23.3.5 Outer product-based: Skip-gram methods

Skip-gram graph embedding models were inspired by research in natural language processing to model the distributional behavior of words [Mik+13c; PSM14b]. Skip-gram word embeddings are optimized to predict words in their context (the surrounding words) for each target word in a sentence. Given

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

a sequence of words $( w _ { 1 } , \dots , w _ { T } )$ , skip-gram will minimize the objective:

$$
\mathcal { L } = - \sum _ { \begin{array} { c } { - K \leq i \leq K , i \neq 0 } \end{array} } \log \mathbb { P } ( w _ { k - i } | w _ { k } ) ,
$$

for each target words $w _ { k }$ . These conditional probabilities can be efficiently estimated using neural networks. See Section 20.5.2.2 for details.

This idea has been leveraged for graph embeddings in the DeepWalk framework of [PARS14]. They justified this by showing empirically how the frequency statistics induced by random walks in real graphs follow a distribution similar to that of words used in natural language. In terms of GraphEDM, skip-gram graph embedding methods use an outer product (Equation 23.13) as their decoder function and a graph reconstruction term computed over random walks on the graph.

In more detail, DeepWalk trains node embeddings to maximize the probability of predicting context nodes for each center node. The context nodes are nodes appearing adjacent to the center node, in simulated random walks on A. To train embeddings, DeepWalk generates sequences of nodes using truncated unbiased random walks on the graph—which can be compared to sentences in natural language models—and then maximize their log-likelihood. Each random walk starts with a node $v _ { i _ { 1 } } \in V$ and repeatedly samples the next node uniformly at random: $v _ { i _ { j + 1 } } \in \{ v \in V \mid ( v _ { i _ { j } } , v ) \in E \}$ . The walk length is a hyperparameter. All generated random-walks can then be encoded by a sequence model. This two-step paradigm introduced by [PARS14] has been followed by many subsequent works, such as node2vec [GL16].

We note that it is common for underlying implementations to use two distinct representations for each node, one for when a node is center of a truncated random walk, and one when it is in the context. The implications of this modeling choice is studied further in [AEHPAR17].

To present DeepWalk in the GraphEDM framework, we can set:

$$
s ( \mathbf { W } ) = \mathbb { E } _ { q } \left[ \left( \mathbf { D } ^ { - 1 } \mathbf { W } \right) ^ { q } \right] { \mathrm { ~ w i t h ~ } } q \sim P ( Q ) = { \mathrm { C a t e g o r i c a l } } ( [ 1 , 2 , . . . , T _ { \operatorname* { m a x } } ] )
$$

where $\begin{array} { r } { P ( Q = q ) = \frac { T _ { \mathrm { m a x } } - 1 + q } { T _ { \mathrm { m a x } } } } \end{array}$ Tmax−1+q (see [AEH+18] for the derivation). Training DeepWalk is equivalent to minimizing:

$$
\mathcal { L } _ { G , \mathrm { R E C O N } } ( W , \widehat { W } ; \Theta ) = \log Z ( \mathbf { Z } ) - \sum _ { v _ { i } \in V , v _ { j } \in V } s ( \mathbf { W } ) _ { i j } \widehat { \mathbf { W } } _ { i j } ,
$$

where $\widehat { \mathbf { W } } = \mathbf { Z } \mathbf { Z } ^ { \mathsf { T } }$ , and the partition function is given by $\begin{array} { r } { Z ( \mathbf { Z } ) = \prod _ { i } \sum _ { j } \exp ( \widehat { \mathbf { W } } _ { i j } ) } \end{array}$ can be approximated in $O ( N )$ time via hierarchical softmax (see Section 20.5.2). (It is also commoncto model $\widehat { \bf W } = { \bf Z } _ { \mathrm { o u t } } { \bf Z } _ { \mathrm { i n } } ^ { \mathrm { ~ \tiny ~ T ~ } }$ for directed graphs using embedding dictionaries $\mathbf { Z } _ { \mathrm { o u t } } , \mathbf { Z } _ { \mathrm { i n } } \in \mathbb { R } ^ { N \times L }$ .)

As noted by [LG14], Skip-gram methods can be viewed as implicit matrix factorization, and the methods discussed here are related to those of Matrix Factorization (see Section 23.3.4). This relationship is discussed in depth by [Qiu+18], who propose a general matrix factorization framework, NetMF, which uses the same underlying graph proximity information as DeepWalk, LINE [Tan+15], and node2vec [GL16]. Casting the node embedding problem as matrix factorization can inherit benefits of efficient sparse matrix operations [Qiu+19a].

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

# 23.3.6 Supervised embeddings

In many applications, we have labeled data in addition to node features and graph structure. While it is possible to tackle a supervised task by first learning unsupervised representations and then using them as features in a secondary model, this is not the ideal workflow. Unsupervised node embeddings might not preserve important properties of graphs (e.g., node neighborhoods or attributes), that are most useful for a downstream supervised task.

In light of this limitation, a number of methods combining these two steps, namely learning embeddings and predicting node or graph labels, have been proposed. Here, we focus on simple shallow methods. We discuss deep, nonlinear embeddings later on.

# 23.3.6.1 Label propagation

Label propagation (LP) [ZG02] is a very popular algorithm for graph-based semi-supervised node classification. The encoder is a shallow model represented by a lookup table $\mathbf { Z }$ . LP uses the label space to represent the node embeddings directly (i.e. the decoder in LP is simply the identity function):

$$
\hat { y } ^ { N } = \mathrm { D E C } ( \mathbf { Z } ; \boldsymbol { \Theta } ^ { C } ) = \mathbf { Z } .
$$

In particular, LP uses the graph structure to smooth the label distribution over the graph by adding a regularization term to the loss function, using the underlying assumption that neighbor nodes should have similar labels (i.e. there exist some label consistency between connected nodes). Laplacian eigenmaps are utilized in the regularization to enforce this smoothness:

$$
\mathcal { L } _ { G , \mathrm { R E C O N } } ( \mathbf { W } , \widehat { \mathbf { W } } ; \Theta ) = \sum _ { i , j } \mathbf { W } _ { i j } | | y _ { i } ^ { N } - \hat { y } _ { j } ^ { N } | | _ { 2 } ^ { 2 }
$$

LP minimizes this energy function over the space of functions that take fixed values on labeled nodes (i.e. $\hat { y } _ { i } ^ { N } = y _ { i } ^ { N } \forall i | v _ { i } \in V _ { L } \backslash$ ) using an iterative algorithm that updates an unlabeled node’s label distribution via the weighted average of its neighbors’ labels.

Label spreading (LS) [Zho+04] is a variant of label propagation which minimizes the following energy function:

$$
\mathcal { L } _ { G , \mathrm { R E C O N } } ( \mathbf { W } , \widehat { \mathbf { W } } ; \boldsymbol { \Theta } ) = \sum _ { i , j } \mathbf { W } _ { i j } \bigg | \bigg | \frac { \hat { y } _ { i } ^ { N } } { \sqrt { D _ { i } } } - \frac { \hat { y } _ { j } ^ { N } } { \sqrt { D _ { j } } } \bigg | \bigg | _ { 2 } ^ { 2 } ,
$$

where $\begin{array} { r } { D _ { i } = \sum _ { j } W _ { i j } } \end{array}$ is the degree of node $v _ { i }$ .

In both methods, the supervised loss is simply the sum of distances between predicted labels and ground truth labels (one-hot vectors):

$$
\mathcal { L } _ { \mathrm { S U P } } ^ { N } ( y ^ { N } , \hat { y } ^ { N } ; \Theta ) = \sum _ { i | v _ { i } \in V _ { L } } | | y _ { i } ^ { N } - \hat { y } _ { i } ^ { N } | | _ { 2 } ^ { 2 } .
$$

Note that while the regularization term is computed over all nodes in the graph, the supervised loss is computed over labeled nodes only. These methods are expected to work well with consistent graphs, that is graphs where node proximity in the graph is positively correlated with label similarity.

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

# 23.4 Graph Neural Networks

An extensive area of research focuses on defining convolutions over graph data. In the notation of Chami et al. [Cha+21], these (semi-)supervised neighborhood aggregation methods can be represented by an encoder of the form $\mathbf { Z } = \mathrm { E N C } ( \mathbf { X } , \mathbf { W } ; \Theta ^ { E } )$ , and decoders of the form $\widehat { \mathbf { W } } = \mathrm { D E C } ( \mathbf { Z } ; \boldsymbol { \Theta } ^ { D } )$ and/or $\widehat { \boldsymbol { y } } ^ { S } = \mathrm { D E C } ( \mathbf { Z } ; \boldsymbol { \Theta } ^ { S } )$ . There are many models in this family; we review somecof them below.

# 23.4.1 Message passing GNNs

The original graph neural network (GNN) model of [GMS05; Sca+09] was the first formulation of deep learning methods for graph-structured data. It views the supervised graph embedding problem as an information diffusion mechanism, where nodes send information to their neighbors until some stable equilibrium state is reached. More concretely, given randomly initialized node embeddings $\mathbf { Z } ^ { 0 }$ , it applies the following recursion:

$$
\begin{array} { r } { \mathbf { Z } ^ { t + 1 } = \mathrm { E N C } ( \mathbf { X } , \mathbf { W } , \mathbf { Z } ^ { t } ; \Theta ^ { E } ) , } \end{array}
$$

where parameters $\Theta ^ { E }$ are reused at every iteration. After convergence ( $t = T$ ), the node embeddings $\mathbf { Z } ^ { T }$ are used to predict the final output such as node or graph labels:

$$
\hat { y } ^ { S } = \operatorname { D E C } ( \mathbf { X } , \mathbf { Z } ^ { T } ; \boldsymbol { \Theta } ^ { S } ) .
$$

This process is repeated several times and the GNN parameters $\Theta ^ { E }$ and $\Theta ^ { D }$ are learned with backpropagation via the Almeda-Pineda algorithm [Alm87; Pin88]. By Banach’s fixed point theorem, this process is guaranteed to converge to a unique solution when the recursion provides a contraction mapping. In light of this, Scarselli et al. [Sca+09] explore maps that can be expressed using message passing networks:

$$
\mathbf { Z } _ { i } ^ { t + 1 } = \sum _ { \substack { j | ( v _ { i } , v _ { j } ) \in E } } f ( \mathbf { X } _ { i } , \mathbf { X } _ { j } , \mathbf { Z } _ { j } ^ { t } ; \boldsymbol { \Theta } ^ { E } ) ,
$$

where $f ( \cdot )$ is a multi-layer perception (MLP) constrained to be a contraction mapping. The decoder function, however, has no constraints and can be any MLP.

Li et al. [Li+15] propose Gated Graph Sequence Neural Networks (GGSNNs), which remove the contraction mapping requirement from GNNs. In GGSNNs, the recursive algorithm in Equation 23.22 is relaxed by applying mapping functions for a fixed number of steps, where each mapping function is a gated recurrent unit [Cho+14b] with parameters shared for every iteration. The GGSNN model outputs predictions at every step, and so is particularly useful for tasks which have sequential structure (such as temporal graphs).

Gilmer et al. [Gil+17] provide a framework for graph neural networks called message passing neural networks (MPNNs), which encapsulates many recent models. In contrast with the GNN model which runs for an indefinite number of iterations, MPNNs provide an abstraction for modern approaches, which consist of multi-layer neural networks with a fixed number of layers. At every layer $\ell$ , message functions $f ^ { \ell } ( . )$ receive messages from neighbors (based on neighbor’s hidden state),

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022 which are then passed to aggregation functions $h ^ { \ell } ( . )$ :

$$
\begin{array} { l } { { \displaystyle { \bf { m } } _ { i } ^ { \ell + 1 } = \sum _ { j | ( v _ { i } , v _ { j } ) \in E } f ^ { \ell } ( { \bf { H } } _ { i } ^ { \ell } , { \bf { H } } _ { j } ^ { \ell } ) } } \\ { { \displaystyle { \bf { H } } _ { i } ^ { \ell + 1 } = h ^ { \ell } ( { \bf { H } } _ { i } ^ { \ell } , { \bf { m } } _ { i } ^ { \ell + 1 } ) } , } \end{array}
$$

where $\mathbf { H } ^ { 0 } = \mathbf { X }$ . After $\ell$ layers of message passing, nodes’ hidden representations encode information within $\ell$ -hop neighborhoods.

Battaglia et al. [Bat+18] propose GraphNet, which further extends the MPNN framework to learn representations for edges, nodes and the entire graph using message passing functions. The explicit addition of edge and graph representations adds additional expressivity to the MPNN model, and allows the application of graph models to additional domains.

# 23.4.2 Spectral Graph Convolutions

Spectral methods define graph convolutions using the spectral domain of the graph Laplacian matrix. These methods broadly fall into two categories: spectrum-based methods, which explicitly compute an eigendecomposition of the Laplacian (e.g., spectral CNNs [Bru+14]) and spectrum-free methods, which are motivated by spectral graph theory but do not actually perform a spectral decomposition (e.g., Graph convolutional networks or GCN [KW16a]).

A major disadvantage of spectrum-based methods is that they rely on the spectrum of the graph Laplacian and are therefore domain-dependent (i.e. cannot generalize to new graphs). Moreover, computing the Laplacian’s spectral decomposition is computationally expensive. Spectrum-free methods overcome these limitations by utilizing approximations of these spectral filters. However, spectrum-free methods require using the whole graph W, and so do not scale well.

For more details on spectral approaches, see e.g., [Bro+17b; Cha+21].

# 23.4.3 Spatial Graph Convolutions

Spectrum-based methods have an inherent domain dependency which limits the application of a model trained on one graph to a new dataset. Additionally, spectrum-free methods (e.g. GCNs) require using the entire graph A, which can quickly become unfeasible as the size of the graph grows.

To overcome these limitations, another branch of graph convolutions (spatial methods) borrow ideas from standard CNNs – applying convolutions in the spatial domain as defined by the graph topology. For instance, in computer vision, convolutional filters are spatially localized by using fixed rectangular patches around each pixel. Combined with the natural ordering of pixels in images (top, left, bottom, right), it is possible to reuse filters’ weights at every location. This process significantly reduces the total number of parameters needed for a model. While such spatial convolutions cannot directly be applied in graph domains, spatial graph convolutions take inspiration from them. The core idea is to use neighborhood sampling and attention mechanisms to create fixed-size graph patches, overcoming the irregularity of graphs.

# 23.4.3.1 Sampling-based spatial methods

To overcome the domain dependency and storage limitations of GCNs, Hamilton, Ying, and Leskovec [HYL17] propose GraphSAGE, a framework to learn inductive node embeddings. Instead of

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license averaging signals from all one-hop neighbors (via multiplications with the Laplacian matrix), SAGE samples fixed neighborhoods (of size $q$ ) for each node. This removes the strong dependency on fixed graph structure and allows generalization to new graphs. At every SAGE layer, nodes aggregate information from nodes sampled from their neighborhood (see Figure 23.5). In the GraphEDM notation, the propagation rule can be written as:

![](images/12862280b5ea123652fe16bfc802c78400d1ee4e592319243bc99410757c4f95.jpg)  
Figure 23.5: Illustration of the GraphSAGE model. Reprinted with permission from [HYL17].

$$
\mathbf { H } _ { : , i } ^ { \ell + 1 } = \sigma ( \Theta _ { 1 } ^ { \ell } \mathbf { H } _ { : , i } ^ { \ell } + \Theta _ { 2 } ^ { \ell } \mathrm { A G G } ( \{ \mathbf { H } _ { : , j } ^ { \ell } \mid v _ { j } \in \mathrm { S a m p l e } ( \mathrm { n b r } ( v _ { i } ) , q ) \} ) ) ,
$$

where AGG $( \cdot )$ is an aggregation function. This aggregation function can be any permutation invariant operator such as averaging (SAGE-mean) or max-pooling (SAGE-pool). As SAGE works with fixed size neighborhoods (and not the entire adjacency matrix), it also reduces the computational complexity of training GCNs.

# 23.4.3.2 Attention-based spatial methods

Attention mechanisms (Section 15.4) have been successfully used in language models where they, for example, allow models to identify relevant parts of long sequence inputs. Inspired by their success in language, similar ideas have been proposed for graph convolution networks. Such graph-based attention models learn to focus their attention on important neighbors during the message passing step via parametric patches which are learned on top of node features. This provides more flexibility in inductive settings, compared to methods that rely on fixed weights such as GCNs.

The Graph attention network (GAT) model of [Vel+18] is an attention-based version of GCNs. At every GAT layer, it attends over the neighborhood of each node and learns to selectively pick nodes which lead to the best performance for some downstream task. The intuition behind this is similar to SAGE [HYL17] and makes GAT suitable for inductive and transductive problems. However unlike SAGE, which limits the convolution step to fixed size-neighborhoods, GAT allows each node to attend over the entirety of its neighbors – assigning each of them different weights. The attention parameters are trained through backpropagation, and the attention scores are then row-normalized with a softmax activation.

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

# 23.4.3.3 Geometric spatial methods

Monti et al. [Mon+17] propose MoNet, a general framework that works particularly well when the node features lie in a geometric space, such as 3D point clouds or meshes. MoNet learns attention patches using parametric functions in a pre-defined spatial domain (e.g. spatial coordinates), and then applies convolution filters in the resulting graph domain.

MoNet generalizes spatial approaches which introduce constructions for convolutions on manifolds, such as the Geodesic CNN (GCNN) [Mas+15] and the Anisotropic CNN (ACNN) [Bos+16]. Both GCNN and ACNN use fixed patches that are defined on a specific coordinate system and therefore cannot generalize to graph-structured data. However, the MoNet framework is more general; any pseudo-coordinates (i.e. node features) can be used to induce the patches. More formally, if $\mathbf { U } ^ { s }$ are pseudo-coordinates and $\mathbf { H } ^ { \ell }$ are features from another domain, the MoNet layer can be expressed in our notation as:

$$
\mathbf { H } ^ { \ell + 1 } = \sigma \bigg ( \sum _ { k = 1 } ^ { K } ( \mathbf { W } \odot g _ { k } ( \mathbf { U } ^ { s } ) ) \mathbf { H } ^ { \ell } \boldsymbol \Theta _ { k } ^ { \ell } \bigg ) ,
$$

where $g _ { k } ( U ^ { s } )$ are the learned parametric patches, which are $N \times N$ matrices. In practice, MoNet uses Gaussian kernels to learn patches, such that:

$$
g _ { k } ( \mathbf { U } ^ { s } ) = \exp \bigg ( - \frac { 1 } { 2 } ( \mathbf { U } ^ { s } - { \pmb \mu } _ { k } ) ^ { \mathsf { T } } \pmb { \Sigma } _ { k } ^ { - 1 } ( \mathbf { U } ^ { s } - { \pmb \mu } _ { k } ) \bigg ) ,
$$

where $\pmb { \mu } _ { k }$ and $\Sigma _ { k }$ are learned parameters, and $\Sigma _ { k }$ is restricted to be diagonal.

# 23.4.4 Non-Euclidean Graph Convolutions

As we discussed in Section 23.3.3, hyperbolic geometry enables learning of shallow embeddings of hierarchical graphs which have smaller distortion than Euclidean embeddings. However, one major downside of shallow embeddings is that they do not generalize well (if at all) across graphs. On the other hand, Graph Neural Networks, which leverage node features, have achieved good results on many inductive graph embedding tasks.

It is natural then, that there has been recent interest in extending Graph Neural Networks to learn non-Euclidean embeddings. One major challenge in doing so again revolves around the nature of convolution itself. How should we perform convolutions in a non-Euclidean space, where standard operations such as inner products and matrix multiplications are not defined?

Hyperbolic Graph Convolution Networks (HGCN) [Cha+19a] and Hyperbolic Graph Neural Networks (HGNN) [LNK19] apply graph convolutions in hyperbolic space by leveraging the Euclidean tangent space, which provides a first-order approximation of the hyperbolic manifold at a point. For every graph convolution step, node embeddings are mapped to the Euclidean tangent space at the origin, where convolutions are applied, and then mapped back to the hyperbolic space. These approaches yield significant improvements on graphs that exhibit hierarchical structure (Figure 23.6).

# 23.5 Deep graph embeddings

In this section, we use graph neural networks to devise graph embeddings in the unsupervised and semi-supervised cases.

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

![](images/acf61ea7b338833cd1eb59155a4801c27a361b31c84a6388eeaf01ea8922404f.jpg)

![](images/0a13e3a699d29c4d4ff569c69329de35d36d7d6091fd4df50f849e281fb14d0e.jpg)  
Figure 23.6: Euclidean (left) and hyperbolic (right) embeddings of a tree graph. Hyperbolic embeddings learn natural hierarchies in the embedding space (depth indicated by color). Reprinted with permission from [Cha+19a].   
Figure 23.7: Unsupervised graph neural networks. Graph structure and input features are mapped to lowdimensional embeddings using a graph neural network encoder. Embeddings are then decoded to compute a graph regularization loss (unsupervised). Reprinted with permission from [Cha+21].

# 23.5.1 Unsupervised embeddings

In this section, we discuss unsupervised losses for GNNs, as illustrated in Figure 23.7.

# 23.5.1.1 Structural deep network embedding

The structural deep network embedding (SDNE) method of [WCZ16] uses auto-encoders which preserve first and second-order node proximity. The SDNE encoder takes a row of the adjacency matrix as input (setting $s ( \mathbf { W } ) = \mathbf { W }$ ) and produces node embeddings $\mathbf { Z } = \mathrm { E N C } ( \mathbf { W } ; \theta ^ { E } )$ . (Note that this ignores any node features.) The SDNE decoder returns $\widehat { \mathbf { W } } = \mathrm { D E C } ( \mathbf { Z } ; \boldsymbol { \Theta } ^ { D } )$ , a reconstruction trained to recover the original graph adjacency matrix. SDNE prceserves second order node proximity by minimizing the following loss:

$$
| | ( s ( \mathbf { W } ) - \widehat { \mathbf { W } } ) \cdot \mathbb { I } \left( s ( \mathbf { W } ) > 0 \right) | | _ { F } ^ { 2 } + \alpha _ { \mathrm { S D N E } } \sum _ { i j } s ( \mathbf { W } ) _ { i j } | | \mathbf { Z } _ { i } - \mathbf { Z } _ { j } | | _ { 2 } ^ { 2 }
$$

The first term is similar to the matrix factorization regularization objective, except that $\widehat { \bf W }$ is not computed using outer products. The second term is used by distance-based shallow emcbedding methods.

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

# 23.5.1.2 (Variational) graph auto-encoders

Kipf and Welling [KW16b] use graph convolutions (Section 23.4.2) to learn node embeddings $\mathbf { Z } =$ $\mathrm { G C N } ( \mathbf { W } , \mathbf { X } ; \Theta ^ { E } )$ . The decoder is an outer product: $\operatorname { D E C } ( \mathbf { Z } ; \Theta ^ { D } ) = \mathbf { Z } \mathbf { Z } ^ { \scriptscriptstyle 1 }$ . The graph reconstruction term is the sigmoid cross entropy between the true adjacency and the predicted edge similarity scores:

$$
\mathbf { \widetilde { \mu } } _ { \mathrm { ' , R E C O N } } ( \mathbf { W } , \widehat { \mathbf { W } } ; \Theta ) = - \bigg ( \sum _ { i , j } ( 1 - \mathbf { W } _ { i j } ) \mathrm { l o g } ( 1 - \sigma ( \widehat { \mathbf { W } } _ { i j } ) ) + \mathbf { W } _ { i j } \mathrm { l o g } \sigma ( \widehat { \mathbf { W } } _ { i j } ) \bigg ) .
$$

Computing the regularization term over all possible nodes pairs is computationally challenging in practice, so the Graph Auto Encoders (GAE) model uses negative sampling to overcome this challenge.

Whereas GAE is a deterministic model, the authors also introduce variational graph auto-encoders (VGAE), which relies on variational auto-encoders (as in Section 20.3.5) to encode and decode the graph structure. In VGAE, the embedding $\mathbf { Z }$ is modeled as a latent variable with a standard multivariate normal prior $p ( \mathbf { Z } ) = \mathcal { N } ( \mathbf { Z } | \mathbf { 0 } , \mathbf { I } )$ and a graph convolution is used as the amortized inference network, $q _ { \Phi } ( \mathbf { Z } | \mathbf { W } , \mathbf { X } )$ . The model is trained by minimizing the corresponding negative evidence lower bound:

$$
\begin{array} { r l } & { \mathrm { N E L B O } ( \mathbf { W } , \mathbf { X } ; \boldsymbol { \Theta } ) = - \mathbb { E } _ { q _ { \Phi } ( \mathbf { Z } | \mathbf { W } , \mathbf { X } ) } [ \log p ( \mathbf { W } | \mathbf { Z } ) ] + \mathrm { K L } ( q _ { \Phi } ( \mathbf { Z } | \mathbf { W } , \mathbf { X } ) | | p ( \mathbf { Z } ) ) } \\ & { \qquad = \mathcal { L } _ { G , \mathrm { R E C O N } } ( \mathbf { W } , \widehat { \mathbf { W } } ; \boldsymbol { \Theta } ) + \mathrm { K L } ( q _ { \Phi } ( \mathbf { Z } | \mathbf { W } , \mathbf { X } ) | | p ( \mathbf { Z } ) ) . } \end{array}
$$

# 23.5.1.3 Iterative generative modelling of graphs (Graphite)

The graphite model of [GZE19] extends GAE and VGAE by introducing a more complex decoder. This decoder iterates between pairwise decoding functions and graph convolutions, as follows:

$$
\begin{array} { c } { \widehat { \mathbf { W } } ^ { ( k ) } = \displaystyle \frac { \mathbf { Z } ^ { ( k ) } \mathbf { Z } ^ { ( k ) } } { | | \mathbf { Z } ^ { ( k ) } | | _ { 2 } ^ { 2 } } + \frac { \mathbf { 1 1 } ^ { \top } } { N } } \\ { \mathbf { Z } ^ { ( k + 1 ) } = \operatorname { G C N } ( \widehat { \mathbf { W } } ^ { ( k ) } , \mathbf { Z } ^ { ( k ) } ) } \end{array}
$$

where $\mathbf { Z } ^ { ( 0 ) }$ is initialized using the output of the encoder network. This process allows Graphite to learn more expressive decoders. Finally, similar to GAE, Graphite can be deterministic or variational.

# 23.5.1.4 Methods based on contrastive losses

The deep graph infomax method of [Vel+19] is a GAN-like method for creating graph-level embeddings. Given one or more real (positive) graphs, each with its adjacency matrix $\mathbf { W } \in \mathbb { R } ^ { N \times N }$ and node features $\mathbf { X } \in \mathbb { R } ^ { N \times D }$ , this method creates fake (negative) adjacency matrices $\mathbf { W } ^ { - } \in \mathbb { R } ^ { N ^ { - } \times N ^ { - } }$ and their features $X ^ { - } \in \mathbb { R } ^ { N ^ { - } \times D }$ . It trains (i) an encoder that processes both real and fake samples, respectively giving $Z = \mathrm { E N C } ( \mathbf { X } , \mathbf { W } ; \boldsymbol { \Theta } ^ { E } ) \in \mathbb { R } ^ { N \times L }$ and $\mathbf { Z } ^ { - } = \mathrm { E N C } ( \mathbf { X } ^ { - } , \mathbf { W } ^ { - } ; \boldsymbol { \Theta } ^ { E } ) \in \mathbb { R } ^ { N ^ { - } \times L }$ , (ii) a (readout) graph pooling function $\mathcal { R } : \mathbb { R } ^ { N \times L }  \mathbb { R } ^ { L }$ , and (iii) a descriminator function $\mathcal { D } : \mathbb { R } ^ { L } \times \mathbb { R } ^ { L } \to$ $[ 0 , 1 ]$ which is trained to output $\mathcal { D } ( \mathbf { Z } _ { i } , \mathcal { R } ( \mathbf { Z } ) ) \approx 1$ and $\begin{array} { r } { \mathcal { D } ( \mathbf { Z } _ { j } ^ { - } , \mathcal { R } ( \mathbf { Z } ^ { - } ) ) \approx 0 } \end{array}$ , respectively, for nodes

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license corresponding to given graph $i \in V$ and fake graph $j \in V ^ { - }$ . Specifically, DGI optimizes:

$$
\operatorname* { m i n } _ { \Theta } - \underset { \mathbf { X } , \mathbf { W } } { \mathbb { E } } \sum _ { i = 1 } ^ { N } \log \mathcal { D } ( \mathbf { Z } _ { i } , \mathcal { R } ( \mathbf { Z } ) ) - \underset { \mathbf { X } - \mathbf { W } - \mathbf { \Sigma } } { \mathbb { E } } \sum _ { j = 1 } ^ { N ^ { - } } \log \left( 1 - \mathcal { D } ( \mathbf { Z } _ { j } ^ { - } , \mathcal { R } ( \mathbf { Z } ^ { - } ) ) \right) ,
$$

where $\Theta$ contains $\Theta ^ { E }$ and the parameters of $\mathcal { R } , \mathcal { D }$ . In the first expectation, DGI samples from the real (positive) graphs. If only one graph is given, it could sample some subgraphs from it (e.g. connected components). The second expectation samples fake (negative) graphs. In DGI, fake samples use the real adjacency $W ^ { - } : = W$ but fake features $X ^ { - }$ are a row-wise random permutation of real $X$ . The ENC used in DGI is a graph convolutional network, though any GNN can be used. The readout $\mathcal { R }$ summarizes an entire (variable-size) graph to a single (fixed-dimension) vector. Veličković et al. [Vel+19] use $\mathcal { R }$ as a row-wise mean, though other graph pooling might be used e.g. ones aware of the adjacency.

The optimization of Equation (23.34) is shown by [Vel+19] to maximize a lower-bound on the mutual information between the outputs of the encoder and the graph pooling function, i.e., between individual node representations and the graph representation.

In [Pen+20] they present a variant called Graphical Mutual Information. Rather than maximizing MI of node information and an entire graph, GMI maximizes the MI between the representation of a node and its neighbors.

# 23.5.2 Semi-supervised embeddings

In this section, we discuss semi-supervised losses for GNNs. We consider the simple special case in which we use a nonlinear encoder of the node features, but ignore the graph structure, i.e., we use $\mathbf { Z } = \mathrm { E N C } ( \mathbf { X } ; \boldsymbol { \Theta } ^ { E } )$ .

# 23.5.2.1 SemiEmb

[WRC08] propose an approach called semi-supervised embeddings (SemiEmb) They use an MLP for the encoder of $\mathbf { X }$ . For the decoder, we can use a distance-based graph decoder: $\widehat { \bf W } _ { i j } =$ $\mathrm { D E C } ( \mathbf { Z } ; \Theta ^ { D } ) _ { i j } = | | \mathbf { Z } _ { i } - \mathbf { Z } _ { j } | | ^ { 2 }$ , where $| | \cdot | |$ can be the L2 or L1 norm.

SemiEmb regularizes intermediate or auxiliary layers in the network using the same regularizer as the label propagation loss in Equation (23.19). SemiEmb uses a feed forward network to predict labels from intermediate embeddings, which are then compared to ground truth labels using the Hinge loss.

# 23.5.2.2 Planetoid

Unsupervised skip-gram methods like DeepWalk and node2vec learn embeddings in a multi-step pipeline, where random walks are first generated from the graph and then used to learn embeddings. These embeddings are likely not optimal for downstream classification tasks. The Planetoid method of [YCS16] extends such random walk methods to leverage node label information during the embedding algorithm.

Planetoid first maps nodes to embeddings ${ \bf Z } = [ { \bf Z } ^ { c } | | { \bf Z } ^ { F } ] = \mathrm { E N C } ( { \bf X } ; \Theta ^ { E } )$ using a neural network (again ignoring graph structure). The node embeddings ${ \bf Z } ^ { c }$ capture structural information while the

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022 node embeddings ${ \bf Z } ^ { F }$ capture feature information. There are two variants, a transductive version that directly learns ${ \bf Z } ^ { c }$ (as an embedding lookup), and an inductive model where ${ \bf Z } ^ { c }$ is computed with parametric mappings that act on input features $\mathbf { X }$ . The Planetoid objective contains both a supervised loss and a graph regularization loss. The graph regularization loss measures the ability to predict context using nodes embeddings:

$$
\mathcal { L } _ { G , \mathrm { R E C O N } } ( \mathbf { W } , \widehat { \mathbf { W } } ; \Theta ) = - \mathbb { E } _ { ( i , j , \gamma ) } \log \sigma \left( \gamma \widehat { \mathbf { W } } _ { i j } \right) ,
$$

with $\widehat { \mathbf { W } } _ { i j } = \mathbf { Z } _ { i } ^ { \top } \mathbf { Z } _ { j }$ and $\gamma \in \{ - 1 , 1 \}$ with $\gamma = 1$ if $( v _ { i } , v _ { j } ) \in E$ is a positive pair and $\gamma = - 1$ if $( v _ { i } , v _ { j } )$ is a necgative pair. The distribution under the expectation is directly defined through a sampling process

The supervised loss in Planetoid is the negative log-likelihood of predicting the correct labels:

$$
\mathcal { L } _ { \mathrm { S U P } } ^ { N } ( \boldsymbol { y } ^ { N } , \widehat { \boldsymbol { y } } ^ { N } ; \boldsymbol { \Theta } ) = - \frac { 1 } { | V _ { L } | } \sum _ { i | v _ { i } \in V _ { L } } \sum _ { 1 \leq k \leq C } y _ { i k } ^ { N } \mathrm { l o g } \widehat { y } _ { i k } ^ { N } ,
$$

where $i$ is a node’s index while $k$ indicates label classes, and $\widehat { y } _ { i } ^ { N }$ are computed using a neural network followed by a softmax activation, mapping $\mathbf { Z } _ { i }$ to predicted lbabels.

# 23.6 Applications

There are many applications of graph embeddings, both unsupervised and supervised. We give some examples in the sections below.

# 23.6.1 Unsupervised applications

In this section, we discuss common unsupervised applications.

# 23.6.1.1 Graph reconstruction

A popular unsupervised graph application is graph reconstruction. In this setting, the goal is to learn mapping functions (which can be parametric or not) that map nodes onto a manifold which can reconstruct the graph. This is regarded as unsupervised in the sense that there is no supervision beyond the graph structure. Models can be trained by minimizing a reconstruction error, which is the error in recovering the original graph from learned embeddings. Several algorithms were designed specifically for this task, and we refer to Section 23.3.1 and Section 23.5.1 for some examples of reconstruction objectives. At a high level, graph reconstruction is similar to dimensionality reduction in the sense that the main goal is to summarize some input data into a low-dimensional embedding. Instead of compressing high dimensional vectors into low-dimensional ones as standard dimensionality reduction methods (e.g. PCA) do, the goal of graph reconstruction models is to compress data defined on graphs into low-dimensional vectors.

# 23.6.1.2 Link prediction

The goal in link prediction is to predict missing or unobserved links (e.g., links that may appear in the future for dynamic and temporal networks). Link prediction can also help identify spurious

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license links and remove them. It is a major application of graph learning models in industry, and common example of applications include predicting friendships in social networks predicting user-product interactions in recommendation systems, predicting suspicious links in a fraud detection system (see Figure 23.8), or predicting missing relationships between entities in a knowledge graph (see e.g., [Nic+15]).

![](images/8558e75295a029393536416556931966ea6c7244c0730551836fb91026f5699e.jpg)  
Figure 23.8: A graph representation of some financial transactions. Adapted from http: // pgql-lang. org/ spec/ 1. 2/ .

A common approach for training link prediction models is to mask some edges in the graph (positive and negative edges), train a model with the remaining edges and then test it on the masked set of edges. Note that link prediction is different from graph reconstruction. In link prediction, we aim at predicting links that are not observed in the original graph while in graph reconstruction, we only want to compute embeddings that preserve the graph structure through reconstruction error minimization.

Finally, while link prediction has similarities with supervised tasks in the sense that we have labels for edges (positive, negative, unobserved), we group it under the unsupervised class of applications since edge labels are usually not used during training, but only used to measure the predictive quality of embeddings.

# 23.6.1.3 Clustering

Clustering is particularly useful for discovering communities and has many real-world applications. For instance, clusters exist in biological networks (e.g. as groups of proteins with similar properties), or in social networks (e.g. as groups of people with similar interests).

The unsupervised methods introduced in this chapter can be used to solve clustering problems

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

by applying the clustering algorithm (e.g. k-means) to embeddings that are output by an encoder. Further, clustering can be joined with the learning algorithm while learning a shallow [Roz+19] or Graph Convolution [Chi+19a; CEL19] embedding model.

# 23.6.1.4 Visualization

There are many off-the-shelf tools for mapping graph nodes onto two-dimensional manifolds for the purpose of visualization. Visualizations allow network scientists to qualitatively understand graph properties, understand relationships between nodes or visualize node clusters. Among the popular tools are methods based on Force-Directed Layouts, with various web-app Javascript implementations.

Unsupervised graph embedding methods are also used for visualization purposes: by first training an encoder-decoder model (corresponding to a shallow embedding or graph convolution network), and then mapping every node representation onto a two-dimensional space using t-SNE (Section 20.4.10) or PCA (Section 20.1). Such a process (embedding $$ dimensionality reduction) is commonly used to qualitatively evaluate the performance of graph learning algorithms. If nodes have attributes, one can use these attributes to color the nodes on 2D visualization plots. Good embedding algorithms embed nodes that have similar attributes nearby in the embedding space, as demonstrated in visualizations of various methods [PARS14; KW16a; AEH+18]. Finally, beyond mapping every node to a 2D coordinate, methods which map every graph to a representation [ARZP19] can similarly be projected into two dimensions to visualize and qualitatively analyze graph-level properties.

# 23.6.2 Supervised applications

In this section, we discuss common supervised applications.

# 23.6.2.1 Node classification

Node classification is an important supervised graph application, where the goal is to learn node representations that can accurately predict node labels. (This is sometimes called statistical relational learning [GT07].) For instance, node labels could be scientific topics in citation networks, or gender and other attributes in social networks.

Since labeling large graphs can be time-consuming and expensive, semi-supervised node classification is a particularly common application. In semi-supervised settings, only a fraction of nodes are labeled and the goal is to leverage links between nodes to predict attributes of unlabeled nodes. This setting is transductive since there is only one partially labeled fixed graph. It is also possible to do inductive node classification, which corresponds to the task of classifying nodes in multiple graphs.

Note that node features can significantly boost the performance on node classification tasks if these are descriptive for the target label. Indeed, recent methods such as GCN (Section 23.4.2) GraphSAGE (Section 23.4.3.1) have achieved state-of-the-art performance on multiple node classification benchmarks due to their ability to combine structural information and semantics coming from features. On the other hand, other methods such as random walks on graphs fail to leverage feature information and therefore achieve lower performance on these tasks.

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

![](images/98effee79226da2fa2699e8fa32659ff51719ca30d8535a6716385101de33218.jpg)  
Figure 23.9: Structurally similar molecules do not necessarily have similar odor descriptors. (A) Lyral, the reference molecule. (B) Molecules with similar structure can share similar odor descriptors. $( C )$ However, a small structural change can render the molecule odorless. (D) Further, large structural changes can leave the odor of the molecule largely unchanged. From Figure 1 of $I S L + { \cal { I } } 9 { \cal { J } }$ , originally from [OPK12]. Used with kind permission of Benjamin Sanchez-Lengeling.

# 23.6.2.2 Graph classification

Graph classification is a supervised application where the goal is to predict graph labels. Graph classification problems are inductive and a common example is classifying chemical compounds (e.g. predicting toxicity or odor from a molecule, as shown in Figure 23.9).

Graph classification requires some notion of pooling, in order to aggregate node-level information into graph-level information. As discussed earlier, generalizing this notion of pooling to arbitrary graphs is non trivial because of the lack of regularity in the graph structure making graph pooling an active research area. In addition to the supervised methods discussed above, a number of unsupervised methods for learning graph-level representations have been proposed [Tsi+18; ARZP19; TMP20].

# A Notation

# A.1 Introduction

It is very difficult to come up with a single, consistent notation to cover the wide variety of data, models and algorithms that we discuss in this book. Furthermore, conventions differ between different fields (such as machine learning, statistics and optimization), and between different books and papers within the same field. Nevertheless, we have tried to be as consistent as possible. Below we summarize most of the notation used in this book, although individual sections may introduce new notation. Note also that the same symbol may have different meanings depending on the context, although we try to avoid this where possible.

# A.2 Common mathematical symbols

We list some common symbols below.

<html><body><table><tr><td>Symbol</td><td>Meaning</td></tr><tr><td>8</td><td>Infinity</td></tr><tr><td>→</td><td>Tends towards, e.g., n → 0</td></tr><tr><td>8</td><td>Proportional to, so y = ax can be written as y x x</td></tr><tr><td></td><td>Defined as</td></tr><tr><td>0(.)</td><td>Big-O:roughly means order of magnitude</td></tr><tr><td>Z+</td><td>The positive integers</td></tr><tr><td>R</td><td>The real numbers</td></tr><tr><td>R+ SK</td><td>The positive reals</td></tr><tr><td>S+</td><td>The K-dimensional probability simplex Cone of positive definite D × D matrices</td></tr><tr><td>~</td><td>Approximately equal to</td></tr><tr><td>{1,...,N}</td><td>The finite set {1,2,...,N}</td></tr><tr><td>1:N</td><td>The finite set {1,2,...,N}</td></tr><tr><td>[e,u]</td><td>The continuous interval {l ≤ x ≤u}.</td></tr></table></body></html>

# A.3 Functions

Generic functions will be denoted by $f$ (and sometimes $g$ or $h$ ). We will encounter many named functions, such as $\operatorname { t a n h } ( x )$ or $\sigma ( x )$ . A scalar function applied to a vector is assumed to be applied elementwise, e.g., $\pmb { x } ^ { 2 } = [ x _ { 1 } ^ { 2 } , \dots , x _ { D } ^ { 2 } ]$ . Functionals (functions of a function) are written using “blackboard” font, e.g., $\mathbb H ( p )$ for the entropy of a distribution $p$ . A function parameterized by fixed parameters $\pmb \theta$ will be denoted by $f ( { \pmb x } ; { \pmb \theta } )$ or sometimes $f _ { \boldsymbol { \theta } } ( \boldsymbol { x } )$ . We list some common functions (with no free parameters) below.

# A.3.1 Common functions of one argument

<html><body><table><tr><td>Symbol</td><td>Meaning</td></tr><tr><td>x [:x]</td><td>Floor of x,i.e.,round down to nearest integer Ceiling of x,i.e., round up to nearest integer</td></tr><tr><td>-a I(x)</td><td>logical NOT Indicator function,I(x)= 1 if x is true,else I(x)= O</td></tr><tr><td>8(x） |x|</td><td>Dirac delta function,δ(x)= o if x = O,else δ(x) = 0 Absolutevalue</td></tr><tr><td>|S| n!</td><td>Size (cardinality) of a set</td></tr><tr><td></td><td>Factorial function</td></tr><tr><td>log(x)</td><td>Natural logarithm of x</td></tr><tr><td>exp(x)</td><td></td></tr><tr><td>Γ(x)</td><td>Exponential function ex</td></tr><tr><td></td><td>Gamma function, Γ(x)= So 2 du</td></tr><tr><td>亚（x)</td><td></td></tr><tr><td></td><td>d logΓ(x) Digamma function, 亚(x) = d 1</td></tr><tr><td>σ(x)</td><td>Sigmoid (logistic) function, 1+e-x</td></tr></table></body></html>

# A.3.2 Common functions of two arguments

A.3.3 Common functions of $> 2$ arguments   

<html><body><table><tr><td>Symbol</td><td>Meaning</td></tr><tr><td>a>b</td><td>logical AND</td></tr><tr><td>avb</td><td>logical OR</td></tr><tr><td>B(a,b)</td><td>T(a+b) Beta function, B(a,b) = Γ(@)r(b)</td></tr><tr><td>(）</td><td>n choose k,equal to n!/(k!(n -k)!)</td></tr><tr><td>8ij</td><td>Kronecker delta,equals I(i = j)</td></tr><tr><td>uov</td><td>Elementwise product of two vectors</td></tr><tr><td>uv</td><td>Convolution of two vectors</td></tr></table></body></html>

<html><body><table><tr><td>Symbol</td><td>Meaning</td></tr><tr><td>B(xc)</td><td>Multivariate beta function, 1kΓ(xk)</td></tr><tr><td>Γ(xc)</td><td>(∑xk) Multi. gamma function,πD(D-1)/4 IId=1Γ(x + (1-d)/2)</td></tr></table></body></html>

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

softmax(x) Softmax function, $\big [ \frac { e ^ { x _ { c } } } { \sum _ { c ^ { \prime } = 1 } ^ { C } e ^ { x _ { c ^ { \prime } } } } \big ] _ { c = 1 } ^ { C }$

# A.4 Linear algebra

In this section, we summarize the notation we use for linear algebra (see Chapter 7 for details).

# A.4.1 General notation

Vectors are bold lower case letters such as $_ { x }$ , $\mathbf { \boldsymbol { w } }$ . Matrices are bold upper case letters, such as $\mathbf { X }$ , $\mathbf { W }$ . Scalars are non-bold lower case. When creating a vector from a list of $N$ scalars, we write $\pmb { x } = [ x _ { 1 } , \dots , x _ { N } ]$ ; this may be a column vector or a row vector, depending on the context. (Vectors are assumed to be column vectors, unless noted otherwise.) When creating an $M \times N$ matrix from a list of vectors, we write $\mathbf { X } = [ \pmb { x } _ { 1 } , \dots , \pmb { x } _ { N } ]$ if we stack along the columns, or $\mathbf { X } = [ \pmb { x } _ { 1 } ; \dots ; \pmb { x } _ { M } ]$ if we stack along the rows.

# A.4.2 Vectors

Here is some standard notation for vectors. (We assume $\mathbf { \Delta } _ { \mathbf { u } }$ and $\mathbf { \nabla } _ { \mathbf { v } }$ are both $N$ -dimensional vectors.)

<html><body><table><tr><td>Symbol</td><td>Meaning</td></tr><tr><td>uu</td><td>Inner (scalar) product, ∑i=1 uUi</td></tr><tr><td>uuT</td><td>Outer product (N × N matrix)</td></tr><tr><td>uov</td><td>Elementwise product,[u1U1,...,uN UN]</td></tr><tr><td>UT dim(v)</td><td>Transpose of v</td></tr><tr><td>diag(v)</td><td>Dimensionality of v (namely N) Diagonal N × N matrix made from vector v</td></tr><tr><td>1 or 1N</td><td>Vector of ones (of length N)</td></tr><tr><td>O or ON</td><td>Vector of zeros (of length N)</td></tr><tr><td>||| = ||||2</td><td>Euclidean or l2 norm √∑N-1 0²</td></tr><tr><td>||u||1</td><td>l1 norm∑1luil</td></tr></table></body></html>

# A.4.3 Matrices

Here is some standard notation for matrices. (We assume $\mathbf { s }$ is a square $N \times N$ matrix, $\mathbf { X }$ and $\mathbf { Y }$ are of size $M \times N$ , and $\mathbf { Z }$ is of size $M ^ { \prime } \times N ^ { \prime }$ .)

<html><body><table><tr><td>Symbol</td><td>Meaning</td></tr><tr><td>X.j</td><td>j'th column of matrix</td></tr><tr><td>Xi</td><td>i'th row of matrix (treated as a column vector)</td></tr><tr><td>sYo Xij</td><td>Element (i,j) of matrix</td></tr><tr><td>tr(S)</td><td>True iff S is a positive definite matrix</td></tr><tr><td>det(S)</td><td>Trace of a square matrix</td></tr><tr><td>|S|</td><td>Determinant of a square matrix Determinant of a square matrix</td></tr></table></body></html>

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

$\mathbf { S } ^ { - 1 }$ Inverse of a square matrix   
$\mathbf { X } ^ { \dagger }$ Pseudo-inverse of a matrix   
$\mathbf { X } ^ { \top }$ Transpose of a matrix   
$\mathrm { d i a g } ( \mathbf { S } )$ Diagonal vector extracted from square matrix   
I or ${ \mathbf { I } } _ { N }$ Identity matrix of size $N \times N$   
$\mathbf { X } \odot \mathbf { Y }$ Elementwise product   
$\mathbf { X } \otimes \mathbf { Z }$ Kronecker product (see Section 7.2.5)

# A.4.4 Matrix calculus

In this section, we summarize the notation we use for matrix calculus (see Section 7.8 for details). Let $\pmb \theta \in \mathbb { R } ^ { N }$ be a vector and $f : \mathbb { R } ^ { N }  \mathbb { R }$ be a scalar valued function. The derivative of $f$ wrt its argument is denoted by the following:

$$
\begin{array} { r } { \nabla _ { \pmb { \theta } } f ( \pmb { \theta } ) \triangleq \nabla f ( \pmb { \theta } ) \triangleq \nabla f \triangleq \bigg ( \frac { \partial f } { \partial \theta _ { 1 } } \quad \cdot \cdot \cdot \quad \frac { \partial f } { \partial \theta _ { N } } \bigg ) } \end{array}
$$

The gradient is a vector that must be evaluated at a point in space. To emphasize this, we will sometimes write

$$
\pmb { g } _ { t } \triangleq \pmb { g } ( \pmb { \theta } _ { t } ) \triangleq \nabla f ( \pmb { \theta } ) \bigg \rvert _ { \pmb { \theta } _ { t } }
$$

We can also compute the (symmetric) $N \times N$ matrix of second partial derivatives, known as the Hessian:

$$
\nabla ^ { 2 } f \triangleq \left( \begin{array} { c c c } { \frac { \partial ^ { 2 } f } { \partial \theta _ { 1 } ^ { 2 } } } & { \cdot \cdot \cdot } & { \frac { \partial ^ { 2 } f } { \partial \theta _ { 1 } \partial \theta _ { N } } } \\ & { \vdots } \\ { \frac { \partial ^ { 2 } f } { \partial \theta _ { N } \theta _ { 1 } } } & { \cdot \cdot \cdot } & { \frac { \partial ^ { 2 } f } { \partial \theta _ { N } ^ { 2 } } } \end{array} \right)
$$

The Hessian is a matrix that must be evaluated at a point in space. To emphasize this, we will sometimes write

$$
\begin{array} { r } { \mathbf { H } _ { t } \triangleq \mathbf { H } ( \pmb { \theta } _ { t } ) \triangleq \nabla ^ { 2 } f ( \pmb { \theta } ) \Bigg \rvert _ { \pmb { \theta } _ { t } } } \end{array}
$$

# A.5 Optimization

In this section, we summarize the notation we use for optimization (see Chapter 8 for details).

We will often write an objective or cost function that we wish to minimize as $\mathcal { L } ( \pmb { \theta } )$ , where $\pmb \theta$ are the variables to be optimized (often thought of as parameters of a statistical model). We denote the parameter value that achieves the minimum as $\theta _ { * } = \mathrm { a r g m i n } _ { \theta \in \Theta } \mathcal { L } ( \theta )$ , where $\Theta$ is the set we are optimizing over. (Note that there may be more than one such optimal value, so we should really write $\theta _ { * } \in \mathrm { a r g m i n } _ { \theta \in \Theta } \mathcal { L } ( \theta )$ .)

When performing iterative optimization, we use $t$ to index the iteration number. We use $\eta$ as a step size (learning rate) parameter. Thus we can write the gradient descent algorithm (explained in Section 8.4) as follows: $\pmb { \theta } _ { t + 1 } = \pmb { \theta } _ { t } - \eta _ { t } \pmb { g } _ { t }$ .

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

We often use a hat symbol to denote an estimate or prediction (e.g., $\hat { \pmb { \theta } }$ , $\hat { y }$ ), a star subscript or superscript to denote a true (but usually unknown) value (e.g., $\pmb { \theta } _ { \ast }$ or $\pmb { \theta } ^ { * }$ ), an overline to denote a mean value (e.g., $\overline { { \pmb { \theta } } }$ ).

# A.6 Probability

n this section, we summarize the notation we use for probability theory (see Chapter 2 for details)

We denote a probability density function (pdf) or probability mass function (pmf) by $p$ , a cumulative distribution function (cdf) by $P$ , and the probability of a binary event by Pr. We write $p ( X )$ for the distribution for random variable $X$ , and $p ( Y )$ for the distribution for random variable $Y$ — these refer to different distributions, even though we use the same $p$ symbol in both cases. (In cases where confusion may arise, we write $p _ { X } ( \cdot )$ and $p _ { Y } ( \cdot )$ .) Approximations to a distribution $p$ will often be represented by $q$ , or sometimes $\hat { p }$ .

In some cases, we distinguish between a random variable (rv) and the values it can take on. In this case, we denote the variable in upper case (e.g., $X$ ), and its value in lower case (e.g., $x$ ). However, we often ignore this distinction between variables and values. For example, we sometimes write $p ( x )$ to denote either the scalar value (the distribution evaluated at a point) or the distribution itself, depending on whether $X$ is observed or not.

We write $X \sim p$ to denote that $X$ is distributed according to distribution $p$ . We write $X \perp Y \mid Z$ to denote that $X$ is conditionally independent of $Y$ given $Z$ . If $X \sim p$ , we denote the expected value of $f ( X )$ using

$$
\operatorname { \mathbb { E } } \left[ f ( X ) \right] = \operatorname { \mathbb { E } } _ { p ( X ) } \left[ f ( X ) \right] = \operatorname { \mathbb { E } } _ { X } \left[ f ( X ) \right] = \int _ { x } f ( x ) p ( x ) d x
$$

If $f$ is the identity function, we write ${ \overline { { X } } } \triangleq \mathbb { E } \left[ X \right]$ . Similarly, the variance is denoted by

$$
\mathbb { V } \left[ f ( X ) \right] = \mathbb { V } _ { p ( X ) } \left[ f ( X ) \right] = \mathbb { V } _ { X } \left[ f ( X ) \right] = \int _ { x } ( f ( x ) - \mathbb { E } \left[ f ( X ) \right] ) ^ { 2 } p ( x ) d x
$$

If $_ { x }$ is a random vector, the covariance matrix is denoted

$$
\operatorname { C o v } \left[ { \pmb x } \right] = \mathbb { E } \left[ ( { \pmb x } - { \overline { { \pmb x } } } ) ( { \pmb x } - { \overline { { \pmb x } } } ) ^ { \top } \right]
$$

If $X \sim p$ , the mode of a distribution is denoted by

$$
{ \hat { x } } = { \mathrm { m o d e } } \left[ p \right] = \operatorname { a r g m a x } _ { x } p ( x )
$$

We denote parametric distributions using $p ( { \boldsymbol { \mathbf { \mathit { x } } } } | \mathbf { \boldsymbol { \theta } } )$ , where $_ { x }$ are the random variables, $\pmb \theta$ are the parameters and $p$ is a pdf or pmf. For example, $\mathcal { N } ( x | \mu , \sigma ^ { 2 } )$ is a Gaussian (normal) distribution with mean $\mu$ and standard deviation $\sigma$ .

# A.7 Information theory

In this section, we summarize the notation we use for information theory (see Chapter 6 for details). If $X \sim p$ , we denote the (differential) entropy of the distribution by $\mathbb { H } \left( X \right)$ or $\mathbb { H } \left( p \right)$ . If $Y \sim q$ , we denote the KL divergence from distribution $p$ to $q$ by $D _ { \mathbb { K L } } \left( p \parallel q \right)$ . If $( X , Y ) \sim p$ , we denote the mutual information between $X$ and $Y$ by $\mathbb { I } \left( X ; Y \right)$ .

Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

# A.8 Statistics and machine learning

We briefly summarize the notation we use for statistical learning.

# A.8.1 Supervised learning

For supervised learning, we denote the observed features (also called inputs or covariates) by $\mathbf { \boldsymbol { x } } \in \mathcal { X }$ . Often $\boldsymbol { \mathcal { X } } = \mathbb { R } ^ { D }$ , meaning the features are real-valued. (Note that this includes the case of discrete-valued inputs, which can be represented as one-hot vectors.) Sometimes we compute manually-specified features of the input; we denote these by $\phi ( { \pmb x } )$ . We also have outputs (also called targets or response variables) $\pmb { y } \in \mathcal { V }$ that we wish to predict. Our task is to learn a conditional probability distribution $p ( \pmb { y } | \pmb { x } , \pmb \theta )$ , where $\pmb \theta$ are the parameters of the model. If $\mathcal { Y } = \{ 1 , \ldots , C \}$ , we call this classification. If $\mathcal { V } = \mathbb { R } ^ { C }$ , we call this regression (often $C = 1$ , so we are just predicting a scalar response).

The parameters $\pmb \theta$ are estimated from training data, denoted by $\mathcal { D } = \{ ( \pmb { x } _ { n } , \pmb { y } _ { n } ) : n \in \{ 1 , \dots , N _ { \mathcal { D } } \} \}$ (so $N _ { \mathcal { D } }$ is the number of training cases). If $\boldsymbol { \mathcal { X } } = \mathbb { R } ^ { D }$ , we can store the training inputs in an $N _ { \mathcal { D } } \times D$ design matrix denoted by $\mathbf { X }$ . If $\mathcal { V } = \mathbb { R } ^ { C }$ , we can store the training outputs in an $N _ { \mathcal { D } } \times C$ matrix $\mathbf { Y }$ . If $\mathcal { Y } = \{ 1 , \ldots , C \}$ , we can represent each class label as a $C$ -dimensional bit vector, with one element turned on (this is known as a one-hot encoding), so we can store the training outputs in an $N _ { \mathit { D } } \times C$ binary matrix $\mathbf { Y }$ .

# A.8.2 Unsupervised learning and generative models

Unsupervised learning is usually formalized as the task of unconditional density estimation, namely modeling $p ( { \pmb x } | { \pmb \theta } )$ . In some cases, we want to perform conditional density estimation; we denote the values we are conditioning on by $\mathbf { \Delta } _ { \mathbf { u } }$ , so the model becomes $p ( \pmb { x } | \pmb { u } , \pmb \theta )$ . This is similar to supervised learning, except that $_ { x }$ is usually high dimensional (e.g., an image) and $\mathbf { \Delta } _ { \mathbf { u } }$ is usually low dimensional (e.g., a class label or a text description).

In some models, we have latent variables, also called hidden variables, which are never observed in the training data. We call such models latent variable models (LVM). We denote the latent variables for data case $n$ by $z _ { n } \in { \mathcal { Z } }$ . Sometimes latent variables are known as hidden variables, and are denoted by $\scriptstyle h _ { n }$ . By contrast, the visible variables will be denoted by ${ \pmb v } _ { n }$ . Typically the latent variables are continuous or discrete, i.e., $\mathcal { Z } = \mathbb { R } ^ { L }$ or $\mathcal { Z } = \{ 1 , \ldots , K \}$ .

Most LVMs have the form $p ( \pmb { x } _ { n } , z _ { n } | \pmb { \theta } )$ ; such models can be used for unsupervised learning. However, LVMs can also be used for supervised learning. In particular, we can either create a generative (unconditional) model of the form $p ( \pmb { x } _ { n } , \pmb { y } _ { n } , z _ { n } | \pmb { \theta } )$ , or a discriminative (conditional) model of the form $p ( \pmb { y } _ { n } , \pmb { z } _ { n } | \pmb { x } _ { n } , \pmb { \theta } )$ .

# A.8.3 Bayesian inference

When working with Bayesian inference, we write the prior over the parameters as $p ( \pmb \theta | \phi )$ , where $\phi$ are the hyperparameters. For conjugate models, the posterior has the same form as the prior (by definition). We can therefore just update the hyperparameters from their prior value, $\breve { \phi }$ , to their posterior value, $\hat { \phi }$ .

Draft of “Probabilistic Machine Learning: An Introduction”. August 8, 2022

In variational inference (Section 4.6.8.3), we use $\psi$ to represent the parameters of the variational posterior, i.e., $p ( \pmb \theta | \mathcal { D } ) \approx q ( \pmb \theta | \psi )$ . We optimize the ELBO wrt $\psi$ to make this a good approximation. When performing Monte Carlo sampling, we use a $s$ subscript or superscript to denote a sample (e.g., $\pmb { \theta } _ { s }$ or $\pmb { \theta } ^ { s }$ ).

# A.9 Abbreviations

Here are some of the abbreviations used in the book.

<html><body><table><tr><td>Abbreviation</td><td>Meaning</td></tr><tr><td>cdf</td><td>Cumulative distribution function</td></tr><tr><td>CNN</td><td>Convolutional neural network</td></tr><tr><td>DAG</td><td>Directed acyclic graph</td></tr><tr><td>DML</td><td>Deep metric learning</td></tr><tr><td>DNN</td><td>Deep neural network</td></tr><tr><td>d.o.f.</td><td>Degrees of freedom</td></tr><tr><td>EB</td><td>Empirical Bayes</td></tr><tr><td>EM</td><td>Expectation maximization algorithm</td></tr><tr><td>GLM</td><td>Generalized linear model</td></tr><tr><td>GMM</td><td>Gaussian mixture model</td></tr><tr><td>HMC</td><td>Hamiltonian Monte Carlo</td></tr><tr><td>HMM</td><td>Hidden Markov model</td></tr><tr><td>i.i.d.</td><td>Independent and identically distributed</td></tr><tr><td>iff</td><td>If and only if</td></tr><tr><td>KDE</td><td>Kernel density estimation</td></tr><tr><td>KL</td><td>Kullback Leibler divergence</td></tr><tr><td>KNN</td><td>K nearest neighbor</td></tr><tr><td>LHS</td><td>Left hand side (of an equation)</td></tr><tr><td>LSTM</td><td>Long short term memory (a kind of RNN)</td></tr><tr><td>LVM</td><td>Latent variable model</td></tr><tr><td>MAP</td><td>Maximum A Posterior estimate</td></tr><tr><td>MCMC</td><td>Markov chain Monte Carlo</td></tr><tr><td>MLE</td><td>Maximum likelihood estimate</td></tr><tr><td>MLP</td><td>Multilayer perceptron</td></tr><tr><td>MSE</td><td>Mean squared error</td></tr><tr><td>NLL</td><td>Negative log likelihood</td></tr><tr><td>OLS</td><td>Ordinary least squares</td></tr><tr><td>psd</td><td>Positive definite (matrix)</td></tr><tr><td>pdf</td><td>Probability density function</td></tr><tr><td>pmf</td><td>Probability mass function</td></tr><tr><td>PNLL</td><td>Penalized NLL</td></tr><tr><td>PGM</td><td>Probabilistic graphical model</td></tr><tr><td>RNN</td><td>Recurrent neural network</td></tr><tr><td>RHS</td><td>Right hand side (of an equation)</td></tr><tr><td>RSS</td><td>Residual sum of squares</td></tr></table></body></html>
